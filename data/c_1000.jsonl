{"lang": "c", "code": "#import <TradPlusAds/MSBannerCustomEvent.h>\n\n\n@interface StartAppBannerCustomEvent : MSBannerCustomEvent\n\n@end\n\n", "comment_ratio": 0.38461538461538464}
{"lang": "c", "code": "#import \"NSView.h\"\n\n#import \"NSCollectionViewSectionHeaderView.h\"\n#import \"NSCollectionViewSectionHeaderViewPrivate.h\"\n\n@class NSButton, NSString;\n\n@interface FIIconHeaderView : NSView <NSCollectionViewSectionHeaderView, NSCollectionViewSectionHeaderViewPrivate>\n{\n    struct TNSRef<FI_TIconCollectionGroupHeaderView, void> _headerView;\n}\n\n- (id).cxx_construct;\n- (void).cxx_destruct;\n- (BOOL)accessibilityIsIgnored;\n- (void)setCollapseButtonPressedBlock:(CDUnknownBlockType)arg1;\n@property __weak NSButton *sectionCollapseButton;\n@property(getter=isFloating) BOOL floating; // @dynamic floating;\n@property(getter=isCollapseButtonHiddenManually) BOOL collapseButtonHiddenManually;\n@property(getter=isCollapseButtonHidden) BOOL collapseButtonHidden; // @dynamic collapseButtonHidden;\n@property(getter=isCollapsed) BOOL collapsed; // @dynamic collapsed;\n@property unsigned long long itemCount; // @dynamic itemCount;\n@property(copy) NSString *titleStr; // @dynamic titleStr;\n- (BOOL)wantsUpdateLayer;\n- (BOOL)isFlipped;\n- (void)initCommon;\n- (id)initWithFrame:(struct CGRect)arg1;\n- (id)initWithCoder:(id)arg1;\n\n// Remaining properties\n@property(readonly, copy) NSString *debugDescription;\n@property(readonly, copy) NSString *description;\n@property(readonly) unsigned long long hash;\n@property(copy) NSString *identifier;\n@property(readonly) Class superclass;\n\n@end\n\n\n", "comment_ratio": 0.24444444444444444}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface XLUndoOrderViewController : UIViewController\n\n@end\n\nNS_ASSUME_NONNULL_END\n\n", "comment_ratio": 0.3888888888888889}
{"lang": "c", "code": "#pragma once\n#include \"Common.h\"\n#include \"CutPursuit.h\"\n\nnamespace CP {\ntemplate <typename T>\nclass CutPursuit_KL : public CutPursuit<T>\n{\n    public:\n    ~CutPursuit_KL(){\n    };      \n    virtual std::pair<T,T> compute_energy() override\n    {\n        VertexAttributeMap<T> vertex_attribute_map\n                = boost::get(boost::vertex_bundle, this->main_graph);\n        EdgeAttributeMap<T> edge_attribute_map\n                = boost::get(boost::edge_bundle, this->main_graph);\n        std::pair<T,T> pair_energy;\n        T energy = 0, smoothedObservation, smoothedValue;\n        //#pragma omp parallel if (this->parameter.parallel)\n        for (VertexIterator<T> i_ver = boost::vertices(this->main_graph).first;\n                     i_ver != this->lastIterator; ++i_ver)\n        {\n            for(uint32_t  i_dim=0; i_dim<this->dim; i_dim++)\n            { //smoothing as a linear combination with the uniform probability\n            smoothedObservation =\n            \tthis->parameter.smoothing / this->dim\n                + (1 - this->parameter.smoothing)\n                * vertex_attribute_map(*i_ver).observation[i_dim];\n            smoothedValue =\n            \tthis->parameter.smoothing / this->dim\n                + (1 - this->parameter.smoothing)\n                * vertex_attribute_map(*i_ver).value[i_dim];\n            energy += smoothedObservation\n                * (log(smoothedObservation) - log(smoothedValue))\n                * vertex_attribute_map(*i_ver).weight;\n            }\n        }\n        pair_energy.first = energy;\n        energy = 0;\n        EdgeIterator<T> i_edg_end =  boost::edges(this->main_graph).second;\n       for (EdgeIterator<T> i_edg = boost::edges(this->main_graph).first;\n                     i_edg != i_edg_end; ++i_edg)\n       {\n            if (!edge_attribute_map(*i_edg).realEdge)\n            {\n                continue;\n            }\n            energy += .5 * edge_attribute_map(*i_edg).isActive * this->parameter.reg_strenth\n                    * edge_attribute_map(*i_edg).weight;\n        }\n        pair_energy.second = energy;\n        return pair_energy;\n    }\n    //=============================================================================================\n    //=============================        SPLIT        ===========================================\n    //=============================================================================================\n    virtual uint32_t  split() override\n    { // split the graph by trying to find the best binary partition\n      // each components is split into B and notB\n      // for each components we associate the value h_1 and h_2 to vertices in B or notB\n      // the affectation as well as h_1 and h_2 are computed alternatively\n      //tic();\n      //--------loading structures---------------------------------------------------------------\n        TimeStack ts; ts.tic();\n        uint32_t  nb_comp = this->components.size();\n        VertexAttributeMap<T> vertex_attribute_map\n                   = boost::get(boost::vertex_bundle, this->main_graph);\n        VertexIndexMap<T> vertex_index_map = boost::get(boost::vertex_index, this->main_graph);\n        uint32_t  saturation;\n        //initialize h_1 and h_2 with kmeans\n        //stores wether each vertex is B or notB\n        std::vector<bool> binary_label(this->nVertex);\n        this->init_labels(binary_label);\n        VectorOfCentroids<T> centers(nb_comp, this->dim);\n        //-----main loop----------------------------------------------------------------\n                // the optimal flow is iteratively approximated\n        for (uint32_t  i_step = 1; i_step <= this->parameter.flow_steps; i_step++)\n        {\n            //compute h_1 and h_2\n            centers = VectorOfCentroids<T>(nb_comp, this->dim);\n            this->compute_centers(centers, binary_label);\n            // update the capacities of the flow graph\n            this->set_capacities(centers);\n            //compute flow\n            boost::boykov_kolmogorov_max_flow(\n                       this->main_graph,\n                       get(&EdgeAttribute<T>::capacity        , this->main_graph),\n                       get(&EdgeAttribute<T>::residualCapacity, this->main_graph),\n                       get(&EdgeAttribute<T>::edge_reverse     , this->main_graph),\n                       get(&VertexAttribute<T>::color         , this->main_graph),\n                       get(boost::vertex_index                , this->main_graph),\n                       this->source,\n                       this->sink);\n            for (uint32_t  i_com = 0; i_com < nb_comp; i_com++)\n            {\n                if (this->saturated_components[i_com])\n                {\n                    continue;\n                }\n                for (uint32_t  i_ver = 0;  i_ver < this->components[i_com].size(); i_ver++)\n                {\n                    binary_label[vertex_index_map(this->components[i_com][i_ver])]\n                          = (vertex_attribute_map(this->components[i_com][i_ver]).color\n                          == vertex_attribute_map(this->sink).color);\n                 }\n             }\n        }\n        saturation = this->activate_edges();\n        return saturation;\n    }\n    //=============================================================================================\n    //=============================    INIT_KL  ===================================================\n    //=============================================================================================\n    inline void init_labels(std::vector<bool> & binary_label)\n    { //-----initialize the labelling for each components with kmeans------------------------------\n        VertexAttributeMap<T> vertex_attribute_map\n                = boost::get(boost::vertex_bundle, this->main_graph);\n        VertexIndexMap<T> vertex_index_map = boost::get(boost::vertex_index, this->main_graph);\n        std::vector< std::vector<T> > kernels(2, std::vector<T>(this->dim));\n        std::vector< std::vector<T> > smooth_kernels(2, std::vector<T>(this->dim));\n        T total_weight[2];\n        uint32_t  nb_comp = this->components.size();\n        T best_energy, current_energy;\n        //#pragma omp parallel for private(kernels, total_weight, best_energy, current_energy) if (this->parameter.parallel && nb_comp>8) schedule(dynamic)\n        for (uint32_t  i_com = 0; i_com < nb_comp; i_com++)\n        {\n            uint32_t  comp_size = this->components[i_com].size();\n            std::vector<bool> potential_label(comp_size);    \n            std::vector<T> energy_array(comp_size);\n            std::vector<T> constant_part(comp_size);\n            std::vector< std::vector<T> > smooth_obs(comp_size, std::vector<T>(2,0));\n            if (this->saturated_components[i_com] || comp_size <= 1)\n            {\n                continue;\n            }\n            //KL fidelity has a part that depends\n            //purely on the observation that can be precomputed\n            //#pragma omp parallel for if (this->parameter.parallel && nb_comp<=8) schedule(dynamic)\n            for (uint32_t  i_ver = 0;  i_ver < comp_size; i_ver++)\n            {\n                constant_part[i_ver] = 0;\n                for(uint32_t  i_dim=0; i_dim < this->dim; i_dim++)\n                {\n                    smooth_obs[i_ver][i_dim] = 0;\n                }\n                for(uint32_t  i_dim=0; i_dim < this->dim; i_dim++)\n                {\n                    smooth_obs[i_ver][i_dim] =\n                        this->parameter.smoothing / this->dim\n                        + (1 - this->parameter.smoothing)\n                        * vertex_attribute_map(this->components[i_com][i_ver]).observation[i_dim];\n                    constant_part[i_ver] += smooth_obs[i_ver][i_dim]\n                           * log(smooth_obs[i_ver][i_dim]) \n                           * vertex_attribute_map(this->components[i_com][i_ver]).weight;\n                 }\n            }\n            for (uint32_t  init_kmeans = 0; init_kmeans < this->parameter.kmeans_resampling; init_kmeans++)\n            {\n                //----- initialization with KM++ ------------------\n                // first kernel chosen randomly\n                uint32_t  first_kernel  = std::rand() % comp_size, second_kernel = 0;\n                for(uint32_t  i_dim=0; i_dim < this->dim; i_dim++)\n                {   //fill the first kernel\n                    kernels[0][i_dim] = vertex_attribute_map(this->components[i_com][first_kernel ]).observation[i_dim];\n                    smooth_kernels[0][i_dim] =  this->parameter.smoothing\n                        / this->dim + (1 - this->parameter.smoothing)\n                        * kernels[0][i_dim];\n                }\n                //now compute the square distance of each pouint32_t to this kernel\n                best_energy = 0; //energy total\n                //#pragma omp parallel for if (this->parameter.parallel && nb_comp<=8) schedule(dynamic)\n                for (uint32_t  i_ver = 0;  i_ver < comp_size; i_ver++)\n                {\n                    energy_array[i_ver] = constant_part[i_ver];\n                    for(uint32_t  i_dim=0; i_dim < this->dim; i_dim++)\n                    {\n                         energy_array[i_ver] -=\n                            smooth_obs[i_ver][i_dim]\n                            * log(smooth_kernels[0][i_dim])\n                            * vertex_attribute_map(this->components[i_com][i_ver]).weight;\n                    }\n                    energy_array[i_ver] = pow(energy_array[i_ver],2);\n                    best_energy += energy_array[i_ver];\n                } // we now generate a random number to determinate which node will be the second kernel\n                if (best_energy==0)\n                { //all the points in this components are identical\n                    for (uint32_t  i_ver = 0;  i_ver < comp_size; i_ver++)\n                    {\n                        binary_label[vertex_index_map(this->components[i_com][i_ver])] = false;\n                    }\n                   break;\n                }\n                //we now choose the second kernel with a probability\n                //proportional to the square distance\n                T random_sample = ((T)(rand())) / ((T)(RAND_MAX));\n                current_energy = best_energy * random_sample;\n                for (uint32_t  i_ver = 0;  i_ver < comp_size; i_ver++)\n                {\n                    current_energy -= energy_array[i_ver];\n                    if (current_energy < 0)\n                    { //we have selected the second kernel\n                        second_kernel = i_ver;\n                        break;\n                    }\n                }\n                for(uint32_t  i_dim=0; i_dim < this->dim; i_dim++)\n                { // now fill the second kernel\n                   kernels[1][i_dim] = vertex_attribute_map(this->components[i_com][second_kernel]).observation[i_dim];\n                   smooth_kernels[1][i_dim] =  this->parameter.smoothing\n                            / this->dim + (1 - this->parameter.smoothing)\n                            * kernels[1][i_dim];\n                }\n                //----main kmeans loop-----\n                for (uint32_t  ite_kmeans = 0; ite_kmeans < this->parameter.kmeans_ite; ite_kmeans++)\n                {\n                    //--affectation step: associate each node with its closest kernel-------------------\n                    //#pragma omp parallel for if (this->parameter.parallel && nb_comp<=8) schedule(dynamic)\n                    for (uint32_t  i_ver = 0;  i_ver < comp_size; i_ver++)\n                    {\n                        //the distance to each kernel\n                        std::vector<T> distance_kernels(2, constant_part[i_ver]);\n                        for(uint32_t  i_dim=0; i_dim < this->dim; i_dim++)\n                        {\n                            distance_kernels[0] -= smooth_obs[i_ver][i_dim]\n                                * log(smooth_kernels[0][i_dim])\n                                * vertex_attribute_map(this->components[i_com][i_ver]).weight;\n                            distance_kernels[1] -= smooth_obs[i_ver][i_dim]\n                                * log(smooth_kernels[1][i_dim])\n                                * vertex_attribute_map(this->components[i_com][i_ver]).weight;\n                        }\n                        potential_label[i_ver] = distance_kernels[0] > distance_kernels[1];\n                    }\n                    //-----computation of the new kernels----------------------------\n                    total_weight[0] = 0.;\n                    total_weight[1] = 0.;\n                    for(uint32_t  i_dim=0; i_dim < this->dim; i_dim++)\n                    {\n                       kernels[0][i_dim] = 0;\n                       kernels[1][i_dim] = 0;\n                    }\n                    for (uint32_t  i_ver = 0;  i_ver < comp_size; i_ver++)\n                    {\n                        if (vertex_attribute_map(this->components[i_com][i_ver]).weight==0)\n                        {\n                            continue;\n                        }\n                        if (potential_label[i_ver])\n                        {\n                            total_weight[0] += vertex_attribute_map(this->components[i_com][i_ver]).weight;\n                            for(uint32_t  i_dim=0; i_dim < this->dim; i_dim++)\n                            {\n                                kernels[0][i_dim] += \n                                    vertex_attribute_map(this->components[i_com][i_ver]).observation[i_dim]\n                                    * vertex_attribute_map(this->components[i_com][i_ver]).weight ;\n                             }\n                         }\n                         else\n                         {\n                            total_weight[1] += vertex_attribute_map(this->components[i_com][i_ver]).weight;\n                            for(uint32_t  i_dim=0; i_dim < this->dim; i_dim++)\n                            {\n                                kernels[1][i_dim] += \n                                    vertex_attribute_map(this->components[i_com][i_ver]).observation[i_dim]\n                                    * vertex_attribute_map(this->components[i_com][i_ver]).weight;\n                            }\n                         }\n                    }\n                    if ((total_weight[0] == 0)||(total_weight[1] == 0))\n                    {\n                        std::cout << \"kmeans error\" << std::endl;\n                    }\n                    for(uint32_t  i_dim=0; i_dim < this->dim; i_dim++)\n                    {\n                        kernels[0][i_dim] = kernels[0][i_dim] / total_weight[0];\n                        kernels[1][i_dim] = kernels[1][i_dim] / total_weight[1];\n                        smooth_kernels[0][i_dim] =  this->parameter.smoothing\n                            / this->dim + (1 - this->parameter.smoothing)\n                            * kernels[0][i_dim];\n                        smooth_kernels[1][i_dim] =  this->parameter.smoothing\n                            / this->dim + (1 - this->parameter.smoothing)\n                            * kernels[1][i_dim];\n                    }\n                }\n                //----compute the associated energy ------\n                current_energy = 0;\n                for (uint32_t  i_ver = 0;  i_ver < comp_size; i_ver++)\n                {\n                    current_energy += constant_part[i_ver];\n                    if (potential_label[i_ver])\n                    {\n                        for(uint32_t  i_dim=0; i_dim < this->dim; i_dim++)\n                        {\n                            current_energy -= smooth_obs[i_ver][i_dim]\n                                 * log(smooth_kernels[0][i_dim])\n                                 * vertex_attribute_map(this->components[i_com][i_ver]).weight;\n                        }\n                    }\n                    else\n                    {\n                        for(uint32_t  i_dim=0; i_dim < this->dim; i_dim++)\n                        {\n                            current_energy -= smooth_obs[i_ver][i_dim]\n                                 * log(smooth_kernels[1][i_dim])\n                                 * vertex_attribute_map(this->components[i_com][i_ver]).weight;\n                        }\n                    }\n                }\n                if (current_energy < best_energy)\n                {\n                    best_energy = current_energy;\n                    for (uint32_t  i_ver = 0;  i_ver < comp_size; i_ver++)\n                    {\n                        binary_label[vertex_index_map(this->components[i_com][i_ver])] = potential_label[i_ver];\n                    }\n                }\n            }\n        }\n     }\n    //=============================================================================================\n    //=============================  COMPUTE_CENTERS_KL  ==========================================\n    //=============================================================================================\n    inline void compute_centers(VectorOfCentroids<T> & centers, const std::vector<bool> & binary_label)\n    {\n        //compute for each component the values of h_1 and h_2\n        VertexAttributeMap<T> vertex_attribute_map\n                = boost::get(boost::vertex_bundle, this->main_graph);\n        VertexIndexMap<T> vertex_index_map = boost::get(boost::vertex_index, this->main_graph);\n        uint32_t  nb_comp = this->components.size();\n        //#pragma omp parallel for if (this->parameter.parallel) schedule(dynamic)\n        for (uint32_t  i_com = 0; i_com < nb_comp; i_com++)\n        {\n            if (this->saturated_components[i_com])\n            {\n                continue;\n            }\n            T total_weight[2];\n            total_weight[0] = 0.;\n            total_weight[1] = 0.;\n            for(uint32_t  i_dim=0; i_dim < this->dim; i_dim++)\n            {\n                centers.centroids[i_com][0][i_dim] = 0.;\n                centers.centroids[i_com][1][i_dim] = 0.;\n            }\n            for (uint32_t  i_ver = 0;  i_ver < this->components[i_com].size(); i_ver++)\n            {\n                if (vertex_attribute_map(this->components[i_com][i_ver]).weight==0)\n                {\n                    continue;\n                }\n                if (binary_label[vertex_index_map(this->components[i_com][i_ver])])\n                {\n                    total_weight[0] += vertex_attribute_map(this->components[i_com][i_ver]).weight;\n                    for(uint32_t  i_dim=0; i_dim < this->dim; i_dim++)\n                    {\n                       centers.centroids[i_com][0][i_dim] += vertex_attribute_map(this->components[i_com][i_ver]).observation[i_dim]\n                                                * vertex_attribute_map(this->components[i_com][i_ver]).weight ;\n                    }\n                }\n                else\n                {\n                   total_weight[1] += vertex_attribute_map(this->components[i_com][i_ver]).weight;\n                   for(uint32_t  i_dim=0; i_dim < this->dim; i_dim++)\n                   {\n                      centers.centroids[i_com][1][i_dim] += vertex_attribute_map(this->components[i_com][i_ver]).observation[i_dim]\n                                               * vertex_attribute_map(this->components[i_com][i_ver]).weight;\n                   }\n                }\n            }\n            if ((total_weight[0] == 0)||(total_weight[1] == 0))\n            {\n                //the component is saturated\n                this->saturateComponent(i_com);\n                for(uint32_t  i_dim=0; i_dim < this->dim; i_dim++)\n                {\n                    centers.centroids[i_com][0][i_dim] = vertex_attribute_map(this->components[i_com].back()).value[i_dim];\n                    centers.centroids[i_com][1][i_dim] = vertex_attribute_map(this->components[i_com].back()).value[i_dim];\n                }\n            }\n            else\n            {\n                for(uint32_t  i_dim=0; i_dim < this->dim; i_dim++)\n                {\n                    centers.centroids[i_com][0][i_dim] = centers.centroids[i_com][0][i_dim] / total_weight[0];\n                    centers.centroids[i_com][1][i_dim] = centers.centroids[i_com][1][i_dim] / total_weight[1];\n                }\n            }\n        }\n        return;\n    }\n    //=============================================================================================\n    //=============================   SET_CAPACITIES     ==========================================\n    //=============================================================================================\n    inline void set_capacities(const VectorOfCentroids<T> & centers)\n    {\n        VertexAttributeMap<T> vertex_attribute_map\n                = boost::get(boost::vertex_bundle, this->main_graph);\n        EdgeAttributeMap<T> edge_attribute_map\n                = boost::get(boost::edge_bundle, this->main_graph);\n        VertexDescriptor<T> desc_v;\n        EdgeDescriptor   desc_source2v, desc_v2sink, desc_v2source;\n        uint32_t  nb_comp = this->components.size();\n        T cost_B, cost_notB, smoothedValueB, smoothedValueNotB, smoothedObservation; //the cost of being in B or not B, local for each component\n        //----first compute the capacity in sink/node edges------------------------------------\n        //#pragma omp parallel for if (this->parameter.parallel) schedule(dynamic)\n        for (uint32_t  i_com = 0; i_com < nb_comp; i_com++)\n        {\n            if (this->saturated_components[i_com])\n            {\n                continue;\n            }\n            for (uint32_t  i_ver = 0;  i_ver < this->components[i_com].size(); i_ver++)\n            {\n                desc_v    = this->components[i_com][i_ver];\n                // because of the adjacency structure NEVER access edge (source,v) directly!\n                desc_v2source = boost::edge(desc_v, this->source,this->main_graph).first;\n                desc_source2v = edge_attribute_map(desc_v2source).edge_reverse; //use edge_reverse instead\n                desc_v2sink   = boost::edge(desc_v, this->sink,this->main_graph).first;\n                cost_B    = 0;\n                cost_notB = 0;\n                if (vertex_attribute_map(desc_v).weight==0)\n                {\n                    edge_attribute_map(desc_source2v).capacity = 0;\n                    edge_attribute_map(desc_v2sink).capacity   = 0;\n                    continue;\n                }\n                for(uint32_t  i_dim=0; i_dim < this->dim; i_dim++)\n                {\n                    smoothedObservation =\n                             this->parameter.smoothing / this->dim\n                           + (1 - this->parameter.smoothing)\n                           * vertex_attribute_map(desc_v).observation[i_dim];\n                    smoothedValueB =\n                             this->parameter.smoothing / this->dim\n                           + (1 - this->parameter.smoothing)\n                           *  centers.centroids[i_com][0][i_dim];\n                    smoothedValueNotB =\n                             this->parameter.smoothing / this->dim\n                           + (1 - this->parameter.smoothing)\n                           *  centers.centroids[i_com][1][i_dim];\n                    cost_B    += smoothedObservation\n                              * (log(smoothedObservation)\n                              -  log(smoothedValueB));\n                    cost_notB += smoothedObservation\n                              * (log(smoothedObservation)\n                              -  log(smoothedValueNotB));\n                }\n                if (cost_B>cost_notB)\n                {\n                    edge_attribute_map(desc_source2v).capacity = cost_B - cost_notB;\n                    edge_attribute_map(desc_v2sink).capacity   = 0.;\n                }\n                else\n                {\n                    edge_attribute_map(desc_source2v).capacity = 0.;\n                    edge_attribute_map(desc_v2sink).capacity   = cost_notB - cost_B;\n                }\n            }\n        }\n        //----then set the vertex to vertex edges ---------------------------------------------\n        EdgeIterator<T> i_edg, i_edg_end;\n        for (boost::tie(i_edg, i_edg_end) = boost::edges(this->main_graph);\n             i_edg != i_edg_end; ++i_edg)\n        {\n            if (!edge_attribute_map(*i_edg).realEdge)\n            {\n                continue;\n            }\n            if (!edge_attribute_map(*i_edg).isActive)\n            {\n                edge_attribute_map(*i_edg).capacity\n                        = edge_attribute_map(*i_edg).weight * this->parameter.reg_strenth;\n            }\n            else\n            {\n                edge_attribute_map(*i_edg).capacity = 0;\n            }\n        }\n    }\n    //=============================================================================================\n    //=================================   COMPUTE_VALUE   =========================================\n    //=============================================================================================\n    virtual std::pair<std::vector<T>, T> compute_value(const uint32_t  & i_com) override\n    {\n        VertexAttributeMap<T> vertex_attribute_map\n                                    = boost::get(boost::vertex_bundle, this->main_graph);\n        T total_weight = 0;\n        std::vector<T> compValue(this->dim);\n        std::fill((compValue.begin()),(compValue.end()),0);\n        for (uint32_t  ind_ver = 0; ind_ver < this->components[i_com].size(); ++ind_ver)\n        {\n            total_weight += vertex_attribute_map(this->components[i_com][ind_ver]).weight;\n            for(uint32_t  i_dim=0; i_dim<this->dim; i_dim++)\n            {\n                compValue[i_dim] += vertex_attribute_map(this->components[i_com][ind_ver]).observation[i_dim]\n                    * vertex_attribute_map(this->components[i_com][ind_ver]).weight;\n            }\n            vertex_attribute_map(this->components[i_com][ind_ver]).in_component = i_com;\n        }\n        for(uint32_t  i_dim=0; i_dim<this->dim; i_dim++)\n        {\n           compValue[i_dim] = compValue[i_dim] / total_weight;\n        }\n        for (uint32_t  ind_ver = 0; ind_ver < this->components[i_com].size(); ++ind_ver)\n        {\n            for(uint32_t  i_dim=0; i_dim<this->dim; i_dim++)\n            {\n                vertex_attribute_map(this->components[i_com][ind_ver]).value[i_dim] = compValue[i_dim];\n            }\n        }\n        return std::pair<std::vector<T>, T>(compValue, total_weight);\n    }\n    //=============================================================================================\n    //=================================   COMPUTE_MERGE_GAIN   =========================================\n    //=============================================================================================\n    virtual std::pair<std::vector<T>, T> compute_merge_gain(const VertexDescriptor<T> & comp1\n                                             , const VertexDescriptor<T> & comp2) override\n    {\n        VertexAttributeMap<T> reduced_vertex_attribute_map\n                = boost::get(boost::vertex_bundle, this->reduced_graph);\n        std::vector<T> merge_value(this->dim);\n        T gain = 0, smoothedValue1, smoothedValue2, smoothedValueMerged;\n        // compute the value obtained by mergeing the two connected components\n        for(uint32_t  i_dim=0; i_dim<this->dim; i_dim++)\n        {\n            merge_value[i_dim] =\n                    (reduced_vertex_attribute_map(comp1).weight *\n                     reduced_vertex_attribute_map(comp1).value[i_dim]\n                    +reduced_vertex_attribute_map(comp2).weight *\n                     reduced_vertex_attribute_map(comp2).value[i_dim])\n                   /(reduced_vertex_attribute_map(comp1).weight\n                    +reduced_vertex_attribute_map(comp2).weight);\n            smoothedValue1 =\n                     this->parameter.smoothing / this->dim\n                   + (1 - this->parameter.smoothing)\n                   * reduced_vertex_attribute_map(comp1).value[i_dim];\n            smoothedValue2 =\n                     this->parameter.smoothing / this->dim\n                   + (1 - this->parameter.smoothing)\n                   * reduced_vertex_attribute_map(comp2).value[i_dim];\n            smoothedValueMerged =\n                    this->parameter.smoothing / this->dim\n                  + (1 - this->parameter.smoothing)\n                  * merge_value[i_dim];\n            gain -= reduced_vertex_attribute_map(comp1).weight\n                  * smoothedValue1 * (log(smoothedValue1)\n                  - log(smoothedValueMerged))\n                  + reduced_vertex_attribute_map(comp2).weight\n                    * smoothedValue2 * (log(smoothedValue2)\n                    - log(smoothedValueMerged));\n        }\n        return std::pair<std::vector<T>, T>(merge_value, gain);\n    }\n};\n}\n\n", "comment_ratio": 0.11870503597122302}
{"lang": "c", "code": "#ifndef C0P_PARAM_OBJECTS_SURFER__US_1O0__SURFTIMECONST_10O0__REORIENTATIONTIME_2O5_GROUP_HOMOGENEOUS_MEMBER_AGENT_ACTIVE_CHOICE_H\n#define C0P_PARAM_OBJECTS_SURFER__US_1O0__SURFTIMECONST_10O0__REORIENTATIONTIME_2O5_GROUP_HOMOGENEOUS_MEMBER_AGENT_ACTIVE_CHOICE_H\n#pragma once\n\n// THIS FILE SHOULD NOT BE EDITED DIRECTLY BY THE USERS.\n// THIS FILE WILL BE AUTOMATICALLY EDITED WHEN THE\n// CHOOSE COMMAND IS USED\n\n#include \"param/env/objects/surfer__us_1o0__surftimeconst_10o0__reorientationtime_2o5/group/homogeneous/_member/agent/_active/_passive/choice.h\"\n// choose your object\n#include \"param/env/objects/surfer__us_1o0__surftimeconst_10o0__reorientationtime_2o5/group/homogeneous/_member/agent/_active/local_axis_swimmer/parameters.h\"\n#include \"core/env/objects/object/active/local_axis_swimmer/core.h\"\nnamespace c0p {\n    using SurferUs1O0Surftimeconst10O0Reorientationtime2O5GroupHomogeneousMemberAgentActiveStep = ActiveLocalAxisSwimmerStep<SurferUs1O0Surftimeconst10O0Reorientationtime2O5GroupHomogeneousMemberAgentActiveLocalAxisSwimmerStepParameters, SurferUs1O0Surftimeconst10O0Reorientationtime2O5GroupHomogeneousMemberAgentActivePassiveStep>;\n}\n\n#endif\n\n", "comment_ratio": 0.2222222222222222}
{"lang": "c", "code": "#include <stdint.h>\n#include <stddef.h>\n#include <avr/pgmspace.h>\n#include \"../../../lib/data-types/misc.h\"\n#include \"../../../lib/usb/usage-page/keyboard--short-names.h\"\n#include \"../../../lib/key-functions/public.h\"\n#include \"../matrix.h\"\n#include \"../layout.h\"\n\n#define FREE 0 \n\n// basic\n#define  kprrel  &kbfun_press_release\n#define  ktog    &kbfun_toggle\n#define  ktrans  &kbfun_transparent\n#define  lpush1   &kbfun_layer_push_1\n#define  lpop1    &kbfun_layer_pop_1\n// device\n#define  dbtldr  &kbfun_jump_to_bootloader\n// special\n#define  sshprre  &kbfun_shift_press_release\n#define  s2kcap   &kbfun_2_keys_capslock_press_release\n#define  slpunum  &kbfun_layer_push_numpad\n#define  slponum  &kbfun_layer_pop_numpad\n\n// Key values\n///////\nconst uint8_t PROGMEM _kb_layout[KB_LAYERS][KB_ROWS][KB_COLUMNS] = {\n\tKB_MATRIX_LAYER(  // layout: layer 0: default\n// unused\n0,\n// left hand\n    _grave,               _1,    _2,    _3,     _4,    _5,    FREE,\n      _tab,               _Q,    _W,    _E,     _R,    _T,    1,\n      _esc,               _A,    _S,    _D,     _F,    _G,\n   _shiftL,               _Z,    _X,    _C,     _V,    _B,    FREE,\n    _ctrlL, _backslash_nonUS, _altL, _dash, _equal,\n                                                  _del, _pageU,\n                                                  0, 0, _pageD,\n                                           _space, _bs,  _guiL,\n// right hand\n     FREE, _6,      _7,      _8,      _9,           _0,      FREE,\n_bracketL, _Y,      _U,      _I,      _O,           _P,      FREE,\n           _H,      _J,      _K,      _L,   _semicolon,    _quote,\n     FREE, _N,      _M,  _comma, _period,       _slash,   _shiftR,\n             _bracketL, _bracketR, _altR, _pound_nonUS,    _ctrlR,\n_pageU, _insert,\n_pageD,       0, 0,\n _guiR,  _enter, _space ),\n\n\n\tKB_MATRIX_LAYER(  // layout: layer 1: function and symbol keys\n// unused\n0,\n// left hand\n  FREE,     _F1,     _F2,     _F3,  _F4,  _F5, _F11,\n  FREE,    FREE, _arrowU,    FREE, FREE, FREE,    1,\n  _esc, _arrowL, _arrowD, _arrowR, FREE, FREE,\n  FREE,    FREE,    FREE,    FREE, FREE, FREE, FREE,\n  FREE,    FREE,    FREE,    FREE, FREE,\n                                        FREE,  _pageU,\n                                       0,  0,  _pageD,\n                               _space,  FREE,  FREE,\n// right hand\n_F12,     _F6,     _F7,     _F8,     _F9, _F10, FREE,\nFREE,    FREE,    FREE,    FREE,    FREE, FREE, FREE,\n      _arrowL, _arrowD, _arrowU, _arrowR, FREE, FREE,\nFREE,    FREE,    FREE,    FREE,    FREE, FREE, FREE,\n                  FREE,    FREE,    FREE, FREE, FREE,\nFREE,  FREE,\nFREE,  0,  0,\nFREE,  _enter,  _space )\n};\n\n// Functions for keypress\n///////\nconst void_funptr_t PROGMEM _kb_layout_press[KB_LAYERS][KB_ROWS][KB_COLUMNS] = {\n\tKB_MATRIX_LAYER(  // press: layer 0: default\n// unused\nNULL,\n// left hand\n kprrel, kprrel, kprrel, kprrel, kprrel, kprrel, NULL,\n kprrel, kprrel, kprrel, kprrel, kprrel, kprrel, lpush1,\n kprrel, kprrel, kprrel, kprrel, kprrel, kprrel,\n s2kcap, kprrel, kprrel, kprrel, kprrel, kprrel, NULL,\n kprrel, kprrel, kprrel, kprrel, kprrel,\n                                                 kprrel, kprrel,\n                                           NULL,   NULL, kprrel,\n                                         kprrel, kprrel, kprrel,\n// right hand\n           NULL, kprrel, kprrel, kprrel, kprrel, kprrel, kprrel,\n         kprrel, kprrel, kprrel, kprrel, kprrel, kprrel, kprrel,\n                 kprrel, kprrel, kprrel, kprrel, kprrel, kprrel,\n         NULL,   kprrel, kprrel, kprrel, kprrel, kprrel, s2kcap,\n                         kprrel, kprrel, kprrel, kprrel, kprrel,\n kprrel, kprrel,\n kprrel,   NULL,   NULL,\n kprrel, kprrel, kprrel ),\n\n\n\tKB_MATRIX_LAYER(  // press: layer 1: function and symbol keys\n// unused\nNULL,\n// left hand\n   NULL, kprrel, kprrel, kprrel, kprrel, kprrel, kprrel,\n kprrel, kprrel, kprrel, kprrel, kprrel,   NULL,  lpop1,\n kprrel, kprrel, kprrel, kprrel, kprrel, kprrel,\n kprrel, kprrel, kprrel, kprrel, kprrel, kprrel, kprrel,\n kprrel, kprrel, kprrel, kprrel, kprrel,\n                                                 kprrel, kprrel,\n                                         kprrel, kprrel, kprrel,\n                                         kprrel, kprrel, kprrel,\n// right hand\n        kprrel, kprrel, kprrel, kprrel, kprrel, kprrel, kprrel,\n        kprrel,   NULL, kprrel, kprrel, kprrel, kprrel, kprrel,\n                kprrel, kprrel, kprrel, kprrel, kprrel, kprrel,\n        kprrel, kprrel, kprrel, kprrel, kprrel, kprrel, kprrel,\n                        kprrel, kprrel, kprrel, kprrel, kprrel,\n kprrel, kprrel,\n kprrel, kprrel, kprrel,\n kprrel, kprrel, kprrel )\n};\n\n// Functions for key release\n///////\nconst void_funptr_t PROGMEM _kb_layout_release[KB_LAYERS][KB_ROWS][KB_COLUMNS] = {\n\tKB_MATRIX_LAYER(  // press: layer 0: default\n// unused\nNULL,\n// left hand\n kprrel, kprrel, kprrel, kprrel, kprrel, kprrel, NULL,\n kprrel, kprrel, kprrel, kprrel, kprrel, kprrel, lpush1,\n kprrel, kprrel, kprrel, kprrel, kprrel, kprrel,\n s2kcap, kprrel, kprrel, kprrel, kprrel, kprrel, NULL,\n kprrel, kprrel, kprrel, kprrel, kprrel,\n                                                 kprrel, kprrel,\n                                           NULL,   NULL, kprrel,\n                                         kprrel, kprrel, kprrel,\n// right hand\n           NULL, kprrel, kprrel, kprrel, kprrel, kprrel, kprrel,\n         kprrel, kprrel, kprrel, kprrel, kprrel, kprrel, kprrel,\n                 kprrel, kprrel, kprrel, kprrel, kprrel, kprrel,\n         NULL,   kprrel, kprrel, kprrel, kprrel, kprrel, s2kcap,\n                         kprrel, kprrel, kprrel, kprrel, kprrel,\n kprrel, kprrel,\n kprrel,   NULL,   NULL,\n kprrel, kprrel, kprrel ),\n\n\n\tKB_MATRIX_LAYER(  // press: layer 1: function and symbol keys\n// unused\nNULL,\n// left hand\n   NULL, kprrel, kprrel, kprrel, kprrel, kprrel, kprrel,\n kprrel, kprrel, kprrel, kprrel, kprrel,   NULL,  lpop1,\n kprrel, kprrel, kprrel, kprrel, kprrel, kprrel,\n kprrel, kprrel, kprrel, kprrel, kprrel, kprrel, kprrel,\n kprrel, kprrel, kprrel, kprrel, kprrel,\n                                                 kprrel, kprrel,\n                                         kprrel, kprrel, kprrel,\n                                         kprrel, kprrel, kprrel,\n// right hand\n        kprrel, kprrel, kprrel, kprrel, kprrel, kprrel, kprrel,\n        kprrel,   NULL, kprrel, kprrel, kprrel, kprrel, kprrel,\n                kprrel, kprrel, kprrel, kprrel, kprrel, kprrel,\n        kprrel, kprrel, kprrel, kprrel, kprrel, kprrel, kprrel,\n                        kprrel, kprrel, kprrel, kprrel, kprrel,\n kprrel, kprrel,\n kprrel, kprrel, kprrel,\n kprrel, kprrel, kprrel )\n};\n\n", "comment_ratio": 0.19186046511627908}
{"lang": "c", "code": "#ifndef SYSTEM_QUEUE_H_\n#define SYSTEM_QUEUE_H_\n// ESP32 Irrigation System\n// (C)2021 bekki.jp\n\n// Include ----------------------\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/queue.h\"\n\nnamespace IrrigationSystem {\n\n/// FreeRTOS Queue Wrap\nclass SystemQueue\n{\npublic:\n    SystemQueue();\n    virtual ~SystemQueue() {}\n\n    void StartPoll();\n\n    virtual void Receive() = 0;\n\nprotected:\n    void CreateQueue();\n\n    void SendQueueFromISR();\n\nprotected:\n    xQueueHandle m_QueueHandle;\n};\n\n\n} // IrrigationSystem\n\n\n#endif // SYSTEM_QUEUE_H_\n// EOF\n\n", "comment_ratio": 0.18421052631578946}
{"lang": "c", "code": "//  The Stonehouse Pattern\n//\n//  Where we allow any clients to connect, but we promise clients\n//  that we are who we claim to be, and our conversations won't be\n//  tampered with or modified, or spied on.\n\n#include <czmq.h>\n\nint main (void) \n{\n    //  Create context and start authentication engine\n    zctx_t *ctx = zctx_new ();\n    zauth_t *auth = zauth_new (ctx);\n    zauth_set_verbose (auth, true);\n    zauth_allow (auth, \"127.0.0.1\");\n    \n    //  Tell the authenticator how to handle CURVE requests\n    zauth_configure_curve (auth, \"*\", CURVE_ALLOW_ANY);\n\n    //  We need two certificates, one for the client and one for\n    //  the server. The client must know the server's public key\n    //  to make a CURVE connection.\n    zcert_t *client_cert = zcert_new ();\n    zcert_t *server_cert = zcert_new ();\n    char *server_key = zcert_public_txt (server_cert);\n        \n    //  Create and bind server socket\n    void *server = zsocket_new (ctx, ZMQ_PUSH);\n    zcert_apply (server_cert, server);\n    zsocket_set_curve_server (server, 1);\n    zsocket_bind (server, \"tcp://*:9000\");\n\n    //  Create and connect client socket\n    void *client = zsocket_new (ctx, ZMQ_PULL);\n    zcert_apply (client_cert, client);\n    zsocket_set_curve_serverkey (client, server_key);\n    zsocket_connect (client, \"tcp://127.0.0.1:9000\");\n    \n    //  Send a single message from server to client\n    zstr_send (server, \"Hello\");\n    char *message = zstr_recv (client);\n    assert (streq (message, \"Hello\"));\n    free (message);\n    puts (\"Stonehouse test OK\");\n\n    zcert_destroy (&client_cert);\n    zcert_destroy (&server_cert);\n    zauth_destroy (&auth);\n    zctx_destroy (&ctx);\n    return 0;\n}\n\n", "comment_ratio": 0.28846153846153844}
{"lang": "c", "code": "//\n//  MyWrappingView.h\n//  WrapDemo\n//\n//  Created by Jonathon Mah on 2014-06-06.\n//  This is free and unencumbered software released into the public domain.\n//\n\n#import <UIKit/UIKit.h>\n\n\n@interface MyWrappingView : UIView\n\n@property (nonatomic) NSInteger itemCount;\n@property (nonatomic) CGFloat preferredMaxLayoutWidth;\n\n@end\n\n", "comment_ratio": 0.3888888888888889}
{"lang": "c", "code": "/**\r\n * Short example to describe how raw ADC data acquired \r\n * on analog channels can be scaled to measurement values\r\n * This example will use the first TRION-dSTG-board in system\r\n * that offers analog channels and will configure the 1st\r\n * channel to bridge-mode\r\n * \r\n * Describes following:\r\n *  - Setup of 1 AI channel\r\n *  - Query for the ADC delay\r\n *  - acquire data\r\n *  - printout the scaled values\r\n */\r\n\r\n#include \"dewepxi_apicore.h\"\r\n#include \"dewepxi_apiutil.h\"\r\n#include \"trion_sdk_util.h\"\r\n\r\n\r\n//either 16 or 24\r\n// 16Bitness should only be used with one odd channel (1,3,5,7) - otherwise\r\n// the example code would become rather bloated\r\n#define DATAWIDTH   24\r\n\r\n// set the give channel on the given board to bridge mode\r\n// all const char parameters are optional, and may be NULL (in this case the board-defaults are taken)\r\nint setupAIBridge(  int nBoardNo, \r\n                    int nChannelNo, \r\n                    const char* Range, \r\n                    const char* Excitation, \r\n                    const char* InputType, \r\n                    const char* BridgeResistance \r\n                    );\r\n\r\n// dumping the current bridge-settings to console\r\n// just as visual feedback\r\nvoid dumpAIBridgeSettings ( int nBoardNo,\r\n                            int nChannelNo\r\n                            );\r\n\r\n\r\n//needed Board-Type for this example\r\nconst  char* sBoardNameNeeded[] = { \"TRION-2402-dSTG\", \r\n                                    NULL };\r\n\r\n\r\nint main(int argc, char* argv[])\r\n{\r\n    int nErrorCode = 0;\r\n    int nADCDelay = 0;\r\n    int i = 0;\r\n    int nNoOfBoards = 0;\r\n    int nBoardID = 0;\r\n    //Range 1000 mV/V, symmetrical\r\n    const double fRangeMin = -1000;  //[mV/V]\r\n    const double fRangeMax = 1000;   //[mV/V]\r\n    const char* sUnitRange = \"mV/V\";\r\n    const float fExcitation = 10;   //[V]\r\n    const char* sUnitExcitation = \"V\";\r\n    char sErrorText[256]    = {0};\r\n    char sSettingStr[256]   = {0};\r\n    char sRangeStr[256]     = {0};\r\n    char sExcitationStr[256]= {0};\r\n    char sBoardID[256] = {0};\r\n    ScaleInfo scaleinfo;\r\n\r\n    // Load pxi_api.dll\r\n    if ( 0 != LoadTrionApi() )\r\n    {\r\n        return 1;\r\n    }\r\n\r\n    // Initialize driver and retrieve the number of TRION boards\r\n    // nNoOfBoards is a negative number if system is in DEMO mode!\r\n    nErrorCode = DeWeDriverInit(&nNoOfBoards);\r\n    CheckError(nErrorCode);\r\n    nNoOfBoards = abs(nNoOfBoards);\r\n\r\n    // Check if TRION cards are in the system\r\n    if (nNoOfBoards == 0)\r\n    {\r\n        return UnloadTrionApi(\"No Trion cards found. Aborting...\\nPlease configure a system using the DEWE2 Explorer.\");\r\n    }\r\n\r\n    // Build BoardId -> Either comming from command line (arg 1) or default \"0\"\r\n    if( TRUE != ARG_GetBoardId(argc, argv, nNoOfBoards, &nBoardID) )\r\n    {\r\n        snprintf(sErrorText, sizeof(sErrorText), \"Invalid BoardId: %d\\nNumber of found boards: %d\", nBoardID, nNoOfBoards);\r\n        return UnloadTrionApi(sErrorText);\r\n    }\r\n\r\n    // Build a string in the format: \"BoardID0\", \"BoardID1\", ...\r\n    snprintf(sBoardID, sizeof(sBoardID),\"BoardID%d\", nBoardID);\r\n\r\n    // Calculate Scaling Values\r\n    nErrorCode = CalcScaling(&scaleinfo, fRangeMin, fRangeMax, (int)DATAWIDTH);\r\n    CheckError(nErrorCode);\r\n\r\n    // Open & Reset the board\r\n    nErrorCode = DeWeSetParam_i32( nBoardID, CMD_OPEN_BOARD, 0 );\r\n    CheckError(nErrorCode);\r\n    nErrorCode = DeWeSetParam_i32( nBoardID, CMD_RESET_BOARD, 0 );\r\n    CheckError(nErrorCode);\r\n\r\n    /// Check if selected board is suitable for test\r\n    if ( FALSE == TestBoardType(nBoardID, sBoardNameNeeded))\r\n    {\r\n        return UnloadTrionApi(NULL);\r\n    }\r\n\r\n    // Set configuration to use one board in standalone operation\r\n    snprintf(sSettingStr, sizeof(sSettingStr),\"%s/AcqProp\", sBoardID);\r\n    nErrorCode = DeWeSetParamStruct_str( sSettingStr, \"OperationMode\", \"Slave\");\r\n    CheckError(nErrorCode);\r\n    nErrorCode = DeWeSetParamStruct_str( sSettingStr, \"ExtTrigger\", \"False\");\r\n    CheckError(nErrorCode);\r\n    nErrorCode = DeWeSetParamStruct_str( sSettingStr, \"ExtClk\", \"False\");\r\n    CheckError(nErrorCode);\r\n\r\n    // After reset all channels are disabled.\r\n    // So here 1 analog channel will be enabled (AI)\r\n    snprintf(sSettingStr, sizeof(sSettingStr),\"%s/AI0\", sBoardID);\r\n    nErrorCode = DeWeSetParamStruct_str( sSettingStr , \"Used\", \"True\");\r\n    CheckError(nErrorCode);\r\n\r\n    //Set the desired range, so that the applied scaling is correct\r\n    snprintf(sRangeStr, sizeof(sRangeStr),\"%f..%f %s\", fRangeMin, fRangeMax, sUnitRange);\r\n    snprintf(sExcitationStr, sizeof(sExcitationStr),\"%f %s\", fExcitation, sUnitExcitation);\r\n\r\n    nErrorCode = setupAIBridge( nBoardID, 0, sRangeStr, sExcitationStr, \"brquarter3w\", \"120\" );\r\n    if ( 0 != nErrorCode )\r\n    {\r\n        return UnloadTrionApi(\"Error setting AI to Bridge-Mode\\n.Aborting.....\\n\");\r\n    }\r\n\r\n    dumpAIBridgeSettings(nBoardID, 0);\r\n    Sleep(5000);\r\n\r\n    // Setup the acquisition buffer: Size = BLOCK_SIZE * BLOCK_COUNT\r\n    // For the default samplerate 2000 samples per second, 200 is a buffer for\r\n    // 0.1 seconds\r\n    nErrorCode = DeWeSetParam_i32( nBoardID, CMD_BUFFER_BLOCK_SIZE, 200);\r\n    CheckError(nErrorCode);\r\n    // Set the ring buffer size to 50 blocks. So ring buffer can store samples\r\n    // for 5 seconds\r\n    nErrorCode = DeWeSetParam_i32( nBoardID, CMD_BUFFER_BLOCK_COUNT, 50);\r\n    CheckError(nErrorCode);\r\n\r\n    // Update the hardware with settings\r\n    nErrorCode = DeWeSetParam_i32( nBoardID, CMD_UPDATE_PARAM_ALL, 0);\r\n    CheckError(nErrorCode);\r\n\r\n    // Get the ADC delay. The typical conversion time of the ADC.\r\n    // The ADCDelay is the offset of analog samples to digital or counter samples.\r\n    // It is measured in number of samples,\r\n    nErrorCode = DeWeGetParam_i32( nBoardID, CMD_BOARD_ADC_DELAY, &nADCDelay);\r\n    CheckError(nErrorCode);\r\n\r\n    // Data Acquisition - stopped with any key\r\n    nErrorCode = DeWeSetParam_i32( nBoardID, CMD_START_ACQUISITION, 0);\r\n    CheckError(nErrorCode);\r\n    if (nErrorCode <= 0)\r\n    {\r\n        int nBufEndPos=0;         // Last position in the ring buffer\r\n        int nBufSize=0;           // Total buffer size\r\n\r\n        // Get detailed information about the ring buffer\r\n        // to be able to handle the wrap around\r\n        nErrorCode = DeWeGetParam_i32( nBoardID, CMD_BUFFER_END_POINTER, &nBufEndPos);\r\n        CheckError(nErrorCode);\r\n        nErrorCode = DeWeGetParam_i32( nBoardID, CMD_BUFFER_TOTAL_MEM_SIZE, &nBufSize);\r\n        CheckError(nErrorCode);\r\n\r\n        while( !kbhit() )\r\n        {\r\n            sint64 nReadPos=0;       // Pointer to the ring buffer read pointer\r\n            int nAvailSamples=0;\r\n            int i=0;\r\n            sint32 nRawData =0;\r\n            double fScaledVal=0;\r\n\r\n            Sleep(100);\r\n\r\n            // Get the number of samples already stored in the ring buffer\r\n            nErrorCode = DeWeGetParam_i32( nBoardID, CMD_BUFFER_AVAIL_NO_SAMPLE, &nAvailSamples );\r\n            CheckError(nErrorCode);\r\n\r\n            // Available samples has to be recalculated according to the ADC delay\r\n            nAvailSamples = nAvailSamples - nADCDelay;\r\n\r\n            // skip if number of samples is smaller than the current ADC delay\r\n            if (nAvailSamples <= 0)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            // Get the current read pointer\r\n            nErrorCode = DeWeGetParam_i64( nBoardID, CMD_BUFFER_ACT_SAMPLE_POS, &nReadPos );\r\n            CheckError(nErrorCode);\r\n\r\n            // recalculate nReadPos to handle ADC delay\r\n            nReadPos = nReadPos + nADCDelay * sizeof(uint32);\r\n\r\n            // Read the current samples from the ring buffer\r\n            for (i = 0; i < nAvailSamples; ++i)\r\n            {\r\n                // Get the sample value at the read pointer of the ring buffer\r\n                // The sample value is 24Bit (little endian, encoded in 32bit). \r\n                nRawData = formatRawData( *(sint32*)nReadPos, (int)DATAWIDTH, 8);\r\n                fScaledVal = ((((double)(nRawData) * scaleinfo.fScaling)) - scaleinfo.fd);\r\n             \r\n                // Print the sample value:\r\n                printf(\"%8.8X =  %#10.6f %s\\n\", nRawData, fScaledVal, sUnitRange );\r\n               \r\n                // Increment the read pointer\r\n                nReadPos += sizeof(uint32);\r\n\r\n                // Handle the ring buffer wrap around\r\n                if (nReadPos > nBufEndPos)\r\n                {\r\n                    nReadPos -= nBufSize;\r\n                }\r\n\r\n            }\r\n            fflush(stdout);\r\n\r\n            // Free the ring buffer after read of all values\r\n            nErrorCode = DeWeSetParam_i32( nBoardID, CMD_BUFFER_FREE_NO_SAMPLE, nAvailSamples );\r\n            CheckError(nErrorCode);\r\n        }\r\n    }\r\n\r\n    // Stop data acquisition\r\n    nErrorCode = DeWeSetParam_i32( nBoardID, CMD_STOP_ACQUISITION, 0);\r\n    CheckError(nErrorCode);\r\n\r\n    // Close the board connection\r\n    nErrorCode = DeWeSetParam_i32( nBoardID, CMD_CLOSE_BOARD, 0);\r\n    CheckError(nErrorCode);\r\n\r\n    // Unload pxi_api.dll\r\n    UnloadTrionApi(\"\\nEnd Of Example\\n\");\r\n\r\n    return nErrorCode;\r\n}\r\n\r\n\r\nint setupAIBridge(  \r\n                    int nBoardNo, \r\n                    int nChannelNo, \r\n                    const char* Range, \r\n                    const char* Excitation, \r\n                    const char* InputType, \r\n                    const char* BridgeResistance )\r\n{\r\n    int  nErrorCode=0;\r\n    char sTargetString[256] ={0};\r\n\r\n    snprintf( sTargetString, sizeof(sTargetString), \"BoardId%d/AI%d\", nBoardNo, nChannelNo );\r\n\r\n    //1st item, to be set is always the mode, as this will initialize all depending sub-properties (like range, etc..)\r\n    nErrorCode = DeWeSetParamStruct_str( sTargetString, \"Mode\", \"Bridge\");\r\n    if (CheckError(nErrorCode)) \r\n        return 1;\r\n\r\n    //now apply all of the passed parameters, unless the pointer is NULL\r\n    //Range and excitation influence each other (Excitation might be [V] or [mA]\r\n    if ( NULL != Range )\r\n    {\r\n        nErrorCode = DeWeSetParamStruct_str( sTargetString, \"Range\", Range );\r\n        if (CheckError(nErrorCode)) \r\n            return 1;\r\n    }\r\n    \r\n    if ( NULL != Excitation )\r\n    {\r\n        nErrorCode = DeWeSetParamStruct_str( sTargetString, \"Excitation\", Excitation);\r\n        if (CheckError(nErrorCode)) \r\n            return 1;\r\n    }\r\n    \r\n    if ( NULL != InputType )\r\n    {\r\n        nErrorCode = DeWeSetParamStruct_str( sTargetString, \"InputType\", InputType);\r\n        if (CheckError(nErrorCode)) \r\n            return 1;\r\n    }\r\n\r\n    if ( NULL != BridgeResistance )\r\n    {\r\n        nErrorCode = DeWeSetParamStruct_str( sTargetString, \"BridgeRes\", BridgeResistance);\r\n        if (CheckError(nErrorCode)) \r\n            return 1;\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n\r\nstatic void dumpProperty(\r\n                        const char* sTarget,\r\n                        const char* sProperty )\r\n{\r\n    int     nErrorCode = 0;\r\n    char    sStrVal[256] = {0};\r\n\r\n    nErrorCode = DeWeGetParamStruct_str( sTarget, sProperty, sStrVal, sizeof(sStrVal));\r\n    if ( !CheckError(nErrorCode))\r\n    {\r\n        //only when retrieved error-free. otherwise the error is printed\r\n        printf( \"%s - %s: %s\\n\", sTarget, sProperty, sStrVal );\r\n    }\r\n}\r\n\r\n\r\nvoid dumpAIBridgeSettings (\r\n                            int nBoardNo,\r\n                            int nChannelNo )\r\n{\r\n    char sTargetString[256] ={0};\r\n\r\n    snprintf( sTargetString, sizeof(sTargetString), \"BoardId%d/AI%d\", nBoardNo, nChannelNo );\r\n\r\n    dumpProperty(sTargetString, \"Mode\");\r\n    dumpProperty(sTargetString, \"LPFilter_Val\");\r\n    dumpProperty(sTargetString, \"HPFilter_Val\");\r\n    dumpProperty(sTargetString, \"Range\");\r\n    dumpProperty(sTargetString, \"Excitation\");\r\n    dumpProperty(sTargetString, \"InputType\");\r\n    dumpProperty(sTargetString, \"BridgeRes\");\r\n    dumpProperty(sTargetString, \"ShuntType\");\r\n    dumpProperty(sTargetString, \"ShuntResistance\");\r\n}\r\n\n", "comment_ratio": 0.17664670658682635}
{"lang": "c", "code": "#ifndef PPAPI_TESTS_TEST_CRYPTO_H_\n#define PPAPI_TESTS_TEST_CRYPTO_H_\n\n#include <string>\n#include <vector>\n\n#include \"ppapi/c/dev/ppb_crypto_dev.h\"\n#include \"ppapi/tests/test_case.h\"\n\nclass TestCrypto : public TestCase {\n public:\n  TestCrypto(TestingInstance* instance);\n\n  // TestCase implementation.\n  virtual bool Init();\n  virtual void RunTests(const std::string& filter);\n\n private:\n  std::string TestGetRandomBytes();\n\n  const PPB_Crypto_Dev* crypto_interface_;\n};\n\n#endif  // PPAPI_TESTS_TEST_CRYPTO_H_\n\n", "comment_ratio": 0.1724137931034483}
{"lang": "c", "code": "#include <cstring>\n#include <string>\n#include <fstream>\n#include <sstream>\n#include <map>\n#include <algorithm>\n\n#include <stdio.h>\n#include <stdint.h>\n#include <poll.h>\n#include <queue>\n\n#include <sst/core/sst_types.h>\n#include <sst/core/event.h>\n#include <sst/core/component.h>\n#include <sst/core/link.h>\n#include <sst/core/timeConverter.h>\n#include <sst/core/interfaces/simpleMem.h>\n#include <sst/core/output.h>\n#include <sst/core/elementinfo.h>\n\n#include \"Opal_Event.h\"\n#include \"mempool.h\"\n\nusing namespace SST;\n\nusing namespace SST::OpalComponent;\n\n\nnamespace SST\n{\n\tnamespace OpalComponent\n\t{\n\n\t\tclass NodePrivateInfo;\n\n\t\tclass Opal : public SST::Component\n\t\t{\n\t\t\tpublic:\n\n\t\t\t\tOpal( SST::ComponentId_t id, SST::Params& params); \n\t\t\t\tvoid setup()  { };\n\t\t\t\tvoid finish();\n\t\t\t\tbool tick(SST::Cycle_t x);\n\n\t\t\t\tvoid setNextMemPool( int node );\n\n\n\t\t\t\tREQRESPONSE allocateLocalMemory(int node, int coreId, uint64_t vAddress, int fault_level, int pages);\n\t\t\t\tREQRESPONSE allocateSharedMemory(int node, int coreId, uint64_t vAddress, int fault_level, int pages);\n\t\t\t\tREQRESPONSE allocateFromReservedMemory(int node, uint64_t reserved_vAddress, uint64_t vAddress, int pages);\n\t\t\t\tREQRESPONSE isAddressReserved(int node, uint64_t vAddress);\n\n\n\t\t\t\tbool processRequest(int node, int coreId, uint64_t vAddress, int fault_level, int size);\n\t\t\t\tvoid processHint(int node, int fileId, uint64_t vAddress, int size);\n\t\t\t\tvoid processShootdownEvent(int node, int coreId, uint64_t vaddress, uint64_t paddress, int fault_level);\n\t\t\t\tvoid processInvalidAddrEvent(int node, int coreId, uint64_t vaddress);\n\t\t\t\tvoid processTLBShootdownAck(int node, int coreId, int shootdownId);\n\t\t\t\tvoid tlbShootdown(int node, int coreId, int shootdownId);\n\t\t\t\tvoid migratePages(int node, int coreId, int pages);\n\n\t\t\t\tstd::queue<OpalEvent*> requestQ;\n\n\t\t\t\t~Opal() { };\n\t\t\t\tSST_ELI_REGISTER_COMPONENT(\n\t\t\t\t\t\tOpal,\n\t\t\t\t\t\t\"Opal\",\n\t\t\t\t\t\t\"Opal\",\n\t\t\t\t\t\tSST_ELI_ELEMENT_VERSION(1,0,0),\n\t\t\t\t\t\t\"Memory Allocation Manager\",\n\t\t\t\t\t\tCOMPONENT_CATEGORY_PROCESSOR\n\t\t\t\t\t\t)\n\n\n\t\t\t\t\tSST_ELI_DOCUMENT_PARAMS(\n\t\t\t\t\t\t\t{\"clock\", \"Internal Controller Clock Rate.\", \"1.0 Ghz\"},\n\t\t\t\t\t\t\t{\"latency\", \"The time to be spent to service a memory request\", \"1000\"},\n\t\t\t\t\t\t\t{\"verbose\", \"debug level\", \"1\"},\n\t\t\t\t\t\t\t{\"max_inst\", \"maximum number of instructions per cycle\", \"1\"},\n\t\t\t\t\t\t\t{\"num_nodes\", \"number of disaggregated nodes in the system\", \"1\"},\n\t\t\t\t\t\t\t{\"cores_per_node\", \"total number of cores. this will be used to account for TLB shootdown latency\", \"1\"},\n\t\t\t\t\t\t\t{\"num_ports\", \"total number of request links\", \"2\"},\n\t\t\t\t\t\t\t{\"num_pools\", \"This determines the number of memory pools\", \"1\"},\n\t\t\t\t\t\t\t{\"num_domains\", \"The number of domains in the system, typically similar to number of sockets/SoCs\", \"1\"},\n\t\t\t\t\t\t\t{\"allocation_policy\", \"0 is private pools, then clustered pools, then public pools\", \"0\"},\n\t\t\t\t\t\t\t{\"shared_mempools\", \"This determines the number of shared memory pools\", \"1\"},\n\t\t\t\t\t\t\t{\"shared_mem.mempool%(shared_mempools).start\", \"the starting physical address of each shared memory pool in KBs\", \"0\"},\n\t\t\t\t\t\t\t{\"shared_mem.mempool%(shared_mempools).size\", \"Size of each shared memory pool in KBs\", \"1024\"},\n\t\t\t\t\t\t\t{\"shared_mem.mempool%(shared_mempools).frame_size\", \"Size of each shared memory pool in KBs\", \"4\"},\n\t\t\t\t\t\t\t{\"shared_mem.mempool%(shared_mempools).mem_tech\", \"memory technology of each shared memory pool in KBs\", \"0\"},\n\t\t\t\t\t\t\t{\"local_mem.mempool%(num_nodes).start\", \"the starting physical address of each local memory pool in KBs\", \"0\"},\n\t\t\t\t\t\t\t{\"local_mem.mempool%(num_nodes).size\", \"Size of each local memory pool in KBs\", \"1024\"},\n\t\t\t\t\t\t\t{\"local_mem.mempool%(num_nodes).frame_size\", \"frame size of each local memory pool in KBs\", \"4\"},\n\t\t\t\t\t\t\t{\"local_mem.mempool%(num_nodes).mem_tech\", \"memory technology of each local memory pool in KBs\", \"0\"},\n\t\t\t\t\t\t\t{\"startaddress%(num_pools)\", \"the starting physical address of the pool\", \"0\"},\n\t\t\t\t\t\t\t{\"type%(num_pools)\", \"0 means private for specific NUMA domain, 1 means shared among specific NUMA domains, 2 means public\", \"2\"},\n\t\t\t\t\t\t\t{\"cluster_size\", \"This determines the number of NUMA domains in each cluster, if clustering is used\", \"1\"},\n\t\t\t\t\t\t\t{\"memtype%(num_pools)\", \"0 for typical DRAM, 1 for die-stacked DRAM, 2 for NVM\", \"0\"},\n\t\t\t\t\t\t\t{\"typepriority%(num_pools)\", \"0 means die-stacked, typical DRAM, then NVM\", \"0\"},\n\t\t\t\t\t\t\t)\n\n\t\t\t\t\t// Optional since there is nothing to document\n\t\t\t\t\tSST_ELI_DOCUMENT_STATISTICS(\n\t\t\t\t\t\t\t{ \"local_mem_usage\", \"Number of pages allocated in local memory\", \"requests\", 1},\n\t\t\t\t\t\t\t{ \"shared_mem_usage\", \"Number of pages allocated in shared memory\", \"requests\", 1},\n\t\t\t\t\t\t\t{ \"local_mem_mapped\", \"Number of pages mapped in local memory\", \"requests\", 1},\n\t\t\t\t\t\t\t{ \"shared_mem_mapped\", \"Number of pages mapped in shared memory\", \"requests\", 1},\n\t\t\t\t\t\t\t{ \"local_mem_unmapped\", \"Number of pages unmapped while memory allocation in local memory\", \"requests\", 1},\n\t\t\t\t\t\t\t{ \"shared_mem_unmapped\", \"Number of pages unmapped while memory allocation in local memory\", \"requests\", 1},\n\t\t\t\t\t\t\t{ \"tlb_shootdowns\", \"Number of tlb shootdowns initiated in a node\", \"requests\", 1},\n\t\t\t\t\t\t\t{ \"tlb_shootdown_delay\", \"Total tlb shootdown delays in a node(initiating core)\", \"requests\", 1},\n\t\t\t\t\t\t\t{ \"num_of_pages_migrated\", \"Number of pages migrated\", \"requests\", 1},\n\t\t\t\t\t\t\t)\n\n\t\t\t\t\tSST_ELI_DOCUMENT_PORTS(\n\t\t\t\t\t\t\t{\"requestLink%(num_ports)d\", \"Link to receive allocation requests\", { \"OpalComponent.OpalEvent\", \"\" } },\n\t\t\t\t\t\t\t{\"shootdownLink%(num_nodes*num_cores)d\", \"Link to send shootdown requests to Samba units\", { \"OpalComponent.OpalEvent\", \"\" } },\n\t\t\t\t\t\t\t)\n\n\t\t\t\t\t// Optional since there is nothing to document\n\t\t\t\t\tSST_ELI_DOCUMENT_SUBCOMPONENT_SLOTS(\n\t\t\t\t\t\t\t)\n\n\t\t\tprivate:\n\t\t\t\t\tOpal();  // for serialization only\n\t\t\t\t\tOpal(const Opal&); // do not implement\n\t\t\t\t\tvoid operator=(const Opal&); // do not implement\n\n\t\t\t\t\tuint32_t num_nodes;\n\t\t\t\t\tuint32_t num_cores;\n\n\t\t\t\t\t//shared memory - memory pool number and its pool\n\t\t\t\t\t//std::map<int, Pool*> shared_mem;\n\t\t\t\t\tPool **sharedMemoryInfo;\n\t\t\t\t\tuint64_t shared_mem_size;\n\t\t\t\t\tuint32_t num_shared_mempools;\n\n\t\t\t\t\t//node specific information\n\t\t\t\t\tNodePrivateInfo **nodeInfo;\n\n\t\t\t\t\t//TLB shootdown information\n\t\t\t\t\tstd::map<int, std::pair<int, int> > tlbShootdownInfo;\n\n\t\t\t\t\t//reserved memory to communicate\n\t\t\t\t\tstd::map<int, std::pair<std::list<int>*, std::list<uint64_t>* > > mmapFileIdHints;\n\n\t\t\t\t\tlong long int max_inst;\n\t\t\t\t\tchar* named_pipe;\n\t\t\t\t\tint* pipe_id;\n\t\t\t\t\tstd::string user_binary;\n\t\t\t\t\tOutput* output;\n\t\t\t\t\tint verbosity;\n\n\t\t\t\t\tStatistic<uint64_t>* statReadRequests;\n\t\t\t\t\tStatistic<uint64_t>* statWriteRequests;\n\t\t\t\t\tStatistic<uint64_t>* statAvgTime;\n\t\t\t\t\tStatistic<uint64_t>* statPagesMigrated;\n\n\n\t\t};// END Opal\n\n\t\tclass CorePrivateInfo\n\t\t{\n\t\t\tpublic:\n\n\t\t\t\tint id;\n\t\t\t\tint nodeId;\n\t\t\t\tint coreId;\n\t\t\t\tSST::Link * coreLink;\n\t\t\t\tSST::Link * mmuLink;\n\t\t\t\tint dummy_address;\n\t\t\t\tCorePrivateInfo() { dummy_address = 0;}\n\t\t\t\tunsigned int latency;\n\t\t\t\tOpal *owner;\n\t\t\t\tvoid setOwner(Opal *owner_) { owner = owner_; }\n\n\t\t\t\tvoid handleRequest(SST::Event* e)\n\t\t\t\t{\n\t\t\t\t\tOpalEvent *ev =  static_cast<OpalComponent::OpalEvent*> (e);\n\t\t\t\t\tev->setNodeId(nodeId);\n\t\t\t\t\tev->setCoreId(coreId);\n\t\t\t\t\towner->requestQ.push(ev);\n\n\t\t\t\t}\n\n\t\t\t\t// number of shootdown acknowledgments required\n\t\t\t\tuint32_t sdAckCount;\n\n\t\t\t\t// list of addresses to be invalidated\n\t\t\t\tstd::list<std::pair<uint64_t, std::pair<uint64_t, int> > > invalidAddrs;\n\n\t\t\t\tvoid addInvalidAddress(uint64_t pAddress, uint64_t vAddress, int fault_level) { invalidAddrs.push_back(std::make_pair(pAddress,std::make_pair(vAddress,fault_level))); }\n\t\t\t\tvoid setInvalidAddresses (std::list<std::pair<uint64_t, std::pair<uint64_t, int> > > ia) { invalidAddrs = ia; }\n\t\t\t\tstd::list<std::pair<uint64_t, std::pair<uint64_t, int> > > * getInvalidAddresses() { return &invalidAddrs; }\n\n\t\t\t\tuint64_t cr3;\n\n\t\t};// END CorePrivateInfo\n\n\t\tclass NodePrivateInfo\n\t\t{\n\t\t\tpublic:\n\t\t\t\tNodePrivateInfo(Opal *_owner, uint32_t node, Params params) {\n\t\t\t\t\towner = _owner;\n\t\t\t\t\tnode_num = node;\n\t\t\t\t\tcores = (uint32_t) params.find<uint32_t>(\"cores\", 1);\n\t\t\t\t\tclock = (uint32_t) params.find<uint32_t>(\"clock\", 2000); // in MHz\n\t\t\t\t\tlatency = (uint32_t) params.find<uint32_t>(\"latency\", 1);\n\t\t\t\t\tmemoryAllocationPolicy = (uint32_t) params.find<uint32_t>(\"allocation_policy\", 0);\n\t\t\t\t\tpage_migration = (uint32_t) params.find<uint32_t>(\"page_migration\", 0);\n\t\t\t\t\tpage_migration_policy = (uint32_t) params.find<uint32_t>(\"page_migration_policy\", 0);\n\t\t\t\t\tnum_pages_to_migrate = (uint32_t) params.find<uint32_t>(\"num_pages_to_migrate\", 0);\n\t\t\t\t\tnextallocmem = 0;\n\t\t\t\t\tallocatedmempool = 0;\n\t\t\t\t\tpool = new Pool(owner, (Params) params.find_prefix_params(\"memory.\"), SST::OpalComponent::MemType::LOCAL, node);\n\t\t\t\t\tmemory_size = (uint32_t) params.find<uint32_t>(\"memory.size\", 1);\n\t\t\t\t\tpage_size = (uint32_t) params.find<uint32_t>(\"memory.frame_size\", 4);\n\t\t\t\t\tcoreInfo = new CorePrivateInfo[cores];\n\n\t\t\t\t\tstd::cerr << \"Node: \" << node_num << \" Allocation policy: \" << memoryAllocationPolicy << std::endl;\n\n\t\t\t\t\tfor(uint32_t i=0; i<cores; i++) {\n\t\t\t\t\t\tcoreInfo[i].latency = latency;\n\t\t\t\t\t\tcoreInfo[i].nodeId = node_num;\n\t\t\t\t\t\tcoreInfo[i].coreId = i;\n\t\t\t\t\t\tcoreInfo[i].owner = owner;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tOpal *owner;\n\t\t\t\tuint32_t node_num;\n\t\t\t\tuint32_t cores;\n\t\t\t\tuint32_t clock;\n\t\t\t\tuint32_t latency;\n\n\t\t\t\t/* core specific information*/\n\t\t\t\tCorePrivateInfo *coreInfo;\n\n\t\t\t\t/* allocation policies */\n\t\t\t\tuint32_t memoryAllocationPolicy;\n\t\t\t\tint nextallocmem;\n\t\t\t\tint allocatedmempool;\n\n\t\t\t\t/*page migration information*/\n\t\t\t\tint page_migration;\n\t\t\t\tint page_migration_policy;\n\t\t\t\tint num_pages_to_migrate;\n\n\t\t\t\t/* local memory */\n\t\t\t\tPool* pool;\n\t\t\t\tuint32_t page_size; // page size of the node in KB's\n\t\t\t\tuint32_t memory_size; // in pages\n\t\t\t\tuint32_t pages_available;\n\t\t\t\tstd::map<uint64_t, std::pair<uint64_t, int> > localPageList; // allocated frame and virtual address, fault level\n\n\t\t\t\t//shared memory info\n\t\t\t\tstd::map<uint64_t, std::pair<uint64_t, int> > globalPageList;\n\n\t\t\t\t//virtual address, fileId, size\n\t\t\t\tstd::map<uint64_t, std::pair<int, std::pair<int, int> > > reservedSpace;\n\n\n\n\t\t\t\tvoid insertFrame(int coreId, uint64_t pAddress, uint64_t vAddress, int fault_level, SST::OpalComponent::MemType memType) {\n\t\t\t\t\tif(4==fault_level)\n\t\t\t\t\t\tcoreInfo[coreId].cr3 = pAddress;\n\t\t\t\t\telse if( memType == SST::OpalComponent::MemType::LOCAL ) {\n\t\t\t\t\t\tlocalPageList[pAddress] = std::make_pair(vAddress,fault_level);\n\t\t\t\t\t}\n\t\t\t\t\telse if( memType == SST::OpalComponent::MemType::SHARED ) {\n\t\t\t\t\t\tglobalPageList[pAddress] = std::make_pair(vAddress,fault_level);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tstd::cout << \"Opal: insert frame Error!!!!\"  <<std::endl;\n\n\t\t\t\t}\n\n\t\t\t\tvoid removeFrame(uint64_t pAddress, SST::OpalComponent::MemType memType) {\n\t\t\t\t\tif( memType == SST::OpalComponent::MemType::LOCAL ) {\n\t\t\t\t\t\tlocalPageList.erase(pAddress);\n\t\t\t\t\t}\n\t\t\t\t\telse if( memType == SST::OpalComponent::MemType::SHARED ) {\n\t\t\t\t\t\tglobalPageList.erase(pAddress);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tstd::cout << \"Opal: insert frame Error!!!!\"  <<std::endl;\n\t\t\t\t}\n\n\t\t\t\t// choose pages to migrate randomly\n\t\t\t\tstd::list<std::pair<uint64_t, std::pair<uint64_t, int> > > getPagesToMigrate(int pages) {\n\t\t\t\t\tstd::list<std::pair<uint64_t, std::pair<uint64_t, int> > > migrate_pages;\n\t\t\t\t\tfor(int i=0; i<pages; i++) {\n\t\t\t\t\t\tauto it = localPageList.begin();\n\t\t\t\t\t\tstd::advance(it, rand() % localPageList.size());\n\t\t\t\t\t\tmigrate_pages.push_back(std::make_pair(it->first, it->second));\n\t\t\t\t\t\tlocalPageList.erase(it->first);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn migrate_pages;\n\t\t\t\t}\n\n\t\t\t\t// choose a single page to migrate randomly\n\t\t\t\tstd::pair<uint64_t, std::pair<uint64_t, int> > getPageToMigrate() {\n\t\t\t\t\tstd::pair<uint64_t, std::pair<uint64_t, int> > migrate_page;\n\t\t\t\t\tauto it = localPageList.begin();\n\t\t\t\t\tstd::advance(it, rand() % localPageList.size());\n\t\t\t\t\tmigrate_page = std::make_pair(it->first, it->second);\n\t\t\t\t\tlocalPageList.erase(it->first);\n\t\t\t\t\treturn migrate_page;\n\t\t\t\t}\n\n\t\t};\n\n\n\t}// END OpalComponent\n}//END SST\n\n\n\n", "comment_ratio": 0.10263929618768329}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n\ntypedef NS_ENUM(NSInteger, QMUICollectionViewPagingLayoutStyle) {\n    QMUICollectionViewPagingLayoutStyleDefault, // \u666e\u901a\u6a21\u5f0f\uff0c\u6c34\u5e73\u6ed1\u52a8\n    QMUICollectionViewPagingLayoutStyleScale,   // \u7f29\u653e\u6a21\u5f0f\uff0c\u4e24\u8fb9\u7684item\u4f1a\u5c0f\u4e00\u70b9\uff0c\u9010\u6e10\u5411\u4e2d\u95f4\u653e\u5927\n    QMUICollectionViewPagingLayoutStyleRotation // \u65cb\u8f6c\u6a21\u5f0f\uff0c\u56f4\u7ed5\u5e95\u90e8\u67d0\u4e2a\u70b9\u4e3a\u4e2d\u5fc3\u65cb\u8f6c\n};\n\n/**\n *  \u652f\u6301\u6309\u9875\u6a2a\u5411\u6eda\u52a8\u7684 UICollectionViewLayout\uff0c\u53ef\u5207\u6362\u4e0d\u540c\u7c7b\u578b\u7684\u6eda\u52a8\u52a8\u753b\u3002\n */\n@interface QMUICollectionViewPagingLayout : UICollectionViewFlowLayout\n\n- (instancetype)initWithStyle:(QMUICollectionViewPagingLayoutStyle)style NS_DESIGNATED_INITIALIZER;\n\n@property(nonatomic, assign, readonly) QMUICollectionViewPagingLayoutStyle style;\n\n/**\n *  \u89c4\u5b9a\u8d85\u8fc7\u8fd9\u4e2a\u6eda\u52a8\u901f\u5ea6\u5c31\u5f3a\u5236\u7ffb\u9875\uff0c\u4ece\u800c\u4f7f\u7ffb\u9875\u66f4\u5bb9\u6613\u89e6\u53d1\u3002\u9ed8\u8ba4\u4e3a 0.4\n */\n@property(nonatomic, assign) CGFloat velocityForEnsurePageDown;\n\n/**\n *  \u662f\u5426\u652f\u6301\u4e00\u6b21\u6ed1\u52a8\u53ef\u4ee5\u6eda\u52a8\u591a\u4e2a item\uff0c\u9ed8\u8ba4\u4e3a YES\n */\n@property(nonatomic, assign) BOOL allowsMultipleItemScroll;\n\n/**\n *  \u89c4\u5b9a\u4e86\u5f53\u652f\u6301\u4e00\u6b21\u6ed1\u52a8\u5141\u8bb8\u6eda\u52a8\u591a\u4e2a item \u7684\u65f6\u5019\uff0c\u6ed1\u52a8\u901f\u5ea6\u8981\u8fbe\u5230\u591a\u5c11\u624d\u4f1a\u6eda\u52a8\u591a\u4e2a item\uff0c\u9ed8\u8ba4\u4e3a 0.7\n *\n *  \u4ec5\u5f53 allowsMultipleItemScroll \u4e3a YES \u65f6\u751f\u6548\n */\n@property(nonatomic, assign) CGFloat multipleItemScrollVelocityLimit;\n\n@end\n\n\n@interface QMUICollectionViewPagingLayout (ScaleStyle)\n\n/**\n *  \u4e2d\u95f4\u90a3\u5f20\u5361\u7247\u57fa\u4e8e\u521d\u59cb\u5927\u5c0f\u7684\u7f29\u653e\u500d\u6570\uff0c\u9ed8\u8ba4\u4e3a 1.0\n */\n@property(nonatomic, assign) CGFloat maximumScale;\n\n/**\n *  \u9664\u4e86\u4e2d\u95f4\u4e4b\u5916\u7684\u5176\u4ed6\u5361\u7247\u57fa\u4e8e\u521d\u59cb\u5927\u5c0f\u7684\u7f29\u653e\u500d\u6570\uff0c\u9ed8\u8ba4\u4e3a 0.9\n */\n@property(nonatomic, assign) CGFloat minimumScale;\n@end\n\n\nextern const CGFloat QMUICollectionViewPagingLayoutRotationRadiusAutomatic;\n\n@interface QMUICollectionViewPagingLayout (RotationStyle)\n\n/**\n *  \u65cb\u8f6c\u5361\u7247\u76f8\u5173\n *  \u5de6\u53f3\u4e24\u4e2a\u5361\u7247\u6700\u7ec8\u65cb\u8f6c\u7684\u89d2\u5ea6\u6709 rotationRadius * 90 \u8ba1\u7b97\u51fa\u6765\n *  rotationRadius\u8868\u793a\u65cb\u8f6c\u7684\u534a\u5f84\n *  @warning \u4ec5\u5f53 style \u4e3a QMUICollectionViewPagingLayoutStyleRotation \u65f6\u624d\u751f\u6548\n */\n@property(nonatomic, assign) CGFloat rotationRatio;\n@property(nonatomic, assign) CGFloat rotationRadius;\n@end\n\n", "comment_ratio": 0.12658227848101267}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface AFOColors : NSObject\n@property (nonatomic, copy) NSString  *name;\n@end\n\nNS_ASSUME_NONNULL_END\n\n", "comment_ratio": 0.3888888888888889}
{"lang": "c", "code": "//\n//  MLNCore.h\n//  MLNCore\n//\n//  Created by MoMo on 2019/7/23.\n//\n\n#ifndef MLNCore_h\n#define MLNCore_h\n\n// \u865a\u62df\u673a\u5185\u6838\n#import \"MLNLuaCore.h\"\n#import \"MLNLuaBundle.h\"\n#import \"MLNBlock.h\"\n#import \"MLNLuaBundle.h\"\n#import \"MLNHeader.h\"\n\n// \u53ef\u5bfc\u51fa\u534f\u8bae\n#import \"MLNStaticExportProtocol.h\"\n#import \"MLNEntityExportProtocol.h\"\n#import \"MLNGlobalFuncExportProtocol.h\"\n#import \"MLNGlobalVarExportProtocol.h\"\n\n// \u5bfc\u51fa\u5de5\u5177\n#import \"MLNStaticExporterMacro.h\"\n#import \"MLNEntityExporterMacro.h\"\n#import \"MLNGlobalFuncExporterMacro.h\"\n#import \"MLNGlobalVarExporterMacro.h\"\n\n// \u5206\u7c7b\n#import \"NSObject+MLNCore.h\"\n#import \"NSDictionary+MLNCore.h\"\n#import \"NSArray+MLNCore.h\"\n#import \"NSNumber+MLNCore.h\"\n#import \"NSMutableArray+MLNCore.h\"\n#import \"NSMutableDictionary+MLNCore.h\"\n#import \"NSString+MLNCore.h\"\n#import \"UIColor+MLNCore.h\"\n#import \"UIView+MLNCore.h\"\n#import \"NSValue+MLNCore.h\"\n#import \"NSError+MLNCore.h\"\n\n#endif /* MLNCore_h */\n\n", "comment_ratio": 0.22727272727272727}
{"lang": "c", "code": "// ======================================================================\n/*!\n * \\file NFmiEquidistArea.h\n * \\brief Interface of class NFmiEquidistArea\n */\n// ======================================================================\n\n#pragma once\n\n#include \"NFmiAngle.h\"\n#include \"NFmiAzimuthalArea.h\"\n\n//! Undocumented\n\nclass NFmiEquidistArea : public NFmiAzimuthalArea\n{\n public:\n  virtual ~NFmiEquidistArea();\n  NFmiEquidistArea();\n  NFmiEquidistArea(const NFmiEquidistArea& theEquidistArea);\n\n  NFmiEquidistArea(double theRadialRangeInMeters,\n                   const NFmiPoint& theCenterLatLon,\n                   const NFmiPoint& theTopLeftXY,\n                   const NFmiPoint& theBottomRightXY);\n\n  NFmiEquidistArea(const NFmiPoint& theBottomLeftLatLon,\n                   const NFmiPoint& theTopRightLatLon,\n                   const double theOrientation = 0.,\n                   const NFmiPoint& theTopLeftXY = NFmiPoint(0.f, 0.f),\n                   const NFmiPoint& theBottomRightXY = NFmiPoint(1.f, 1.f),\n                   const double theCentralLatitude = 90.,  // 90 deg. = North Pole\n                   bool usePacificView = false);\n\n  NFmiEquidistArea(const NFmiPoint& theBottomLeftLatLon,\n                   const double theWidthInMeters,\n                   const double theHeightInMeters,\n                   const double theOrientation = 0.,\n                   const NFmiPoint& theTopLeftXY = NFmiPoint(0.f, 0.f),\n                   const NFmiPoint& theBottomRightXY = NFmiPoint(1.f, 1.f),\n                   const double theCentralLatitude = 90.);  // 90 deg. = North Pole\n\n  NFmiEquidistArea(const double theRadialRange,\n                   const double theOrientation = 0.,\n                   const NFmiPoint& theTopLeftXY = NFmiPoint(0.f, 0.f),\n                   const NFmiPoint& theBottomRightXY = NFmiPoint(1.f, 1.f),\n                   const double theCentralLatitude = 90.);  // 90 deg. = North Pole\n\n  virtual void Init(bool fKeepWorldRect = false);\n  virtual NFmiArea* NewArea(const NFmiPoint& theBottomLeftLatLon,\n                            const NFmiPoint& theTopRightLatLon,\n                            bool allowPacificFix = true) const;\n\n  NFmiEquidistArea& operator=(const NFmiEquidistArea& theArea);\n  bool operator==(const NFmiEquidistArea& theArea) const;\n  bool operator!=(const NFmiEquidistArea& theArea) const;\n\n  using NFmiAzimuthalArea::operator==;\n  using NFmiAzimuthalArea::operator!=;\n\n  bool operator==(const NFmiArea& theArea) const;\n  bool operator!=(const NFmiArea& theArea) const;\n\n  virtual NFmiArea* Clone() const;\n  virtual unsigned long ClassId() const;\n  virtual const char* ClassName() const;\n  const std::string AreaStr() const;\n  virtual const std::string WKT() const;\n\n  std::size_t HashValue() const;\n\n protected:\n  virtual double K(const double delta) const;\n  virtual double CalcDelta(const double xyDistance) const;\n  virtual double DistanceFromPerspectivePointToCenterOfEarth() const;\n\n private:\n};  // class NFmiEquidistArea\n\n//! Undocumented, should be removed\ntypedef NFmiEquidistArea* PNFmiEquidistArea;\n\n// ----------------------------------------------------------------------\n/*!\n * The destructor does nothing special\n */\n// ----------------------------------------------------------------------\n\ninline NFmiEquidistArea::~NFmiEquidistArea() {}\n// ----------------------------------------------------------------------\n/*!\n * Void constructor\n */\n// ----------------------------------------------------------------------\n\ninline NFmiEquidistArea::NFmiEquidistArea() : NFmiAzimuthalArea() {}\n// ----------------------------------------------------------------------\n/*!\n * \\return Undocumented\n */\n// ----------------------------------------------------------------------\n\ninline unsigned long NFmiEquidistArea::ClassId() const\n{\n  return kNFmiEquiDistArea;\n}\n// ----------------------------------------------------------------------\n/*!\n * \\return Undocumented\n */\n// ----------------------------------------------------------------------\n\ninline const char* NFmiEquidistArea::ClassName() const\n{\n  return \"NFmiEquiDistArea\";\n}\n\n// ======================================================================\n\n", "comment_ratio": 0.14285714285714285}
{"lang": "c", "code": "#ifndef _NVDLA_CDMA_CVT_H_\n#define _NVDLA_CDMA_CVT_H_\n\n#include \"../../../nvdla_cmod/hls/include/ac_channel.h\"\n#include \"../../../nvdla_cmod/hls/include/ac_fixed.h\"\n#include \"../../../nvdla_cmod/hls/include/ac_int.h\"\n#include \"../../../nvdla_cmod/hls/include/nvdla_float.h\"\n#include \"../../../nvdla_cmod/hls/include/nvdla_int.h\"\n\n#define ENUM_INT8  0x0\n#define ENUM_INT16 0x1\n#define ENUM_FP16  0x2\n\n#define vFloatExpoSize  5\n#define vFloatMantSize  10\n#define vFloatSize      16\n\n#define vInt8Size  8\n#define vInt16Size 16\n#define vInt17Size 17\n#define vInt18Size 18\n\n#define vDataInSize  17\n#define vAluInSize   16\n#define vMulInSize   16\n#define vAluOutSize  18\n#define vMulOutSize  34\n#define vDataOutSize 16\n#define vTruncateBits 6\n\ntypedef ACINTT(vFloatSize)      vFloatType;\ntypedef ACINTT(vInt16Size)      vInt16Type;\ntypedef ACINTT(vInt17Size)      vInt17Type;\ntypedef ACINTT(vInt8Size)       vInt8Type;\n\ntypedef ACINTT(vDataInSize)     vDataInType;\ntypedef ACINTT(vAluInSize)      vAluInType;\ntypedef ACINTT(vMulInSize)      vMulInType;\ntypedef ACINTT(vAluOutSize)     vAluOutType;\ntypedef ACINTT(vMulOutSize)     vMulOutType;\ntypedef ACINTF(vTruncateBits)   vTruncateType;\ntypedef ACINTT(vDataOutSize)    vDataOutType;\n\nvoid NV_NVDLA_CDMA_CVT_cell (\n     ac_channel<vDataInType>  & chn_data_in\n    ,ac_channel<vAluInType>   & chn_alu_in\n    ,vMulInType               cfg_mul_in\n    ,ACINTF(2)                cfg_in_precision\n    ,ACINTF(2)                cfg_out_precision\n    ,vTruncateType            cfg_truncate\n    ,ac_channel<vDataOutType> & chn_data_out\n    );\n#endif\n\n", "comment_ratio": 0.125}
{"lang": "c", "code": "#ifndef VARIATION_BUILDER_COMMON_H\n#define VARIATION_BUILDER_COMMON_H\n#include \"BWT.h\"\n#include \"BWTInterval.h\"\n#include \"SGUtil.h\"\n#include \"SGWalk.h\"\n#include <queue>\n\n// Result of the bubble construction\n// Used to track statistics\nenum BubbleResultCode\n{\n    BRC_UNKNOWN,\n    BRC_OK,\n    BRC_SOURCE_BROKEN,\n    BRC_SOURCE_BRANCH,\n    BRC_TARGET_BROKEN,\n    BRC_TARGET_BRANCH,\n    BRC_WALK_FAILED,\n    BRC_HB_FAILED,\n    BRC_NO_SOLUTION\n};\n\n// The actual result structure\nstruct BubbleResult\n{\n    std::string targetString;\n    std::string sourceString;\n    double targetCoverage;\n    double sourceCoverage;\n    BubbleResultCode returnCode;\n};\n\n// A directed node in a graph that\n// has not had it's neighbors visited\nstruct BuilderExtensionNode\n{\n    BuilderExtensionNode(Vertex* pX, EdgeDir d) : pVertex(pX), direction(d), distance(0) {}\n    BuilderExtensionNode(Vertex* pX, EdgeDir dir, int dist) : pVertex(pX), direction(dir), distance(dist) {}\n\n    Vertex* pVertex; // the vertex to extend\n    EdgeDir direction; // the direction to extend to\n    int distance; // the total number of nodes from the start to this node.\n};\ntypedef std::queue<BuilderExtensionNode> BuilderExtensionQueue;\ntypedef std::map<std::string, int> StrIntMap;\n\n// Common functions\nnamespace VariationBuilderCommon\n{\n\n// Count the number of extensions above the given threshold\nsize_t countValidExtensions(const AlphaCount64& ac, size_t threshold);\n\n// Returns true if there are multiple characters above the threshold\nbool hasMultipleBranch(const AlphaCount64& ac, size_t threshold);\n\n// Filter out low counts in AlphaCount using a coverage threshold\n// relative to the most frequent count. Returns the number of\n// surviving counts\nsize_t filterLowFrequency(AlphaCount64& ac, double alpha);\n\n// Make a de Bruijn graph string \nstd::string makeDeBruijnVertex(const std::string& v, char edgeBase, EdgeDir direction);\n\n// Add a de Bruijn graph edge to the given graph betwee pX and pY.\nvoid addSameStrandDeBruijnEdges(StringGraph* pGraph, const Vertex* pX, const Vertex* pY, EdgeDir direction);\n\n};\n\n#endif\n\n", "comment_ratio": 0.3170731707317073}
{"lang": "c", "code": "// RUN: %clang_cc1 -analyze -analyzer-checker=core,alpha.core -analyzer-store=region -verify %s\n// expected-no-diagnostics\n\nvoid foo() {\n  int *p = (int*) 0x10000; // Should not crash here.\n  *p = 3;\n}\n\n", "comment_ratio": 0.375}
{"lang": "c", "code": "#ifndef __SGD_DENSE_KERNEL_ONEAPI_H__\n#define __SGD_DENSE_KERNEL_ONEAPI_H__\n\n#include \"algorithms/optimization_solver/sgd/sgd_batch.h\"\n#include \"src/algorithms/kernel.h\"\n#include \"data_management/data/numeric_table.h\"\n#include \"src/algorithms/optimization_solver/iterative_solver_kernel.h\"\n#include \"src/algorithms/optimization_solver/sgd/sgd_dense_kernel.h\"\n#include \"src/services/service_algo_utils.h\"\n\nnamespace daal\n{\nnamespace algorithms\n{\nnamespace optimization_solver\n{\nnamespace sgd\n{\nnamespace internal\n{\nusing namespace daal::data_management;\n\ntemplate <typename algorithmFPType, Method method>\nclass SGDKernelOneAPI : public Kernel\n{\npublic:\n    services::Status compute(HostAppIface * pHost, NumericTable * inputArgument, NumericTablePtr minimum, NumericTable * nIterations,\n                             Parameter<method> * parameter, NumericTable * learningRateSequence, NumericTable * batchIndices,\n                             OptionalArgument * optionalArgument, OptionalArgument * optionalResult, engines::BatchBase & engine)\n    {\n        return services::ErrorMethodNotImplemented;\n    }\n};\n\ntemplate <typename algorithmFPType>\nclass SGDKernelOneAPI<algorithmFPType, miniBatch> : public Kernel\n{\npublic:\n    services::Status compute(HostAppIface * pHost, NumericTable * inputArgument, NumericTablePtr minimum, NumericTable * nIterations,\n                             Parameter<miniBatch> * parameter, NumericTable * learningRateSequence, NumericTable * batchIndices,\n                             OptionalArgument * optionalArgument, OptionalArgument * optionalResult, engines::BatchBase & engine);\n\nprivate:\n    static services::Status makeStep(const uint32_t argumentSize, const services::internal::Buffer<algorithmFPType> & prevWorkValueBuff,\n                                     const services::internal::Buffer<algorithmFPType> & gradientBuff,\n                                     services::internal::Buffer<algorithmFPType> & workValueBuff, const algorithmFPType learningRate,\n                                     const algorithmFPType consCoeff);\n\n    static services::Status vectorNorm(const services::internal::Buffer<algorithmFPType> & x, const uint32_t n, algorithmFPType & norm);\n\n    static services::Status buildProgram(services::internal::sycl::ClKernelFactoryIface & factory);\n\n    enum IndicesStatus\n    {\n        random = 0, /*!< Indices of the terms are generated randomly */\n        user   = 1, /*!< Indices of the terms are provided by user */\n        all    = 2  /*!< All objective function terms are used for computations */\n    };\n};\n\n} // namespace internal\n} // namespace sgd\n} // namespace optimization_solver\n} // namespace algorithms\n} // namespace daal\n\n#endif\n\n", "comment_ratio": 0.10112359550561797}
{"lang": "c", "code": "#ifndef _TUSB_CONFIG_H_\n#define _TUSB_CONFIG_H_\n\n#include <stdint.h>\n#include \"app_conf.h\"\n\n//--------------------------------------------------------------------\n// COMMON CONFIGURATION\n//--------------------------------------------------------------------\n\n#define CFG_TUSB_RHPORT0_MODE      (OPT_MODE_DEVICE | OPT_MODE_HIGH_SPEED)\n#define CFG_TUSB_OS                OPT_OS_CUSTOM\n\n#ifndef CFG_TUSB_DEBUG\n#define CFG_TUSB_DEBUG             0\n#endif\n\n#define CFG_TUSB_MEM_ALIGN         __attribute__ ((aligned(4)))\n\n#define CFG_TUSB_DEBUG_PRINTF     rtos_printf\n\n//--------------------------------------------------------------------\n// DEVICE CONFIGURATION\n//--------------------------------------------------------------------\n\n#define CFG_TUD_EP_MAX            12\n#define CFG_TUD_TASK_QUEUE_SZ     8\n#define CFG_TUD_ENDPOINT0_SIZE    64\n\n#define CFG_TUD_XCORE_INTERRUPT_CORE appconfUSB_INTERRUPT_CORE\n#define CFG_TUD_XCORE_IO_CORE_MASK   (1 << appconfXUD_IO_CORE)\n\n//------------- CLASS -------------//\n#define CFG_TUD_CDC               0\n#define CFG_TUD_MSC               0\n#define CFG_TUD_HID               0\n#define CFG_TUD_MIDI              0\n#define CFG_TUD_AUDIO             1\n#define CFG_TUD_VENDOR            0\n\n//--------------------------------------------------------------------\n// AUDIO CLASS DRIVER CONFIGURATION\n//--------------------------------------------------------------------\nextern const uint16_t tud_audio_desc_lengths[CFG_TUD_AUDIO];\n\n#define CFG_TUD_AUDIO_FUNC_1_DESC_LEN                       tud_audio_desc_lengths[0]\n#define CFG_TUD_AUDIO_FUNC_1_N_AS_INT                       1\n#define CFG_TUD_AUDIO_FUNC_1_CTRL_BUF_SZ                    64\n\n\n#define CFG_TUD_AUDIO_FUNC_1_N_BYTES_PER_SAMPLE_TX          2\n#define CFG_TUD_AUDIO_FUNC_1_N_BYTES_PER_SAMPLE_RX          2\n\n#define CFG_TUD_AUDIO_FUNC_1_N_CHANNELS_TX                  2\n#define CFG_TUD_AUDIO_FUNC_1_N_CHANNELS_RX                  2\n\n// EP and buffer sizes\n#define SAMPLES_PER_FRAME_NOMINAL                   (AUDIO_SAMPLE_RATE / 1000)\n\n#define CFG_TUD_AUDIO_ENABLE_EP_IN                  1\n#define BYTES_PER_TX_FRAME_NOMINAL                  (SAMPLES_PER_FRAME_NOMINAL * CFG_TUD_AUDIO_FUNC_1_N_BYTES_PER_SAMPLE_TX * CFG_TUD_AUDIO_FUNC_1_N_CHANNELS_TX)\n#define CFG_TUD_AUDIO_FUNC_1_EP_IN_SZ               BYTES_PER_TX_FRAME_NOMINAL\n#define CFG_TUD_AUDIO_FUNC_1_EP_IN_SZ_MAX           (CFG_TUD_AUDIO_FUNC_1_EP_IN_SZ)    // Maximum EP IN size for all AS alternate settings used\n#define CFG_TUD_AUDIO_FUNC_1_EP_IN_SW_BUF_SZ        CFG_TUD_AUDIO_FUNC_1_EP_IN_SZ\n\n#define CFG_TUD_AUDIO_ENABLE_EP_OUT                 1\n#define BYTES_PER_RX_FRAME_NOMINAL                  (SAMPLES_PER_FRAME_NOMINAL * CFG_TUD_AUDIO_FUNC_1_N_BYTES_PER_SAMPLE_RX * CFG_TUD_AUDIO_FUNC_1_N_CHANNELS_RX)\n#define CFG_TUD_AUDIO_FUNC_1_EP_OUT_SZ              BYTES_PER_RX_FRAME_NOMINAL\n#define CFG_TUD_AUDIO_FUNC_1_EP_OUT_SZ_MAX          (CFG_TUD_AUDIO_FUNC_1_EP_OUT_SZ + 2)   // Maximum EP IN size for all AS alternate settings used. Plus 2 for CRC\n#define CFG_TUD_AUDIO_FUNC_1_EP_OUT_SW_BUF_SZ       CFG_TUD_AUDIO_FUNC_1_EP_OUT_SZ*3\n\n#endif /* _TUSB_CONFIG_H_ */\n\n", "comment_ratio": 0.1326530612244898}
{"lang": "c", "code": "#pragma once\n#include <aws/iotevents/IoTEvents_EXPORTS.h>\n#include <aws/core/utils/memory/stl/AWSString.h>\n\nnamespace Aws\n{\nnamespace IoTEvents\n{\nnamespace Model\n{\n  enum class DetectorModelVersionStatus\n  {\n    NOT_SET,\n    ACTIVE,\n    ACTIVATING,\n    INACTIVE,\n    DEPRECATED,\n    DRAFT,\n    PAUSED,\n    FAILED\n  };\n\nnamespace DetectorModelVersionStatusMapper\n{\nAWS_IOTEVENTS_API DetectorModelVersionStatus GetDetectorModelVersionStatusForName(const Aws::String& name);\n\nAWS_IOTEVENTS_API Aws::String GetNameForDetectorModelVersionStatus(DetectorModelVersionStatus value);\n} // namespace DetectorModelVersionStatusMapper\n} // namespace Model\n} // namespace IoTEvents\n} // namespace Aws\n\n", "comment_ratio": 0.10638297872340426}
{"lang": "c", "code": "#include <stdlib.h>                      // for malloc\n#include \"Friction_cst.h\"                // for SICONOS_GLOBAL_FRICTION_3D_ADMM\n#include \"NumericsFwd.h\"                 // for SolverOptions\n#include \"SolverOptions.h\"               // for solver_options_create, Solve...\n#include \"frictionContact_test_utils.h\"  // for build_test_collection\n#include \"test_utils.h\"                  // for TestCase\n\nTestCase * build_test_collection(int n_data, const char ** data_collection, int* number_of_tests)\n{\n\n  int n_solvers = 6;\n  *number_of_tests = n_data * n_solvers;\n  TestCase * collection = (TestCase*)malloc((*number_of_tests) * sizeof(TestCase));\n\n  int current = 0;\n  /* for(int d =0; d <n_data; d++) */\n  /* { */\n  /*   // GFC3D, NSGS_WR. */\n  /*   collection[current].filename = data_collection[d]; */\n  /*   collection[current].options = solver_options_create(SICONOS_GLOBAL_FRICTION_3D_NSGS_WR); */\n  /*   collection[current].options->dparam[SICONOS_DPARAM_TOL] = 1e-5; */\n  /*   collection[current].options->iparam[SICONOS_IPARAM_MAX_ITER] = 10000; */\n  /*   current++; */\n  /* } */\n\n  for(int d =0; d <n_data; d++)\n  {\n    // GFC3D, ADMM.\n    collection[current].filename = data_collection[d];\n    collection[current].options = solver_options_create(SICONOS_GLOBAL_FRICTION_3D_ADMM);\n    collection[current].options->dparam[SICONOS_DPARAM_TOL] = 1e-5;\n    collection[current].options->iparam[SICONOS_IPARAM_MAX_ITER] = 1000;\n    collection[current].will_fail = 1; // expected to fail\n    current++;\n  }\n\n  for(int d =0; d <n_data; d++)\n  {\n    // GFC3D, ADMM, set rho strategy\n    collection[current].filename = data_collection[d];\n    collection[current].options = solver_options_create(SICONOS_GLOBAL_FRICTION_3D_ADMM);\n    collection[current].options->dparam[SICONOS_DPARAM_TOL] = 1e-5;\n    collection[current].options->iparam[SICONOS_IPARAM_MAX_ITER] = 10000;\n    collection[current].options->iparam[SICONOS_FRICTION_3D_ADMM_IPARAM_RHO_STRATEGY] = SICONOS_FRICTION_3D_ADMM_RHO_STRATEGY_RESIDUAL_BALANCING;\n    collection[current].will_fail = 1; // expected to fail\n    current++;\n  }\n\n  for(int d =0; d <n_data; d++)\n  {\n    // GFC3D, ADMM, set rho strategy.\n    collection[current].filename = data_collection[d];\n    collection[current].options = solver_options_create(SICONOS_GLOBAL_FRICTION_3D_ADMM);\n    collection[current].options->dparam[SICONOS_DPARAM_TOL] = 1e-5;\n    collection[current].options->iparam[SICONOS_IPARAM_MAX_ITER] = 10000;\n    collection[current].options->iparam[SICONOS_FRICTION_3D_ADMM_IPARAM_RHO_STRATEGY] = SICONOS_FRICTION_3D_ADMM_RHO_STRATEGY_SCALED_RESIDUAL_BALANCING;\n    current++;\n  }\n\n  for(int d =0; d <n_data; d++)\n  {\n    // GFC3D, ADMM, set rho strategy and rescaling\n    collection[current].filename = data_collection[d];\n    collection[current].options = solver_options_create(SICONOS_GLOBAL_FRICTION_3D_ADMM);\n    collection[current].options->dparam[SICONOS_DPARAM_TOL] = 1e-5;\n    collection[current].options->iparam[SICONOS_IPARAM_MAX_ITER] = 30000;\n    collection[current].options->iparam[SICONOS_FRICTION_3D_ADMM_IPARAM_RHO_STRATEGY] = SICONOS_FRICTION_3D_ADMM_RHO_STRATEGY_RESIDUAL_BALANCING;\n    collection[current].options->iparam[SICONOS_FRICTION_3D_IPARAM_RESCALING] = SICONOS_FRICTION_3D_RESCALING_SCALAR;\n    current++;\n  }\n\n  for(int d =0; d <n_data; d++)\n  {\n    // GFC3D, ADMM, set rho strategy and rescaling\n    collection[current].filename = data_collection[d];\n    collection[current].options = solver_options_create(SICONOS_GLOBAL_FRICTION_3D_ADMM);\n    collection[current].options->dparam[SICONOS_DPARAM_TOL] = 1e-5;\n    collection[current].options->iparam[SICONOS_IPARAM_MAX_ITER] = 30000;\n    collection[current].options->iparam[SICONOS_FRICTION_3D_ADMM_IPARAM_RHO_STRATEGY] = SICONOS_FRICTION_3D_ADMM_RHO_STRATEGY_RESIDUAL_BALANCING;\n    collection[current].options->iparam[SICONOS_FRICTION_3D_IPARAM_RESCALING] = SICONOS_FRICTION_3D_RESCALING_BALANCING_M;\n    current++;\n  }\n  for(int d =0; d <n_data; d++)\n  {\n    // GFC3D, ADMM, set rho strategy and rescaling\n    collection[current].filename = data_collection[d];\n    collection[current].options = solver_options_create(SICONOS_GLOBAL_FRICTION_3D_ADMM);\n    collection[current].options->dparam[SICONOS_DPARAM_TOL] = 1e-5;\n    collection[current].options->iparam[SICONOS_IPARAM_MAX_ITER] = 100000;\n    collection[current].options->iparam[SICONOS_FRICTION_3D_ADMM_IPARAM_RHO_STRATEGY] = SICONOS_FRICTION_3D_ADMM_RHO_STRATEGY_RESIDUAL_BALANCING;\n    collection[current].options->iparam[SICONOS_FRICTION_3D_IPARAM_RESCALING] = SICONOS_FRICTION_3D_RESCALING_BALANCING_MHHT;\n    current++;\n  }\n  return collection;\n}\n\n", "comment_ratio": 0.14035087719298245}
{"lang": "c", "code": "#ifndef EESEN_GPUCOMPUTE_CTC_UTILS_H_\n#define EESEN_GPUCOMPUTE_CTC_UTILS_H_\n\n//#if HAVE_CUDA == 1\n\n/*\n * Some numeric limits and operations. These limits and operations\n * are used in CTC computation/evaluation.\n */\ntemplate <typename T>\nstruct NumericLimits;\n\n// some compilers (Mac) require the following 8 \"const\" to be \"constexpr\"?\ntemplate <>\nstruct NumericLimits<float>\n{\n  static constexpr float log_zero_ = -1e30f;\n  static constexpr float exp_limit_ = 88.722839f;\n  static constexpr float log_inf_ = 1e30f;\n  static constexpr float max_ = 3.4028235e+038f;\n};\n\ntemplate <>\nstruct NumericLimits<double>\n{\n  static constexpr double log_zero_ = -1e100;\n  static constexpr double exp_limit_ = 709.78271289338397;\n  static constexpr double log_inf_ = 1e100;\n  static constexpr double max_ = 1.7976931348623157e+308;\n};\n\n#if HAVE_CUDA == 1\n\n// a + b, where a and b are assumed to be in the log scale \ntemplate <typename T>\nstatic inline __host__ __device__ T AddAB(T a, T b)\n{\n  if (a == NumericLimits<T>::log_zero_ || b == NumericLimits<T>::log_zero_)\n    return NumericLimits<T>::log_zero_;\n  else\n    return a + b;\n}\n\n// a - b, where a and b are assumed to be in the log scale\ntemplate <typename T>\nstatic inline __host__ __device__ T SubAB(T a, T b)\n{\n  if (a == NumericLimits<T>::log_zero_)\n    return NumericLimits<T>::log_zero_;\n  else if (b == NumericLimits<T>::log_zero_)\n    return NumericLimits<T>::log_inf_;\n  else\n    return a - b;\n}\n\n// exp(a)\ntemplate <typename T>\nstatic inline __host__ __device__ T ExpA(T a)\n{\n  if (a <= NumericLimits<T>::log_zero_)\n    return 0;\n  else if (a >= NumericLimits<T>::exp_limit_)\n    return NumericLimits<T>::max_;\n  else\n    return exp(a);\n}\n\n// Approximation of  log(a + b) = log(a) + log(1 + b/a), if b < a\n//                              = log(b) + log(1 + a/b), if a < b\ntemplate <typename T>\nstatic inline __host__ __device__ T LogAPlusB(T a, T b) // x and y are in log scale and so is the result\n  {\n    if (b < a)\n      return AddAB(a, log(1 + ExpA(SubAB(b, a))));\n    else\n      return AddAB(b, log(1 + ExpA(SubAB(a, b))));\n  }\n\n#else\n\n// exp(a)\ntemplate <typename T>\nstatic inline T ExpA(T a)\n{\n  return exp(a);\n}\n\n#endif // HAVE_CUDA\n\n#endif\n\n", "comment_ratio": 0.21818181818181817}
{"lang": "c", "code": "#ifndef NET_SPDY_SPDY_SESSION_TEST_UTIL_H_\n#define NET_SPDY_SPDY_SESSION_TEST_UTIL_H_\n\n#include <stdint.h>\n\n#include <string>\n\n#include \"base/message_loop/message_loop.h\"\n#include \"base/pending_task.h\"\n\nnamespace net {\n\n// SpdySessionTestTaskObserver is a MessageLoop::TaskObserver that monitors the\n// completion of all tasks executed by the current MessageLoop, recording the\n// number of tasks that refer to a specific function and filename.\nclass SpdySessionTestTaskObserver : public base::MessageLoop::TaskObserver {\n public:\n  // Creates a SpdySessionTaskObserver that will record all tasks that are\n  // executed that were posted by the function named by |function_name|, located\n  // in the file |file_name|.\n  // Example:\n  //  file_name = \"foo.cc\"\n  //  function = \"DoFoo\"\n  SpdySessionTestTaskObserver(const std::string& file_name,\n                              const std::string& function_name);\n  ~SpdySessionTestTaskObserver() override;\n\n  // Implements MessageLoop::TaskObserver.\n  void WillProcessTask(const base::PendingTask& pending_task) override;\n  void DidProcessTask(const base::PendingTask& pending_task) override;\n\n  // Returns the number of tasks posted by the given function and file.\n  uint16_t executed_count() const { return executed_count_; }\n\n private:\n  uint16_t executed_count_;\n  std::string file_name_;\n  std::string function_name_;\n};\n\n}  // namespace net\n\n#endif  // NET_SPDY_SPDY_SESSION_TEST_UTIL_H_\n\n", "comment_ratio": 0.3333333333333333}
{"lang": "c", "code": "#import <Transparency/GPBMessage.h>\n\n@class NSMutableDictionary;\n\n__attribute__((visibility(\"hidden\")))\n@interface GPBStruct : GPBMessage\n{\n}\n\n+ (id)descriptor;\n\n// Remaining properties\n@property(retain, nonatomic) NSMutableDictionary *fields; // @dynamic fields;\n@property(readonly, nonatomic) unsigned long long fields_Count; // @dynamic fields_Count;\n\n@end\n\n\n", "comment_ratio": 0.3333333333333333}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n\n@class EBCommentsView;\n@protocol EBCommentsViewDelegate <NSObject>\n\n- (void)commentsView:(EBCommentsView *)view\n   didPostNewComment:(NSString *)commentText;\n\n@end\n\n", "comment_ratio": 0.17391304347826086}
{"lang": "c", "code": "//\n// Created by nbrei on 4/8/19.\n//\n\n#ifndef JANA2_JEVENTSOURCEARROW_H\n#define JANA2_JEVENTSOURCEARROW_H\n\n#include <JANA/JFactorySet.h>\n\n#include <JANA/Engine/JArrow.h>\n#include <JANA/Engine/JMailbox.h>\n\nusing Event = std::shared_ptr<JEvent>;\nusing EventQueue = JMailbox<Event>;\n\nclass JEventPool;\n\nclass JEventSourceArrow : public JArrow {\nprivate:\n    JEventSource* _source;\n    EventQueue* _output_queue;\n    std::shared_ptr<JEventPool> _pool;\n    std::vector<Event> _chunk_buffer;\n    JLogger _logger;\n\npublic:\n    JEventSourceArrow(std::string name, JEventSource* source, EventQueue* output_queue, std::shared_ptr<JEventPool> pool);\n    void initialize() final;\n    void execute(JArrowMetrics& result, size_t location_id) final;\n};\n\n#endif //JANA2_JEVENTSOURCEARROW_H\n\n", "comment_ratio": 0.12121212121212122}
{"lang": "c", "code": "#ifndef _EVAL_H_\n#define _EVAL_H_\n\n#include \"ast.h\"\n\nstruct _EVAL_ERROR {\n    char *message;\n\n    struct _EVAL_ERROR *__next;\n};\n\nstruct _EVAL_CONTEXT {\n    bool success;\n    LONG_DOUBLE result;\n\n    struct _EVAL_ERROR *error;\n};\n\ntypedef struct _EVAL_ERROR eval_error;\ntypedef struct _EVAL_CONTEXT eval_context;\n\n// Ausdruck auswerten und Ergebnis zur\u00fcckliefern.\n// R\u00fcckgabewert sollte vom Aufrufer mit free()\n// freigegeben werden.\neval_context *eval(ast_node *tree);\n\nLONG_DOUBLE eval_expr(eval_context *ctx, ast_node *tree);\n\nvoid evalprintf(ast_node *tree);\n// Auswertungskontext freigeben\nvoid end_eval(eval_context *ctx);\n\n#endif // _EVAL_H_\n\n", "comment_ratio": 0.125}
{"lang": "c", "code": "#ifndef PBBAM_SNR_H\n#define PBBAM_SNR_H\n\n#include <pbbam/Config.h>\n\n#include <pbcopper/data/SNR.h>\n\nnamespace PacBio {\nnamespace BAM {\n\nusing SNR PBBAM_DEPRECATED = PacBio::Data::SNR;\n\nPBBAM_DEPRECATED constexpr auto ClampSNR = PacBio::Data::ClampSNR;\n\n}  // namespace BAM\n}  // namespace PacBio\n\n#endif  // PBBAM_SNR_H\n\n", "comment_ratio": 0.15789473684210525}
{"lang": "c", "code": "#include \"stm32f10x.h\"                  // Device header\r\n\r\n//Wheel PWM Init\r\n//500 HZ PWM and Duty cycle is 50%\r\nvoid TIM3_CH12_PWM_init(void){\r\n\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);\r\n\t\r\n\tGPIO_InitTypeDef GPIO_InitStruct;\r\n\t// PA6 Init for PWM CH1 Right Wheel\r\n\tGPIO_InitStruct.GPIO_Pin = GPIO_Pin_6;\r\n\tGPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP;\r\n\tGPIO_InitStruct.GPIO_Speed = GPIO_Speed_2MHz;\r\n\tGPIO_Init(GPIOA,&GPIO_InitStruct);\r\n\t\r\n\t// PA7 Init for PWM CH2 Left Wheel\r\n\tGPIO_InitStruct.GPIO_Pin = GPIO_Pin_7;\r\n\tGPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP;\r\n\tGPIO_InitStruct.GPIO_Speed = GPIO_Speed_2MHz;\r\n\tGPIO_Init(GPIOA,&GPIO_InitStruct);\r\n\t\r\n\t//Tim3 Set up\r\n\tRCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);\r\n\tTIM_TimeBaseInitTypeDef TIM_InitStruct;\r\n\tTIM_InitStruct.TIM_Prescaler = 1440-1;\r\n\tTIM_InitStruct.TIM_CounterMode = TIM_CounterMode_Up;\r\n\tTIM_InitStruct.TIM_Period = 100-1;\r\n\tTIM_InitStruct.TIM_ClockDivision = TIM_CKD_DIV1; \r\n\tTIM_InitStruct.TIM_RepetitionCounter = 0;\r\n\tTIM_TimeBaseInit(TIM3,&TIM_InitStruct);\r\n\tTIM_Cmd(TIM3,ENABLE);\r\n\t\r\n\t//Enable Tim3 Ch1 PWM Right-Wheel\r\n\tTIM_OCInitTypeDef OC_InitStruct;\r\n\tOC_InitStruct.TIM_OCMode = TIM_OCMode_PWM1;\r\n\tOC_InitStruct.TIM_Pulse = 1-1;//100-1; // 1000 / 2000 = 0.5 duty cycle\r\n\tOC_InitStruct.TIM_OutputState = TIM_OutputState_Enable;\r\n\tOC_InitStruct.TIM_OCPolarity = TIM_OCPolarity_High;\r\n\tTIM_OC1Init(TIM3,&OC_InitStruct);\r\n\tTIM_OC1PreloadConfig(TIM3,TIM_OCPreload_Enable);\r\n\t\r\n\t//Enable Tim3 Ch2 PWM Left-Wheel\r\n\tOC_InitStruct.TIM_OCMode = TIM_OCMode_PWM1;\r\n\tOC_InitStruct.TIM_Pulse = 1-1;//100-1; // 1000 / 2000 = 0.5 duty cycle\r\n\tOC_InitStruct.TIM_OutputState = TIM_OutputState_Enable;\r\n\tOC_InitStruct.TIM_OCPolarity = TIM_OCPolarity_High;\r\n\tTIM_OC2Init(TIM3,&OC_InitStruct);\r\n\tTIM_OC2PreloadConfig(TIM3, TIM_OCPreload_Enable);\r\n}\r\n\r\n\r\nvoid TIM2_Init(void){\r\n\tRCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);\r\n\tTIM_TimeBaseInitTypeDef TIM_InitStruct;\r\n\tTIM_InitStruct.TIM_Prescaler = 720-1;  \r\n\tTIM_InitStruct.TIM_CounterMode = TIM_CounterMode_Up;\r\n\tTIM_InitStruct.TIM_Period = 2500-1; // 25ms // \r\n\tTIM_InitStruct.TIM_ClockDivision = TIM_CKD_DIV1; \r\n\tTIM_InitStruct.TIM_RepetitionCounter = 0;\r\n\tTIM_TimeBaseInit(TIM2,&TIM_InitStruct);\r\n\tTIM_Cmd(TIM2,ENABLE);\r\n\t\r\n\t//Enable update event for Timer2\r\n\tTIM_ITConfig(TIM2, TIM_IT_Update, ENABLE);\r\n\tNVIC_EnableIRQ(TIM2_IRQn);\r\n}\r\n\r\nvoid USART2_init(void){\r\n\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);\r\n\tGPIO_InitTypeDef GPIO_InitStructure;\r\n\tGPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;\r\n\tGPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\r\n\tGPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;\r\n\tGPIO_Init(GPIOA, &GPIO_InitStructure);\r\n\tGPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;\r\n\tGPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;\r\n\tGPIO_Init(GPIOA, &GPIO_InitStructure);\r\n\t//USART2 ST-LINK USB\r\n\tRCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2,ENABLE);\r\n\tUSART_InitTypeDef USART_InitStructure;\r\n\tUSART_InitStructure.USART_BaudRate = 115200;\r\n\tUSART_InitStructure.USART_WordLength = USART_WordLength_8b;\r\n\tUSART_InitStructure.USART_StopBits = USART_StopBits_1;\r\n\tUSART_InitStructure.USART_Parity = USART_Parity_No;\r\n\tUSART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;\r\n\tUSART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;\r\n\tUSART_Init(USART2, &USART_InitStructure);\r\n\tUSART_Cmd(USART2, ENABLE);\r\n\t// Enable the USART2 RX Interrupt\t\r\n\tNVIC_InitTypeDef NVIC_InitStructure;\r\n\tUSART_ITConfig(USART2, USART_IT_RXNE, ENABLE);\r\n\tNVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;\r\n\tNVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;\r\n\tNVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;\r\n\tNVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;\r\n\tNVIC_Init(&NVIC_InitStructure);\r\n}\r\n\r\n// SPI MASTER init\r\n// PB12 IR LED  SS\r\nvoid SPI2_init(void){\r\n\tRCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2, ENABLE);\r\n\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB | RCC_APB2Periph_AFIO, ENABLE);\r\n\t\r\n\tGPIO_InitTypeDef GPIO_InitStructure;\r\n\tGPIO_InitStructure.GPIO_Pin = GPIO_Pin_14;\r\n\tGPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;\r\n\tGPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;\r\n\tGPIO_Init(GPIOB, &GPIO_InitStructure);\r\n\t\r\n\tGPIO_InitStructure.GPIO_Pin = GPIO_Pin_13 | GPIO_Pin_15;\r\n\tGPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;\r\n\tGPIO_Init(GPIOB, &GPIO_InitStructure);\r\n\t\r\n\tGPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;\r\n\tGPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;\r\n\tGPIO_Init(GPIOB, &GPIO_InitStructure);\r\n\t\r\n\t\r\n\t//SPI Configuration\r\n\tSPI_InitTypeDef SPI_InitStructure;\r\n\tSPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;\r\n\tSPI_InitStructure.SPI_Mode = SPI_Mode_Master;\r\n\tSPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;\r\n\tSPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;\r\n\tSPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;\r\n\tSPI_InitStructure.SPI_NSS = SPI_NSS_Soft;\r\n\tSPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_256;\r\n\tSPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;\r\n\tSPI_Init(SPI2, &SPI_InitStructure);\r\n\t// Enable SPI2\r\n\tSPI_Cmd(SPI2, ENABLE);\r\n}\r\n\r\n// Right Wheel Counter Init PA1 Timer2\r\nvoid Right_Wheel_Cnt_init(void){\r\n\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA| RCC_APB2Periph_AFIO, ENABLE);\r\n\t\r\n\tGPIO_InitTypeDef GPIO_InitStruct;\r\n\t// PA1 Init for Right Wheel Counter\r\n\tGPIO_InitStruct.GPIO_Pin = GPIO_Pin_1;\r\n\tGPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;\r\n\tGPIO_InitStruct.GPIO_Speed = GPIO_Speed_2MHz;\r\n\tGPIO_Init(GPIOA,&GPIO_InitStruct);\r\n\t\r\n\t// EXTI Configuration\r\n\tGPIO_EXTILineConfig(GPIO_PortSourceGPIOA, GPIO_PinSource1);\r\n\tEXTI_InitTypeDef EXTI_InitStruct;\r\n\tEXTI_InitStruct.EXTI_Line = EXTI_Line1;\r\n\tEXTI_InitStruct.EXTI_Mode = EXTI_Mode_Interrupt;\r\n\tEXTI_InitStruct.EXTI_Trigger = EXTI_Trigger_Rising;\r\n\tEXTI_InitStruct.EXTI_LineCmd = ENABLE;\r\n\tEXTI_Init(&EXTI_InitStruct);\r\n\t\r\n\t// Enable Interrupt\r\n\tNVIC_InitTypeDef NVIC_InitStruct;\r\n\tNVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;\r\n  NVIC_InitStruct.NVIC_IRQChannel = EXTI1_IRQn;\r\n\tNVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = 0x02;\r\n\tNVIC_Init(&NVIC_InitStruct);\r\n\t\r\n\t//NVIC_EnableIRQ(EXTI1_IRQn);\r\n}\r\n\r\n// Left Wheel Counter Init PB6 Timer4\r\nvoid Left_Wheel_Cnt_init(void){\r\n\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB| RCC_APB2Periph_AFIO, ENABLE);\r\n\t\r\n\tGPIO_InitTypeDef GPIO_InitStruct;\r\n\t// PB6 Init for Left Wheel Counter\r\n\tGPIO_InitStruct.GPIO_Pin = GPIO_Pin_6;\r\n\tGPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;\r\n\tGPIO_InitStruct.GPIO_Speed = GPIO_Speed_2MHz;\r\n\tGPIO_Init(GPIOB,&GPIO_InitStruct);\r\n\t\r\n\t// EXTI Configuration\r\n\tGPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource6);\r\n\tEXTI_InitTypeDef EXTI_InitStruct;\r\n\tEXTI_InitStruct.EXTI_Line = EXTI_Line6;\r\n\tEXTI_InitStruct.EXTI_Mode = EXTI_Mode_Interrupt;\r\n\tEXTI_InitStruct.EXTI_Trigger = EXTI_Trigger_Rising;\r\n\tEXTI_InitStruct.EXTI_LineCmd = ENABLE;\r\n\tEXTI_Init(&EXTI_InitStruct);\r\n\t\r\n\t// Enable Interrupt\r\n\t\r\n\tNVIC_InitTypeDef NVIC_InitStruct;\r\n\tNVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;\r\n  NVIC_InitStruct.NVIC_IRQChannel = EXTI9_5_IRQn;\r\n\tNVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = 0x02;\r\n\tNVIC_Init(&NVIC_InitStruct);\r\n\t\r\n\t//NVIC_EnableIRQ(EXTI9_5_IRQn);\r\n}\r\n\r\n// Wheel Direction Init\r\n// PC15 Right Dir\r\n// PA0 Left Dir\r\nvoid Wheel_Dir_Init(void){\r\n\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOC, ENABLE);\r\n\t\r\n\tGPIO_InitTypeDef GPIO_InitStruct;\r\n\t//PC15\r\n\tGPIO_InitStruct.GPIO_Pin = GPIO_Pin_15;\r\n\tGPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;\r\n\tGPIO_InitStruct.GPIO_Speed = GPIO_Speed_2MHz;\r\n\tGPIO_Init(GPIOC,&GPIO_InitStruct);\r\n\t\r\n\t//PA0\r\n\tGPIO_InitStruct.GPIO_Pin = GPIO_Pin_0;\r\n\tGPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;\r\n\tGPIO_InitStruct.GPIO_Speed = GPIO_Speed_2MHz;\r\n\tGPIO_Init(GPIOA,&GPIO_InitStruct);\r\n}\r\n\r\n// On-board button init PB8\r\nvoid Button_init(void){\r\n\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB|RCC_APB2Periph_AFIO, ENABLE);\r\n\t\r\n\tGPIO_InitTypeDef GPIO_InitStruct;\r\n\tGPIO_InitStruct.GPIO_Pin = GPIO_Pin_8;\r\n\tGPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;\r\n\tGPIO_InitStruct.GPIO_Speed = GPIO_Speed_2MHz;\r\n\tGPIO_Init(GPIOB,&GPIO_InitStruct);\r\n\t\r\n\t\t// EXTI Configuration\r\n\tGPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource8);\r\n\tEXTI_InitTypeDef EXTI_InitStruct;\r\n\tEXTI_InitStruct.EXTI_Line = EXTI_Line8;\r\n\tEXTI_InitStruct.EXTI_Mode = EXTI_Mode_Interrupt;\r\n\tEXTI_InitStruct.EXTI_Trigger = EXTI_Trigger_Falling;\r\n\tEXTI_InitStruct.EXTI_LineCmd = ENABLE;\r\n\tEXTI_Init(&EXTI_InitStruct);\r\n\r\n\tNVIC_EnableIRQ(EXTI9_5_IRQn);\r\n}\r\n\r\n// On-board LED init PB7\r\nvoid OnBoard_lED_Init(void){\r\n\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);\r\n\t\r\n\tGPIO_InitTypeDef GPIO_InitStructure;\r\n\tGPIO_InitStructure.GPIO_Pin   = GPIO_Pin_7;\r\n  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;\r\n  GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;\r\n\tGPIO_Init(GPIOB, &GPIO_InitStructure);\r\n}\r\n\r\n\n", "comment_ratio": 0.14516129032258066}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n\nNS_ASSUME_NONNULL_BEGIN\n/**\n Provides extensions method for `UIColor`.\n */\n@interface UIColor (HZExtend)\n\n/**\n Creates and returns a color object using the specified RGB hex value.\n \n @param rgbHex The rgb value such as 0x66CCFF.\n \n @return The color object. The color information represented by this object is in the device RGB colorspace.\n */\n+ (UIColor *)colorForHex:(NSInteger)rgbHex;\n\n/**\n Creates and returns a color object using the specified opacity and RGB hex value.\n \n @param rgbHex The rgb value such as 0x66CCFF.\n @param alpha The opacity value of the color object,specified as a value from 0.0 to 1.0.\n \n @return The color object. The color information represented by this object is in the device RGB colorspace.\n */\n+ (UIColor *)colorForHex:(NSInteger)rgbHex alpha:(CGFloat)alpha;\n\n/**\n Creates and returns a color object from hex string. e.g @\"#F0F\", @\"#66ccff 0.9\"\n \n @param string  The hex and alpha string value for the new color.\n @return An UIColor object from string, or nil if an error occurs.\n */\n+ (nullable UIColor *)colorForString:(NSString *)string;\n\n@end\n\nNS_ASSUME_NONNULL_END\n\n", "comment_ratio": 0.15217391304347827}
{"lang": "c", "code": "// Write a C program to calculate the average, geometric and harmonic mean of n elements\n\n// arithmatic mean is nothing bu t the average only\n// geometry mean is multiply all the \u201cn\u201d numbers together and take the \u201cnth root of them\n// harmonic mean is the reciprocal of arithmatic mean\n\n#include <stdio.h>\n#include <conio.h>\n#include <math.h>\n\nint main()\n{\n    float n, count = 0.0, sum = 0.0, a_mean = 0.0, g_mean = 0.0, h_mean = 0.0, reciprocal = 0.0, product = 1.0;\n\n    printf(\"\\nenter elements to calculate all mean (-1 to exit): \");\n    scanf(\"%f\", &n);\n\n    while (n != -1.0)\n    {\n        printf(\"\\nenter the element: \");\n        sum = sum + n;\n        product = product * n;\n        reciprocal = reciprocal + (1 / n);\n        count++;\n        scanf(\"%f\", &n);\n    }\n    a_mean = sum / count;\n    g_mean = pow(product, (1 / count));\n    h_mean = count / reciprocal;\n\n    printf(\"\\naritnmatic_mean = %f\", a_mean);\n    printf(\"\\ngeometry mean = %f\", g_mean);\n    printf(\"\\nharmonic mean = %f\\n\", h_mean);\n\n    return 0;\n}\n\n", "comment_ratio": 0.10810810810810811}
{"lang": "c", "code": "//\n//  BaseResponse.h\n//  Pods\n//\n//  Created by \u6768\u78ca on 15/7/15.\n//\n//\n\n#import <Foundation/Foundation.h>\n#import \"BJIMConstants.h\"\n\n@interface BaseResponse : MTLModel<MTLJSONSerializing>\n\n@property (nonatomic, assign) NSInteger code;\n@property (nonatomic, assign) NSString *msg;\n@property (nonatomic, strong) id data;\n@property (nonatomic, assign) NSInteger ts;\n\n\n- (id)arrayData;\n- (id)dictionaryData;\n@end\n\n", "comment_ratio": 0.30434782608695654}
{"lang": "c", "code": "#import \"NSObject.h\"\n\n@class HSNetworkInterfaceManager;\n\n@protocol HSNetworkInterfaceManagerDelegate <NSObject>\n- (void)networkInterfaceManager:(HSNetworkInterfaceManager *)arg1 didUpdateWiFiInterfaceStatus:(unsigned long long)arg2;\n- (void)networkInterfaceManager:(HSNetworkInterfaceManager *)arg1 didUpdateBluetoothInterfaceStatus:(unsigned long long)arg2;\n@end\n\n\n", "comment_ratio": 0.3125}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n@protocol ZJTopViewDelegate <NSObject>\n\n/**\n \u8fd4\u56de\u4e8b\u4ef6\n */\n- (void)back;\n- (void)setRate:(float)rate;\n\n/**\n \u622a\u56fe\n */\n- (void)fetchScreen;\n/**\n GIF\u89c6\u9891\u622a\u5c4f\n */\n- (void)gifScreenshot;\n\n/**\n \u4e0b\u8f7d\u89c6\u9891\n */\n- (void)downloadVideo;\n/**\n airPlay\n */\n- (void)airPlayVideo;\n@end\n@interface ZJTopView : UIView\n@property(weak,nonatomic) id<ZJTopViewDelegate> delegate;\n@property(assign,nonatomic) float  rate;\n/**\n \u6807\u9898\n */\n@property(copy,nonatomic) NSString * title;\n/**\n \u500d\u901f\u5f521.0X\n */\n- (void)resetRate;\n- (void)resetFrame:(BOOL)fullScreen;\n\n/**\n \u8bbe\u7f6e\u4e0b\u8f7d\u5b8c\u6210\u72b6\u6001\n */\n- (void)downloadFinish;\n@end\n\n", "comment_ratio": 0.12962962962962962}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n\n/**\n *  Table name\n */\nextern NSString * const GPKG_GPTM_TABLE_NAME;\n\n/**\n *  Column names\n */\nextern NSString * const GPKG_GPTM_COLUMN_PK1;\nextern NSString * const GPKG_GPTM_COLUMN_PK2;\nextern NSString * const GPKG_GPTM_COLUMN_GEOPACKAGE_ID;\nextern NSString * const GPKG_GPTM_COLUMN_TABLE_NAME;\nextern NSString * const GPKG_GPTM_COLUMN_LAST_INDEXED;\n\n/**\n *  Table Metadata\n */\n@interface GPKGTableMetadata : NSObject\n\n/**\n *  GeoPackage id\n */\n@property (nonatomic, strong) NSNumber *geoPackageId;\n\n/**\n *  Table name\n */\n@property (nonatomic, strong) NSString *tableName;\n\n/**\n *  Last indexed date\n */\n@property (nonatomic, strong) NSDate *lastIndexed;\n\n@end\n\n", "comment_ratio": 0.15217391304347827}
{"lang": "c", "code": "#include <stdlib.h>\n#include \"audio.h\"\n\n// Fonction d'aide pour g\u00e9rer les probl\u00e8mes d'allocation de m\u00e9moire\nstatic void *merr(void *p) {\n    if (p == NULL) {\n        fprintf(stderr, \"Erreur malloc dans audio.c\\n\");\n        exit(1);\n    }\n    return p;\n}\n\n// Le code li\u00e9 \u00e0 l'audio est inspir\u00e9 la doc de la SDL1\nstatic SDL_AudioSpec wav_spec; // Caract\u00e9ristique du fichier audio\nstatic Sons playing = {.data = NULL, .len = 0, .max_size = 10}; // Liste des fichier audios en cours de lecture\nstatic Sons samples; // Liste de tous les fichiers\nstatic int _volume = SDL_MIX_MAXVOLUME;\nstatic int _audio_actif = 1;\n\n// Liste des fichiers audio \u00e0 charger\n#define SAMPLES_COUNT 6\nconst char *sons_chemin[SAMPLES_COUNT] = {\n    \"data/sons/music.wav\",\n    \"data/sons/pacman_chomp.wav\",\n    \"data/sons/pacman_eatghost.wav\",\n    \"data/sons/pacman_eatfruit.wav\",\n    \"data/sons/pacman_beginning.wav\",\n    \"data/sons/pacman_death.wav\",\n};\n// Le fichier doit-il \u00eatre rejou\u00e9 lorsqu'il est fini ? \n// Correspond au m\u00eame que sons_chemin\nconst int looping[SAMPLES_COUNT] = {\n    1, 1, 0, 0, 0, 0\n};\n\n// Permet d'avancer la lecture du fichier audio\n// Provient de la doc SDL1\nstatic void retour_audio(void *userdata, Uint8 *stream, int len) {\n    Sons *sons = (Sons*) userdata;\n\n    for (int i = 0; i < sons->len; i++) {\n        Son *s = sons->data[i];\n        if (!s->playing) {\n            continue;\n        }\n        if (s->curr >= s->len) {\n            if (s->loop) {\n                s->curr = 0;\n            }\n            else {\n                s->playing = 0;\n                continue;\n            }\n        }\n        // Si le temps restant est plus petit que le temps \u00e0 jouer, alors ne jouer que le temps restant:\n        len = ( s->curr + len > s->len ? s->len - s->curr : len);\n        // Additionne les sons en cours de lecture\n        SDL_MixAudio(stream, s->buff + s->curr, len, _volume);\n        // Fais avancer l'audio\n        s->curr += len;\n    }\n}\n\n// Chargement des sons\nvoid init_sons() {\n    // Initialisation des de playing\n    playing.data = merr(malloc(sizeof(Son*) * playing.max_size));\n    for (int i = 0; i < playing.max_size; i++) {\n        playing.data[i] = merr(malloc(sizeof(Son)));\n    }\n\n    samples.data = merr(malloc(sizeof(Son*) * SAMPLES_COUNT));\n    for (int i = 0; i < SAMPLES_COUNT; i++) {\n        samples.data[i] = merr(calloc(1, sizeof(Son)));\n    }\n    // Charge chaque fichier dans samples\n    samples.len = SAMPLES_COUNT;\n    for (int i = 0; i < SAMPLES_COUNT; i++) {\n        if (SDL_LoadWAV(sons_chemin[i], &wav_spec, &samples.data[i]->buff, &samples.data[i]->len) != NULL ){\n            samples.data[i]->loop = looping[i];\n            wav_spec.callback = retour_audio;\n            wav_spec.userdata = &playing;\n        }\n        else {\n            fprintf(stderr, \"erreur chargement %s\\n\", sons_chemin[i]);\n        }\n    }\n\n    // Ouverture du p\u00e9riph\u00e9rique audio\n    if (SDL_OpenAudio(&wav_spec, NULL) < 0 ) {\n    #ifdef DEBUG\n        fprintf(stderr, \"Erreur lors de l'ouverture de l'audio: %s\\n\", SDL_GetError());\n    #endif\n        _audio_actif = 0;\n        return;\n    }\n    // Active la lecture du son\n    SDL_PauseAudio(0);\n}\n\n// Redimensionne playing et inialise les nouveaux \u00e9l\u00e9ments\nstatic void resize_playing() {\n    playing.max_size *= 2;\n    playing.data = merr(realloc(playing.data, sizeof(Son*) * playing.max_size));\n    for (int i = playing.len; i < playing.max_size; i++) {\n        playing.data[i] = merr(calloc(1, sizeof(Son)));\n    }\n}\n\n// Ajoute un audio \u00e0 playing pour \u00eatre ensuite jou\u00e9\nint charger_fichier_audio(int id) {\n    // Si playing est complet, augmenter sa taille\n    if (playing.len == playing.max_size) {\n        resize_playing();\n    }\n    // Copie l'audio de samples vers playing\n    memcpy(playing.data[playing.len], samples.data[id], sizeof(Son));\n    playing.data[playing.len]->playing = 1;\n    playing.len++;\n    // Renvoie l'index du nouveau son\n    return playing.len - 1;\n}\n\n// Mettre en pause le son ou non\nvoid pause_son(int index, int pause) {\n    playing.data[index]->playing = !pause;\n}\n\n// Le fichier est-il en cours de lecture ?\nint is_playing(int index) {\n    return playing.data[index]->playing;\n}\n\n// Remet un son au d\u00e9but et en pause\nvoid stop_son(int index) {\n    playing.data[index]->playing = 0;\n    playing.data[index]->curr = 0;\n}\n\n// Active et d\u00e9sactive le son lorsque m est press\u00e9\nvoid toggle_volume(int touche) {\n    if (touche == SDLK_m) {\n        _volume = (_volume == 0) ? SDL_MIX_MAXVOLUME : 0; // Echange le volume entre volume max et coup\u00e9\n    }\n}\n\nint volume() {\n    return _volume;\n}\n\nint audio_actif() {\n    return _audio_actif;\n}\n\n", "comment_ratio": 0.18181818181818182}
{"lang": "c", "code": "#ifndef CARDS_H\n#define CARDS_H\n\nenum cardSuit {CLUBS, DIAMONDS, HEARTS, SPADES};\n\ntypedef int cardRank; //2=deuce, 3=trey, 4=four,... 10=ten,\n\t\t      //11=Jack, 12=Queen, 13=King, 14=Ace\n\nclass playingCard {\n    private:\n\tcardSuit suit;\n\tcardRank rank;\n\n    public:\n\t//default constructor\n\tplayingCard(cardSuit = CLUBS, cardRank = 2);\n\n\t//inspectors\n\tcardRank theRank() const;\n\tcardSuit theSuit() const;\n\n\t//display\n\tvoid print() const; //for example: 2S, 9D, TH, QC, AD\n};\n\nclass deckOfCards {\n    private:\n\tint deck[52];\n\tint cardsInDeck;\n\n    public:\n\t//default constructor\n\tdeckOfCards();\n\n\t//inspector\n\tint deckEmpty() const; //answer whether the deck is empty\n\n\t//modifiers\n\tvoid shuffle();    //Replace all 52 cards into the deck\n\tplayingCard deal();//Return 1 card at random. The card\n\t\t\t   //\tis removed from the deck.\n};\n#endif\n\n", "comment_ratio": 0.3333333333333333}
{"lang": "c", "code": "#ifndef _TYPES_H\n#define _TYPES_H\n\n#include <stdint.h>\n#include <sys/types.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// ** Defines and types from nffile.h\n#define IDENTLEN\t128\n#define IDENTNONE\t\"none\"\n\ntypedef struct file_header_s {\n\tuint16_t\tmagic;\t\t\t\t// magic to recognize nfdump file type and endian type\n#define MAGIC 0xA50C\n\n\tuint16_t\tversion;\t\t\t// version of binary file layout, incl. magic\n#define LAYOUT_VERSION_1\t1\n#define LAYOUT_VERSION_2\t2\n\n\tuint32_t\tflags;\t\t\t\t\n#define FLAG_NOT_COMPRESSED\t 0x0\t\t// records are not compressed\n#define FLAG_LZO_COMPRESSED\t 0x1\t\t// records are LZO compressed\n#define FLAG_ANONYMIZED \t 0x2\t\t// flow data are anonimized \n#define FLAG_CATALOG\t\t 0x4\t\t// has a file catalog record after stat record\n#define FLAG_BZ2_COMPRESSED  0x8\t\t// records are BZ2 compressed\n// New flags introduced\n#define FLAG_LZ4_COMPRESSED  0x10\n#define FLAG_LZMA_COMPRESSED 0x20\n\tuint32_t\tNumBlocks;\t\t\t// number of data blocks in file\n\tchar\t\tident[IDENTLEN];\t// string identifier for this file\n} file_header_t;\n\ntypedef struct stat_record_s {\n\t// overall stat\n\tuint64_t\tnumflows;\n\tuint64_t\tnumbytes;\n\tuint64_t\tnumpackets;\n\t// flow stat\n\tuint64_t\tnumflows_tcp;\n\tuint64_t\tnumflows_udp;\n\tuint64_t\tnumflows_icmp;\n\tuint64_t\tnumflows_other;\n\t// bytes stat\n\tuint64_t\tnumbytes_tcp;\n\tuint64_t\tnumbytes_udp;\n\tuint64_t\tnumbytes_icmp;\n\tuint64_t\tnumbytes_other;\n\t// packet stat\n\tuint64_t\tnumpackets_tcp;\n\tuint64_t\tnumpackets_udp;\n\tuint64_t\tnumpackets_icmp;\n\tuint64_t\tnumpackets_other;\n\t// time window\n\tuint32_t\tfirst_seen;\n\tuint32_t\tlast_seen;\n\tuint16_t\tmsec_first;\n\tuint16_t\tmsec_last;\n\t// other\n\tuint32_t\tsequence_failure;\n} stat_record_t;\n\ntypedef struct data_block_header_s {\n\tuint32_t\tNumRecords;\t\t// number of data records in data block\n\tuint32_t\tsize;\t\t\t// size of this block in bytes without this header\n\tuint16_t\tid;\t\t\t\t// Block ID == DATA_BLOCK_TYPE_2\n#define DATA_BLOCK_TYPE_1       1\n#define DATA_BLOCK_TYPE_2       2\n#define Large_BLOCK_Type        3\n#define CATALOG_BLOCK           4\n\tuint16_t\tflags;\t\t\t// 0 - compatibility\n\t\t\t\t\t\t\t\t// 1 - block uncompressed\n\t\t\t\t\t\t\t\t// 2 - block compressed\n} data_block_header_t;\n\ntypedef struct L_record_header_s {\n    uint32_t    type;\n#define CommonRecordV0Type      1\n#define ExtensionMapType        2\n#define PortHistogramType       3\n#define BppHistogramType        4\n// TC code - phased out\n#define ExporterRecordType      5\n#define SamplerRecordype        6\n// replaces TC Types\n#define ExporterInfoRecordType  7\n#define ExporterStatRecordType  8\n#define SamplerInfoRecordype    9\n// new extended Common Record as intermediate solution to overcome 255 exporters\n// requires moderate changes till 1.7\n#define CommonRecordType       10\n\n    uint32_t    size;\n} L_record_header_t;\n\n// *** end of nffile.h defines and types\n\ntypedef enum {\n  compressed_none, \n  compressed_lzo,\n  compressed_bz2,\n  compressed_lz4,\n  compressed_lzma,\n  compressed_term // terminator: leave as last element\n} compression_t;\n\n\n#ifdef __cplusplus\n}  // extern \"C\"\n#endif\n\n#endif\n\n\n", "comment_ratio": 0.23622047244094488}
{"lang": "c", "code": "#ifndef SRC_GRAPHICS_LIB_MAGMA_SRC_MAGMA_UTIL_PLATFORM_PLATFORM_CONNECTION_CLIENT_H_\n#define SRC_GRAPHICS_LIB_MAGMA_SRC_MAGMA_UTIL_PLATFORM_PLATFORM_CONNECTION_CLIENT_H_\n\n#include <memory>\n\n#include \"magma.h\"\n#include \"magma_util/macros.h\"\n#include \"magma_util/status.h\"\n#include \"platform_buffer.h\"\n#include \"platform_object.h\"\n#include \"platform_thread.h\"\n\nnamespace magma {\n\nclass PlatformPerfCountPoolClient {\n public:\n  virtual ~PlatformPerfCountPoolClient() = default;\n  virtual uint64_t pool_id() = 0;\n  virtual magma_handle_t handle() = 0;\n  virtual magma::Status ReadPerformanceCounterCompletion(uint32_t* trigger_id_out,\n                                                         uint64_t* buffer_id_out,\n                                                         uint32_t* buffer_offset_out,\n                                                         uint64_t* time_out,\n                                                         uint32_t* result_flags_out) = 0;\n};\n\n// Any implementation of PlatformConnectionClient shall be threadsafe.\nclass PlatformConnectionClient : public magma_connection {\n public:\n  virtual ~PlatformConnectionClient() {}\n\n  static std::unique_ptr<PlatformConnectionClient> Create(uint32_t device_handle,\n                                                          uint32_t device_notification_handle,\n                                                          uint64_t max_inflight_messages,\n                                                          uint64_t max_inflight_bytes);\n  // Imports an object for use in the system driver\n  virtual magma_status_t ImportObject(uint32_t handle, PlatformObject::Type object_type) = 0;\n\n  // Releases the connection's reference to the given object.\n  virtual magma_status_t ReleaseObject(uint64_t object_id, PlatformObject::Type object_type) = 0;\n\n  // Creates a context and returns the context id\n  virtual magma_status_t CreateContext(uint32_t* context_id_out) = 0;\n  // Destroys a context for the given id\n  virtual magma_status_t DestroyContext(uint32_t context_id) = 0;\n\n  virtual magma_status_t GetError() = 0;\n  virtual magma_status_t Sync() = 0;\n\n  virtual magma_status_t MapBufferGpu(uint64_t buffer_id, uint64_t gpu_va, uint64_t page_offset,\n                                      uint64_t page_count, uint64_t flags) = 0;\n\n  virtual magma_status_t UnmapBufferGpu(uint64_t buffer_id, uint64_t gpu_va) = 0;\n\n  virtual magma_status_t BufferRangeOp(uint64_t buffer_id, uint32_t options, uint64_t start,\n                                       uint64_t length) = 0;\n\n  virtual uint32_t GetNotificationChannelHandle() = 0;\n  virtual magma_status_t ReadNotificationChannel(void* buffer, size_t buffer_size,\n                                                 size_t* buffer_size_out,\n                                                 magma_bool_t* more_data_out) = 0;\n  virtual magma_status_t ExecuteCommandBufferWithResources(uint32_t context_id,\n                                                           magma_command_buffer* command_buffer,\n                                                           magma_exec_resource* resources,\n                                                           uint64_t* semaphores) = 0;\n  virtual magma_status_t ExecuteImmediateCommands(uint32_t context_id, uint64_t command_count,\n                                                  magma_inline_command_buffer* command_buffers,\n                                                  uint64_t* messages_sent_out) = 0;\n\n  virtual magma_status_t AccessPerformanceCounters(\n      std::unique_ptr<magma::PlatformHandle> handle) = 0;\n  virtual magma_status_t IsPerformanceCounterAccessEnabled(bool* enabled_out) = 0;\n  virtual magma::Status EnablePerformanceCounters(uint64_t* counters, uint64_t counter_count) = 0;\n  virtual magma::Status CreatePerformanceCounterBufferPool(\n      std::unique_ptr<PlatformPerfCountPoolClient>* pool_out) = 0;\n  virtual magma::Status ReleasePerformanceCounterBufferPool(uint64_t pool_id) = 0;\n  virtual magma::Status AddPerformanceCounterBufferOffsetsToPool(uint64_t pool_id,\n                                                                 const magma_buffer_offset* offsets,\n                                                                 uint64_t offsets_count) = 0;\n  virtual magma::Status RemovePerformanceCounterBufferFromPool(uint64_t pool_id,\n                                                               uint64_t buffer_id) = 0;\n  virtual magma::Status DumpPerformanceCounters(uint64_t pool_id, uint32_t trigger_id) = 0;\n  virtual magma::Status ClearPerformanceCounters(uint64_t* counters, uint64_t counter_count) = 0;\n\n  // Retrieve the performance counter access token from a channel to a gpu-performance-counters\n  // device.\n  static std::unique_ptr<magma::PlatformHandle> RetrieveAccessToken(magma::PlatformHandle* channel);\n\n  static PlatformConnectionClient* cast(magma_connection_t connection) {\n    DASSERT(connection);\n    DASSERT(connection->magic_ == kMagic);\n    return static_cast<PlatformConnectionClient*>(connection);\n  }\n\n  // Returns: inflight messages, inflight memory\n  virtual std::pair<uint64_t, uint64_t> GetFlowControlCounts() = 0;\n\n protected:\n  PlatformConnectionClient() { magic_ = kMagic; }\n\n private:\n  static const uint32_t kMagic = 0x636f6e6e;  // \"conn\" (Connection)\n};\n\n}  // namespace magma\n\n#endif  // SRC_GRAPHICS_LIB_MAGMA_SRC_MAGMA_UTIL_PLATFORM_PLATFORM_CONNECTION_CLIENT_H_\n\n", "comment_ratio": 0.125}
{"lang": "c", "code": "#ifndef RANKSCORE_STRATEGY_H_\n#define RANKSCORE_STRATEGY_H_\n\n#include \"Interfaces/StrategyBase.h\"\n\nnamespace rank {\nclass RankScoreStrategy : public StrategyBase {\npublic:\n  OBJECT_CLASS(RankScoreStrategy)\n\n  bool Initialize(strategy_arg_t& arg,\n                  const std::map<std::string, ConditionBase*>& conditions,\n                  ResourceManager* resource_manager);\n  bool Filter(const RankRequest& fisher_request,\n              std::vector<RankAdInfo>& ad_list_for_rank,\n              std::vector<RankItemInfo>& item_list_for_rank,\n              RankDataContext& ptd);\n  bool Update();\n  strategy_arg_t& getArgument() {\n    return mArg;\n  };\n\n private:\n  strategy_arg_t mArg;\n  std::string mFeatureDir, mStrategyDir, mConfigFile;\n\n  std::string mOptimizeOption, mOptimizeMethod;\n  float mPacingAlpha, mCpcBeta;\n  //mCPMWeight, mCPEWeight, mOCPMWeight, mCPMQ, mCPEQ, mOCPMQ, mMaxCPEScore, mMaxCPECTR, mOptimizerFlag, mPrecedureFlag;\n  //float ocpm_oscore_scale;\n  //float cpm_ctr_thresh, cpe_ctr_thresh, ocpm_ctr_thresh, cpc_ctr_thresh;\n};\n}  // namespace rank\n\n#endif\n\n", "comment_ratio": 0.1111111111111111}
{"lang": "c", "code": "//\n// Created by Tristan Seifert on 2019-08-19.\n//\n\n#ifndef LICHTENSTEIN_SERVER_VERSION_H\n#define LICHTENSTEIN_SERVER_VERSION_H\n\n// Global version strings\nextern const char *gVERSION;\nextern const char *gVERSION_SHORT;\n\nextern const char *gVERSION_HASH;\nextern const char *gVERSION_BRANCH;\n\n#endif //LICHTENSTEIN_SERVER_VERSION_H\n\n", "comment_ratio": 0.3125}
{"lang": "c", "code": "#ifndef NODE_H\n#define NODE_H\n\n#include <map>\n#include <string>\n#include \"../types.h\"\n//#include \"../sockets/InputSocket.h\"\n//#include \"../sockets/OutputSocket.h\"\n\nclass Socket;\nclass InputSocket;\nclass OutputSocket;\n\nclass Node \n{\n\tpublic:\n\t\tNode(); //Todo, constructor with title, so the title must be set for each node\n\t\tvirtual ~Node();\n\t\t\n\t\tstd::string Title=\"\";\n\t\tint id=0;\n\t\tvoid Process();\n\t\tvoid Process(Socket* caller);\n\n\t\tInputSocket* GetInputSocket(std::string name);\n\t\tstd::map<std::string, InputSocket*>* GetInputSockets();\n\n\t\tOutputSocket* GetOutputSocket(std::string name);\n\t\tstd::map<std::string, OutputSocket*>* GetOutputSockets();\n\n\t\t//virtual std::map<std::string, OutputSocket*>* GetOutputSockets(){return 0;} //TODO this is done to the ui can access the outputsockets. fix this is a neat way.\n\n//#ifdef WITHCOMPOSER\n\t\tint x=0,y=0;\n//#endif\n\n\tprotected:\n\t\tvirtual void ProcessInternal(Socket* caller)=0; //TODO only processnodes can have this\n\t\tSOCKETTYPE getInput(std::string name);\n\t\tInputSocket* CreateInputSocket(std::string name, SocketDrive drive, SOCKETTYPE defaultValue);\n\t\tvoid DeleteInputSocket(std::string name);\n\n\t\tvoid setOutput(std::string name, SOCKETTYPE value);\n\t\tvoid setOutput(std::string name, SOCKETTYPE value, bool force); //if force is set to true, it will still send an update, even if the value has not changed\n\n\t\tOutputSocket* CreateOutputSocket(std::string name, SocketDrive drive);\n\t\tvoid DeleteOutputSocket(std::string name);\n\n\tprivate:\n\t\tstd::map<std::string, InputSocket*> InputSockets;\n\t\tstd::map<std::string, OutputSocket*> OutputSockets;\n\t\t\n\t\tunsigned int frameNumber=-1;\n};\n\n#endif\n\n", "comment_ratio": 0.14035087719298245}
{"lang": "c", "code": "#ifndef UI_OZONE_PLATFORM_DRM_GPU_DRM_GPU_UTIL_H_\n#define UI_OZONE_PLATFORM_DRM_GPU_DRM_GPU_UTIL_H_\n\n#include \"ui/ozone/platform/drm/common/scoped_drm_types.h\"\n#include \"ui/ozone/platform/drm/gpu/drm_device.h\"\n\nnamespace ui {\n\n// Helper function that finds the property with the specified name.\nbool GetDrmPropertyForName(DrmDevice* drm,\n                           drmModeObjectProperties* properties,\n                           const std::string& name,\n                           DrmDevice::Property* property);\n\n}  // namespace ui\n\n#endif  // UI_OZONE_PLATFORM_DRM_GPU_DRM_GPU_UTIL_H_\n\n", "comment_ratio": 0.2727272727272727}
{"lang": "c", "code": "#ifndef SSD_CACHE_H_\n#define SSD_CACHE_H_\n\n#include <atomic>\n#include <fcntl.h>\n#include <functional>\n#include <iostream>\n#include <unistd.h>\n#include <unordered_map>\n#include <vector>\n\n#include \"leveldb/status.h\"\n#include \"port/port.h\"\n#include \"util/hash.h\"\n#include \"util/mutexlock.h\"\n\nnamespace leveldb {\n\nstatic const int kSegmentOffsetBits = 18; // For 256K segments\nstatic const int kSegmentNumBits = 64 - kSegmentOffsetBits;\nstatic const int kSegmentSize = 1 << kSegmentOffsetBits;\nstatic const int kSegmentOffsetMask = kSegmentSize-1;\n\n#define SEGMENT_NUM(x) (x >> kSegmentOffsetBits)\n#define SEGMENT_OFF(x) (x & kSegmentOffsetMask)\n#define ADDRESS(segment, off) ((segment << kSegmentOffsetBits) | off)\n\nstruct Segment {\n  uint32_t num;\n  uint32_t size;\n  uint32_t curr_offset;\n  uint32_t garbage_bytes;\n\n  Segment(uint32_t n, uint32_t sz): num(n), size(sz) { curr_offset = 0; garbage_bytes = 0; }\n  \n  double Unused() const { \n    double total_unused = garbage_bytes + (size - curr_offset);\n    return static_cast<double>(total_unused) / static_cast<double>(size); \n  }\n\n  uint32_t BytesAvailable() const { return size - curr_offset; }\n\n  void MarkGarbage(uint64_t nbytes) { garbage_bytes += nbytes; }\n\n  uint64_t StartOffset() const { return num * size; }\n};\n\nclass SegmentManager {\n public:\n\n private:\n  uint32_t segment_size;\n  std::vector<Segment> segments_;\n  int i;\n\n public:\n  SegmentManager(size_t sz);\n\n  inline Segment* NextSegment() { return &segments_[i++]; }\n\n  inline Segment* GetSegment(int seg_num) { return &segments_[seg_num]; }\n};\n\nstruct IndexEntry {\n  uint64_t off;\n  uint32_t len; // total length of entry on-disk (include key size)\n  uint32_t key_len;\n  //char* key_; // pointer to heap-allocated key\n  uint32_t hash;\n\n  IndexEntry* prev;\n  IndexEntry* next;\n  IndexEntry* next_hash;\n\n  char key_[1];   // Beginning of key\n\n  Slice key() const { return Slice{key_, key_len}; }\n};\n\nclass HandleTable {\n public:\n  HandleTable() : length_(0), elems_(0), list_(NULL) { Resize(); }\n  ~HandleTable() {\n      for (uint32_t i = 0; i < length_; i++) {\n          IndexEntry* h = list_[i];\n          while (h != NULL) {\n              IndexEntry* next = h->next_hash;\n              free(h);\n              h = next;\n          }\n      }\n      delete[] list_;\n  }\n\n  IndexEntry* Lookup(const Slice& key, uint32_t hash) {\n    return *FindPointer(key, hash);\n  }\n\n  IndexEntry* Insert(IndexEntry* h) {\n    IndexEntry** ptr = FindPointer(h->key(), h->hash);\n    IndexEntry* old = *ptr;\n    h->next_hash = (old == NULL ? NULL : old->next_hash);\n    *ptr = h;\n    if (old == NULL) {\n      ++elems_;\n      if (elems_ > length_) {\n        // Since each cache entry is fairly large, we aim for a small\n        // average linked list length (<= 1).\n        Resize();\n      }\n    }\n    return old;\n  }\n\n  IndexEntry* Remove(const Slice& key, uint32_t hash) {\n    IndexEntry** ptr = FindPointer(key, hash);\n    IndexEntry* result = *ptr;\n    if (result != NULL) {\n      *ptr = result->next_hash;\n      --elems_;\n    }\n    return result;\n  }\n\n  uint32_t Size() const { return elems_; }\n\n private:\n  // The table consists of an array of buckets where each bucket is\n  // a linked list of cache entries that hash into the bucket.\n  uint32_t length_;\n  uint32_t elems_;\n  IndexEntry** list_;\n\n  // Return a pointer to slot that points to a cache entry that\n  // matches key/hash.  If there is no such cache entry, return a\n  // pointer to the trailing slot in the corresponding linked list.\n  IndexEntry** FindPointer(const Slice& key, uint32_t hash) {\n    IndexEntry** ptr = &list_[hash & (length_ - 1)];\n    while (*ptr != NULL &&\n           ((*ptr)->hash != hash || key != (*ptr)->key())) {\n      ptr = &(*ptr)->next_hash;\n    }\n    return ptr;\n  }\n\n  void Resize() {\n    uint32_t new_length = 4;\n    while (new_length < elems_) {\n      new_length *= 2;\n    }\n    IndexEntry** new_list = new IndexEntry*[new_length];\n    memset(new_list, 0, sizeof(new_list[0]) * new_length);\n    uint32_t count = 0;\n    for (uint32_t i = 0; i < length_; i++) {\n      IndexEntry* h = list_[i];\n      while (h != NULL) {\n        IndexEntry* next = h->next_hash;\n        uint32_t hash = h->hash;\n        IndexEntry** ptr = &new_list[hash & (new_length - 1)];\n        h->next_hash = *ptr;\n        *ptr = h;\n        h = next;\n        count++;\n      }\n    }\n    assert(elems_ == count);\n    delete[] list_;\n    list_ = new_list;\n    length_ = new_length;\n  }\n};\n\nclass SsdCache {\n\n private:\n  static inline uint32_t HashSlice(const Slice& key) {\n    return Hash(key.data(), key.size(), 0);\n  }\n\n  static inline bool KeyEquals(const Slice& k1, const Slice& k2) {\n    return k1 == k2;\n  }\n\n  // The name of the file used by this cache\n  std::string cache_fname_;\n\n  // The file descriptor of the cache file if the cache has been opened\n  int fd_;\n  port::Mutex mutex_;\n\n  // The class that manages the segments in the file\n  SegmentManager segment_manager_;\n  Segment* active_segment_;\n\n  // Write Buffer\n  char buf_[kSegmentSize]; \n\n  // Read buffer\n  char rbuf_[kSegmentSize];\n\n  // The maximum size of the cache (in bytes)\n  uint64_t capacity_;\n  uint64_t curr_size_;\n\n  // The in-memory index that maps keys to offset into the file\n  /*\n  std::unordered_map<\n    Slice, \n    IndexEntry*, \n    std::function<decltype(HashSlice)>,\n    std::function<decltype(KeyEquals)>> index_;\n  */\n\n  HandleTable table_;\n\n  // LRU\n  IndexEntry dummy_;\n\n public:\n  explicit SsdCache(std::string cache_dir, size_t capacity);\n\n  ~SsdCache();\n\n  bool Insert(const Slice& key, void* value, size_t size);\n\n  void Lookup(const Slice& key, void* arg, void (*saver)(void*, const Slice& key, const Slice& val));\n\n  void Erase(const Slice& key);\n\n  //inline bool ContainsKey(const Slice& key) const { return index_.find(key) != index_.end(); }\n  inline bool ContainsKey(const Slice& key) { return table_.Lookup(key, HashSlice(key)) != nullptr; }\n\n  //inline uint64_t NumKeys() const { return index_.size(); }\n  inline uint64_t NumKeys() const { return table_.Size(); }\n\n  Status Open() {\n    fd_ = open(cache_fname_.c_str(), O_CREAT | O_RDWR, S_IRUSR | S_IWUSR );\n    if (fd_ < 0) {\n      // error\n      std::cout << \"Error opening file: \" << strerror(errno) << std::endl;\n      return Status::IOError(cache_fname_, strerror(errno));\n    }\n    return Status::OK();\n  }\n\n private:\n  // Persist current active segment and start using a new one\n  void RollSegment();\n\n  // Append the parameters to the current active segment\n  uint64_t AppendToSegment(const Slice& key, void* value, size_t sz);\n\n  // Ensure there is sufficient room in the index for the given kv pair\n  void MakeRoomForInsert(const Slice& key, size_t sz);\n\n  // Remove the key (and it's value) from the index and cleanup resources\n  void Remove(IndexEntry* e);\n\n  void LRU_Append(IndexEntry* e);\n\n  void LRU_Remove(IndexEntry* e);\n};\n\n} // namespace\n\n#endif\n\n", "comment_ratio": 0.10112359550561797}
{"lang": "c", "code": "#ifndef TRACKER_STEREO_TRACKER_H_\n#define TRACKER_STEREO_TRACKER_H_\n\n#include <vector>\n#include <unordered_map>\n\n#include <boost/archive/text_oarchive.hpp>\n#include <boost/archive/text_iarchive.hpp>\n#include <boost/serialization/vector.hpp>\n\n#include <opencv2/core/core.hpp>\n#include <opencv2/highgui/highgui.hpp>\n#include <opencv2/imgproc/imgproc.hpp>\n\n#include \"../base/types.h\"\n#include \"stereo_tracker_base.h\"\n#include \"debug_helper.h\"\n#include \"../base/helper_opencv.h\"\n#include \"../mono/tracker_base.h\"\n#include \"../../core/image.h\"\n#include \"../../core/types.h\"\n#include \"../detector/feature_detector_base.h\"\n#include \"../../reconstruction/base/stereo_costs.h\"\n\nnamespace track {\n\nclass StereoTracker : public StereoTrackerBase\n{\n public:\n  StereoTracker(TrackerBase& tracker, int max_disparity, int stereo_wsz,\n                double ncc_thresh, bool estimate_subpixel,\n                bool use_df, const std::string& deformation_field_path);\n  virtual void init(const cv::Mat& img_left, const cv::Mat& img_right);\n  virtual void track(const cv::Mat& img_left, const cv::Mat& img_right);\n  virtual int countFeatures() const;\n  virtual FeatureInfo featureLeft(int i) const;\n  virtual FeatureInfo featureRight(int i) const;\n  virtual void removeTrack(int id);\n  virtual int countActiveTracks() const;\n\n  virtual FeatureData getLeftFeatureData(int i);\n  virtual FeatureData getRightFeatureData(int i);\n  virtual void showTrack(int i) const;\n\nprivate:\n  friend class boost::serialization::access;\n  // When the class Archive corresponds to an output archive, the\n  // & operator is defined similar to <<.  Likewise, when the class Archive\n  // is a type of input archive the & operator is defined similar to >>.\n  template<class Archive>\n  void serialize(Archive& ar, const unsigned int version)\n  {\n      // serialize base class information\n      //ar & boost::serialization::base_object<StereoTrackerBase>(*this);\n      ar & max_feats_;\n      ar & img_size_;\n      ar & max_disparity_;\n      ar & stereo_wsz_;\n      ar & margin_sz_;\n      ar & ncc_thresh_;\n      ar & estimate_subpixel_;\n      ar & age_;\n      ar & pts_left_prev_;\n      ar & pts_left_curr_;\n      ar & pts_right_prev_;\n      ar & pts_right_curr_;\n  }\n\n  void AddMissingDescriptors(const cv::Mat& img, const core::Point& point, int window_size,\n                             std::vector<std::pair<bool, core::DescriptorNCC>>& descriptors_rprev_);\n\n  bool stereo_match_ncc(const core::DescriptorNCC& desc_left,\n                        const std::vector<std::pair<bool, core::DescriptorNCC>>& descriptors_right,\n                        const core::Point& left_pt, const cv::Mat& img_right,\n                        bool debug, core::Point& right_pt);\n\n  // deformation field functions\n  void ComputeCellCenters();\n  void GetPointCell(const core::Point& pt, int& row, int& col);\n  void InterpolateBilinear(const cv::Mat& mat, const int row, const int col,\n                           const double x, const double y, double& ival);\n  void InterpolateLinear(const double val1, const double val2, const double x,\n                         const double size, double& ival);\n  void ApplyDeformationField(const cv::Mat& def_x, const cv::Mat& def_y, core::Point& pt);\n\n  track::TrackerBase& tracker_;\n  int max_feats_;\n  int img_size_;\n  int max_disparity_;\n  int stereo_wsz_, margin_sz_;\n  double ncc_thresh_;\n  bool estimate_subpixel_;\n  cv::Mat img_lp_, img_rp_, img_lc_, img_rc_;\n  std::vector<std::pair<bool, core::DescriptorNCC>> descriptors_rprev_, descriptors_rcurr_;\n  //cv::Mat desc_rprev_, desc_rcurr_;\n  //std::vector<double> distances_prev_, distances_curr_;\n\n  std::vector<int> age_;\n  std::vector<core::Point> pts_left_prev_, pts_left_curr_;\n  std::vector<core::Point> pts_right_prev_, pts_right_curr_;\n  std::vector<core::Point> df_left_prev_, df_left_curr_;\n  std::vector<core::Point> df_right_prev_, df_right_curr_;\n\n  bool use_deformation_field_ = false; \n  cv::Mat left_dx_, left_dy_;\n  cv::Mat right_dx_, right_dy_;\n  cv::Mat cell_centers_x_;\n  cv::Mat cell_centers_y_;\n  int img_rows_;\n  int img_cols_;\n  int cell_width_, cell_height_;\n};\n\ninline\nFeatureData StereoTracker::getLeftFeatureData(int i)\n{\n  FeatureData fdata = tracker_.getFeatureData(i);\n  return fdata;\n}\n\ninline\nFeatureData StereoTracker::getRightFeatureData(int i)\n{\n  FeatureData fdata;\n  fdata.feat_ = featureRight(i);\n  //fdata.desc_prev_ = desc_rprev_.row(i).reshape(1, stereo_wsz_);\n  //fdata.desc_curr_ = desc_rcurr_.row(i).reshape(1, stereo_wsz_);\n  return fdata;\n}\n\ninline\nbool StereoTracker::stereo_match_ncc(const core::DescriptorNCC& desc_left,\n                                     const std::vector<std::pair<bool, core::DescriptorNCC>>& descriptors_right,\n                                     const core::Point& left_pt, const cv::Mat& img_right,\n                                     bool debug, core::Point& right_pt)\n{\n  bool success = false;\n  std::vector<double> costs;\n  costs.assign(max_disparity_, std::numeric_limits<double>::max());\n  int x = static_cast<int>(left_pt.x_);\n  int y = static_cast<int>(left_pt.y_);\n  //int min_x = std::max(margin_sz_, int(left_pt.x_) - max_disparity_);\n  int max_disp = std::min(max_disparity_, static_cast<int>(left_pt.x_) - margin_sz_);\n  int best_d = -1;\n  double best_cost = 0.0;\n  //for (; x >= min_x; x--, d++) {\n  int row_start = y * img_right.cols;\n  #pragma omp parallel for\n  for (int d = 0; d <= max_disp; d++) {\n    int key = row_start + x - d;\n    assert(descriptors_right[key].first == true);\n    const core::DescriptorNCC& desc_right = descriptors_right[key].second;\n    costs[d] = recon::StereoCosts::get_cost_NCC(desc_left, desc_right);\n    if (debug) {\n      printf(\"d = %d\\nNCC = %f\\n\\b\", d, costs[d]);\n      HelperOpencv::DrawPoint(core::Point(left_pt.x_ - d, left_pt.y_), img_right, \"right_point\");\n      HelperOpencv::DrawPoint(core::Point(left_pt.x_ - best_d, left_pt.y_), img_right, \"best_right_point\");\n      HelperOpencv::DrawDescriptor(desc_left.vec, stereo_wsz_, \"desc_left\");\n      HelperOpencv::DrawDescriptor(desc_right.vec, stereo_wsz_, \"desc_right\");\n      int key = cv::waitKey(0);\n      if (key == 27) debug = false;\n    }\n    if (std::isnan(costs[d])) {\n      //printf(\"nan skipped!\\n\", d, costs[d]);\n      continue;\n    }\n    if (costs[d] > best_cost) {\n      best_cost = costs[d];\n      best_d = d;\n    }\n  }\n  //printf(\"Min cost = %d -- d = %d\\n\", static_cast<int>(min_cost), best_d);\n  if (best_d >= 0 && best_cost >= ncc_thresh_) {\n    //descriptors_right[best_desc_idx].vec.copyTo(save_descriptor);\n    //save_descriptor = descriptors_right[best_desc_idx].vec.t();\n    //if (best_d > (max_disparity_ - 2))\n    //  printf(\"Warning: big disp, best cost = %f -- d = %d. max_disp = %d\\n\", best_cost, best_d, max_disparity_);\n      //std::cout << left_pt << \"\\n\";\n    success = true;\n    right_pt.y_ = left_pt.y_;\n    // perform parabolic subpixel interpolation if we can\n    if (estimate_subpixel_ && best_d >= 1 && best_d < (max_disp - 1)\n       && !std::isnan(costs[best_d-1]) && !std::isnan(costs[best_d+1])) {\n      double C_left = 2.0 - costs[best_d-1];\n      double C_center = 2.0 - costs[best_d];\n      double C_right = 2.0 - costs[best_d+1];\n      double d_s = (C_left - C_right) / (2.0*C_left - 4.0*C_center + 2.0*C_right);\n      //printf(\"Parabolic fitting: %d --> %f\\n\", best_d, best_d+d_s);\n      right_pt.x_ = left_pt.x_ - (static_cast<double>(best_d) + d_s);\n    }\n    else\n      right_pt.x_ = left_pt.x_ - static_cast<double>(best_d);\n    // perform equiangular subpixel interpolation\n    //if (best_d >= 1 && best_d < (max_disp - 1)) {\n    //  double C_left = 2.0 - costs[best_d-1];\n    //  double C_center = 2.0 - costs[best_d];\n    //  double C_right = 2.0 - costs[best_d+1];\n    //  double d_s;\n    //  if (C_right < C_left)\n    //    d_s = 0.5f * (C_right - C_left) / (C_center - C_left);\n    //  else\n    //    d_s = 0.5f * (C_right - C_left) / (C_center - C_right);\n    //  printf(\"Equangular fitting: %d --> %f\\n\", best_d, best_d+d_s);\n    //  //right_pt.x_ = left_pt.x_ - (static_cast<double>(best_d) + d_s);\n    //}\n    ////else\n    ////  right_pt.x_ = left_pt.x_ - static_cast<double>(best_d);\n  }\n  else {\n    right_pt.x_ = std::numeric_limits<double>::max();\n    right_pt.y_ = std::numeric_limits<double>::max();\n  }\n  assert(!std::isnan(right_pt.x_) && !std::isnan(right_pt.y_));\n  return success;\n}\n\ninline\nvoid StereoTracker::InterpolateBilinear(const cv::Mat& mat, const int row, const int col,\n                                               const double x, const double y, double& ival) {\n  double q1 = mat.at<double>(row, col);\n  double q2 = mat.at<double>(row, col+1);\n  double q3 = mat.at<double>(row+1, col);\n  double q4 = mat.at<double>(row+1, col+1);\n\n  double w = cell_width_;\n  double h = cell_height_;\n  double q12 = ((w-x) / w) * q1 + (x / w) * q2;\n  double q34 = ((w-x) / w) * q3 + (x / w) * q4;\n  ival = ((h-y) / h) * q12 + (y / h) * q34;\n}\n\ninline\nvoid StereoTracker::InterpolateLinear(const double val1, const double val2, const double x,\n                                             const double size, double& ival) {\n  ival = ((size - x) / size) * val1 + (x / size) * val2;\n}\n\ninline\nvoid StereoTracker::GetPointCell(const core::Point& pt, int& row, int& col) {\n  col = pt.x_ / cell_width_;\n  row = pt.y_ / cell_height_;\n  //int bin_num = row * bin_cols_ + col;\n}\n\n//inline\n//bool StereoTracker::stereo_match_census(int max_disparity, int margin_sz, uint32_t census,\n//                                        const cv::Mat& census_img,\n//                                        const core::Point& left_pt,\n//                                        core::Point& right_pt)\n//{\n//  bool success = false;\n//  std::vector<uint8_t> costs;\n//  costs.assign(max_disparity, std::numeric_limits<uint8_t>::max());\n//  int cx = static_cast<int>(left_pt.x_) - margin_sz;\n//  int cy = static_cast<int>(left_pt.y_) - margin_sz;\n//  int max_disp = std::min(max_disparity, cx);\n//  int best_d = -1;\n//  uint8_t min_cost = std::numeric_limits<uint8_t>::max();\n//  for (int d = 0; d <= max_disp; d++) {\n//    costs[d] = recon::StereoCosts::hamming_dist(census, census_img.at<uint32_t>(cy,cx-d));\n//    if (costs[d] < min_cost) {\n//      min_cost = costs[d];\n//      best_d = d;\n//    }\n//  }\n//  //printf(\"Min cost = %d -- d = %d\\n\", static_cast<int>(min_cost), best_d);\n//  if (best_d >= 0 && (int)(min_cost) == 0) {\n//    printf(\"Min cost = %d -- d = %d\\n\", static_cast<int>(min_cost), best_d);\n//    success = true;\n//    right_pt.y_ = left_pt.y_;\n//    // perform equiangular subpixel interpolation\n//    if (best_d >= 1 && best_d < (max_disp - 1) && !std::isnan(costs[best_d-1]) && !std::isnan(costs[best_d+1])) {\n//      double C_left = static_cast<double>(costs[best_d-1]);\n//      double C_center = static_cast<double>(costs[best_d]);\n//      double C_right = static_cast<double>(costs[best_d+1]);\n//      double d_s = 0;\n//      if (C_right < C_left)\n//        d_s = 0.5f * (C_right - C_left) / (C_center - C_left);\n//      else\n//        d_s = 0.5f * (C_right - C_left) / (C_center - C_right);\n//      //std::cout << d << \" -- \" << d+d_s << \"\\n\";\n//      right_pt.x_ = left_pt.x_ - (static_cast<double>(best_d) + d_s);\n//    }\n//    else\n//      right_pt.x_ = left_pt.x_ - static_cast<double>(best_d);\n//  }\n//  return success;\n//}\n\n}\n\n#endif\n\n", "comment_ratio": 0.2764505119453925}
{"lang": "c", "code": "#define SERVER \"127.0.0.1\"  // IP address of udp server\r\n#define PORT 40001   \t\t//The port on which to listen for incoming data\r\n\r\n// SYSTEM INCLUDES\r\n#include<stdio.h>\r\n#include<stdint.h>\r\n#include<winsock2.h>\r\n\r\n// PROJECT INCLUDES\r\n\r\n// LOCAL INCLUDES\r\n#include<protobuf_header/loc.pb-c.h> /* make sure to include -I\"./external\" in the Makefile */\r\n\r\n// FORWARD REFERENCES\r\n\r\n// FUNCTION PROTOTYPES\r\n\r\n/** @brief\r\n *  @param\r\n *  @return\r\n */\r\n\r\n// GLOBAL VARIABLES\r\n\r\n//// MAIN //////////////////////////////////////////////////////////////////////////////////////////\r\nint main(void)\r\n{\r\n    struct sockaddr_in si_other;\r\n    int s, slen=sizeof(si_other);\r\n    WSADATA wsa;\r\n \r\n    //Initialise winsock\r\n    printf(\"\\nInitialising Winsock...\");\r\n    if (WSAStartup(MAKEWORD(2,2),&wsa) != 0) {\r\n        printf(\"Failed. Error Code : %d\",WSAGetLastError());\r\n        exit(EXIT_FAILURE);\r\n    }\r\n    printf(\"Initialised.\\n\");\r\n     \r\n    //create socket\r\n    if ( (s=socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) == SOCKET_ERROR) {\r\n        printf(\"socket() failed with error code : %d\" , WSAGetLastError());\r\n        exit(EXIT_FAILURE);\r\n    }\r\n     \r\n    //setup address structure\r\n    memset((char *) &si_other, 0, sizeof(si_other));\r\n    si_other.sin_family = AF_INET;\r\n    si_other.sin_port = htons(PORT);\r\n    si_other.sin_addr.S_un.S_addr = inet_addr(SERVER);\r\n    \r\n    /* Create protobuf object */ \r\n    Loc localization_data = LOC__INIT;\r\n    void *buf;     \t// Buffer to store serialized protobuf data\r\n    unsigned len;\t// Length of serialized protobuf data\r\n    \r\n    //start communication\r\n    while(1) {\r\n         \r\n\t  /* Set values of protobuf message */\r\n\t  localization_data.x = 2;\r\n\t  localization_data.y = 16;\r\n\t\r\n\t  /* Serialize protobuf message */\r\n\t  len = loc__get_packed_size(&localization_data);\r\n\t  buf = malloc(len);\r\n\t  loc__pack(&localization_data,buf);\r\n    \r\n      //send the message\r\n      if (sendto(s, buf, len, 0 , (struct sockaddr *) &si_other, slen) == SOCKET_ERROR) {\r\n          printf(\"sendto() failed with error code : %d\" , WSAGetLastError());\r\n          getchar();\r\n          exit(EXIT_FAILURE);\r\n      }\r\n      \r\n      printf(\"Sending package... \\n\");\r\n      sleep(1);\r\n    }\r\n \r\n    closesocket(s);\r\n    WSACleanup();\r\n \r\n    return 0;\r\n}\r\n\r\n//// FUNCTION DEFINITIONS //////////////////////////////////////////////////////////////////////////\r\n\r\n\n", "comment_ratio": 0.17272727272727273}
{"lang": "c", "code": "#ifndef MOJO_PUBLIC_CPP_BINDINGS_ARRAY_H_\n#define MOJO_PUBLIC_CPP_BINDINGS_ARRAY_H_\n\n#include <stddef.h>\n#include <string.h>\n\n#include <algorithm>\n#include <cstddef>\n#include <set>\n#include <string>\n#include <vector>\n\n#include \"mojo/public/cpp/bindings/lib/array_internal.h\"\n#include \"mojo/public/cpp/bindings/lib/bindings_internal.h\"\n#include \"mojo/public/cpp/bindings/lib/template_util.h\"\n#include \"mojo/public/cpp/bindings/type_converter.h\"\n\nnamespace mojo {\n\n// Represents a moveable array with contents of type |T|. The array can be null,\n// meaning that no value has been assigned to it. Null is distinct from empty.\ntemplate <typename T>\nclass Array {\n public:\n  using ConstRefType = typename std::vector<T>::const_reference;\n  using RefType = typename std::vector<T>::reference;\n\n  using Traits = internal::ArrayTraits<T, internal::IsMoveOnlyType<T>::value>;\n  using ForwardType = typename Traits::ForwardType;\n\n  typedef internal::Array_Data<typename internal::WrapperTraits<T>::DataType>\n      Data_;\n\n  // Constructs a new array that is null.\n  Array() : is_null_(true) {}\n\n  // Makes null arrays implicitly constructible from |nullptr|.\n  Array(std::nullptr_t) : is_null_(true) {}\n\n  ~Array() {}\n\n  // Moves the contents of |other| into this array.\n  Array(Array&& other) : is_null_(true) { Take(&other); }\n  Array& operator=(Array&& other) {\n    Take(&other);\n    return *this;\n  }\n\n  // Creates a non-null array of the specified size. The elements will be\n  // value-initialized (meaning that they will be initialized by their default\n  // constructor, if any, or else zero-initialized).\n  static Array New(size_t size) {\n    Array ret;\n    ret.resize(size);\n    return ret;\n  }\n\n  // Creates a new array with a copy of the contents of |other|.\n  template <typename U>\n  static Array From(const U& other) {\n    return TypeConverter<Array, U>::Convert(other);\n  }\n\n  // Copies the contents of this array to a new object of type |U|.\n  template <typename U>\n  U To() const {\n    return TypeConverter<U, Array>::Convert(*this);\n  }\n\n  // Resets the contents of this array back to null.\n  void reset() {\n    vec_.clear();\n    is_null_ = true;\n  }\n\n  // Tests as true if non-null, false if null.\n  explicit operator bool() const { return !is_null_; }\n\n  // Indicates whether the array is null (which is distinct from empty).\n  bool is_null() const { return is_null_; }\n\n  // Returns a reference to the first element of the array. Calling this on a\n  // null or empty array causes undefined behavior.\n  ConstRefType front() const { return vec_.front(); }\n  RefType front() { return vec_.front(); }\n\n  // Returns the size of the array, which will be zero if the array is null.\n  size_t size() const { return vec_.size(); }\n\n  // For non-null arrays of non-bool types, returns a pointer to the first\n  // element, if any. (If the array is empty, the semantics are the same as for\n  // |std::vector<T>::data()|. The behavior is undefined if the array is null.)\n  const T* data() const { return vec_.data(); }\n  T* data() { return vec_.data(); }\n\n  // Returns a reference to the element at zero-based |offset|. Calling this on\n  // an array with size less than |offset|+1 causes undefined behavior.\n  ConstRefType at(size_t offset) const { return vec_.at(offset); }\n  ConstRefType operator[](size_t offset) const { return at(offset); }\n  RefType at(size_t offset) { return vec_.at(offset); }\n  RefType operator[](size_t offset) { return at(offset); }\n\n  // Pushes |value| onto the back of the array. If this array was null, it will\n  // become non-null with a size of 1.\n  void push_back(ForwardType value) {\n    is_null_ = false;\n    Traits::PushBack(&vec_, value);\n  }\n\n  // Resizes the array to |size| and makes it non-null. Otherwise, works just\n  // like the resize method of |std::vector|.\n  void resize(size_t size) {\n    is_null_ = false;\n    vec_.resize(size);\n  }\n\n  // Returns a const reference to the |std::vector| managed by this class. If\n  // the array is null, this will be an empty vector.\n  const std::vector<T>& storage() const { return vec_; }\n  operator const std::vector<T>&() const { return vec_; }\n\n  // Swaps the contents of this array with the |other| array, including\n  // nullness.\n  void Swap(Array* other) {\n    std::swap(is_null_, other->is_null_);\n    vec_.swap(other->vec_);\n  }\n\n  // Swaps the contents of this array with the specified vector, making this\n  // array non-null. Since the vector cannot represent null, it will just be\n  // made empty if this array is null.\n  void Swap(std::vector<T>* other) {\n    is_null_ = false;\n    vec_.swap(*other);\n  }\n\n  // Returns a copy of the array where each value of the new array has been\n  // \"cloned\" from the corresponding value of this array. If this array contains\n  // primitive data types, this is equivalent to simply copying the contents.\n  // However, if the array contains objects, then each new element is created by\n  // calling the |Clone| method of the source element, which should make a copy\n  // of the element.\n  //\n  // Please note that calling this method will fail compilation if the element\n  // type cannot be cloned (which usually means that it is a Mojo handle type or\n  // a type contains Mojo handles).\n  Array Clone() const {\n    Array result;\n    result.is_null_ = is_null_;\n    Traits::Clone(vec_, &result.vec_);\n    return result;\n  }\n\n  // Indicates whether the contents of this array are equal to |other|. A null\n  // array is only equal to another null array. Elements are compared using the\n  // |ValueTraits::Equals| method, which in most cases calls the |Equals| method\n  // of the element.\n  bool Equals(const Array& other) const {\n    if (is_null() != other.is_null())\n      return false;\n    if (size() != other.size())\n      return false;\n    for (size_t i = 0; i < size(); ++i) {\n      if (!internal::ValueTraits<T>::Equals(at(i), other.at(i)))\n        return false;\n    }\n    return true;\n  }\n\n public:\n  // Array<>::Iterator satisfies the RandomAccessIterator concept:\n  //   http://en.cppreference.com/w/cpp/concept/RandomAccessIterator.\n  class Iterator {\n   public:\n    using difference_type = std::ptrdiff_t;\n\n    // The following satisfy BidirectionalIterator:\n    Iterator() : arr_(nullptr), pos_(0u) {}\n    Iterator(Array<T>* arr, size_t pos) : arr_(arr), pos_(pos) {}\n    Iterator& operator++() {\n      ++pos_;\n      return *this;\n    }\n    Iterator operator++(int) {\n      Iterator original = *this;\n      ++pos_;\n      return original;\n    }\n    Iterator& operator--() {\n      --pos_;\n      return *this;\n    }\n    Iterator operator--(int) {\n      Iterator original = *this;\n      --pos_;\n      return original;\n    }\n    bool operator==(const Iterator& o) const {\n      return o.arr_ == arr_ && o.pos_ == pos_;\n    }\n    bool operator!=(const Iterator& o) const { return !(*this == o); }\n    RefType operator*() const { return arr_->at(pos_); }\n    T* operator->() const { return &arr_->at(pos_); }\n\n    // The following satisfy RandomAccessIterator:\n    Iterator& operator+=(difference_type dist) {\n      pos_ += dist;\n      return *this;\n    }\n    Iterator& operator-=(difference_type dist) {\n      pos_ -= dist;\n      return *this;\n    }\n    friend Iterator operator+(difference_type dist, const Iterator& o_it) {\n      return Iterator(o_it.arr_, dist + o_it.pos_);\n    }\n    Iterator operator+(difference_type dist) const {\n      return Iterator(arr_, pos_ + dist);\n    }\n    Iterator operator-(difference_type dist) const {\n      return Iterator(arr_, pos_ - dist);\n    }\n    difference_type operator-(const Iterator& o_it) const {\n      return pos_ - o_it.pos_;\n    }\n    bool operator<(const Iterator& o_it) const { return pos_ < o_it.pos_; }\n    bool operator>(const Iterator& o_it) const { return pos_ > o_it.pos_; }\n    bool operator<=(const Iterator& o_it) const { return pos_ <= o_it.pos_; }\n    bool operator>=(const Iterator& o_it) const { return pos_ >= o_it.pos_; }\n    RefType operator[](difference_type dist) { return arr_->at(pos_ + dist); }\n\n   private:\n    Array<T>* arr_;\n    size_t pos_;\n  };\n\n  Iterator begin() { return Iterator(this, 0); }\n  Iterator end() { return Iterator(this, size()); }\n\n private:\n  void Take(Array* other) {\n    reset();\n    Swap(other);\n  }\n\n  std::vector<T> vec_;\n  bool is_null_;\n\n  MOJO_MOVE_ONLY_TYPE(Array);\n};\n\n// A |TypeConverter| that will create an |Array<T>| containing a copy of the\n// contents of an |std::vector<E>|, using |TypeConverter<T, E>| to copy each\n// element. The returned array will always be non-null.\ntemplate <typename T, typename E>\nstruct TypeConverter<Array<T>, std::vector<E>> {\n  static Array<T> Convert(const std::vector<E>& input) {\n    auto result = Array<T>::New(input.size());\n    for (size_t i = 0; i < input.size(); ++i)\n      result[i] = TypeConverter<T, E>::Convert(input[i]);\n    return result;\n  }\n};\n\n// A |TypeConverter| that will create an |std::vector<E>| containing a copy of\n// the contents of an |Array<T>|, using |TypeConverter<E, T>| to copy each\n// element. If the input array is null, the output vector will be empty.\ntemplate <typename E, typename T>\nstruct TypeConverter<std::vector<E>, Array<T>> {\n  static std::vector<E> Convert(const Array<T>& input) {\n    std::vector<E> result;\n    if (!input.is_null()) {\n      result.resize(input.size());\n      for (size_t i = 0; i < input.size(); ++i)\n        result[i] = TypeConverter<E, T>::Convert(input[i]);\n    }\n    return result;\n  }\n};\n\n// A |TypeConverter| that will create an |Array<T>| containing a copy of the\n// contents of an |std::set<E>|, using |TypeConverter<T, E>| to copy each\n// element. The returned array will always be non-null.\ntemplate <typename T, typename E>\nstruct TypeConverter<Array<T>, std::set<E>> {\n  static Array<T> Convert(const std::set<E>& input) {\n    Array<T> result = Array<T>::New(0u);\n    for (auto i : input)\n      result.push_back(TypeConverter<T, E>::Convert(i));\n    return result;\n  }\n};\n\n// A |TypeConverter| that will create an |std::set<E>| containing a copy of\n// the contents of an |Array<T>|, using |TypeConverter<E, T>| to copy each\n// element. If the input array is null, the output set will be empty.\ntemplate <typename E, typename T>\nstruct TypeConverter<std::set<E>, Array<T>> {\n  static std::set<E> Convert(const Array<T>& input) {\n    std::set<E> result;\n    if (!input.is_null()) {\n      for (size_t i = 0; i < input.size(); ++i)\n        result.insert(TypeConverter<E, T>::Convert(input[i]));\n    }\n    return result;\n  }\n};\n\n}  // namespace mojo\n\n#endif  // MOJO_PUBLIC_CPP_BINDINGS_ARRAY_H_\n\n", "comment_ratio": 0.2120253164556962}
{"lang": "c", "code": "#include \"Shared.h\"\n\n#import \"IDEViewController.h\"\n\n#import \"IDEDebuggerBarEditorInfoProvider-Protocol.h\"\n\n@class DVTBorderedView, DVTLayoutView_ML, DVTObservingToken, DVTReplacementView, DVTSplitView, DVTSplitViewItem, DVTStateToken, IDEDebugArea, IDEDebugBar, IDEEditorContext, IDEEditorDocument, IDEEditorModeViewController, IDENavigableItemArchivableRepresentation, IDEWorkspaceTabControllerLayoutTree, NSMutableDictionary, NSString, NSTouchBar, NSView;\n@protocol DVTCancellable;\n\n@interface IDEEditorArea : IDEViewController <NSTouchBarProvider, NSTouchBarDelegate, IDEDebuggerBarEditorInfoProvider>\n{\n    NSView *_editorModeHostView;\n    IDEEditorModeViewController *_editorModeViewController;\n    int _editorMode;\n    int _versionEditorSubmode;\n    DVTObservingToken *_workspaceActivityObserver;\n    DVTObservingToken *_navigationTargetedEditorContextIsValidObservingToken;\n    IDEEditorContext *_lastActiveEditorContext;\n    IDEDebugBar *_activeDebuggerBar;\n    IDEDebugArea *_activeDebuggerArea;\n    NSMutableDictionary *_defaultPersistentRepresentations;\n    NSString *_currentDefaultDebugAreaExtensionID;\n    DVTLayoutView_ML *_editorAreaAutoLayoutView;\n    DVTLayoutView_ML *_debuggerAreaAutoLayoutView;\n    DVTBorderedView *_debuggerBarBorderedView;\n    DVTBorderedView *_debuggerAreaBorderedView;\n    DVTReplacementView *_debuggerBarReplacementView;\n    DVTReplacementView *_debuggerAreaReplacementView;\n    DVTSplitView *_debuggerSplitView;\n    DVTSplitViewItem *_debugAreaSplitViewItem;\n    double _heightToReturnToDebuggerArea;\n    id _launchSessionObserver;\n    DVTObservingToken *_themeObserver;\n    IDEWorkspaceTabControllerLayoutTree *_layoutTreeForNavigationHUD;\n    IDEWorkspaceTabControllerLayoutTree *_oldLayoutTreeFromStateSaving;\n    BOOL _needsToRefreshContexts;\n    BOOL _didRestoreState;\n    BOOL _userWantsEditorVisible;\n    BOOL _showDebuggerArea;\n    id <DVTCancellable> _setEditorModeAfterDelayToken;\n    id <DVTCancellable> _invokeCompletionBlockAfterDelayToken;\n    IDEEditorContext *_navigationTargetedEditorContext;\n}\n\n+ (long long)version;\n+ (void)configureStateSavingObjectPersistenceByName:(id)arg1;\n+ (id)keyPathsForValuesAffectingShowEditor;\n+ (id)keyPathsForValuesAffectingSelectedNavigableItemArchivedRepresentation;\n+ (id)keyPathsForValuesAffectingNavigationTargetedEditorDocument;\n+ (id)keyPathsForValuesAffectingPrimaryEditorDocument;\n+ (id)keyPathsForValuesAffectingPrimaryEditorContext;\n+ (int)defaultVersionEditorSubmode;\n+ (int)defaultEditorMode;\n+ (BOOL)automaticallyNotifiesObserversOfLastActiveEditorContext;\n@property(retain) IDEEditorContext *navigationTargetedEditorContext; // @synthesize navigationTargetedEditorContext=_navigationTargetedEditorContext;\n@property(nonatomic) int versionEditorSubmode; // @synthesize versionEditorSubmode=_versionEditorSubmode;\n@property(nonatomic) int editorMode; // @synthesize editorMode=_editorMode;\n@property(retain) IDEDebugArea *activeDebuggerArea; // @synthesize activeDebuggerArea=_activeDebuggerArea;\n@property(retain) IDEDebugBar *activeDebuggerBar; // @synthesize activeDebuggerBar=_activeDebuggerBar;\n@property(retain, nonatomic) IDEEditorContext *lastActiveEditorContext; // @synthesize lastActiveEditorContext=_lastActiveEditorContext;\n@property(readonly) DVTReplacementView *debuggerAreaReplacementView; // @synthesize debuggerAreaReplacementView=_debuggerAreaReplacementView;\n@property(nonatomic) BOOL userWantsEditorVisible; // @synthesize userWantsEditorVisible=_userWantsEditorVisible;\n@property(retain) IDEEditorModeViewController *editorModeViewController; // @synthesize editorModeViewController=_editorModeViewController;\n// - (void).cxx_destruct;\n- (void)_clearLayoutTreeForNavigationHUD;\n- (void)setLayoutTreeForNavigationHUD:(IDEWorkspaceTabControllerLayoutTree *)arg1;\n@property(readonly) IDEWorkspaceTabControllerLayoutTree *layoutTreeForNavigationHUD;\n- (id)_generateLayoutTreeForNavigationHUD;\n- (void)discardEditing;\n- (BOOL)commitEditingForAction:(int)arg1 errors:(id)arg2;\n- (void)commitStateToDictionary:(id)arg1;\n- (void)revertStateWithDictionary:(id)arg1;\n- (void)revertState;\n@property(retain) DVTStateToken *stateToken; // @dynamic stateToken;\n- (void)_updateStateSavingRegistrations;\n- (void)splitView:(id)arg1 resizeSubviewsWithOldSize:(struct CGSize)arg2;\n- (void)_resizeSubviewsForHeightIncrease:(double)arg1;\n- (void)_resizeSubviewsForHeightDecrease:(double)arg1;\n- (id)splitView:(id)arg1 additionalEffectiveRectsOfDividerAtIndex:(long long)arg2;\n- (double)splitView:(id)arg1 constrainSplitPosition:(double)arg2 ofSubviewAt:(long long)arg3;\n- (BOOL)splitView:(id)arg1 canCollapseSubview:(id)arg2;\n- (double)splitView:(id)arg1 constrainMaxCoordinate:(double)arg2 ofSubviewAt:(long long)arg3;\n- (double)splitView:(id)arg1 constrainMinCoordinate:(double)arg2 ofSubviewAt:(long long)arg3;\n- (void)compareRevisionChange:(id)arg1;\n- (void)showBlame;\n- (BOOL)validateUserInterfaceItem:(id)arg1;\n- (void)toggleDebuggerVisibility:(id)arg1;\n- (void)activateConsole:(id)arg1;\n@property BOOL showDebuggerArea;\n- (void)_setShowDebuggerArea:(BOOL)arg1 animate:(BOOL)arg2;\n- (void)showDebuggerArea:(id)arg1;\n@property BOOL showEditor;\n- (void)_updateDebuggerBarVisibility;\n- (void)_addDebuggerBarToDebuggerArea;\n- (void)_addDebuggerBarToEditorArea;\n- (void)_moveDebuggerBarToDebuggerArea;\n- (void)_moveDebuggerBarToEditorArea;\n- (void)_hideDebuggerBarAndResetSplitViewFrames;\n- (void)_resetSplitViewFrames;\n@property(readonly) BOOL showDebuggerBar;\n- (id)_defaultPersistentRepresentationForDocumentExtensionIdentifier:(id)arg1 documentURL:(id)arg2;\n- (void)_clearDefaultPersistentRepresentationForDocumentExtensionIdentifier:(id)arg1 documentURL:(id)arg2;\n- (void)_cacheDefaultPersistentRepresentation:(id)arg1 forDocumentExtensionIdentifier:(id)arg2 documentURL:(id)arg3;\n- (void)setStateSavingDefaultPersistentRepresentations:(id)arg1;\n- (id)stateSavingDefaultPersistentRepresentations;\n- (id)_editorContexts;\n- (void)_openEditorOpenSpecifier:(id)arg1 editorContext:(id)arg2 takeFocus:(BOOL)arg3;\n- (void)_openEditorHistoryItem:(id)arg1 editorContext:(id)arg2 takeFocus:(BOOL)arg3;\n@property(readonly) IDENavigableItemArchivableRepresentation *selectedNavigableItemArchivedRepresentation;\n@property(readonly) IDEEditorDocument *navigationTargetedEditorDocument;\n@property(readonly) IDEEditorDocument *primaryEditorDocument;\n@property(readonly) IDEEditorContext *primaryEditorContext;\n- (void)_installDebugAreaWithExtensionID:(id)arg1 revertDebugAreaState:(BOOL)arg2;\n- (void)installDebugAreaWithExtensionID:(id)arg1;\n- (void)installNewDefaultDebugAreaWithExtensionID:(id)arg1;\n- (void)_installDefaultDebugAreaAndRevertDebugAreaState:(BOOL)arg1;\n- (void)installDefaultDebugArea;\n- (void)_setEditorMode:(int)arg1;\n- (void)editorContextWasRemoved:(id)arg1;\n- (void)editorContextDidBecomeLastActiveEditor:(id)arg1;\n- (void)viewWillUninstall;\n- (void)viewDidInstall;\n- (void)_refreshEditorContextsAndPreserveCurrentEditorHistoryStack:(BOOL)arg1;\n- (void)_resetEditor;\n- (BOOL)_canResetEditor;\n- (void)_removeAssistantEditor;\n- (BOOL)_canRemoveAssistantEditor;\n- (id)_addNewAssistantEditor;\n- (BOOL)_canAddNewAssistantEditor;\n- (void)_addAssistantEditor;\n- (BOOL)_canAddAssistantEditor;\n- (void)_setAssistantEditorsLayout:(unsigned long long)arg1;\n- (BOOL)_canChangeAssistantEditorsLayout;\n- (void)primitiveInvalidate;\n- (void)_updateDebugAreaAfterDocumentOpened;\n- (void)_updateDebugBarAfterDocumentOpened;\n- (void)loadView;\n- (void)_setEditorModeViewControllerWithPrimaryEditorContext:(id)arg1;\n- (id)editorAreaDFRController;\n- (id)_fileHistoryNavigationMode;\n- (void)validateHistoryNavigation;\n- (void)navigateHistoryWithSegmentedControl:(id)arg1;\n- (id)_segmentedControlForHistoryNavigation;\n- (id)_editorAreaItem;\n- (id)touchBar:(id)arg1 makeItemForIdentifier:(id)arg2;\n- (id)_touchBarForNavigatorWidget;\n- (id)makeTouchBar;\n- (void)updateTouchBar;\n- (BOOL)wantsToSuppressFunctionBar;\n\n// Remaining properties\n@property(readonly, copy) NSString *debugDescription;\n@property(readonly, copy) NSString *description;\n@property(readonly) Class superclass;\n@property(readonly) NSTouchBar *touchBar;\n\n@end\n\n\n", "comment_ratio": 0.11834319526627218}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n#import <CoreGraphics/CGGeometry.h>\n\ntypedef enum {\n    ZegoAVConfigPreset_Verylow  = 0,\n    ZegoAVConfigPreset_Low      = 1,\n    ZegoAVConfigPreset_Generic  = 2,\n    ZegoAVConfigPreset_High     = 3,    ///< \u624b\u673a\u7aef\u76f4\u64ad\u5efa\u8bae\u4f7f\u7528High\u914d\u7f6e\uff0c\u6548\u679c\u6700\u4f18\n    ZegoAVConfigPreset_Veryhigh = 4\n} ZegoAVConfigPreset;\n\ntypedef enum {\n    ZegoAVConfigVideoFps_Verylow    = 5,\n    ZegoAVConfigVideoFps_Low        = 10,\n    ZegoAVConfigVideoFps_Generic    = 15,\n    ZegoAVConfigVideoFps_High       = 20,\n    ZegoAVConfigVideoFps_Veryhigh   = 25,\n    ZegoAVConfigVideoFps_Superhigh  = 30\n} ZegoAVConfigVideoFps;\n\ntypedef enum {\n    ZegoAVConfigVideoBitrate_Verylow    = 250*1000,\n    ZegoAVConfigVideoBitrate_Low        = 300*1000,\n    ZegoAVConfigVideoBitrate_Generic    = 480*1000,\n    ZegoAVConfigVideoBitrate_High       = 600*1000,\n    ZegoAVConfigVideoBitrate_Veryhigh   = 800*1000,\n    ZegoAVConfigVideoBitrate_Superhigh  = 1000*1000\n} ZegoAVConfigVideoBitrate;\n\n\n/// \\brief \u63a8\u6d41\u89c6\u9891\u914d\u7f6e\n@interface ZegoAVConfig : NSObject\n\n@property (assign) CGSize videoEncodeResolution;    ///< \u89c6\u9891\u7f16\u7801\u8f93\u51fa\u5206\u8fa8\u7387\n@property (assign) CGSize videoCaptureResolution;   ///< \u89c6\u9891\u91c7\u96c6\u5206\u8fa8\u7387\n@property (assign) int fps;                         ///< \u89c6\u9891\u5e27\u7387\n@property (assign) int bitrate;                     ///< \u89c6\u9891\u7801\u7387\n\n/// \\brief \u83b7\u53d6\u9884\u8bbe\u914d\u7f6e\n/// \\param preset \u5206\u4e3a5\u4e2a\u7b49\u7ea7\uff0c\u6839\u636e\u673a\u5668\u6027\u80fd\u548c\u7f51\u7edc\u6761\u4ef6\u9009\u62e9\u9884\u8bbe\uff0c\u624b\u673a\u7aef\u76f4\u64ad\u5efa\u8bae\u4f7f\u7528Generic\u914d\u7f6e\uff0c\u6548\u679c\u6700\u4f18\n/// \\return \u9884\u8bbe\u914d\u7f6e\n+ (ZegoAVConfig *)defaultZegoAVConfig:(ZegoAVConfigPreset)preset;\n\n@end\n\n", "comment_ratio": 0.28846153846153844}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n#import <UIKit/UIKit.h>\n\n@interface NSBundle (CPExtension)\n\n+ (instancetype)cp_tableViewBundle;\n+ (UIImage *)cp_arrowImage;\n+ (UIImage *)cp_checkmarkImage;\n\n@end\n\n", "comment_ratio": 0.3684210526315789}
{"lang": "c", "code": "#include \"sisl-copyright.h\"\n\n/*\n *\n * $Id: s1602.c,v 1.3 2005-02-28 09:04:48 afr Exp $\n *\n */\n\n\n#define S1602\n\n#include \"sislP.h\"\n\f\n#if defined(SISLNEEDPROTOTYPES)\nvoid \ns1602(double estapt[],double endpt[],int ik,int idim,double astpar,\n\t   double *cendpar,SISLCurve **rc,int *jstat)\n#else\nvoid s1602(estapt,endpt,ik,idim,astpar,cendpar,rc,jstat)\n     double estapt[];\n     double endpt[];\n     int    ik;\n     int    idim;\n     double astpar;\n     double *cendpar;\n     SISLCurve  **rc;\n     int    *jstat;\n#endif\n/*\n*********************************************************************\n*                                                                   \n* PURPOSE    : Convert a straight line to a B-spline described curve.\n*             \n*\n* INPUT      : estapt - start point of the straight line \n*              endpt  - end point of the straight line\n*              ik     - the order of the B-spline curve to be found\n*              idim   - The dimension of the space\n*              astpar - start value of parameterization of the curve\n*             \n* OUTPUT\n*            : cendpar - parameter used at the end of the curve\n*              rc      - Pointer to the found curve\n*              jstat  - status messages\n  \n*                                         > 0      : warning\n*                                         = 0      : ok\n*                                         < 0      : error\n*\n* METHOD     : First the knots are found with ik knots in the start\n*              and ik knots in the end of the curve. Then a modified\n*              Marsdens identity is used to find ik vertices equally \n*              spaced on the straight line.\n*\n* EXAMPLE OF USE:\n*\n* REFERENCES :\n*\n*-                                                 \n* CALLS      : s6dist,newCurve,s6err\n*\n*\n* WRITTEN BY : Qyvind Hjelle, SI, Oslo, Norway. 10. Nov 1988\n*\n*********************************************************************\n*/\n{\n  int kit;            /* Loop control                                    */\n  int kit2;           /* Loop contero                                    */\n  int kvert;          /* Counter for position in vertex array            */\n  int kpos=0;         /* Position of error                               */\n  \n  double *st=SISL_NULL;    /* Pointer to the first element of the knot vector\n\t\t\t of the curve.                                   */\n  double *scoef=SISL_NULL; /* Pointer to the first element of the curve's\n\t\t\t B-spline coefficients.                          */\n  double tdist;       /* Distance                                        */\n  double tdel;        /* Delta x, y , ....                               */\n  \n  /* Check input */          \n  \n  if (idim <  1) goto err102;\n  if (ik   <  2) goto err109;\n  \n  /* Find distance between start nd end point */\n  tdist = s6dist(estapt,endpt,idim);\n  \n  \n  /* Make knots. First allocate space */\n  \n  st = newarray(ik*2,DOUBLE);\n  if (st == SISL_NULL) goto err101;\n  \n  for (kit=0; kit<ik; kit++) \n    {\n      st[kit]    = astpar;\n      st[kit+ik] = astpar + tdist;\n    }\n  \n  /* calculate the vertices. First allocate space */ \n  \n  /* First allocate space for vertices */ \n  \n  scoef = newarray(ik*idim,DOUBLE);\n  if (scoef == SISL_NULL) goto err101;\n  \n  /* Find first and last vertex. */ \n  \n  kvert = (ik-1) * idim;\n  for (kit=0; kit<idim; kit++,kvert++) \n    {\n      scoef[kit]   = estapt[kit];\n      scoef[kvert] = endpt[kit];\n    }\n  \n  /* Find other vertices */ \n  \n  for (kit=0; kit<idim; kit++)\n    {   \n      tdel = (endpt[kit] - estapt[kit])/(ik - 1);\n      for (kit2=2; kit2<ik; kit2++)\n\tscoef[(kit2-1)*idim + kit] = scoef[(kit2-2)*idim + kit] + tdel; \n    }\n  \n  /* Make the curve */\n  \n  *rc = SISL_NULL;              \n  *rc = newCurve(ik,ik,st,scoef,1,idim,1);\n  if (*rc == SISL_NULL) goto err101;                \n  \n  *cendpar = st[ik];\n  *jstat = 0;\n  goto out;\n  \n  /* Error in memory allocation */\n  \n err101: \n  *jstat = -101;\n  s6err(\"s1602\",*jstat,kpos);\n  goto out;\n  \n  /* Error in input. Dimension less than 1 */\n  \n err102: \n  *jstat = -102;\n  s6err(\"s1602\",*jstat,kpos);\n  goto out;                          \n  /* Error in input. Order less than 2 */\n  \n err109: \n  *jstat = -109;\n  s6err(\"s1602\",*jstat,kpos);\n  goto out;                          \n    \n out:\n  if (st     != SISL_NULL) freearray(st);\n  if (scoef  != SISL_NULL) freearray(scoef);\n  return;\n}          \n                    \n\n", "comment_ratio": 0.16062176165803108}
{"lang": "c", "code": "#ifndef V8_PROFILER_TICK_SAMPLE_H_\n#define V8_PROFILER_TICK_SAMPLE_H_\n\n#include \"include/v8-profiler.h\"\n#include \"src/base/platform/time.h\"\n#include \"src/globals.h\"\n\nnamespace v8 {\nnamespace internal {\n\nclass Isolate;\n\nstruct TickSample : public v8::TickSample {\n  void Init(Isolate* isolate, const v8::RegisterState& state,\n            RecordCEntryFrame record_c_entry_frame, bool update_stats,\n            bool use_simulator_reg_state = true);\n  base::TimeTicks timestamp;\n};\n\n}  // namespace internal\n}  // namespace v8\n\n#endif  // V8_PROFILER_TICK_SAMPLE_H_\n\n", "comment_ratio": 0.21428571428571427}
{"lang": "c", "code": "#pragma once\n\n#include <string>\n#include <bitset>\n\n#include \"Utilities/Time/Time.h\"\n#include \"Utilities/Math/Math.h\"\n#include \"Core/Event/Events/KeyEvent.h\"\n\nstruct GLFWwindow; // from glfw header file\n\nenum class Profile\n{\n\tANY,\n\tCOMPAT,\n\tCORE,\n};\n\nenum class CursorMode\n{\n\tNORMAL,\n\tHIDDEN,\n\tDISABLED,\n};\n\nnamespace MxEngine\n{\n\tclass Window\n\t{\n\t\tusing WindowHandle = GLFWwindow*;\n\tprivate:\n\t\tMxString title;\n\t\tGLFWwindow* window = nullptr;\n\t\tint width = 0, height = 0;\n\t\tAppEventDispatcher* dispatcher = nullptr;\n\t\tmutable std::bitset<350> keyHeld;\n\t\tmutable std::bitset<350> keyPressed;\n\t\tmutable std::bitset<350> keyReleased;\n\t\tCursorMode cursorMode = CursorMode::NORMAL;\n\t\tbool doubleBuffer = false;\n\t\tVector2 windowPosition{ 0.0f, 0.0f };\n\t\tVector2 cursorPosition{ 0.0f, 0.0f };\n\n\t\tvoid Destroy();\n\t\tvoid Move(Window&& window);\n\tpublic:\n\t\tWindow() = default;\n\t\tWindow(int width, int height, const MxString& title);\n\t\tWindow(const Window&) = delete;\n\t\tWindow(Window&& other) noexcept;\n\t\tWindow& operator=(const Window&) = delete;\n\t\tWindow& operator=(Window&& other) noexcept;\n\t\t~Window();\n\n\t\tint GetHeight() const;\n\t\tint GetWidth() const;\n\t\tbool IsOpen() const;\n\t\tvoid PullEvents() const;\n\t\tvoid OnUpdate();\n\t\tVector2 GetCursorPosition() const;\n\t\tVector2 GetWindowPosition() const;\n\t\tCursorMode GetCursorMode() const;\n\t\tconst MxString& GetTitle() const;\n\t\tbool IsKeyHeld(KeyCode key) const;\n\t\tbool IsKeyPressed(KeyCode key) const;\n\t\tbool IsKeyReleased(KeyCode key) const;\n\t\tWindowHandle GetNativeHandle();\n\t\tAppEventDispatcher& GetEventDispatcher();\n\t\tbool IsCreated() const;\n\t\tWindow& Create();\n\t\tWindow& Close();\n\t\tWindow& SwitchContext();\n\t\tWindow& UseDebugging(bool value = true);\n\t\tWindow& UseDoubleBuffering(bool value = true);\n\t\tWindow& UseCursorMode(CursorMode cursor);\n\t\tWindow& UseCursorPosition(const Vector2& pos);\n\t\tWindow& UseTitle(const MxString& title);\n\t\tWindow& UseWindowPosition(int xpos, int ypos);\n\t\tWindow& UseWindowSize(int width, int height);\n\t\tWindow& UseEventDispatcher(AppEventDispatcher* dispatcher);\n\t\tWindow& UseProfile(int majorVersion, int minorVersion, Profile profile);\n\t};\n}\n", "comment_ratio": 0.25225225225225223}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n#import \"ZYResponse.h\"\nNS_ASSUME_NONNULL_BEGIN\n\n@interface ZYFeedViewModel : NSObject\n\n@property (nonatomic, strong) NSArray<NSString *> * nodeClazzs;\n\n@property (nonatomic, strong) ZYList * dataObject;\n\n+ (instancetype)createFeedViewModel:(ZYList*)object extra:(NSDictionary*)extraParams;\n\n@end\n\nNS_ASSUME_NONNULL_END\n\n", "comment_ratio": 0.2916666666666667}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n#import \"SMFeedMessageData.h\"\n\n#define TABLEVIEW_BACKGROUND_COLOR [UIColor colorWithRed:224.f/255.f green:224.f/255.f blue:224.f/255.f alpha:1]\n\n/*!\n @class SMActivityFeedViewController\n @abstract A standard implementation for presenting instances of @link SMFeedMessageData @/link in an activity feed.\n */\n@interface SMActivityFeedViewController : UIViewController <UITableViewDataSource,UITableViewDelegate,UIContentContainer>\n\n/*!\n @property tableView\n @abstract The table view in which the activity feed is presented.\n */\n@property(strong, nonatomic) UITableView *tableView;\n\n/*!\n @abstract Initializes an instance of this class with the specified frame and style.\n @param frame - Frame in which the activity feed will be presented.\n @param style - The section grouping style.\n @result SMActivityFeedViewController instance with the specified frame and style.\n */\n- (instancetype)initWithFrame:(CGRect)frame andStyle:(UITableViewStyle)style;\n/*!\n @abstract Gets the message data corresponding to the specified index path.\n @param indexPath - An index path in the activity feed.\n @result SMFeedMessageData at the specified index path.\n */\n- (SMFeedMessageData *)messageDataAtIndexPath:(NSIndexPath *)indexPath;\n\n@end\n\n", "comment_ratio": 0.15}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n#import <GoogleMobileAds/GoogleMobileAds.h>\n#import \"EbluAdBaseManager.h\"\n\n@interface AdmobBannerAdHelper : EbluAdBaseManager\n-(GADBannerView *) getAdView;\n-(void)LoadAd;\n+ (instancetype)sharedInstance;\n-(CGFloat) getBannerAdHegiht;\n@end\n\n", "comment_ratio": 0.3684210526315789}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n\nextern NSString *const kVesperCell;\n\n@interface LCVCell : UITableViewCell\n\n@property (weak, nonatomic) IBOutlet UILabel *titleLabel;\n@property (weak, nonatomic) IBOutlet UIImageView *imgView;\n@property (weak, nonatomic) IBOutlet NSLayoutConstraint *imgViewWidthLayoutConstraint;\n@property (nonatomic) CGFloat oldWidthLayoutConstraint;\n\n@end\n\n", "comment_ratio": 0.3333333333333333}
{"lang": "c", "code": "#pragma once\n\n#include <Applications/Window3.h>\n#include \"DisplacementEffect.h\"\nusing namespace gte;\n\nclass VertexTexturesWindow3 : public Window3\n{\npublic:\n    VertexTexturesWindow3(Parameters& parameters);\n\n    virtual void OnIdle();\n\nprivate:\n    bool SetEnvironment();\n    void CreateMesh();\n\n    std::shared_ptr<Visual> mHeightMesh;\n    std::shared_ptr<DisplacementEffect> mEffect;\n};\n\n", "comment_ratio": 0.21428571428571427}
{"lang": "c", "code": "#import \"CNMKGeometry.h\"\n\n\n@class CNMKSearchInternal;\n@protocol CNMKSearchDelegate;\n\n//...\u9014\u5f84\u70b9\ntypedef struct __midPoints\n{\n    double Longitude;\n    double Latitude;\n}midPoints_t;\n//...\u9a7e\u8f66API\u7684\u53c2\u6570\u7ed3\u6784\u4f53Base\ntypedef struct __driving\n{\n    CNMKGeoPoint StartPoint;        //...\u5f00\u59cb\u70b9\u5750\u6807\n    CNMKGeoPoint EndPoint;          //...\u7ed3\u675f\u70b9\u5750\u6807\n    NSInteger midPointCnt;          //...\u5171\u591a\u5c11\u4e2a\u9014\u5f84\u70b9\n    midPoints_t midPoints[50];      //...\u6700\u591a\u652f\u630150\n    \n    CNMKGeoPoint ServerPoints[5000]; //...\u8fd4\u56de\u7ed3\u679c\u70b9\n    \n}driving_t;\ndriving_t gstu_driving;\n\n@interface CNMKSearch : NSObject\n{\n\tid<CNMKSearchDelegate> _delegate;\n\tint _busPolicy;\n\tint _routingPolicy;\n}\n\n@property (nonatomic, retain) id<CNMKSearchDelegate> delegate;\n//...\u516c\u4ea4\u68c0\u7d22\u7b56\u7565\n@property (nonatomic) int busPolicy;\n//...\u9a7e\u4e58\u68c0\u7d22\u7b56\u7565\n@property (nonatomic) int routingPolicy;\n\n\n//...POI\u67e5\u8be2\n//...POI\u57ce\u5e02\u5173\u952e\u5b57\u67e5\u8be2\n- (BOOL)poiSearchInCity:(NSString*)cityCode types:(NSString*)types searchType:(NSString*)searchType dataType:(NSString*)dataType language:(NSInteger)language pageCount:(NSInteger)pageCount pageNumber:(NSInteger)pageNumber;\n\n//...POI\u5468\u8fb9\u5706\u5f62\u67e5\u8be2\n- (BOOL)poiCircleSearch:(NSString*)cityCode centerPoint:(CNMKGeoPoint)point radius:(NSInteger)radius types:(NSString *)types searchType:(NSString*)searchType dataType:(NSString*)dataType language:(NSInteger)language pageCount:(NSInteger)pageCount pageNumber:(NSInteger)pageNumber inRadius:(NSInteger)inRadius sortMethod:(NSInteger)sortMethod;\n\n//...POI\u77e9\u5f62\u8303\u56f4\u67e5\u8be2\u3001dataType\uff1a\u5982\u6c7d\u8f66\u3001\u9910\u996e\n- (BOOL)poiRectangleSearch:(NSString*)cityCode withRect:(CNMKGeoRectNew)rect types:(NSString*)types searchType:(NSString*)searchType dataType:(NSString*)dataType language:(NSInteger)language pageCount:(NSInteger)pageCount pageNumber:(NSInteger)pageNumber;\n\n//...\u516c\u4ea4\u8def\u7ebf\u67e5\u8be2    time\u683c\u5f0f\uff1aHH:MM\n- (BOOL)busSearchInCity:(NSString *)city startPoint:(CNMKGeoPoint)startPoint endPoint:(CNMKGeoPoint)endPoint\n                   time:(NSString *)time;\n\n//...\u9a7e\u8f66\u8def\u7ebf\u67e5\u8be2\n//...directionIconStatus 0\u8868\u793a\u663e\u793a\u9a7e\u8f66\u65b9\u5411\u56fe\u6807\u30011\u8868\u793a\u4e0d\u663e\u793a\u9a7e\u8f66\u65b9\u5411\u56fe\u6807\n- (BOOL)drivingSearch:(CNMKGeoPoint)StartPoint EndPoint:(CNMKGeoPoint)EndPoint iCostModel:(NSInteger)iCostModel iCriterial:(NSInteger)iCriterial language:(NSInteger) language bear:(NSInteger)bear vehiclespeed:(NSInteger)vehiclespeed directionIconStatus:(NSInteger)directionIconStatus;\n\n//...\u9a7e\u8f66\u8def\u7ebf\u67e5\u8be2(\u5e26\u8def\u51b5)\n//...directionIconStatus 0\u8868\u793a\u663e\u793a\u9a7e\u8f66\u65b9\u5411\u56fe\u6807\u30011\u8868\u793a\u4e0d\u663e\u793a\u9a7e\u8f66\u65b9\u5411\u56fe\u6807\n- (BOOL)drivingSearchTraffic:(CNMKGeoPoint)StartPoint EndPoint:(CNMKGeoPoint)EndPoint iCostModel:(NSInteger)iCostModel iCriterial:(NSInteger)iCriterial language:(NSInteger) language bear:(NSInteger)bear vehiclespeed:(NSInteger)vehiclespeed directionIconStatus:(NSInteger)directionIconStatus ArrivalTime:(NSString *)arrivaltime DepartureTime:(NSString *)departuretime;\n\n//...POI\u652f\u6301\u57ce\u5e02\n- (NSArray *)poiCityList;\n\n//...POI\u652f\u6301\u7c7b\u578b\n- (NSArray *)poiTypeList;\n\n//...\u516c\u4ea4\u8def\u7ebf\u652f\u6301\u57ce\u5e02\n- (NSArray *)busCityList;\n\n@end\n\n\n//...\u641c\u7d22delegate\uff0c\u7528\u4e8e\u83b7\u53d6\u641c\u7d22\u7ed3\u679c\n@protocol CNMKSearchDelegate<NSObject>\n@optional\n//...\u8fd4\u56de\u5750\u6807\u70b9\u6240\u5728\u57ce\u5e02\n- (void)onGetCity:(NSString *)city forLocation:(CNMKGeoPoint)location errorCode:(int)errorCode;\n\n/*\n *\u8fd4\u56dePOI\u641c\u7d22\u7ed3\u679c\n *@param poiResultList \u641c\u7d22\u7ed3\u679c\u5217\u8868\uff0c\u6210\u5458\u7c7b\u578b\u4e3aCNMKPoiResult\n *@param type \u8fd4\u56de\u7ed3\u679c\u7c7b\u578b\uff1a CNMKTypePoiList,CNMKTypeAreaPoiList,CNMKAreaMultiPoiList\n *@param error \u9519\u8bef\u53f7\uff0c@see CNMKErrorCode\n */\n- (void)onGetPoiResult:(NSArray*)result searchType:(int)type errorCode:(int)error;\n\n/*\n *\u8fd4\u56de\u516c\u4ea4\u641c\u7d22\u7ed3\u679c\n *@param result \u641c\u7d22\u7ed3\u679c\n *@param error \u9519\u8bef\u53f7\uff0c@see CNMKErrorCode\n */\n- (void)onGetBusResult:(id)result errorCode:(int)error;\n\n/*\n *\u8fd4\u56de\u9a7e\u4e58\u641c\u7d22\u7ed3\u679c\n *@param result \u641c\u7d22\u7ed3\u679c\n *@param error \u9519\u8bef\u53f7\uff0c@see CNMKErrorCode\n */\n- (void)onGetRoutingResult:(id)result errorCode:(int)error;\n\n@end\n\n", "comment_ratio": 0.26785714285714285}
{"lang": "c", "code": "#ifndef _TYPE_TRAITS_FWD_H\n#define _TYPE_TRAITS_FWD_H 1\n\n#include <cstddef>\n\n// namespace std::tr1\nnamespace std\n{\n_GLIBCXX_BEGIN_NAMESPACE(tr1)\n\n  /// @brief  helper classes [4.3].\n  template<typename _Tp, _Tp __v>\n    struct integral_constant;\n  typedef integral_constant<bool, true>     true_type;\n  typedef integral_constant<bool, false>    false_type;\n\n  /// @brief  primary type categories [4.5.1].\n  template<typename _Tp>\n    struct is_void;\n\n  template<typename _Tp>\n    struct is_integral;\n\n  template<typename _Tp>\n    struct is_floating_point;\n\n  template<typename _Tp>\n    struct is_array;\n  \n  template<typename _Tp>\n    struct is_pointer;\n \n  template<typename _Tp>\n    struct is_reference;\n\n  template<typename _Tp>\n    struct is_member_object_pointer;\n  \n  template<typename _Tp>\n    struct is_member_function_pointer;   \n\n  template<typename _Tp>\n    struct is_enum;\n  \n  template<typename _Tp>\n    struct is_union;\n  \n  template<typename _Tp>\n    struct is_class;\n\n  template<typename _Tp>\n    struct is_function;\n\n  /// @brief  composite type traits [4.5.2].\n  template<typename _Tp>\n    struct is_arithmetic;\n\n  template<typename _Tp>\n    struct is_fundamental;\n\n  template<typename _Tp>\n    struct is_object;\n\n  template<typename _Tp>\n    struct is_scalar;\n\n  template<typename _Tp>\n    struct is_compound;\n\n  template<typename _Tp>\n    struct is_member_pointer;\n\n  // Extension.\n  template<typename _Tp>\n    struct __is_union_or_class;\n   \n  /// @brief  type properties [4.5.3].\n  template<typename _Tp>\n    struct is_const;\n  \n  template<typename _Tp>\n    struct is_volatile;\n\n  template<typename _Tp>\n    struct is_pod;\n  \n  template<typename _Tp>\n    struct is_empty;\n  \n  template<typename _Tp>\n    struct is_polymorphic;\n  \n  template<typename _Tp>\n    struct is_abstract;\n  \n  template<typename _Tp>\n    struct has_trivial_constructor;\n  \n  template<typename _Tp>\n    struct has_trivial_copy;\n\n  template<typename _Tp>\n    struct has_trivial_assign;\n  \n  template<typename _Tp>\n    struct has_trivial_destructor;\n  \n  template<typename _Tp>\n    struct has_nothrow_constructor;\n  \n  template<typename _Tp>\n    struct has_nothrow_copy;\n\n  template<typename _Tp>\n    struct has_nothrow_assign;\n  \n  template<typename _Tp>\n    struct has_virtual_destructor;\n  \n  template<typename _Tp>\n    struct is_signed;\n  \n  template<typename _Tp>\n    struct is_unsigned;\n   \n  template<typename _Tp>\n    struct alignment_of;\n  \n  template<typename _Tp>\n    struct rank;\n  \n  template<typename _Tp, unsigned _Uint = 0>\n    struct extent;\n  \n  /// @brief  relationships between types [4.6].\n  template<typename _Tp, typename _Up>\n    struct is_same;\n\n  template<typename _From, typename _To>\n    struct is_convertible;\n\n  template<typename _Base, typename _Derived>\n    struct is_base_of;\n\n  /// @brief  const-volatile modifications [4.7.1].\n  template<typename _Tp>\n    struct remove_const;\n  \n  template<typename _Tp>\n    struct remove_volatile;\n  \n  template<typename _Tp>\n    struct remove_cv;\n  \n  template<typename _Tp>\n    struct add_const;\n   \n  template<typename _Tp>\n    struct add_volatile;\n  \n  template<typename _Tp>\n    struct add_cv;\n\n  /// @brief  reference modifications [4.7.2].\n  template<typename _Tp>\n    struct remove_reference;\n  \n  template<typename _Tp>\n    struct add_reference;\n\n  /// @brief  array modifications [4.7.3].\n  template<typename _Tp>\n    struct remove_extent;\n\n  template<typename _Tp>\n    struct remove_all_extents;\n\n  /// @brief  pointer modifications [4.7.4].\n  template<typename _Tp>\n    struct remove_pointer;\n  \n  template<typename _Tp>\n    struct add_pointer;\n\n  /// @brief  other transformations [4.8].\n  template<std::size_t _Len, std::size_t _Align>\n    struct aligned_storage;\n\n_GLIBCXX_END_NAMESPACE\n}\n\n#endif\n\n", "comment_ratio": 0.15859030837004406}
{"lang": "c", "code": "#include \"myapp-person.h\"\n\n#include <stdio.h>\n\n// ----------------------------------------------------------------------------\n\n/* Instance private data\n * =====================\n */\n\ntypedef struct {\n  gchar* name;\n  int age;\n} MyappPersonPrivate;\n\n/* This helper macro defines the following:\n *\n * static void myapp_person_init(MyappPerson* self);\n * static void myapp_person_class_init(MyappPersonClass* klass);\n * static gpointer myapp_person_parent_class = NULL;\n * static gint MyappPerson_private_offset;\n *\n * static void\n * myapp_person_class_intern_init(gpointer klass)\n * { ... }\n *\n * static inline gpointer\n * myapp_person_get_instance_private(MyappPerson* self)\n * {\n *   return (G_STRUCT_MEMBER_P(self, MyappPerson_private_offset));\n * }\n *\n * GType\n * myapp_person_get_type(void)\n * { ... }\n *\n * MyappPerson_private_offset =\n *   g_type_add_instance_private(g_define_type_id, sizeof (MyappPersonPrivate));\n */\nG_DEFINE_TYPE_WITH_PRIVATE(MyappPerson, myapp_person, G_TYPE_OBJECT)\n\n#define GET_PRIVATE(instance) \\\n    myapp_person_get_instance_private(MYAPP_PERSON(instance))\n\n// ----------------------------------------------------------------------------\n\n/* Instance properties\n * ===================\n */\n\nenum {\n  PROP_NAME = 1,\n  PROP_AGE,\n  N_PROPERTIES\n};\n\nstatic GParamSpec* obj_properties[N_PROPERTIES] = { 0 };\n\nvoid\nmyapp_person_set_property(GObject* object, guint property_id,\n                          const GValue* value, GParamSpec* pspec)\n{\n  MyappPersonPrivate* priv = GET_PRIVATE(object);\n\n  switch (property_id) {\n  case PROP_NAME:\n    g_free(priv->name);\n    priv->name = g_value_dup_string(value);\n    printf(\"myapp_person_set_property(), name: %s\\n\", priv->name);\n    break;\n  case PROP_AGE:\n    priv->age = g_value_get_int(value);\n    printf(\"myapp_person_set_property(), age: %d\\n\", priv->age);\n    break;\n  default:\n    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);\n    break;\n  }\n}\n\nvoid\nmyapp_person_get_property(GObject* object, guint property_id,\n                          GValue* value, GParamSpec* pspec)\n{\n  printf(\"myapp_person_get_property(), property_id: %u\\n\", property_id);\n\n  MyappPersonPrivate* priv = GET_PRIVATE(object);\n\n  switch (property_id) {\n  case PROP_NAME:\n    g_value_set_string(value, priv->name);\n    break;\n  case PROP_AGE:\n    g_value_set_int(value, priv->age);\n    break;\n  default:\n    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);\n    break;\n  }\n}\n\n// ----------------------------------------------------------------------------\n\n/* Class methods\n * =============\n */\n\nvoid\nmyapp_person_say(MyappPerson* self, char* words)\n{\n  printf(\"myapp_person_say()\\n\");\n\n  g_return_if_fail(MYAPP_IS_PERSON(self));\n  g_return_if_fail(words != NULL);\n\n  MyappPersonClass* klass = MYAPP_PERSON_GET_CLASS(self);\n  // g_return_if_fail(klass->say != NULL);\n  klass->say(self, words);\n}\n\nstatic void\nmyapp_person_say_impl(MyappPerson* self, char* words)\n{\n  printf(\"myapp_person_say_impl()\\n\");\n\n  MyappPersonPrivate* priv = GET_PRIVATE(self);\n\n  printf(\"I am Person '%s', aged '%d', and I say '%s'\\n\", priv->name,\n         priv->age, words);\n}\n\n// ----------------------------------------------------------------------------\n\n/* Class destructor\n * ================\n *\n * Unreference all objects in `dispose()`,\n * and free all memory or close file descriptors in `finalize()`.\n */\n\nstatic void\nmyapp_person_dispose(GObject* object)\n{\n  printf(\"myapp_person_dispose()\\n\");\n\n  //MyappPersonPrivate* priv = GET_PRIVATE(object);\n\n  // Release all types referenced from this object\n  //g_object_unref(priv->some_object); priv->some_object = NULL;\n  // Alternative:\n  //g_clear_object(&priv->some_object);\n\n  // Chain up\n  G_OBJECT_CLASS(myapp_person_parent_class)->dispose(object);\n}\n\nstatic void\nmyapp_person_finalize(GObject* object)\n{\n  printf(\"myapp_person_finalize()\\n\");\n\n  MyappPersonPrivate* priv = GET_PRIVATE(object);\n\n  // Free all memory allocated by this object\n  g_free(priv->name); priv->name = NULL;\n  // Alternative:\n  //g_clear_pointer(&priv->name, g_free);\n\n  // Chain up\n  G_OBJECT_CLASS(myapp_person_parent_class)->finalize(object);\n}\n\n// ----------------------------------------------------------------------------\n\n/* Class constructor\n * =================\n */\n\nstatic void\nmyapp_person_init(MyappPerson* self)\n{\n  printf(\"myapp_person_init()\\n\");\n\n  MyappPersonPrivate* priv = GET_PRIVATE(self);\n\n  // Initialize all public and private members to reasonable default values.\n  // They are all automatically initialized to 0 to begin with.\n  priv->name = g_strdup(\"No Name\");\n  priv->age = 99;\n}\n\nstatic void\nmyapp_person_class_init(MyappPersonClass* klass)\n{\n  printf(\"myapp_person_class_init()\\n\");\n\n  // Override virtual methods from GObject\n  GObjectClass* object_class = G_OBJECT_CLASS(klass);\n  object_class->set_property = myapp_person_set_property;\n  object_class->get_property = myapp_person_get_property;\n  object_class->dispose = myapp_person_dispose;\n  object_class->finalize = myapp_person_finalize;\n\n  // Set default implementation for own methods\n  klass->say = myapp_person_say_impl;\n\n  // Register object properties\n  obj_properties[PROP_NAME] =\n      g_param_spec_string(\"name\",\n                          \"Full Name\",\n                          \"The full name of this person\",\n                          \"John Doe\",  // Default value\n                          G_PARAM_CONSTRUCT | G_PARAM_READWRITE);\n  obj_properties[PROP_AGE] =\n      g_param_spec_int(\"age\",\n                       \"Age\",\n                       \"Age of this person\",\n                       0,    // Minimum value\n                       100,  // Maximum value\n                       20,   // Default value\n                       G_PARAM_CONSTRUCT | G_PARAM_READWRITE);\n  g_object_class_install_properties(object_class,\n                                    N_PROPERTIES, obj_properties);\n}\n\n// ----------------------------------------------------------------------------\n\n", "comment_ratio": 0.1145374449339207}
{"lang": "c", "code": "#ifndef CHROME_BROWSER_ASH_ARC_AUTH_ARC_FETCHER_BASE_H_\n#define CHROME_BROWSER_ASH_ARC_AUTH_ARC_FETCHER_BASE_H_\n\n#include \"services/network/public/cpp/shared_url_loader_factory.h\"\n\nnamespace arc {\n\n// Base class for Arc*Fetcher classes, only used to manage the lifetime of their\n// instances.\nclass ArcFetcherBase {\n public:\n  ArcFetcherBase();\n  virtual ~ArcFetcherBase();\n\n  void SetURLLoaderFactoryForTesting(\n      scoped_refptr<network::SharedURLLoaderFactory> factory);\n\n protected:\n  scoped_refptr<network::SharedURLLoaderFactory>\n  url_loader_factory_for_testing() {\n    return url_loader_factory_for_testing_;\n  }\n\n private:\n  scoped_refptr<network::SharedURLLoaderFactory>\n      url_loader_factory_for_testing_;\n};\n\n}  // namespace arc\n\n#endif  // CHROME_BROWSER_ASH_ARC_AUTH_ARC_FETCHER_BASE_H_\n\n", "comment_ratio": 0.19444444444444445}
{"lang": "c", "code": "/*****************************************************************************\n * Wave Simulation in OpenGL\n * (C) 2002 Jakob Thomsen\n * http://home.in.tum.de/~thomsen\n * Modified for GLFW by Sylvain Hellegouarch - sh@programmationworld.com\n * Modified for variable frame rate by Marcus Geelnard\n * 2003-Jan-31: Minor cleanups and speedups / MG\n * 2010-10-24: Formatting and cleanup - Camilla L\u00f6wy\n *****************************************************************************/\n\n#if defined(_MSC_VER)\n // Make MS math.h define M_PI\n #define _USE_MATH_DEFINES\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#include \"..\\deps\\glad\\glad.h\"\n#include \"..\\include\\GLFW\\glfw3.h\"\n\n#include \"..\\deps\\linmath.h\"\n#include \"wave.h\"\n#include \"LinkedList.h\"\n#include \"ParseLogs.h\"\n\n#define INTERFRAME_HEIGHT_SPACING_PX 1\n\n// Maximum delta T to allow for differential calculations\n#define MAX_DELTA_T 0.01\n\n// Animation speed (10.0 looks good)\n#define ANIMATION_SPEED 10.0\n\nGLfloat alpha = 210.f, beta = -70.f;\nGLfloat z = 0.f;\nGLfloat zoom = 1000.f;\n\ndouble cursorX;\ndouble cursorY;\n\n#define GRIDW 5\n#define GRIDH 5\n#define GRIDD 2\n#define VERTEXNUM (GRIDW*GRIDH*GRIDD)\n\nGLuint quad[VERTEXNUM];\nstruct Vertex vertex[VERTEXNUM];\nstruct Node * linked_list;\nstruct Vertex * vertex_array = NULL;\nint vertex_array_length = 0;\nint * indices;\n\n/* The grid will look like this:\n *\n *      3   4   5\n *      *---*---*\n *      |   |   |\n *      | 0 | 1 |\n *      |   |   |\n *      *---*---*\n *      0   1   2\n */\n\n\nvoid update_vertex_array()\n{\n\tToArray(*linked_list, &vertex_array);\n\tvertex_array_length = NumberOfElements(*linked_list);\n\tglVertexPointer(3, GL_FLOAT, sizeof(struct Vertex), vertex_array);\n\tglColorPointer(3, GL_FLOAT, sizeof(struct Vertex), &(vertex_array[0].r)); // Pointer to the first color\n}\n\n\n//========================================================================\n// Initialize grid geometry\n//========================================================================\n\nvoid init_vertices(void)\n{\n    int x, y, z, p;\n\n    // Place the vertices in a grid\n    for (y = 0;  y < GRIDH;  y++)\n    {\n        for (x = 0;  x < GRIDW;  x++)\n        {\n\t\t\tfor (z = 0; z < GRIDD; z++)\n\t\t\t{\n\t\t\t\tp = (y * GRIDW * GRIDD) + (x * GRIDD) + z;\n\n\t\t\t\tvertex[p].x = (GLfloat) (x - GRIDW / 2) / (GLfloat) (GRIDW / 2);\n\t\t\t\tvertex[p].y = (GLfloat) (y - GRIDH / 2) / (GLfloat) (GRIDH / 2);\n\t\t\t\tvertex[p].z = INTERFRAME_HEIGHT_SPACING_PX*z;\n\t\t\t\t//vertex[p].z = 0;\n\n\t\t\t\tif ((x % 4 < 2) ^ (y % 4 < 2))\n\t\t\t\t\tvertex[p].r = 0.0;\n\t\t\t\telse\n\t\t\t\t\tvertex[p].r = 1.0;\n\n\t\t\t\tvertex[p].g = (GLfloat) y / (GLfloat) GRIDH;\n\t\t\t\tvertex[p].b = 1.f - ((GLfloat) x / (GLfloat) GRIDW + (GLfloat) y / (GLfloat) GRIDH) / 2.f;\n\n\t\t\t}\n        }\n    }\n\n    for (int i=0; i<VERTEXNUM;i++)\n    {        \n\t\tquad[i] =i;\n    }\n\n\tupdate_vertex_array();\n}\n\n//========================================================================\n// Draw scene\n//========================================================================\n\nvoid draw_scene(GLFWwindow* window)\n{\n    // Clear the color and depth buffers\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n    // We don't want to modify the projection matrix\n    glMatrixMode(GL_MODELVIEW);\n    glLoadIdentity();\n\n    // Move back\n    glTranslatef(0.0, z, -zoom);\n    // Rotate the view\n    glRotatef(beta, 1.0, 0.0, 0.0);\n    glRotatef(alpha, 0.0, 0.0, 1.0);\n\n    glDrawElements(GL_POINTS, vertex_array_length, GL_UNSIGNED_INT, indices);\n\t//glDrawElements(GL_POINTS, VERTEXNUM, GL_UNSIGNED_INT, quad);\n\n    glfwSwapBuffers(window);\n}\n\n\n//========================================================================\n// Initialize Miscellaneous OpenGL state\n//========================================================================\n\nvoid init_opengl(void)\n{\n    // Use Gouraud (smooth) shading\n    glShadeModel(GL_SMOOTH);\n\n    // Switch on the z-buffer\n    glEnable(GL_DEPTH_TEST);\n\n    glEnableClientState(GL_VERTEX_ARRAY);\n    glEnableClientState(GL_COLOR_ARRAY);\n    glVertexPointer(3, GL_FLOAT, sizeof(struct Vertex), vertex);\n    glColorPointer(3, GL_FLOAT, sizeof(struct Vertex), &vertex[0].r); // Pointer to the first color\n\n    glPointSize(2.0);\n\n    // Background color is black\n    glClearColor(0, 0, 0, 0);\n}\n\n\n//========================================================================\n// Print errors\n//========================================================================\n\nstatic void error_callback(int error, const char* description)\n{\n    fprintf(stderr, \"Error: %s\\n\", description);\n}\n\n\n//========================================================================\n// Handle key strokes\n//========================================================================\n\nvoid key_callback(GLFWwindow* window, int key, int scancode, int action, int mods)\n{\n    if (action != GLFW_PRESS)\n        return;\n\n    switch (key)\n    {\n        case GLFW_KEY_ESCAPE:\n            glfwSetWindowShouldClose(window, GLFW_TRUE);\n            break;\n        case GLFW_KEY_SPACE:\n            break;\n        case GLFW_KEY_LEFT:\n            alpha += 5;\n            break;\n        case GLFW_KEY_RIGHT:\n            alpha -= 5;\n            break;\n        case GLFW_KEY_UP:\n            //beta -= 5;\n\t\t\tz -= 1;\n            break;\n        case GLFW_KEY_DOWN:\n            //beta += 5;\n\t\t\tz += 1;\n            break;\n        case GLFW_KEY_PAGE_UP:\n            zoom -= 0.25f;\n            if (zoom < 0.f)\n                zoom = 0.f;\n            break;\n        case GLFW_KEY_PAGE_DOWN:\n            zoom += 0.25f;\n            break;\n        default:\n            break;\n    }\n}\n\n\n//========================================================================\n// Callback function for mouse button events\n//========================================================================\n\nvoid mouse_button_callback(GLFWwindow* window, int button, int action, int mods)\n{\n    if (button != GLFW_MOUSE_BUTTON_LEFT)\n        return;\n\n    if (action == GLFW_PRESS)\n    {\n        glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);\n        glfwGetCursorPos(window, &cursorX, &cursorY);\n    }\n    else\n        glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_NORMAL);\n}\n\n\n//========================================================================\n// Callback function for cursor motion events\n//========================================================================\n\nvoid cursor_position_callback(GLFWwindow* window, double x, double y)\n{\n    if (glfwGetInputMode(window, GLFW_CURSOR) == GLFW_CURSOR_DISABLED)\n    {\n        alpha += (GLfloat) (x - cursorX) / 10.f;\n        //beta += (GLfloat) (y - cursorY) / 10.f;\n\t\tz -= (GLfloat)(y - cursorY) / 10.f;\n\n        cursorX = x;\n        cursorY = y;\n    }\n}\n\n\n//========================================================================\n// Callback function for scroll events\n//========================================================================\n\nvoid scroll_callback(GLFWwindow* window, double x, double y)\n{\n    zoom += (float) 15.f * y;\n    if (zoom < 0)\n        zoom = 0;\n}\n\n\n//========================================================================\n// Callback function for framebuffer resize events\n//========================================================================\n\nvoid framebuffer_size_callback(GLFWwindow* window, int width, int height)\n{\n    float ratio = 1.f;\n    mat4x4 projection;\n\n    if (height > 0)\n        ratio = (float) width / (float) height;\n\n    // Setup viewport\n    glViewport(0, 0, width, height);\n\n    // Change to the projection matrix and set our viewing volume\n    glMatrixMode(GL_PROJECTION);\n    mat4x4_perspective(projection,\n                       60.f * (float) M_PI / 180.f,\n                       ratio,\n                       1.f, 1024.f);\n    glLoadMatrixf((const GLfloat*) projection);\n}\n\n\n//========================================================================\n// main\n//========================================================================\n\nint main(int argc, char* argv[])\n{\n    GLFWwindow* window;\n    double t, dt_total, t_old;\n    int width, height;\n\n    glfwSetErrorCallback(error_callback);\n\n    if (!glfwInit())\n        exit(EXIT_FAILURE);\n\n    window = glfwCreateWindow(640, 480, \"Wave Simulation\", NULL, NULL);\n    if (!window)\n    {\n        glfwTerminate();\n        exit(EXIT_FAILURE);\n    }\n\n    glfwSetKeyCallback(window, key_callback);\n    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);\n    glfwSetMouseButtonCallback(window, mouse_button_callback);\n    glfwSetCursorPosCallback(window, cursor_position_callback);\n    glfwSetScrollCallback(window, scroll_callback);\n\n    glfwMakeContextCurrent(window);\n    gladLoadGLLoader((GLADloadproc) glfwGetProcAddress);\n    glfwSwapInterval(1);\n\n    glfwGetFramebufferSize(window, &width, &height);\n    framebuffer_size_callback(window, width, height);\n\n    // Initialize OpenGL\n    init_opengl();\n\n\tchar const* filename = \"C:\\\\VTCProject\\\\trackviewer\\\\build\\\\vertex.txt\";\n\tFILE * fp = fopen(filename, \"r\");\n\tParseTextfile(fp, &linked_list);\n\n\tchar debugString[100] = { 0 };\n\t\n\tint count = NumberOfElements(*linked_list);\n\tsprintf(debugString, \"linked_list: %d elements \\r\\n\", count);\n\tOutputDebugString(debugString);\n\n\tPrintElements(*linked_list);\n\tupdate_vertex_array();\n\n\tindices = malloc(vertex_array_length * sizeof(GLuint));\n\tfor (int i = 0; i<vertex_array_length; i++)\n\t{\n\t\tindices[i] = i;\n\t}\n\n    // Initialize simulation\n    //init_vertices();\n\n    // Initialize timer\n    t_old = glfwGetTime() - 0.01;\n\n    while (!glfwWindowShouldClose(window))\n    {\n        draw_scene(window);\n        glfwPollEvents();\n    }\n\n    exit(EXIT_SUCCESS);\n}\n\n\n", "comment_ratio": 0.14945652173913043}
{"lang": "c", "code": "#ifndef IoT_UnitsOfMeasure_UnitsOfMeasureServiceRemoteObject_INCLUDED\n#define IoT_UnitsOfMeasure_UnitsOfMeasureServiceRemoteObject_INCLUDED\n\n\n#include \"IoT/UnitsOfMeasure/IUnitsOfMeasureService.h\"\n#include \"Poco/RemotingNG/Identifiable.h\"\n#include \"Poco/RemotingNG/RemoteObject.h\"\n#include \"Poco/SharedPtr.h\"\n\n\nnamespace IoT {\nnamespace UnitsOfMeasure {\n\n\nclass UnitsOfMeasureServiceRemoteObject: public IoT::UnitsOfMeasure::IUnitsOfMeasureService, public Poco::RemotingNG::RemoteObject\n\t/// The UnitsOfMeasureService service is mainly used to map\n\t/// [[http://unitsofmeasure.org/ucum.html Unified Code for Units of Measure]] (UCUM),\n\t/// codes, such as used with the IoT::Devices::Sensor interface, to display/print units.\n\t///\n\t/// It provides a programmatic interface to the\n\t/// [[http://unitsofmeasure.org/ucum-essence.xml UCUM-Essence XML file]]\n\t/// containing unit definitions.\n{\npublic:\n\ttypedef Poco::AutoPtr<UnitsOfMeasureServiceRemoteObject> Ptr;\n\n\tUnitsOfMeasureServiceRemoteObject(const Poco::RemotingNG::Identifiable::ObjectId& oid, Poco::SharedPtr<IoT::UnitsOfMeasure::UnitsOfMeasureService> pServiceObject);\n\t\t/// Creates a UnitsOfMeasureServiceRemoteObject.\n\n\tvirtual ~UnitsOfMeasureServiceRemoteObject();\n\t\t/// Destroys the UnitsOfMeasureServiceRemoteObject.\n\n\tIoT::UnitsOfMeasure::CanonicalValue canonicalize(double value, const std::string& prefixedCode) const;\n\t\t/// Removes the prefix from the code and scales the value accordingly.\n\n\tvirtual double convert(double value, const std::string& fromPrefixedCode, const std::string& toPrefixedCode) const;\n\t\t/// Converts the value from one unit (given in fromPrefixedCode) to a different one (given in\n\t\t/// toPrefixedCode). Conversion only works if both units share the same base unit.\n\n\tPoco::SharedPtr < IoT::UnitsOfMeasure::Prefix > findPrefix(const std::string& code) const;\n\t\t/// Looks up the prefix with the given code.\n\t\t///\n\t\t/// Returns the Prefix, or a null pointer if not found.\n\n\tPoco::SharedPtr < IoT::UnitsOfMeasure::Unit > findUnit(const std::string& code) const;\n\t\t/// Looks up the unit with the given (non-prefixed) code.\n\t\t///\n\t\t/// Returns the Unit, or a null pointer if not found.\n\n\tvirtual std::string format(const std::string& prefixedCode) const;\n\t\t/// Looks up the given unit code with optional prefix (e.g., \"cm\")\n\t\t/// and returns the \"printable\" string.\n\t\t///\n\t\t/// If not found, simply returns prefixedCode.\n\n\tvirtual const Poco::RemotingNG::Identifiable::TypeId& remoting__typeId() const;\n\n\tIoT::UnitsOfMeasure::PrefixedUnit resolve(const std::string& prefixedCode) const;\n\t\t/// Looks up the given unit code with optional prefix (e.g., \"cm\")\n\t\t/// and returns a PrefixUnit structure containing the (optional) prefix\n\t\t/// and unit information.\n\t\t///\n\t\t/// Throws a Poco::NotFoundException if no matching unit is found.\n\nprivate:\n\tPoco::SharedPtr<IoT::UnitsOfMeasure::UnitsOfMeasureService> _pServiceObject;\n};\n\n\ninline IoT::UnitsOfMeasure::CanonicalValue UnitsOfMeasureServiceRemoteObject::canonicalize(double value, const std::string& prefixedCode) const\n{\n\treturn _pServiceObject->canonicalize(value, prefixedCode);\n}\n\n\ninline double UnitsOfMeasureServiceRemoteObject::convert(double value, const std::string& fromPrefixedCode, const std::string& toPrefixedCode) const\n{\n\treturn _pServiceObject->convert(value, fromPrefixedCode, toPrefixedCode);\n}\n\n\ninline Poco::SharedPtr < IoT::UnitsOfMeasure::Prefix > UnitsOfMeasureServiceRemoteObject::findPrefix(const std::string& code) const\n{\n\treturn _pServiceObject->findPrefix(code);\n}\n\n\ninline Poco::SharedPtr < IoT::UnitsOfMeasure::Unit > UnitsOfMeasureServiceRemoteObject::findUnit(const std::string& code) const\n{\n\treturn _pServiceObject->findUnit(code);\n}\n\n\ninline std::string UnitsOfMeasureServiceRemoteObject::format(const std::string& prefixedCode) const\n{\n\treturn _pServiceObject->format(prefixedCode);\n}\n\n\ninline const Poco::RemotingNG::Identifiable::TypeId& UnitsOfMeasureServiceRemoteObject::remoting__typeId() const\n{\n\treturn IUnitsOfMeasureService::remoting__typeId();\n}\n\n\ninline IoT::UnitsOfMeasure::PrefixedUnit UnitsOfMeasureServiceRemoteObject::resolve(const std::string& prefixedCode) const\n{\n\treturn _pServiceObject->resolve(prefixedCode);\n}\n\n\n} // namespace UnitsOfMeasure\n} // namespace IoT\n\n\n#endif // IoT_UnitsOfMeasure_UnitsOfMeasureServiceRemoteObject_INCLUDED\n\n\n", "comment_ratio": 0.3333333333333333}
{"lang": "c", "code": "#ifndef LVEC2_OPS_H\n#define LVEC2_OPS_H\n\n#include <math.h>\n#include \"nearly_zero.h\"\n#include \"lvecBase2.h\"\n#include \"lpoint2.h\"\n#include \"lvector2.h\"\n\n#include \"fltnames.h\"\n#include \"lvec2_ops_src.h\"\n\n#include \"dblnames.h\"\n#include \"lvec2_ops_src.h\"\n\n#include \"intnames.h\"\n#include \"lvec2_ops_src.h\"\n\n#endif\n\n", "comment_ratio": 0.38235294117647056}
{"lang": "c", "code": "#include <stdlib.h> // used for the dtostrf function\n\n//#define DHTTYPE DHT11   // DHT 11 \n#define DHTTYPE DHT22   // DHT 22  (AM2302)\n//#define DHTTYPE DHT21   // DHT 21 (AM2301)\n#define DHTPIN 6     // what pin the DHT is connected to\n#define UNIT 1      // 0 for Fahrenheit and 1 for Celsius\n\nDHT dht(DHTPIN, DHTTYPE); // set dht\n\nchar home_temperature() {\n    // reset error\n    error.is_error = false;\n    memset(&error.message, 0, sizeof(error.message)); // clear it\n    \n    // declare variables\n    char temperature[7]; //2 int, 2 dec, 1 point, and \\0\n    float t = 0;\n    float tf = 0;\n\n    // empty variables\n    memset(&temperature, 0, sizeof(temperature)); // clear it\n\n    t = dht.readTemperature();\n    tf = t * 1.8 +32;  //Convert from C to F\n\n    if (isnan(t)) {\n      Serial.println(\"Error getTemperature(), Failed read DHT !\");\n      error.is_error = true;\n      strncpy( error.message, \"Failed read DHT !\", sizeof(error.message)-1 );\n\n      return (char) \"Failed read DHT !\";\n    }\n\n    error.is_error = false;\n\n    Serial.print(\"Temperature: \");\n    if (UNIT == 0 ){  //choose the right unit F or C\n      Serial.print(tf);\n      Serial.println(\" *F\");\n      //Floats don't work in sprintf statements on Arduino without pain, so convert to string separately.\n      dtostrf(tf, 2, 2, temperature); // dtostrf convert it to 2 before decimal and 2 after decimal\n    }else {\n      Serial.print(t);\n      Serial.println(\" *C\");\n      dtostrf(t, 2, 2, temperature); // dtostrf convert it to 2 before decimal and 2 after decimal\n    }\n\n    return temperature;\n}\n\nchar *home_humidity() {\n    // reset error\n    error.is_error = false;\n    memset(&error.message, 0, sizeof(error.message)); // clear it\n    \n    // declare variables\n    char humidity[7]; //2 int, 2 dec, 1 point, and \\0\n    float h = 0;\n\n    // empty variables\n    memset(&humidity, 0, sizeof(humidity)); // clear it\n\n    h = dht.readHumidity();\n\n    if (isnan(h)) {\n      Serial.println(\"Error getHumidity(), Failed read DHT !\");\n      error.is_error = true;\n      strncpy( error.message, \"Failed read DHT !\", sizeof(error.message)-1 );\n\n      return (char *) \"Failed read DHT !\";\n    }\n\n    error.is_error = false;\n\n    Serial.print(\"Humidity: \"); \n    Serial.print(h);\n    Serial.println(\" %\\t\");\n\n    //Floats don't work in sprintf statements on Arduino without pain, so convert to string separately.\n    dtostrf(h, 2, 2, humidity); // dtostrf convert it to 2 before decimal and 2 after decimal\n\n    return humidity;\n}\n", "comment_ratio": 0.30952380952380953}
{"lang": "c", "code": "#ifndef CTRANSFORMATIONSYSTEM_H\n#define CTRANSFORMATIONSYSTEM_H\n\n#include \"ISystem.h\"\n#include \"CTransformationComponent.h\"\n\n\nnamespace jam {\nCLASS_PTR(IEntity)\nCLASS_PTR(CTransfromationSystem)\n\nclass CTransfromationSystem : public CSystemBase<CTransformationComponent> {\n    JAM_OBJECT\npublic:\n    CTransfromationSystem();\n    virtual ~CTransfromationSystem();\n\n    virtual void Update(unsigned long dt) override;\n    void UpdateTransformsRecursively(CTransformationComponentPtr transformationComponent);\n};\n\n} // namespace jam\n\n#endif /* CTRANSFORMATIONSYSTEM_H */\n\n", "comment_ratio": 0.24242424242424243}
{"lang": "c", "code": "//\n//  MBVinRecognizer.h\n//  Microblink\n//\n//  Created by Dino Gustin on 23/04/2018.\n//\n\n#import <Foundation/Foundation.h>\n#import \"MBMicroblinkDefines.h\"\n#import \"MBRecognizer.h\"\n#import \"MBVinRecognizerResult.h\"\n#import \"MBMicroblinkInitialization.h\"\n\nNS_ASSUME_NONNULL_BEGIN\n\n/**\n * Recognizer that can perform recognition of VINs (Vehicle Identification Number).\n */\nMB_CLASS_AVAILABLE_IOS(8.0) MB_FINAL\n@interface MBIVinRecognizer : MBIRecognizer<NSCopying>\n\nMB_INIT\n\n/**\n * Vin recognizer result\n */\n@property (nonatomic, strong, readonly) MBIVinRecognizerResult *result;\n\n@end\n\nNS_ASSUME_NONNULL_END\n\n", "comment_ratio": 0.1875}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n\ntypedef void(^RequestSuccessBlock)(NSMutableArray *mutableArray);\ntypedef void(^RequestFailBlock)(void);\n\n@interface Fcgo_HomeViewModel : NSObject\n\n//\u8bf7\u6c42\u8f6e\u64ad\u6570\u636e\n+ (void)postRequestCycleListSuccess:(RequestSuccessBlock )requestSuccessBlock\n                             ofFail:(RequestFailBlock )requestFailBlock;\n\n\n//\u8bf7\u6c42H5\u6570\u636e\n+ (void)postRequestH5Success:(void(^)(NSDictionary *dict))requestSuccessBlock\n                                ofFail:(RequestFailBlock )requestFailBlock;\n//\u8bf7\u6c42\u5206\u7c7b\u56fe\u6807\u6570\u636e\n+ (void)postRequestSortIconListSuccess:(RequestSuccessBlock )requestSuccessBlock\n                                         ofFail:(RequestFailBlock )requestFailBlock;\n//\u8bf7\u6c42\u6574\u70b9\u62a2\u6570\u636e\n+ (void)postRequestGrabTheWholePointListSuccess:(RequestSuccessBlock )requestSuccessBlock\n                                         ofFail:(RequestFailBlock )requestFailBlock;\n//\u8bf7\u6c42\u6d3b\u52a8\u4fc3\u9500\u6570\u636e\n+ (void)postRequestPromoteListSuccess:(RequestSuccessBlock )requestSuccessBlock\n                                         ofFail:(RequestFailBlock )requestFailBlock;\n//\u8bf7\u6c42\u4e13\u9898\u6570\u636e\n+ (void)postRequestChoseSpecilSuccess:(RequestSuccessBlock )requestSuccessBlock\n                                         ofFail:(RequestFailBlock )requestFailBlock;\n\n//\u70ed\u95e8\u63a8\u8350\u6570\u636e\n+ (void)postRequestAdviceListWithPage:(int)page success:(RequestSuccessBlock )requestSuccessBlock    ofFail:(RequestFailBlock )requestFailBlock;\n\n@end\n\n", "comment_ratio": 0.34146341463414637}
{"lang": "c", "code": "#include \"bspatch.h\"\n#include \"bzlib.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <err.h>\n#include <unistd.h>\n#include <fcntl.h>\n\nstatic int64_t offtin(uint8_t *buf)\n{\n\tint64_t y;\n\n\ty=buf[7]&0x7F;\n\ty=y*256;y+=buf[6];\n\ty=y*256;y+=buf[5];\n\ty=y*256;y+=buf[4];\n\ty=y*256;y+=buf[3];\n\ty=y*256;y+=buf[2];\n\ty=y*256;y+=buf[1];\n\ty=y*256;y+=buf[0];\n\n\tif(buf[7]&0x80) y=-y;\n\n\treturn y;\n}\n\nint applypatch(int argc, char * argv[]) {\n    FILE * f, *cpf, *dpf, *epf;\n    BZFILE * cpfbz2, *dpfbz2, *epfbz2;\n    int cbz2err, dbz2err, ebz2err;\n    int fd;\n    ssize_t oldsize, newsize;\n    ssize_t bzctrllen, bzdatalen;\n    u_char header[32], buf[8];\n    u_char *oldApk, *newApk;\n    off_t oldpos, newpos;\n    off_t ctrl[3];\n    off_t lenread;\n    off_t i;\n    \n    if (argc != 4)\n        //errx(1, \"usage: %s oldfile newfile patchfile\\n\", argv[0]);\n        return -1;\n    /* Open patch file */\n    if ((f = fopen(argv[3], \"r\")) == NULL)\n        //err(1, \"fopen(%s)\", argv[3]);\n        return -1;\n    \n    /*\n     File format:\n     0\t8\t\"BSDIFF40\"\n     8\t8\tX\n     16\t8\tY\n     24\t8\tsizeof(newfile)\n     32\tX\tbzip2(control block)\n     32+X\tY\tbzip2(diff block)\n     32+X+Y\t???\tbzip2(extra block)\n     with control block a set of triples (x,y,z) meaning \"add x bytes\n     from oldfile to x bytes from the diff block; copy y bytes from the\n     extra block; seek forwards in oldfile by z bytes\".\n     */\n    \n    /* Read header */\n    if (fread(header, 1, 32, f) < 32) {\n        return -1;\n    }\n    \n    /* Check for appropriate magic */\n    if (memcmp(header, \"BSDIFF40\", 8) != 0)\n        //errx(1, \"Corrupt patch\\n\");\n        return -1;\n    \n    /* Read lengths from header */\n    bzctrllen = offtin(header + 8);\n    bzdatalen = offtin(header + 16);\n    newsize = offtin(header + 24);\n    if ((bzctrllen < 0) || (bzdatalen < 0) || (newsize < 0))\n        //errx(1, \"Corrupt patch\\n\");\n        return -1;\n    \n    /* Close patch file and re-open it via libbzip2 at the right places */\n    if (fclose(f))\n        //err(1, \"fclose(%s)\", argv[3]);\n        return -1;\n    if ((cpf = fopen(argv[3], \"r\")) == NULL)\n        //err(1, \"fopen(%s)\", argv[3]);\n        return -1;\n    if (fseeko(cpf, 32, SEEK_SET))\n        //err(1, \"fseeko(%s, %lld)\", argv[3], (long long) 32);\n        return -1;\n    if ((cpfbz2 = BZ2_bzReadOpen(&cbz2err, cpf, 0, 0, NULL, 0)) == NULL)\n        //errx(1, \"BZ2_bzReadOpen, bz2err = %d\", cbz2err);\n        return -1;\n    if ((dpf = fopen(argv[3], \"r\")) == NULL)\n        //err(1, \"fopen(%s)\", argv[3]);\n        return -1;\n    if (fseeko(dpf, 32 + bzctrllen, SEEK_SET))\n        //err(1, \"fseeko(%s, %lld)\", argv[3], (long long) (32 + bzctrllen));\n        return -1;\n    if ((dpfbz2 = BZ2_bzReadOpen(&dbz2err, dpf, 0, 0, NULL, 0)) == NULL)\n        //errx(1, \"BZ2_bzReadOpen, bz2err = %d\", dbz2err);\n        return -1;\n    if ((epf = fopen(argv[3], \"r\")) == NULL)\n        //err(1, \"fopen(%s)\", argv[3]);\n        return -1;\n    if (fseeko(epf, 32 + bzctrllen + bzdatalen, SEEK_SET))\n//        err(1, \"fseeko(%s, %lld)\", argv[3],\n//            (long long) (32 + bzctrllen + bzdatalen));\n        return -1;\n    if ((epfbz2 = BZ2_bzReadOpen(&ebz2err, epf, 0, 0, NULL, 0)) == NULL)\n        //errx(1, \"BZ2_bzReadOpen, bz2err = %d\", ebz2err);\n        return -1;\n    \n    if (((fd = open(argv[1], O_RDONLY, 0)) < 0)\n        || ((oldsize = lseek(fd, 0, SEEK_END)) == -1)\n        || ((oldApk = malloc(oldsize + 1)) == NULL)\n        || (lseek(fd, 0, SEEK_SET) != 0)\n        || (read(fd, oldApk, oldsize) != oldsize) || (close(fd) == -1))\n        //err(1, \"%s\", argv[1]);\n        return -1;\n    if ((newApk = malloc(newsize + 1)) == NULL)\n        //err(1, NULL);\n        return -1;\n    \n    oldpos = 0;\n    newpos = 0;\n    while (newpos < newsize) {\n        /* Read control data */\n        for (i = 0; i <= 2; i++) {\n            lenread = BZ2_bzRead(&cbz2err, cpfbz2, buf, 8);\n            if ((lenread < 8)\n                || ((cbz2err != BZ_OK) && (cbz2err != BZ_STREAM_END)))\n                //errx(1, \"Corrupt patch\\n\");\n                return -1;\n            ctrl[i] = offtin(buf);\n        };\n        \n        /* Sanity-check */\n        if (newpos + ctrl[0] > newsize)\n            //errx(1, \"Corrupt patch\\n\");\n            return -1;\n        \n        /* Read diff string */\n        lenread = BZ2_bzRead(&dbz2err, dpfbz2, newApk + newpos, ctrl[0]);\n        if ((lenread < ctrl[0])\n            || ((dbz2err != BZ_OK) && (dbz2err != BZ_STREAM_END)))\n            //errx(1, \"Corrupt patch\\n\");\n            return -1;\n        \n        /* Add old data to diff string */\n        for (i = 0; i < ctrl[0]; i++)\n            if ((oldpos + i >= 0) && (oldpos + i < oldsize))\n                newApk[newpos + i] += oldApk[oldpos + i];\n        \n        /* Adjust pointers */\n        newpos += ctrl[0];\n        oldpos += ctrl[0];\n        \n        /* Sanity-check */\n        if (newpos + ctrl[1] > newsize)\n            //errx(1, \"Corrupt patch\\n\");\n            return -1;\n        \n        /* Read extra string */\n        lenread = BZ2_bzRead(&ebz2err, epfbz2, newApk + newpos, ctrl[1]);\n        if ((lenread < ctrl[1])\n            || ((ebz2err != BZ_OK) && (ebz2err != BZ_STREAM_END)))\n           // errx(1, \"Corrupt patch\\n\");\n            return -1;\n        \n        /* Adjust pointers */\n        newpos += ctrl[1];\n        oldpos += ctrl[2];\n    };\n    \n    /* Clean up the bzip2 reads */\n    BZ2_bzReadClose(&cbz2err, cpfbz2);\n    BZ2_bzReadClose(&dbz2err, dpfbz2);\n    BZ2_bzReadClose(&ebz2err, epfbz2);\n    if (fclose(cpf) || fclose(dpf) || fclose(epf))\n        //err(1, \"fclose(%s)\", argv[3]);\n        return -1;\n    \n    /* Write the newApk file */\n    if (((fd = open(argv[2], O_CREAT | O_TRUNC | O_WRONLY, 0666)) < 0)\n        || (write(fd, newApk, newsize) != newsize) || (close(fd) == -1))\n        //err(1, \"%s\", argv[2]);\n        return -1;\n    \n    free(newApk);\n    free(oldApk);\n    \n    return 0;\n}\n\n", "comment_ratio": 0.10762331838565023}
{"lang": "c", "code": "#ifndef LLVM_LIB_TARGET_AMDGPU_AMDGPUTARGETOBJECTFILE_H\n#define LLVM_LIB_TARGET_AMDGPU_AMDGPUTARGETOBJECTFILE_H\n\n#include \"AMDGPU.h\"\n#include \"llvm/CodeGen/TargetLoweringObjectFileImpl.h\"\n#include \"llvm/Target/TargetMachine.h\"\n\nnamespace llvm {\n\nclass AMDGPUTargetObjectFile : public TargetLoweringObjectFileELF {\n  public:\n    MCSection *SelectSectionForGlobal(const GlobalObject *GO, SectionKind Kind,\n                                      const TargetMachine &TM) const override;\n    MCSection *getExplicitSectionGlobal(const GlobalObject *GO, SectionKind Kind,\n                                        const TargetMachine &TM) const override;\n};\n\n} // end namespace llvm\n\n#endif\n\n", "comment_ratio": 0.4}
{"lang": "c", "code": "#ifndef UmfpackGenLinSolver_h\n#define UmfpackGenLinSolver_h\n\n#include <LinearSOESolver.h>\n#include \"../../../../OTHER/UMFPACK/umfpack.h\"\n\nclass UmfpackGenLinSOE;\n\nclass UmfpackGenLinSolver : public LinearSOESolver\n{\n  public:\n    UmfpackGenLinSolver();     \n    ~UmfpackGenLinSolver();\n\n    int solve(void);\n    int setSize(void);\n\n    int setLinearSOE(UmfpackGenLinSOE &theSOE);\n    \n    int sendSelf(int commitTag, Channel &theChannel);\n    int recvSelf(int commitTag, Channel &theChannel, \n\t\t FEM_ObjectBroker &theBroker);    \n    \n  protected:\n\n  private:\n    void *Symbolic;\n    double Control[UMFPACK_CONTROL], Info[UMFPACK_INFO];\n    UmfpackGenLinSOE *theSOE;\n};\n\n#endif\n\n\n", "comment_ratio": 0.16176470588235295}
{"lang": "c", "code": "#ifndef C0P_PARAM_OBJECTS_SURFER__US_0O05__SURFTIMEPREFACTOR_1O25_GROUP_HOMOGENEOUS_MEMBER_AGENT_BEHAVIOUR_NAVIGATOR_BEHAVIOUR_VELOCITY_CHOICE_H\n#define C0P_PARAM_OBJECTS_SURFER__US_0O05__SURFTIMEPREFACTOR_1O25_GROUP_HOMOGENEOUS_MEMBER_AGENT_BEHAVIOUR_NAVIGATOR_BEHAVIOUR_VELOCITY_CHOICE_H\n#pragma once\n\n// THIS FILE SHOULD NOT BE EDITED DIRECTLY BY THE USERS.\n// THIS FILE WILL BE AUTOMATICALLY EDITED WHEN THE\n// CHOOSE COMMAND IS USED\n\n// choose your behaviour\n#include \"param/env/objects/static/surfer__us_0o05__surftimeprefactor_1o25/group/homogeneous/_member/agent/_behaviour/navigator/_behaviour_velocity/const/choice.h\"\nnamespace c0p {\n    template<typename SurferUs0O05Surftimeprefactor1O25GroupHomogeneousMemberAgentActiveStep>\n    using SurferUs0O05Surftimeprefactor1O25GroupHomogeneousMemberAgentBehaviourNavigatorBehaviourVelocity = SurferUs0O05Surftimeprefactor1O25GroupHomogeneousMemberAgentBehaviourNavigatorBehaviourVelocityConst<SurferUs0O05Surftimeprefactor1O25GroupHomogeneousMemberAgentActiveStep>;\n}\n\n#endif\n\n", "comment_ratio": 0.23529411764705882}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n\n//! Project version number for Bedrock.\nFOUNDATION_EXPORT double BedrockVersionNumber;\n\n//! Project version string for Bedrock.\nFOUNDATION_EXPORT const unsigned char BedrockVersionString[];\n\n// In this header, you should import all the public headers of your framework using statements like #import <Bedrock/PublicHeader.h>\n\n", "comment_ratio": 0.3}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n\n@interface AppDelegate : UIResponder <UIApplicationDelegate>\n\n@property (strong, nonatomic) UIWindow *window;\n\n\n@end\n\n\n", "comment_ratio": 0.3888888888888889}
{"lang": "c", "code": "#ifndef SX1272_h\n#define SX1272_h\n\n/******************************************************************************\n * Includes\n ******************************************************************************/\n\n#include <stdlib.h>\n#include <stdint.h>\n#include <Arduino.h>\n#include <SPI.h>\n\n#ifndef inttypes_h\n\t#include <inttypes.h>\n#endif\n\n/******************************************************************************\n * Definitions & Declarations\n *****************************************************************************/\n\n// added by C. Pham\n// do not remove!\n#define W_REQUESTED_ACK\n//#define W_NET_KEY\n//#define W_INITIALIZATION\n\n//it is not mandatory to wire this pin\n//we take pin 4 as it is available on many boards\n#define SX1272_WRST\n#define SX1272_RST  4\n\n#if defined ARDUINO_AVR_FEATHER32U4 || defined ARDUINO_SAMD_FEATHER_M0\n// on the Adafruit Feather, the RFM95W is embeded and CS pin is normally on pin 8\n#define SX1272_SS 8\n#elif defined ARDUINO_ESP8266_ESP01\n#define SX1272_SS 15\n#else\n// starting from November 3rd, 2017, the CS pin is always pin number 10 on Arduino boards\n// if you use the Libelium Multiprotocol shield to connect a Libelium LoRa then change the CS pin to pin 2\n#define SX1272_SS 10\n#endif\n\n#define SX1272Chip  0\n#define SX1276Chip  1\n// end\n\n#define SX1272_debug_mode 0\n// added by C. Pham\n//#define SX1272_led_send_receive\n\n#ifdef SX1272_led_send_receive\n#define SX1272_led_send 2\n#define SX1272_led_receive 3\n#endif\n\n//! MACROS //\n#define bitRead(value, bit) (((value) >> (bit)) & 0x01)  // read a bit\n#define bitSet(value, bit) ((value) |= (1UL << (bit)))    // set bit to '1'\n#define bitClear(value, bit) ((value) &= ~(1UL << (bit))) // set bit to '0'\n\n//! REGISTERS //\n\n#define        REG_FIFO        \t\t\t\t\t0x00\n#define        REG_OP_MODE        \t\t\t\t0x01\n#define        REG_BITRATE_MSB    \t\t\t\t0x02\n#define        REG_BITRATE_LSB    \t\t\t\t0x03\n#define        REG_FDEV_MSB   \t\t\t\t\t0x04\n#define        REG_FDEV_LSB    \t\t\t\t\t0x05\n#define        REG_FRF_MSB    \t\t\t\t\t0x06\n#define        REG_FRF_MID    \t\t\t\t\t0x07\n#define        REG_FRF_LSB    \t\t\t\t\t0x08\n#define        REG_PA_CONFIG    \t\t\t\t0x09\n#define        REG_PA_RAMP    \t\t\t\t\t0x0A\n#define        REG_OCP    \t\t\t\t\t\t0x0B\n#define        REG_LNA    \t\t\t\t\t\t0x0C\n#define        REG_RX_CONFIG    \t\t\t\t0x0D\n#define        REG_FIFO_ADDR_PTR  \t\t\t\t0x0D\n#define        REG_RSSI_CONFIG   \t\t\t\t0x0E\n#define        REG_FIFO_TX_BASE_ADDR \t\t    0x0E\n#define        REG_RSSI_COLLISION    \t\t\t0x0F\n#define        REG_FIFO_RX_BASE_ADDR   \t\t\t0x0F\n#define        REG_RSSI_THRESH    \t\t\t\t0x10\n#define        REG_FIFO_RX_CURRENT_ADDR   \t\t0x10\n#define        REG_RSSI_VALUE_FSK\t    \t\t0x11\n#define        REG_IRQ_FLAGS_MASK    \t\t\t0x11\n#define        REG_RX_BW\t\t    \t\t\t0x12\n#define        REG_IRQ_FLAGS\t    \t\t\t0x12\n#define        REG_AFC_BW\t\t    \t\t\t0x13\n#define        REG_RX_NB_BYTES\t    \t\t\t0x13\n#define        REG_OOK_PEAK\t    \t\t\t\t0x14\n#define        REG_RX_HEADER_CNT_VALUE_MSB  \t0x14\n#define        REG_OOK_FIX\t    \t\t\t\t0x15\n#define        REG_RX_HEADER_CNT_VALUE_LSB  \t0x15\n#define        REG_OOK_AVG\t \t\t\t\t\t0x16\n#define        REG_RX_PACKET_CNT_VALUE_MSB  \t0x16\n#define        REG_RX_PACKET_CNT_VALUE_LSB  \t0x17\n#define        REG_MODEM_STAT\t  \t\t\t\t0x18\n#define        REG_PKT_SNR_VALUE\t  \t\t\t0x19\n#define        REG_AFC_FEI\t  \t\t\t\t\t0x1A\n#define        REG_PKT_RSSI_VALUE\t  \t\t\t0x1A\n#define        REG_AFC_MSB\t  \t\t\t\t\t0x1B\n#define        REG_RSSI_VALUE_LORA\t  \t\t\t0x1B\n#define        REG_AFC_LSB\t  \t\t\t\t\t0x1C\n#define        REG_HOP_CHANNEL\t  \t\t\t\t0x1C\n#define        REG_FEI_MSB\t  \t\t\t\t\t0x1D\n#define        REG_MODEM_CONFIG1\t \t\t \t0x1D\n#define        REG_FEI_LSB\t  \t\t\t\t\t0x1E\n#define        REG_MODEM_CONFIG2\t  \t\t\t0x1E\n#define        REG_PREAMBLE_DETECT  \t\t\t0x1F\n#define        REG_SYMB_TIMEOUT_LSB  \t\t\t0x1F\n#define        REG_RX_TIMEOUT1\t  \t\t\t\t0x20\n#define        REG_PREAMBLE_MSB_LORA  \t\t\t0x20\n#define        REG_RX_TIMEOUT2\t  \t\t\t\t0x21\n#define        REG_PREAMBLE_LSB_LORA  \t\t\t0x21\n#define        REG_RX_TIMEOUT3\t \t\t\t\t0x22\n#define        REG_PAYLOAD_LENGTH_LORA\t\t \t0x22\n#define        REG_RX_DELAY\t \t\t\t\t\t0x23\n#define        REG_MAX_PAYLOAD_LENGTH \t\t\t0x23\n#define        REG_OSC\t\t \t\t\t\t\t0x24\n#define        REG_HOP_PERIOD\t  \t\t\t\t0x24\n#define        REG_PREAMBLE_MSB_FSK \t\t\t0x25\n#define        REG_FIFO_RX_BYTE_ADDR \t\t\t0x25\n#define        REG_PREAMBLE_LSB_FSK \t\t\t0x26\n// added by C. Pham\n#define        REG_MODEM_CONFIG3\t  \t\t\t0x26\n// end\n#define        REG_SYNC_CONFIG\t  \t\t\t\t0x27\n#define        REG_SYNC_VALUE1\t \t\t\t\t0x28\n#define        REG_SYNC_VALUE2\t  \t\t\t\t0x29\n#define        REG_SYNC_VALUE3\t  \t\t\t\t0x2A\n#define        REG_SYNC_VALUE4\t  \t\t\t\t0x2B\n#define        REG_SYNC_VALUE5\t  \t\t\t\t0x2C\n#define        REG_SYNC_VALUE6\t  \t\t\t\t0x2D\n#define        REG_SYNC_VALUE7\t  \t\t\t\t0x2E\n#define        REG_SYNC_VALUE8\t  \t\t\t\t0x2F\n#define        REG_PACKET_CONFIG1\t  \t\t\t0x30\n#define        REG_PACKET_CONFIG2\t  \t\t\t0x31\n#define        REG_DETECT_OPTIMIZE              0x31\n#define        REG_PAYLOAD_LENGTH_FSK\t\t\t0x32\n// added by C. Pham\n#define        REG_INVERT_IQ\t  \t\t\t\t0x33\n#define        REG_INVERT_IQ2\t  \t\t\t\t0x3B\n#define        REG_BROADCAST_ADRS\t \t\t \t0x34\n#define        REG_FIFO_THRESH\t  \t\t\t\t0x35\n#define        REG_SEQ_CONFIG1\t  \t\t\t\t0x36\n#define        REG_SEQ_CONFIG2\t  \t\t\t\t0x37\n#define        REG_DETECTION_THRESHOLD          0x37\n#define        REG_TIMER_RESOL\t  \t\t\t\t0x38\n// added by C. Pham\n#define        REG_SYNC_WORD                    0x39\n//end\n#define        REG_TIMER1_COEF\t  \t\t\t\t0x39\n#define        REG_TIMER2_COEF\t  \t\t\t\t0x3A\n#define        REG_IMAGE_CAL\t  \t\t\t\t0x3B\n#define        REG_TEMP\t\t  \t\t\t\t\t0x3C\n#define        REG_LOW_BAT\t  \t\t\t\t\t0x3D\n#define        REG_IRQ_FLAGS1\t  \t\t\t\t0x3E\n#define        REG_IRQ_FLAGS2\t  \t\t\t\t0x3F\n#define        REG_DIO_MAPPING1\t  \t\t\t\t0x40\n#define        REG_DIO_MAPPING2\t  \t\t\t\t0x41\n#define        REG_VERSION\t  \t\t\t\t\t0x42\n#define        REG_AGC_REF\t  \t\t\t\t\t0x43\n#define        REG_AGC_THRESH1\t  \t\t\t\t0x44\n#define        REG_AGC_THRESH2\t  \t\t\t\t0x45\n#define        REG_AGC_THRESH3\t  \t\t\t\t0x46\n#define        REG_PLL_HOP\t  \t\t\t\t\t0x4B\n#define        REG_TCXO\t\t  \t\t\t\t\t0x58\n#define        REG_PA_DAC\t\t  \t\t\t\t0x5A\n#define        REG_PLL\t\t  \t\t\t\t\t0x5C\n#define        REG_PLL_LOW_PN\t  \t\t\t\t0x5E\n#define        REG_FORMER_TEMP\t  \t\t\t\t0x6C\n#define        REG_BIT_RATE_FRAC\t  \t\t\t0x70\n\n// added by C. Pham\n// copied from LoRaMAC-Node\n/*!\n * RegImageCal\n */\n#define RF_IMAGECAL_AUTOIMAGECAL_MASK               0x7F\n#define RF_IMAGECAL_AUTOIMAGECAL_ON                 0x80\n#define RF_IMAGECAL_AUTOIMAGECAL_OFF                0x00  // Default\n\n#define RF_IMAGECAL_IMAGECAL_MASK                   0xBF\n#define RF_IMAGECAL_IMAGECAL_START                  0x40\n\n#define RF_IMAGECAL_IMAGECAL_RUNNING                0x20\n#define RF_IMAGECAL_IMAGECAL_DONE                   0x00  // Default\n\n#define RF_IMAGECAL_TEMPCHANGE_HIGHER               0x08\n#define RF_IMAGECAL_TEMPCHANGE_LOWER                0x00\n\n#define RF_IMAGECAL_TEMPTHRESHOLD_MASK              0xF9\n#define RF_IMAGECAL_TEMPTHRESHOLD_05                0x00\n#define RF_IMAGECAL_TEMPTHRESHOLD_10                0x02  // Default\n#define RF_IMAGECAL_TEMPTHRESHOLD_15                0x04\n#define RF_IMAGECAL_TEMPTHRESHOLD_20                0x06\n\n#define RF_IMAGECAL_TEMPMONITOR_MASK                0xFE\n#define RF_IMAGECAL_TEMPMONITOR_ON                  0x00 // Default\n#define RF_IMAGECAL_TEMPMONITOR_OFF                 0x01\n\n// added by C. Pham\n// The crystal oscillator frequency of the module\n#define RH_LORA_FXOSC 32000000.0\n \n// The Frequency Synthesizer step = RH_LORA_FXOSC / 2^^19\n#define RH_LORA_FCONVERT  (524288 / RH_LORA_FXOSC)\n\n// Frf = frf(Hz)*2^19/RH_LORA_FXOSC\n\n/////\n\n//FREQUENCY CHANNELS:\n// added by C. Pham for Senegal\nconst uint32_t CH_04_868 = 0xD7CCCC; // channel 04, central freq = 863.20MHz\nconst uint32_t CH_05_868 = 0xD7E000; // channel 05, central freq = 863.50MHz\nconst uint32_t CH_06_868 = 0xD7F333; // channel 06, central freq = 863.80MHz\nconst uint32_t CH_07_868 = 0xD80666; // channel 07, central freq = 864.10MHz\nconst uint32_t CH_08_868 = 0xD81999; // channel 08, central freq = 864.40MHz\nconst uint32_t CH_09_868 = 0xD82CCC; // channel 09, central freq = 864.70MHz\n//\nconst uint32_t CH_10_868 = 0xD84CCC; // channel 10, central freq = 865.20MHz, = 865200000*RH_LORA_FCONVERT\nconst uint32_t CH_11_868 = 0xD86000; // channel 11, central freq = 865.50MHz\nconst uint32_t CH_12_868 = 0xD87333; // channel 12, central freq = 865.80MHz\nconst uint32_t CH_13_868 = 0xD88666; // channel 13, central freq = 866.10MHz\nconst uint32_t CH_14_868 = 0xD89999; // channel 14, central freq = 866.40MHz\nconst uint32_t CH_15_868 = 0xD8ACCC; // channel 15, central freq = 866.70MHz\nconst uint32_t CH_16_868 = 0xD8C000; // channel 16, central freq = 867.00MHz\nconst uint32_t CH_17_868 = 0xD90000; // channel 17, central freq = 868.00MHz\n\n// added by C. Pham\nconst uint32_t CH_18_868 = 0xD90666; // 868.1MHz for LoRaWAN test\n// end\nconst uint32_t CH_00_900 = 0xE1C51E; // channel 00, central freq = 903.08MHz\nconst uint32_t CH_01_900 = 0xE24F5C; // channel 01, central freq = 905.24MHz\nconst uint32_t CH_02_900 = 0xE2D999; // channel 02, central freq = 907.40MHz\nconst uint32_t CH_03_900 = 0xE363D7; // channel 03, central freq = 909.56MHz\nconst uint32_t CH_04_900 = 0xE3EE14; // channel 04, central freq = 911.72MHz\nconst uint32_t CH_05_900 = 0xE47851; // channel 05, central freq = 913.88MHz\nconst uint32_t CH_06_900 = 0xE5028F; // channel 06, central freq = 916.04MHz\nconst uint32_t CH_07_900 = 0xE58CCC; // channel 07, central freq = 918.20MHz\nconst uint32_t CH_08_900 = 0xE6170A; // channel 08, central freq = 920.36MHz\nconst uint32_t CH_09_900 = 0xE6A147; // channel 09, central freq = 922.52MHz\nconst uint32_t CH_10_900 = 0xE72B85; // channel 10, central freq = 924.68MHz\nconst uint32_t CH_11_900 = 0xE7B5C2; // channel 11, central freq = 926.84MHz\nconst uint32_t CH_12_900 = 0xE4C000; // default channel 915MHz, the module is configured with it\n\n// added by C. Pham\nconst uint32_t CH_00_433 = 0x6C5333; // 433.3MHz\nconst uint32_t CH_01_433 = 0x6C6666; // 433.6MHz\nconst uint32_t CH_02_433 = 0x6C7999; // 433.9MHz\nconst uint32_t CH_03_433 = 0x6C9333; // 434.3MHz\n// end\n\n//LORA BANDWIDTH:\n// modified by C. Pham\nconst uint8_t SX1272_BW_125 = 0x00;\nconst uint8_t SX1272_BW_250 = 0x01;\nconst uint8_t SX1272_BW_500 = 0x02;\n\n// use the following constants with setBW()\nconst uint8_t BW_7_8 = 0x00;\nconst uint8_t BW_10_4 = 0x01;\nconst uint8_t BW_15_6 = 0x02;\nconst uint8_t BW_20_8 = 0x03;\nconst uint8_t BW_31_25 = 0x04;\nconst uint8_t BW_41_7 = 0x05;\nconst uint8_t BW_62_5 = 0x06;\nconst uint8_t BW_125 = 0x07;\nconst uint8_t BW_250 = 0x08;\nconst uint8_t BW_500 = 0x09;\n// end\n\nconst double SignalBwLog[] =\n{\n    5.0969100130080564143587833158265,\n    5.397940008672037609572522210551,\n    5.6989700043360188047862611052755\n};\n\n//LORA CODING RATE:\nconst uint8_t CR_5 = 0x01;\nconst uint8_t CR_6 = 0x02;\nconst uint8_t CR_7 = 0x03;\nconst uint8_t CR_8 = 0x04;\n\n//LORA SPREADING FACTOR:\nconst uint8_t SF_6 = 0x06;\nconst uint8_t SF_7 = 0x07;\nconst uint8_t SF_8 = 0x08;\nconst uint8_t SF_9 = 0x09;\nconst uint8_t SF_10 = 0x0A;\nconst uint8_t SF_11 = 0x0B;\nconst uint8_t SF_12 = 0x0C;\n\n//LORA MODES:\nconst uint8_t LORA_SLEEP_MODE = 0x80;\nconst uint8_t LORA_STANDBY_MODE = 0x81;\nconst uint8_t LORA_TX_MODE = 0x83;\nconst uint8_t LORA_RX_MODE = 0x85;\n\n// added by C. Pham\nconst uint8_t LORA_CAD_MODE = 0x87;\n#define LNA_MAX_GAIN                0x23\n#define LNA_OFF_GAIN                0x00\n#define LNA_LOW_GAIN\t\t    0x20\n// end\n\nconst uint8_t LORA_STANDBY_FSK_REGS_MODE = 0xC1;\n\n//FSK MODES:\nconst uint8_t FSK_SLEEP_MODE = 0x00;\nconst uint8_t FSK_STANDBY_MODE = 0x01;\nconst uint8_t FSK_TX_MODE = 0x03;\nconst uint8_t FSK_RX_MODE = 0x05;\n\n//OTHER CONSTANTS:\n\nconst uint8_t HEADER_ON = 0;\nconst uint8_t HEADER_OFF = 1;\nconst uint8_t CRC_ON = 1;\nconst uint8_t CRC_OFF = 0;\nconst uint8_t LORA = 1;\nconst uint8_t FSK = 0;\nconst uint8_t BROADCAST_0 = 0x00;\nconst uint8_t MAX_LENGTH = 255;\nconst uint8_t MAX_PAYLOAD = 251;\nconst uint8_t MAX_LENGTH_FSK = 64;\nconst uint8_t MAX_PAYLOAD_FSK = 60;\n//modified by C. Pham, 7 instead of 5 because we added a type field which should be PKT_TYPE_ACK and the SNR\nconst uint8_t ACK_LENGTH = 7;\n// added by C. Pham\n#ifdef W_NET_KEY\nconst uint8_t NET_KEY_LENGTH=2;\nconst uint8_t OFFSET_PAYLOADLENGTH = 4+NET_KEY_LENGTH;\nconst uint8_t net_key_0 = 0x12;\nconst uint8_t net_key_1 = 0x34;\n#else\n// modified by C. Pham to remove the retry field and the length field\n// which will be replaced by packet type field\nconst uint8_t OFFSET_PAYLOADLENGTH = 4;\n#endif\nconst uint8_t OFFSET_RSSI = 139;\nconst uint8_t NOISE_FIGURE = 6.0;\nconst uint8_t NOISE_ABSOLUTE_ZERO = 174.0;\nconst uint16_t MAX_TIMEOUT = 10000;\t\t//10000 msec = 10.0 sec\nconst uint16_t MAX_WAIT = 12000;\t\t//12000 msec = 12.0 sec\nconst uint8_t MAX_RETRIES = 5;\nconst uint8_t CORRECT_PACKET = 0;\nconst uint8_t INCORRECT_PACKET = 1;\nconst uint8_t INCORRECT_PACKET_TYPE = 2;\n\n// added by C. Pham\n// Packet type definition\n\n#define PKT_TYPE_MASK   0xF0\n#define PKT_FLAG_MASK   0x0F\n\n#define PKT_TYPE_DATA   0x10\n#define PKT_TYPE_ACK    0x20\n\n#define PKT_FLAG_ACK_REQ            0x08\n#define PKT_FLAG_DATA_ENCRYPTED     0x04\n#define PKT_FLAG_DATA_WAPPKEY       0x02\n#define PKT_FLAG_DATA_DOWNLINK      0x01\n\n#define SX1272_ERROR_ACK        3\n#define SX1272_ERROR_TOA        4\n\n#define INVERT_IQ_RX\t\t\t0x00\n#define INVERT_IQ_TX\t\t\t0x01\n\n//! Structure :\n/*!\n */\nstruct pack\n{\n\t// added by C. Pham\n#ifdef W_NET_KEY\t\n\tuint8_t netkey[NET_KEY_LENGTH];\n#endif\t\n\t//! Structure Variable : Packet destination\n\t/*!\n \t*/\n\tuint8_t dst;\n\n    // added by C. Pham\n    //! Structure Variable : Packet type\n    /*!\n    */\n    uint8_t type;\n\n\t//! Structure Variable : Packet source\n\t/*!\n \t*/\n\tuint8_t src;\n\n\t//! Structure Variable : Packet number\n\t/*!\n \t*/\n\tuint8_t packnum;\n\n    // modified by C. Pham\n    // will not be used in the transmitted packet\n\t//! Structure Variable : Packet length\n\t/*!\n \t*/\n\tuint8_t length;\n\n    // modified by C. Pham\n    // use a pointer instead of static variable to same memory footprint\n\t//! Structure Variable : Packet payload\n\t/*!\n \t*/\n    uint8_t* data;\n\n    // modified by C. Pham\n    // will not be used in the transmitted packet\n\t//! Structure Variable : Retry number\n\t/*!\n \t*/\n\tuint8_t retry;\n};\n\n/******************************************************************************\n * Class\n ******************************************************************************/\n\n//! SX1272 Class\n/*!\n\tSX1272 Class defines all the variables and functions used to manage\n\tSX1272 modules.\n */\nclass SX1272\n{\n\npublic:\n\n\t//! class constructor\n  \t/*!\n\tIt does nothing\n\t\\param void\n\t\\return void\n  \t */\n   \tSX1272();\n\n\t//! It puts the module ON\n  \t/*!\n\t\\param void\n\t\\return uint8_t setLORA state\n\t */\n\tuint8_t ON();\n\n\t//! It puts the module OFF\n  \t/*!\n\t\\param void\n\t\\return void\n\t */\n\tvoid OFF();\n\n\t//! It reads an internal module register.\n  \t/*!\n  \t\\param byte address : address register to read from.\n\t\\return the content of the register.\n\t */\n\tbyte readRegister(byte address);\n\n\t//! It writes in an internal module register.\n  \t/*!\n  \t\\param byte address : address register to write in.\n  \t\\param byte data : value to write in the register.\n\t */\n\tvoid writeRegister(byte address, byte data);\n\n\t//! It clears the interruption flags.\n  \t/*!\n\t\\param void\n\t\\return void\n\t */\n\tvoid clearFlags();\n\n\t//! It sets the LoRa mode on.\n  \t/*!\n  \tIt stores in global '_LORA' variable '1' when success\n    \\return '0' on success, '1' otherwise\n\t */\n\tuint8_t setLORA();\n\n\t//! It sets the FSK mode on.\n  \t/*!\n  \tIt stores in global '_FSK' variable '1' when success\n\t\\return '0' on success, '1' otherwise\n\t */\n\tuint8_t setFSK();\n\n\t//! It gets the BW, SF and CR of the module.\n  \t/*!\n\tIt stores in global '_bandwidth' variable the BW\n\tIt stores in global '_codingRate' variable the CR\n\tIt stores in global '_spreadingFactor' variable the SF\n\t\\return '0' on success, '1' otherwise\n\t */\n\tuint8_t getMode();\n\n\t//! It sets the BW, SF and CR of the module.\n  \t/*!\n\tIt stores in global '_bandwidth' variable the BW\n\tIt stores in global '_codingRate' variable the CR\n\tIt stores in global '_spreadingFactor' variable the SF\n\t\\param uint8_t mode : there is a mode number to different values of\n\tthe\tconfigured parameters with this function.\n\t\\return '0' on success, '1' otherwise\n\t */\n\tint8_t setMode(uint8_t mode);\n\n\t//! It gets the header mode configured.\n  \t/*!\n  \tIt stores in global '_header' variable '0' when header is sent\n  \t(explicit header mode) or '1' when is not sent (implicit header\n  \tmode).\n\t\\return '0' on success, '1' otherwise\n\t */\n\tuint8_t\tgetHeader();\n\n\t//! It sets explicit header mode.\n  \t/*!\n  \tIt stores in global '_header' variable '1' when success\n\t\\return '0' on success, '1' otherwise\n\t */\n\tint8_t\tsetHeaderON();\n\n\t//! It sets implicit header mode.\n  \t/*!\n  \tIt stores in global '_header' variable '0' when success\n\t\\return '0' on success, '1' otherwise\n\t */\n\tint8_t\tsetHeaderOFF();\n\n\t//! It gets the CRC configured.\n  \t/*!\n  \tIt stores in global '_CRC' variable '1' enabling CRC generation on\n  \tpayload, or '0' disabling the CRC.\n\t\\return '0' on success, '1' otherwise\n\t */\n\tuint8_t\tgetCRC();\n\n\t//! It sets CRC on.\n  \t/*!\n  \tIt stores in global '_CRC' variable '1' when success\n\t\\return '0' on success, '1' otherwise\n\t */\n\tuint8_t\tsetCRC_ON();\n\n\t//! It sets CRC off.\n  \t/*!\n  \tIt stores in global '_CRC' variable '0' when success\n\t\\return '0' on success, '1' otherwise\n\t */\n\tuint8_t\tsetCRC_OFF();\n\n\t//! It is true if the SF selected exists.\n  \t/*!\n\t\\param uint8_t spr : spreading factor value to check.\n\t\\return 'true' on success, 'false' otherwise\n\t */\n\tboolean\tisSF(uint8_t spr);\n\n\t//! It gets the SF configured.\n  \t/*!\n\tIt stores in global '_spreadingFactor' variable the current value of SF\n\t\\return '0' on success, '1' otherwise\n\t */\n\tint8_t\tgetSF();\n\n\t//! It sets the SF.\n  \t/*!\n\tIt stores in global '_spreadingFactor' variable the current value of SF\n\t\\param uint8_t spr : spreading factor value to set in the configuration.\n\t\\return '0' on success, '1' otherwise\n\t */\n\tuint8_t\tsetSF(uint8_t spr);\n\n\t//! It is true if the BW selected exists.\n  \t/*!\n\t\\param uint16_t band : bandwidth value to check.\n\t\\return 'true' on success, 'false' otherwise\n\t */\n\tboolean\tisBW(uint16_t band);\n\n\t//! It gets the BW configured.\n  \t/*!\n\tIt stores in global '_bandwidth' variable the BW selected\n\tin the configuration\n\t\\return '0' on success, '1' otherwise\n\t */\n\tint8_t\tgetBW();\n\n\t//! It sets the BW.\n  \t/*!\n\tIt stores in global '_bandwidth' variable the BW selected\n\tin the configuration\n\t\\param uint16_t band : bandwidth value to set in the configuration.\n\t\\return '0' on success, '1' otherwise\n\t */\n\tint8_t setBW(uint16_t band);\n\n\t//! It is true if the CR selected exists.\n  \t/*!\n\t\\param uint8_t cod : the coding rate value to check.\n\t\\return 'true' on success, 'false' otherwise\n\t */\n\tboolean\tisCR(uint8_t cod);\n\n\t//! It gets the CR configured.\n  \t/*!\n\tIt stores in global '_codingRate' variable the CR selected\n\tin the configuration\n\t\\return '0' on success, '1' otherwise\n\t */\n\tint8_t\tgetCR();\n\n\t//! It sets the CR.\n  \t/*!\n\tIt stores in global '_codingRate' variable the CR selected\n\tin the configuration\n\t\\param uint8_t cod : coding rate value to set in the configuration.\n\t\\return '0' on success, '1' otherwise\n\t */\n\tint8_t\tsetCR(uint8_t cod);\n\n\n\t//! It is true if the channel selected exists.\n  \t/*!\n\t\\param uint32_t ch : frequency channel value to check.\n\t\\return 'true' on success, 'false' otherwise\n\t */\n\tboolean isChannel(uint32_t ch);\n\n\t//! It gets frequency channel the module is using.\n  \t/*!\n\tIt stores in global '_channel' variable the frequency channel\n\t\\return '0' on success, '1' otherwise\n\t */\n\tuint8_t getChannel();\n\n\t//! It sets frequency channel the module is using.\n  \t/*!\n\tIt stores in global '_channel' variable the frequency channel\n\t\\param uint32_t ch : frequency channel value to set in the configuration.\n\t\\return '0' on success, '1' otherwise\n\t */\n\tint8_t setChannel(uint32_t ch);\n\n\t//! It gets the output power of the signal.\n  \t/*!\n\tIt stores in global '_power' variable the output power of the signal\n\t\\return '0' on success, '1' otherwise\n\t */\n\tuint8_t getPower();\n\n\t//! It sets the output power of the signal.\n  \t/*!\n\tIt stores in global '_power' variable the output power of the signal\n\t\\param char p : 'M', 'H' or 'L' if you want Maximum, High or Low\n\toutput power signal.\n\t\\return '0' on success, '1' otherwise\n\t */\n\tint8_t setPower(char p);\n\n\t//! It sets the output power of the signal.\n  \t/*!\n\tIt stores in global '_power' variable the output power of the signal\n\t\\param uint8_t pow : value to set as output power.\n\t\\return '0' on success, '1' otherwise\n\t */\n\tint8_t setPowerNum(uint8_t pow);\n\n\t//! It gets the preamble length configured.\n  \t/*!\n\tIt stores in global '_preamblelength' variable the preamble length\n\t\\return '0' on success, '1' otherwise\n\t */\n\tuint8_t getPreambleLength();\n\n\t//! It sets the preamble length.\n  \t/*!\n    It stores in global '_preamblelength' variable the preamble length\n  \t\\param uint16_t l : preamble length to set in the configuration.\n\t\\return '0' on success, '1' otherwise\n\t */\n\tuint8_t setPreambleLength(uint16_t l);\n\n\t//! It gets the payload length of the last packet to send/receive.\n  \t/*!\n    It stores in global '_payloadlength' variable the payload length of\n    the last packet to send/receive.\n\t\\return '0' on success, '1' otherwise\n\t */\n\tuint8_t getPayloadLength();\n\n\t//! It sets the packet length to send/receive.\n  \t/*!\n  \tIt stores in global '_payloadlength' variable the payload length of\n    the last packet to send/receive.\n\t\\return '0' on success, '1' otherwise\n\t */\n\tint8_t setPacketLength();\n\n\t//! It sets the packet length to send/receive.\n  \t/*!\n  \tIt stores in global '_payloadlength' variable the payload length of\n    the last packet to send/receive.\n  \t\\param uint8_t l : payload length to set in the configuration.\n\t\\return '0' on success, '1' otherwise\n\t */\n\tint8_t setPacketLength(uint8_t l);\n\n\t//! It gets the node address of the mote.\n  \t/*!\n  \treturns '_nodeAddress' variable the node address\n\t */\n\tuint8_t getNodeAddress();\n\n\t//! It sets the node address of the mote.\n  \t/*!\n  \tIt stores in global '_nodeAddress' variable the node address\n  \t\\param uint8_t addr : address value to set as node address.\n\t\\return '0' on success, '-1' otherwise\n\t */\n\tint8_t setNodeAddress(uint8_t addr);\n\n\t//! It gets the SNR of the latest received packet.\n  \t/*!\n\tIt stores in global '_SNR' variable the SNR\n\t\\return '0' on success, '1' otherwise\n\t */\n\tint8_t getSNR();\n\n\t//! It gets the current value of RSSI.\n  \t/*!\n\tIt stores in global '_RSSI' variable the current value of RSSI\n\t\\return '0' on success, '1' otherwise\n\t */\n\tuint8_t getRSSI();\n\n\t//! It gets the RSSI of the latest received packet.\n  \t/*!\n\tIt stores in global '_RSSIpacket' variable the RSSI of the latest\n\tpacket received.\n\t\\return '0' on success, '1' otherwise\n\t */\n\tint16_t getRSSIpacket();\n\n\t//! It sets the total of retries when a packet is not correctly received.\n\t/*!\n\tIt stores in global '_maxRetries' variable the number of retries.\n  \t\\param uint8_t ret : number of retries.\n\t\\return '0' on success, '1' otherwise\n\t */\n\t//uint8_t setRetries(uint8_t ret);\n\n\t//! It gets the maximum current supply by the module.\n\t/*!\n  \t *\n\t\\return '0' on success, '1' otherwise\n\t */\n\tuint8_t getMaxCurrent();\n\n\t//! It sets the maximum current supply by the module.\n\t/*!\n\tIt stores in global '_maxCurrent' variable the maximum current supply.\n  \t\\param uint8_t rate : maximum current supply.\n\t\\return '0' on success, '1' otherwise\n\t */\n\tint8_t setMaxCurrent(uint8_t rate);\n\n\t//! It gets the content of the main configuration registers.\n  \t/*!\n\tIt stores in global '_bandwidth' variable the BW.\n\tIt stores in global '_codingRate' variable the CR.\n\tIt stores in global '_spreadingFactor' variable the SF.\n\tIt stores in global '_power' variable the output power of the signal.\n  \tIt stores in global '_channel' variable the frequency channel.\n  \tIt stores in global '_CRC' variable '1' enabling CRC generation on\n  \tpayload, or '0' disabling the CRC.\n  \tIt stores in global '_header' variable '0' when header is sent\n  \t(explicit header mode) or '1' when is not sent (implicit header\n  \tmode).\n\tIt stores in global '_preamblelength' variable the preamble length.\n    It stores in global '_payloadlength' variable the payload length of\n    the last packet to send/receive.\n  \tIt stores in global '_nodeAddress' variable the node address.\n\tIt stores in global '_temp' variable the module temperature.\n\t\\return '0' on success, '1' otherwise\n\t */\n\tuint8_t getRegs();\n\n\t//! It sets the maximum number of bytes from a frame that fit in a packet structure.\n\t/*!\n\tIt stores in global '_payloadlength' variable the maximum number of bytes.\n  \t\\param uint16_t length16 : total frame length.\n\t\\return '0' on success, '1' otherwise\n\t */\n\tuint8_t truncPayload(uint16_t length16);\n\n\t//! It writes an ACK in FIFO to send it.\n\t/*!\n\t *\n\t\\return '0' on success, '1' otherwise\n\t*/\n\tuint8_t setACK();\n\n\t//! It puts the module in reception mode.\n  \t/*!\n  \t *\n\t\\return '0' on success, '1' otherwise\n\t */\n\tuint8_t receive();\n\n\t//! It receives a packet before MAX_TIMEOUT.\n  \t/*!\n  \t *\n\t\\return '0' on success, '1' otherwise\n\t */\n\tuint8_t receivePacketMAXTimeout();\n\n\t//! It receives a packet before a timeout.\n  \t/*!\n  \t *\n\t\\return '0' on success, '1' otherwise\n\t */\n\tuint8_t receivePacketTimeout();\n\n\t//! It receives a packet before a timeout.\n  \t/*!\n  \t\\param uint16_t wait : time to wait to receive something.\n\t\\return '0' on success, '1' otherwise\n\t */\n\tuint8_t receivePacketTimeout(uint16_t wait);\n\n\t//! It receives a packet before MAX_TIMEOUT and reply with an ACK.\n  \t/*!\n  \t *\n\t\\return '0' on success, '1' otherwise\n\t */\n\tuint8_t receivePacketMAXTimeoutACK();\n\n\t//! It receives a packet before a timeout and reply with an ACK.\n  \t/*!\n  \t *\n\t\\return '0' on success, '1' otherwise\n\t */\n\tuint8_t receivePacketTimeoutACK();\n\n\t//! It receives a packet before a timeout and reply with an ACK.\n  \t/*!\n  \t\\param uint16_t wait : time to wait to receive something.\n\t\\return '0' on success, '1' otherwise\n\t */\n\tuint8_t receivePacketTimeoutACK(uint16_t wait);\n\n\t//! It puts the module in 'promiscuous' reception mode.\n  \t/*!\n  \t *\n\t\\return '0' on success, '1' otherwise\n\t */\n\tuint8_t receiveAll();\n\n\t//! It puts the module in 'promiscuous' reception mode with a timeout.\n  \t/*!\n  \t\\param uint16_t wait : time to wait to receive something.\n\t\\return '0' on success, '1' otherwise\n\t */\n\tuint8_t receiveAll(uint16_t wait);\n\n\t//! It checks if there is an available packet and its destination.\n  \t/*!\n  \t *\n\t\\return 'true' on success, 'false' otherwise\n\t */\n\tboolean\tavailableData();\n\n\t//! It checks if there is an available packet and its destination before a timeout.\n  \t/*!\n  \t *\n  \t\\param uint16_t wait : time to wait while there is no a valid header received.\n\t\\return 'true' on success, 'false' otherwise\n\t */\n\tboolean\tavailableData(uint16_t wait);\n\n\t//! It writes a packet in FIFO in order to send it.\n\t/*!\n\t\\param uint8_t dest : packet destination.\n\t\\param char *payload : packet payload.\n\t\\return '0' on success, '1' otherwise\n\t*/\n\t//uint8_t setPacket(uint8_t dest, char *payload);\n\n\t//! It writes a packet in FIFO in order to send it.\n\t/*!\n\t\\param uint8_t dest : packet destination.\n\t\\param uint8_t *payload: packet payload.\n\t\\return '0' on success, '1' otherwise\n\t*/\n\tuint8_t setPacket(uint8_t dest, uint8_t *payload);\n\n\t//! It reads a received packet from the FIFO, if it arrives before ending MAX_TIMEOUT time.\n\t/*!\n\t *\n\t\\return '0' on success, '1' otherwise\n\t*/\n\tuint8_t getPacketMAXTimeout();\n\n\t//! It reads a received packet from the FIFO, if it arrives before ending '_sendTime' time.\n\t/*!\n\t *\n\t\\return '0' on success, '1' otherwise\n\t*/\n\tint8_t getPacket();\n\n\t//! It receives and gets a packet from FIFO, if it arrives before ending 'wait' time.\n\t/*!\n\t *\n\t\\param uint16_t wait : time to wait while there is no a complete packet received.\n\t\\return '0' on success, '1' otherwise\n\t*/\n\tint8_t getPacket(uint16_t wait);\n\n\t//! It sends the packet stored in FIFO before ending MAX_TIMEOUT.\n\t/*!\n\t *\n\t\\return '0' on success, '1' otherwise\n\t*/\n\tuint8_t sendWithMAXTimeout();\n\n\t//! It sends the packet stored in FIFO before ending _sendTime time.\n\t/*!\n\t *\n\t\\return '0' on success, '1' otherwise\n\t*/\n\tuint8_t sendWithTimeout();\n\n\t//! It tries to send the packet stored in FIFO before ending 'wait' time.\n\t/*!\n\t\\param uint16_t wait : time to wait to send the packet.\n\t\\return '0' on success, '1' otherwise\n\t*/\n\tuint8_t sendWithTimeout(uint16_t wait);\n\n\t//! It tries to send the packet wich payload is a parameter before ending MAX_TIMEOUT.\n\t/*!\n\t\\param uint8_t dest : packet destination.\n\t\\param char *payload : packet payload.\n\t\\return '0' on success, '1' otherwise\n\t*/\n\t//uint8_t sendPacketMAXTimeout(uint8_t dest, char *payload);\n\n\t//! It tries to send the packet wich payload is a parameter before ending MAX_TIMEOUT.\n\t/*!\n\t\\param uint8_t dest : packet destination.\n\t\\param uint8_t *payload : packet payload.\n\t\\param uint16_t length : payload buffer length.\n\t\\return '0' on success, '1' otherwise\n\t*/\n\tuint8_t sendPacketMAXTimeout(uint8_t dest, uint8_t *payload, uint16_t length);\n\n\n\t//! It sends the packet wich payload is a parameter before ending MAX_TIMEOUT.\n\t/*!\n\t\\param uint8_t dest : packet destination.\n\t\\param char *payload : packet payload.\n\t\\return '0' on success, '1' otherwise\n\t*/\n\t//uint8_t sendPacketTimeout(uint8_t dest, char *payload);\n\n\t//! It sends the packet wich payload is a parameter before ending MAX_TIMEOUT.\n\t/*!\n\t\\param uint8_t dest : packet destination.\n\t\\param uint8_t *payload: packet payload.\n\t\\param uint16_t length : payload buffer length.\n\t\\return '0' on success, '1' otherwise\n\t*/\n\tuint8_t sendPacketTimeout(uint8_t dest, uint8_t *payload, uint16_t length);\n\n\t//! It sends the packet wich payload is a parameter before ending 'wait' time.\n\t/*!\n\t\\param uint8_t dest : packet destination.\n\t\\param char *payload : packet payload.\n\t\\param uint16_t wait : time to wait.\n\t\\return '0' on success, '1' otherwise\n\t*/\n\t//uint8_t sendPacketTimeout(uint8_t dest, char *payload, uint16_t wait);\n\n\t//! It sends the packet wich payload is a parameter before ending 'wait' time.\n\t/*!\n\t\\param uint8_t dest : packet destination.\n\t\\param uint8_t *payload : packet payload.\n\t\\param uint16_t length : payload buffer length.\n\t\\param uint16_t wait : time to wait.\n\t\\return '0' on success, '1' otherwise\n\t*/\n\tuint8_t sendPacketTimeout(uint8_t dest, uint8_t *payload, uint16_t length, uint16_t wait);\n\n\t//! It sends the packet wich payload is a parameter before MAX_TIMEOUT, and replies with ACK.\n\t/*!\n\t\\param uint8_t dest : packet destination.\n\t\\param char *payload : packet payload.\n\t\\return '0' on success, '1' otherwise\n\t*/\n\t//uint8_t sendPacketMAXTimeoutACK(uint8_t dest, char *payload);\n\n\t//! It sends the packet wich payload is a parameter before MAX_TIMEOUT, and replies with ACK.\n\t/*!\n\t\\param uint8_t dest : packet destination.\n\t\\param uint8_t payload: packet payload.\n\t\\param uint16_t length : payload buffer length.\n\t\\return '0' on success, '1' otherwise\n\t*/\n\tuint8_t sendPacketMAXTimeoutACK(uint8_t dest, uint8_t *payload, uint16_t length);\n\n\t//! It sends the packet wich payload is a parameter before a timeout, and replies with ACK.\n\t/*!\n\t\\param uint8_t dest : packet destination.\n\t\\param char *payload : packet payload.\n\t\\return '0' on success, '1' otherwise\n\t*/\n\t//uint8_t sendPacketTimeoutACK(uint8_t dest, char *payload);\n\n\t//! It sends the packet wich payload is a parameter before a timeout, and replies with ACK.\n\t/*!\n\t\\param uint8_t dest : packet destination.\n\t\\param uint8_t payload: packet payload.\n\t\\param uint16_t length : payload buffer length.\n\t\\return '0' on success, '1' otherwise\n\t*/\n\tuint8_t sendPacketTimeoutACK(uint8_t dest, uint8_t *payload, uint16_t length);\n\n\t//! It sends the packet wich payload is a parameter before 'wait' time, and replies with ACK.\n\t/*!\n\t\\param uint8_t dest : packet destination.\n\t\\param char *payload : packet payload.\n\t\\param uint16_t wait : time to wait to send the packet.\n\t\\return '0' on success, '1' otherwise\n\t*/\n\t//uint8_t sendPacketTimeoutACK(uint8_t dest, char *payload, uint16_t wait);\n\n\t//! It sends the packet wich payload is a parameter before 'wait' time, and replies with ACK.\n\t/*!\n\t\\param uint8_t dest : packet destination.\n\t\\param uint8_t payload: packet payload.\n\t\\param uint16_t length : payload buffer length.\n\t\\param uint16_t wait : time to wait to send the packet.\n\t\\return '0' on success, '1' otherwise\n\t*/\n\tuint8_t sendPacketTimeoutACK(uint8_t dest, uint8_t *payload, uint16_t length, uint16_t wait);\n\n\t//! It sets the destination of a packet.\n  \t/*!\n  \t\\param uint8_t dest : value to set as destination address.\n\t\\return '0' on success, '1' otherwise\n\t */\n\tint8_t setDestination(uint8_t dest);\n\n\t//! It sets the waiting time to send a packet.\n  \t/*!\n   \tIt stores in global '_sendTime' variable the time for each mode.\n\t\\return '0' on success, '1' otherwise\n\t */\n\tuint8_t setTimeout();\n\n\t//! It sets the payload of the packet that is going to be sent.\n  \t/*!\n  \t\\param char *payload : packet payload.\n\t\\return '0' on success, '1' otherwise\n\t */\n\t//uint8_t setPayload(char *payload);\n\n\t//! It sets the payload of the packet that is going to be sent.\n  \t/*!\n  \t\\param uint8_t payload: packet payload.\n\t\\return '0' on success, '1' otherwise\n\t */\n\tuint8_t setPayload(uint8_t *payload);\n\n\t//! If an ACK is received, it gets it and checks its content.\n\t/*!\n\t *\n\t\\return '0' on success, '1' otherwise\n\t*/\n\tuint8_t getACK();\n\n \t//! It receives and gets an ACK from FIFO, if it arrives before ending 'wait' time.\n\t/*!\n\t *\n\t\\param uint16_t wait : time to wait while there is no an ACK received.\n\t\\return '0' on success, '1' otherwise\n\t*/\n\tuint8_t getACK(uint16_t wait);\n\n\t//! It sends a packet, waits to receive an ACK and updates the _retries value, before ending MAX_TIMEOUT time.\n\t/*!\n\t\\param uint8_t dest : packet destination.\n\t\\param char *payload : packet payload.\n\t\\return '0' on success, '1' otherwise\n\t*/\n\t//uint8_t sendPacketMAXTimeoutACKRetries(uint8_t dest, char *payload);\n\n\t//! It sends a packet, waits to receive an ACK and updates the _retries value, before ending MAX_TIMEOUT time.\n\t/*!\n\t\\param uint8_t dest : packet destination.\n\t\\param uint8_t *payload : packet payload.\n\t\\param uint16_t length : payload buffer length.\n\t\\return '0' on success, '1' otherwise\n\t*/\n\t//uint8_t sendPacketMAXTimeoutACKRetries(uint8_t dest, uint8_t *payload, uint16_t length);\n\n\t//! It sends a packet, waits to receive an ACK and updates the _retries value.\n\t/*!\n\t\\param uint8_t dest : packet destination.\n\t\\param char *payload : packet payload.\n\t\\return '0' on success, '1' otherwise\n\t*/\n\t//uint8_t sendPacketTimeoutACKRetries(uint8_t dest, char *payload);\n\n\t//! It sends a packet, waits to receive an ACK and updates the _retries value.\n\t/*!\n\t\\param uint8_t dest : packet destination.\n\t\\param uint8_t *payload : packet payload.\n\t\\param uint16_t length : payload buffer length.\n\t\\return '0' on success, '1' otherwise\n\t*/\n\t//uint8_t sendPacketTimeoutACKRetries(uint8_t dest, uint8_t *payload, uint16_t length);\n\n\t//! It sends a packet, waits to receive an ACK and updates the _retries value, before ending 'wait' time.\n\t/*!\n\t\\param uint8_t dest : packet destination.\n\t\\param char *payload : packet payload.\n\t\\param uint16_t wait : time to wait while trying to send the packet.\n\t\\return '0' on success, '1' otherwise\n\t*/\n\t//uint8_t sendPacketTimeoutACKRetries(uint8_t dest, char *payload, uint16_t wait);\n\n\t//! It sends a packet, waits to receive an ACK and updates the _retries value, before ending 'wait' time.\n\t/*!\n\t\\param uint8_t dest : packet destination.\n\t\\param uint8_t *payload : packet payload.\n\t\\param uint16_t length : payload buffer length.\n\t\\param uint16_t wait : time to wait while trying to send the packet.\n\t\\return '0' on success, '1' otherwise\n\t*/\n\t//uint8_t sendPacketTimeoutACKRetries(uint8_t dest, uint8_t *payload, uint16_t length, uint16_t wait);\n\n\t//! It gets the internal temperature of the module.\n\t/*!\n\tIt stores in global '_temp' variable the module temperature.\n\t\\return '0' on success, '1' otherwise\n\t*/\n\tuint8_t getTemp();\n\n    // added by C. Pham\n    void setPacketType(uint8_t type);\n    void RxChainCalibration();\n    uint8_t doCAD(uint8_t counter);\n    uint16_t getToA(uint8_t pl);\n    void CarrierSense(uint8_t cs=1);\n    void CarrierSense1();\n    void CarrierSense2();\n    void CarrierSense3(); \n    int8_t setSyncWord(uint8_t sw);\n    int8_t getSyncWord();\n    int8_t setSleepMode();\n    int8_t setPowerDBM(uint8_t dbm);\n    long limitToA();\n    long getRemainingToA();\n    long removeToA(uint16_t toa);\n    int8_t setFreqHopOn();\n    int8_t invertIQ(uint8_t dir, bool invert);\n    void setCSPin(uint8_t cs);\n\n    // SX1272 or SX1276?\n    uint8_t _board;\n    uint8_t _syncWord;\n    uint8_t _defaultSyncWord;\n    uint8_t _SX1272_SS;\n    unsigned long _starttime;\n    unsigned long _stoptime;\n    unsigned long _startDoCad;\n    unsigned long _endDoCad;\n    uint8_t _loraMode;\n    uint8_t _send_cad_number;\n    bool _extendedIFS;\n    bool _RSSIonSend;\n    bool _enableCarrierSense;\n    bool _freqHopOn;\n    uint8_t _hopPeriod;\n    bool _rawFormat;\n    bool _rawFormat_send;\n    int8_t _rcv_snr_in_ack;\n    bool _needPABOOST;\n    uint8_t _rawSNR;\n\n#ifdef W_REQUESTED_ACK\n\tuint8_t _requestACK;\n\tuint8_t _requestACK_indicator;\n#endif\n\n#ifdef W_NET_KEY\n\tuint8_t _my_netkey[NET_KEY_LENGTH];\n        uint8_t _the_net_key_0;\n        uint8_t _the_net_key_1;\n#endif\n\t// end\n\t\n\t/// Variables /////////////////////////////////////////////////////////////\n\n\t//! Variable : bandwidth configured in LoRa mode.\n\t//!    bandwidth = 00  --> BW = 125KHz\n\t//!    bandwidth = 01  --> BW = 250KHz\n\t//!    bandwidth = 10  --> BW = 500KHz\n  \t/*!\n   \t*/\n\tuint8_t _bandwidth;\n\n\t//! Variable : coding rate configured in LoRa mode.\n\t//!    codingRate = 001  --> CR = 4/5\n\t//!    codingRate = 010  --> CR = 4/6\n\t//!    codingRate = 011  --> CR = 4/7\n\t//!    codingRate = 100  --> CR = 4/8\n  \t/*!\n   \t*/\n\tuint8_t _codingRate;\n\n\t//! Variable : spreading factor configured in LoRa mode.\n\t//!    spreadingFactor = 6   --> SF = 6, 64 chips/symbol\n\t//!    spreadingFactor = 7   --> SF = 7, 128 chips/symbol\n\t//!    spreadingFactor = 8   --> SF = 8, 256 chips/symbol\n\t//!    spreadingFactor = 9   --> SF = 9, 512 chips/symbol\n\t//!    spreadingFactor = 10  --> SF = 10, 1024 chips/symbol\n\t//!    spreadingFactor = 11  --> SF = 11, 2048 chips/symbol\n\t//!    spreadingFactor = 12  --> SF = 12, 4096 chips/symbol\n  \t/*!\n   \t*/\n\tuint8_t _spreadingFactor;\n\n\t//! Variable : frequency channel.\n\t//!    channel = 0xD84CCC  --> CH = 10_868, 865.20MHz\n\t//!    channel = 0xD86000  --> CH = 11_868, 865.50MHz\n\t//!    channel = 0xD87333  --> CH = 12_868, 865.80MHz\n\t//!    channel = 0xD88666  --> CH = 13_868, 866.10MHz\n\t//!    channel = 0xD89999  --> CH = 14_868, 866.40MHz\n\t//!    channel = 0xD8ACCC  --> CH = 15_868, 866.70MHz\n\t//!    channel = 0xD8C000  --> CH = 16_868, 867.00MHz\n\t//!    channel = 0xE1C51E  --> CH = 00_900, 903.08MHz\n\t//!    channel = 0xE24F5C  --> CH = 01_900, 905.24MHz\n\t//!    channel = 0xE2D999  --> CH = 02_900, 907.40MHz\n\t//!    channel = 0xE363D7  --> CH = 03_900, 909.56MHz\n\t//!    channel = 0xE3EE14  --> CH = 04_900, 911.72MHz\n\t//!    channel = 0xE47851  --> CH = 05_900, 913.88MHz\n\t//!    channel = 0xE5028F  --> CH = 06_900, 916.04MHz\n\t//!    channel = 0xE58CCC  --> CH = 07_900, 918.20MHz\n\t//!    channel = 0xE6170A  --> CH = 08_900, 920.36MHz\n\t//!    channel = 0xE6A147  --> CH = 09_900, 922.52MHz\n\t//!    channel = 0xE72B85  --> CH = 10_900, 924.68MHz\n\t//!    channel = 0xE7B5C2  --> CH = 11_900, 926.84MHz\n  \t/*!\n   \t*/\n\tuint32_t _channel;\n\n\t//! Variable : output power.\n\t//!\n  \t/*!\n   \t*/\n\tuint8_t _power;\n\n\t//! Variable : SNR from the last packet received in LoRa mode.\n\t//!\n  \t/*!\n   \t*/\n\tint8_t _SNR;\n\n\t//! Variable : RSSI current value.\n\t//!\n  \t/*!\n   \t*/\n\tint8_t _RSSI;\n\n\t//! Variable : RSSI from the last packet received in LoRa mode.\n\t//!\n  \t/*!\n   \t*/\n\tint16_t _RSSIpacket;\n\n\t//! Variable : preamble length sent/received.\n\t//!\n  \t/*!\n   \t*/\n\tuint16_t _preamblelength;\n\n\t//! Variable : payload length sent/received.\n\t//!\n  \t/*!\n   \t*/\n\tuint16_t _payloadlength;\n\n\t//! Variable : node address.\n\t//!\n  \t/*!\n   \t*/\n\tuint8_t _nodeAddress;\n\n\t//! Variable : implicit or explicit header in LoRa mode.\n\t//!\n  \t/*!\n   \t*/\n\tuint8_t _header;\n\n\t//! Variable : header received while waiting a packet to arrive.\n\t//!\n  \t/*!\n   \t*/\n\tuint8_t _hreceived;\n\n\t//! Variable : presence or absence of CRC calculation.\n\t//!\n  \t/*!\n   \t*/\n\tuint8_t _CRC;\n\n\t//! Variable : packet destination.\n\t//!\n  \t/*!\n   \t*/\n\tuint8_t _destination;\n\n\t//! Variable : packet number.\n\t//!\n  \t/*!\n   \t*/\n\tuint8_t _packetNumber;\n\n\t//! Variable : indicates if received packet is correct or incorrect.\n\t//!\n  \t/*!\n   \t*/\n   \tuint8_t _reception;\n\n\t//! Variable : number of current retry.\n\t//!\n  \t/*!\n   \t*/\n   \tuint8_t _retries;\n\n   \t//! Variable : maximum number of retries.\n\t//!\n  \t/*!\n   \t*/\n   \tuint8_t _maxRetries;\n\n   \t//! Variable : maximum current supply.\n\t//!\n  \t/*!\n   \t*/\n   \tuint8_t _maxCurrent;\n\n\t//! Variable : indicates FSK or LoRa 'modem'.\n\t//!\n  \t/*!\n   \t*/\n\tuint8_t _modem;\n\n\t//! Variable : array with all the information about a sent packet.\n\t//!\n  \t/*!\n   \t*/\n\tpack packet_sent;\n\n\t//! Variable : array with all the information about a received packet.\n\t//!\n  \t/*!\n   \t*/\n\tpack packet_received;\n\n\t//! Variable : array with all the information about a sent/received ack.\n\t//!\n  \t/*!\n   \t*/\n\tpack ACK;\n\n    //! Structure Variable : Packet payload\n    /*!\n    */\n    uint8_t packet_data[MAX_PAYLOAD];\n    uint8_t ack_data[2];\n\n\t//! Variable : temperature module.\n\t//!\n  \t/*!\n   \t*/\n\tint _temp;\n\n\t//! Variable : current timeout to send a packet.\n\t//!\n  \t/*!\n   \t*/\n\tuint16_t _sendTime;\n\n    // added by C. Pham for ToA management\n    //\nprivate:\n\n    bool _limitToA;\n    long _remainingToA;\n    unsigned long _startToAcycle;\n    unsigned long _endToAcycle;\n    uint16_t _currentToA;\n};\n\nextern SX1272\tsx1272;\n\n#endif\n\n", "comment_ratio": 0.2096551724137931}
{"lang": "c", "code": "#ifndef included_INSCollocatedCenteredConvectiveOperator\n#define included_INSCollocatedCenteredConvectiveOperator\n\n/////////////////////////////// INCLUDES /////////////////////////////////////\n\n#include <string>\n#include <vector>\n\n#include \"CellVariable.h\"\n#include \"CoarsenAlgorithm.h\"\n#include \"FaceVariable.h\"\n#include \"PatchHierarchy.h\"\n#include \"RefineAlgorithm.h\"\n#include \"RefinePatchStrategy.h\"\n#include \"ibamr/ConvectiveOperator.h\"\n#include \"ibamr/ibamr_enums.h\"\n#include \"tbox/Database.h\"\n#include \"tbox/Pointer.h\"\n\nnamespace SAMRAI {\nnamespace solv {\ntemplate <int DIM, class TYPE> class SAMRAIVectorReal;\ntemplate <int DIM> class RobinBcCoefStrategy;\n}  // namespace solv\nnamespace xfer {\ntemplate <int DIM> class CoarsenSchedule;\ntemplate <int DIM> class RefineSchedule;\n}  // namespace xfer\n}  // namespace SAMRAI\n\n/////////////////////////////// CLASS DEFINITION /////////////////////////////\n\nnamespace IBAMR\n{\n/*!\n * \\brief Class INSCollocatedCenteredConvectiveOperator is a concrete\n * ConvectiveOperator which implements a centered convective differencing\n * operator.\n *\n * \\see INSCollocatedHierarchyIntegrator\n */\nclass INSCollocatedCenteredConvectiveOperator\n    : public ConvectiveOperator\n{\npublic:\n    /*!\n     * \\brief Class constructor.\n     */\n    INSCollocatedCenteredConvectiveOperator(\n        const std::string& object_name,\n        SAMRAI::tbox::Pointer<SAMRAI::tbox::Database> input_db,\n        ConvectiveDifferencingType difference_form,\n        const std::vector<SAMRAI::solv::RobinBcCoefStrategy<NDIM>*>& bc_coefs);\n\n    /*!\n     * \\brief Destructor.\n     */\n    ~INSCollocatedCenteredConvectiveOperator();\n\n    /*!\n     * \\brief Static function to construct an\n     * INSCollocatedCenteredConvectiveOperator.\n     */\n    static SAMRAI::tbox::Pointer<ConvectiveOperator>\n    allocate_operator(\n        const std::string& object_name,\n        SAMRAI::tbox::Pointer<SAMRAI::tbox::Database> input_db,\n        ConvectiveDifferencingType difference_form,\n        const std::vector<SAMRAI::solv::RobinBcCoefStrategy<NDIM>*>& bc_coefs)\n        {\n            return new INSCollocatedCenteredConvectiveOperator(object_name, input_db, difference_form, bc_coefs);\n        }// allocate_operator\n\n    /*!\n     * \\brief Compute the action of the convective operator.\n     */\n    void\n    applyConvectiveOperator(\n        int U_idx,\n        int N_idx);\n\n    /*!\n     * \\name General operator functionality.\n     */\n    //\\{\n\n    /*!\n     * \\brief Compute hierarchy dependent data required for computing y=F[x] and\n     * z=F[x]+y.\n     *\n     * The vector arguments for apply(), applyAdjoint(), etc, need not match\n     * those for initializeOperatorState().  However, there must be a certain\n     * degree of similarity, including\n     * - hierarchy configuration (hierarchy pointer and level range)\n     * - number, type and alignment of vector component data\n     * - ghost cell widths of data in the input and output vectors\n     *\n     * \\note It is generally necessary to reinitialize the operator state when\n     * the hierarchy configuration changes.\n     *\n     * It is safe to call initializeOperatorState() when the state is already\n     * initialized.  In this case, the operator state is first deallocated and\n     * then reinitialized.\n     *\n     * Conditions on arguments:\n     * - input and output vectors must have same hierarchy\n     * - input and output vectors must have same structure, depth, etc.\n     *\n     * Call deallocateOperatorState() to remove any data allocated by this\n     * method.\n     *\n     * \\see deallocateOperatorState\n     *\n     * \\param in input vector\n     * \\param out output vector\n     */\n    void\n    initializeOperatorState(\n        const SAMRAI::solv::SAMRAIVectorReal<NDIM,double>& in,\n        const SAMRAI::solv::SAMRAIVectorReal<NDIM,double>& out);\n\n    /*!\n     * \\brief Remove all hierarchy dependent data allocated by\n     * initializeOperatorState().\n     *\n     * \\note It is safe to call deallocateOperatorState() when the operator\n     * state is already deallocated.\n     *\n     * \\see initializeOperatorState\n     */\n    void\n    deallocateOperatorState();\n\n    //\\}\n\nprivate:\n    /*!\n     * \\brief Default constructor.\n     *\n     * \\note This constructor is not implemented and should not be used.\n     */\n    INSCollocatedCenteredConvectiveOperator();\n\n    /*!\n     * \\brief Copy constructor.\n     *\n     * \\note This constructor is not implemented and should not be used.\n     *\n     * \\param from The value to copy to this object.\n     */\n    INSCollocatedCenteredConvectiveOperator(\n        const INSCollocatedCenteredConvectiveOperator& from);\n\n    /*!\n     * \\brief Assignment operator.\n     *\n     * \\note This operator is not implemented and should not be used.\n     *\n     * \\param that The value to assign to this object.\n     *\n     * \\return A reference to this object.\n     */\n    INSCollocatedCenteredConvectiveOperator&\n    operator=(\n        const INSCollocatedCenteredConvectiveOperator& that);\n\n    // Data communication algorithms, operators, and schedules.\n    SAMRAI::tbox::Pointer<SAMRAI::xfer::CoarsenAlgorithm<NDIM> > d_coarsen_alg;\n    std::vector<SAMRAI::tbox::Pointer<SAMRAI::xfer::CoarsenSchedule<NDIM> > > d_coarsen_scheds;\n    SAMRAI::tbox::Pointer<SAMRAI::xfer::RefineAlgorithm<NDIM> > d_ghostfill_alg;\n    SAMRAI::tbox::Pointer<SAMRAI::xfer::RefinePatchStrategy<NDIM> > d_ghostfill_strategy;\n    std::vector<SAMRAI::tbox::Pointer<SAMRAI::xfer::RefineSchedule<NDIM> > > d_ghostfill_scheds;\n    std::string d_bdry_extrap_type;\n\n    // Hierarchy configuration.\n    SAMRAI::tbox::Pointer<SAMRAI::hier::PatchHierarchy<NDIM> > d_hierarchy;\n    int d_coarsest_ln, d_finest_ln;\n\n    // Scratch data.\n    SAMRAI::tbox::Pointer<SAMRAI::pdat::CellVariable<NDIM,double> > d_U_var;\n    int d_U_scratch_idx;\n    SAMRAI::tbox::Pointer<SAMRAI::pdat::FaceVariable<NDIM,double> > d_u_extrap_var, d_u_flux_var;\n    int d_u_extrap_idx, d_u_flux_idx;\n};\n}// namespace IBAMR\n\n//////////////////////////////////////////////////////////////////////////////\n\n#endif //#ifndef included_INSCollocatedCenteredConvectiveOperator\n\n", "comment_ratio": 0.20270270270270271}
{"lang": "c", "code": "#pragma once\n\n#include \"stdafx.h\"\n\n//\n// Define CUDA Device API Typedefs.\n//\n\ntypedef LONG CU_DEVICE;\ntypedef ULONG_PTR CU_DEVICE_POINTER;\ntypedef CU_DEVICE *PCU_DEVICE;\ntypedef CU_DEVICE **PPCU_DEVICE;\ntypedef CU_DEVICE_POINTER *PCU_DEVICE_POINTER;\ntypedef CU_DEVICE_POINTER **PPCU_DEVICE_POINTER;\n\nstruct CU_CONTEXT;\ntypedef struct CU_CONTEXT *PCU_CONTEXT;\ntypedef struct CU_CONTEXT **PPCU_CONTEXT;\n\nstruct CU_MODULE;\ntypedef struct CU_MODULE *PCU_MODULE;\ntypedef struct CU_MODULE **PPCU_MODULE;\n\nstruct CU_EVENT;\ntypedef struct CU_EVENT *PCU_EVENT;\ntypedef struct CU_EVENT **PPCU_EVENT;\n\nstruct CU_STREAM;\ntypedef struct CU_STREAM *PCU_STREAM;\ntypedef struct CU_STREAM **PPCU_STREAM;\n\nstruct CU_FUNCTION;\ntypedef struct CU_FUNCTION *PCU_FUNCTION;\ntypedef struct CU_FUNCTION **PPCU_FUNCTION;\n\ntypedef enum _CU_RESULT {\n\n    //\n    // The API call returned with no errors. In the case of query calls, this\n    // can also mean that the operation being queried is complete (see\n    // ::cuEventQuery() and ::cuStreamQuery()).\n    //\n\n    CUDA_SUCCESS                              = 0,\n\n    //\n    // This indicates that one or more of the parameters passed to the API call\n    // is not within an acceptable range of values.\n    //\n\n    CUDA_ERROR_INVALID_VALUE                  = 1,\n\n    //\n    // The API call failed because it was unable to allocate enough memory to\n    // perform the requested operation.\n    //\n\n    CUDA_ERROR_OUT_OF_MEMORY                  = 2,\n\n    //\n    // This indicates that the CUDA driver has not been initialized with\n    // ::cuInit() or that initialization has failed.\n    //\n\n    CUDA_ERROR_NOT_INITIALIZED                = 3,\n\n    //\n    // This indicates that the CUDA driver is in the process of shutting down.\n    //\n\n    CUDA_ERROR_DEINITIALIZED                  = 4,\n\n    //\n    // This indicates profiling APIs are called while application is running\n    // in visual profiler mode.\n   //\n\n    CUDA_ERROR_PROFILER_DISABLED           = 5,\n    //\n    // This indicates profiling has not been initialized for this context.\n    // Call cuProfilerInitialize() to resolve this.\n   //\n\n    CUDA_ERROR_PROFILER_NOT_INITIALIZED       = 6,\n    //\n    // This indicates profiler has already been started and probably\n    // cuProfilerStart() is incorrectly called.\n   //\n\n    CUDA_ERROR_PROFILER_ALREADY_STARTED       = 7,\n    //\n    // This indicates profiler has already been stopped and probably\n    // cuProfilerStop() is incorrectly called.\n   //\n\n    CUDA_ERROR_PROFILER_ALREADY_STOPPED       = 8,\n    //\n    // This indicates that no CUDA-capable devices were detected by the\n    // installed CUDA driver.\n    //\n\n    CUDA_ERROR_NO_DEVICE                      = 100,\n\n    //\n    // This indicates that the device ordinal supplied by the user does not\n    // correspond to a valid CUDA device.\n    //\n\n    CUDA_ERROR_INVALID_DEVICE                 = 101,\n\n\n    //\n    // This indicates that the device kernel image is invalid. This can also\n    // indicate an invalid CUDA module.\n    //\n\n    CUDA_ERROR_INVALID_IMAGE                  = 200,\n\n    //\n    // This most frequently indicates that there is no context bound to the\n    // current thread. This can also be returned if the context passed to an\n    // API call is not a valid handle (such as a context that has had\n    // ::cuCtxDestroy() invoked on it). This can also be returned if a user\n    // mixes different API versions (i.e. 3010 context with 3020 API calls).\n    // See ::cuCtxGetApiVersion() for more details.\n    //\n\n    CUDA_ERROR_INVALID_CONTEXT                = 201,\n\n    //\n    // This indicated that the context being supplied as a parameter to the\n    // API call was already the active context.\n    // \\deprecated\n    // This error return is deprecated as of CUDA 3.2. It is no longer an\n    // error to attempt to push the active context via ::cuCtxPushCurrent().\n    //\n\n    CUDA_ERROR_CONTEXT_ALREADY_CURRENT        = 202,\n\n    //\n    // This indicates that a map or register operation has failed.\n    //\n\n    CUDA_ERROR_MAP_FAILED                     = 205,\n\n    //\n    // This indicates that an unmap or unregister operation has failed.\n    //\n\n    CUDA_ERROR_UNMAP_FAILED                   = 206,\n\n    //\n    // This indicates that the specified array is currently mapped and thus\n    // cannot be destroyed.\n    //\n\n    CUDA_ERROR_ARRAY_IS_MAPPED                = 207,\n\n    //\n    // This indicates that the resource is already mapped.\n    //\n\n    CUDA_ERROR_ALREADY_MAPPED                 = 208,\n\n    //\n    // This indicates that there is no kernel image available that is suitable\n    // for the device. This can occur when a user specifies code generation\n    // options for a particular CUDA source file that do not include the\n    // corresponding device configuration.\n    //\n\n    CUDA_ERROR_NO_BINARY_FOR_GPU              = 209,\n\n    //\n    // This indicates that a resource has already been acquired.\n    //\n\n    CUDA_ERROR_ALREADY_ACQUIRED               = 210,\n\n    //\n    // This indicates that a resource is not mapped.\n    //\n\n    CUDA_ERROR_NOT_MAPPED                     = 211,\n\n    //\n    // This indicates that a mapped resource is not available for access as an\n    // array.\n    //\n\n    CUDA_ERROR_NOT_MAPPED_AS_ARRAY            = 212,\n\n    //\n    // This indicates that a mapped resource is not available for access as a\n    // pointer.\n    //\n\n    CUDA_ERROR_NOT_MAPPED_AS_POINTER          = 213,\n\n    //\n    // This indicates that an uncorrectable ECC error was detected during\n    // execution.\n    //\n\n    CUDA_ERROR_ECC_UNCORRECTABLE              = 214,\n\n    //\n    // This indicates that the ::CUlimit passed to the API call is not\n    // supported by the active device.\n    //\n\n    CUDA_ERROR_UNSUPPORTED_LIMIT              = 215,\n\n    //\n    // This indicates that the ::CUcontext passed to the API call can\n    // only be bound to a single CPU thread at a time but is already\n    // bound to a CPU thread.\n    //\n\n    CUDA_ERROR_CONTEXT_ALREADY_IN_USE         = 216,\n\n    //\n    // This indicates that the device kernel source is invalid.\n    //\n\n    CUDA_ERROR_INVALID_SOURCE                 = 300,\n\n    //\n    // This indicates that the file specified was not found.\n    //\n\n    CUDA_ERROR_FILE_NOT_FOUND                 = 301,\n\n    //\n    // This indicates that a link to a shared object failed to resolve.\n    //\n\n    CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND = 302,\n\n    //\n    // This indicates that initialization of a shared object failed.\n    //\n\n    CUDA_ERROR_SHARED_OBJECT_INIT_FAILED      = 303,\n\n    //\n    // This indicates that an OS call failed.\n    //\n\n    CUDA_ERROR_OPERATING_SYSTEM               = 304,\n\n\n    //\n    // This indicates that a resource handle passed to the API call was not\n    // valid. Resource handles are opaque types like ::CUstream and ::CUevent.\n    //\n\n    CUDA_ERROR_INVALID_HANDLE                 = 400,\n\n\n    //\n    // This indicates that a named symbol was not found. Examples of symbols\n    // are global/constant variable names, texture names, and surface names.\n    //\n\n    CUDA_ERROR_NOT_FOUND                      = 500,\n\n\n    //\n    // This indicates that asynchronous operations issued previously have not\n    // completed yet. This result is not actually an error, but must be\n    // indicated differently than ::CUDA_SUCCESS (which indicates completion).\n    // Calls that may return this value include ::cuEventQuery() and\n    // ::cuStreamQuery().\n    //\n\n    CUDA_ERROR_NOT_READY                      = 600,\n\n\n    //\n    // An exception occurred on the device while executing a kernel. Common\n    // causes include dereferencing an invalid device pointer and accessing\n    // out of bounds shared memory. The context cannot be used, so it must\n    // be destroyed (and a new one should be created). All existing device\n    // memory allocations from this context are invalid and must be\n    // reconstructed if the program is to continue using CUDA.\n    //\n\n    CUDA_ERROR_LAUNCH_FAILED                  = 700,\n\n    //\n    // This indicates that a launch did not occur because it did not have\n    // appropriate resources. This error usually indicates that the user has\n    // attempted to pass too many arguments to the device kernel, or the\n    // kernel launch specifies too many threads for the kernel's register\n    // count. Passing arguments of the wrong size (i.e. a 64-bit pointer\n    // when a 32-bit int is expected) is equivalent to passing too many\n    // arguments and can also result in this error.\n    //\n\n    CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES        = 701,\n\n    //\n    // This indicates that the device kernel took too long to execute. This can\n    // only occur if timeouts are enabled - see the device attribute\n    // ::CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT for more information. The\n    // context cannot be used (and must be destroyed similar to\n    // ::CUDA_ERROR_LAUNCH_FAILED). All existing device memory allocations from\n    // this context are invalid and must be reconstructed if the program is to\n    // continue using CUDA.\n    //\n\n    CUDA_ERROR_LAUNCH_TIMEOUT                 = 702,\n\n    //\n    // This error indicates a kernel launch that uses an incompatible texturing\n    // mode.\n    //\n\n    CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING  = 703,\n\n    //\n    // This error indicates that a call to ::cuCtxEnablePeerAccess() is\n    // trying to re-enable peer access to a context which has already\n    // had peer access to it enabled.\n    //\n\n    CUDA_ERROR_PEER_ACCESS_ALREADY_ENABLED = 704,\n\n    //\n    // This error indicates that a call to ::cuMemPeerRegister is trying to\n    // register memory from a context which has not had peer access\n    // enabled yet via ::cuCtxEnablePeerAccess(), or that\n    // ::cuCtxDisablePeerAccess() is trying to disable peer access\n    // which has not been enabled yet.\n    //\n\n    CUDA_ERROR_PEER_ACCESS_NOT_ENABLED    = 705,\n\n    //\n    // This error indicates that a call to ::cuMemPeerRegister is trying to\n    // register already-registered memory.\n    //\n\n    CUDA_ERROR_PEER_MEMORY_ALREADY_REGISTERED = 706,\n\n    //\n    // This error indicates that a call to ::cuMemPeerUnregister is trying to\n    // unregister memory that has not been registered.\n    //\n\n    CUDA_ERROR_PEER_MEMORY_NOT_REGISTERED     = 707,\n\n    //\n    // This error indicates that ::cuCtxCreate was called with the flag\n    // ::CU_CTX_PRIMARY on a device which already has initialized its\n    // primary context.\n    //\n\n    CUDA_ERROR_PRIMARY_CONTEXT_ACTIVE         = 708,\n\n    //\n    // This error indicates that the context current to the calling thread\n    // has been destroyed using ::cuCtxDestroy, or is a primary context which\n    // has not yet been initialized.\n    //\n\n    CUDA_ERROR_CONTEXT_IS_DESTROYED           = 709,\n\n    //\n    // A device-side assert triggered during kernel execution. The context\n    // cannot be used anymore, and must be destroyed. All existing device\n    // memory allocations from this context are invalid and must be\n    // reconstructed if the program is to continue using CUDA.\n    //\n\n    CUDA_ERROR_ASSERT                         = 710,\n\n    //\n    // This error indicates that the hardware resources required to enable\n    // peer access have been exhausted for one or more of the devices\n    // passed to ::cuCtxEnablePeerAccess().\n    //\n\n    CUDA_ERROR_TOO_MANY_PEERS                 = 711,\n\n    //\n    // This error indicates that the memory range passed to ::cuMemHostRegister()\n    // has already been registered.\n    //\n\n    CUDA_ERROR_HOST_MEMORY_ALREADY_REGISTERED = 712,\n\n    //\n    // This error indicates that the pointer passed to ::cuMemHostUnregister()\n    // does not correspond to any currently registered memory region.\n    //\n\n    CUDA_ERROR_HOST_MEMORY_NOT_REGISTERED     = 713,\n\n    //\n    // This indicates that an unknown internal error has occurred.\n    //\n\n    CUDA_ERROR_UNKNOWN                        = 999\n\n} CU_RESULT;\n\n#define CU_SUCCEEDED(Result) (Result == CUDA_SUCCESS)\n#define CU_FAILED(Result) (Result != CUDA_SUCCESS)\n\ntypedef enum _Enum_is_bitflag_ _CU_CTX_CREATE_FLAGS {\n    CU_CTX_SCHED_AUTO           = 0x00,\n    CU_CTX_SCHED_SPIN           = 0x01,\n    CU_CTX_SCHED_YIELD          = 0x02,\n    CU_CTX_SCHED_BLOCKING_SYNC  = 0x04,\n    CU_CTX_BLOCKING_SYNC        = 0x04,\n    CU_CTX_MAP_HOST             = 0x08,\n    CU_CTX_LMEM_RESIZE_TO_MAX   = 0x10,\n    CU_CTX_SCHED_MASK           = 0x07,\n    CU_CTX_PRIMARY              = 0x20,\n    CU_CTX_FLAGS_MASK           = 0x3f\n} CU_CTX_CREATE_FLAGS;\n\ntypedef enum _Enum_is_bitflag_ _CU_EVENT_FLAGS {\n    CU_EVENT_DEFAULT            = 0x0,\n    CU_EVENT_BLOCKING_SYNC      = 0x1,\n    CU_EVENT_DISABLE_TIMING     = 0x2,\n    CU_EVENT_INTERPROCESS       = 0x4\n} CU_EVENT_FLAGS;\n\ntypedef enum _Enum_is_bitflag_ _CU_STREAM_FLAGS {\n    CU_STREAM_DEFAULT           =   0x0,\n    CU_STREAM_NON_BLOCKING      =   0x1\n} CU_STREAM_FLAGS;\n\ntypedef enum _Enum_is_bitflag_ _CU_MEM_ATTACH_FLAGS {\n    CU_MEM_ATTACH_GLOBAL        = 0x1,\n    CU_MEM_ATTACH_HOST          = 0x2,\n    CU_MEM_ATTACH_SINGLE        = 0x4\n} CU_MEM_ATTACH_FLAGS;\n\ntypedef enum _Enum_is_bitflag_ _CU_STREAM_WAIT_VALUE {\n    CU_STREAM_WAIT_VALUE_GEQ   = 0x0,\n    CU_STREAM_WAIT_VALUE_EQ    = 0x1,\n    CU_STREAM_WAIT_VALUE_AND   = 0x2,\n    CU_STREAM_WAIT_VALUE_FLUSH = 1<<30\n} CU_STREAM_WAIT_VALUE;\n\ntypedef enum _Enum_is_bitflag_ _CU_STREAM_WRITE_VALUE {\n    CU_STREAM_WRITE_VALUE_DEFAULT           = 0x0,\n    CU_STREAM_WRITE_VALUE_NO_MEMORY_BARRIER = 0x1\n} CU_STREAM_WRITE_VALUE;\n\ntypedef enum _CU_STREAM_BATCH_MEM_OP_TYPE {\n    CU_STREAM_MEM_OP_WAIT_VALUE_32          = 1,\n    CU_STREAM_MEM_OP_WRITE_VALUE_32         = 2,\n    CU_STREAM_MEM_OP_FLUSH_REMOTE_WRITES    = 3\n} CU_STREAM_BATCH_MEM_OP_TYPE;\ntypedef CU_STREAM_BATCH_MEM_OP_TYPE *PCU_STREAM_BATCH_MEM_OP_TYPE;\n\ntypedef union _CU_STREAM_BATCH_MEM_OP_PARAMS {\n    CU_STREAM_BATCH_MEM_OP_TYPE Operation;\n    struct {\n        CU_STREAM_BATCH_MEM_OP_TYPE Operation;\n        PCU_DEVICE_POINTER Address;\n        ULONG Value;\n        ULONG Padding1;\n        CU_STREAM_WAIT_VALUE Flags;\n        ULONG Padding2;\n        PCU_DEVICE_POINTER Alias;\n    } Wait;\n    struct {\n        CU_STREAM_BATCH_MEM_OP_TYPE Operation;\n        PCU_DEVICE_POINTER Address;\n        ULONG Value;\n        ULONG Padding1;\n        CU_STREAM_WRITE_VALUE Flags;\n        ULONG Padding2;\n        PCU_DEVICE_POINTER Alias;\n    } Write;\n    struct {\n        CU_STREAM_BATCH_MEM_OP_TYPE Operation;\n        ULONG Flags;\n    } FlushRemoteWrites;\n    ULONG64 Padding[6];\n} CU_STREAM_BATCH_MEM_OP_PARAMS;\ntypedef CU_STREAM_BATCH_MEM_OP_PARAMS *PCU_STREAM_BATCH_MEM_OP_PARAMS;\n\ntypedef enum _CU_JIT_OPTION {\n    CU_JIT_MAX_REGISTERS = 0,\n    CU_JIT_THREADS_PER_BLOCK,\n    CU_JIT_WALL_TIME,\n    CU_JIT_INFO_LOG_BUFFER,\n    CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES,\n    CU_JIT_ERROR_LOG_BUFFER,\n    CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES,\n    CU_JIT_OPTIMIZATION_LEVEL,\n    CU_JIT_TARGET_FROM_CUCONTEXT,\n    CU_JIT_TARGET,\n    CU_JIT_FALLBACK_STRATEGY\n} CU_JIT_OPTION;\ntypedef CU_JIT_OPTION *PCU_JIT_OPTION;\ntypedef CU_JIT_OPTION **PPCU_JIT_OPTION;\n\ntypedef enum _CU_DEVICE_ATTRIBUTE {\n    CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK = 1,\n    CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_X = 2,\n    CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Y = 3,\n    CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Z = 4,\n    CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_X = 5,\n    CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Y = 6,\n    CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Z = 7,\n    CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK = 8,\n    CU_DEVICE_ATTRIBUTE_TOTAL_CONSTANT_MEMORY = 9,\n    CU_DEVICE_ATTRIBUTE_WARP_SIZE = 10,\n    CU_DEVICE_ATTRIBUTE_MAX_PITCH = 11,\n    CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK = 12,\n    CU_DEVICE_ATTRIBUTE_CLOCK_RATE = 13,\n    CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT = 14,\n    CU_DEVICE_ATTRIBUTE_GPU_OVERLAP = 15,\n    CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT = 16,\n    CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT = 17,\n    CU_DEVICE_ATTRIBUTE_INTEGRATED = 18,\n    CU_DEVICE_ATTRIBUTE_CAN_MAP_HOST_MEMORY = 19,\n    CU_DEVICE_ATTRIBUTE_COMPUTE_MODE = 20,\n    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_WIDTH = 21,\n    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_WIDTH = 22,\n    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_HEIGHT = 23,\n    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH = 24,\n    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT = 25,\n    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH = 26,\n    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_WIDTH = 27,\n    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_HEIGHT = 28,\n    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_NUMSLICES = 29,\n    CU_DEVICE_ATTRIBUTE_SURFACE_ALIGNMENT = 30,\n    CU_DEVICE_ATTRIBUTE_CONCURRENT_KERNELS = 31,\n    CU_DEVICE_ATTRIBUTE_ECC_ENABLED = 32,\n    CU_DEVICE_ATTRIBUTE_PCI_BUS_ID = 33,\n    CU_DEVICE_ATTRIBUTE_PCI_DEVICE_ID = 34,\n    CU_DEVICE_ATTRIBUTE_TCC_DRIVER = 35,\n    CU_DEVICE_ATTRIBUTE_MEMORY_CLOCK_RATE = 36,\n    CU_DEVICE_ATTRIBUTE_GLOBAL_MEMORY_BUS_WIDTH = 37,\n    CU_DEVICE_ATTRIBUTE_L2_CACHE_SIZE = 38,\n    CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_MULTIPROCESSOR = 39,\n    CU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT = 40,\n    CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING = 41,\n    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_WIDTH = 42,\n    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_LAYERS = 43,\n    CU_DEVICE_ATTRIBUTE_CAN_TEX2D_GATHER = 44,\n    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_WIDTH = 45,\n    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_HEIGHT = 46,\n    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH_ALTERNATE = 47,\n    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT_ALTERNATE = 48,\n    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH_ALTERNATE = 49,\n    CU_DEVICE_ATTRIBUTE_PCI_DOMAIN_ID = 50,\n    CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT = 51,\n    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_WIDTH = 52,\n    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_WIDTH = 53,\n    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_LAYERS = 54,\n    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_WIDTH = 55,\n    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_WIDTH = 56,\n    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_HEIGHT = 57,\n    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_WIDTH = 58,\n    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_HEIGHT = 59,\n    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_DEPTH = 60,\n    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_WIDTH = 61,\n    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_LAYERS = 62,\n    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_WIDTH = 63,\n    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_HEIGHT = 64,\n    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_LAYERS = 65,\n    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_WIDTH = 66,\n    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_WIDTH = 67,\n    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_LAYERS = 68,\n    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH = 69,\n    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH = 70,\n    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT = 71,\n    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH = 72,\n    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_WIDTH = 73,\n    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_HEIGHT = 74,\n    CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR = 75,\n    CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR = 76,\n    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_MIPMAPPED_WIDTH = 77,\n    CU_DEVICE_ATTRIBUTE_STREAM_PRIORITIES_SUPPORTED = 78,\n    CU_DEVICE_ATTRIBUTE_GLOBAL_L1_CACHE_SUPPORTED = 79,\n    CU_DEVICE_ATTRIBUTE_LOCAL_L1_CACHE_SUPPORTED = 80,\n    CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR = 81,\n    CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_MULTIPROCESSOR = 82,\n    CU_DEVICE_ATTRIBUTE_MANAGED_MEMORY = 83,\n    CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD = 84,\n    CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD_GROUP_ID = 85,\n    CU_DEVICE_ATTRIBUTE_HOST_NATIVE_ATOMIC_SUPPORTED = 86,\n    CU_DEVICE_ATTRIBUTE_SINGLE_TO_DOUBLE_PRECISION_PERF_RATIO = 87,\n    CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS = 88,\n    CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS = 89,\n    CU_DEVICE_ATTRIBUTE_COMPUTE_PREEMPTION_SUPPORTED = 90,\n    CU_DEVICE_ATTRIBUTE_CAN_USE_HOST_POINTER_FOR_REGISTERED_MEM = 91,\n    CU_DEVICE_ATTRIBUTE_MAX\n} CU_DEVICE_ATTRIBUTE;\ntypedef CU_DEVICE_ATTRIBUTE *PCU_DEVICE_ATTRIBUTE;\n\ntypedef struct _CU_DEVICE_ATTRIBUTES {\n    ULONG MaxThreadsPerBlock;\n    ULONG MaxBlockDimX;\n    ULONG MaxBlockDimY;\n    ULONG MaxBlockDimZ;\n    ULONG MaxGridDimX;\n    ULONG MaxGridDimY;\n    ULONG MaxGridDimZ;\n    ULONG MaxSharedMemoryPerBlock;\n    ULONG TotalConstantMemory;\n    ULONG WarpSize;\n    ULONG MaxPitch;\n    ULONG MaxRegistersPerBlock;\n    ULONG ClockRate;\n    ULONG TextureAlignment;\n    ULONG GpuOverlap;\n    ULONG MultiprocessorCount;\n    ULONG KernelExecTimeout;\n    ULONG Integrated;\n    ULONG CanMapHostMemory;\n    ULONG ComputeMode;\n    ULONG MaximumTexture1DWidth;\n    ULONG MaximumTexture2DWidth;\n    ULONG MaximumTexture2DHeight;\n    ULONG MaximumTexture3DWidth;\n    ULONG MaximumTexture3DHeight;\n    ULONG MaximumTexture3DDepth;\n    ULONG MaximumTexture2DArrayWidth;\n    ULONG MaximumTexture2DArrayHeight;\n    ULONG MaximumTexture2DArrayNumslices;\n    ULONG SurfaceAlignment;\n    ULONG ConcurrentKernels;\n    ULONG EccEnabled;\n    ULONG PciBusId;\n    ULONG PciDeviceId;\n    ULONG TccDriver;\n    ULONG MemoryClockRate;\n    ULONG GlobalMemoryBusWidth;\n    ULONG L2CacheSize;\n    ULONG MaxThreadsPerMultiprocessor;\n    ULONG AsyncEngineCount;\n    ULONG UnifiedAddressing;\n    ULONG MaximumTexture1DLayeredWidth;\n    ULONG MaximumTexture1DLayeredLayers;\n    ULONG CanTex2DGather;\n    ULONG MaximumTexture2DGatherWidth;\n    ULONG MaximumTexture2DGatherHeight;\n    ULONG MaximumTexture3DWidthAlternate;\n    ULONG MaximumTexture3DHeightAlternate;\n    ULONG MaximumTexture3DDepthAlternate;\n    ULONG PciDomainId;\n    ULONG TexturePitchAlignment;\n    ULONG MaximumTexturecubemapWidth;\n    ULONG MaximumTexturecubemapLayeredWidth;\n    ULONG MaximumTexturecubemapLayeredLayers;\n    ULONG MaximumSurface1DWidth;\n    ULONG MaximumSurface2DWidth;\n    ULONG MaximumSurface2DHeight;\n    ULONG MaximumSurface3DWidth;\n    ULONG MaximumSurface3DHeight;\n    ULONG MaximumSurface3DDepth;\n    ULONG MaximumSurface1DLayeredWidth;\n    ULONG MaximumSurface1DLayeredLayers;\n    ULONG MaximumSurface2DLayeredWidth;\n    ULONG MaximumSurface2DLayeredHeight;\n    ULONG MaximumSurface2DLayeredLayers;\n    ULONG MaximumSurfacecubemapWidth;\n    ULONG MaximumSurfacecubemapLayeredWidth;\n    ULONG MaximumSurfacecubemapLayeredLayers;\n    ULONG MaximumTexture1DLinearWidth;\n    ULONG MaximumTexture2DLinearWidth;\n    ULONG MaximumTexture2DLinearHeight;\n    ULONG MaximumTexture2DLinearPitch;\n    ULONG MaximumTexture2DMipmappedWidth;\n    ULONG MaximumTexture2DMipmappedHeight;\n    ULONG ComputeCapabilityMajor;\n    ULONG ComputeCapabilityMinor;\n    ULONG MaximumTexture1DMipmappedWidth;\n    ULONG StreamPrioritiesSupported;\n    ULONG GlobalL1CacheSupported;\n    ULONG LocalL1CacheSupported;\n    ULONG MaxSharedMemoryPerMultiprocessor;\n    ULONG MaxRegistersPerMultiprocessor;\n    ULONG ManagedMemory;\n    ULONG MultiGpuBoard;\n    ULONG MultiGpuBoardGroupId;\n    ULONG HostNativeAtomicSupported;\n    ULONG SingleToDoublePrecisionPerfRatio;\n    ULONG PageableMemoryAccess;\n    ULONG ConcurrentManagedAccess;\n    ULONG ComputePreemptionSupported;\n    ULONG CanUseHostPointerForRegisteredMem;\n} CU_DEVICE_ATTRIBUTES;\ntypedef CU_DEVICE_ATTRIBUTES *PCU_DEVICE_ATTRIBUTES;\n\n#define CU_MEMHOSTALLOC_PORTABLE        0x01\n#define CU_MEMHOSTALLOC_DEVICEMAP       0x02\n#define CU_MEMHOSTALLOC_WRITECOMBINED   0x04\n#define CU_MEMHOSTREGISTER_PORTABLE     0x01\n#define CU_MEMHOSTREGISTER_DEVICEMAP    0x02\n#define CU_MEMHOSTREGISTER_IOMEMORY     0x04\n#define CU_MEMPEERREGISTER_DEVICEMAP    0x02\n\ntypedef union _CU_MEM_HOST_ALLOC_FLAGS {\n    struct _Struct_size_bytes_(sizeof(ULONG)) {\n        ULONG Portable:1;\n        ULONG DeviceMap:1;\n        ULONG WriteCombined:1;\n    };\n    LONG AsLong;\n    ULONG AsULong;\n} CU_MEM_HOST_ALLOC_FLAGS;\nC_ASSERT(sizeof(CU_MEM_HOST_ALLOC_FLAGS) == sizeof(ULONG));\n\ntypedef union _CU_MEM_HOST_REGISTER_FLAGS {\n    struct _Struct_size_bytes_(sizeof(ULONG)) {\n        ULONG Portable:1;\n        ULONG DeviceMap:1;\n        ULONG IoMemory:1;\n    };\n    LONG AsLong;\n    ULONG AsULong;\n} CU_MEM_HOST_REGISTER_FLAGS;\nC_ASSERT(sizeof(CU_MEM_HOST_REGISTER_FLAGS) == sizeof(ULONG));\n\n//\n// Initialization.\n//\n\ntypedef\n_Check_return_\nCU_RESULT\n(CU_INIT)(\n    _In_opt_ ULONG Flags\n    );\ntypedef CU_INIT *PCU_INIT;\n\n//\n// Errors.\n//\n\ntypedef\n_Check_return_\nCU_RESULT\n(CU_GET_ERROR_NAME)(\n    _In_opt_ CU_RESULT Error,\n    _Outptr_result_z_ PCSZ *ErrorString\n    );\ntypedef CU_GET_ERROR_NAME *PCU_GET_ERROR_NAME;\n\ntypedef\n_Check_return_\nCU_RESULT\n(CU_GET_ERROR_STRING)(\n    _In_opt_ CU_RESULT Error,\n    _Outptr_result_z_ PCSZ *ErrorString\n    );\ntypedef CU_GET_ERROR_STRING *PCU_GET_ERROR_STRING;\n\n//\n// Driver Version.\n//\n\ntypedef\n_Check_return_\nCU_RESULT\n(CU_DRIVER_GET_VERSION)(\n    _Out_ PLONG DriverVersion\n    );\ntypedef CU_DRIVER_GET_VERSION *PCU_DRIVER_GET_VERSION;\n\n//\n// Device Management.\n//\n\ntypedef\n_Check_return_\nCU_RESULT\n(CU_DEVICE_GET)(\n    _Outptr_result_maybenull_ PCU_DEVICE Device,\n    _In_opt_ LONG Ordinal\n    );\ntypedef CU_DEVICE_GET *PCU_DEVICE_GET;\n\ntypedef\n_Check_return_\nCU_RESULT\n(CU_DEVICE_GET_COUNT)(\n    _Out_ PLONG Count\n    );\ntypedef CU_DEVICE_GET_COUNT *PCU_DEVICE_GET_COUNT;\n\ntypedef\n_Check_return_\nCU_RESULT\n(CU_DEVICE_GET_NAME)(\n    _Out_writes_z_(SizeOfNameBufferInBytes) PCHAR NameBuffer,\n    _In_ LONG SizeOfNameBufferInBytes,\n    _In_ CU_DEVICE Device\n    );\ntypedef CU_DEVICE_GET_NAME *PCU_DEVICE_GET_NAME;\n\ntypedef\n_Check_return_\nCU_RESULT\n(CU_DEVICE_GET_TOTAL_MEMORY)(\n    _Out_ PSIZE_T TotalMemoryInBytes,\n    _In_ CU_DEVICE Device\n    );\ntypedef CU_DEVICE_GET_TOTAL_MEMORY *PCU_DEVICE_GET_TOTAL_MEMORY;\n\ntypedef\n_Check_return_\nCU_RESULT\n(CU_DEVICE_COMPUTE_CAPABILITY)(\n    _Out_ PLONG Major,\n    _Out_ PLONG Minor,\n    _In_ CU_DEVICE Device\n    );\ntypedef CU_DEVICE_COMPUTE_CAPABILITY *PCU_DEVICE_COMPUTE_CAPABILITY;\n\ntypedef\n_Check_return_\nCU_RESULT\n(CU_DEVICE_GET_ATTRIBUTE)(\n    _Outptr_result_maybenull_ PLONG AttributeValuePointer,\n    _In_ CU_DEVICE_ATTRIBUTE Attribute,\n    _In_ CU_DEVICE Device\n    );\ntypedef CU_DEVICE_GET_ATTRIBUTE *PCU_DEVICE_GET_ATTRIBUTE;\n\n//\n// Context Management.\n//\n\ntypedef\n_Check_return_\nCU_RESULT\n(CU_CTX_CREATE)(\n    _Outptr_result_maybenull_ PPCU_CONTEXT ContextPointer,\n    _In_opt_ CU_CTX_CREATE_FLAGS Flags,\n    _In_ CU_DEVICE Device\n    );\ntypedef CU_CTX_CREATE *PCU_CTX_CREATE;\n\ntypedef\n_Check_return_\nCU_RESULT\n(CU_CTX_DESTROY)(\n    _In_ _Post_invalid_ PCU_CONTEXT Context\n    );\ntypedef CU_CTX_DESTROY *PCU_CTX_DESTROY;\n\ntypedef\n_Check_return_\nCU_RESULT\n(CU_CTX_PUSH_CURRENT)(\n    _In_ PCU_CONTEXT Context\n    );\ntypedef CU_CTX_PUSH_CURRENT *PCU_CTX_PUSH_CURRENT;\n\ntypedef\n_Check_return_\nCU_RESULT\n(CU_CTX_POP_CURRENT)(\n    _Outptr_result_maybenull_ PPCU_CONTEXT ContextPointer\n    );\ntypedef CU_CTX_POP_CURRENT *PCU_CTX_POP_CURRENT;\n\ntypedef\n_Check_return_\nCU_RESULT\n(CU_CTX_SET_CURRENT)(\n    _In_ PCU_CONTEXT Context\n    );\ntypedef CU_CTX_SET_CURRENT *PCU_CTX_SET_CURRENT;\n\ntypedef\n_Check_return_\nCU_RESULT\n(CU_CTX_GET_CURRENT)(\n    _Outptr_result_maybenull_ PPCU_CONTEXT ContextPointer\n    );\ntypedef CU_CTX_GET_CURRENT *PCU_CTX_GET_CURRENT;\n\ntypedef\n_Check_return_\nCU_RESULT\n(CU_CTX_GET_DEVICE)(\n    _Outptr_result_maybenull_ PPCU_DEVICE pDevice\n    );\ntypedef CU_CTX_GET_DEVICE *PCU_CTX_GET_DEVICE;\n\ntypedef\n_Check_return_\nCU_RESULT\n(CU_CTX_SYNCHRONIZE)(\n    VOID\n    );\ntypedef CU_CTX_SYNCHRONIZE *PCU_CTX_SYNCHRONIZE;\n\ntypedef\n_Check_return_\nCU_RESULT\n(CU_CTX_GET_STREAM_PRIORITY_RANGE)(\n    _Out_ PULONG LeastPriority,\n    _Out_ PULONG GreatestPriority\n    );\ntypedef CU_CTX_GET_STREAM_PRIORITY_RANGE *PCU_CTX_GET_STREAM_PRIORITY_RANGE;\n\n//\n// Module Management.\n//\n\ntypedef\n_Check_return_\nCU_RESULT\n(CU_MODULE_LOAD)(\n    _Outptr_result_maybenull_ PPCU_MODULE ModulePointer,\n    _In_ PCSZ Path\n    );\ntypedef CU_MODULE_LOAD *PCU_MODULE_LOAD;\n\ntypedef\n_Check_return_\nCU_RESULT\n(CU_MODULE_UNLOAD)(\n    _In_ _Post_invalid_ PCU_MODULE Module\n    );\ntypedef CU_MODULE_UNLOAD *PCU_MODULE_UNLOAD;\n\ntypedef\n_Check_return_\nCU_RESULT\n(CU_MODULE_LOAD_DATA_EX)(\n    _Outptr_result_maybenull_ PPCU_MODULE ModulePointer,\n    _In_z_ PCHAR Image,\n    _In_ LONG NumberOfOptions,\n    _In_reads_(NumberOfOptions) PCU_JIT_OPTION Options,\n    _Out_writes_(NumberOfOptions) PPVOID OptionValuesPointer\n    );\ntypedef CU_MODULE_LOAD_DATA_EX *PCU_MODULE_LOAD_DATA_EX;\n\ntypedef\n_Check_return_\nCU_RESULT\n(CU_MODULE_GET_FUNCTION)(\n    _Outptr_result_maybenull_ PPCU_FUNCTION FunctionPointer,\n    _In_ PCU_MODULE Module,\n    _In_ PCSZ FunctioName\n    );\ntypedef CU_MODULE_GET_FUNCTION *PCU_MODULE_GET_FUNCTION;\n\ntypedef\n_Check_return_\nCU_RESULT\n(CU_MODULE_GET_GLOBAL)(\n    _Outptr_result_maybenull_ PPCU_DEVICE_POINTER DevicePtrPointer,\n    _Outptr_result_maybenull_ PSIZE_T SizeInBytes,\n    _In_ PCU_MODULE Module,\n    _In_ PCSZ Name\n    );\ntypedef CU_MODULE_GET_GLOBAL *PCU_MODULE_GET_GLOBAL;\n\n//\n// Stream Management.\n//\n\ntypedef\n_Check_return_\nCU_RESULT\n(CU_STREAM_CREATE)(\n    _Outptr_result_maybenull_ PPCU_STREAM StreamPointer,\n    _In_opt_ CU_STREAM_FLAGS Flags\n    );\ntypedef CU_STREAM_CREATE *PCU_STREAM_CREATE;\n\ntypedef\n_Check_return_\nCU_RESULT\n(CU_STREAM_CREATE_WITH_PRIORITY)(\n    _Outptr_result_maybenull_ PPCU_STREAM StreamPointer,\n    _In_opt_ CU_STREAM_FLAGS Flags,\n    _In_opt_ ULONG Priority\n    );\ntypedef CU_STREAM_CREATE_WITH_PRIORITY *PCU_STREAM_CREATE_WITH_PRIORITY;\n\ntypedef\n_Check_return_\nCU_RESULT\n(CU_STREAM_DESTROY)(\n    _In_ _Post_invalid_ PCU_STREAM Stream\n    );\ntypedef CU_STREAM_DESTROY *PCU_STREAM_DESTROY;\n\ntypedef\n_Check_return_\nCU_RESULT\n(CU_STREAM_QUERY)(\n    _In_ PCU_STREAM Stream\n    );\ntypedef CU_STREAM_QUERY *PCU_STREAM_QUERY;\n\ntypedef\n_Check_return_\nCU_RESULT\n(CU_STREAM_SYNCHRONIZE)(\n    _In_ PCU_STREAM Stream\n    );\ntypedef CU_STREAM_SYNCHRONIZE *PCU_STREAM_SYNCHRONIZE;\n\ntypedef\n_Check_return_\nCU_RESULT\n(CALLBACK CU_STREAM_CALLBACK)(\n    _In_opt_ PCU_STREAM Stream,\n    _In_opt_ CU_RESULT Status,\n    _In_opt_ PVOID UserData\n    );\ntypedef CU_STREAM_CALLBACK *PCU_STREAM_CALLBACK;\n\ntypedef\n_Check_return_\nCU_RESULT\n(CU_STREAM_ADD_CALLBACK)(\n    _In_ PCU_STREAM Stream,\n    _In_ PCU_STREAM_CALLBACK Callback,\n    _In_opt_ PVOID UserData,\n    _In_opt_ ULONG Flags\n    );\ntypedef CU_STREAM_ADD_CALLBACK *PCU_STREAM_ADD_CALLBACK;\n\ntypedef\n_Check_return_\nCU_RESULT\n(CU_STREAM_ATTACH_MEM_ASYNC)(\n    _In_ PCU_STREAM Stream,\n    _In_ PCU_DEVICE_POINTER Address,\n    _In_opt_ _Pre_ _Field_range_(==, 0) SIZE_T Length,\n    _In_opt_ CU_MEM_ATTACH_FLAGS Flags\n    );\ntypedef CU_STREAM_ATTACH_MEM_ASYNC *PCU_STREAM_ATTACH_MEM_ASYNC;\n\ntypedef\n_Check_return_\nCU_RESULT\n(CU_STREAM_WAIT_EVENT)(\n    _In_ PCU_STREAM Stream,\n    _In_ PCU_EVENT Event,\n    _In_opt_ ULONG Unused\n    );\ntypedef CU_STREAM_WAIT_EVENT *PCU_STREAM_WAIT_EVENT;\n\ntypedef\n_Check_return_\nCU_RESULT\n(CU_STREAM_WAIT_VALUE_32)(\n    _In_ PCU_STREAM Stream,\n    _In_ PCU_DEVICE_POINTER Address,\n    _In_opt_ ULONG Value,\n    _In_opt_ CU_STREAM_WAIT_VALUE Flags\n    );\ntypedef CU_STREAM_WAIT_VALUE_32 *PCU_STREAM_WAIT_VALUE_32;\n\ntypedef\n_Check_return_\nCU_RESULT\n(CU_STREAM_WRITE_VALUE_32)(\n    _In_ PCU_STREAM Stream,\n    _In_ PCU_DEVICE_POINTER Address,\n    _In_opt_ ULONG Value,\n    _In_opt_ CU_STREAM_WRITE_VALUE Flags\n    );\ntypedef CU_STREAM_WRITE_VALUE_32 *PCU_STREAM_WRITE_VALUE_32;\n\ntypedef\n_Check_return_\nCU_RESULT\n(CU_STREAM_BATCH_MEM_OP)(\n    _In_ PCU_STREAM Stream,\n    _In_ ULONG Count,\n    _In_reads_(Count) PCU_STREAM_BATCH_MEM_OP_PARAMS Params,\n    _In_opt_ ULONG Flags\n    );\ntypedef CU_STREAM_BATCH_MEM_OP *PCU_STREAM_BATCH_MEM_OP;\n\n//\n// Event Management.\n//\n\ntypedef\n_Check_return_\nCU_RESULT\n(CU_EVENT_CREATE)(\n    _Outptr_result_maybenull_ PPCU_EVENT EventPointer,\n    _In_opt_ CU_EVENT_FLAGS Flags\n    );\ntypedef CU_EVENT_CREATE *PCU_EVENT_CREATE;\n\ntypedef\n_Check_return_\nCU_RESULT\n(CU_EVENT_DESTROY)(\n    _In_ _Post_invalid_ PCU_EVENT Event\n    );\ntypedef CU_EVENT_DESTROY *PCU_EVENT_DESTROY;\n\ntypedef\n_Check_return_\nCU_RESULT\n(CU_EVENT_ELAPSED_TIME)(\n    _Outptr_ PFLOAT Milliseconds,\n    _In_ PCU_EVENT StartEvent,\n    _In_ PCU_EVENT EndEvent\n    );\ntypedef CU_EVENT_ELAPSED_TIME *PCU_EVENT_ELAPSED_TIME;\n\ntypedef\n_Check_return_\nCU_RESULT\n(CU_EVENT_QUERY)(\n    _In_ PCU_EVENT Event\n    );\ntypedef CU_EVENT_QUERY *PCU_EVENT_QUERY;\n\ntypedef\n_Check_return_\nCU_RESULT\n(CU_EVENT_RECORD)(\n    _In_ PCU_EVENT Event,\n    _In_ PCU_STREAM Stream\n    );\ntypedef CU_EVENT_RECORD *PCU_EVENT_RECORD;\n\ntypedef\n_Check_return_\nCU_RESULT\n(CU_EVENT_SYNCHRONIZE)(\n    _In_ PCU_EVENT Event\n    );\ntypedef CU_EVENT_SYNCHRONIZE *PCU_EVENT_SYNCHRONIZE;\n\n//\n// Memory Management.\n//\n\ntypedef\n_Check_return_\nCU_RESULT\n(CU_MEM_ALLOC)(\n    _Outptr_result_maybenull_ PPCU_DEVICE_POINTER pDevicePointer,\n    _In_ SIZE_T SizeInBytes\n    );\ntypedef CU_MEM_ALLOC *PCU_MEM_ALLOC;\n\ntypedef\n_Check_return_\nCU_RESULT\n(CU_MEM_FREE)(\n    _In_ _Post_invalid_ PCU_DEVICE_POINTER DevicePointer\n    );\ntypedef CU_MEM_FREE *PCU_MEM_FREE;\n\ntypedef\n_Check_return_\nCU_RESULT\n(CU_MEM_HOST_ALLOC)(\n    _Outptr_result_maybenull_ PPVOID pHostPointer,\n    _In_ SIZE_T SizeInBytes,\n    _In_opt_ CU_MEM_HOST_ALLOC_FLAGS Flags\n    );\ntypedef CU_MEM_HOST_ALLOC *PCU_MEM_HOST_ALLOC;\n\ntypedef\n_Check_return_\nCU_RESULT\n(CU_MEM_PREFETCH_ASYNC)(\n    _In_ PCU_DEVICE_POINTER DevicePointer,\n    _In_ SIZE_T Count,\n    _In_ CU_DEVICE DestDevice,\n    _In_ PCU_STREAM Stream\n    );\ntypedef CU_MEM_PREFETCH_ASYNC *PCU_MEM_PREFETCH_ASYNC;\n\ntypedef\n_Check_return_\nCU_RESULT\n(CU_MEM_HOST_GET_DEVICE_POINTER)(\n    _Outptr_result_maybenull_ PPCU_DEVICE_POINTER pDevicePointer,\n    _In_ PVOID HostPointer,\n    _In_ LONG Unused\n    );\ntypedef CU_MEM_HOST_GET_DEVICE_POINTER *PCU_MEM_HOST_GET_DEVICE_POINTER;\n\ntypedef\n_Check_return_\nCU_RESULT\n(CU_MEM_HOST_REGISTER)(\n    _In_ PVOID HostPointer,\n    _In_ SIZE_T SizeInBytes,\n    _In_ CU_MEM_HOST_REGISTER_FLAGS Flags\n    );\ntypedef CU_MEM_HOST_REGISTER *PCU_MEM_HOST_REGISTER;\n\ntypedef\n_Check_return_\nCU_RESULT\n(CU_MEM_HOST_UNREGISTER)(\n    _In_ PVOID HostPointer\n    );\ntypedef CU_MEM_HOST_UNREGISTER *PCU_MEM_HOST_UNREGISTER;\n\ntypedef\n_Check_return_\nCU_RESULT\n(CU_MEM_FREE_HOST)(\n    _In_ _Post_invalid_ PVOID HostPointer\n    );\ntypedef CU_MEM_FREE_HOST *PCU_MEM_FREE_HOST;\n\n//\n// Memcpy Functions.\n//\n\ntypedef\n_Check_return_\nCU_RESULT\n(CU_MEMCPY_HOST_TO_DEVICE)(\n    _In_ PCU_DEVICE_POINTER DestDevicePointer,\n    _In_reads_bytes_(ByteCount) PCVOID SourceHostPointer,\n    _In_ SIZE_T ByteCount\n    );\ntypedef CU_MEMCPY_HOST_TO_DEVICE *PCU_MEMCPY_HOST_TO_DEVICE;\n\ntypedef\n_Check_return_\nCU_RESULT\n(CU_MEMCPY_DEVICE_TO_HOST)(\n    _Out_writes_(ByteCount) PVOID DestHostPointer,\n    _In_ PCU_DEVICE_POINTER SourceDevicePointer,\n    _In_ SIZE_T ByteCount\n    );\ntypedef CU_MEMCPY_DEVICE_TO_HOST *PCU_MEMCPY_DEVICE_TO_HOST;\n\ntypedef\n_Check_return_\nCU_RESULT\n(CU_MEMCPY_HOST_TO_DEVICE_ASYNC)(\n    _In_ PCU_DEVICE_POINTER DestDevicePointer,\n    _In_reads_bytes_(ByteCount) PCVOID SourceHostPointer,\n    _In_ SIZE_T ByteCount,\n    _In_ PCU_STREAM Stream\n    );\ntypedef CU_MEMCPY_HOST_TO_DEVICE_ASYNC *PCU_MEMCPY_HOST_TO_DEVICE_ASYNC;\n\ntypedef\n_Check_return_\nCU_RESULT\n(CU_MEMCPY_DEVICE_TO_HOST_ASYNC)(\n    _Out_writes_bytes_(ByteCount) PVOID DestHostPointer,\n    _In_ PCU_DEVICE_POINTER SourceDevicePointer,\n    _In_ SIZE_T ByteCount,\n    _In_ PCU_STREAM Stream\n    );\ntypedef CU_MEMCPY_DEVICE_TO_HOST_ASYNC *PCU_MEMCPY_DEVICE_TO_HOST_ASYNC;\n\n//\n// Functions.\n//\n\ntypedef\n_Check_return_\nCU_RESULT\n(CU_LAUNCH_KERNEL)(\n    _In_ PCU_FUNCTION Function,\n    _In_ ULONG GridDimX,\n    _In_ ULONG GridDimY,\n    _In_ ULONG GridDimZ,\n    _In_ ULONG BlockDimX,\n    _In_ ULONG BlockDimY,\n    _In_ ULONG BlockDimZ,\n    _In_ ULONG SharedMemoryInBytes,\n    _In_ PCU_STREAM Stream,\n    _In_ PPVOID KernelParameters,\n    _In_ PPVOID Extra\n    );\ntypedef CU_LAUNCH_KERNEL *PCU_LAUNCH_KERNEL;\n\n//\n// Define function pointer head macro.\n//\n\n#define CU_FUNCTIONS_HEAD                                        \\\n    PCU_INIT Init;                                               \\\n    PCU_GET_ERROR_NAME GetErrorName;                             \\\n    PCU_GET_ERROR_STRING GetErrorString;                         \\\n    PCU_DEVICE_GET DeviceGet;                                    \\\n    PCU_DEVICE_GET_COUNT DeviceGetCount;                         \\\n    PCU_DEVICE_GET_NAME DeviceGetName;                           \\\n    PCU_DEVICE_GET_TOTAL_MEMORY DeviceGetTotalMem;               \\\n    PCU_DEVICE_COMPUTE_CAPABILITY DeviceComputeCapability;       \\\n    PCU_DEVICE_GET_ATTRIBUTE DeviceGetAttribute;                 \\\n    PCU_CTX_CREATE CtxCreate;                                    \\\n    PCU_CTX_DESTROY CtxDestroy;                                  \\\n    PCU_CTX_PUSH_CURRENT CtxPushCurrent;                         \\\n    PCU_CTX_POP_CURRENT CtxPopCurrent;                           \\\n    PCU_CTX_SET_CURRENT CtxSetCurrent;                           \\\n    PCU_CTX_GET_CURRENT CtxGetCurrent;                           \\\n    PCU_CTX_GET_DEVICE CtxGetDevice;                             \\\n    PCU_CTX_SYNCHRONIZE CtxSynchronize;                          \\\n    PCU_CTX_GET_STREAM_PRIORITY_RANGE CtxGetStreamPriorityRange; \\\n    PCU_MODULE_LOAD ModuleLoad;                                  \\\n    PCU_MODULE_UNLOAD ModuleUnload;                              \\\n    PCU_MODULE_LOAD_DATA_EX ModuleLoadDataEx;                    \\\n    PCU_MODULE_GET_FUNCTION ModuleGetFunction;                   \\\n    PCU_MODULE_GET_GLOBAL ModuleGetGlobal;                       \\\n    PCU_STREAM_CREATE StreamCreate;                              \\\n    PCU_STREAM_CREATE_WITH_PRIORITY StreamCreateWithPriority;    \\\n    PCU_STREAM_DESTROY StreamDestroy;                            \\\n    PCU_STREAM_QUERY StreamQuery;                                \\\n    PCU_STREAM_SYNCHRONIZE StreamSynchronize;                    \\\n    PCU_STREAM_ADD_CALLBACK StreamAddCallback;                   \\\n    PCU_STREAM_ATTACH_MEM_ASYNC StreamAttachMemAsync;            \\\n    PCU_STREAM_WAIT_EVENT StreamWaitEvent;                       \\\n    PCU_STREAM_WAIT_VALUE_32 StreamWaitValue32;                  \\\n    PCU_STREAM_WRITE_VALUE_32 StreamWriteValue32;                \\\n    PCU_STREAM_BATCH_MEM_OP StreamBatchMemOp;                    \\\n    PCU_EVENT_CREATE EventCreate;                                \\\n    PCU_EVENT_DESTROY EventDestroy;                              \\\n    PCU_EVENT_ELAPSED_TIME EventElapsedTime;                     \\\n    PCU_EVENT_QUERY EventQuery;                                  \\\n    PCU_EVENT_RECORD EventRecord;                                \\\n    PCU_EVENT_SYNCHRONIZE EventSynchronize;                      \\\n    PCU_MEM_ALLOC MemAlloc;                                      \\\n    PCU_MEM_FREE MemFree;                                        \\\n    PCU_MEM_HOST_ALLOC MemHostAlloc;                             \\\n    PCU_MEM_PREFETCH_ASYNC MemPrefetchAsync;                     \\\n    PCU_MEM_HOST_GET_DEVICE_POINTER MemHostGetDevicePointer;     \\\n    PCU_MEM_HOST_REGISTER MemHostRegister;                       \\\n    PCU_MEM_HOST_UNREGISTER MemHostUnregister;                   \\\n    PCU_MEM_FREE_HOST MemFreeHost;                               \\\n    PCU_MEMCPY_HOST_TO_DEVICE MemcpyHtoD;                        \\\n    PCU_MEMCPY_DEVICE_TO_HOST MemcpyDtoH;                        \\\n    PCU_MEMCPY_HOST_TO_DEVICE_ASYNC MemcpyHtoDAsync;             \\\n    PCU_MEMCPY_DEVICE_TO_HOST_ASYNC MemcpyDtoHAsync;             \\\n    PCU_LAUNCH_KERNEL LaunchKernel;\n\ntypedef struct _CU_FUNCTIONS {\n    CU_FUNCTIONS_HEAD\n} CU_FUNCTIONS;\ntypedef CU_FUNCTIONS *PCU_FUNCTIONS;\n\n//\n// Define the CU structure that encapsulates all CUDA Driver functionality.\n//\n\ntypedef union _CU_FLAGS {\n    struct _Struct_size_bytes_(sizeof(ULONG)) {\n        ULONG Unused:32;\n    };\n    LONG AsLong;\n    ULONG AsULong;\n} CU_FLAGS;\nC_ASSERT(sizeof(CU_FLAGS) == sizeof(ULONG));\ntypedef CU_FLAGS *PCU_FLAGS;\n\ntypedef struct _Struct_size_bytes_(SizeOfStruct) _CU {\n\n    //\n    // Size of the structure, in bytes.\n    //\n\n    _Field_range_(==, sizeof(struct _CU)) ULONG SizeOfStruct;\n\n    //\n    // Flags.\n    //\n\n    CU_FLAGS Flags;\n\n    //\n    // Number of function pointers.\n    //\n\n    ULONG NumberOfFunctions;\n\n    //\n    // Pad out to 8 bytes.\n    //\n\n    ULONG Unused;\n\n    //\n    // Function pointers.\n    //\n\n    union {\n        CU_FUNCTIONS Functions;\n        struct {\n            CU_FUNCTIONS_HEAD\n        };\n    };\n\n} CU;\ntypedef CU *PCU;\n\nFORCEINLINE\nCU_RESULT\nLoadCuDeviceAttributes(\n    _In_ PCU Cu,\n    _Inout_ PCU_DEVICE_ATTRIBUTES AttributesPointer,\n    _In_ CU_DEVICE Device\n    )\n{\n    LONG Index;\n    LONG NumberOfAttributes;\n    PLONG Attribute;\n    CU_RESULT Result;\n\n    ZeroStructPointer(AttributesPointer);\n\n    Attribute = (PLONG)AttributesPointer;\n    NumberOfAttributes = sizeof(*AttributesPointer) / sizeof(ULONG);\n\n    for (Index = 0; Index < NumberOfAttributes; Index++) {\n        Result = Cu->DeviceGetAttribute(Attribute, Index+1, Device);\n        if (CU_FAILED(Result)) {\n            return Result;\n        }\n        Attribute++;\n    }\n\n    return CUDA_SUCCESS;\n}\n\n// vim:set ts=8 sw=4 sts=4 tw=80 expandtab                                     :\n\n", "comment_ratio": 0.1921487603305785}
{"lang": "c", "code": "//\n// Created by liuyubobobo on 8/08/19.\n//\n\n#ifndef INC_03_IMPLEMENTATION_OF_DIJKSTRA_DIJKSTRA_H\n#define INC_03_IMPLEMENTATION_OF_DIJKSTRA_DIJKSTRA_H\n\n#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include \"Edge.h\"\n\nusing namespace std;\n\n// Dijkstra\u7b97\u6cd5\u6c42\u6700\u77ed\u8def\u5f84\ntemplate<typename Graph>\nclass Dijkstra{\n\nprivate:\n    Graph &G;                   // \u56fe\u7684\u5f15\u7528\n    int s;                      // \u8d77\u59cb\u70b9\n    int *distTo;                // distTo[i]\u5b58\u50a8\u4ece\u8d77\u59cb\u70b9s\u5230i\u7684\u6700\u77ed\u8def\u5f84\u957f\u5ea6\n    bool *marked;               // \u6807\u8bb0\u6570\u7ec4, \u5728\u7b97\u6cd5\u8fd0\u884c\u8fc7\u7a0b\u4e2d\u6807\u8bb0\u8282\u70b9i\u662f\u5426\u88ab\u8bbf\u95ee\n    vector<Edge<int>*> from;    // from[i]\u8bb0\u5f55\u6700\u77ed\u8def\u5f84\u4e2d, \u5230\u8fbei\u70b9\u7684\u8fb9\u662f\u54ea\u4e00\u6761\n                                // \u53ef\u4ee5\u7528\u6765\u6062\u590d\u6574\u4e2a\u6700\u77ed\u8def\u5f84\n\npublic:\n    // \u6784\u9020\u51fd\u6570, \u4f7f\u7528Dijkstra\u7b97\u6cd5\u6c42\u6700\u77ed\u8def\u5f84\n    Dijkstra(Graph &graph, int s):G(graph){\n\n        // \u7b97\u6cd5\u521d\u59cb\u5316\n        assert( s >= 0 && s < G.V() );\n        this->s = s;\n        distTo = new int[G.V()];\n        marked = new bool[G.V()];\n        for( int i = 0 ; i < G.V() ; i ++ ){\n            distTo[i] = INT_MAX; // \u6ce8\u610f\uff1a\u521d\u59cb\u5316\uff0c\u6240\u6709\u7684\u8ddd\u79bb\u4e3a\u65e0\u7a77\n            marked[i] = false;\n            from.push_back(NULL);\n        }\n\n        // \u4f7f\u7528\u4f18\u5148\u961f\u5217\uff0c\u5806\u9876\u5143\u7d20\u4fdd\u6301\u5f53\u524d\u627e\u5230\u7684\uff0c\u8ddd\u79bb\u6e90\u70b9\u6700\u8fd1\u7684\u9876\u70b9\n        auto comp = [this](int a, int b) { return this->distTo[a] > this->distTo[b]; };\n        priority_queue<int, vector<int>, decltype(comp)> pq(comp);\n\n        // \u5bf9\u4e8e\u8d77\u59cb\u70b9s\u8fdb\u884c\u521d\u59cb\u5316\n        distTo[s] = 0;\n        from[s] = new Edge<int>(s, s, 0);\n        pq.push(0);\n        while(!pq.empty()){\n            int v = pq.top();\n            pq.pop();\n\n            // \u4f7f\u7528\u6700\u5c0f\u5806\u5b9e\u73b0\uff0c\u8fd9\u4e2a\u5224\u65ad\u5f88\u91cd\u8981\u3002\u5982\u679c v \u5df2\u7ecf\u88ab\u5904\u7406\u4e86\uff0c\u5219\u76f4\u63a5 continue\n            if(marked[v]) continue;\n\n            // distTo[v]\u5c31\u662fs\u5230v\u7684\u6700\u77ed\u8ddd\u79bb\n            marked[v] = true;\n\n            // \u5bf9v\u7684\u6240\u6709\u76f8\u90bb\u8282\u70b9\u8fdb\u884c\u66f4\u65b0\n            typename Graph::adjIterator adj(G, v);\n            for(Edge<int>* e = adj.begin() ; !adj.end() ; e = adj.next() ){\n                int w = e->other(v);\n                // \u5982\u679c\u4eces\u70b9\u5230w\u70b9\u7684\u6700\u77ed\u8def\u5f84\u8fd8\u6ca1\u6709\u627e\u5230\n                if( !marked[w] ){\n                    // \u5982\u679cw\u70b9\u4ee5\u524d\u6ca1\u6709\u8bbf\u95ee\u8fc7,\n                    // \u6216\u8005\u8bbf\u95ee\u8fc7, \u4f46\u662f\u901a\u8fc7\u5f53\u524d\u7684v\u70b9\u5230w\u70b9\u8ddd\u79bb\u66f4\u77ed, \u5219\u8fdb\u884c\u66f4\u65b0\n                    if( from[w] == NULL || distTo[v] + e->wt() < distTo[w] ){\n                        distTo[w] = distTo[v] + e->wt();\n                        from[w] = e;\n\n                        // \u6ce8\u610f\uff0c\u6211\u4eec\u4f7f\u7528\u6700\u5c0f\u5806\uff0c\u6539\u53d8distTo\u4ee5\u540e\uff0c\u5e76\u4e0d\u80fd\u6539\u53d8\u4f18\u5148\u961f\u5217\u4e2d\u7684\u5143\u7d20\u6392\u5217\n                        // \u89e3\u51b3\u65b9\u6848\u662f\uff0c\u5c06w\u91cd\u590d\u538b\u8fdb\u4f18\u5148\u961f\u5217\u3002\u6b64\u65f6\uff0cw\u5728\u4f18\u5148\u961f\u5217\u4e2d\u7684\u4f4d\u7f6e\uff0c\u4f1a\u6309\u7167\u65b0\u66f4\u65b0\u7684 distTo \u8ba1\u7b97\n                        // \u914d\u5408 56 \u884c\u7684\u5224\u65ad\uff0c\u4fdd\u8bc1\u4f18\u5148\u961f\u5217\u4e2d\u867d\u7136\u6709\u91cd\u590d\u5143\u7d20\uff0c\u4f46\u662f\u4e0d\u4f1a\u88ab\u91cd\u590d\u5904\u7406\n                        pq.push(w);\n                    }\n                }\n            }\n        }\n    }\n\n    // \u6790\u6784\u51fd\u6570\n    ~Dijkstra(){\n        delete[] distTo;\n        delete[] marked;\n        delete from[0];\n    }\n\n    // \u8fd4\u56de\u4eces\u70b9\u5230w\u70b9\u7684\u6700\u77ed\u8def\u5f84\u957f\u5ea6\n    int shortestPathTo( int w ){\n        assert( w >= 0 && w < G.V() );\n        assert( hasPathTo(w) );\n        return distTo[w];\n    }\n\n    // \u5224\u65ad\u4eces\u70b9\u5230w\u70b9\u662f\u5426\u8054\u901a\n    bool hasPathTo( int w ){\n        assert( w >= 0 && w < G.V() );\n        return marked[w];\n    }\n\n    // \u5bfb\u627e\u4eces\u5230w\u7684\u6700\u77ed\u8def\u5f84, \u5c06\u6574\u4e2a\u8def\u5f84\u7ecf\u8fc7\u7684\u8fb9\u5b58\u653e\u5728vec\u4e2d\n    void shortestPath( int w, vector<Edge<int>> &vec ){\n\n        assert( w >= 0 && w < G.V() );\n        assert( hasPathTo(w) );\n\n        // \u901a\u8fc7from\u6570\u7ec4\u9006\u5411\u67e5\u627e\u5230\u4eces\u5230w\u7684\u8def\u5f84, \u5b58\u653e\u5230\u6808\u4e2d\n        stack<Edge<int>*> s;\n        Edge<int> *e = from[w];\n        while( e->v() != this->s ){\n            s.push(e);\n            e = from[e->v()];\n        }\n        s.push(e);\n\n        // \u4ece\u6808\u4e2d\u4f9d\u6b21\u53d6\u51fa\u5143\u7d20, \u83b7\u5f97\u987a\u5e8f\u7684\u4eces\u5230w\u7684\u8def\u5f84\n        while( !s.empty() ){\n            e = s.top();\n            vec.push_back( *e );\n            s.pop();\n        }\n    }\n\n    // \u6253\u5370\u51fa\u4eces\u70b9\u5230w\u70b9\u7684\u8def\u5f84\n    void showPath(int w){\n\n        assert( w >= 0 && w < G.V() );\n        assert( hasPathTo(w) );\n\n        vector<Edge<int>> vec;\n        shortestPath(w, vec);\n        for( int i = 0 ; i < vec.size() ; i ++ ){\n            cout<<vec[i].v()<<\" -> \";\n            if( i == vec.size()-1 )\n                cout<<vec[i].w()<<endl;\n        }\n    }\n};\n\n#endif //INC_03_IMPLEMENTATION_OF_DIJKSTRA_DIJKSTRA_H\n\n", "comment_ratio": 0.22377622377622378}
{"lang": "c", "code": "#ifndef __http2_adaptor_h__\n#define __http2_adaptor_h__ 1\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n#include \"adaptors/http_common.h\"\n#include \"server_private.h\"\n\n#include \"qpid/dispatch/alloc.h\"\n#include \"qpid/dispatch/atomic.h\"\n#include \"qpid/dispatch/compose.h\"\n#include \"qpid/dispatch/ctools.h\"\n#include \"qpid/dispatch/log.h\"\n#include \"qpid/dispatch/protocol_adaptor.h\"\n#include \"qpid/dispatch/server.h\"\n#include \"qpid/dispatch/threading.h\"\n\n#include <nghttp2/nghttp2.h>\n#include <time.h>\n\nsize_t QD_HTTP2_BUFFER_SIZE = 16384;\nsize_t NUM_QD_BUFFERS_IN_ONE_HTTP2_BUFFER = 32;\nsize_t MAX_BUFFERS = 16;\nsize_t HTTP2_DATA_FRAME_HEADER_LENGTH = 9;\n\n\ntypedef struct qdr_http2_stream_data_t  qdr_http2_stream_data_t;\ntypedef struct qdr_http2_connection_t   qdr_http2_connection_t;\ntypedef struct qd_http2_buffer_t        qd_http2_buffer_t;\n\n/**\n * Stream status\n */\ntypedef enum {\n    QD_STREAM_OPEN,\n    QD_STREAM_HALF_CLOSED,\n    QD_STREAM_FULLY_CLOSED\n} qd_http2_stream_status_t;\n\n\nDEQ_DECLARE(qdr_http2_stream_data_t, qd_http2_stream_data_list_t);\nDEQ_DECLARE(qd_http2_buffer_t,       qd_http2_buffer_list_t);\nDEQ_DECLARE(qdr_http2_connection_t,  qdr_http2_connection_list_t);\n\nstruct qdr_http2_stream_data_t {\n    qdr_http2_connection_t   *conn;\n    void                     *context;\n    char                     *reply_to;\n    char                     *remote_site; //for stats:\n    char                     *method; //for stats, also used in the subject field of AMQP request message.\n    char                     *request_status; //for stats, also used in the subject field of AMQP response message.\n    qdr_delivery_t           *in_dlv;\n    qdr_delivery_t           *out_dlv;\n    uint64_t                  incoming_id;\n    uint64_t                  outgoing_id;\n    uint64_t                  out_dlv_local_disposition;\n    qdr_link_t               *in_link;\n    qdr_link_t               *out_link;\n    qd_message_t             *message;\n    qd_composed_field_t      *app_properties;\n    qd_composed_field_t      *footer_properties;\n    qd_buffer_list_t          body_buffers;\n    qd_message_stream_data_t *curr_stream_data;\n    qd_iterator_t            *curr_stream_data_iter; // points to the data contained in the stream_data/raw_buffers\n    qd_message_stream_data_t *next_stream_data;\n    qd_message_stream_data_t *footer_stream_data;\n    qd_iterator_t            *footer_stream_data_iter;\n    DEQ_LINKS(qdr_http2_stream_data_t);\n\n    qd_message_stream_data_result_t  curr_stream_data_result;\n    qd_message_stream_data_result_t  next_stream_data_result;\n    int                            payload_handled;\n    int                            in_link_credit;   // provided by router\n    int32_t                        stream_id;\n    qd_http2_stream_status_t       status;\n    bool                     entire_footer_arrived;\n    bool                     entire_header_arrived;\n    bool                     out_msg_header_sent;\n    bool                     out_msg_body_sent;\n    bool                     use_footer_properties;\n    bool                     full_payload_handled; // applies to the sending side.\n    bool                     out_msg_has_body;\n    bool                     out_msg_data_flag_eof;\n    bool                     out_msg_has_footer;\n    bool                     out_msg_send_complete; // we use this flag to save the send_complete flag because the delivery and message associated with this stream might have been freed.\n    bool                     disp_updated;   // Has the disposition already been set on the out_dlv\n    bool                     disp_applied;   // Has the disp been applied to the out_dlv. The stream is ready to be freed now.\n    bool                     header_and_props_composed;  // true if the header and properties of the inbound message have already been composed so we don't have to do it again.\n    bool                     stream_force_closed;\n    bool                     in_dlv_decrefed;\n    bool                     out_dlv_decrefed;\n    bool                     body_data_added_to_msg;\n    int                      bytes_in;\n    int                      bytes_out;\n    qd_timestamp_t           start;\n    qd_timestamp_t           stop;\n};\n\nstruct qdr_http2_connection_t {\n    qd_handler_context_t     context;\n    qdr_connection_t        *qdr_conn;\n    pn_raw_connection_t     *pn_raw_conn;\n    pn_raw_buffer_t          read_buffers[4];\n    qd_timer_t              *activate_timer;\n    qd_timer_t              *ping_timer;  // This timer is used to send a ping frame on the egress connection every 4 seconds.\n    qd_http_bridge_config_t *config;\n    qd_server_t             *server;\n    uint64_t                 conn_id;\n    char                     *remote_address;\n    qdr_link_t               *stream_dispatcher;\n    qdr_http2_stream_data_t  *stream_dispatcher_stream_data;\n    uint64_t                  stream_dispatcher_id;\n    nghttp2_data_provider     data_prd;\n    qd_http2_buffer_list_t    granted_read_buffs; //buffers for reading\n    time_t                    prev_ping; // Time the previous PING frame was sent on egress connection.\n    time_t                    last_pn_raw_conn_read;  // The last time a PN_RAW_CONNECTION_READ event was invoked with more than zero bytes on an egress connection.\n    qd_http2_buffer_list_t    buffs;      // Buffers for writing\n    nghttp2_session          *session;    // A pointer to the nghttp2s' session object\n    qd_http2_stream_data_list_t  streams;    // A session can have many streams.\n\n    bool                      connection_established;\n    bool                      grant_initial_buffers;\n    bool                      ingress;\n    bool                      timer_scheduled;\n    bool                      client_magic_sent;\n    bool                      woken_by_ping;\n    bool                      first_pinged;\n    bool                      delete_egress_connections;  // If set to true, the egress qdr_connection_t and qdr_http2_connection_t objects will be deleted\n    bool                      goaway_received;\n    sys_atomic_t \t\t      raw_closed_read;\n    sys_atomic_t \t\t\t  raw_closed_write;\n    bool                      q2_blocked;      // send a connection level WINDOW_UPDATE frame to tell the client to stop sending data.\n    sys_atomic_t              q2_restart;      // signal to resume receive\n    sys_atomic_t              delay_buffer_write;   // if true, buffers will not be written to proton.\n    DEQ_LINKS(qdr_http2_connection_t);\n };\n\nstruct qd_http2_buffer_t {\n    unsigned int  size;     ///< Size of data content\n    unsigned char content[16393];   // 16k max content + 9 bytes for the HTTP2 header, 16384 + 9 = 16393\n    DEQ_LINKS(qd_http2_buffer_t);\n};\n\n\nstatic inline unsigned char *qd_http2_buffer_base(const qd_http2_buffer_t *buf)\n{\n    return (unsigned char*) &buf->content[0];\n}\n\n/**\n * Return a pointer to the first unused byte in the buffer.\n * @param buf A pointer to an allocated buffer\n * @return A pointer to the first free octet in the buffer, the insert point for new data.\n */\nstatic inline unsigned char *qd_http2_buffer_cursor(const qd_http2_buffer_t *buf)\n{\n    return ( (unsigned char*) &(buf->content[0]) ) + buf->size;\n}\n\n/**\n * Return remaining capacity at end of buffer.\n * @param buf A pointer to an allocated buffer\n * @return The number of octets in the buffer's free space, how many octets may be inserted.\n */\nstatic inline size_t qd_http2_buffer_capacity(const qd_http2_buffer_t *buf)\n{\n    return QD_HTTP2_BUFFER_SIZE - buf->size;\n}\n\n/**\n * Return the size of the buffers data content.\n * @param buf A pointer to an allocated buffer\n * @return The number of octets of data in the buffer\n */\nstatic inline size_t qd_http2_buffer_size(const qd_http2_buffer_t *buf)\n{\n    return buf->size;\n}\n\n/**\n * Notify the buffer that octets have been inserted at the buffer's cursor.  This will advance the\n * cursor by len octets.\n *\n * @param buf A pointer to an allocated buffer\n * @param len The number of octets that have been appended to the buffer\n */\nstatic inline void qd_http2_buffer_insert(qd_http2_buffer_t *buf, size_t len)\n{\n    buf->size += len;\n    assert(buf->size <= QD_HTTP2_BUFFER_SIZE + HTTP2_DATA_FRAME_HEADER_LENGTH);\n}\n\nALLOC_DECLARE(qdr_http2_stream_data_t);\nALLOC_DECLARE(qdr_http2_connection_t);\nALLOC_DECLARE(qd_http2_buffer_t);\n\n\n#endif // __http2_adaptor_h__\n\n", "comment_ratio": 0.11627906976744186}
{"lang": "c", "code": "#pragma once\n\n#include \"ModuleManager.h\"\n\nDECLARE_LOG_CATEGORY_EXTERN(LogCrashlytics, Log, All);\n\nclass ICrashlytics : public IModuleInterface\n{\npublic:\n\tstatic inline ICrashlytics& Get()\n\t{\n\t\treturn FModuleManager::LoadModuleChecked< ICrashlytics >(\"Crashlytics\");\n\t}\n\n\tstatic inline bool IsAvailable()\n\t{\n\t\treturn FModuleManager::Get().IsModuleLoaded(\"Crashlytics\");\n\t}\n};\n\n", "comment_ratio": 0.125}
{"lang": "c", "code": "/* This file was generated by syncqt. */\n#ifndef QT_QTLOCATION_VERSION_H\n#define QT_QTLOCATION_VERSION_H\n\n#define QTLOCATION_VERSION_STR \"5.2.2\"\n\n#define QTLOCATION_VERSION 0x050202\n\n#endif // QT_QTLOCATION_VERSION_H\n\n", "comment_ratio": 0.1}
{"lang": "c", "code": "#ifndef _IVW_MODULE_PROGRESSIVEPHOTONMAPPING_DEFINE_H_\n#define _IVW_MODULE_PROGRESSIVEPHOTONMAPPING_DEFINE_H_\n\n#ifdef INVIWO_ALL_DYN_LINK //DYNAMIC\n// If we are building DLL files we must declare dllexport/dllimport\n#ifdef IVW_MODULE_PROGRESSIVEPHOTONMAPPING_EXPORTS\n#ifdef _WIN32\n#define IVW_MODULE_PROGRESSIVEPHOTONMAPPING_API __declspec(dllexport)\n#else //UNIX (GCC)\n#define IVW_MODULE_PROGRESSIVEPHOTONMAPPING_API __attribute__ ((visibility (\"default\")))\n#endif\n#else\n#ifdef _WIN32\n#define IVW_MODULE_PROGRESSIVEPHOTONMAPPING_API __declspec(dllimport)\n#else\n#define IVW_MODULE_PROGRESSIVEPHOTONMAPPING_API\n#endif\n#endif\n#else //STATIC\n#define IVW_MODULE_PROGRESSIVEPHOTONMAPPING_API\n#endif\n\n#endif /* _IVW_MODULE_PROGRESSIVEPHOTONMAPPING_DEFINE_H_ */\n", "comment_ratio": 0.17391304347826086}
{"lang": "c", "code": "#import <AVConference/AVConference-Structs.h>\n#import <libobjc.A.dylib/CannedVideoFrameFeeder.h>\n\n@class AVURLAsset, AVAssetReader, AVAssetTrack, AVAssetReaderTrackOutput, NSString, VideoScaler;\n\n@interface CannedEncodedVideoCapture : NSObject <CannedVideoFrameFeeder> {\n\n\tAVURLAsset* _compressedFileAsset;\n\tAVAssetReader* _assetReader;\n\tAVAssetTrack* _videoTrack;\n\tAVAssetReaderTrackOutput* _readerVideoTrackOutput;\n\tNSString* _movieURLString;\n\tVideoScaler* _videoScaler;\n\tCVPixelBufferPoolRef _pixelBufferPool;\n\tCVPixelBufferPoolRef _rotatedPixelBufferPool;\n\tint _width;\n\tint _height;\n\tint _allFrameCount;\n\tdouble _allFrameRate;\n\tint _frameCount;\n\topaque_pthread_mutex_t _inputMutex;\n\topaque_pthread_mutex_t _attributeMutex;\n\n}\n\n@property (nonatomic,retain) AVURLAsset * compressedFileAsset;                               //@synthesize compressedFileAsset=_compressedFileAsset - In the implementation block\n@property (nonatomic,retain) AVAssetReader * assetReader;                                    //@synthesize assetReader=_assetReader - In the implementation block\n@property (nonatomic,retain) AVAssetTrack * videoTrack;                                      //@synthesize videoTrack=_videoTrack - In the implementation block\n@property (nonatomic,retain) AVAssetReaderTrackOutput * readerVideoTrackOutput;              //@synthesize readerVideoTrackOutput=_readerVideoTrackOutput - In the implementation block\n@property (nonatomic,retain) NSString * movieURLString;                                      //@synthesize movieURLString=_movieURLString - In the implementation block\n@property (nonatomic,retain) VideoScaler * videoScaler;                                      //@synthesize videoScaler=_videoScaler - In the implementation block\n@property (assign,nonatomic) int width;                                                      //@synthesize width=_width - In the implementation block\n@property (assign,nonatomic) int height;                                                     //@synthesize height=_height - In the implementation block\n@property (assign,nonatomic) int allFrameCount;                                              //@synthesize allFrameCount=_allFrameCount - In the implementation block\n@property (assign,nonatomic) double allFrameRate;                                            //@synthesize allFrameRate=_allFrameRate - In the implementation block\n@property (assign,nonatomic) int frameCount;                                                 //@synthesize frameCount=_frameCount - In the implementation block\n@property (readonly) unsigned long long hash; \n@property (readonly) Class superclass; \n@property (copy,readonly) NSString * description; \n@property (copy,readonly) NSString * debugDescription; \n-(int)initialize;\n-(id)initWithPath:(id)arg1 ;\n-(void)setHeight:(int)arg1 ;\n-(int)width;\n-(int)frameCount;\n-(int)height;\n-(void)setFrameCount:(int)arg1 ;\n-(void)dealloc;\n-(void)setWidth:(int)arg1 ;\n-(void)setCompressedFileAsset:(AVURLAsset *)arg1 ;\n-(AVURLAsset *)compressedFileAsset;\n-(void)setAssetReader:(AVAssetReader *)arg1 ;\n-(AVAssetReader *)assetReader;\n-(void)setVideoTrack:(AVAssetTrack *)arg1 ;\n-(AVAssetTrack *)videoTrack;\n-(void)setReaderVideoTrackOutput:(AVAssetReaderTrackOutput *)arg1 ;\n-(AVAssetReaderTrackOutput *)readerVideoTrackOutput;\n-(int)initializeDecoder;\n-(CVBufferRef)createPixelBufferForFrameIndex:(int)arg1 ;\n-(void)getFrameRate:(double*)arg1 frameCount:(int*)arg2 ;\n-(int)setWidth:(int)arg1 height:(int)arg2 ;\n-(NSString *)movieURLString;\n-(void)setMovieURLString:(NSString *)arg1 ;\n-(VideoScaler *)videoScaler;\n-(void)setVideoScaler:(VideoScaler *)arg1 ;\n-(int)allFrameCount;\n-(void)setAllFrameCount:(int)arg1 ;\n-(double)allFrameRate;\n-(void)setAllFrameRate:(double)arg1 ;\n@end\n\n\n", "comment_ratio": 0.1375}
{"lang": "c", "code": "#import \"MMObject.h\"\n\n#import \"PBCoding-Protocol.h\"\n\n@class NSString;\n\n@interface GameSearchRecommendItem : MMObject <PBCoding>\n{\n    unsigned int actionType;\n    NSString *appID;\n    NSString *recommendKey;\n    NSString *desc;\n    NSString *targetUrl;\n}\n\n+ (void)initialize;\n+ (void)PBArrayAdd_targetUrl;\n+ (void)PBArrayAdd_actionType;\n+ (void)PBArrayAdd_desc;\n+ (void)PBArrayAdd_recommendKey;\n+ (void)PBArrayAdd_appID;\n@property(retain, nonatomic) NSString *targetUrl; // @synthesize targetUrl;\n@property(nonatomic) unsigned int actionType; // @synthesize actionType;\n@property(retain, nonatomic) NSString *desc; // @synthesize desc;\n@property(retain, nonatomic) NSString *recommendKey; // @synthesize recommendKey;\n@property(retain, nonatomic) NSString *appID; // @synthesize appID;\n- (void).cxx_destruct;\n- (void)dealloc;\n- (id)getPBPropertyTable;\n\n// Remaining properties\n@property(readonly, copy) NSString *debugDescription;\n@property(readonly, copy) NSString *description;\n@property(readonly) unsigned long long hash;\n@property(readonly) Class superclass;\n\n@end\n\n\n", "comment_ratio": 0.24444444444444444}
{"lang": "c", "code": "#include <stdio.h>\n#include <sys/socket.h>\n#include <stdlib.h>\n#include <netinet/in.h>\n#include <string.h>\n#include<sys/types.h>\n#include<sys/stat.h>\n#include<fcntl.h>\n#include<unistd.h>\n#define PORT 8000\nint main(int argc, char const *argv[])\n{\n    int server_fd, new_socket, valread;\n    struct sockaddr_in address;  \n    int opt = 1;\n    int addrlen = sizeof(address);\n    \n    char *hello = \"Hello from server\";\n\n    // Creating socket file descriptor\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0)  // creates socket, SOCK_STREAM is for TCP. SOCK_DGRAM for UDP\n    {\n        perror(\"socket failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    // This is to lose the pesky \"Address already in use\" error message\n    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT,\n                                                  &opt, sizeof(opt))) // SOL_SOCKET is the socket layer itself\n    {\n        perror(\"setsockopt\");\n        exit(EXIT_FAILURE);\n    }\n    address.sin_family = AF_INET;  // Address family. For IPv6, it's AF_INET6. 29 others exist like AF_UNIX etc. \n    address.sin_addr.s_addr = INADDR_ANY;  // Accept connections from any IP address - listens from all interfaces.\n    address.sin_port = htons( PORT );    // Server port to open. Htons converts to Big Endian - Left to Right. RTL is Little Endian\n\n    // Forcefully attaching socket to the port 8080\n    if (bind(server_fd, (struct sockaddr *)&address,\n                                 sizeof(address))<0)\n    {\n        perror(\"bind failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Port bind is done. You want to wait for incoming connections and handle them in some way.\n    // The process is two step: first you listen(), then you accept()\n    if (listen(server_fd, 3) < 0) // 3 is the maximum size of queue - connections you haven't accepted\n    {\n        perror(\"listen\");\n        exit(EXIT_FAILURE);\n    }\n\n    // returns a brand new socket file descriptor to use for this single accepted connection. Once done, use send and recv\n    if ((new_socket = accept(server_fd, (struct sockaddr *)&address,\n                       (socklen_t*)&addrlen))<0)\n    {\n        perror(\"accept\");\n        exit(EXIT_FAILURE);\n    }\n    // valread = read(new_socket , buffer, 1024);  // read infromation received into the buffer\n    // printf(\"%s\\n\",buffer);\n    // send(new_socket , hello , strlen(hello) , 0 );  // use sendto() and recvfrom() for DGRAM\n    // printf(\"Hello message sent\\n\");\n     \n     while(1)\n     {   char buffer[1000000] = {0};\n        char buffer2[1000000]={0};\n         recv(new_socket,buffer,1024,0);\n         buffer[strlen(buffer)]='\\0';\n         send(new_socket,\"ok\",3,0);\n         if(strcmp(buffer,\"get\")==0)\n         {   //printf(\"NOOB\\n\");\n             while(1)\n             {   \n                 read(new_socket,buffer2,1024);\n                 buffer2[strlen(buffer2)]='\\0';\n                 char name[20];\n                 strcpy(name,buffer2);\n                 //printf(\"%s\\n\",buffer2);\n                 if(strcmp(buffer2,\"end\")==0)\n                 {break;}\n                 int fd =open(buffer2,O_RDONLY);\n                 if(fd<0)\n                 {   if(strcmp(buffer2,\"oki\")!=0)\n                     {printf(\"Error opening file %s\\n\",buffer2);}\n                 send(new_socket,\"Invalid\",8,0);\n                 continue;}\n                 int z=lseek(fd,0,SEEK_END);\n                 lseek(fd,0,SEEK_SET);\n                 char str[20];\n                 sprintf(str,\"%d\",z);\n\n\n                 send(new_socket,str,strlen(str)+1,0);\n                  read(new_socket,buffer2,5);\n                  int n=0;\n                 while(1)\n                 {   //printf(\"rukja\\n\");\n                     int x=read(fd,buffer2,99999);\n                     buffer2[strlen(buffer2)]='\\0';\n                     //printf(\"2\\n\");\n                     if(x==0)\n                     {printf(\"\\n\");send(new_socket,\"end\",4,0);buffer2[0]='\\0';break;}\n                     n+=x;\n                     \n                     long double per=(long double)((long double)n/(long double)z);\n                    char num[]=\"0123456789\";\n             per=per*100;\n            char perc[50];\n            perc[0]='\\r';\n            int a,b,c,d,e;\n            a=per/100,b=((int)(per/10))%10,c=((int)(per))%10;\n            d=((int)(per*10))%10;\n            e=((int)(per*100))%10;\n           // printf(\"%d %d %Lf\",a,b,per);\n              perc[1]=num[a];perc[2]=num[b];perc[3]=num[c];perc[4]='.',perc[5]=num[d],perc[6]=num[e],perc[7]='%';\n              perc[8]='\\0';\n              char su[50];\n              strcpy(su,\" of file \");\n              strcat(su,name);\n              strcat(su,\" sent\");\n              strcat(perc,su);\n              perc[strlen(perc)]='\\0';\n              //printf(\"%s\\n\",perc);\n              write(1,perc,strlen(perc));\n\n\n                     send(new_socket,buffer2,x,0);\n                      recv(new_socket,buffer2,4,0);\n                 }\n                 \n\n\n\n             }\n\n\n         }\n         else if(strcmp(buffer,\"exit\")==0)\n         {\n             break;\n         }\n         else\n         {\n             printf(\"wrong command\\n\");\n             buffer[0]='\\0';\n         }\n         \n\n         \n\n\n\n\n     }\n\n\n\n\n    return 0;\n}\n\n", "comment_ratio": 0.13496932515337423}
{"lang": "c", "code": "#ifndef CAN_BRAKE_H_\n#define CAN_BRAKE_H_\n\n#include <Arduino.h>\n#include \"config.h\"\n#include \"Throttle.h\"\n#include \"TickHandler.h\"\n#include \"CanHandler.h\"\n#include \"CanThrottle.h\"\n#include \"constants.h\"\n\nclass CanBrakeConfiguration : public ThrottleConfiguration {\npublic:\n\tuint16_t minimumLevel1, maximumLevel1; // values for when the pedal is at its min and max\n\tuint16_t carType; // the type of car, so we know how to interpret which bytes\n};\n\nclass CanBrake: public Throttle, CanObserver {\npublic:\n\tCanBrake();\n\tvoid setup();\n\tvoid handleTick();\n\tvoid handleCanFrame(CAN_FRAME *frame);\n\tDeviceId getId();\n\tDeviceType getType();\n\n\tRawSignalData *acquireRawSignal();\n\tvoid loadConfiguration();\n\tvoid saveConfiguration();\n\nprotected:\n\tbool validateSignal(RawSignalData *);\n\tuint16_t calculatePedalPosition(RawSignalData *);\n\tint16_t mapPedalPosition(int16_t);\n\nprivate:\n\tCAN_FRAME requestFrame; // the request frame sent to the car\n\tRawSignalData rawSignal; // raw signal\n\tuint8_t ticksNoResponse; // number of ticks no response was received\n\tuint32_t responseId; // the CAN id with which the response is sent;\n\tuint32_t responseMask; // the mask for the responseId\n\tbool responseExtended; // if the response is expected as an extended frame\n};\n\n#endif /* CAN_BRAKE_H_ */\n\n\n\n", "comment_ratio": 0.10810810810810811}
{"lang": "c", "code": "#ifndef NPCOMP_DIALECT_REFBACKRT_IR_REFBACKRTOPS_H\n#define NPCOMP_DIALECT_REFBACKRT_IR_REFBACKRTOPS_H\n\n#include \"mlir/IR/BuiltinTypes.h\"\n#include \"mlir/IR/OpDefinition.h\"\n#include \"mlir/IR/OpImplementation.h\"\n#include \"mlir/IR/SymbolTable.h\"\n\n#define GET_OP_CLASSES\n#include \"npcomp/Dialect/Refbackrt/IR/RefbackrtOps.h.inc\"\n\n#endif // NPCOMP_DIALECT_REFBACKRT_IR_REFBACKRTOPS_H\n\n", "comment_ratio": 0.38095238095238093}
{"lang": "c", "code": "#import <objc/NSObject.h>\n\n@class CMMotionManager, NSOperationQueue;\n@protocol APBMotionServiceDelegate;\n\n@interface APBMotionService : NSObject\n{\n    CMMotionManager *_motionManager;\n    NSOperationQueue *_queue;\n    id <APBMotionServiceDelegate> _delegate;\n    struct APBAttitude_t _attitude;\n    CDStruct_31142d93 _acceleration;\n    CDStruct_31142d93 _rotation;\n    CDStruct_31142d93 _magnetic;\n}\n\n@property(nonatomic) __weak id <APBMotionServiceDelegate> delegate; // @synthesize delegate=_delegate;\n@property(retain, nonatomic) NSOperationQueue *queue; // @synthesize queue=_queue;\n@property(retain, nonatomic) CMMotionManager *motionManager; // @synthesize motionManager=_motionManager;\n@property(nonatomic) struct APBAttitude_t attitude; // @synthesize attitude=_attitude;\n@property(nonatomic) CDStruct_39925896 magnetic; // @synthesize magnetic=_magnetic;\n@property(nonatomic) CDStruct_39925896 rotation; // @synthesize rotation=_rotation;\n@property(nonatomic) CDStruct_39925896 acceleration; // @synthesize acceleration=_acceleration;\n- (id).cxx_construct;\n- (void).cxx_destruct;\n- (void)stopUpdate;\n- (void)_updateDeviceMotion:(double)arg1 withHandler:(CDUnknownBlockType)arg2;\n- (void)_updateMagneto:(double)arg1 withHandler:(CDUnknownBlockType)arg2;\n- (void)_updateGyro:(double)arg1 withHandler:(CDUnknownBlockType)arg2;\n- (void)_updateAccelerometer:(double)arg1 withHandler:(CDUnknownBlockType)arg2;\n- (_Bool)_accelerometerAvailable;\n- (void)updateWithIntervalForAccelerometer:(double)arg1 gyroInterval:(double)arg2 magnetoInterval:(double)arg3 attitudeInterval:(double)arg4;\n- (id)init;\n\n@end\n\n\n", "comment_ratio": 0.27906976744186046}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n\n@class YLAlertMessageView;\n@protocol YLAlertMessageViewDeleage <NSObject>\n\n@optional\n- (void)yl_AlertMessageViewOtherBtnClick;\n\n@end\n\n@interface YLAlertMessageView : UIView\n\n@property (nonatomic, weak) id<YLAlertMessageViewDeleage> delegate;\n\n/// \u521d\u59cb\u5316 AlertView\n/// @param title \u6807\u9898\n/// @param message \u5185\u5bb9\n/// @param cancleBtnTitle \u53d6\u6d88\u6309\u94ae\n/// @param otherBtnTitle \u786e\u5b9a\u6309\u94ae\n- (instancetype)initWithTitle:(NSString *)title message:(NSString *)message cancleBtnTitle:(NSString *)cancleBtnTitle otherBtnTitle:(NSString *)otherBtnTitle;\n\n- (void)show;\n\n@end\n\n", "comment_ratio": 0.36363636363636365}
{"lang": "c", "code": "#ifndef INCLUDE_JET_DETAIL_SAMPLERS_INL_H_\n#define INCLUDE_JET_DETAIL_SAMPLERS_INL_H_\n\n#include <jet/constants.h>\n#include <jet/math_utils.h>\n#include <algorithm>\n\nnamespace jet {\n\ntemplate <typename T>\ninline Vector3<T> uniformSampleCone(\n    T u1, T u2, const Vector3<T>& axis, T angle) {\n    T cosAngle_2 = std::cos(angle / 2);\n    T y = 1 - (1 - cosAngle_2) * u1;\n    T r = std::sqrt(std::max<T>(0, 1 - y * y));\n    T phi = twoPi<T>() * u2;\n    T x = r * std::cos(phi);\n    T z = r * std::sin(phi);\n    auto ts = axis.tangential();\n    return std::get<0>(ts) * x + axis * y + std::get<1>(ts) * z;\n}\n\ntemplate <typename T>\ninline Vector3<T> uniformSampleHemisphere(\n    T u1, T u2, const Vector3<T>& normal) {\n    T y = u1;\n    T r = std::sqrt(std::max<T>(0, 1 - y*y));\n    T phi = twoPi<T>() * u2;\n    T x = r * std::cos(phi);\n    T z = r * std::sin(phi);\n    auto ts = normal.tangential();\n    return std::get<0>(ts) * x + normal * y + std::get<1>(ts) * z;\n}\n\ntemplate <typename T>\ninline Vector3<T> cosineWeightedSampleHemisphere(\n    T u1, T u2, const Vector3<T> &normal) {\n    T phi = twoPi<T>()*u1;\n    T y = std::sqrt(u2);\n    T theta = std::acos(y);\n    T x = std::cos(phi) * std::sin(theta);\n    T z = std::sin(phi) * std::sin(theta);\n    Vector3<T> t = tangential(normal);\n    auto ts = normal.tangential();\n    return std::get<0>(ts) * x + normal * y + std::get<1>(ts) * z;\n}\n\ntemplate <typename T>\ninline Vector3<T> uniformSampleSphere(T u1, T u2) {\n    T y = 1 - 2 * u1;\n    T r = std::sqrt(std::max<T>(0, 1 - y * y));\n    T phi = twoPi<T>() * u2;\n    T x = r * std::cos(phi);\n    T z = r * std::sin(phi);\n    return Vector3<T>(x, y, z);\n}\n\ntemplate <typename T>\ninline Vector2<T> uniformSampleDisk(T u1, T u2) {\n    T r = std::sqrt(u1);\n    T theta = twoPi<T>() * u2;\n\n    return Vector2<T>(r * std::cos(theta), r * std::sin(theta));\n}\n\n}  // namespace jet\n\n#endif  // INCLUDE_JET_DETAIL_SAMPLERS_INL_H_\n\n", "comment_ratio": 0.2857142857142857}
{"lang": "c", "code": "#ifndef CDSLIB_CONTAINER_SPLIT_LIST_SET_RCU_H\n#define CDSLIB_CONTAINER_SPLIT_LIST_SET_RCU_H\n\n#include <cds/intrusive/split_list_rcu.h>\n#include <cds/container/details/make_split_list_set.h>\n#include <cds/urcu/exempt_ptr.h>\n\nnamespace cds { namespace container {\n\n    //@cond\n    namespace split_list { namespace details {\n\n        template <\n            typename T,\n            class OrdList,\n            typename OrdListTag\n        >\n        class make_raw_ptr;\n\n#ifdef CDSLIB_CONTAINER_DETAILS_MICHAEL_LIST_BASE_H\n        template <typename T, class RawPtr>\n        class make_raw_ptr< T, RawPtr, cds::container::michael_list_tag >\n        {\n            typedef RawPtr intrusive_raw_ptr;\n            typedef typename intrusive_raw_ptr::value_type node_type;\n            typedef T value_type;\n\n            struct raw_ptr_converter\n            {\n                value_type * operator()( node_type * p ) const\n                {\n                   return p ? &p->m_Value : nullptr;\n                }\n\n                value_type& operator()( node_type& n ) const\n                {\n                    return n.m_Value;\n                }\n\n                value_type const& operator()( node_type const& n ) const\n                {\n                    return n.m_Value;\n                }\n            };\n        public:\n            typedef cds::urcu::raw_ptr_adaptor< value_type, intrusive_raw_ptr, raw_ptr_converter > raw_ptr;\n\n            static raw_ptr make( intrusive_raw_ptr&& p )\n            {\n                return raw_ptr(std::move( p ));\n            }\n        };\n#endif\n\n#ifdef CDSLIB_CONTAINER_DETAILS_LAZY_LIST_BASE_H\n        template <typename T, typename RawPtr>\n        class make_raw_ptr< T, RawPtr, cds::container::lazy_list_tag >\n        {\n            typedef RawPtr node_type_pointer;\n            typedef T value_type;\n\n        public:\n            typedef value_type * raw_ptr;\n\n            static raw_ptr make( node_type_pointer p )\n            {\n                return p ? &p->m_Value : nullptr;\n            }\n        };\n#endif\n    }} //namespace split_list::details\n    //@endcond\n\n    /// Split-ordered list set (template specialization for \\ref cds_urcu_desc \"RCU\")\n    /** @ingroup cds_nonintrusive_set\n        \\anchor cds_nonintrusive_SplitListSet_rcu\n\n        Hash table implementation based on split-ordered list algorithm discovered by Ori Shalev and Nir Shavit, see\n        - [2003] Ori Shalev, Nir Shavit \"Split-Ordered Lists - Lock-free Resizable Hash Tables\"\n        - [2008] Nir Shavit \"The Art of Multiprocessor Programming\"\n\n        See \\p intrusive::SplitListSet for a brief description of the split-list algorithm.\n\n        Template parameters:\n        - \\p RCU - one of \\ref cds_urcu_gc \"RCU type\"\n        - \\p T - type of the value to be stored in the split-list.\n        - \\p Traits - type traits, default is \\p split_list::traits. Instead of declaring \\p split_list::traits -based\n            struct you can apply option-based notation with \\p split_list::make_traits metafunction.\n\n        <b>Iterators</b>\n\n        The class supports a forward iterator (\\ref iterator and \\ref const_iterator).\n        The iteration is unordered.\n\n        You may iterate over split-list set items only under RCU lock.\n        Only in this case the iterator is thread-safe since\n        while RCU is locked any set's item cannot be reclaimed.\n\n        @warning The iterator object cannot be passed between threads\n\n        \\warning Due to concurrent nature of skip-list set it is not guarantee that you can iterate\n        all elements in the set: any concurrent deletion can exclude the element\n        pointed by the iterator from the set, and your iteration can be terminated\n        before end of the set. Therefore, such iteration is more suitable for debugging purposes\n\n        The iterator class supports the following minimalistic interface:\n        \\code\n        struct iterator {\n            // Default ctor\n            iterator();\n\n            // Copy ctor\n            iterator( iterator const& s);\n\n            value_type * operator ->() const;\n            value_type& operator *() const;\n\n            // Pre-increment\n            iterator& operator ++();\n\n            // Copy assignment\n            iterator& operator = (const iterator& src);\n\n            bool operator ==(iterator const& i ) const;\n            bool operator !=(iterator const& i ) const;\n        };\n        \\endcode\n        Note, the iterator object returned by \\p end(), \\p cend() member functions points to \\p nullptr and should not be dereferenced.\n\n        \\par Usage\n\n        You should decide what garbage collector you want, and what ordered list you want to use. Split-ordered list\n        is an original data structure based on an ordered list. Suppose, you want construct split-list set based on \\p cds::urcu::general_buffered<> GC\n        and \\p LazyList as ordered list implementation. So, you beginning your program with following include:\n        \\code\n        #include <cds/urcu/general_buffered.h>\n        #include <cds/container/lazy_list_rcu.h>\n        #include <cds/container/split_list_set_rcu.h>\n\n        namespace cc = cds::container;\n\n        // The data belonged to split-ordered list\n        sturuct foo {\n            int     nKey;   // key field\n            std::string strValue    ;   // value field\n        };\n        \\endcode\n        The inclusion order is important:\n        - first, include one of \\ref cds_urcu_gc \"RCU implementation\" (<tt>cds/urcu/general_buffered.h</tt> in our case)\n        - second, include file for ordered-list implementation (for this example, <tt>cds/container/lazy_list_rcu.h</tt>),\n        - then, the header for RCU-based split-list set <tt>cds/container/split_list_set_rcu.h</tt>.\n\n        Now, you should declare traits for split-list set. The main parts of traits are a hash functor for the set and a comparing functor for ordered list.\n        Note that we define several function in \\p foo_hash and \\p foo_less functors for different argument types since we want call our \\p %SplitListSet\n        object by the key of type \\p int and by the value of type \\p foo.\n\n        The second attention: instead of using \\p %LazyList in \\p %SplitListSet traits we use \\p cds::contaner::lazy_list_tag tag for the lazy list.\n        The split-list requires significant support from underlying ordered list class and it is not good idea to dive you\n        into deep implementation details of split-list and ordered list interrelations. The tag paradigm simplifies split-list interface.\n\n        \\code\n        // foo hash functor\n        struct foo_hash {\n            size_t operator()( int key ) const { return std::hash( key ) ; }\n            size_t operator()( foo const& item ) const { return std::hash( item.nKey ) ; }\n        };\n\n        // foo comparator\n        struct foo_less {\n            bool operator()(int i, foo const& f ) const { return i < f.nKey ; }\n            bool operator()(foo const& f, int i ) const { return f.nKey < i ; }\n            bool operator()(foo const& f1, foo const& f2) const { return f1.nKey < f2.nKey; }\n        };\n\n        // SplitListSet traits\n        struct foo_set_traits: public cc::split_list::traits\n        {\n            typedef cc::lazy_list_tag   ordered_list    ;   // what type of ordered list we want to use\n            typedef foo_hash            hash            ;   // hash functor for our data stored in split-list set\n\n            // Type traits for our LazyList class\n            struct ordered_list_traits: public cc::lazy_list::traits\n            {\n                typedef foo_less less   ;   // use our foo_less as comparator to order list nodes\n            };\n        };\n        \\endcode\n\n        Now you are ready to declare our set class based on \\p %SplitListSet:\n        \\code\n        typedef cc::SplitListSet< cds::urcu::gc<cds::urcu::general_buffered<> >, foo, foo_set_traits > foo_set;\n        \\endcode\n\n        You may use the modern option-based declaration instead of classic type-traits-based one:\n        \\code\n        typedef cc::SplitListSet<\n            cds::urcu::gc<cds::urcu::general_buffered<> >   // RCU type used\n            ,foo                                            // type of data stored\n            ,cc::split_list::make_traits<      // metafunction to build split-list traits\n                cc::split_list::ordered_list<cc::lazy_list_tag>     // tag for underlying ordered list implementation\n                ,cc::opt::hash< foo_hash >              // hash functor\n                ,cc::split_list::ordered_list_traits<   // ordered list traits\n                    cc::lazy_list::make_traits<         // metafunction to build lazy list traits\n                        cc::opt::less< foo_less >       // less-based compare functor\n                    >::type\n                >\n            >::type\n        >  foo_set;\n        \\endcode\n        In case of option-based declaration using \\p split_list::make_traits metafunction\n        the struct \\p foo_set_traits is not required.\n\n        Now, the set of type \\p foo_set is ready to use in your program.\n\n        Note that in this example we show only mandatory \\p traits parts, optional ones is the default and they are inherited\n        from \\p container::split_list::traits.\n        There are many other options for deep tuning of the split-list and ordered-list containers.\n    */\n    template <\n        class RCU,\n        class T,\n#ifdef CDS_DOXYGEN_INVOKED\n        class Traits = split_list::traits\n#else\n        class Traits\n#endif\n    >\n    class SplitListSet< cds::urcu::gc< RCU >, T, Traits >:\n#ifdef CDS_DOXYGEN_INVOKED\n        protected intrusive::SplitListSet< cds::urcu::gc< RCU >, T, typename Traits::ordered_list, Traits >\n#else\n        protected details::make_split_list_set< cds::urcu::gc< RCU >, T, typename Traits::ordered_list, split_list::details::wrap_set_traits<T, Traits> >::type\n#endif\n    {\n    protected:\n        //@cond\n        typedef details::make_split_list_set< cds::urcu::gc< RCU >, T, typename Traits::ordered_list, split_list::details::wrap_set_traits<T, Traits> > maker;\n        typedef typename maker::type  base_class;\n        //@endcond\n\n    public:\n        typedef cds::urcu::gc< RCU >  gc; ///< RCU-based garbage collector\n        typedef T       value_type; ///< Type of value to be storedin the set\n        typedef Traits  traits;    ///< \\p Traits template argument\n\n        // Note: ordered_list is not real ordered list type. Actual type is base_class::ordered_list\n        typedef typename maker::ordered_list        ordered_list;   ///< Underlying ordered list class\n        typedef typename base_class::key_comparator key_comparator; ///< key compare functor\n\n        /// Hash functor for \\ref value_type and all its derivatives that you use\n        typedef typename base_class::hash           hash;\n        typedef typename base_class::item_counter   item_counter; ///< Item counter type\n        typedef typename base_class::stat           stat; ///< Internal statistics\n\n        typedef typename base_class::rcu_lock      rcu_lock   ; ///< RCU scoped lock\n        /// Group of \\p extract_xxx functions require external locking if underlying ordered list requires that\n        static CDS_CONSTEXPR const bool c_bExtractLockExternal = base_class::c_bExtractLockExternal;\n\n    protected:\n        //@cond\n        typedef typename maker::cxx_node_allocator    cxx_node_allocator;\n        typedef typename maker::node_type             node_type;\n        //@endcond\n\n    public:\n        /// pointer to extracted node\n        using exempt_ptr = cds::urcu::exempt_ptr< gc, node_type, value_type, typename maker::ordered_list_traits::disposer >;\n#   ifdef CDS_DOXYGEN_INVOKED\n        /// pointer to the node for \\p get() function\n        /**\n            For \\p LazyList, \\p %raw_ptr is just pointer to \\p value_type.\n\n            For \\p MichaelList, \\p %raw_ptr is \\p cds::urcu::raw_ptr object giving access to \\p value_type.\n        */\n        typedef implementation_defined raw_ptr;\n#   else\n    private:\n        typedef split_list::details::make_raw_ptr< value_type, typename base_class::ordered_list::raw_ptr, typename traits::ordered_list > raw_ptr_maker;\n    public:\n        typedef typename raw_ptr_maker::raw_ptr raw_ptr;\n#endif\n\n    protected:\n        //@cond\n        template <typename Q, typename Func>\n        bool find_( Q& val, Func f )\n        {\n            return base_class::find( val, [&f]( node_type& item, Q& val ) { f(item.m_Value, val) ; } );\n        }\n\n        template <typename Q, typename Less, typename Func>\n        bool find_with_( Q& val, Less pred, Func f )\n        {\n            CDS_UNUSED( pred );\n            return base_class::find_with( val, typename maker::template predicate_wrapper<Less>::type(),\n                [&f]( node_type& item, Q& val ) { f(item.m_Value, val) ; } );\n        }\n\n        template <typename Q>\n        static node_type * alloc_node( Q const& v )\n        {\n            return cxx_node_allocator().New( v );\n        }\n\n        template <typename... Args>\n        static node_type * alloc_node( Args&&... args )\n        {\n            return cxx_node_allocator().MoveNew( std::forward<Args>(args)...);\n        }\n\n        static void free_node( node_type * pNode )\n        {\n            cxx_node_allocator().Delete( pNode );\n        }\n\n        struct node_disposer {\n            void operator()( node_type * pNode )\n            {\n                free_node( pNode );\n            }\n        };\n        typedef std::unique_ptr< node_type, node_disposer >     scoped_node_ptr;\n\n        bool insert_node( node_type * pNode )\n        {\n            assert( pNode != nullptr );\n            scoped_node_ptr p(pNode);\n\n            if ( base_class::insert( *pNode ) ) {\n                p.release();\n                return true;\n            }\n\n            return false;\n        }\n        //@endcond\n\n    protected:\n        //@cond\n        template <bool IsConst>\n        class iterator_type: protected base_class::template iterator_type<IsConst>\n        {\n            typedef typename base_class::template iterator_type<IsConst> iterator_base_class;\n            friend class SplitListSet;\n\n        public:\n            /// Value pointer type (const for const iterator)\n            typedef typename cds::details::make_const_type<value_type, IsConst>::pointer   value_ptr;\n            /// Value reference type (const for const iterator)\n            typedef typename cds::details::make_const_type<value_type, IsConst>::reference value_ref;\n\n        public:\n            /// Default ctor\n            iterator_type()\n            {}\n\n            /// Copy ctor\n            iterator_type( iterator_type const& src )\n                : iterator_base_class( src )\n            {}\n\n        protected:\n            explicit iterator_type( iterator_base_class const& src )\n                : iterator_base_class( src )\n            {}\n\n        public:\n            /// Dereference operator\n            value_ptr operator ->() const\n            {\n                return &(iterator_base_class::operator->()->m_Value);\n            }\n\n            /// Dereference operator\n            value_ref operator *() const\n            {\n                return iterator_base_class::operator*().m_Value;\n            }\n\n            /// Pre-increment\n            iterator_type& operator ++()\n            {\n                iterator_base_class::operator++();\n                return *this;\n            }\n\n            /// Assignment operator\n            iterator_type& operator = (iterator_type const& src)\n            {\n                iterator_base_class::operator=(src);\n                return *this;\n            }\n\n            /// Equality operator\n            template <bool C>\n            bool operator ==(iterator_type<C> const& i ) const\n            {\n                return iterator_base_class::operator==(i);\n            }\n\n            /// Equality operator\n            template <bool C>\n            bool operator !=(iterator_type<C> const& i ) const\n            {\n                return iterator_base_class::operator!=(i);\n            }\n        };\n        //@endcond\n\n    public:\n        /// Initializes split-ordered list of default capacity\n        /**\n            The default capacity is defined in bucket table constructor.\n            See \\p intrusive::split_list::expandable_bucket_table, \\p intrusive::split_list::static_bucket_table\n            which selects by \\p container::split_list::dynamic_bucket_table option.\n        */\n        SplitListSet()\n            : base_class()\n        {}\n\n        /// Initializes split-ordered list\n        SplitListSet(\n            size_t nItemCount           ///< estimated average of item count\n            , size_t nLoadFactor = 1    ///< load factor - average item count per bucket. Small integer up to 8, default is 1.\n            )\n            : base_class( nItemCount, nLoadFactor )\n        {}\n\n    public:\n    ///@name Forward iterators (thread-safe under RCU lock)\n    //@{\n        /// Forward iterator\n        /**\n            The forward iterator for Michael's set is based on \\p OrderedList forward iterator and has some features:\n            - it has no post-increment operator\n            - it iterates items in unordered fashion\n\n            You may safely use iterators in multi-threaded environment only under RCU lock.\n            Otherwise, a crash is possible if another thread deletes the element the iterator points to.\n\n            The iterator interface:\n            \\code\n            class iterator {\n            public:\n                // Default constructor\n                iterator();\n\n                // Copy construtor\n                iterator( iterator const& src );\n\n                // Dereference operator\n                value_type * operator ->() const;\n\n                // Dereference operator\n                value_type& operator *() const;\n\n                // Preincrement operator\n                iterator& operator ++();\n\n                // Assignment operator\n                iterator& operator = (iterator const& src);\n\n                // Equality operators\n                bool operator ==(iterator const& i ) const;\n                bool operator !=(iterator const& i ) const;\n            };\n            \\endcode\n        */\n        typedef iterator_type<false>  iterator;\n\n        /// Forward const iterator\n        typedef iterator_type<true>   const_iterator;\n\n        /// Returns a forward iterator addressing the first element in a set\n        /**\n            For empty set \\code begin() == end() \\endcode\n        */\n        iterator begin()\n        {\n            return iterator( base_class::begin() );\n        }\n\n        /// Returns an iterator that addresses the location succeeding the last element in a set\n        /**\n            Do not use the value returned by <tt>end</tt> function to access any item.\n            The returned value can be used only to control reaching the end of the set.\n            For empty set \\code begin() == end() \\endcode\n        */\n        iterator end()\n        {\n            return iterator( base_class::end() );\n        }\n\n        /// Returns a forward const iterator addressing the first element in a set\n        const_iterator begin() const\n        {\n            return cbegin();\n        }\n        /// Returns a forward const iterator addressing the first element in a set\n        const_iterator cbegin() const\n        {\n            return const_iterator( base_class::cbegin() );\n        }\n\n        /// Returns an const iterator that addresses the location succeeding the last element in a set\n        const_iterator end() const\n        {\n            return cend();\n        }\n        /// Returns an const iterator that addresses the location succeeding the last element in a set\n        const_iterator cend() const\n        {\n            return const_iterator( base_class::cend() );\n        }\n    //@}\n\n    public:\n        /// Inserts new node\n        /**\n            The function creates a node with copy of \\p val value\n            and then inserts the node created into the set.\n\n            The type \\p Q should contain as minimum the complete key for the node.\n            The object of \\p value_type should be constructible from a value of type \\p Q.\n            In trivial case, \\p Q is equal to \\p value_type.\n\n            The function applies RCU lock internally.\n\n            Returns \\p true if \\p val is inserted into the set, \\p false otherwise.\n        */\n        template <typename Q>\n        bool insert( Q const& val )\n        {\n            return insert_node( alloc_node( val ) );\n        }\n\n        /// Inserts new node\n        /**\n            The function allows to split creating of new item into two part:\n            - create item with key only\n            - insert new item into the set\n            - if inserting is success, calls  \\p f functor to initialize value-field of \\p val.\n\n            The functor signature is:\n            \\code\n                void func( value_type& val );\n            \\endcode\n            where \\p val is the item inserted. User-defined functor \\p f should guarantee that during changing\n            \\p val no any other changes could be made on this set's item by concurrent threads.\n            The user-defined functor is called only if the inserting is success.\n\n            The function applies RCU lock internally.\n        */\n        template <typename Q, typename Func>\n        bool insert( Q const& key, Func f )\n        {\n            scoped_node_ptr pNode( alloc_node( key ));\n\n            if ( base_class::insert( *pNode, [&f](node_type& node) { f( node.m_Value ) ; } )) {\n                pNode.release();\n                return true;\n            }\n            return false;\n        }\n\n        /// Inserts data of type \\p value_type created from \\p args\n        /**\n            Returns \\p true if inserting successful, \\p false otherwise.\n\n            The function applies RCU lock internally.\n        */\n        template <typename... Args>\n        bool emplace( Args&&... args )\n        {\n            return insert_node( alloc_node( std::forward<Args>(args)...));\n        }\n\n        /// Updates an element with given \\p val\n        /**\n            The operation performs inserting or changing data with lock-free manner.\n\n            If the \\p val key not found in the set, then the new item created from \\p val\n            is inserted into the set. Otherwise, the functor \\p func is called with the item found.\n            The functor \\p Func signature is:\n            \\code\n                struct my_functor {\n                    void operator()( bool bNew, value_type& item, const Q& val );\n                };\n            \\endcode\n\n            with arguments:\n            - \\p bNew - \\p true if the item has been inserted, \\p false otherwise\n            - \\p item - item of the set\n            - \\p val - argument \\p val passed into the \\p %ensure() function\n\n            The functor may change non-key fields of the \\p item; however, \\p func must guarantee\n            that during changing no any other modifications could be made on this item by concurrent threads.\n\n            The function applies RCU lock internally.\n\n            Returns <tt> std::pair<bool, bool> </tt> where \\p first is true if operation is successfull,\n            \\p second is true if new item has been added or \\p false if the item with \\p key\n            already is in the set.\n        */\n        /// Updates the node\n        /**\n            The operation performs inserting or changing data with lock-free manner.\n\n            If \\p key is not found in the set, then \\p key is inserted iff \\p bAllowInsert is \\p true.\n            Otherwise, the functor \\p func is called with item found.\n\n            The functor signature is:\n            \\code\n                struct my_functor {\n                    void operator()( bool bNew, value_type& item, const Q& val );\n                };\n            \\endcode\n\n            with arguments:\n            - \\p bNew - \\p true if the item has been inserted, \\p false otherwise\n            - \\p item - item of the set\n            - \\p val - argument \\p val passed into the \\p %update() function\n\n            The functor may change non-key fields of the \\p item.\n\n            The function applies RCU lock internally.\n\n            Returns <tt> std::pair<bool, bool> </tt> where \\p first is true if operation is successfull,\n            \\p second is true if new item has been added or \\p false if the item with \\p key\n            already is in the map.\n\n            @warning For \\ref cds_intrusive_MichaelList_rcu \"MichaelList\" as the bucket see \\ref cds_intrusive_item_creating \"insert item troubleshooting\".\n            \\ref cds_intrusive_LazyList_rcu \"LazyList\" provides exclusive access to inserted item and does not require any node-level\n            synchronization.\n        */\n        template <typename Q, typename Func>\n        std::pair<bool, bool> update( Q const& val, Func func, bool bAllowInsert = true )\n        {\n            scoped_node_ptr pNode( alloc_node( val ));\n\n            std::pair<bool, bool> bRet = base_class::update( *pNode,\n                [&func, &val]( bool bNew, node_type& item,  node_type const& /*val*/ ) {\n                    func( bNew, item.m_Value, val );\n                }, bAllowInsert );\n            if ( bRet.first && bRet.second )\n                pNode.release();\n            return bRet;\n        }\n        //@cond\n        // Dprecated, use update()\n        template <typename Q, typename Func>\n        std::pair<bool, bool> ensure( Q const& val, Func func )\n        {\n            return update( val, func, true );\n        }\n        //@endcond\n\n        /// Deletes \\p key from the set\n        /** \\anchor cds_nonintrusive_SplitListSet_rcu_erase_val\n\n            Template parameter of type \\p Q defines the key type searching in the list.\n            The set item comparator should be able to compare the values of type \\p value_type\n            and the type \\p Q.\n\n            RCU \\p synchronize method can be called. RCU should not be locked.\n\n            Return \\p true if key is found and deleted, \\p false otherwise\n        */\n        template <typename Q>\n        bool erase( Q const& key )\n        {\n            return base_class::erase( key );\n        }\n\n        /// Deletes the item from the set using \\p pred predicate for searching\n        /**\n            The function is an analog of \\ref cds_nonintrusive_SplitListSet_rcu_erase_val \"erase(Q const&)\"\n            but \\p pred is used for key comparing.\n            \\p Less functor has the interface like \\p std::less.\n            \\p Less must imply the same element order as the comparator used for building the set.\n        */\n        template <typename Q, typename Less>\n        bool erase_with( Q const& key, Less pred )\n        {\n            CDS_UNUSED( pred );\n             return base_class::erase_with( key, typename maker::template predicate_wrapper<Less>::type() );\n        }\n\n        /// Deletes \\p key from the set\n        /** \\anchor cds_nonintrusive_SplitListSet_rcu_erase_func\n\n            The function searches an item with key \\p key, calls \\p f functor\n            and deletes the item. If \\p key is not found, the functor is not called.\n\n            The functor \\p Func interface:\n            \\code\n            struct extractor {\n                void operator()(value_type const& val);\n            };\n            \\endcode\n\n            Template parameter of type \\p Q defines the key type searching in the list.\n            The list item comparator should be able to compare the values of the type \\p value_type\n            and the type \\p Q.\n\n            RCU \\p synchronize method can be called. RCU should not be locked.\n\n            Return \\p true if key is found and deleted, \\p false otherwise\n        */\n        template <typename Q, typename Func>\n        bool erase( Q const& key, Func f )\n        {\n            return base_class::erase( key, [&f](node_type& node) { f( node.m_Value ); } );\n        }\n\n        /// Deletes the item from the set using \\p pred predicate for searching\n        /**\n            The function is an analog of \\ref cds_nonintrusive_SplitListSet_rcu_erase_func \"erase(Q const&, Func)\"\n            but \\p pred is used for key comparing.\n            \\p Less functor has the interface like \\p std::less.\n            \\p Less must imply the same element order as the comparator used for building the set.\n        */\n        template <typename Q, typename Less, typename Func>\n        bool erase_with( Q const& key, Less pred, Func f )\n        {\n            CDS_UNUSED( pred );\n            return base_class::erase_with( key, typename maker::template predicate_wrapper<Less>::type(),\n                [&f](node_type& node) { f( node.m_Value ); } );\n        }\n\n        /// Extracts an item from the set\n        /** \\anchor cds_nonintrusive_SplitListSet_rcu_extract\n            The function searches an item with key equal to \\p key in the set,\n            unlinks it from the set, and returns \\ref cds::urcu::exempt_ptr \"exempt_ptr\" pointer to the item found.\n            If the item with the key equal to \\p key is not found the function returns an empty \\p exempt_ptr.\n\n            Depends on \\p bucket_type you should or should not lock RCU before calling of this function:\n            - for the set based on \\ref cds_intrusive_MichaelList_rcu \"MichaelList\" RCU should not be locked\n            - for the set based on \\ref cds_intrusive_LazyList_rcu \"LazyList\" RCU should be locked\n            See ordered list implementation for details.\n\n            \\code\n            typedef cds::urcu::gc< general_buffered<> > rcu;\n\n            // Split-list set based on MichaelList by default\n            typedef cds::container::SplitListSet< rcu, Foo > splitlist_set;\n\n            splitlist_set theSet;\n            // ...\n\n            splitlist_set::exempt_ptr p;\n\n            // For MichaelList we should not lock RCU\n\n            // Now, you can apply extract function\n            p = theSet.extract( 10 );\n            if ( p ) {\n                // do something with p\n                ...\n            }\n\n            // We may safely release p here\n            // release() passes the pointer to RCU reclamation cycle\n            p.release();\n            \\endcode\n        */\n        template <typename Q>\n        exempt_ptr extract( Q const& key )\n        {\n            return exempt_ptr( base_class::extract_( key, key_comparator() ));\n        }\n\n        /// Extracts an item from the set using \\p pred predicate for searching\n        /**\n            The function is an analog of \\p extract(Q const&) but \\p pred is used for key comparing.\n            \\p Less functor has the interface like \\p std::less.\n            \\p pred must imply the same element order as the comparator used for building the set.\n        */\n        template <typename Q, typename Less>\n        exempt_ptr extract_with( Q const& key, Less pred )\n        {\n            CDS_UNUSED( pred );\n            return exempt_ptr( base_class::extract_with_( key, typename maker::template predicate_wrapper<Less>::type()));\n        }\n\n        /// Finds the key \\p key\n        /** \\anchor cds_nonintrusive_SplitListSet_rcu_find_func\n\n            The function searches the item with key equal to \\p key and calls the functor \\p f for item found.\n            The interface of \\p Func functor is:\n            \\code\n            struct functor {\n                void operator()( value_type& item, Q& key );\n            };\n            \\endcode\n            where \\p item is the item found, \\p key is the <tt>find</tt> function argument.\n\n            The functor may change non-key fields of \\p item. Note that the functor is only guarantee\n            that \\p item cannot be disposed during functor is executing.\n            The functor does not serialize simultaneous access to the set's \\p item. If such access is\n            possible you must provide your own synchronization schema on item level to exclude unsafe item modifications.\n\n            Note the hash functor specified for class \\p Traits template parameter\n            should accept a parameter of type \\p Q that can be not the same as \\p value_type.\n\n            The function makes RCU lock internally.\n\n            The function returns \\p true if \\p key is found, \\p false otherwise.\n        */\n        template <typename Q, typename Func>\n        bool find( Q& key, Func f )\n        {\n            return find_( key, f );\n        }\n        //@cond\n        template <typename Q, typename Func>\n        bool find( Q const& key, Func f )\n        {\n            return find_( key, f );\n        }\n        //@endcond\n\n        /// Finds the key \\p key using \\p pred predicate for searching\n        /**\n            The function is an analog of \\ref cds_nonintrusive_SplitListSet_rcu_find_func \"find(Q&, Func)\"\n            but \\p pred is used for key comparing.\n            \\p Less functor has the interface like \\p std::less.\n            \\p Less must imply the same element order as the comparator used for building the set.\n        */\n        template <typename Q, typename Less, typename Func>\n        bool find_with( Q& key, Less pred, Func f )\n        {\n            return find_with_( key, pred, f );\n        }\n        //@cond\n        template <typename Q, typename Less, typename Func>\n        bool find_with( Q const& key, Less pred, Func f )\n        {\n            return find_with_( key, pred, f );\n        }\n        //@endcond\n\n        /// Checks whether the set contains \\p key\n        /**\n            The function searches the item with key equal to \\p key\n            and returns \\p true if it is found, and \\p false otherwise.\n\n            Note the hash functor specified for class \\p Traits template parameter\n            should accept a parameter of type \\p Q that can be not the same as \\p value_type.\n            Otherwise, you may use \\p contains( Q const&, Less pred ) functions with explicit predicate for key comparing.\n\n            The function applies RCU lock internally.\n        */\n        template <typename Q>\n        bool contains( Q const& key )\n        {\n            return base_class::contains( key );\n        }\n        //@cond\n        template <typename Q>\n        CDS_DEPRECATED(\"deprecated, use contains()\")\n        bool find( Q const& key )\n        {\n            return contains( key );\n        }\n        //@endcond\n\n        /// Checks whether the map contains \\p key using \\p pred predicate for searching\n        /**\n            The function is similar to <tt>contains( key )</tt> but \\p pred is used for key comparing.\n            \\p Less functor has the interface like \\p std::less.\n            \\p Less must imply the same element order as the comparator used for building the map.\n        */\n        template <typename Q, typename Less>\n        bool contains( Q const& key, Less pred )\n        {\n            CDS_UNUSED( pred );\n            return base_class::contains( key, typename maker::template predicate_wrapper<Less>::type() );\n        }\n        //@cond\n        template <typename Q, typename Less>\n        CDS_DEPRECATED(\"deprecated, use contains()\")\n        bool find_with( Q const& key, Less pred )\n        {\n            return contains( key, pred );\n        }\n        //@endcond\n\n        /// Finds the key \\p key and return the item found\n        /** \\anchor cds_nonintrusive_SplitListSet_rcu_get\n            The function searches the item with key equal to \\p key and returns the pointer to item found.\n            If \\p key is not found it returns \\p nullptr.\n\n            Note the compare functor should accept a parameter of type \\p Q that can be not the same as \\p value_type.\n\n            RCU should be locked before call of this function.\n            Returned item is valid only while RCU is locked:\n            \\code\n            typedef cds::urcu::gc< general_buffered<> > rcu;\n            typedef cds::container::SplitListSet< rcu, Foo > splitlist_set;\n            splitlist_set theSet;\n            // ...\n            {\n                // Lock RCU\n                splitlist_set::rcu_lock lock;\n\n                foo * pVal = theSet.get( 5 );\n                if ( pVal ) {\n                    // Deal with pVal\n                    //...\n                }\n                // Unlock RCU by rcu_lock destructor\n                // pVal can be retired by disposer at any time after RCU has been unlocked\n            }\n            \\endcode\n        */\n        template <typename Q>\n        raw_ptr get( Q const& key )\n        {\n            return raw_ptr_maker::make( base_class::get( key ));\n        }\n\n        /// Finds the key \\p key and return the item found\n        /**\n            The function is an analog of \\ref cds_nonintrusive_SplitListSet_rcu_get \"get(Q const&)\"\n            but \\p pred is used for comparing the keys.\n\n            \\p Less functor has the semantics like \\p std::less but should take arguments of type \\ref value_type and \\p Q\n            in any order.\n            \\p pred must imply the same element order as the comparator used for building the set.\n        */\n        template <typename Q, typename Less>\n        raw_ptr get_with( Q const& key, Less pred )\n        {\n            CDS_UNUSED( pred );\n            return raw_ptr_maker::make( base_class::get_with( key, typename maker::template predicate_wrapper<Less>::type()));\n        }\n\n        /// Clears the set (not atomic)\n        void clear()\n        {\n            base_class::clear();\n        }\n\n        /// Checks if the set is empty\n        /**\n            Emptiness is checked by item counting: if item count is zero then assume that the set is empty.\n            Thus, the correct item counting feature is an important part of split-list set implementation.\n        */\n        bool empty() const\n        {\n            return base_class::empty();\n        }\n\n        /// Returns item count in the set\n        size_t size() const\n        {\n            return base_class::size();\n        }\n\n        /// Returns internal statistics\n        stat const& statistics() const\n        {\n            return base_class::statistics();\n        }\n    };\n}}  // namespace cds::container\n\n#endif // #ifndef CDSLIB_CONTAINER_SPLIT_LIST_SET_RCU_H\n\n", "comment_ratio": 0.128}
{"lang": "c", "code": "// ----------------------------------------------------------------------------\n// <auto-generated>\n// This is autogenerated code by Embeddinator-4000.\n// Do not edit this file or all your changes will be lost after re-generation.\n// </auto-generated>\n// ----------------------------------------------------------------------------\n#include \"System.h\"\n#include \"glib.h\"\n#include \"mono_embeddinator.h\"\n#include \"c-support.h\"\n\nmono_embeddinator_context_t __mono_context;\nMonoImage* __System_dll_image;\n\nstatic MonoClass* class_System_Text_RegularExpressions_RegexOptions = 0;\n\nstatic void __initialize_mono()\n{\n    if (__mono_context.domain)\n        return;\n    mono_embeddinator_init(&__mono_context, \"mono_embeddinator_binding\");\n}\n\nstatic void __lookup_assembly_System_dll()\n{\n    if (__System_dll_image)\n        return;\n    __System_dll_image = mono_embeddinator_load_assembly(&__mono_context, \"System.dll\");\n}\n\n", "comment_ratio": 0.2}
{"lang": "c", "code": "#ifndef JRD_SDW_H\n#define JRD_SDW_H\n\n#include \"../include/fb_blk.h\"\n\nnamespace Jrd {\n\tclass jrd_file;\n\n// Shadowing block\n\nclass Shadow : public pool_alloc<type_sdw>\n{\npublic:\n\tShadow* sdw_next;\t\t\t\t// next in linked list\n\tjrd_file* sdw_file;\t\t\t\t// Stack of shadow files\n\tUSHORT sdw_number;\t\t\t\t// number of shadow\n\tUSHORT sdw_flags;\n};\n\n// sdw_flags\n\nconst USHORT SDW_dumped\t= 1;\t\t\t// bit set when file has been copied\nconst USHORT SDW_shutdown\t= 2;\t\t// stop shadowing on next cache flush\nconst USHORT SDW_manual\t= 4;\t\t\t// shadow is a manual shadow--don't delete\nconst USHORT SDW_delete\t= 8;\t\t\t// delete the shadow at the next shutdown\nconst USHORT SDW_found\t\t= 16;\t\t// flag to mark shadow found in database\nconst USHORT SDW_rollover\t= 32;\t\t// this shadow was rolled over to when the main db file went away\nconst USHORT SDW_conditional\t= 64;\t// shadow to be used if another shadow becomes unavailable\n\n/* these macros are a convenient combination of switches:\n   the first specifies the shadow is invalid for writing to;\n   the second specifies that the shadow no SLONGer exists and the\n   shadow block simply hasn't been cleared out yet */\n\nconst USHORT SDW_INVALID\t= (SDW_shutdown | SDW_delete | SDW_rollover | SDW_conditional);\nconst USHORT SDW_IGNORE\t= (SDW_shutdown | SDW_delete);\n\n} //namespace Jrd\n\n#endif // JRD_SDW_H\n\n", "comment_ratio": 0.234375}
{"lang": "c", "code": "// We cannot directly reuse the npy_isfinite from npy_math.h as numpy\n// and scikit-learn are not necessarily built with the same compiler.\n// When re-declaring the functions in the template for cython\n// specific for each parameter input type, it needs to be 2 different functions\n// as cython doesn't support function overloading.\n#ifdef _MSC_VER\n# include <float.h>\n# define skl_isfinite _finite\n# define skl_isfinite32 _finite\n# define skl_isfinite64 _finite\n#else\n# include <numpy/npy_math.h>\n# define skl_isfinite npy_isfinite\n# define skl_isfinite32 npy_isfinite\n# define skl_isfinite64 npy_isfinite\n#endif\n\n", "comment_ratio": 0.29411764705882354}
{"lang": "c", "code": "@interface UIView (imageRepresentation)\n\n- (UIImage *)imageRepresentation;\n\n- (void)hide;\n- (void)show;\n\n- (void)fadeOut;\n- (void)fadeOutAndPerformSelector:(SEL)selector;\n- (void)fadeOutAndPerformSelector:(SEL)selector withObject:(id)object;\n\n- (void)fadeIn;\n- (void)fadeInAndPerformSelector:(SEL)selector;\n- (void)fadeInAndPerformSelector:(SEL)selector withObject:(id)object;\n\n- (void)fadeAlphaTo:(CGFloat)targetAlpha;\n- (void)fadeAlphaTo:(CGFloat)targetAlpha andPerformSelector:(SEL)selector;\n- (void)fadeAlphaTo:(CGFloat)targetAlpha andPerformSelector:(SEL)selector withObject:(id)object;\n\n@end\n\n", "comment_ratio": 0.2413793103448276}
{"lang": "c", "code": "#ifndef ASH_SYSTEM_ACCESSIBILITY_SWITCH_ACCESS_SWITCH_ACCESS_MENU_BUTTON_H_\n#define ASH_SYSTEM_ACCESSIBILITY_SWITCH_ACCESS_SWITCH_ACCESS_MENU_BUTTON_H_\n\n#include \"ui/base/metadata/metadata_header_macros.h\"\n#include \"ui/views/controls/button/button.h\"\n#include \"ui/views/metadata/view_factory.h\"\n\nnamespace gfx {\nstruct VectorIcon;\n}\n\nnamespace views {\nclass ImageView;\nclass Label;\n}  // namespace views\n\nnamespace ash {\n\nclass SwitchAccessMenuButton : public views::Button {\n public:\n  METADATA_HEADER(SwitchAccessMenuButton);\n\n  SwitchAccessMenuButton(std::string action_name,\n                         const gfx::VectorIcon& icon,\n                         int accessible_name_id);\n  ~SwitchAccessMenuButton() override = default;\n\n  SwitchAccessMenuButton(const SwitchAccessMenuButton&) = delete;\n  SwitchAccessMenuButton& operator=(const SwitchAccessMenuButton&) = delete;\n\n  static constexpr int kWidthDip = 80;\n\n  // views::View:\n  void GetAccessibleNodeData(ui::AXNodeData* node_data) override;\n\n private:\n  friend class SwitchAccessMenuBubbleControllerTest;\n\n  void OnButtonPressed();\n\n  std::string action_name_;\n\n  // Owned by the views hierarchy.\n  views::ImageView* image_view_;\n  views::Label* label_;\n};\n\nBEGIN_VIEW_BUILDER(/* no export */, SwitchAccessMenuButton, views::Button)\nEND_VIEW_BUILDER\n\n}  // namespace ash\n\nDEFINE_VIEW_BUILDER(/* no export */, ash::SwitchAccessMenuButton)\n\n#endif  // ASH_SYSTEM_ACCESSIBILITY_SWITCH_ACCESS_SWITCH_ACCESS_MENU_BUTTON_H_\n\n", "comment_ratio": 0.13333333333333333}
{"lang": "c", "code": "#ifndef BITCOIN_EXPEDITED_H\n#define BITCOIN_EXPEDITED_H\n\n#include \"net.h\"\n#include \"thinblock.h\"\n\n#include <univalue.h>\n#include <vector>\n\n\nenum\n{\n    EXPEDITED_STOP = 1,\n    EXPEDITED_BLOCKS = 2,\n    EXPEDITED_TXNS = 4,\n};\n\nenum\n{\n    EXPEDITED_MSG_HDR = 1,\n    EXPEDITED_MSG_XTHIN = 2,\n};\n\n\nextern CCriticalSection cs_xpedited; // protects xpeditedBlk, xpeditedBlkUp and xpeditedTxn\nextern std::vector<CNode *> xpeditedBlk; // Who requested expedited blocks from us\nextern std::vector<CNode *> xpeditedBlkUp; // Who we requested expedited blocks from\nextern std::vector<CNode *> xpeditedTxn;\n\n// Checks to see if the node is configured in bitcoin.conf to\nextern bool CheckAndRequestExpeditedBlocks(CNode *pfrom);\n\n// be an expedited block source and if so, request them.\nextern void SendExpeditedBlock(CXThinBlock &thinBlock, unsigned char hops, const CNode *skip = NULL);\nextern void SendExpeditedBlock(const CBlock &block, const CNode *skip = NULL);\nextern bool HandleExpeditedRequest(CDataStream &vRecv, CNode *pfrom);\nextern bool IsRecentlyExpeditedAndStore(const uint256 &hash);\n\n// process incoming unsolicited block\nextern bool HandleExpeditedBlock(CDataStream &vRecv, CNode *pfrom);\n\n// is this node an expedited node\nextern bool IsExpeditedNode(const CNode *pfrom);\n\n#endif\n\n", "comment_ratio": 0.2}
{"lang": "c", "code": "#import \"NSObject.h\"\n\n#import \"PHAssetRepresentationDownloadObserver.h\"\n\n@class MBProjectClipsLoader, NSArray, NSDictionary, NSSet, NSString, Project;\n\n__attribute__((visibility(\"hidden\")))\n@interface ProjectAssetManager : NSObject <PHAssetRepresentationDownloadObserver>\n{\n    BOOL _downloading;\n    BOOL _automaticallyStartDownloads;\n    BOOL _cacheRepairableEditItems;\n    double _downloadProgress;\n    Project *_project;\n    id <ProjectAssetManagerDelegate> _delegate;\n    NSDictionary *_movieMatches;\n    MBProjectClipsLoader *_sharedClipsLoader;\n    NSArray *_cachedRepairableEditItems;\n    unsigned long long _numberOfWorkItems;\n    unsigned long long _numberOfCompletedWorkItems;\n    NSSet *_offlineAssetRepresentations;\n}\n\n@property(retain, nonatomic) NSSet *offlineAssetRepresentations; // @synthesize offlineAssetRepresentations=_offlineAssetRepresentations;\n@property unsigned long long numberOfCompletedWorkItems; // @synthesize numberOfCompletedWorkItems=_numberOfCompletedWorkItems;\n@property unsigned long long numberOfWorkItems; // @synthesize numberOfWorkItems=_numberOfWorkItems;\n@property(retain, nonatomic) NSArray *cachedRepairableEditItems; // @synthesize cachedRepairableEditItems=_cachedRepairableEditItems;\n@property(nonatomic) BOOL cacheRepairableEditItems; // @synthesize cacheRepairableEditItems=_cacheRepairableEditItems;\n@property(retain, nonatomic) MBProjectClipsLoader *sharedClipsLoader; // @synthesize sharedClipsLoader=_sharedClipsLoader;\n@property(retain, nonatomic) NSDictionary *movieMatches; // @synthesize movieMatches=_movieMatches;\n@property(nonatomic) __weak id <ProjectAssetManagerDelegate> delegate; // @synthesize delegate=_delegate;\n@property(nonatomic) __weak Project *project; // @synthesize project=_project;\n@property(nonatomic) BOOL automaticallyStartDownloads; // @synthesize automaticallyStartDownloads=_automaticallyStartDownloads;\n@property(nonatomic, getter=isDownloading) BOOL downloading; // @synthesize downloading=_downloading;\n@property(nonatomic) double downloadProgress; // @synthesize downloadProgress=_downloadProgress;\n- (void).cxx_destruct;\n- (id)localOriginalImageForIdentifierURL:(id)arg1;\n- (id)projectOriginalImageForIdentifierURL:(id)arg1;\n- (id)originalImageForIdentifierURL:(id)arg1;\n- (BOOL)hasProjectAssetForIdentifierURL:(id)arg1;\n- (id)filePathForAdjustedVideoIdentifierURL:(id)arg1;\n- (void)postProgressNotification;\n- (void)repairEditItems:(id)arg1;\n- (void)repairMismatchedAssets;\n- (void)repairMissingAssets;\n- (id)matchLocalMovies;\n- (id)predicateForDuration:(double)arg1;\n- (id)predicateForCreationDate:(id)arg1 tolerance:(double)arg2;\n- (id)matchLibraryAssets;\n- (id)matchingAssetsForEditItem:(id)arg1 creationDateTolerance:(double)arg2;\n- (id)fetchOptionsForEditItem:(id)arg1 creationDateTolerance:(double)arg2;\n- (void)connectivityDidChange:(id)arg1;\n- (void)downloadStateOfAssetRepresentationDidChange:(id)arg1 previousState:(unsigned long long)arg2 currentState:(unsigned long long)arg3;\n- (void)_updateDownloadProgress;\n- (void)updateDownloadProgress;\n- (void)downloadOfAssetRepresentation:(id)arg1 didProgress:(double)arg2;\n- (void)cancelDownloads;\n- (void)downloadOfflineAssetsIfNecessary;\n- (void)projectDidFinishAllEditing:(id)arg1;\n- (BOOL)hasOfflineAssets;\n- (id)offlineEditItems;\n- (unsigned long long)numberOfOfflineAssets;\n- (BOOL)hasModifiedAssets;\n- (BOOL)hasMismatchedDurationAssets;\n- (BOOL)hasMismatchedAssets;\n- (id)mismatchedEditItems;\n- (id)mismatchedDurationEditItems;\n- (unsigned long long)numberOfMismatchedAssets;\n- (void)hasAssetsInPhotosTrash:(CDUnknownBlockType)arg1;\n- (BOOL)hasMissingAssets;\n- (id)missingEditItems;\n- (unsigned long long)numberOfMissingAssets;\n- (unsigned long long)numberOfAssetsMatchingCriteria:(long long)arg1;\n- (id)assetURLsMatchingCriteria:(long long)arg1 breakOnFirst:(BOOL)arg2;\n- (id)editItemsMatchingCriteria:(long long)arg1 breakOnFirst:(BOOL)arg2;\n- (id)repairableEditItems;\n- (void)dealloc;\n- (id)initWithProject:(id)arg1;\n\n// Remaining properties\n@property(readonly, copy) NSString *debugDescription;\n@property(readonly, copy) NSString *description;\n@property(readonly) unsigned long long hash;\n@property(readonly) Class superclass;\n\n@end\n\n\n", "comment_ratio": 0.19148936170212766}
{"lang": "c", "code": "@import ZBase;\n@import ZTransition;\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface ZCollectionNoLoadingViewController : ZTViewController\n\n@property (nonatomic ,strong ,readonly) UICollectionView *collectionView;\n\n- (UICollectionView *)createCollectionWithLayout:(UICollectionViewFlowLayout *)layout;\n\n- (UICollectionViewCell *)configCollectionViewCell:(id)data forIndexPath:(NSIndexPath *)ip ;\n\n- (void)collectionViewSelectData:(id)data forIndexPath:(NSIndexPath *)ip ;\n\n@end\n\nNS_ASSUME_NONNULL_END\n\n", "comment_ratio": 0.25925925925925924}
{"lang": "c", "code": "#ifndef ELECTRON_SHELL_BROWSER_ELECTRON_WEB_CONTENTS_UTILITY_HANDLER_IMPL_H_\n#define ELECTRON_SHELL_BROWSER_ELECTRON_WEB_CONTENTS_UTILITY_HANDLER_IMPL_H_\n\n#include <string>\n#include <vector>\n\n#include \"base/memory/weak_ptr.h\"\n#include \"content/public/browser/web_contents_observer.h\"\n#include \"electron/shell/common/api/api.mojom.h\"\n#include \"mojo/public/cpp/bindings/associated_receiver.h\"\n#include \"shell/browser/api/electron_api_web_contents.h\"\n\nnamespace content {\nclass RenderFrameHost;\n}\n\nnamespace electron {\nclass ElectronWebContentsUtilityHandlerImpl\n    : public mojom::ElectronWebContentsUtility,\n      public content::WebContentsObserver {\n public:\n  explicit ElectronWebContentsUtilityHandlerImpl(\n      content::RenderFrameHost* render_frame_host,\n      mojo::PendingAssociatedReceiver<mojom::ElectronWebContentsUtility>\n          receiver);\n\n  static void Create(\n      content::RenderFrameHost* frame_host,\n      mojo::PendingAssociatedReceiver<mojom::ElectronWebContentsUtility>\n          receiver);\n\n  // disable copy\n  ElectronWebContentsUtilityHandlerImpl(\n      const ElectronWebContentsUtilityHandlerImpl&) = delete;\n  ElectronWebContentsUtilityHandlerImpl& operator=(\n      const ElectronWebContentsUtilityHandlerImpl&) = delete;\n\n  // mojom::ElectronWebContentsUtility:\n  void OnFirstNonEmptyLayout() override;\n  void UpdateDraggableRegions(\n      std::vector<mojom::DraggableRegionPtr> regions) override;\n  void SetTemporaryZoomLevel(double level) override;\n  void DoGetZoomLevel(DoGetZoomLevelCallback callback) override;\n\n  base::WeakPtr<ElectronWebContentsUtilityHandlerImpl> GetWeakPtr() {\n    return weak_factory_.GetWeakPtr();\n  }\n\n private:\n  ~ElectronWebContentsUtilityHandlerImpl() override;\n\n  // content::WebContentsObserver:\n  void WebContentsDestroyed() override;\n\n  void OnConnectionError();\n\n  content::RenderFrameHost* GetRenderFrameHost();\n\n  const int render_process_id_;\n  const int render_frame_id_;\n\n  mojo::AssociatedReceiver<mojom::ElectronWebContentsUtility> receiver_{this};\n\n  base::WeakPtrFactory<ElectronWebContentsUtilityHandlerImpl> weak_factory_{\n      this};\n};\n}  // namespace electron\n#endif  // ELECTRON_SHELL_BROWSER_ELECTRON_WEB_CONTENTS_UTILITY_HANDLER_IMPL_H_\n\n", "comment_ratio": 0.1095890410958904}
{"lang": "c", "code": "#ifndef IMATERIAL_DECLARATIONS_HDR \n#define IMATERIAL_DECLARATIONS_HDR \n\n#include \"materialsystem/imaterialsystemhardwareconfig_declarations.h\"\n\n//-----------------------------------------------------------------------------\n// Shader state flags can be read from the FLAGS materialvar\n// Also can be read or written to with the Set/GetMaterialVarFlags() call\n// Also make sure you add/remove a string associated with each flag below to CShaderSystem::ShaderStateString in ShaderSystem.cpp\n//-----------------------------------------------------------------------------\nenum MaterialVarFlags_t\n{\n\tMATERIAL_VAR_DEBUG\t\t\t\t\t  = (1 << 0),\n\tMATERIAL_VAR_NO_DEBUG_OVERRIDE\t\t  = (1 << 1),\n\tMATERIAL_VAR_NO_DRAW\t\t\t\t  = (1 << 2),\n\tMATERIAL_VAR_USE_IN_FILLRATE_MODE\t  = (1 << 3),\n\n\tMATERIAL_VAR_VERTEXCOLOR\t\t\t  = (1 << 4),\n\tMATERIAL_VAR_VERTEXALPHA\t\t\t  = (1 << 5),\n\tMATERIAL_VAR_SELFILLUM\t\t\t\t  = (1 << 6),\n\tMATERIAL_VAR_ADDITIVE\t\t\t\t  = (1 << 7),\n\tMATERIAL_VAR_ALPHATEST\t\t\t\t  = (1 << 8),\n#if defined( _PS3 ) || defined SPU\n\t// This Material flag is specifically for the final bloom pass only (the bloom add pass).\n\t// We need to disable alpha writes for 2x MSAA otherwise this pass will cause a heavy\n\t// blurring artifact to appear. It's only ever used in bloomadd_ps3.vmt, a modified version\n\t// of bloomadd.vmt for PS3 only - Jawad.\n\tMATERIAL_VAR_NOALPHAWRITES            = (1 << 30),\n#endif //_PS3\n\tMATERIAL_VAR_ZNEARER\t\t\t\t  = (1 << 10),\n\tMATERIAL_VAR_MODEL\t\t\t\t\t  = (1 << 11),\n\tMATERIAL_VAR_FLAT\t\t\t\t\t  = (1 << 12),\n\tMATERIAL_VAR_NOCULL\t\t\t\t\t  = (1 << 13),\n\tMATERIAL_VAR_NOFOG\t\t\t\t\t  = (1 << 14),\n\tMATERIAL_VAR_IGNOREZ\t\t\t\t  = (1 << 15),\n\tMATERIAL_VAR_DECAL\t\t\t\t\t  = (1 << 16),\n\tMATERIAL_VAR_ENVMAPSPHERE\t\t\t  = (1 << 17), // OBSOLETE\n//\tMATERIAL_VAR_UNUSED\t\t\t\t\t  = (1 << 18),\n\tMATERIAL_VAR_ENVMAPCAMERASPACE\t      = (1 << 19), // OBSOLETE\n\tMATERIAL_VAR_BASEALPHAENVMAPMASK\t  = (1 << 20),\n\tMATERIAL_VAR_TRANSLUCENT              = (1 << 21),\n\tMATERIAL_VAR_NORMALMAPALPHAENVMAPMASK = (1 << 22),\n\tMATERIAL_VAR_NEEDS_SOFTWARE_SKINNING  = (1 << 23), // OBSOLETE\n\tMATERIAL_VAR_OPAQUETEXTURE\t\t\t  = (1 << 24),\n\tMATERIAL_VAR_MULTIPLY\t\t\t\t  = (1 << 25),\n\tMATERIAL_VAR_SUPPRESS_DECALS\t\t  = (1 << 26),\n\tMATERIAL_VAR_HALFLAMBERT\t\t\t  = (1 << 27),\n\tMATERIAL_VAR_WIREFRAME                = (1 << 28),\n\tMATERIAL_VAR_ALLOWALPHATOCOVERAGE     = (1 << 29),\n\tMATERIAL_VAR_ALPHA_MODIFIED_BY_PROXY  = (1 << 30),\n\tMATERIAL_VAR_VERTEXFOG\t\t\t\t  = (1 << 31),\n\n\t// NOTE: Only add flags here that either should be read from\n\t// .vmts or can be set directly from client code. Other, internal\n\t// flags should to into the flag enum in IMaterialInternal.h\n};\n\n\n//-----------------------------------------------------------------------------\n// Internal flags not accessible from outside the material system. Stored in Flags2\n//-----------------------------------------------------------------------------\nenum MaterialVarFlags2_t\n{\n\t// NOTE: These are for $flags2!!!!!\n//\tUNUSED\t\t\t\t\t\t\t\t\t\t\t= (1 << 0),\n\n\tMATERIAL_VAR2_LIGHTING_UNLIT\t\t\t\t\t= 0,\n\tMATERIAL_VAR2_LIGHTING_VERTEX_LIT\t\t\t\t= (1 << 1),\n\tMATERIAL_VAR2_LIGHTING_LIGHTMAP\t\t\t\t\t= (1 << 2),\n\tMATERIAL_VAR2_LIGHTING_BUMPED_LIGHTMAP\t\t\t= (1 << 3),\n\tMATERIAL_VAR2_LIGHTING_MASK\t\t\t\t\t\t= \n\t\t( MATERIAL_VAR2_LIGHTING_VERTEX_LIT | \n\t\t  MATERIAL_VAR2_LIGHTING_LIGHTMAP | \n\t\t  MATERIAL_VAR2_LIGHTING_BUMPED_LIGHTMAP ),\n\n\t// FIXME: Should this be a part of the above lighting enums?\n\tMATERIAL_VAR2_DIFFUSE_BUMPMAPPED_MODEL\t\t\t\t\t= (1 << 4),\n\tMATERIAL_VAR2_USES_ENV_CUBEMAP\t\t\t\t\t\t\t= (1 << 5),\n\tMATERIAL_VAR2_NEEDS_TANGENT_SPACES\t\t\t\t\t\t= (1 << 6),\n\tMATERIAL_VAR2_NEEDS_SOFTWARE_LIGHTING\t\t\t\t\t= (1 << 7),\n\t// GR - HDR path puts lightmap alpha in separate texture...\n\tMATERIAL_VAR2_BLEND_WITH_LIGHTMAP_ALPHA\t\t\t\t\t= (1 << 8),\n\tMATERIAL_VAR2_NEEDS_BAKED_LIGHTING_SNAPSHOTS\t\t\t= (1 << 9),\n\tMATERIAL_VAR2_USE_FLASHLIGHT\t\t\t\t\t\t\t= (1 << 10),\n\tMATERIAL_VAR2_USE_FIXED_FUNCTION_BAKED_LIGHTING\t\t\t= (1 << 11),\n\tMATERIAL_VAR2_NEEDS_FIXED_FUNCTION_FLASHLIGHT\t\t\t= (1 << 12),\n\tMATERIAL_VAR2_USE_EDITOR\t\t\t\t\t\t\t\t= (1 << 13),\n\tMATERIAL_VAR2_NEEDS_POWER_OF_TWO_FRAME_BUFFER_TEXTURE\t= (1 << 14),\n\tMATERIAL_VAR2_NEEDS_FULL_FRAME_BUFFER_TEXTURE\t\t\t= (1 << 15),\n\tMATERIAL_VAR2_IS_SPRITECARD\t\t\t\t\t\t\t\t= (1 << 16),\n\tMATERIAL_VAR2_USES_VERTEXID\t\t\t\t\t\t\t\t= (1 << 17),\n\tMATERIAL_VAR2_SUPPORTS_HW_SKINNING\t\t\t\t\t\t= (1 << 18),\n\tMATERIAL_VAR2_SUPPORTS_FLASHLIGHT\t\t\t\t\t\t= (1 << 19),\n\tMATERIAL_VAR2_USE_GBUFFER0                              = (1 << 20),\n\tMATERIAL_VAR2_USE_GBUFFER1                              = (1 << 21),\n\tMATERIAL_VAR2_SELFILLUMMASK\t\t\t\t\t\t\t\t= (1 << 22),\n\tMATERIAL_VAR2_SUPPORTS_TESSELLATION\t\t\t\t\t\t= (1 << 23),\n\n\t// Support for types of vertex compression:\n\tMATERIAL_VAR2_SUPPORTS_VERTEX_COMPRESSION_BIT\t\t\t= 26,\n\tMATERIAL_VAR2_SUPPORTS_VERTEX_COMPRESSION_FULL\t\t\t= ( VERTEX_COMPRESSION_FULL << MATERIAL_VAR2_SUPPORTS_VERTEX_COMPRESSION_BIT ),\n\tMATERIAL_VAR2_SUPPORTS_VERTEX_COMPRESSION_NOUV\t\t\t= ( VERTEX_COMPRESSION_NOUV << MATERIAL_VAR2_SUPPORTS_VERTEX_COMPRESSION_BIT ), \n\tMATERIAL_VAR2_SUPPORTS_VERTEX_COMPRESSION_MASK\t\t\t= \n\t( MATERIAL_VAR2_SUPPORTS_VERTEX_COMPRESSION_FULL |\n\tMATERIAL_VAR2_SUPPORTS_VERTEX_COMPRESSION_NOUV ),\n};\n\n#endif\n", "comment_ratio": 0.23853211009174313}
{"lang": "c", "code": "// RUN: %clang_cc1 %s -verify -fsyntax-only -pedantic\n// Check that we don't crash trying to emit warnings in a potentially-evaluated\n// sizeof or typeof.  (This test needs to be in a separate file because we use\n// a different codepath when we have already emitted an error.)\n\nint PotentiallyEvaluatedSizeofWarn(int n) {\n  return (int)sizeof *(0 << 32,(int(*)[n])0); // expected-warning {{expression result unused}} expected-warning {{shift count >= width of type}}\n}\n\nvoid PotentiallyEvaluatedTypeofWarn(int n) {\n  __typeof(*(0 << 32,(int(*)[n])0)) x; // expected-warning {{expression result unused}} expected-warning {{shift count >= width of type}}\n  (void)x;\n}\n\nvoid PotentiallyEvaluatedArrayBoundWarn(int n) {\n  (void)*(int(*)[(0 << 32,n)])0; // FIXME: We should warn here.\n}\n\n", "comment_ratio": 0.3888888888888889}
{"lang": "c", "code": "#ifndef __INET_IEEE80211QUEUE_H\n#define __INET_IEEE80211QUEUE_H\n\n#include \"inet/common/INETDefs.h\"\n#include \"inet/linklayer/ieee80211/mac/Ieee80211Frame_m.h\"\n\nnamespace inet {\nnamespace ieee80211 {\n\nclass INET_API Ieee80211Queue : public cQueue\n{\n    protected:\n        int maxQueueSize = -1; // -1 means unlimited queue\n\n    public:\n        virtual ~Ieee80211Queue() { }\n        Ieee80211Queue(int maxQueueSize, const char *name);\n\n        virtual bool insert(Ieee80211DataOrMgmtFrame *frame);\n        virtual bool insertBefore(Ieee80211DataOrMgmtFrame *where, Ieee80211DataOrMgmtFrame *frame);\n        virtual bool insertAfter(Ieee80211DataOrMgmtFrame *where, Ieee80211DataOrMgmtFrame *frame);\n\n        virtual Ieee80211DataOrMgmtFrame *remove(Ieee80211DataOrMgmtFrame *frame);\n        virtual Ieee80211DataOrMgmtFrame *pop();\n\n        virtual Ieee80211DataOrMgmtFrame *front() const;\n        virtual Ieee80211DataOrMgmtFrame *back() const;\n\n        virtual bool contains(Ieee80211DataOrMgmtFrame *frame) const;\n\n        int getNumberOfFrames() { return getLength(); }\n        int getMaxQueueSize() { return maxQueueSize; }\n\n};\n\nclass PendingQueue : public Ieee80211Queue {\n    public:\n        enum class Priority {\n            PRIORITIZE_MGMT_OVER_DATA,\n            PRIORITIZE_MULTICAST_OVER_DATA\n        };\n\n    public:\n        virtual ~PendingQueue() { }\n        PendingQueue(int maxQueueSize, const char *name);\n        PendingQueue(int maxQueueSize, const char *name, Priority priority);\n\n    public:\n        static int cmpMgmtOverData(Ieee80211DataOrMgmtFrame *a, Ieee80211DataOrMgmtFrame *b);\n        static int cmpMgmtOverMulticastOverUnicast(Ieee80211DataOrMgmtFrame *a, Ieee80211DataOrMgmtFrame *b);\n};\n\n} /* namespace ieee80211 */\n} /* namespace inet */\n\n#endif // ifndef __INET_IEEE80211QUEUE_H\n\n", "comment_ratio": 0.24324324324324326}
{"lang": "c", "code": "//\n// AED, 2020/2021\n//\n// Decoding a non-instantaneous binary code\n//\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"elapsed_time.h\"\n\n//\n// Compile time parameters\n//\n\n#ifndef MAX_N_SYMBOLS\n#define MAX_N_SYMBOLS 500  // maximum number of alphabet symbols in a code\n#endif\n#ifndef MAX_CODEWORD_SIZE\n#define MAX_CODEWORD_SIZE 23  // maximum number of bits of a codeword\n#endif\n#ifndef MAX_MESSAGE_SIZE\n#define MAX_MESSAGE_SIZE 100000  // maximum number of symbols in a message\n#endif\n\n#ifndef N_OUTLIERS\n#define N_OUTLIERS 20  // discard this number of mesurements (outliers) on each side of the median\n#endif\n#ifndef N_VALID\n#define N_VALID 80  // use this number of measurements on each side of the median\n#endif\n#define N_MEASUREMENTS (2 * N_OUTLIERS + 2 * N_VALID + 1)  // total number of measurements\n\n#ifndef N\n#define N 0\n#endif\n\n//\n// Random number generator interface\n//\n// In order to ensure reproducible results on Windows and GNU/Linux, we use a good random number generator, available at\n//   https://www-cs-faculty.stanford.edu/~knuth/programs/rng.c\n// This file has to be used without any modifications, so we take care of the main function that is there by applying\n// some C preprocessor tricks\n//\n// DO NOT CHANGE THIS CODE\n//\n\n#define main rng_main  // main gets replaced by rng_main\n#ifdef __GNUC__\nint rng_main() __attribute__((__unused__));  // gcc will not complain if rnd_main() is not used\n#endif\n#include \"rng.c\"\n#undef main  // main becomes main again\n\n#define srandom(seed) ran_start((long)seed)  // start the pseudo-random number generator\n#define random() ran_arr_next()              // get the next pseudo-random number (0 to 2^30-1)\n\n//\n// Generation of a random non-instantaneous uniquely decodable code with n symbols (inverted Hufffman code)\n//\n// DO NOT CHANGE THIS CODE\n//\n\ntypedef struct\n{\n    int scaled_prob;                       // proportional to the probability of occurrence of this symbol\n    int cum_scaled_prob;                   // proportional to the probability of occurrence of this or of all previous symbols\n    int parent;                            // -1 means no parent, >= 0 gives the index of the parent\n    int bit;                               // -1 means no information, 0 or 1 means append this bit to the parent's code\n    char codeword[MAX_CODEWORD_SIZE + 1];  // the complete (inverted) Huffman code\n} symbol_t;\n\ntypedef struct\n{\n    int n_symbols;   // the number of symbols\n    int max_bits;    // maximum number of bits of a codeword\n    symbol_t *data;  // the symbols and their codes (with extra data at the end --- used to construct the entire Huffman tree)\n} code_t;\n\nvoid free_code(code_t *c) {\n    if (c != NULL) {\n        if (c->data != NULL)\n            free(c->data);\n        c->data = NULL;\n        free(c);\n    }\n}\n\ncode_t *new_code(int n_symbols) {\n    int i, i0, i1, n;\n    code_t *c;\n\n    //\n    // Refuse to handle too few or too many symbols\n    //\n    if (n_symbols < 2 || n_symbols > MAX_N_SYMBOLS) {\n        fprintf(stderr, \"new_code: n_symbols (%d) is either too small or too large\\n\", n_symbols);\n        exit(1);\n    }\n    //\n    // Allocate memory for the n_symbols symbols plus n_symbols-1 tree nodes for the Huffman tree\n    //\n    c = (code_t *)malloc(sizeof(code_t));\n    if (c == NULL) {\n        fprintf(stderr, \"new_code: out of memory\\n\");\n        exit(1);\n    }\n    c->data = (symbol_t *)malloc((size_t)(2 * n_symbols - 1) * sizeof(symbol_t));\n    if (c->data == NULL) {\n        free(c);\n        fprintf(stderr, \"new_code: out of memory\\n\");\n        exit(1);\n    }\n    //\n    // Initialize the symbols --- at the beginning, the symbols (leaves of the Huffman tree) are disconnected\n    //\n    c->n_symbols = n_symbols;\n    for (i = 0; i < n_symbols; i++) {\n        c->data[i].scaled_prob = 10 + (int)random() % 991;                 // a pseudo-random integer belonging to the interval [10,1000]\n        c->data[i].cum_scaled_prob = c->data[i].scaled_prob;               // used only to generate\n        if (i > 0)                                                         //   symbols with the\n            c->data[i].cum_scaled_prob += c->data[i - 1].cum_scaled_prob;  //   correct probability\n        c->data[i].parent = -1;                                            // currently, no parent node\n        c->data[i].bit = -1;                                               // currently, no bit numbier\n        c->data[i].codeword[0] = '\\0';                                     // currently, no codeword string\n    }\n    //\n    // Construct the Huffman code\n    //\n    // We are going to do it in a O(n^2) way --- speed is not important here\n    // Using min-heaps would reduce that to O(n log n), but the code would be longer and more difficult to understand\n    //\n    n = n_symbols;\n    for (;;) {\n        //\n        // Find the two \"open\" nodes (those with a parent equal to -1) with the smallest scaled_prob\n        //\n        i0 = i1 = -1;\n        for (i = 0; i < n; i++)\n            if (c->data[i].parent == -1) {                                         // ok, we have an open node\n                if (i0 < 0 || c->data[i].scaled_prob < c->data[i0].scaled_prob) {  // the smallest scaled_prob so far\n                    i1 = i0;\n                    i0 = i;\n                } else if (i1 < 0 || c->data[i].scaled_prob < c->data[i1].scaled_prob) {  // the second smallest scaled_prob so far\n                    i1 = i;\n                }\n            }\n        //\n        // Are we done? Yes when we cannot find two open nodes (this will happen when n == 2 * n_symbols - 1)\n        //\n        if (i1 < 0)\n            break;\n        //\n        // Merge the two open nodes (close them and create a new open node)\n        //\n        c->data[n].scaled_prob = c->data[i0].scaled_prob + c->data[i1].scaled_prob;\n        c->data[n].cum_scaled_prob = -1;  // not used but we initialize it anyway\n        c->data[n].parent = -1;\n        c->data[n].bit = -1;\n        c->data[n].codeword[0] = '\\0';  // not used but we initialize it anyway\n        c->data[i0].parent = n;         // the parent of node i0 becomes node n --- the left descendant of node n is node i0 (we do not record this information)\n        c->data[i0].bit = 0;            // give this branch a bit of 0\n        c->data[i1].parent = n;         // the parent of node i1 becomes node n --- the right descendant of node n is node i1 (we do not record this information)\n        c->data[i1].bit = 1;            // give this branch a bit of 1\n        n++;\n    }\n    if (n != 2 * n_symbols - 1) {\n        fprintf(stderr, \"new_code: unexpected value of n [expected %d, we got %d]\\n\", 2 * n_symbols - 1, n);\n        exit(1);\n    }\n    //\n    // For each symbol, initialize its (inverted) Huffman code\n    //\n    c->max_bits = 0;\n    for (n = 0; n < n_symbols; n++) {\n        i = 0;   // the current code size\n        i0 = n;  // the initial tree node index\n        while (c->data[i0].parent >= 0) {\n            if (i >= MAX_CODEWORD_SIZE) {\n                fprintf(stderr, \"ne_code: MAX_CODEWORD_SIZE is too small\\n\");\n                exit(1);\n            }\n            c->data[n].codeword[i] = '0' + c->data[i0].bit;\n            i++;\n            i0 = c->data[i0].parent;\n        }\n        c->data[n].codeword[i] = '\\0';  // terminate the codeword string\n        if (i > c->max_bits)\n            c->max_bits = i;\n    }\n    //\n    // Done!\n    //\n    return c;\n}\n\n//\n// Random code symbol\n//\n// DO NOT CHANGE THIS CODE\n//\n\nint random_symbol(code_t *c) {\n    int i, r;\n\n    //\n    // Generate an (approximately) uniformly distributed integer in the appropriate range\n    //\n    r = random() % c->data[c->n_symbols - 1].cum_scaled_prob;\n    //\n    // Find the index i for which c->data[i - 1].cum_scaled_prob <= r < c->data[i].cum_scaled_prob (with c->data[-1].cum_scaled_prob implicitly 0)\n    // We are going to do it in a O(n) way --- speed is not important here\n    // We could have used a special version of binary search here, but the code would be longer and more difficult to understand\n    //\n    for (i = 0; i < c->n_symbols; i++)\n        if (r < c->data[i].cum_scaled_prob)\n            break;\n    if (i == c->n_symbols) {\n        fprintf(stderr, \"ramdom_symbol: i is too large! Impossible!!! [r=%d]\\n\", r);\n        exit(1);\n    }\n    return i;\n}\n\n//\n// Random message\n//\n// DO NOT CHANGE THIS CODE\n//\n\nvoid random_message(code_t *c, int message_size, int message[message_size]) {\n    int i;\n\n    if (message_size < 1 || message_size > MAX_MESSAGE_SIZE) {\n        fprintf(stderr, \"random_message: bad message size (%d)\\n\", message_size);\n        exit(1);\n    }\n    for (i = 0; i < message_size; i++)\n        message[i] = random_symbol(c);\n}\n\n//\n// Encode a message\n//\n// DO NOT CHANGE THIS CODE\n//\n\nvoid encode_message(code_t *c, int message_size, int message[message_size], int max_encoded_message_size, char encoded_message[max_encoded_message_size + 1]) {\n    int i, j, n;\n    char *s;\n\n    if (message_size < 1 || message_size > MAX_MESSAGE_SIZE) {\n        fprintf(stderr, \"encode_message: bad message size (%d)\\n\", message_size);\n        exit(1);\n    }\n    n = 0;  // encoded message size\n    for (i = 0; i < message_size; i++) {\n        if (message[i] < 0 || message[i] >= c->n_symbols) {\n            fprintf(stderr, \"encoded_message: unexpected symbol (%d)\\n\", message[i]);\n            exit(1);\n        }\n        s = c->data[message[i]].codeword;\n        for (j = 0; s[j] != 0; j++) {\n            if (n > max_encoded_message_size) {\n                fprintf(stderr, \"encode_message: the encoded message is too big\\n\");\n                exit(1);\n            }\n            encoded_message[n++] = s[j];  // concatenate the code word\n        }\n    }\n    encoded_message[n] = '\\0';  // terminate the string\n}\n\n//\n// Global data used for decoding (to avoid passing all this information in function arguments, thus making the program more efficient)\n//\n\nstruct\n{\n    code_t *c;                                // the code being used\n    int *original_message;                    // the original message\n    int original_message_size;                // the original message length\n    int max_encoded_message_size;             // the largest possible encoded message size\n    char *encoded_message;                    // the encoded message\n    int max_decoded_message_size;             // the largest possible decoded message length\n    int *decoded_message;                     // the decoded message (should be equal to the original message)\n    long number_of_calls;                     // the number of recursive function calls\n    long number_of_solutions;                 // the number of solutions (at the end, is all is well, must be equal to 1)\n    int max_extra_symbols;                    // the largest difference between the partially decoded message and the good part of the partially decoded message)\n    double cpu_time;                          // the variable to measure the time of each n\n} decoder_global_data;\n\n#define _c_ decoder_global_data.c\n#define _original_message_ decoder_global_data.original_message\n#define _original_message_size_ decoder_global_data.original_message_size\n#define _max_encoded_message_size_ decoder_global_data.max_encoded_message_size\n#define _encoded_message_ decoder_global_data.encoded_message\n#define _max_decoded_message_size_ decoder_global_data.max_decoded_message_size\n#define _decoded_message_ decoder_global_data.decoded_message\n#define _number_of_calls_ decoder_global_data.number_of_calls\n#define _number_of_solutions_ decoder_global_data.number_of_solutions\n#define _max_extra_symbols_ decoder_global_data.max_extra_symbols\n#define _cpu_time_ decoder_global_data.cpu_time\n\n//\n// Recursive decoder\n//\n// encoded_idx ......... index into the _encoded_message_ array of the next bit to be considered\n// decoded_idx ......... index into the _decoded_message_ array where the next decoded symbol will be placed\n// good_decoded_size ... number of correct decoded symbols\n//\n// Decoding large messages require a large amount of stack space (one recursion level per message symbol)\n// If you get a segmentation fault in our program you may need to increase the stack size (under GNU/linux, you can do it using the command \"ulimit -s 16384\")\n//\n\nstatic void print_decode_real_time(int decoded_idx) {\n    usleep(100000);\n    printf(\"\\r\");\n    for (int k = 0; k <= decoded_idx; k++) {\n        printf(\"%d\", _decoded_message_[k]);\n    }\n    fflush(stdout);\n}\n\nstatic void recursive_decoder(int encoded_idx, int decoded_idx, int good_decoded_size) {\n    _number_of_calls_++;  //increase by one, each time the function is called\n\n    if ((decoded_idx - good_decoded_size) > _max_extra_symbols_) {  //update the max_extra_symbols, when the condition is true\n        _max_extra_symbols_ = (decoded_idx - good_decoded_size);\n    }\n\n    //* Terminal condition, it means that message is already decoded\n    if (_encoded_message_[encoded_idx] == '\\0') {  //if the last index of _encoded_message is equal to NULL, the message is decoded\n        _number_of_solutions_++;                   //increase by one, and it should be one\n\n        return;\n    }\n\n    for (int i = 0; i < _c_->n_symbols; i++) {  //for cycle to go through\n        int j = 0;\n        while (_c_->data[i].codeword[j] == _encoded_message_[encoded_idx + j]) {  //while the codeword[j] is equal to the bit [encoded_idx + j] of _encoded_message_\n            if (_c_->data[i].codeword[++j] == '\\0') {                             //when the codeword finish, this is when codeword[j + 1] == '\\0')\n                _decoded_message_[decoded_idx] = i;                               // decode array is incremented with the i, in decoded index\n                //* confirm if the symbol decoded is equal to the symbol original, and if the good_decoded_size is equal to decoded_idx, both may be equal to be right\n                if (_original_message_[decoded_idx] == _decoded_message_[decoded_idx] && (good_decoded_size) == decoded_idx) {\n                    if (N == 1) {\n                        print_decode_real_time(decoded_idx);\n                    }\n                    recursive_decoder(encoded_idx + j, decoded_idx + 1, good_decoded_size + 1);\n                } else {\n                    if (N == 1) {\n                        print_decode_real_time(decoded_idx);\n                    }\n                    recursive_decoder(encoded_idx + j, decoded_idx + 1, good_decoded_size);\n                }\n                break;\n            }\n        }\n    }\n}\n\n//\n// Encode and decode driver\n//\n// DO NOT CHANGE THIS CODE\n//\n\nvoid try_it(code_t *c, int message_size, int show_results) {\n    if (message_size < 1 || message_size > MAX_MESSAGE_SIZE) {\n        fprintf(stderr, \"try_it: bad message size (%d)\\n\", message_size);\n        exit(1);\n    }\n    _c_ = c;\n    _original_message_size_ = message_size;\n    _max_encoded_message_size_ = message_size * c->max_bits;\n    _max_decoded_message_size_ = message_size + 2000;\n    _original_message_ = (int *)malloc((size_t)_original_message_size_ * sizeof(int));\n    _encoded_message_ = (char *)malloc((size_t)(_max_encoded_message_size_ + 1) * sizeof(char));\n    _decoded_message_ = (int *)malloc((size_t)_max_decoded_message_size_ * sizeof(int));\n    _number_of_calls_ = 0L;\n    _number_of_solutions_ = 0L;\n    _max_extra_symbols_ = -1;\n    if (_original_message_ == NULL || _encoded_message_ == NULL || _decoded_message_ == NULL) {\n        fprintf(stderr, \"try it: out of memory!\\n\");\n        exit(1);\n    }\n    random_message(_c_, _original_message_size_, _original_message_);\n    encode_message(_c_, _original_message_size_, _original_message_, _max_encoded_message_size_, _encoded_message_);\n\n    //decoder_global_data.cpu_time = cpu_time();\n    recursive_decoder(0, 0, 0);\n    //decoder_global_data.cpu_time = cpu_time() - decoder_global_data.cpu_time;\n\n    if (_number_of_solutions_ != 1L) {\n        fprintf(stderr, \"number of solutions: %ld\\n\", _number_of_solutions_);\n        fprintf(stderr, \"number of function calls: %ld (%.3f per message symbol)\\n\", _number_of_calls_, (double)_number_of_calls_ / (double)_original_message_size_);\n        fprintf(stderr, \"number of extra symbols: %d\\n\\n\", _max_extra_symbols_);\n    }\n    if (show_results != 0) {\n        //\n        // print some data about this particular case (average number of calls per symbol, worst probe lookahead)\n        //\n        if (N == 1){printf(\"\\n\");}\n        printf(\"%4s %13.3s %15s\\n\", \"Symbols\", \"Avg Calls\", \"Max extra symbols\");\n        printf(\"%4d %13.3f %15d\\n\", _c_->n_symbols, (double)_number_of_calls_ / (double)_original_message_size_, _max_extra_symbols_);\n        fflush(stdout);\n    }\n    free(_original_message_);\n    _original_message_ = NULL;\n    free(_encoded_message_);\n    _encoded_message_ = NULL;\n    free(_decoded_message_);\n    _decoded_message_ = NULL;\n}\n\n//\n// Main program\n//\n// DO NOT CHANGE THIS CODE\n//\n\nint main(int argc, char **argv) {\n    //\n    // Show code words (called with arguments -s n_symbols seed)\n    //\n    if (argc == 4 && argv[1][0] == '-' && argv[1][1] == 's') {\n        int seed, n_symbols, i;\n        code_t *c;\n\n        n_symbols = atoi(argv[2]);\n        seed = atoi(argv[3]);\n        srandom(seed);\n        c = new_code(n_symbols);\n        printf(\"seed: %d\\n\", seed);\n        printf(\"number of symbols: %d\\n\", c->n_symbols);\n        printf(\"maximum bits of a code word: %d\\n\\n\", c->max_bits);\n        printf(\"symb freq  cfreq codeword\\n\");\n        printf(\"---- ---- ------ --------------------\\n\");\n        for (i = 0; i < c->n_symbols; i++)\n            printf(\"%4d %4d %6d %s\\n\", i, c->data[i].scaled_prob, c->data[i].cum_scaled_prob, c->data[i].codeword);\n        printf(\"---- ---- ------ --------------------\\n\\n\");\n        free_code(c);\n        return 0;\n    }\n    //\n    // Encode and decode a message (called with arguments -t [n_symbols [message_size [seed]]])\n    //\n    if (argc >= 2 && argc <= 5 && argv[1][0] == '-' && argv[1][1] == 't') {\n        int n_symbols, message_size, seed;\n        code_t *c;\n\n        n_symbols = (argc < 3) ? 3 : atoi(argv[2]);\n        message_size = (argc < 4) ? 10 : atoi(argv[3]);\n        seed = (argc < 5) ? 1 : atoi(argv[4]);\n        srandom(seed);\n        c = new_code(n_symbols);\n        try_it(c, message_size, 1);\n        free_code(c);\n        return 0;\n    }\n    //\n    // Try the first N_MEASUREMENTS seeds (called with arguments -x n_symbols)\n    //\n    if (argc == 3 && argv[1][0] == '-' && argv[1][1] == 'x') {\n        double t, t_min, t_max, t_avg, t_data[N_MEASUREMENTS], u_avg;\n        int u, u_min, u_max, u_data[N_MEASUREMENTS];\n        int seed, n_symbols, i;\n        code_t *c;\n\n        n_symbols = atoi(argv[2]);\n        if (n_symbols == 2) {\n            printf(\"# data for MAX_MESSAGE_SIZE equal to %d\\n\", MAX_MESSAGE_SIZE);\n            printf(\"# data for N_OUTLIERS equal to %d\\n\", N_OUTLIERS);\n            printf(\"# data for N_VALID equal to %d\\n\", N_VALID);\n            printf(\"#\\n\");\n            printf(\"#      number of calls per message symbol      lookahead symbols\\n\");\n            printf(\"#     -----------------------------------  ---------------------\\n\");\n            printf(\"# ns       min      avg      med      max   min    avg  med  max\\n\");\n            printf(\"#---  -------- -------- -------- --------  ---- ------ ---- ----\\n\");\n        }\n        if (n_symbols < 3 || n_symbols > MAX_N_SYMBOLS) {\n            fprintf(stderr, \"main: bad number of symbols for the -x command line option\\n\");\n            exit(1);\n        }\n        t_min = t_max = 0.0;\n        u_min = u_max = 0;\n        _cpu_time_ = cpu_time();\n        for (seed = 1; seed <= N_MEASUREMENTS; seed++) {\n            srandom(seed);\n            c = new_code(n_symbols);\n            try_it(c, MAX_MESSAGE_SIZE, 0);\n            free_code(c);\n            t = (double)_number_of_calls_ / (double)MAX_MESSAGE_SIZE;\n            u = _max_extra_symbols_;\n            if (seed == 1 || t < t_min)\n                t_min = t;\n            if (seed == 1 || t > t_max)\n                t_max = t;\n            if (seed == 1 || u < u_min)\n                u_min = u;\n            if (seed == 1 || u > u_max)\n                u_max = u;\n            for (i = seed - 1; i > 0 && t_data[i - 1] > t; i--)  // inner loop of insertion sort!\n                t_data[i] = t_data[i - 1];\n            t_data[i] = t;\n            for (i = seed - 1; i > 0 && u_data[i - 1] > u; i--)  // inner loop of insertion sort!\n                u_data[i] = u_data[i - 1];\n            u_data[i] = u;\n        }\n        t_avg = u_avg = 0.0;\n        for (i = N_OUTLIERS; i < N_MEASUREMENTS - N_OUTLIERS; i++) {\n            t_avg += t_data[i];\n            u_avg += (double)u_data[i];\n        }\n        t_avg /= (double)(2 * N_VALID + 1);\n        u_avg /= (double)(2 * N_VALID + 1);\n        _cpu_time_ = cpu_time() - _cpu_time_;\n\n        printf(\"%4d %8.3f %6.3f %7.3f %6.3f  %3d %6.1f %4d %6d %6.2f\\n\", n_symbols, t_min, t_avg, t_data[N_OUTLIERS + N_VALID], t_max, u_min, u_avg, u_data[N_OUTLIERS + N_VALID], u_max, _cpu_time_);\n        return 0;\n    }\n    //\n    // Help message\n    //\n    fprintf(stderr, \"usage: %s -s n_symbols seed                     # show the code words of random code\\n\", argv[0]);\n    fprintf(stderr, \"       %s -t [n_symbols [message_size [seed]]]  # encode and decode a message\\n\", argv[0]);\n    fprintf(stderr, \"       %s -x n_symbols                          # try the first %d seeds\\n\", argv[0], N_MEASUREMENTS);\n    return 1;\n}\n\n", "comment_ratio": 0.33771106941838647}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n#import \"YZWord.h\"\n\n@interface YZWordDetailView : UIView\n\n@property(nonatomic, strong)UILabel *wordLabel;\n@property(nonatomic, strong)UILabel *senLabel;\n@property(nonatomic, strong)UILabel *senTranLabel;\n@property(nonatomic, strong)UILabel *ukPhoneLabel;\n@property(nonatomic, strong)UILabel *usPhoneLabel;\n@property(nonatomic, strong)UILabel *firstTranLabel;\n@property(nonatomic, strong)UILabel *secondTranLabel;\n@property(nonatomic, strong)UILabel *thirdTranLabel;\n\n@property(nonatomic, strong)UIView *cardView;\n@property(nonatomic, strong)UIImageView *backImageView;\n\n@property(nonatomic, copy)YZWord *wordData;\n\n@end\n\n", "comment_ratio": 0.2413793103448276}
{"lang": "c", "code": "#ifndef CRYPTOPP_NETWORK_H\n#define CRYPTOPP_NETWORK_H\n\n#include \"filters.h\"\n#include \"hrtimer.h\"\n\nNAMESPACE_BEGIN(CryptoPP)\n\n//! a Source class that can pump from a device for a specified amount of time.\nclass CRYPTOPP_NO_VTABLE NonblockingSource : public AutoSignaling<Source>\n{\npublic:\n\tNonblockingSource(BufferedTransformation *attachment)\n\t\t: m_messageEndSent(false) {Detach(attachment);}\n\n\t//!\t\\name NONBLOCKING SOURCE\n\t//@{\n\n\t//! pump up to maxSize bytes using at most maxTime milliseconds\n\t/*! If checkDelimiter is true, pump up to delimiter, which itself is not extracted or pumped. */\n\tvirtual unsigned int GeneralPump2(unsigned long &byteCount, bool blockingOutput=true, unsigned long maxTime=INFINITE_TIME, bool checkDelimiter=false, byte delimiter='\\n') =0;\n\n\tunsigned long GeneralPump(unsigned long maxSize=ULONG_MAX, unsigned long maxTime=INFINITE_TIME, bool checkDelimiter=false, byte delimiter='\\n')\n\t{\n\t\tGeneralPump2(maxSize, true, maxTime, checkDelimiter, delimiter);\n\t\treturn maxSize;\n\t}\n\tunsigned long TimedPump(unsigned long maxTime)\n\t\t{return GeneralPump(ULONG_MAX, maxTime);}\n\tunsigned long PumpLine(byte delimiter='\\n', unsigned long maxSize=1024)\n\t\t{return GeneralPump(maxSize, INFINITE_TIME, true, delimiter);}\n\n\tunsigned int Pump2(unsigned long &byteCount, bool blocking=true)\n\t\t{return GeneralPump2(byteCount, blocking, blocking ? INFINITE_TIME : 0);}\n\tunsigned int PumpMessages2(unsigned int &messageCount, bool blocking=true);\n\t//@}\n\nprivate:\n\tbool m_messageEndSent;\n};\n\n//! Network Receiver\nclass CRYPTOPP_NO_VTABLE NetworkReceiver : public Waitable\n{\npublic:\n\tvirtual bool MustWaitToReceive() {return false;}\n\tvirtual bool MustWaitForResult() {return false;}\n\t//! receive data from network source, returns whether result is immediately available\n\tvirtual bool Receive(byte* buf, unsigned int bufLen) =0;\n\tvirtual unsigned int GetReceiveResult() =0;\n\tvirtual bool EofReceived() const =0;\n};\n\nclass CRYPTOPP_NO_VTABLE NonblockingSinkInfo\n{\npublic:\n\tvirtual ~NonblockingSinkInfo() {}\n\tvirtual unsigned int GetMaxBufferSize() const =0;\n\tvirtual unsigned int GetCurrentBufferSize() const =0;\n\t//! compute the current speed of this sink in bytes per second\n\tvirtual float ComputeCurrentSpeed() =0;\n\t//! get the maximum observed speed of this sink in bytes per second\n\tvirtual float GetMaxObservedSpeed() const =0;\n};\n\n//! a Sink class that queues input and can flush to a device for a specified amount of time.\nclass CRYPTOPP_NO_VTABLE NonblockingSink : public Sink, public NonblockingSinkInfo\n{\npublic:\n\tbool IsolatedFlush(bool hardFlush, bool blocking);\n\n\t//! flush to device for no more than maxTime milliseconds\n\t/*! This function will repeatedly attempt to flush data to some device, until\n\t\tthe queue is empty, or a total of maxTime milliseconds have elapsed.\n\t\tIf maxTime == 0, at least one attempt will be made to flush some data, but\n\t\tit is likely that not all queued data will be flushed, even if the device\n\t\tis ready to receive more data without waiting. If you want to flush as much data\n\t\tas possible without waiting for the device, call this function in a loop.\n\t\tFor example: while (sink.TimedFlush(0) > 0) {}\n\t\t\\return number of bytes flushed\n\t*/\n\tvirtual unsigned int TimedFlush(unsigned long maxTime, unsigned int targetSize = 0) =0;\n\n\tvirtual void SetMaxBufferSize(unsigned int maxBufferSize) =0;\n\t//! set a bound which will cause sink to flush if exceeded by GetCurrentBufferSize()\n\tvirtual void SetAutoFlushBound(unsigned int bound) =0;\n};\n\n//! Network Sender\nclass CRYPTOPP_NO_VTABLE NetworkSender : public Waitable\n{\npublic:\n\tvirtual bool MustWaitToSend() {return false;}\n\tvirtual bool MustWaitForResult() {return false;}\n\tvirtual void Send(const byte* buf, unsigned int bufLen) =0;\n\tvirtual unsigned int GetSendResult() =0;\n\tvirtual void SendEof() =0;\n};\n\n#ifdef HIGHRES_TIMER_AVAILABLE\n\n//! Network Source\nclass CRYPTOPP_NO_VTABLE NetworkSource : public NonblockingSource\n{\npublic:\n\tNetworkSource(BufferedTransformation *attachment);\n\n\tunsigned int GetMaxWaitObjectCount() const\n\t\t{return GetReceiver().GetMaxWaitObjectCount() + AttachedTransformation()->GetMaxWaitObjectCount();}\n\tvoid GetWaitObjects(WaitObjectContainer &container);\n\n\tunsigned int GeneralPump2(unsigned long &byteCount, bool blockingOutput=true, unsigned long maxTime=INFINITE_TIME, bool checkDelimiter=false, byte delimiter='\\n');\n\tbool SourceExhausted() const {return m_dataBegin == m_dataEnd && GetReceiver().EofReceived();}\n\nprotected:\n\tvirtual NetworkReceiver & AccessReceiver() =0;\n\tconst NetworkReceiver & GetReceiver() const {return const_cast<NetworkSource *>(this)->AccessReceiver();}\n\nprivate:\n\tSecByteBlock m_buf;\n\tunsigned int m_putSize, m_dataBegin, m_dataEnd;\n\tbool m_waitingForResult, m_outputBlocked;\n};\n\n//! Network Sink\nclass CRYPTOPP_NO_VTABLE NetworkSink : public NonblockingSink\n{\npublic:\n\tNetworkSink(unsigned int maxBufferSize, unsigned int autoFlushBound);\n\n\tunsigned int GetMaxWaitObjectCount() const\n\t\t{return GetSender().GetMaxWaitObjectCount();}\n\tvoid GetWaitObjects(WaitObjectContainer &container)\n\t\t{if (m_wasBlocked || !m_buffer.IsEmpty()) AccessSender().GetWaitObjects(container);}\n\n\tunsigned int Put2(const byte *inString, unsigned int length, int messageEnd, bool blocking);\n\n\tunsigned int TimedFlush(unsigned long maxTime, unsigned int targetSize = 0);\n\n\tvoid SetMaxBufferSize(unsigned int maxBufferSize) {m_maxBufferSize = maxBufferSize; m_buffer.SetNodeSize(STDMIN(16U*1024U+256, maxBufferSize));}\n\tvoid SetAutoFlushBound(unsigned int bound) {m_autoFlushBound = bound;}\n\n\tunsigned int GetMaxBufferSize() const {return m_maxBufferSize;}\n\tunsigned int GetCurrentBufferSize() const {return m_buffer.CurrentSize();}\n\n\tvoid ClearBuffer() {m_buffer.Clear();}\n\n\t//! compute the current speed of this sink in bytes per second\n\tfloat ComputeCurrentSpeed();\n\t//! get the maximum observed speed of this sink in bytes per second\n\tfloat GetMaxObservedSpeed() const {return m_maxObservedSpeed;}\n\nprotected:\n\tvirtual NetworkSender & AccessSender() =0;\n\tconst NetworkSender & GetSender() const {return const_cast<NetworkSink *>(this)->AccessSender();}\n\nprivate:\n\tunsigned int m_maxBufferSize, m_autoFlushBound;\n\tbool m_needSendResult, m_wasBlocked;\n\tByteQueue m_buffer;\n\tunsigned int m_skipBytes;\n\tTimer m_speedTimer;\n\tfloat m_byteCountSinceLastTimerReset, m_currentSpeed, m_maxObservedSpeed;\n};\n\n#endif\t// #ifdef HIGHRES_TIMER_AVAILABLE\n\nNAMESPACE_END\n\n#endif\n\n", "comment_ratio": 0.10526315789473684}
{"lang": "c", "code": "//\n//  SOWXApiManager.h\n//\n//  Created by Sharker on 2021/7/16.\n//\n\n#import <Foundation/Foundation.h>\n#import \"WXApi.h\"\n\nNS_ASSUME_NONNULL_BEGIN\nextern NSString* kWXLoginNotification;\ntypedef NS_ENUM(NSInteger, SOWXReqType) {\n    SOWXReqLoginType,\n    \n};\n@interface SOWXApiManager : NSObject<WXApiDelegate>\n\n+ (instancetype)defaultManager;\n\n/// \u542f\u52a8\u5fae\u4fe1SDK\n- (void)setupWXSDKWithApp:(NSString *)app universalLink:(NSString *)universalLink;\n\n// \u53d1\u8d77\u767b\u5f55\u8bf7\u6c42\n- (void)sendWXRequestWithType:(SOWXReqType)type\n                        scope:(NSString *)scopeCode\n                        state:(NSString *)requestState\n                   completion:(void(^)(BOOL success))completion;\n\n/// \u5df2\u7ecf\u5b89\u88c5\u5fae\u4fe1\n- (BOOL)appWXInstalled;\n\n+ (BOOL)handleOpenURL:(NSURL *)url delegate:(nullable id<WXApiDelegate>)delegate;\n\n\n@end\n\nNS_ASSUME_NONNULL_END\n\n", "comment_ratio": 0.21052631578947367}
{"lang": "c", "code": "\ufeff// -----------------------------------------------\n// File : PtrAlias.h\n// Copyright (c) 2017 yashihei\n// Licensed under the MIT license\n// -----------------------------------------------\n\n#pragma once\n\n#include <memory>\n#include \"Fwd.h\"\n\nnamespace hks {\n\nusing WindowPtr = std::shared_ptr<Window>;\nusing GraphicsPtr = std::shared_ptr<Graphics>;\nusing RenderTargetPtr = std::shared_ptr<RenderTarget>;\nusing ScenePtr = std::shared_ptr<Scene>;\nusing CameraPtr = std::shared_ptr<Camera>;\nusing LightParamPtr = std::shared_ptr<LightParam>;\nusing InputManagerPtr = std::shared_ptr<InputManager>;\nusing AudioManagerPtr = std::shared_ptr<AudioManager>;\nusing AssetsMangerPtr = std::shared_ptr<AssetsManager>;\nusing FPSManagerPtr = std::shared_ptr<FPSManager>;\nusing TimePtr = std::shared_ptr<Time>;\n\nusing ModelPtr = std::shared_ptr<Model>;\nusing SpritePtr = std::shared_ptr<Sprite>;\nusing Sprite2DPtr = std::shared_ptr<Sprite2D>;\n\nusing BasicEffectPtr = std::shared_ptr<BasicEffect>;\nusing SpriteEffectPtr = std::shared_ptr<SpriteEffect>;\nusing ToonEffectPtr = std::shared_ptr<ToonEffect>;\nusing BlurEffectPtr = std::shared_ptr<BlurEffect>;\n\n} // namespace hks\n\nusing CommonStatesPtr = std::shared_ptr<DirectX::CommonStates>;\nusing SpriteFontPtr = std::shared_ptr<DirectX::SpriteFont>;\nusing SpriteBatchPtr = std::shared_ptr<DirectX::SpriteBatch>;\n\n", "comment_ratio": 0.15}
{"lang": "c", "code": "#ifndef HScrollBar_h__\n#define HScrollBar_h__\n\n#include \"ScrollBarControl.h\"\n\nnamespace Base\n{\n\ttemplate<class BaseType, class SubType> \n\tBaseType * GenericObjectCreationFunction();\n}\n\nnamespace Graphics\n{\n\t///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t/// @brief Class Declaration for a Horizontal Scrollbar UI Control\n\t///\n\t///\n\t///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\tclass cHScrollBar\n\t\t: public cScrollBarControl\n\t{\n\tpublic:\n\t\tstatic Base::cHashedString\tGetName()  {return m_Name; }\n\t\t~cHScrollBar();\n\n\tprivate:\n\t\tcHScrollBar();\n\t\tshared_ptr<IBaseControl> VDuplicate();\n\t\tbool VOnMouseMove(const int X, const int Y);\n\t\tvoid VSetAbsolutePosition();\n\t\tvoid VSetSize(const Base::cVector2 & vSize);\n\t\tvoid VSetThumbPosition(const int iNewPosition);\n\t\tvoid VAutoSizeThumb();\n\n\tprivate:\n\t\tstatic Base::cHashedString\tm_Name;\t///< The control name\n\n\tprivate:\n\t\ttemplate<class BaseType, class SubType> \n\t\tfriend BaseType * Base::GenericObjectCreationFunction();\n\t};\n}\n#endif // HScrollBar_h__\n\n", "comment_ratio": 0.3018867924528302}
{"lang": "c", "code": "#ifndef WATCHMOVEMENTSUPPLIER_H\n#define WATCHMOVEMENTSUPPLIER_H\n\n#include \"A4988.h\"\n#include \"WatchRequirement.h\"\n\ntypedef std::pair<WatchRequirement, bool> WatchRequirementTurningLikeStepper;\n\nclass WatchMovementSupplier\n{\npublic:\n    WatchMovementSupplier();\n    \n    std::vector<WatchRequirementTurningLikeStepper>& GetAllRequirements();\n    void SetStepper(A4988 stepper);\n    A4988& GetStepper();\n    short GetRPM();\n    void SetRPM(short rpm);\n    void Rotate(double degree);\n    void RemoveRequirementAtIndex(int index);\n    \nprivate:\n    std::vector<WatchRequirementTurningLikeStepper> requirements_;\n    A4988 stepper_;\n};\n\n#endif // #ifndef WATCHMOVEMENTSUPPLIER_H\n\n", "comment_ratio": 0.18181818181818182}
{"lang": "c", "code": "#import <libobjc.A.dylib/NSSecureCoding.h>\n\n@class NSDate, NSMutableArray, NSUUID;\n\n@interface PCSMTT : NSObject <NSSecureCoding> {\n\n\tNSDate* _startTime;\n\tNSMutableArray* _completedPoints;\n\tNSUUID* _parentUUID;\n\tNSUUID* _UUID;\n\tdouble _time;\n\n}\n\n@property (retain) NSDate * startTime;                            //@synthesize startTime=_startTime - In the implementation block\n@property (retain) NSMutableArray * completedPoints;              //@synthesize completedPoints=_completedPoints - In the implementation block\n@property (readonly) NSUUID * parentUUID;                         //@synthesize parentUUID=_parentUUID - In the implementation block\n@property (readonly) NSUUID * UUID;                               //@synthesize UUID=_UUID - In the implementation block\n@property (readonly) double time;                                 //@synthesize time=_time - In the implementation block\n+(BOOL)supportsSecureCoding;\n-(double)time;\n-(id)jsonDict;\n-(NSUUID *)UUID;\n-(NSDate *)startTime;\n-(void)setStartTime:(NSDate *)arg1 ;\n-(void)start;\n-(id)init;\n-(id)initWithCoder:(id)arg1 ;\n-(void)encodeWithCoder:(id)arg1 ;\n-(void)stop;\n-(NSUUID *)parentUUID;\n-(id)description;\n-(id)measurePoint:(id)arg1 ;\n-(void)completePoint:(id)arg1 ;\n-(NSMutableArray *)completedPoints;\n-(id)initWithMTT:(id)arg1 ;\n-(void)measure:(id)arg1 block:(/*^block*/id)arg2 ;\n-(void)measure:(id)arg1 success:(BOOL)arg2 time:(double)arg3 ;\n-(void)setCompletedPoints:(NSMutableArray *)arg1 ;\n@end\n\n\n", "comment_ratio": 0.1}
{"lang": "c", "code": "#import <FrontBoardServices/FBSOrientationObserver.h>\n\n#import \"CSDOrientationObserver-Protocol.h\"\n\n@interface FBSOrientationObserver (CSDProximityController) <CSDOrientationObserver>\n\n// Remaining properties\n@property(copy, nonatomic) CDUnknownBlockType handler;\n@end\n\n\n", "comment_ratio": 0.35294117647058826}
{"lang": "c", "code": "#ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_SCROLL_SCROLLBAR_LAYER_DELEGATE_H_\n#define THIRD_PARTY_BLINK_RENDERER_PLATFORM_SCROLL_SCROLLBAR_LAYER_DELEGATE_H_\n\n#include <memory>\n\n#include \"base/macros.h\"\n#include \"cc/input/scrollbar.h\"\n#include \"cc/paint/paint_canvas.h\"\n#include \"third_party/blink/renderer/platform/heap/handle.h\"\n#include \"third_party/blink/renderer/platform/platform_export.h\"\n\nnamespace blink {\n\nclass Scrollbar;\nclass ScrollbarTheme;\n\n// Implementation of cc::Scrollbar, providing a delegate to query about\n// scrollbar state and to paint the image in the scrollbar.\nclass PLATFORM_EXPORT ScrollbarLayerDelegate : public cc::Scrollbar {\n public:\n  ScrollbarLayerDelegate(blink::Scrollbar& scrollbar,\n                         float device_scale_factor);\n  ~ScrollbarLayerDelegate() override;\n\n  // cc::Scrollbar implementation.\n  cc::ScrollbarOrientation Orientation() const override;\n  bool IsLeftSideVerticalScrollbar() const override;\n  bool HasThumb() const override;\n  bool IsOverlay() const override;\n  gfx::Point Location() const override;\n  int ThumbThickness() const override;\n  int ThumbLength() const override;\n  gfx::Rect TrackRect() const override;\n  float ThumbOpacity() const override;\n  bool NeedsPaintPart(cc::ScrollbarPart part) const override;\n  bool HasTickmarks() const override;\n  void PaintPart(cc::PaintCanvas* canvas,\n                 cc::ScrollbarPart part,\n                 const gfx::Rect& content_rect) override;\n\n  bool UsesNinePatchThumbResource() const override;\n  gfx::Size NinePatchThumbCanvasSize() const override;\n  gfx::Rect NinePatchThumbAperture() const override;\n\n private:\n  // Accessed by main and compositor threads, e.g., the compositor thread\n  // checks |Orientation()|.\n  CrossThreadPersistent<blink::Scrollbar> scrollbar_;\n\n  ScrollbarTheme& theme_;\n  float device_scale_factor_;\n\n  DISALLOW_COPY_AND_ASSIGN(ScrollbarLayerDelegate);\n};\n\n}  // namespace blink\n\n#endif  // THIRD_PARTY_BLINK_RENDERER_PLATFORM_SCROLL_SCROLLBAR_LAYER_DELEGATE_H_\n\n", "comment_ratio": 0.15873015873015872}
{"lang": "c", "code": "#pragma once\n#include \"core/providers/cuda/cuda_kernel.h\"\n\nnamespace onnxruntime {\nnamespace contrib {\nnamespace cuda {\n\nusing namespace onnxruntime::cuda;\n\ntemplate <typename T, typename U, typename V, bool simplified>\nclass LayerNorm final : public CudaKernel {\n public:\n  LayerNorm(const OpKernelInfo& op_kernel_info);\n\n  Status ComputeInternal(OpKernelContext* ctx) const override;\n\n private:\n  int64_t axis_;\n  double epsilon_;\n};\n\n}  // namespace cuda\n}  // namespace contrib\n}  // namespace onnxruntime\n\n", "comment_ratio": 0.17857142857142858}
{"lang": "c", "code": "#ifndef PickViewCommon_h\n#define PickViewCommon_h\n\n#define kScreenWidth [UIScreen mainScreen].bounds.size.width\n#define kScreenHeight [UIScreen mainScreen].bounds.size.height\n#define kScreenBound [UIScreen mainScreen].bounds\n#define kPickerSize self.datePicker.frame.size\n#define RGBA(r, g, b, a) ([UIColor colorWithRed:(r / 255.0) green:(g / 255.0) blue:(b / 255.0) alpha:a])\n#define RGB(r, g, b) RGBA(r,g,b,1)\n#define ColorMain RGB(250, 197, 50)\n#define ColorLine RGB(236, 236, 236)\n\n\n#define MAXYEAR 2050\n#define MINYEAR 1970\n\n\n#endif /* PickViewCommon_h */\n\n", "comment_ratio": 0.25925925925925924}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n\n@interface AppDelegate : UIResponder <UIApplicationDelegate>\n\n@property (strong, nonatomic) UIWindow *window;\n\n\n@end\n\n\n", "comment_ratio": 0.3888888888888889}
{"lang": "c", "code": "#ifndef MINDSPORE_CCSRC_PIPELINE_JIT_VALIDATOR_H_\n#define MINDSPORE_CCSRC_PIPELINE_JIT_VALIDATOR_H_\n\n#include <string>\n#include <iostream>\n#include <memory>\n#include <unordered_set>\n#include \"frontend/operator/ops.h\"\n#include \"ir/anf.h\"\n#include \"utils/misc.h\"\n\nnamespace mindspore {\nnamespace validator {\nvoid Validate(const FuncGraphPtr &func_graph);\nvoid ValidateAbstract(const AnfNodePtr &node);\nvoid ValidateOperation(const AnfNodePtr &node);\n}  // namespace validator\n}  // namespace mindspore\n\n#endif  // MINDSPORE_CCSRC_PIPELINE_JIT_VALIDATOR_H__\n\n", "comment_ratio": 0.1282051282051282}
{"lang": "c", "code": "#import \"ALPPassBasePage.h\"\n\n@class ALPPassTabView, AUCustomNavigationBar, NSDictionary, NSMutableArray;\n\n@interface ALPPassHomePage : ALPPassBasePage\n{\n    ALPPassTabView *_tabView;\n    NSMutableArray *_contentPages;\n    ALPPassBasePage *_curPage;\n    AUCustomNavigationBar *_customNavi;\n    long long _pageIndex;\n    NSDictionary *_schemeParams;\n}\n\n@property(retain, nonatomic) NSDictionary *schemeParams; // @synthesize schemeParams=_schemeParams;\n@property(nonatomic) long long pageIndex; // @synthesize pageIndex=_pageIndex;\n@property(retain, nonatomic) AUCustomNavigationBar *customNavi; // @synthesize customNavi=_customNavi;\n@property(nonatomic) __weak ALPPassBasePage *curPage; // @synthesize curPage=_curPage;\n@property(retain, nonatomic) NSMutableArray *contentPages; // @synthesize contentPages=_contentPages;\n@property(retain, nonatomic) ALPPassTabView *tabView; // @synthesize tabView=_tabView;\n- (void).cxx_destruct;\n- (void)promotionViewDidFinishLoading:(id)arg1 spaceCode:(id)arg2;\n- (void)hideContentController:(id)arg1;\n- (void)displayContentController:(id)arg1;\n- (_Bool)onTabSwitch:(long long)arg1;\n- (void)scroolToIndex:(long long)arg1;\n- (id)getTabItemLogParams:(long long)arg1;\n- (void)writeTabLog:(long long)arg1 isClick:(_Bool)arg2;\n- (void)clickTabBarItemWithIndex:(long long)arg1;\n- (void)updateTabInfo:(id)arg1;\n- (void)switchTab:(long long)arg1 animated:(_Bool)arg2;\n- (void)createTabView;\n- (void)openOldHomePage;\n- (void)setTabNoticeData;\n- (id)pageParams;\n- (id)pageSpm;\n- (id)pageTitle;\n- (void)stopTitleLoading;\n- (void)showLoading:(id)arg1;\n- (void)preload;\n- (void)reload;\n- (void)load;\n- (id)listModel;\n- (void)createMainModel;\n- (void)createCustomNavi;\n- (_Bool)autohideNavigationBar;\n- (id)customNavigationBar;\n- (void)viewWillDestroy;\n- (void)viewDidDisappear:(_Bool)arg1;\n- (void)viewWillDisappear:(_Bool)arg1;\n- (void)viewDidAppear:(_Bool)arg1;\n- (void)viewWillAppear:(_Bool)arg1;\n- (void)viewDidLoad;\n- (id)initWithQuery:(id)arg1 params:(id)arg2;\n- (void)dealloc;\n\n@end\n\n\n", "comment_ratio": 0.16923076923076924}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n#import \"FSIPModel.h\"\n#import \"FuSoft.h\"\n\n#define Key_CameraRoll      @\"cameraRoll\"\n\n@interface FSImagePicker : NSObject\n\n@property (nonatomic,strong) NSDictionary<NSString *,PHAssetCollection *>               *allThumbnails;\n@property (nonatomic,strong) NSArray<FSIPModel*>                                        *allModels;\n@property (nonatomic,strong) NSArray<FSIPModel*>                                        *selectedImages;\n\n// \u662f\u5426\u4e3a\u539f\u56fe\n@property (nonatomic,assign) BOOL isOriginal;\n\n// \u8bf7\u6c42\u8d44\u6e90\n- (void)requestAllResources;\n\n// \u83b7\u53d6\u6240\u9009\u62e9\u7684\u56fe\u7247\u7684\u5927\u5c0f\n- (NSInteger)sizeOfSelectedImages;\n\n// \u83b7\u53d6\u6240\u6709\u56fe\u7247\u7684Model\u96c6\u5408\n- (NSDictionary<NSString *,PHAssetCollection *> *)allAssetCollection;\n\n// \u7a0d\u5fae\u6e05\u6670\u7684\u56fe\u7247\uff0c\u4f46\u4e0d\u662f\u539f\u56fe\n+ (void)thumbnailsImageForModel:(FSIPModel *)model completion:(void(^)(UIImage *bImage))completion;\n\n- (NSArray *)enumerateAssetsInAssetCollection:(PHAssetCollection *)assetCollection original:(BOOL)original;\n\n// \u56fe\u7247\u5927\u5c0f\n- (NSInteger)sizeForImageWithAsset:(PHAsset *)asset;\n+ (NSInteger)sizeForAsset:(PHAsset *)asset;\n\n- (NSArray *)selectedAssetsWithModels;\n\n- (NSArray *)selectedImagesWithModels;\n\n+ (UIImage *)theNewestImageFromAlbum;\n- (UIImage *)theNewestImageFromAlbum;// \u83b7\u53d6\u76f8\u518c\u4e2d\u6700\u65b0\u7684\u90a3\u5f20\u56fe\u7247\uff0ceg.\u5728\u5c4f\u5e55\u622a\u56fe\u65f6\u8c03\u7528\u83b7\u53d6\n\n@end\n\n", "comment_ratio": 0.28}
{"lang": "c", "code": "#pragma once\n\n/// \\file\n/// Implementation of the Diligent::SamplerBase template class\n\n#include \"Sampler.h\"\n#include \"DeviceObjectBase.h\"\n#include \"RenderDeviceBase.h\"\n\nnamespace Diligent\n{\n\n/// Template class implementing base functionality for a sampler object.\n\n/// \\tparam BaseInterface - base interface that this class will inheret\n///                          (Diligent::ISamplerD3D11, Diligent::ISamplerD3D12,\n///                           Diligent::ISamplerGL or Diligent::ISamplerVk).\n/// \\tparam RenderDeviceImplType - type of the render device implementation\n///                                (Diligent::RenderDeviceD3D11Impl, Diligent::RenderDeviceD3D12Impl,\n///                                 Diligent::RenderDeviceGLImpl, or Diligent::RenderDeviceVkImpl)\ntemplate <class BaseInterface, class RenderDeviceImplType>\nclass SamplerBase : public DeviceObjectBase<BaseInterface, RenderDeviceImplType, SamplerDesc>\n{\npublic:\n    using TDeviceObjectBase = DeviceObjectBase<BaseInterface, RenderDeviceImplType, SamplerDesc>;\n\n    /// \\param pRefCounters - reference counters object that controls the lifetime of this sampler.\n    /// \\param pDevice - pointer to the device.\n    /// \\param SamDesc - sampler description.\n    /// \\param bIsDeviceInternal - flag indicating if the sampler is an internal device object and\n    ///\t\t\t\t\t\t\t   must not keep a strong reference to the device.\n    SamplerBase(IReferenceCounters* pRefCounters, RenderDeviceImplType* pDevice, const SamplerDesc& SamDesc, bool bIsDeviceInternal = false) :\n        TDeviceObjectBase{pRefCounters, pDevice, SamDesc, bIsDeviceInternal}\n    {}\n\n    ~SamplerBase()\n    {\n        /// \\note Destructor cannot directly remove the object from the registry as this may cause a\n        ///       deadlock.\n        auto& SamplerRegistry = this->GetDevice()->GetSamplerRegistry();\n        SamplerRegistry.ReportDeletedObject();\n    }\n\n    IMPLEMENT_QUERY_INTERFACE_IN_PLACE(IID_Sampler, TDeviceObjectBase)\n};\n\n} // namespace Diligent\n\n", "comment_ratio": 0.2535211267605634}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n\n@interface YKViewBase : UIView\n@property (nonatomic,assign) CGRect contentRect;\n@property (nonatomic,assign) CGFloat chartHeight;\n@property (nonatomic,assign) CGFloat chartWidth;\n\n\n\n\n- (void)setupChartOffsetWithLeft:(CGFloat)left\n                             top:(CGFloat)top\n                           right:(CGFloat)right\n                          bottom:(CGFloat)bottom;\n\n- (void)notifyDataSetChanged;\n\n- (void)notifyDeviceOrientationChanged;\n- (BOOL)isInBoundsX:(CGFloat)x;\n\n- (BOOL)isInBoundsY:(CGFloat)y;\n\n- (BOOL)isInBoundsX:(CGFloat)x\n                  y:(CGFloat)y;\n\n- (BOOL)isInBoundsLeft:(CGFloat)x;\n- (BOOL)isInBoundsRight:(CGFloat)x;\n\n- (BOOL)isInBoundsTop:(CGFloat)y;\n\n- (BOOL)isInBoundsBottom:(CGFloat)y;\n\n- (CGFloat)contentTop;\n- (CGFloat)contentLeft;\n- (CGFloat)contentRight;\n- (CGFloat)contentBottom;\n- (CGFloat)contentWidth;\n- (CGFloat)contentHeight;\n@end\n\n", "comment_ratio": 0.14583333333333334}
{"lang": "c", "code": "#ifndef DiAllocator_h__\n#define DiAllocator_h__\n\n#include <new>\n\nnamespace Demi\n{\n    struct DiAllocatorBlock;\n    struct DiAllocatorNode;\n\n    struct DiAllocatorBlock\n    {\n        unsigned            mNodeSize;\n        unsigned            mCapacity;\n        DiAllocatorNode*    mFree;\n        DiAllocatorBlock*   mNext;\n    };\n\n    struct DiAllocatorNode\n    {\n        DiAllocatorNode* mNext;\n    };\n\n    /// Init a fixed-size allocator with the node size and initial capacity.\n    DI_MISC_API DiAllocatorBlock* AllocatorInitialize(unsigned nodeSize, unsigned initialCapacity = 1);\n    /// Uninitialize a fixed-size allocator. Frees all blocks in the chain.\n    DI_MISC_API void AllocatorUninitialize(DiAllocatorBlock* allocator);\n    /// Reserve a node. Creates a new block if necessary.\n    DI_MISC_API void* AllocatorReserve(DiAllocatorBlock* allocator);\n    /// Free a node. Does not free any blocks.\n    DI_MISC_API void AllocatorFree(DiAllocatorBlock* allocator, void* ptr);\n\n    /// %Allocator template class. Allocates objects of a specific class.\n    template <class T> \n    class DI_MISC_API DiAllocator\n    {\n    public:\n        DiAllocator(unsigned initialCapacity = 0) :\n          mAllocator(0)\n          {\n              if (initialCapacity)\n              {\n                  mAllocator = AllocatorInitialize(sizeof(T), initialCapacity);\n              }\n          }\n\n          ~DiAllocator()\n          {\n              AllocatorUninitialize(mAllocator);\n          }\n\n          /// Reserve and default-construct an object.\n          T* Reserve()\n          {\n              if (!mAllocator)\n              {\n                  mAllocator = AllocatorInitialize(sizeof(T));\n              }\n              T* newObject = static_cast<T*>(AllocatorReserve(mAllocator));\n              new(newObject) T();\n\n              return newObject;\n          }\n\n          /// Reserve and copy-construct an object.\n          T* Reserve(const T& object)\n          {\n              if (!mAllocator)\n              {\n                  mAllocator = AllocatorInitialize(sizeof(T));\n              }\n              T* newObject = static_cast<T*>(AllocatorReserve(mAllocator));\n              new(newObject) T(object);\n\n              return newObject;\n          }\n\n          /// Destruct and free an object.\n          void Free(T* object)\n          {\n              (object)->~T();\n              AllocatorFree(mAllocator, object);\n          }\n\n    private:\n        /// Prevent copy construction.\n        DiAllocator(const DiAllocator<T>& rhs);\n\n        /// Prevent assignment.\n        DiAllocator<T>& operator = (const DiAllocator<T>& rhs);\n\n        /// Allocator block.\n        DiAllocatorBlock* mAllocator;\n    };\n}\n#endif // Allocator_h__\n\n", "comment_ratio": 0.12727272727272726}
{"lang": "c", "code": "#ifndef RCL_INTERFACES__MSG__PARAMETER_DESCRIPTOR__ROSIDL_TYPESUPPORT_FASTRTPS_C_H_\n#define RCL_INTERFACES__MSG__PARAMETER_DESCRIPTOR__ROSIDL_TYPESUPPORT_FASTRTPS_C_H_\n\n#include <stddef.h>\n\n#include \"rosidl_generator_c/message_type_support_struct.h\"\n#include \"rosidl_typesupport_interface/macros.h\"\n\n#include \"rcl_interfaces/msg/rosidl_typesupport_fastrtps_c__visibility_control.h\"\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\nROSIDL_TYPESUPPORT_FASTRTPS_C_PUBLIC_rcl_interfaces\nsize_t get_serialized_size_rcl_interfaces__msg__ParameterDescriptor(\n  const void * untyped_ros_message,\n  size_t current_alignment);\n\nROSIDL_TYPESUPPORT_FASTRTPS_C_PUBLIC_rcl_interfaces\nsize_t max_serialized_size_rcl_interfaces__msg__ParameterDescriptor(\n  bool & full_bounded,\n  size_t current_alignment);\n\nROSIDL_TYPESUPPORT_FASTRTPS_C_PUBLIC_rcl_interfaces\nconst rosidl_message_type_support_t *\n  ROSIDL_TYPESUPPORT_INTERFACE__MESSAGE_SYMBOL_NAME(rosidl_typesupport_fastrtps_c, rcl_interfaces, msg, ParameterDescriptor)();\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif  // RCL_INTERFACES__MSG__PARAMETER_DESCRIPTOR__ROSIDL_TYPESUPPORT_FASTRTPS_C_H_\n\n", "comment_ratio": 0.10256410256410256}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface UIImage (SebasUtility)\n/**\n * Returns the data converted to PNG representation.\n * (read-only)\n */\n@property (nonatomic, readonly) NSData *util_toPNG;\n/**\n * Returns the data converted to JPEG representation that is best quality.\n * (read-only)\n */\n@property (nonatomic, readonly) NSData *util_toJPEG;\n/**\n * Creates new instance filled with given color and size.\n */\n+ (instancetype)util_imageWithColor:(UIColor *)color size:(CGSize)size;\n\n/**\n * Returns the data converted to JPEG representation with quality.\n *\n * @param quality The value 0~1.0\n */\n- (NSData *)util_toJPEGWithQuality:(CGFloat)quality;\n/**\n * Returns resized image with given size of rect.\n *\n * @param rect A rect.\n * @param maintainingAspectRatio If YES, maintains aspect ratio.\n * @return Resized image.\n */\n- (UIImage *)util_resizedWithRect:(CGRect)rect maintainingAspectRatio:(BOOL)maintainingAspectRatio;\n/**\n * Returns the resized image with given size.\n *\n * @param width A width.\n * @param height A height.\n * @param maintainingAspectRatio If YES, maintains aspect ratio.\n * @return Resized image.\n */\n- (UIImage *)util_resizedWithWidth:(CGFloat)width\n                            height:(CGFloat)height\n            maintainingAspectRatio:(BOOL)maintainingAspectRatio;\n/**\n * Returns the cropped image.\n *\n * @param rect A rect.\n * @return Cropped image.\n */\n- (UIImage *)util_croppedInRect:(CGRect)rect;\n/**\n * Returns the masked image using given mask image.\n *\n * @param maskImage A mask image.\n * @return Masked image.\n */\n- (UIImage *)util_maskedWithMaskImage:(UIImage *)maskImage;\n@end\n\nNS_ASSUME_NONNULL_END\n\n", "comment_ratio": 0.2727272727272727}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n\n@interface YWTableViewHeadView : UITableViewHeaderFooterView\n\n@property (nonatomic, strong) UIScrollView *rightScrollView;\n\n@property (nonatomic, strong) UILabel *nameLabel;\n- (instancetype)initWithReuseIdentifier:(NSString *)reuseIdentifier\n                              parameter:(NSDictionary *)parameter;\n@end\n\n", "comment_ratio": 0.3684210526315789}
{"lang": "c", "code": "#import <HexFiend/HFByteArray.h>\n\n@class NSMutableData;\n\n@interface HFFullMemoryByteArray : HFByteArray\n{\n    NSMutableData *data;\n}\n\n- (void)insertByteSlice:(id)arg1 inRange:(CDStruct_91ee6ea3)arg2;\n- (id)byteSlices;\n- (id)subarrayWithRange:(CDStruct_91ee6ea3)arg1;\n- (void)copyBytes:(char *)arg1 range:(CDStruct_91ee6ea3)arg2;\n- (unsigned long long)length;\n- (void)dealloc;\n- (id)init;\n\n@end\n\n\n", "comment_ratio": 0.19230769230769232}
{"lang": "c", "code": "#ifndef TENSORFLOW_CORE_KERNELS_BATCHING_UTIL_BATCH_INPUT_TASK_H_\n#define TENSORFLOW_CORE_KERNELS_BATCHING_UTIL_BATCH_INPUT_TASK_H_\n\n#include <algorithm>\n#include <atomic>\n#include <functional>\n#include <memory>\n#include <utility>\n\n#include \"absl/base/call_once.h\"\n#include \"absl/synchronization/mutex.h\"\n#include \"tensorflow/core/kernels/batching_util/batch_scheduler.h\"\n#include \"tensorflow/core/kernels/batching_util/concat_split_util.h\"\n#include \"tensorflow/core/platform/errors.h\"\n#include \"tensorflow/core/platform/thread_annotations.h\"\n#include \"tensorflow/core/util/incremental_barrier.h\"\n\nnamespace tensorflow {\nnamespace serving {\n\ntemplate <typename TaskType>\nclass BatchInputTask;\n\n// A RAII-style object that holds a ref-counted batch-input-task, and\n// represents a slice of batch-input-task.\n\n// To be handed out to callers of `BatchInputTask::GetNextTaskHandle` quickly\n// (i.e. not necessarily waiting for input split)\n//\n// GetSplitTask evaluates to the slice of task.\ntemplate <typename TaskType>\nclass BatchInputTaskHandle {\n public:\n  BatchInputTaskHandle(\n      std::shared_ptr<BatchInputTask<TaskType>> batch_input_task, int split_id);\n\n  // Should be called once. Returns nullptr on subsequent calls.\n  std::unique_ptr<TaskType> GetSplitTask();\n\n  int split_id() const { return split_id_; }\n\n private:\n  std::shared_ptr<BatchInputTask<TaskType>> batch_input_task_;\n\n  // The handle evaluates to the N-th slice of original task, and\n  // N is `split_id_`.\n  const int split_id_;\n\n  std::atomic<bool> once_{false};\n};\n\n// BatchInputTask encapsulates a input (`input_task`) to be batched and the\n// information to get task splits after it's enqueued, so as to support lazy\n// split of a task.\n//\n// Input split could reduce excessive padding for efficiency; lazy split\n// moves task-split out of the critical path of enqueue and dequeue and reduces\n// contention.\n//\n// BatchInputTask is thread safe.\n//\n// Usage:\n//\n// ... a deque with frequent enqueue and dequeue operations ...\n// std::deque<shared_ptr<BatchInputTask<BatchTask>>> deque_ TF_GUARDED_BY(mu_);\n//\n// ... input_task provided by batch scheduling  ...\n// std::unique_ptr<TaskType> input_task;\n//\n// ... Enqueue path ...\n//\n// {\n//   mutex_lock l(mu_);\n//   ...... construct `batch_input_task` quickly without split ......\n//   std::shared_ptr<BatchInputTask<BatchTask>> batch_input_task;\n//   deque_.push_back(batch_input_task);\n// }\n//\n// ... Dequeue path ...\n// vector<std::unique_ptr<BatchInputTaskHandle<TaskType>>> handles;\n// {\n//    mutex_lock l(mu_);\n//    auto handle = deque_.front()->GetNextTaskHandle();\n//    handles.push_back(std::move(handle));\n//    ... call `GetNextTaskHandle` until we accumuate enough to form a batch ...\n// }\n// ...... `mu_` is released ......\n// Caller calls `BatchInputTaskHandle::GetSplitTask` to lazily evaluate each\n// task in the batch.\ntemplate <typename TaskType>\nclass BatchInputTask\n    : public std::enable_shared_from_this<BatchInputTask<TaskType>> {\n public:\n  using BatchSplitFunc = std::function<Status(\n      std::unique_ptr<TaskType>* input_task, int first_output_task_size,\n      int input_batch_size_limit,\n      std::vector<std::unique_ptr<TaskType>>* output_tasks)>;\n\n  // TODO(b/194294263):\n  // Add a SplitMetadataFunc in constructor, so users of this class specify\n  // both how to split, and how to compute split metadata in a consistent way.\n  BatchInputTask(std::unique_ptr<TaskType> input_task,\n                 int open_batch_remaining_slot, int batch_size_limit,\n                 BatchSplitFunc split_func);\n\n  // A stateful method to hand out the next task to be processed.\n  // Returns nullptr if all batches are given out.\n  std::unique_ptr<BatchInputTaskHandle<TaskType>> GetNextTaskHandle();\n\n  // Following method exposes split metadata of this task.\n  // Metadata are used to determine batch construction so needed before split\n  // happens.\n  //\n  // Task size of `input_task`\n  size_t size() const;\n\n  // The number of batches the input spans.\n  int num_batches() const;\n\n  // The number of new batches this input adds.\n  int num_new_batches() const;\n\n  // The task size of the last batch.\n  int tail_batch_task_size() const;\n\n private:\n  friend class BatchInputTaskHandle<TaskType>;\n\n  std::unique_ptr<TaskType> GetSplitTask(int split_id);\n\n  Status SplitBatches(std::vector<std::unique_ptr<TaskType>>* output_tasks);\n\n  std::unique_ptr<TaskType> input_task_;\n\n  const int input_task_size_ = 0;\n  const int open_batch_remaining_slot_;\n\n  const int batch_size_limit_;\n\n  const BatchSplitFunc split_func_;\n\n  // The number of batches that this input appends to.\n  // Should be either zero or one.\n  const int num_batches_reused_ = 0;\n\n  // The number of batches this input spans over.\n  int num_batches_ = 0;\n\n  // The task size of the last batch.\n  int tail_batch_task_size_;\n\n  mutable absl::once_flag once_;\n\n  std::vector<std::unique_ptr<TaskType>> task_splits_;\n  Status split_status_;\n\n  mutable mutex mu_;\n  int next_task_id_ TF_GUARDED_BY(mu_) = 0;\n};\n\n//\n// Implementation details. API readers may skip.\n//\n\ntemplate <typename TaskType>\nBatchInputTaskHandle<TaskType>::BatchInputTaskHandle(\n    std::shared_ptr<BatchInputTask<TaskType>> batch_input_task, int split_id)\n    : batch_input_task_(batch_input_task), split_id_(split_id) {}\n\ntemplate <typename TaskType>\nstd::unique_ptr<TaskType> BatchInputTaskHandle<TaskType>::GetSplitTask() {\n  if (once_.load(std::memory_order_acquire)) {\n    return nullptr;\n  }\n  once_.store(true, std::memory_order_release);\n  return batch_input_task_->GetSplitTask(split_id_);\n}\n\ntemplate <typename TaskType>\nBatchInputTask<TaskType>::BatchInputTask(\n    std::unique_ptr<TaskType> input_task, int open_batch_remaining_slot,\n    int batch_size_limit,\n    std::function<Status(std::unique_ptr<TaskType>* input_task,\n                         int first_output_task_size, int input_batch_size_limit,\n                         std::vector<std::unique_ptr<TaskType>>* output_tasks)>\n        split_func)\n    : input_task_(std::move(input_task)),\n      input_task_size_(input_task_->size()),\n      open_batch_remaining_slot_(open_batch_remaining_slot),\n      batch_size_limit_(batch_size_limit),\n      split_func_(split_func),\n      num_batches_reused_((open_batch_remaining_slot_ > 0) ? 1 : 0) {\n  // The total task size starting from current open batch, after this task is\n  // enqueued.\n  const int task_size_from_open_batch =\n      (open_batch_remaining_slot_ > 0)\n          ? (input_task_size_ + batch_size_limit_ - open_batch_remaining_slot_)\n          : input_task_size_;\n\n  num_batches_ =\n      (task_size_from_open_batch + batch_size_limit_ - 1) / batch_size_limit_;\n\n  tail_batch_task_size_ = task_size_from_open_batch % batch_size_limit_;\n  if (tail_batch_task_size_ == 0) {\n    tail_batch_task_size_ = batch_size_limit_;\n  }\n}\n\ntemplate <typename TaskType>\nsize_t BatchInputTask<TaskType>::size() const {\n  return input_task_size_;\n}\n\ntemplate <typename TaskType>\nint BatchInputTask<TaskType>::num_batches() const {\n  return num_batches_;\n}\n\ntemplate <typename TaskType>\nint BatchInputTask<TaskType>::tail_batch_task_size() const {\n  return tail_batch_task_size_;\n}\n\ntemplate <typename TaskType>\nint BatchInputTask<TaskType>::num_new_batches() const {\n  return num_batches_ - num_batches_reused_;\n}\n\ntemplate <typename TaskType>\nstd::unique_ptr<BatchInputTaskHandle<TaskType>>\nBatchInputTask<TaskType>::GetNextTaskHandle() {\n  mutex_lock l(mu_);\n  if (next_task_id_ < num_batches_) {\n    auto handle = std::make_unique<BatchInputTaskHandle<TaskType>>(\n        this->shared_from_this(), next_task_id_);\n    next_task_id_++;\n    return handle;\n  }\n  return nullptr;\n}\n\ntemplate <typename TaskType>\nstd::unique_ptr<TaskType> BatchInputTask<TaskType>::GetSplitTask(int split_id) {\n  absl::call_once(once_,\n                  [this]() { split_status_ = SplitBatches(&task_splits_); });\n  if (!split_status_.ok()) {\n    return nullptr;\n  }\n  if (split_id >= 0 && split_id < task_splits_.size()) {\n    return std::move(task_splits_[split_id]);\n  }\n  return nullptr;\n}\n\ntemplate <typename TaskType>\nStatus BatchInputTask<TaskType>::SplitBatches(\n    std::vector<std::unique_ptr<TaskType>>* output_tasks) {\n  return split_func_(&input_task_, open_batch_remaining_slot_,\n                     batch_size_limit_, output_tasks);\n}\n\n}  // namespace serving\n}  // namespace tensorflow\n\n#endif  // TENSORFLOW_CORE_KERNELS_BATCHING_UTIL_BATCH_INPUT_TASK_H_\n\n", "comment_ratio": 0.2597864768683274}
{"lang": "c", "code": "#import <objc/NSObject.h>\n\n@interface PSTNHelper : NSObject\n{\n}\n\n+ (void)NotifyWithData:(id)arg1;\n+ (void)HandleExtNotifydata:(id)arg1 andRoomId:(int)arg2 andRoomKey:(unsigned long long)arg3;\n+ (void)DataNotifyWithData:(id)arg1;\n+ (void)APNSPushWithUsrInfo:(id)arg1;\n\n@end\n\n\n", "comment_ratio": 0.25}
{"lang": "c", "code": "#ifndef ServiceRegistry_ServiceRegistry_h\n#define ServiceRegistry_ServiceRegistry_h\n// -*- C++ -*-\n//\n// Package:     ServiceRegistry\n// Class  :     ServiceRegistry\n//\n/**\\class ServiceRegistry ServiceRegistry.h FWCore/ServiceRegistry/interface/ServiceRegistry.h\n\n Description: Manages the 'thread specific' instance of Services\n\n Usage:\n    <usage>\n\n*/\n//\n// Original Author:  Chris Jones\n//         Created:  Mon Sep  5 13:33:00 EDT 2005\n//\n\n// user include files\n#include \"FWCore/ParameterSet/interface/ParameterSet.h\"\n#include \"FWCore/ServiceRegistry/interface/ServiceLegacy.h\"\n#include \"FWCore/ServiceRegistry/interface/ServiceToken.h\"\n#include \"FWCore/ServiceRegistry/interface/ServicesManager.h\"\n\n// system include files\n#include <vector>\n\n// forward declarations\nnamespace edm {\n  class FwkImpl;\n  namespace serviceregistry {\n    template <typename T>\n    class ServiceWrapper;\n  }\n\n  class ServiceRegistry {\n  public:\n    class Operate {\n    public:\n      Operate(ServiceToken const& iToken) : oldToken_(ServiceRegistry::instance().setContext(iToken)) {}\n      Operate(Operate const&) = delete;                   //stop default\n      Operate const& operator=(Operate const&) = delete;  //stop default\n      ~Operate() { ServiceRegistry::instance().unsetContext(oldToken_); }\n\n      //override operator new to stop use on heap?\n    private:\n      ServiceToken oldToken_;\n    };\n\n    friend class edm::FwkImpl;\n    friend int main(int argc, char* argv[]);\n    friend class Operate;\n\n    ServiceRegistry(ServiceRegistry const&) = delete;                   // stop default\n    ServiceRegistry const& operator=(ServiceRegistry const&) = delete;  // stop default\n    virtual ~ServiceRegistry();\n\n    // ---------- const member functions ---------------------\n    template <typename T>\n    T& get() const {\n      if (nullptr == manager_.get()) {\n        Exception::throwThis(errors::NotFound,\n                             \"Service\"\n                             \" no ServiceRegistry has been set for this thread\");\n      }\n      return manager_->template get<T>();\n    }\n\n    template <typename T>\n    bool isAvailable() const {\n      if (nullptr == manager_.get()) {\n        Exception::throwThis(errors::NotFound,\n                             \"Service\"\n                             \" no ServiceRegistry has been set for this thread\");\n      }\n      return manager_->template isAvailable<T>();\n    }\n    /** The token can be passed to another thread in order to have the\n         same services available in the other thread.\n         */\n    ServiceToken presentToken() const;\n    // ---------- static member functions --------------------\n    static ServiceRegistry& instance();\n\n    // ---------- member functions ---------------------------\n\n    static ServiceToken createServicesFromConfig(std::unique_ptr<ParameterSet> params);\n\n  public:  // Made public (temporarily) at the request of Emilio Meschi.\n    static ServiceToken createSet(std::vector<ParameterSet>&);\n    static ServiceToken createSet(std::vector<ParameterSet>&,\n                                  ServiceToken,\n                                  serviceregistry::ServiceLegacy,\n                                  bool associate = true);\n    /// create a service token that holds the service defined by iService\n    template <typename T>\n    static ServiceToken createContaining(std::unique_ptr<T> iService) {\n      std::vector<edm::ParameterSet> config;\n      auto manager = std::make_shared<serviceregistry::ServicesManager>(config);\n      auto wrapper = std::make_shared<serviceregistry::ServiceWrapper<T> >(std::move(iService));\n      manager->put(wrapper);\n      return manager;\n    }\n    template <typename T>\n    static ServiceToken createContaining(std::unique_ptr<T> iService,\n                                         ServiceToken iToken,\n                                         serviceregistry::ServiceLegacy iLegacy) {\n      std::vector<edm::ParameterSet> config;\n      auto manager = std::make_shared<serviceregistry::ServicesManager>(iToken, iLegacy, config);\n      auto wrapper = std::make_shared<serviceregistry::ServiceWrapper<T> >(std::move(iService));\n      manager->put(wrapper);\n      return manager;\n    }\n    /// create a service token that holds the service held by iWrapper\n    template <typename T>\n    static ServiceToken createContaining(std::shared_ptr<serviceregistry::ServiceWrapper<T> > iWrapper) {\n      std::vector<edm::ParameterSet> config;\n      auto manager = std::make_shared<serviceregistry::ServicesManager>(config);\n      manager->put(iWrapper);\n      return manager;\n    }\n    template <typename T>\n    static ServiceToken createContaining(std::shared_ptr<serviceregistry::ServiceWrapper<T> > iWrapper,\n                                         ServiceToken iToken,\n                                         serviceregistry::ServiceLegacy iLegacy) {\n      std::vector<edm::ParameterSet> config;\n      auto manager = std::make_shared<serviceregistry::ServicesManager>(iToken, iLegacy, config);\n      manager->put(iWrapper);\n      return manager;\n    }\n\n  private:\n    //returns old token\n    ServiceToken setContext(ServiceToken const& iNewToken);\n    void unsetContext(ServiceToken const& iOldToken);\n\n    ServiceRegistry();\n\n    // ---------- member data --------------------------------\n    std::shared_ptr<serviceregistry::ServicesManager> manager_;\n  };\n}  // namespace edm\n\n#endif\n\n", "comment_ratio": 0.17687074829931973}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n#import \"BUInfoPlacedEntity.h\"\n\n@class BUHeader;\n@class BULink;\n@class BUSubdivision;\n@interface BUDepartment : BUInfoPlacedEntity <NSCopying>\n\n@property (strong, nonatomic) BUHeader *header;\n@property (strong, nonatomic) BULink *link;\n@property (readonly, nonatomic) NSArray<BUSubdivision *> *subdivisions;\n\n@end\n\n", "comment_ratio": 0.3181818181818182}
{"lang": "c", "code": "//\n//  LMGDAOfferRemoteStore.h\n//  LMGData\n//\n//  Created by Myroslav Pomazan on 2018-09-12.\n//\n\n#import <Foundation/Foundation.h>\n#import \"LMGDAOfferStore.h\"\n\n@protocol LMGDAOfferRemoteSource <NSObject>\n\n\n- (nullable LMGDAOffer *)getWithDetailParams:(nonnull LMGDADetailsRequestParams *)params\n                                     session:(nonnull LMGDASession *)session\n                                      expect:(NSError *__autoreleasing  _Nullable * _Nullable)error;\n\n\n- (nullable LMGDARedemptionState *)getRedemptionStateForId:(nonnull LMGDAPlatformId *)offerId\n                                                atLocation:(nonnull LMGDAPlatformId *)locationId\n                                                 inSession:(nonnull LMGDASession *)session\n                                                    expect:(NSError * _Nullable * _Nullable)error;\n\n\n- (BOOL)bookmark:(BOOL)bookmark\n           offer:(nonnull LMGDAPlatformId *)offerId\n      atLocation:(nonnull LMGDAPlatformId *)locationId\n       inSession:(nonnull LMGDASession *)session\n          expect:(NSError * _Nullable * _Nullable)error;\n\n\n- (nullable LMGDARedemptionState *)transitionOfferState:(nonnull NSString *)redemptionState\n                                        usingTransition:(nonnull LMGDARedemptionStateTransition *)transition\n                                               withArgs:(nonnull NSArray<LMGDARedemptionTransitionArgument *> *)args\n                                               forOffer:(nonnull LMGDAPlatformId *)offerId\n                                             atLocation:(nonnull LMGDAPlatformId *)locationId\n                                         deviceLocation:(nullable LMGDACoordinate *)coordinate\n                                              inSession:(nonnull LMGDASession *)session\n                                                 expect:(NSError * _Nullable * _Nullable)error;\n\n\n@end\n\n@interface LMGDAOfferRemoteStore : NSObject<LMGDAOfferStore>\n\n- (nonnull instancetype)initWithSource:(nonnull id<LMGDAOfferRemoteSource>)source NS_DESIGNATED_INITIALIZER;\n- (nonnull instancetype)init NS_UNAVAILABLE;\n\n@end\n\n", "comment_ratio": 0.12}
{"lang": "c", "code": "////////////////////////////////////////////////////////////////////////////////////////////////\n// GDNative module that wraps some utility functions that need the VrApi\n\n#ifndef ovrpl_utilities_NS_H\n#define ovrpl_utilities_NS_H\n\n#include \"nativescript_common.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// registers the OvrUtilities class and functions to GDNative and should be called from godot_ovrplatform_nativescript_init\nvoid register_gdnative_utilities(void *p_handle);\n\nGDCALLINGCONV void *ovrpl_utilities_constructor(godot_object *p_instance, void *p_method_data);\nGDCALLINGCONV void ovrpl_utilities_destructor(godot_object *p_instance, void *p_method_data, void *p_user_data);\n\n// uses the internal left and right view matrix to compute the IPD. Returns a float in GDScript\nGDCALLINGCONV godot_variant get_ipd(godot_object *p_instance, void *p_method_data, void *p_user_data, int p_num_args, godot_variant **p_args);\n\n// Expects a Color parameter in GDScript and sets the color multiplier for the default layer used by the VrAPI compositor\nGDCALLINGCONV godot_variant set_default_layer_color_scale(godot_object *p_instance, void *p_method_data, void *p_user_data, int p_num_args, godot_variant **p_args);\n\nGDCALLINGCONV godot_variant get_controller_angular_velocity(godot_object *p_instance, void *p_method_data, void *p_user_data, int p_num_args, godot_variant **p_args);\nGDCALLINGCONV godot_variant get_controller_linear_velocity(godot_object *p_instance, void *p_method_data, void *p_user_data, int p_num_args, godot_variant **p_args);\nGDCALLINGCONV godot_variant get_controller_angular_acceleration(godot_object *p_instance, void *p_method_data, void *p_user_data, int p_num_args, godot_variant **p_args);\nGDCALLINGCONV godot_variant get_controller_linear_acceleration(godot_object *p_instance, void *p_method_data, void *p_user_data, int p_num_args, godot_variant **p_args);\n\nGDCALLINGCONV godot_variant get_head_angular_velocity(godot_object *p_instance, void *p_method_data, void *p_user_data, int p_num_args, godot_variant **p_args);\nGDCALLINGCONV godot_variant get_head_linear_velocity(godot_object *p_instance, void *p_method_data, void *p_user_data, int p_num_args, godot_variant **p_args);\nGDCALLINGCONV godot_variant get_head_angular_acceleration(godot_object *p_instance, void *p_method_data, void *p_user_data, int p_num_args, godot_variant **p_args);\nGDCALLINGCONV godot_variant get_head_linear_acceleration(godot_object *p_instance, void *p_method_data, void *p_user_data, int p_num_args, godot_variant **p_args);\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* !ovrpl_utilities_NS_H */\n\n", "comment_ratio": 0.12195121951219512}
{"lang": "c", "code": "#ifndef CHROME_BROWSER_EXTENSIONS_EXTENSION_WEB_CONTENTS_OBSERVER_H_\n#define CHROME_BROWSER_EXTENSIONS_EXTENSION_WEB_CONTENTS_OBSERVER_H_\n\n#include \"base/basictypes.h\"\n#include \"base/strings/string16.h\"\n#include \"content/public/browser/web_contents_observer.h\"\n#include \"content/public/browser/web_contents_user_data.h\"\n#include \"extensions/common/stack_frame.h\"\n\nnamespace content {\nclass BrowserContext;\n}\n\nnamespace extensions {\nclass Extension;\nstruct Message;\n\n// A web contents observer that's used for WebContents in renderer and extension\n// processes. Grants the renderer access to certain URL patterns for extensions,\n// notifies the renderer that the extension was loaded and routes messages to\n// the MessageService.\nclass ExtensionWebContentsObserver\n    : public content::WebContentsObserver,\n      public content::WebContentsUserData<ExtensionWebContentsObserver> {\n public:\n  virtual ~ExtensionWebContentsObserver();\n\n private:\n  explicit ExtensionWebContentsObserver(content::WebContents* web_contents);\n  friend class content::WebContentsUserData<ExtensionWebContentsObserver>;\n\n  // content::WebContentsObserver overrides.\n  virtual void RenderViewCreated(\n      content::RenderViewHost* render_view_host) OVERRIDE;\n  virtual bool OnMessageReceived(const IPC::Message& message) OVERRIDE;\n\n  void OnPostMessage(int port_id, const Message& message);\n  void OnDetailedConsoleMessageAdded(const base::string16& message,\n                                     const base::string16& source,\n                                     const StackTrace& stack_trace,\n                                     int32 severity_level);\n\n\n  // Gets the extension or app (if any) that is associated with a RVH.\n  const Extension* GetExtension(content::RenderViewHost* render_view_host);\n\n  // The browser context for the web contents this is observing.\n  content::BrowserContext* browser_context_;\n\n  DISALLOW_COPY_AND_ASSIGN(ExtensionWebContentsObserver);\n};\n\n}  // namespace extensions\n\n#endif  // CHROME_BROWSER_EXTENSIONS_EXTENSION_WEB_CONTENTS_OBSERVER_H_\n\n", "comment_ratio": 0.2}
{"lang": "c", "code": "// Generated by Haxe 4.1.5\n#ifndef INCLUDED_flixel_system_debug_interaction_tools__Eraser_GraphicEraserTool\n#define INCLUDED_flixel_system_debug_interaction_tools__Eraser_GraphicEraserTool\n\n#ifndef HXCPP_H\n#include <hxcpp.h>\n#endif\n\n#ifndef INCLUDED_openfl_display_BitmapData\n#include <openfl/display/BitmapData.h>\n#endif\nHX_DECLARE_CLASS6(flixel,_hx_system,debug,interaction,tools,_Eraser,GraphicEraserTool)\nHX_DECLARE_CLASS2(openfl,display,BitmapData)\nHX_DECLARE_CLASS2(openfl,display,IBitmapDrawable)\n\nnamespace flixel{\nnamespace _hx_system{\nnamespace debug{\nnamespace interaction{\nnamespace tools{\nnamespace _Eraser{\n\n\nclass HXCPP_CLASS_ATTRIBUTES GraphicEraserTool_obj : public  ::openfl::display::BitmapData_obj\n{\n\tpublic:\n\t\ttypedef  ::openfl::display::BitmapData_obj super;\n\t\ttypedef GraphicEraserTool_obj OBJ_;\n\t\tGraphicEraserTool_obj();\n\n\tpublic:\n\t\tenum { _hx_ClassId = 0x23e86b72 };\n\n\t\tvoid __construct(int width,int height, ::Dynamic __o_transparent, ::Dynamic __o_fillRGBA);\n\t\tinline void *operator new(size_t inSize, bool inContainer=true,const char *inName=\"flixel.system.debug.interaction.tools._Eraser.GraphicEraserTool\")\n\t\t\t{ return ::hx::Object::operator new(inSize,inContainer,inName); }\n\t\tinline void *operator new(size_t inSize, int extra)\n\t\t\t{ return ::hx::Object::operator new(inSize+extra,true,\"flixel.system.debug.interaction.tools._Eraser.GraphicEraserTool\"); }\n\t\tstatic ::hx::ObjectPtr< GraphicEraserTool_obj > __new(int width,int height, ::Dynamic __o_transparent, ::Dynamic __o_fillRGBA);\n\t\tstatic ::hx::ObjectPtr< GraphicEraserTool_obj > __alloc(::hx::Ctx *_hx_ctx,int width,int height, ::Dynamic __o_transparent, ::Dynamic __o_fillRGBA);\n\t\tstatic void * _hx_vtable;\n\t\tstatic Dynamic __CreateEmpty();\n\t\tstatic Dynamic __Create(::hx::DynamicArray inArgs);\n\t\t//~GraphicEraserTool_obj();\n\n\t\tHX_DO_RTTI_ALL;\n\t\tstatic bool __GetStatic(const ::String &inString, Dynamic &outValue, ::hx::PropertyAccess inCallProp);\n\t\tstatic bool __SetStatic(const ::String &inString, Dynamic &ioValue, ::hx::PropertyAccess inCallProp);\n\t\tstatic void __register();\n\t\tbool _hx_isInstanceOf(int inClassId);\n\t\t::String __ToString() const { return HX_(\"GraphicEraserTool\",ec,be,60,23); }\n\n\t\tstatic void __boot();\n\t\tstatic ::String resourceName;\n};\n\n} // end namespace flixel\n} // end namespace system\n} // end namespace debug\n} // end namespace interaction\n} // end namespace tools\n} // end namespace _Eraser\n\n#endif /* INCLUDED_flixel_system_debug_interaction_tools__Eraser_GraphicEraserTool */ \n\n", "comment_ratio": 0.12307692307692308}
{"lang": "c", "code": "// Register addresses -----------------\n#define CONFIG      0x00\n#define EN_AA       0x01\n#define EN_RXADDR   0x02\n#define SETUP_AW    0x03\n#define SETUP_RETR  0x04\n#define RF_CH       0x05\n#define RF_SETUP    0x06\n#define STATUS      0x07\n#define OBSERVE_TX  0x08\n#define RPD         0x09\n#define RX_ADDR_P0  0x0A\n#define RX_ADDR_P1  0x0B\n#define RX_ADDR_P2  0x0C\n#define RX_ADDR_P3  0x0D\n#define RX_ADDR_P4  0x0E\n#define RX_ADDR_P5  0x0F\n#define TX_ADDR     0x10\n#define RX_PW_P0    0x11\n#define RX_PW_P1    0x12\n#define RX_PW_P2    0x13\n#define RX_PW_P3    0x14\n#define RX_PW_P4    0x15\n#define RX_PW_P5    0x16\n#define FIFO_STATUS 0x17\n#define DYNPD       0x1C\n#define FEATURE     0x1D\n\n\n// Bit Mnemonics ----------------------\n\n// CONFIG\n#define MASK_RX_DR  0x40\n#define MASK_TX_DS  0x20\n#define MASK_MAX_RT 0x10\n#define EN_CRC      0x08\n#define CRCO        0x04\n#define PWR_UP      0x02\n#define PRIM_RX     0x01\n// EN_AA\n#define ENAA_P5     0x20\n#define ENAA_P4     0x10\n#define ENAA_P3     0x08\n#define ENAA_P2     0x04\n#define ENAA_P1     0x02\n#define ENAA_P0     0x01\n// EN_RXADDR\n#define ERX_P5      0x20\n#define ERX_P4      0x10\n#define ERX_P3      0x08\n#define ERX_P2      0x04\n#define ERX_P1      0x02\n#define ERX_P0      0x01\n// SETUP_AW\n#define AW          0x01\n// SETUP_RETR\n#define ARD         0x10\n#define ARC         0x01\n// RF_SETUP\n#define CONT_WAVE   0x80\n#define RF_DR_LOW   0x20\n#define PLL_LOCK    0x10\n#define RF_DR_HIGH  0x08\n#define RF_PA_HIGH  0x04\n#define RF_PA_LOW   0x02\n// STATUS\n#define RX_DR       0x40\n#define TX_DS       0x20\n#define MAX_RT      0x10\n#define RX_P_NO     0x02\n#define TX_FULL     0x01\n// OBSERVE_TX\n#define PLOS_CNT    0x10\n#define ARC_CNT     0x01\n// FIFO_STATUS\n#define TX_REUSE    0x40\n#define TX_FULL_FIFO 0x20 // annoyingly this has the same mnemonic as in STATUS\n#define TX_EMPTY    0x10\n#define RX_FULL     0x02\n#define RX_EMPTY    0x01\n// DYNPD\n#define DPL_P5      0x20\n#define DPL_P4      0x10\n#define DPL_P3      0x08\n#define DPL_P2      0x04\n#define DPL_P1      0x02\n#define DPL_P0      0x01\n// FEATURE\n#define EN_DPL      0x04\n#define EN_ACK_PAY  0x02\n#define EN_DYN_ACK  0x01\n\n\n// SPI Commands ----------------------\n#define REGISTER_MASK       0x1F\n#define R_REGISTER          0x00\n#define W_REGISTER          0x20\n#define R_RX_PAYLOAD        0x61\n#define W_TX_PAYLOAD        0xA0\n#define FLUSH_TX            0xE1\n#define FLUSH_RX            0xE2\n#define REUSE_TX_PL         0xE3\n#define ACTIVATE            0x50\n#define R_RX_PL_WID         0x60\n#define W_ACK_PAYLOAD       0xA8\n#define W_TX_PAYLOAD_NO_ACK 0xB0\n#define NOP                 0xFF\n", "comment_ratio": 0.14018691588785046}
{"lang": "c", "code": "@class MCLSettings;\n\n@interface MCLSoundEffectPlayer : NSObject\n\n- (instancetype)initWithSettings:(MCLSettings *)settings;\n\n- (void)playCreatePostingSound;\n- (void)playEditPostingSound;\n- (void)playReloadSound;\n- (void)playMarkAllAsReadSound;\n- (void)playAddThreadToFavoritesSound;\n- (void)playRemoveThreadFromFavoritesSound;\n- (void)playAddThreadToKillfileSound;\n- (void)playRemoveThreadFromKillfileSound;\n- (void)playLoginFailedSound;\n- (void)playCopyLinkSound;\n- (void)playErrorSound;\n- (void)playSwitchSound;\n- (void)playTickSound;\n- (void)playPrivateMessageReceivedSound;\n- (void)playSecretFoundSound;\n\n@end\n\n", "comment_ratio": 0.21875}
{"lang": "c", "code": "#ifndef ATHENA_TEST_SAMPLE_ACTIVITY_FACTORY_H_\n#define ATHENA_TEST_SAMPLE_ACTIVITY_FACTORY_H_\n\n#include \"athena/activity/public/activity_factory.h\"\n#include \"base/macros.h\"\n\nnamespace athena {\nnamespace test {\n\nclass SampleActivityFactory : public ActivityFactory {\n public:\n  SampleActivityFactory();\n  virtual ~SampleActivityFactory();\n\n  // Overridden from ActivityFactory:\n  virtual Activity* CreateWebActivity(content::BrowserContext* browser_context,\n                                      const base::string16& title,\n                                      const GURL& url) OVERRIDE;\n  virtual Activity* CreateAppActivity(extensions::AppWindow* app_window,\n                                      views::WebView* web_view) OVERRIDE;\n\n private:\n  DISALLOW_COPY_AND_ASSIGN(SampleActivityFactory);\n};\n\n}  // namespace test\n}  // namespace athena\n\n#endif  // ATHENA_TEST_SAMPLE_ACTIVITY_FACTORY_H_\n\n", "comment_ratio": 0.20588235294117646}
{"lang": "c", "code": "/*  Config Option\r\n *\r\n *  From: https://github.com/PokemonAutomation/Arduino-Source\r\n *\r\n */\r\n\r\n#ifndef PokemonAutomation_ConfigOption_H\r\n#define PokemonAutomation_ConfigOption_H\r\n\r\nclass QString;\r\nclass QJsonValue;\r\nclass QWidget;\r\n\r\nnamespace PokemonAutomation{\r\n\r\n\r\nenum class ConfigOptionState{\r\n    ENABLED,\r\n    DISABLED,\r\n    HIDDEN,\r\n};\r\n\r\n\r\nclass ConfigWidget;\r\n\r\n// An option of a program, like the number of boxes of eggs to hatch,\r\n// the number of frames to skip, or what type of pokeballs to throw.\r\n// It is responsible for setting the UI (by calling make_ui()) of this option.\r\n// It also uses load_json() and to_json() to load and save the option to\r\n// a json file, so that the program can remember what user has selected.\r\nclass ConfigOption{\r\npublic:\r\n    virtual ~ConfigOption() = default;\r\n\r\n    virtual void load_json(const QJsonValue& json) = 0;\r\n    virtual QJsonValue to_json() const = 0;\r\n\r\n    //  Returns error message if invalid. Otherwise returns empty string.\r\n    virtual QString check_validity() const;\r\n\r\n    virtual void restore_defaults(){};\r\n\r\n    //  This is called by the framework at the start of a program to reset any\r\n    //  transient state that the option object may have.\r\n    virtual void reset_state(){};\r\n\r\n    virtual ConfigWidget* make_ui(QWidget& parent) = 0;\r\n\r\npublic:\r\n    ConfigOptionState visibility = ConfigOptionState::ENABLED;\r\n};\r\n\r\n\r\nclass ConfigWidget{\r\npublic:\r\n    virtual ~ConfigWidget() = default;\r\n    ConfigWidget(ConfigOption& m_value, QWidget& widget);\r\n\r\n    const ConfigOption& option() const{ return m_value; }\r\n    ConfigOption& option(){ return m_value; }\r\n\r\n    QWidget& widget(){ return m_widget; }\r\n\r\n    virtual void restore_defaults() = 0;\r\n    virtual void update_ui() = 0;\r\n    virtual void update_visibility();\r\n\r\nprivate:\r\n    ConfigOption& m_value;\r\n    QWidget& m_widget;\r\n};\r\n\r\n\r\n}\r\n#endif\r\n\n", "comment_ratio": 0.11842105263157894}
{"lang": "c", "code": "//\n//  EGRouterManager+Module.h\n//  Pods\n//\n//  Created by \u987e\u65b0\u751f on 2018/2/8.\n//\n\n#import <EagleSDK/EagleSDK.h>\n@class EGURL;\n@interface EGRouterManager (Module)\n+ (void)navigateToModule:(EGURL *)url options:(id)options;\n+ (void)navigateToModule:(EGURL *)url options:(id)options callback:(EGCallback)callback;\n\n+ (void)startAppWithModuleRouter:(NSString *)moduleRouter;\n@end\n\n", "comment_ratio": 0.375}
{"lang": "c", "code": "version https://git-lfs.github.com/spec/v1\noid sha256:e86cf7fe678ec3e2a3aca40df69685187bcdb039d021605e6337ab3e1516dc64\nsize 39576\n\n", "comment_ratio": 0.25}
{"lang": "c", "code": "#ifndef GOOGLE_PROTOBUF_INCLUDED_google_2ffirestore_2fv1_2fdocument_2eproto\n#define GOOGLE_PROTOBUF_INCLUDED_google_2ffirestore_2fv1_2fdocument_2eproto\n\n#include <limits>\n#include <string>\n\n#include <google/protobuf/port_def.inc>\n#if PROTOBUF_VERSION < 3009000\n#error This file was generated by a newer version of protoc which is\n#error incompatible with your Protocol Buffer headers. Please update\n#error your headers.\n#endif\n#if 3009002 < PROTOBUF_MIN_PROTOC_VERSION\n#error This file was generated by an older version of protoc which is\n#error incompatible with your Protocol Buffer headers. Please\n#error regenerate this file with a newer version of protoc.\n#endif\n\n#include <google/protobuf/port_undef.inc>\n#include <google/protobuf/io/coded_stream.h>\n#include <google/protobuf/arena.h>\n#include <google/protobuf/arenastring.h>\n#include <google/protobuf/generated_message_table_driven.h>\n#include <google/protobuf/generated_message_util.h>\n#include <google/protobuf/inlined_string_field.h>\n#include <google/protobuf/metadata.h>\n#include <google/protobuf/generated_message_reflection.h>\n#include <google/protobuf/message.h>\n#include <google/protobuf/repeated_field.h>  // IWYU pragma: export\n#include <google/protobuf/extension_set.h>  // IWYU pragma: export\n#include <google/protobuf/map.h>  // IWYU pragma: export\n#include <google/protobuf/map_entry.h>\n#include <google/protobuf/map_field_inl.h>\n#include <google/protobuf/unknown_field_set.h>\n#include \"google/api/annotations.pb.h\"\n#include <google/protobuf/struct.pb.h>\n#include <google/protobuf/timestamp.pb.h>\n#include \"google/type/latlng.pb.h\"\n// @@protoc_insertion_point(includes)\n#include <google/protobuf/port_def.inc>\n#define PROTOBUF_INTERNAL_EXPORT_google_2ffirestore_2fv1_2fdocument_2eproto\nPROTOBUF_NAMESPACE_OPEN\nnamespace internal {\nclass AnyMetadata;\n}  // namespace internal\nPROTOBUF_NAMESPACE_CLOSE\n\n// Internal implementation detail -- do not use these members.\nstruct TableStruct_google_2ffirestore_2fv1_2fdocument_2eproto {\n  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]\n    PROTOBUF_SECTION_VARIABLE(protodesc_cold);\n  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]\n    PROTOBUF_SECTION_VARIABLE(protodesc_cold);\n  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[6]\n    PROTOBUF_SECTION_VARIABLE(protodesc_cold);\n  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];\n  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];\n  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];\n};\nextern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_google_2ffirestore_2fv1_2fdocument_2eproto;\nnamespace google {\nnamespace firestore {\nnamespace v1 {\nclass ArrayValue;\nclass ArrayValueDefaultTypeInternal;\nextern ArrayValueDefaultTypeInternal _ArrayValue_default_instance_;\nclass Document;\nclass DocumentDefaultTypeInternal;\nextern DocumentDefaultTypeInternal _Document_default_instance_;\nclass Document_FieldsEntry_DoNotUse;\nclass Document_FieldsEntry_DoNotUseDefaultTypeInternal;\nextern Document_FieldsEntry_DoNotUseDefaultTypeInternal _Document_FieldsEntry_DoNotUse_default_instance_;\nclass MapValue;\nclass MapValueDefaultTypeInternal;\nextern MapValueDefaultTypeInternal _MapValue_default_instance_;\nclass MapValue_FieldsEntry_DoNotUse;\nclass MapValue_FieldsEntry_DoNotUseDefaultTypeInternal;\nextern MapValue_FieldsEntry_DoNotUseDefaultTypeInternal _MapValue_FieldsEntry_DoNotUse_default_instance_;\nclass Value;\nclass ValueDefaultTypeInternal;\nextern ValueDefaultTypeInternal _Value_default_instance_;\n}  // namespace v1\n}  // namespace firestore\n}  // namespace google\nPROTOBUF_NAMESPACE_OPEN\ntemplate<> ::google::firestore::v1::ArrayValue* Arena::CreateMaybeMessage<::google::firestore::v1::ArrayValue>(Arena*);\ntemplate<> ::google::firestore::v1::Document* Arena::CreateMaybeMessage<::google::firestore::v1::Document>(Arena*);\ntemplate<> ::google::firestore::v1::Document_FieldsEntry_DoNotUse* Arena::CreateMaybeMessage<::google::firestore::v1::Document_FieldsEntry_DoNotUse>(Arena*);\ntemplate<> ::google::firestore::v1::MapValue* Arena::CreateMaybeMessage<::google::firestore::v1::MapValue>(Arena*);\ntemplate<> ::google::firestore::v1::MapValue_FieldsEntry_DoNotUse* Arena::CreateMaybeMessage<::google::firestore::v1::MapValue_FieldsEntry_DoNotUse>(Arena*);\ntemplate<> ::google::firestore::v1::Value* Arena::CreateMaybeMessage<::google::firestore::v1::Value>(Arena*);\nPROTOBUF_NAMESPACE_CLOSE\nnamespace google {\nnamespace firestore {\nnamespace v1 {\n\n// ===================================================================\n\nclass Document_FieldsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Document_FieldsEntry_DoNotUse, \n    std::string, ::google::firestore::v1::Value,\n    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,\n    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,\n    0 > {\npublic:\n  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Document_FieldsEntry_DoNotUse, \n    std::string, ::google::firestore::v1::Value,\n    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,\n    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,\n    0 > SuperType;\n  Document_FieldsEntry_DoNotUse();\n  Document_FieldsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);\n  void MergeFrom(const Document_FieldsEntry_DoNotUse& other);\n  static const Document_FieldsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Document_FieldsEntry_DoNotUse*>(&_Document_FieldsEntry_DoNotUse_default_instance_); }\n  static bool ValidateKey(std::string* s) {\n    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), s->size(), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, \"google.firestore.v1.Document.FieldsEntry.key\");\n }\n  static bool ValidateValue(void*) { return true; }\n  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;\n  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;\n  private:\n  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {\n    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_google_2ffirestore_2fv1_2fdocument_2eproto);\n    return ::descriptor_table_google_2ffirestore_2fv1_2fdocument_2eproto.file_level_metadata[0];\n  }\n\n  public:\n};\n\n// -------------------------------------------------------------------\n\nclass Document :\n    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.firestore.v1.Document) */ {\n public:\n  Document();\n  virtual ~Document();\n\n  Document(const Document& from);\n  Document(Document&& from) noexcept\n    : Document() {\n    *this = ::std::move(from);\n  }\n\n  inline Document& operator=(const Document& from) {\n    CopyFrom(from);\n    return *this;\n  }\n  inline Document& operator=(Document&& from) noexcept {\n    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {\n      if (this != &from) InternalSwap(&from);\n    } else {\n      CopyFrom(from);\n    }\n    return *this;\n  }\n\n  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {\n    return GetDescriptor();\n  }\n  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {\n    return GetMetadataStatic().descriptor;\n  }\n  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {\n    return GetMetadataStatic().reflection;\n  }\n  static const Document& default_instance();\n\n  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY\n  static inline const Document* internal_default_instance() {\n    return reinterpret_cast<const Document*>(\n               &_Document_default_instance_);\n  }\n  static constexpr int kIndexInFileMessages =\n    1;\n\n  friend void swap(Document& a, Document& b) {\n    a.Swap(&b);\n  }\n  inline void Swap(Document* other) {\n    if (other == this) return;\n    InternalSwap(other);\n  }\n\n  // implements Message ----------------------------------------------\n\n  inline Document* New() const final {\n    return CreateMaybeMessage<Document>(nullptr);\n  }\n\n  Document* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {\n    return CreateMaybeMessage<Document>(arena);\n  }\n  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;\n  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;\n  void CopyFrom(const Document& from);\n  void MergeFrom(const Document& from);\n  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;\n  bool IsInitialized() const final;\n\n  size_t ByteSizeLong() const final;\n  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER\n  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;\n  #else\n  bool MergePartialFromCodedStream(\n      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;\n  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER\n  void SerializeWithCachedSizes(\n      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;\n  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(\n      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;\n  int GetCachedSize() const final { return _cached_size_.Get(); }\n\n  private:\n  inline void SharedCtor();\n  inline void SharedDtor();\n  void SetCachedSize(int size) const final;\n  void InternalSwap(Document* other);\n  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;\n  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {\n    return \"google.firestore.v1.Document\";\n  }\n  private:\n  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {\n    return nullptr;\n  }\n  inline void* MaybeArenaPtr() const {\n    return nullptr;\n  }\n  public:\n\n  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;\n  private:\n  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {\n    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_google_2ffirestore_2fv1_2fdocument_2eproto);\n    return ::descriptor_table_google_2ffirestore_2fv1_2fdocument_2eproto.file_level_metadata[kIndexInFileMessages];\n  }\n\n  public:\n\n  // nested types ----------------------------------------------------\n\n\n  // accessors -------------------------------------------------------\n\n  enum : int {\n    kFieldsFieldNumber = 2,\n    kNameFieldNumber = 1,\n    kCreateTimeFieldNumber = 3,\n    kUpdateTimeFieldNumber = 4,\n  };\n  // map<string, .google.firestore.v1.Value> fields = 2;\n  int fields_size() const;\n  void clear_fields();\n  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::firestore::v1::Value >&\n      fields() const;\n  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::firestore::v1::Value >*\n      mutable_fields();\n\n  // string name = 1;\n  void clear_name();\n  const std::string& name() const;\n  void set_name(const std::string& value);\n  void set_name(std::string&& value);\n  void set_name(const char* value);\n  void set_name(const char* value, size_t size);\n  std::string* mutable_name();\n  std::string* release_name();\n  void set_allocated_name(std::string* name);\n\n  // .google.protobuf.Timestamp create_time = 3;\n  bool has_create_time() const;\n  void clear_create_time();\n  const PROTOBUF_NAMESPACE_ID::Timestamp& create_time() const;\n  PROTOBUF_NAMESPACE_ID::Timestamp* release_create_time();\n  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_create_time();\n  void set_allocated_create_time(PROTOBUF_NAMESPACE_ID::Timestamp* create_time);\n\n  // .google.protobuf.Timestamp update_time = 4;\n  bool has_update_time() const;\n  void clear_update_time();\n  const PROTOBUF_NAMESPACE_ID::Timestamp& update_time() const;\n  PROTOBUF_NAMESPACE_ID::Timestamp* release_update_time();\n  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_update_time();\n  void set_allocated_update_time(PROTOBUF_NAMESPACE_ID::Timestamp* update_time);\n\n  // @@protoc_insertion_point(class_scope:google.firestore.v1.Document)\n private:\n  class _Internal;\n\n  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;\n  ::PROTOBUF_NAMESPACE_ID::internal::MapField<\n      Document_FieldsEntry_DoNotUse,\n      std::string, ::google::firestore::v1::Value,\n      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,\n      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,\n      0 > fields_;\n  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;\n  PROTOBUF_NAMESPACE_ID::Timestamp* create_time_;\n  PROTOBUF_NAMESPACE_ID::Timestamp* update_time_;\n  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;\n  friend struct ::TableStruct_google_2ffirestore_2fv1_2fdocument_2eproto;\n};\n// -------------------------------------------------------------------\n\nclass Value :\n    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.firestore.v1.Value) */ {\n public:\n  Value();\n  virtual ~Value();\n\n  Value(const Value& from);\n  Value(Value&& from) noexcept\n    : Value() {\n    *this = ::std::move(from);\n  }\n\n  inline Value& operator=(const Value& from) {\n    CopyFrom(from);\n    return *this;\n  }\n  inline Value& operator=(Value&& from) noexcept {\n    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {\n      if (this != &from) InternalSwap(&from);\n    } else {\n      CopyFrom(from);\n    }\n    return *this;\n  }\n\n  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {\n    return GetDescriptor();\n  }\n  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {\n    return GetMetadataStatic().descriptor;\n  }\n  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {\n    return GetMetadataStatic().reflection;\n  }\n  static const Value& default_instance();\n\n  enum ValueTypeCase {\n    kNullValue = 11,\n    kBooleanValue = 1,\n    kIntegerValue = 2,\n    kDoubleValue = 3,\n    kTimestampValue = 10,\n    kStringValue = 17,\n    kBytesValue = 18,\n    kReferenceValue = 5,\n    kGeoPointValue = 8,\n    kArrayValue = 9,\n    kMapValue = 6,\n    VALUE_TYPE_NOT_SET = 0,\n  };\n\n  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY\n  static inline const Value* internal_default_instance() {\n    return reinterpret_cast<const Value*>(\n               &_Value_default_instance_);\n  }\n  static constexpr int kIndexInFileMessages =\n    2;\n\n  friend void swap(Value& a, Value& b) {\n    a.Swap(&b);\n  }\n  inline void Swap(Value* other) {\n    if (other == this) return;\n    InternalSwap(other);\n  }\n\n  // implements Message ----------------------------------------------\n\n  inline Value* New() const final {\n    return CreateMaybeMessage<Value>(nullptr);\n  }\n\n  Value* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {\n    return CreateMaybeMessage<Value>(arena);\n  }\n  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;\n  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;\n  void CopyFrom(const Value& from);\n  void MergeFrom(const Value& from);\n  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;\n  bool IsInitialized() const final;\n\n  size_t ByteSizeLong() const final;\n  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER\n  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;\n  #else\n  bool MergePartialFromCodedStream(\n      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;\n  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER\n  void SerializeWithCachedSizes(\n      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;\n  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(\n      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;\n  int GetCachedSize() const final { return _cached_size_.Get(); }\n\n  private:\n  inline void SharedCtor();\n  inline void SharedDtor();\n  void SetCachedSize(int size) const final;\n  void InternalSwap(Value* other);\n  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;\n  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {\n    return \"google.firestore.v1.Value\";\n  }\n  private:\n  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {\n    return nullptr;\n  }\n  inline void* MaybeArenaPtr() const {\n    return nullptr;\n  }\n  public:\n\n  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;\n  private:\n  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {\n    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_google_2ffirestore_2fv1_2fdocument_2eproto);\n    return ::descriptor_table_google_2ffirestore_2fv1_2fdocument_2eproto.file_level_metadata[kIndexInFileMessages];\n  }\n\n  public:\n\n  // nested types ----------------------------------------------------\n\n  // accessors -------------------------------------------------------\n\n  enum : int {\n    kNullValueFieldNumber = 11,\n    kBooleanValueFieldNumber = 1,\n    kIntegerValueFieldNumber = 2,\n    kDoubleValueFieldNumber = 3,\n    kTimestampValueFieldNumber = 10,\n    kStringValueFieldNumber = 17,\n    kBytesValueFieldNumber = 18,\n    kReferenceValueFieldNumber = 5,\n    kGeoPointValueFieldNumber = 8,\n    kArrayValueFieldNumber = 9,\n    kMapValueFieldNumber = 6,\n  };\n  // .google.protobuf.NullValue null_value = 11;\n  private:\n  bool has_null_value() const;\n  public:\n  void clear_null_value();\n  PROTOBUF_NAMESPACE_ID::NullValue null_value() const;\n  void set_null_value(PROTOBUF_NAMESPACE_ID::NullValue value);\n\n  // bool boolean_value = 1;\n  private:\n  bool has_boolean_value() const;\n  public:\n  void clear_boolean_value();\n  bool boolean_value() const;\n  void set_boolean_value(bool value);\n\n  // int64 integer_value = 2;\n  private:\n  bool has_integer_value() const;\n  public:\n  void clear_integer_value();\n  ::PROTOBUF_NAMESPACE_ID::int64 integer_value() const;\n  void set_integer_value(::PROTOBUF_NAMESPACE_ID::int64 value);\n\n  // double double_value = 3;\n  private:\n  bool has_double_value() const;\n  public:\n  void clear_double_value();\n  double double_value() const;\n  void set_double_value(double value);\n\n  // .google.protobuf.Timestamp timestamp_value = 10;\n  bool has_timestamp_value() const;\n  void clear_timestamp_value();\n  const PROTOBUF_NAMESPACE_ID::Timestamp& timestamp_value() const;\n  PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp_value();\n  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp_value();\n  void set_allocated_timestamp_value(PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_value);\n\n  // string string_value = 17;\n  private:\n  bool has_string_value() const;\n  public:\n  void clear_string_value();\n  const std::string& string_value() const;\n  void set_string_value(const std::string& value);\n  void set_string_value(std::string&& value);\n  void set_string_value(const char* value);\n  void set_string_value(const char* value, size_t size);\n  std::string* mutable_string_value();\n  std::string* release_string_value();\n  void set_allocated_string_value(std::string* string_value);\n\n  // bytes bytes_value = 18;\n  private:\n  bool has_bytes_value() const;\n  public:\n  void clear_bytes_value();\n  const std::string& bytes_value() const;\n  void set_bytes_value(const std::string& value);\n  void set_bytes_value(std::string&& value);\n  void set_bytes_value(const char* value);\n  void set_bytes_value(const void* value, size_t size);\n  std::string* mutable_bytes_value();\n  std::string* release_bytes_value();\n  void set_allocated_bytes_value(std::string* bytes_value);\n\n  // string reference_value = 5;\n  private:\n  bool has_reference_value() const;\n  public:\n  void clear_reference_value();\n  const std::string& reference_value() const;\n  void set_reference_value(const std::string& value);\n  void set_reference_value(std::string&& value);\n  void set_reference_value(const char* value);\n  void set_reference_value(const char* value, size_t size);\n  std::string* mutable_reference_value();\n  std::string* release_reference_value();\n  void set_allocated_reference_value(std::string* reference_value);\n\n  // .google.type.LatLng geo_point_value = 8;\n  bool has_geo_point_value() const;\n  void clear_geo_point_value();\n  const ::google::type::LatLng& geo_point_value() const;\n  ::google::type::LatLng* release_geo_point_value();\n  ::google::type::LatLng* mutable_geo_point_value();\n  void set_allocated_geo_point_value(::google::type::LatLng* geo_point_value);\n\n  // .google.firestore.v1.ArrayValue array_value = 9;\n  bool has_array_value() const;\n  void clear_array_value();\n  const ::google::firestore::v1::ArrayValue& array_value() const;\n  ::google::firestore::v1::ArrayValue* release_array_value();\n  ::google::firestore::v1::ArrayValue* mutable_array_value();\n  void set_allocated_array_value(::google::firestore::v1::ArrayValue* array_value);\n\n  // .google.firestore.v1.MapValue map_value = 6;\n  bool has_map_value() const;\n  void clear_map_value();\n  const ::google::firestore::v1::MapValue& map_value() const;\n  ::google::firestore::v1::MapValue* release_map_value();\n  ::google::firestore::v1::MapValue* mutable_map_value();\n  void set_allocated_map_value(::google::firestore::v1::MapValue* map_value);\n\n  void clear_value_type();\n  ValueTypeCase value_type_case() const;\n  // @@protoc_insertion_point(class_scope:google.firestore.v1.Value)\n private:\n  class _Internal;\n  void set_has_null_value();\n  void set_has_boolean_value();\n  void set_has_integer_value();\n  void set_has_double_value();\n  void set_has_timestamp_value();\n  void set_has_string_value();\n  void set_has_bytes_value();\n  void set_has_reference_value();\n  void set_has_geo_point_value();\n  void set_has_array_value();\n  void set_has_map_value();\n\n  inline bool has_value_type() const;\n  inline void clear_has_value_type();\n\n  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;\n  union ValueTypeUnion {\n    ValueTypeUnion() {}\n    int null_value_;\n    bool boolean_value_;\n    ::PROTOBUF_NAMESPACE_ID::int64 integer_value_;\n    double double_value_;\n    PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_value_;\n    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr string_value_;\n    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bytes_value_;\n    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reference_value_;\n    ::google::type::LatLng* geo_point_value_;\n    ::google::firestore::v1::ArrayValue* array_value_;\n    ::google::firestore::v1::MapValue* map_value_;\n  } value_type_;\n  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;\n  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];\n\n  friend struct ::TableStruct_google_2ffirestore_2fv1_2fdocument_2eproto;\n};\n// -------------------------------------------------------------------\n\nclass ArrayValue :\n    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.firestore.v1.ArrayValue) */ {\n public:\n  ArrayValue();\n  virtual ~ArrayValue();\n\n  ArrayValue(const ArrayValue& from);\n  ArrayValue(ArrayValue&& from) noexcept\n    : ArrayValue() {\n    *this = ::std::move(from);\n  }\n\n  inline ArrayValue& operator=(const ArrayValue& from) {\n    CopyFrom(from);\n    return *this;\n  }\n  inline ArrayValue& operator=(ArrayValue&& from) noexcept {\n    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {\n      if (this != &from) InternalSwap(&from);\n    } else {\n      CopyFrom(from);\n    }\n    return *this;\n  }\n\n  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {\n    return GetDescriptor();\n  }\n  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {\n    return GetMetadataStatic().descriptor;\n  }\n  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {\n    return GetMetadataStatic().reflection;\n  }\n  static const ArrayValue& default_instance();\n\n  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY\n  static inline const ArrayValue* internal_default_instance() {\n    return reinterpret_cast<const ArrayValue*>(\n               &_ArrayValue_default_instance_);\n  }\n  static constexpr int kIndexInFileMessages =\n    3;\n\n  friend void swap(ArrayValue& a, ArrayValue& b) {\n    a.Swap(&b);\n  }\n  inline void Swap(ArrayValue* other) {\n    if (other == this) return;\n    InternalSwap(other);\n  }\n\n  // implements Message ----------------------------------------------\n\n  inline ArrayValue* New() const final {\n    return CreateMaybeMessage<ArrayValue>(nullptr);\n  }\n\n  ArrayValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {\n    return CreateMaybeMessage<ArrayValue>(arena);\n  }\n  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;\n  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;\n  void CopyFrom(const ArrayValue& from);\n  void MergeFrom(const ArrayValue& from);\n  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;\n  bool IsInitialized() const final;\n\n  size_t ByteSizeLong() const final;\n  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER\n  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;\n  #else\n  bool MergePartialFromCodedStream(\n      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;\n  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER\n  void SerializeWithCachedSizes(\n      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;\n  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(\n      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;\n  int GetCachedSize() const final { return _cached_size_.Get(); }\n\n  private:\n  inline void SharedCtor();\n  inline void SharedDtor();\n  void SetCachedSize(int size) const final;\n  void InternalSwap(ArrayValue* other);\n  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;\n  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {\n    return \"google.firestore.v1.ArrayValue\";\n  }\n  private:\n  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {\n    return nullptr;\n  }\n  inline void* MaybeArenaPtr() const {\n    return nullptr;\n  }\n  public:\n\n  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;\n  private:\n  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {\n    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_google_2ffirestore_2fv1_2fdocument_2eproto);\n    return ::descriptor_table_google_2ffirestore_2fv1_2fdocument_2eproto.file_level_metadata[kIndexInFileMessages];\n  }\n\n  public:\n\n  // nested types ----------------------------------------------------\n\n  // accessors -------------------------------------------------------\n\n  enum : int {\n    kValuesFieldNumber = 1,\n  };\n  // repeated .google.firestore.v1.Value values = 1;\n  int values_size() const;\n  void clear_values();\n  ::google::firestore::v1::Value* mutable_values(int index);\n  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::firestore::v1::Value >*\n      mutable_values();\n  const ::google::firestore::v1::Value& values(int index) const;\n  ::google::firestore::v1::Value* add_values();\n  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::firestore::v1::Value >&\n      values() const;\n\n  // @@protoc_insertion_point(class_scope:google.firestore.v1.ArrayValue)\n private:\n  class _Internal;\n\n  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;\n  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::firestore::v1::Value > values_;\n  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;\n  friend struct ::TableStruct_google_2ffirestore_2fv1_2fdocument_2eproto;\n};\n// -------------------------------------------------------------------\n\nclass MapValue_FieldsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<MapValue_FieldsEntry_DoNotUse, \n    std::string, ::google::firestore::v1::Value,\n    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,\n    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,\n    0 > {\npublic:\n  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<MapValue_FieldsEntry_DoNotUse, \n    std::string, ::google::firestore::v1::Value,\n    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,\n    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,\n    0 > SuperType;\n  MapValue_FieldsEntry_DoNotUse();\n  MapValue_FieldsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);\n  void MergeFrom(const MapValue_FieldsEntry_DoNotUse& other);\n  static const MapValue_FieldsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const MapValue_FieldsEntry_DoNotUse*>(&_MapValue_FieldsEntry_DoNotUse_default_instance_); }\n  static bool ValidateKey(std::string* s) {\n    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), s->size(), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, \"google.firestore.v1.MapValue.FieldsEntry.key\");\n }\n  static bool ValidateValue(void*) { return true; }\n  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;\n  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;\n  private:\n  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {\n    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_google_2ffirestore_2fv1_2fdocument_2eproto);\n    return ::descriptor_table_google_2ffirestore_2fv1_2fdocument_2eproto.file_level_metadata[4];\n  }\n\n  public:\n};\n\n// -------------------------------------------------------------------\n\nclass MapValue :\n    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.firestore.v1.MapValue) */ {\n public:\n  MapValue();\n  virtual ~MapValue();\n\n  MapValue(const MapValue& from);\n  MapValue(MapValue&& from) noexcept\n    : MapValue() {\n    *this = ::std::move(from);\n  }\n\n  inline MapValue& operator=(const MapValue& from) {\n    CopyFrom(from);\n    return *this;\n  }\n  inline MapValue& operator=(MapValue&& from) noexcept {\n    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {\n      if (this != &from) InternalSwap(&from);\n    } else {\n      CopyFrom(from);\n    }\n    return *this;\n  }\n\n  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {\n    return GetDescriptor();\n  }\n  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {\n    return GetMetadataStatic().descriptor;\n  }\n  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {\n    return GetMetadataStatic().reflection;\n  }\n  static const MapValue& default_instance();\n\n  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY\n  static inline const MapValue* internal_default_instance() {\n    return reinterpret_cast<const MapValue*>(\n               &_MapValue_default_instance_);\n  }\n  static constexpr int kIndexInFileMessages =\n    5;\n\n  friend void swap(MapValue& a, MapValue& b) {\n    a.Swap(&b);\n  }\n  inline void Swap(MapValue* other) {\n    if (other == this) return;\n    InternalSwap(other);\n  }\n\n  // implements Message ----------------------------------------------\n\n  inline MapValue* New() const final {\n    return CreateMaybeMessage<MapValue>(nullptr);\n  }\n\n  MapValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {\n    return CreateMaybeMessage<MapValue>(arena);\n  }\n  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;\n  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;\n  void CopyFrom(const MapValue& from);\n  void MergeFrom(const MapValue& from);\n  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;\n  bool IsInitialized() const final;\n\n  size_t ByteSizeLong() const final;\n  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER\n  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;\n  #else\n  bool MergePartialFromCodedStream(\n      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;\n  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER\n  void SerializeWithCachedSizes(\n      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;\n  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(\n      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;\n  int GetCachedSize() const final { return _cached_size_.Get(); }\n\n  private:\n  inline void SharedCtor();\n  inline void SharedDtor();\n  void SetCachedSize(int size) const final;\n  void InternalSwap(MapValue* other);\n  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;\n  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {\n    return \"google.firestore.v1.MapValue\";\n  }\n  private:\n  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {\n    return nullptr;\n  }\n  inline void* MaybeArenaPtr() const {\n    return nullptr;\n  }\n  public:\n\n  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;\n  private:\n  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {\n    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_google_2ffirestore_2fv1_2fdocument_2eproto);\n    return ::descriptor_table_google_2ffirestore_2fv1_2fdocument_2eproto.file_level_metadata[kIndexInFileMessages];\n  }\n\n  public:\n\n  // nested types ----------------------------------------------------\n\n\n  // accessors -------------------------------------------------------\n\n  enum : int {\n    kFieldsFieldNumber = 1,\n  };\n  // map<string, .google.firestore.v1.Value> fields = 1;\n  int fields_size() const;\n  void clear_fields();\n  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::firestore::v1::Value >&\n      fields() const;\n  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::firestore::v1::Value >*\n      mutable_fields();\n\n  // @@protoc_insertion_point(class_scope:google.firestore.v1.MapValue)\n private:\n  class _Internal;\n\n  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;\n  ::PROTOBUF_NAMESPACE_ID::internal::MapField<\n      MapValue_FieldsEntry_DoNotUse,\n      std::string, ::google::firestore::v1::Value,\n      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,\n      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,\n      0 > fields_;\n  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;\n  friend struct ::TableStruct_google_2ffirestore_2fv1_2fdocument_2eproto;\n};\n// ===================================================================\n\n\n// ===================================================================\n\n#ifdef __GNUC__\n  #pragma GCC diagnostic push\n  #pragma GCC diagnostic ignored \"-Wstrict-aliasing\"\n#endif  // __GNUC__\n// -------------------------------------------------------------------\n\n// Document\n\n// string name = 1;\ninline void Document::clear_name() {\n  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());\n}\ninline const std::string& Document::name() const {\n  // @@protoc_insertion_point(field_get:google.firestore.v1.Document.name)\n  return name_.GetNoArena();\n}\ninline void Document::set_name(const std::string& value) {\n  \n  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);\n  // @@protoc_insertion_point(field_set:google.firestore.v1.Document.name)\n}\ninline void Document::set_name(std::string&& value) {\n  \n  name_.SetNoArena(\n    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));\n  // @@protoc_insertion_point(field_set_rvalue:google.firestore.v1.Document.name)\n}\ninline void Document::set_name(const char* value) {\n  GOOGLE_DCHECK(value != nullptr);\n  \n  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));\n  // @@protoc_insertion_point(field_set_char:google.firestore.v1.Document.name)\n}\ninline void Document::set_name(const char* value, size_t size) {\n  \n  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),\n      ::std::string(reinterpret_cast<const char*>(value), size));\n  // @@protoc_insertion_point(field_set_pointer:google.firestore.v1.Document.name)\n}\ninline std::string* Document::mutable_name() {\n  \n  // @@protoc_insertion_point(field_mutable:google.firestore.v1.Document.name)\n  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());\n}\ninline std::string* Document::release_name() {\n  // @@protoc_insertion_point(field_release:google.firestore.v1.Document.name)\n  \n  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());\n}\ninline void Document::set_allocated_name(std::string* name) {\n  if (name != nullptr) {\n    \n  } else {\n    \n  }\n  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);\n  // @@protoc_insertion_point(field_set_allocated:google.firestore.v1.Document.name)\n}\n\n// map<string, .google.firestore.v1.Value> fields = 2;\ninline int Document::fields_size() const {\n  return fields_.size();\n}\ninline void Document::clear_fields() {\n  fields_.Clear();\n}\ninline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::firestore::v1::Value >&\nDocument::fields() const {\n  // @@protoc_insertion_point(field_map:google.firestore.v1.Document.fields)\n  return fields_.GetMap();\n}\ninline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::firestore::v1::Value >*\nDocument::mutable_fields() {\n  // @@protoc_insertion_point(field_mutable_map:google.firestore.v1.Document.fields)\n  return fields_.MutableMap();\n}\n\n// .google.protobuf.Timestamp create_time = 3;\ninline bool Document::has_create_time() const {\n  return this != internal_default_instance() && create_time_ != nullptr;\n}\ninline const PROTOBUF_NAMESPACE_ID::Timestamp& Document::create_time() const {\n  const PROTOBUF_NAMESPACE_ID::Timestamp* p = create_time_;\n  // @@protoc_insertion_point(field_get:google.firestore.v1.Document.create_time)\n  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(\n      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);\n}\ninline PROTOBUF_NAMESPACE_ID::Timestamp* Document::release_create_time() {\n  // @@protoc_insertion_point(field_release:google.firestore.v1.Document.create_time)\n  \n  PROTOBUF_NAMESPACE_ID::Timestamp* temp = create_time_;\n  create_time_ = nullptr;\n  return temp;\n}\ninline PROTOBUF_NAMESPACE_ID::Timestamp* Document::mutable_create_time() {\n  \n  if (create_time_ == nullptr) {\n    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaNoVirtual());\n    create_time_ = p;\n  }\n  // @@protoc_insertion_point(field_mutable:google.firestore.v1.Document.create_time)\n  return create_time_;\n}\ninline void Document::set_allocated_create_time(PROTOBUF_NAMESPACE_ID::Timestamp* create_time) {\n  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();\n  if (message_arena == nullptr) {\n    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(create_time_);\n  }\n  if (create_time) {\n    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =\n      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(create_time)->GetArena();\n    if (message_arena != submessage_arena) {\n      create_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(\n          message_arena, create_time, submessage_arena);\n    }\n    \n  } else {\n    \n  }\n  create_time_ = create_time;\n  // @@protoc_insertion_point(field_set_allocated:google.firestore.v1.Document.create_time)\n}\n\n// .google.protobuf.Timestamp update_time = 4;\ninline bool Document::has_update_time() const {\n  return this != internal_default_instance() && update_time_ != nullptr;\n}\ninline const PROTOBUF_NAMESPACE_ID::Timestamp& Document::update_time() const {\n  const PROTOBUF_NAMESPACE_ID::Timestamp* p = update_time_;\n  // @@protoc_insertion_point(field_get:google.firestore.v1.Document.update_time)\n  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(\n      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);\n}\ninline PROTOBUF_NAMESPACE_ID::Timestamp* Document::release_update_time() {\n  // @@protoc_insertion_point(field_release:google.firestore.v1.Document.update_time)\n  \n  PROTOBUF_NAMESPACE_ID::Timestamp* temp = update_time_;\n  update_time_ = nullptr;\n  return temp;\n}\ninline PROTOBUF_NAMESPACE_ID::Timestamp* Document::mutable_update_time() {\n  \n  if (update_time_ == nullptr) {\n    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaNoVirtual());\n    update_time_ = p;\n  }\n  // @@protoc_insertion_point(field_mutable:google.firestore.v1.Document.update_time)\n  return update_time_;\n}\ninline void Document::set_allocated_update_time(PROTOBUF_NAMESPACE_ID::Timestamp* update_time) {\n  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();\n  if (message_arena == nullptr) {\n    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_time_);\n  }\n  if (update_time) {\n    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =\n      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_time)->GetArena();\n    if (message_arena != submessage_arena) {\n      update_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(\n          message_arena, update_time, submessage_arena);\n    }\n    \n  } else {\n    \n  }\n  update_time_ = update_time;\n  // @@protoc_insertion_point(field_set_allocated:google.firestore.v1.Document.update_time)\n}\n\n// -------------------------------------------------------------------\n\n// Value\n\n// .google.protobuf.NullValue null_value = 11;\ninline bool Value::has_null_value() const {\n  return value_type_case() == kNullValue;\n}\ninline void Value::set_has_null_value() {\n  _oneof_case_[0] = kNullValue;\n}\ninline void Value::clear_null_value() {\n  if (has_null_value()) {\n    value_type_.null_value_ = 0;\n    clear_has_value_type();\n  }\n}\ninline PROTOBUF_NAMESPACE_ID::NullValue Value::null_value() const {\n  // @@protoc_insertion_point(field_get:google.firestore.v1.Value.null_value)\n  if (has_null_value()) {\n    return static_cast< PROTOBUF_NAMESPACE_ID::NullValue >(value_type_.null_value_);\n  }\n  return static_cast< PROTOBUF_NAMESPACE_ID::NullValue >(0);\n}\ninline void Value::set_null_value(PROTOBUF_NAMESPACE_ID::NullValue value) {\n  if (!has_null_value()) {\n    clear_value_type();\n    set_has_null_value();\n  }\n  value_type_.null_value_ = value;\n  // @@protoc_insertion_point(field_set:google.firestore.v1.Value.null_value)\n}\n\n// bool boolean_value = 1;\ninline bool Value::has_boolean_value() const {\n  return value_type_case() == kBooleanValue;\n}\ninline void Value::set_has_boolean_value() {\n  _oneof_case_[0] = kBooleanValue;\n}\ninline void Value::clear_boolean_value() {\n  if (has_boolean_value()) {\n    value_type_.boolean_value_ = false;\n    clear_has_value_type();\n  }\n}\ninline bool Value::boolean_value() const {\n  // @@protoc_insertion_point(field_get:google.firestore.v1.Value.boolean_value)\n  if (has_boolean_value()) {\n    return value_type_.boolean_value_;\n  }\n  return false;\n}\ninline void Value::set_boolean_value(bool value) {\n  if (!has_boolean_value()) {\n    clear_value_type();\n    set_has_boolean_value();\n  }\n  value_type_.boolean_value_ = value;\n  // @@protoc_insertion_point(field_set:google.firestore.v1.Value.boolean_value)\n}\n\n// int64 integer_value = 2;\ninline bool Value::has_integer_value() const {\n  return value_type_case() == kIntegerValue;\n}\ninline void Value::set_has_integer_value() {\n  _oneof_case_[0] = kIntegerValue;\n}\ninline void Value::clear_integer_value() {\n  if (has_integer_value()) {\n    value_type_.integer_value_ = PROTOBUF_LONGLONG(0);\n    clear_has_value_type();\n  }\n}\ninline ::PROTOBUF_NAMESPACE_ID::int64 Value::integer_value() const {\n  // @@protoc_insertion_point(field_get:google.firestore.v1.Value.integer_value)\n  if (has_integer_value()) {\n    return value_type_.integer_value_;\n  }\n  return PROTOBUF_LONGLONG(0);\n}\ninline void Value::set_integer_value(::PROTOBUF_NAMESPACE_ID::int64 value) {\n  if (!has_integer_value()) {\n    clear_value_type();\n    set_has_integer_value();\n  }\n  value_type_.integer_value_ = value;\n  // @@protoc_insertion_point(field_set:google.firestore.v1.Value.integer_value)\n}\n\n// double double_value = 3;\ninline bool Value::has_double_value() const {\n  return value_type_case() == kDoubleValue;\n}\ninline void Value::set_has_double_value() {\n  _oneof_case_[0] = kDoubleValue;\n}\ninline void Value::clear_double_value() {\n  if (has_double_value()) {\n    value_type_.double_value_ = 0;\n    clear_has_value_type();\n  }\n}\ninline double Value::double_value() const {\n  // @@protoc_insertion_point(field_get:google.firestore.v1.Value.double_value)\n  if (has_double_value()) {\n    return value_type_.double_value_;\n  }\n  return 0;\n}\ninline void Value::set_double_value(double value) {\n  if (!has_double_value()) {\n    clear_value_type();\n    set_has_double_value();\n  }\n  value_type_.double_value_ = value;\n  // @@protoc_insertion_point(field_set:google.firestore.v1.Value.double_value)\n}\n\n// .google.protobuf.Timestamp timestamp_value = 10;\ninline bool Value::has_timestamp_value() const {\n  return value_type_case() == kTimestampValue;\n}\ninline void Value::set_has_timestamp_value() {\n  _oneof_case_[0] = kTimestampValue;\n}\ninline PROTOBUF_NAMESPACE_ID::Timestamp* Value::release_timestamp_value() {\n  // @@protoc_insertion_point(field_release:google.firestore.v1.Value.timestamp_value)\n  if (has_timestamp_value()) {\n    clear_has_value_type();\n      PROTOBUF_NAMESPACE_ID::Timestamp* temp = value_type_.timestamp_value_;\n    value_type_.timestamp_value_ = nullptr;\n    return temp;\n  } else {\n    return nullptr;\n  }\n}\ninline const PROTOBUF_NAMESPACE_ID::Timestamp& Value::timestamp_value() const {\n  // @@protoc_insertion_point(field_get:google.firestore.v1.Value.timestamp_value)\n  return has_timestamp_value()\n      ? *value_type_.timestamp_value_\n      : *reinterpret_cast< PROTOBUF_NAMESPACE_ID::Timestamp*>(&PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);\n}\ninline PROTOBUF_NAMESPACE_ID::Timestamp* Value::mutable_timestamp_value() {\n  if (!has_timestamp_value()) {\n    clear_value_type();\n    set_has_timestamp_value();\n    value_type_.timestamp_value_ = CreateMaybeMessage< PROTOBUF_NAMESPACE_ID::Timestamp >(\n        GetArenaNoVirtual());\n  }\n  // @@protoc_insertion_point(field_mutable:google.firestore.v1.Value.timestamp_value)\n  return value_type_.timestamp_value_;\n}\n\n// string string_value = 17;\ninline bool Value::has_string_value() const {\n  return value_type_case() == kStringValue;\n}\ninline void Value::set_has_string_value() {\n  _oneof_case_[0] = kStringValue;\n}\ninline void Value::clear_string_value() {\n  if (has_string_value()) {\n    value_type_.string_value_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());\n    clear_has_value_type();\n  }\n}\ninline const std::string& Value::string_value() const {\n  // @@protoc_insertion_point(field_get:google.firestore.v1.Value.string_value)\n  if (has_string_value()) {\n    return value_type_.string_value_.GetNoArena();\n  }\n  return *&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();\n}\ninline void Value::set_string_value(const std::string& value) {\n  // @@protoc_insertion_point(field_set:google.firestore.v1.Value.string_value)\n  if (!has_string_value()) {\n    clear_value_type();\n    set_has_string_value();\n    value_type_.string_value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());\n  }\n  value_type_.string_value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);\n  // @@protoc_insertion_point(field_set:google.firestore.v1.Value.string_value)\n}\ninline void Value::set_string_value(std::string&& value) {\n  // @@protoc_insertion_point(field_set:google.firestore.v1.Value.string_value)\n  if (!has_string_value()) {\n    clear_value_type();\n    set_has_string_value();\n    value_type_.string_value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());\n  }\n  value_type_.string_value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));\n  // @@protoc_insertion_point(field_set_rvalue:google.firestore.v1.Value.string_value)\n}\ninline void Value::set_string_value(const char* value) {\n  GOOGLE_DCHECK(value != nullptr);\n  if (!has_string_value()) {\n    clear_value_type();\n    set_has_string_value();\n    value_type_.string_value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());\n  }\n  value_type_.string_value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),\n      ::std::string(value));\n  // @@protoc_insertion_point(field_set_char:google.firestore.v1.Value.string_value)\n}\ninline void Value::set_string_value(const char* value, size_t size) {\n  if (!has_string_value()) {\n    clear_value_type();\n    set_has_string_value();\n    value_type_.string_value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());\n  }\n  value_type_.string_value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(\n      reinterpret_cast<const char*>(value), size));\n  // @@protoc_insertion_point(field_set_pointer:google.firestore.v1.Value.string_value)\n}\ninline std::string* Value::mutable_string_value() {\n  if (!has_string_value()) {\n    clear_value_type();\n    set_has_string_value();\n    value_type_.string_value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());\n  }\n  // @@protoc_insertion_point(field_mutable:google.firestore.v1.Value.string_value)\n  return value_type_.string_value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());\n}\ninline std::string* Value::release_string_value() {\n  // @@protoc_insertion_point(field_release:google.firestore.v1.Value.string_value)\n  if (has_string_value()) {\n    clear_has_value_type();\n    return value_type_.string_value_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());\n  } else {\n    return nullptr;\n  }\n}\ninline void Value::set_allocated_string_value(std::string* string_value) {\n  if (has_value_type()) {\n    clear_value_type();\n  }\n  if (string_value != nullptr) {\n    set_has_string_value();\n    value_type_.string_value_.UnsafeSetDefault(string_value);\n  }\n  // @@protoc_insertion_point(field_set_allocated:google.firestore.v1.Value.string_value)\n}\n\n// bytes bytes_value = 18;\ninline bool Value::has_bytes_value() const {\n  return value_type_case() == kBytesValue;\n}\ninline void Value::set_has_bytes_value() {\n  _oneof_case_[0] = kBytesValue;\n}\ninline void Value::clear_bytes_value() {\n  if (has_bytes_value()) {\n    value_type_.bytes_value_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());\n    clear_has_value_type();\n  }\n}\ninline const std::string& Value::bytes_value() const {\n  // @@protoc_insertion_point(field_get:google.firestore.v1.Value.bytes_value)\n  if (has_bytes_value()) {\n    return value_type_.bytes_value_.GetNoArena();\n  }\n  return *&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();\n}\ninline void Value::set_bytes_value(const std::string& value) {\n  // @@protoc_insertion_point(field_set:google.firestore.v1.Value.bytes_value)\n  if (!has_bytes_value()) {\n    clear_value_type();\n    set_has_bytes_value();\n    value_type_.bytes_value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());\n  }\n  value_type_.bytes_value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);\n  // @@protoc_insertion_point(field_set:google.firestore.v1.Value.bytes_value)\n}\ninline void Value::set_bytes_value(std::string&& value) {\n  // @@protoc_insertion_point(field_set:google.firestore.v1.Value.bytes_value)\n  if (!has_bytes_value()) {\n    clear_value_type();\n    set_has_bytes_value();\n    value_type_.bytes_value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());\n  }\n  value_type_.bytes_value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));\n  // @@protoc_insertion_point(field_set_rvalue:google.firestore.v1.Value.bytes_value)\n}\ninline void Value::set_bytes_value(const char* value) {\n  GOOGLE_DCHECK(value != nullptr);\n  if (!has_bytes_value()) {\n    clear_value_type();\n    set_has_bytes_value();\n    value_type_.bytes_value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());\n  }\n  value_type_.bytes_value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),\n      ::std::string(value));\n  // @@protoc_insertion_point(field_set_char:google.firestore.v1.Value.bytes_value)\n}\ninline void Value::set_bytes_value(const void* value, size_t size) {\n  if (!has_bytes_value()) {\n    clear_value_type();\n    set_has_bytes_value();\n    value_type_.bytes_value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());\n  }\n  value_type_.bytes_value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(\n      reinterpret_cast<const char*>(value), size));\n  // @@protoc_insertion_point(field_set_pointer:google.firestore.v1.Value.bytes_value)\n}\ninline std::string* Value::mutable_bytes_value() {\n  if (!has_bytes_value()) {\n    clear_value_type();\n    set_has_bytes_value();\n    value_type_.bytes_value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());\n  }\n  // @@protoc_insertion_point(field_mutable:google.firestore.v1.Value.bytes_value)\n  return value_type_.bytes_value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());\n}\ninline std::string* Value::release_bytes_value() {\n  // @@protoc_insertion_point(field_release:google.firestore.v1.Value.bytes_value)\n  if (has_bytes_value()) {\n    clear_has_value_type();\n    return value_type_.bytes_value_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());\n  } else {\n    return nullptr;\n  }\n}\ninline void Value::set_allocated_bytes_value(std::string* bytes_value) {\n  if (has_value_type()) {\n    clear_value_type();\n  }\n  if (bytes_value != nullptr) {\n    set_has_bytes_value();\n    value_type_.bytes_value_.UnsafeSetDefault(bytes_value);\n  }\n  // @@protoc_insertion_point(field_set_allocated:google.firestore.v1.Value.bytes_value)\n}\n\n// string reference_value = 5;\ninline bool Value::has_reference_value() const {\n  return value_type_case() == kReferenceValue;\n}\ninline void Value::set_has_reference_value() {\n  _oneof_case_[0] = kReferenceValue;\n}\ninline void Value::clear_reference_value() {\n  if (has_reference_value()) {\n    value_type_.reference_value_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());\n    clear_has_value_type();\n  }\n}\ninline const std::string& Value::reference_value() const {\n  // @@protoc_insertion_point(field_get:google.firestore.v1.Value.reference_value)\n  if (has_reference_value()) {\n    return value_type_.reference_value_.GetNoArena();\n  }\n  return *&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();\n}\ninline void Value::set_reference_value(const std::string& value) {\n  // @@protoc_insertion_point(field_set:google.firestore.v1.Value.reference_value)\n  if (!has_reference_value()) {\n    clear_value_type();\n    set_has_reference_value();\n    value_type_.reference_value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());\n  }\n  value_type_.reference_value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);\n  // @@protoc_insertion_point(field_set:google.firestore.v1.Value.reference_value)\n}\ninline void Value::set_reference_value(std::string&& value) {\n  // @@protoc_insertion_point(field_set:google.firestore.v1.Value.reference_value)\n  if (!has_reference_value()) {\n    clear_value_type();\n    set_has_reference_value();\n    value_type_.reference_value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());\n  }\n  value_type_.reference_value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));\n  // @@protoc_insertion_point(field_set_rvalue:google.firestore.v1.Value.reference_value)\n}\ninline void Value::set_reference_value(const char* value) {\n  GOOGLE_DCHECK(value != nullptr);\n  if (!has_reference_value()) {\n    clear_value_type();\n    set_has_reference_value();\n    value_type_.reference_value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());\n  }\n  value_type_.reference_value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),\n      ::std::string(value));\n  // @@protoc_insertion_point(field_set_char:google.firestore.v1.Value.reference_value)\n}\ninline void Value::set_reference_value(const char* value, size_t size) {\n  if (!has_reference_value()) {\n    clear_value_type();\n    set_has_reference_value();\n    value_type_.reference_value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());\n  }\n  value_type_.reference_value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(\n      reinterpret_cast<const char*>(value), size));\n  // @@protoc_insertion_point(field_set_pointer:google.firestore.v1.Value.reference_value)\n}\ninline std::string* Value::mutable_reference_value() {\n  if (!has_reference_value()) {\n    clear_value_type();\n    set_has_reference_value();\n    value_type_.reference_value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());\n  }\n  // @@protoc_insertion_point(field_mutable:google.firestore.v1.Value.reference_value)\n  return value_type_.reference_value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());\n}\ninline std::string* Value::release_reference_value() {\n  // @@protoc_insertion_point(field_release:google.firestore.v1.Value.reference_value)\n  if (has_reference_value()) {\n    clear_has_value_type();\n    return value_type_.reference_value_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());\n  } else {\n    return nullptr;\n  }\n}\ninline void Value::set_allocated_reference_value(std::string* reference_value) {\n  if (has_value_type()) {\n    clear_value_type();\n  }\n  if (reference_value != nullptr) {\n    set_has_reference_value();\n    value_type_.reference_value_.UnsafeSetDefault(reference_value);\n  }\n  // @@protoc_insertion_point(field_set_allocated:google.firestore.v1.Value.reference_value)\n}\n\n// .google.type.LatLng geo_point_value = 8;\ninline bool Value::has_geo_point_value() const {\n  return value_type_case() == kGeoPointValue;\n}\ninline void Value::set_has_geo_point_value() {\n  _oneof_case_[0] = kGeoPointValue;\n}\ninline ::google::type::LatLng* Value::release_geo_point_value() {\n  // @@protoc_insertion_point(field_release:google.firestore.v1.Value.geo_point_value)\n  if (has_geo_point_value()) {\n    clear_has_value_type();\n      ::google::type::LatLng* temp = value_type_.geo_point_value_;\n    value_type_.geo_point_value_ = nullptr;\n    return temp;\n  } else {\n    return nullptr;\n  }\n}\ninline const ::google::type::LatLng& Value::geo_point_value() const {\n  // @@protoc_insertion_point(field_get:google.firestore.v1.Value.geo_point_value)\n  return has_geo_point_value()\n      ? *value_type_.geo_point_value_\n      : *reinterpret_cast< ::google::type::LatLng*>(&::google::type::_LatLng_default_instance_);\n}\ninline ::google::type::LatLng* Value::mutable_geo_point_value() {\n  if (!has_geo_point_value()) {\n    clear_value_type();\n    set_has_geo_point_value();\n    value_type_.geo_point_value_ = CreateMaybeMessage< ::google::type::LatLng >(\n        GetArenaNoVirtual());\n  }\n  // @@protoc_insertion_point(field_mutable:google.firestore.v1.Value.geo_point_value)\n  return value_type_.geo_point_value_;\n}\n\n// .google.firestore.v1.ArrayValue array_value = 9;\ninline bool Value::has_array_value() const {\n  return value_type_case() == kArrayValue;\n}\ninline void Value::set_has_array_value() {\n  _oneof_case_[0] = kArrayValue;\n}\ninline void Value::clear_array_value() {\n  if (has_array_value()) {\n    delete value_type_.array_value_;\n    clear_has_value_type();\n  }\n}\ninline ::google::firestore::v1::ArrayValue* Value::release_array_value() {\n  // @@protoc_insertion_point(field_release:google.firestore.v1.Value.array_value)\n  if (has_array_value()) {\n    clear_has_value_type();\n      ::google::firestore::v1::ArrayValue* temp = value_type_.array_value_;\n    value_type_.array_value_ = nullptr;\n    return temp;\n  } else {\n    return nullptr;\n  }\n}\ninline const ::google::firestore::v1::ArrayValue& Value::array_value() const {\n  // @@protoc_insertion_point(field_get:google.firestore.v1.Value.array_value)\n  return has_array_value()\n      ? *value_type_.array_value_\n      : *reinterpret_cast< ::google::firestore::v1::ArrayValue*>(&::google::firestore::v1::_ArrayValue_default_instance_);\n}\ninline ::google::firestore::v1::ArrayValue* Value::mutable_array_value() {\n  if (!has_array_value()) {\n    clear_value_type();\n    set_has_array_value();\n    value_type_.array_value_ = CreateMaybeMessage< ::google::firestore::v1::ArrayValue >(\n        GetArenaNoVirtual());\n  }\n  // @@protoc_insertion_point(field_mutable:google.firestore.v1.Value.array_value)\n  return value_type_.array_value_;\n}\n\n// .google.firestore.v1.MapValue map_value = 6;\ninline bool Value::has_map_value() const {\n  return value_type_case() == kMapValue;\n}\ninline void Value::set_has_map_value() {\n  _oneof_case_[0] = kMapValue;\n}\ninline void Value::clear_map_value() {\n  if (has_map_value()) {\n    delete value_type_.map_value_;\n    clear_has_value_type();\n  }\n}\ninline ::google::firestore::v1::MapValue* Value::release_map_value() {\n  // @@protoc_insertion_point(field_release:google.firestore.v1.Value.map_value)\n  if (has_map_value()) {\n    clear_has_value_type();\n      ::google::firestore::v1::MapValue* temp = value_type_.map_value_;\n    value_type_.map_value_ = nullptr;\n    return temp;\n  } else {\n    return nullptr;\n  }\n}\ninline const ::google::firestore::v1::MapValue& Value::map_value() const {\n  // @@protoc_insertion_point(field_get:google.firestore.v1.Value.map_value)\n  return has_map_value()\n      ? *value_type_.map_value_\n      : *reinterpret_cast< ::google::firestore::v1::MapValue*>(&::google::firestore::v1::_MapValue_default_instance_);\n}\ninline ::google::firestore::v1::MapValue* Value::mutable_map_value() {\n  if (!has_map_value()) {\n    clear_value_type();\n    set_has_map_value();\n    value_type_.map_value_ = CreateMaybeMessage< ::google::firestore::v1::MapValue >(\n        GetArenaNoVirtual());\n  }\n  // @@protoc_insertion_point(field_mutable:google.firestore.v1.Value.map_value)\n  return value_type_.map_value_;\n}\n\ninline bool Value::has_value_type() const {\n  return value_type_case() != VALUE_TYPE_NOT_SET;\n}\ninline void Value::clear_has_value_type() {\n  _oneof_case_[0] = VALUE_TYPE_NOT_SET;\n}\ninline Value::ValueTypeCase Value::value_type_case() const {\n  return Value::ValueTypeCase(_oneof_case_[0]);\n}\n// -------------------------------------------------------------------\n\n// ArrayValue\n\n// repeated .google.firestore.v1.Value values = 1;\ninline int ArrayValue::values_size() const {\n  return values_.size();\n}\ninline void ArrayValue::clear_values() {\n  values_.Clear();\n}\ninline ::google::firestore::v1::Value* ArrayValue::mutable_values(int index) {\n  // @@protoc_insertion_point(field_mutable:google.firestore.v1.ArrayValue.values)\n  return values_.Mutable(index);\n}\ninline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::firestore::v1::Value >*\nArrayValue::mutable_values() {\n  // @@protoc_insertion_point(field_mutable_list:google.firestore.v1.ArrayValue.values)\n  return &values_;\n}\ninline const ::google::firestore::v1::Value& ArrayValue::values(int index) const {\n  // @@protoc_insertion_point(field_get:google.firestore.v1.ArrayValue.values)\n  return values_.Get(index);\n}\ninline ::google::firestore::v1::Value* ArrayValue::add_values() {\n  // @@protoc_insertion_point(field_add:google.firestore.v1.ArrayValue.values)\n  return values_.Add();\n}\ninline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::firestore::v1::Value >&\nArrayValue::values() const {\n  // @@protoc_insertion_point(field_list:google.firestore.v1.ArrayValue.values)\n  return values_;\n}\n\n// -------------------------------------------------------------------\n\n// -------------------------------------------------------------------\n\n// MapValue\n\n// map<string, .google.firestore.v1.Value> fields = 1;\ninline int MapValue::fields_size() const {\n  return fields_.size();\n}\ninline void MapValue::clear_fields() {\n  fields_.Clear();\n}\ninline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::firestore::v1::Value >&\nMapValue::fields() const {\n  // @@protoc_insertion_point(field_map:google.firestore.v1.MapValue.fields)\n  return fields_.GetMap();\n}\ninline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::firestore::v1::Value >*\nMapValue::mutable_fields() {\n  // @@protoc_insertion_point(field_mutable_map:google.firestore.v1.MapValue.fields)\n  return fields_.MutableMap();\n}\n\n#ifdef __GNUC__\n  #pragma GCC diagnostic pop\n#endif  // __GNUC__\n// -------------------------------------------------------------------\n\n// -------------------------------------------------------------------\n\n// -------------------------------------------------------------------\n\n// -------------------------------------------------------------------\n\n// -------------------------------------------------------------------\n\n\n// @@protoc_insertion_point(namespace_scope)\n\n}  // namespace v1\n}  // namespace firestore\n}  // namespace google\n\n// @@protoc_insertion_point(global_scope)\n\n#include <google/protobuf/port_undef.inc>\n#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_google_2ffirestore_2fv1_2fdocument_2eproto\n\n", "comment_ratio": 0.10144927536231885}
{"lang": "c", "code": "#if !defined(__IAR__SRC_IAR_H)\n\t#define __IAR__SRC_IAR_H\n\n#include <stdio.h>\n#include <stdint.h>\n\n// iar macros\n\n#define IAR_MAGIC 0x1A4C1A4C1A4C1A4C\n\n#if !defined(IAR_VERSION)\n\t#define IAR_VERSION 1lu // *latest* supported version\n#endif\n\n#if !defined(IAR_DEFAULT_PAGE_BYTES)\n\t#define IAR_DEFAULT_PAGE_BYTES 4096lu\n#endif\n\n#if !defined(IAR_MAX_READ_BLOCK_SIZE)\n\t#define IAR_MAX_READ_BLOCK_SIZE 0x10000 // 64 KiB\n#endif\n\n// iar data structures\n\ntypedef struct {\n\tuint64_t magic;\n\tuint64_t version;\n\tuint64_t root_node_offset;\n\tuint64_t page_bytes;\n} iar_header_t;\n\ntypedef struct {\n\tuint64_t is_dir;\n\n\tuint64_t name_bytes; // the name is always null-terminated, so this is (strlen(name) + 1)\n\tuint64_t name_offset;\n\n\tunion {\n\t\tuint64_t node_count;\n\t\tuint64_t data_bytes;\n\t};\n\n\tunion {\n\t\tuint64_t node_offsets_offset;\n\t\tuint64_t data_offset;\n\t};\n} iar_node_t;\n\n// functions for opening / closing iar files\n\ntypedef struct {\n\tchar* absolute_path;\n\n\tFILE* fp;\n\tint fd;\n\n\tiar_header_t header;\n\tiar_node_t root_node;\n\n\tuint64_t current_offset;\n} iar_file_t;\n\nint iar_open_read(iar_file_t* self, const char* path);\nint iar_open_write(iar_file_t* self, const char* path);\n\nvoid iar_close(iar_file_t* self);\n\n// functions for reading iar files\n\nuint64_t iar_find_node(iar_file_t* self, iar_node_t* node, const char* name, iar_node_t* parent); // return the index of found file or -1 if nothing found\nint iar_read_node_name(iar_file_t* self, iar_node_t* node, char* buffer);\n\nint iar_read_node_content /* content not contents */ (iar_file_t* self, iar_node_t* node, char* buffer);\nint iar_map_node_content /* content not contents */ (iar_file_t* self, iar_node_t* node, void* address);\n\n// functions for writing to iar files\n\nint iar_write_header(iar_file_t* self);\n\n// functions for packing and unpacking iar files\n\nint iar_pack(iar_file_t* self, const char* path, const char* name); // if no name is passed ((const char*) 0), the name will automatically be generated from the path\nint iar_unpack(iar_file_t* self, const char* path);\n\n#endif\n", "comment_ratio": 0.12941176470588237}
{"lang": "c", "code": "#ifndef NET_SPDY_SPDY_SESSION_H_\n#define NET_SPDY_SPDY_SESSION_H_\n\n#include <deque>\n#include <map>\n#include <set>\n#include <string>\n\n#include \"base/basictypes.h\"\n#include \"base/gtest_prod_util.h\"\n#include \"base/memory/ref_counted.h\"\n#include \"base/memory/scoped_ptr.h\"\n#include \"base/memory/weak_ptr.h\"\n#include \"base/time/time.h\"\n#include \"net/base/io_buffer.h\"\n#include \"net/base/load_states.h\"\n#include \"net/base/net_errors.h\"\n#include \"net/base/net_export.h\"\n#include \"net/base/request_priority.h\"\n#include \"net/socket/client_socket_handle.h\"\n#include \"net/socket/client_socket_pool.h\"\n#include \"net/socket/next_proto.h\"\n#include \"net/socket/ssl_client_socket.h\"\n#include \"net/socket/stream_socket.h\"\n#include \"net/spdy/buffered_spdy_framer.h\"\n#include \"net/spdy/spdy_buffer.h\"\n#include \"net/spdy/spdy_credential_state.h\"\n#include \"net/spdy/spdy_framer.h\"\n#include \"net/spdy/spdy_header_block.h\"\n#include \"net/spdy/spdy_protocol.h\"\n#include \"net/spdy/spdy_session_pool.h\"\n#include \"net/spdy/spdy_stream.h\"\n#include \"net/spdy/spdy_write_queue.h\"\n#include \"net/ssl/ssl_config_service.h\"\n#include \"url/gurl.h\"\n\nnamespace net {\n\n// This is somewhat arbitrary and not really fixed, but it will always work\n// reasonably with ethernet. Chop the world into 2-packet chunks.  This is\n// somewhat arbitrary, but is reasonably small and ensures that we elicit\n// ACKs quickly from TCP (because TCP tries to only ACK every other packet).\nconst int kMss = 1430;\n// The 8 is the size of the SPDY frame header.\nconst int kMaxSpdyFrameChunkSize = (2 * kMss) - 8;\n\n// Maximum number of concurrent streams we will create, unless the server\n// sends a SETTINGS frame with a different value.\nconst size_t kInitialMaxConcurrentStreams = 100;\n\n// Specifies the maxiumum concurrent streams server could send (via push).\nconst int kMaxConcurrentPushedStreams = 1000;\n\n// Specifies the maximum number of bytes to read synchronously before\n// yielding.\nconst int kMaxReadBytesWithoutYielding = 32 * 1024;\n\n// The initial receive window size for both streams and sessions.\nconst int32 kDefaultInitialRecvWindowSize = 10 * 1024 * 1024;  // 10MB\n\nclass BoundNetLog;\nstruct LoadTimingInfo;\nclass SpdyStream;\nclass SSLInfo;\n\n// NOTE: There's an enum of the same name (also with numeric suffixes)\n// in histograms.xml.\n//\n// WARNING: DO NOT INSERT ENUMS INTO THIS LIST! Add only to the end.\nenum SpdyProtocolErrorDetails {\n  // SpdyFramer::SpdyErrors\n  SPDY_ERROR_NO_ERROR,\n  SPDY_ERROR_INVALID_CONTROL_FRAME,\n  SPDY_ERROR_CONTROL_PAYLOAD_TOO_LARGE,\n  SPDY_ERROR_ZLIB_INIT_FAILURE,\n  SPDY_ERROR_UNSUPPORTED_VERSION,\n  SPDY_ERROR_DECOMPRESS_FAILURE,\n  SPDY_ERROR_COMPRESS_FAILURE,\n  SPDY_ERROR_CREDENTIAL_FRAME_CORRUPT,\n  SPDY_ERROR_INVALID_DATA_FRAME_FLAGS,\n  SPDY_ERROR_INVALID_CONTROL_FRAME_FLAGS,\n  // SpdyRstStreamStatus\n  STATUS_CODE_INVALID,\n  STATUS_CODE_PROTOCOL_ERROR,\n  STATUS_CODE_INVALID_STREAM,\n  STATUS_CODE_REFUSED_STREAM,\n  STATUS_CODE_UNSUPPORTED_VERSION,\n  STATUS_CODE_CANCEL,\n  STATUS_CODE_INTERNAL_ERROR,\n  STATUS_CODE_FLOW_CONTROL_ERROR,\n  STATUS_CODE_STREAM_IN_USE,\n  STATUS_CODE_STREAM_ALREADY_CLOSED,\n  STATUS_CODE_INVALID_CREDENTIALS,\n  STATUS_CODE_FRAME_TOO_LARGE,\n  // SpdySession errors\n  PROTOCOL_ERROR_UNEXPECTED_PING,\n  PROTOCOL_ERROR_RST_STREAM_FOR_NON_ACTIVE_STREAM,\n  PROTOCOL_ERROR_SPDY_COMPRESSION_FAILURE,\n  PROTOCOL_ERROR_REQUEST_FOR_SECURE_CONTENT_OVER_INSECURE_SESSION,\n  PROTOCOL_ERROR_SYN_REPLY_NOT_RECEIVED,\n  PROTOCOL_ERROR_INVALID_WINDOW_UPDATE_SIZE,\n  PROTOCOL_ERROR_RECEIVE_WINDOW_VIOLATION,\n  NUM_SPDY_PROTOCOL_ERROR_DETAILS\n};\n\nCOMPILE_ASSERT(STATUS_CODE_INVALID ==\n               static_cast<SpdyProtocolErrorDetails>(SpdyFramer::LAST_ERROR),\n               SpdyProtocolErrorDetails_SpdyErrors_mismatch);\n\nCOMPILE_ASSERT(PROTOCOL_ERROR_UNEXPECTED_PING ==\n               static_cast<SpdyProtocolErrorDetails>(\n                   RST_STREAM_NUM_STATUS_CODES + STATUS_CODE_INVALID),\n               SpdyProtocolErrorDetails_SpdyErrors_mismatch);\n\n// A helper class used to manage a request to create a stream.\nclass NET_EXPORT_PRIVATE SpdyStreamRequest {\n public:\n  SpdyStreamRequest();\n  // Calls CancelRequest().\n  ~SpdyStreamRequest();\n\n  // Starts the request to create a stream. If OK is returned, then\n  // ReleaseStream() may be called. If ERR_IO_PENDING is returned,\n  // then when the stream is created, |callback| will be called, at\n  // which point ReleaseStream() may be called. Otherwise, the stream\n  // is not created, an error is returned, and ReleaseStream() may not\n  // be called.\n  //\n  // If OK is returned, must not be called again without\n  // ReleaseStream() being called first. If ERR_IO_PENDING is\n  // returned, must not be called again without CancelRequest() or\n  // ReleaseStream() being called first. Otherwise, in case of an\n  // immediate error, this may be called again.\n  int StartRequest(SpdyStreamType type,\n                   const base::WeakPtr<SpdySession>& session,\n                   const GURL& url,\n                   RequestPriority priority,\n                   const BoundNetLog& net_log,\n                   const CompletionCallback& callback);\n\n  // Cancels any pending stream creation request. May be called\n  // repeatedly.\n  void CancelRequest();\n\n  // Transfers the created stream (guaranteed to not be NULL) to the\n  // caller. Must be called at most once after StartRequest() returns\n  // OK or |callback| is called with OK. The caller must immediately\n  // set a delegate for the returned stream (except for test code).\n  base::WeakPtr<SpdyStream> ReleaseStream();\n\n private:\n  friend class SpdySession;\n\n  // Called by |session_| when the stream attempt has finished\n  // successfully.\n  void OnRequestCompleteSuccess(base::WeakPtr<SpdyStream>* stream);\n\n  // Called by |session_| when the stream attempt has finished with an\n  // error. Also called with ERR_ABORTED if |session_| is destroyed\n  // while the stream attempt is still pending.\n  void OnRequestCompleteFailure(int rv);\n\n  // Accessors called by |session_|.\n  SpdyStreamType type() const { return type_; }\n  const GURL& url() const { return url_; }\n  RequestPriority priority() const { return priority_; }\n  const BoundNetLog& net_log() const { return net_log_; }\n\n  void Reset();\n\n  SpdyStreamType type_;\n  base::WeakPtr<SpdySession> session_;\n  base::WeakPtr<SpdyStream> stream_;\n  GURL url_;\n  RequestPriority priority_;\n  BoundNetLog net_log_;\n  CompletionCallback callback_;\n\n  DISALLOW_COPY_AND_ASSIGN(SpdyStreamRequest);\n};\n\nclass NET_EXPORT SpdySession : public BufferedSpdyFramerVisitorInterface,\n                               public SpdyFramerDebugVisitorInterface,\n                               public LayeredPool {\n public:\n  // TODO(akalin): Use base::TickClock when it becomes available.\n  typedef base::TimeTicks (*TimeFunc)(void);\n\n  // How we handle flow control (version-dependent).\n  enum FlowControlState {\n    FLOW_CONTROL_NONE,\n    FLOW_CONTROL_STREAM,\n    FLOW_CONTROL_STREAM_AND_SESSION\n  };\n\n  // Create a new SpdySession.\n  // |spdy_session_key| is the host/port that this session connects to, privacy\n  // and proxy configuration settings that it's using.\n  // |session| is the HttpNetworkSession.  |net_log| is the NetLog that we log\n  // network events to.\n  SpdySession(const SpdySessionKey& spdy_session_key,\n              const base::WeakPtr<HttpServerProperties>& http_server_properties,\n              bool verify_domain_authentication,\n              bool enable_sending_initial_data,\n              bool enable_credential_frames,\n              bool enable_compression,\n              bool enable_ping_based_connection_checking,\n              NextProto default_protocol,\n              size_t stream_initial_recv_window_size,\n              size_t initial_max_concurrent_streams,\n              size_t max_concurrent_streams_limit,\n              TimeFunc time_func,\n              const HostPortPair& trusted_spdy_proxy,\n              NetLog* net_log);\n\n  virtual ~SpdySession();\n\n  const HostPortPair& host_port_pair() const {\n    return spdy_session_key_.host_port_proxy_pair().first;\n  }\n  const HostPortProxyPair& host_port_proxy_pair() const {\n    return spdy_session_key_.host_port_proxy_pair();\n  }\n  const SpdySessionKey& spdy_session_key() const {\n    return spdy_session_key_;\n  }\n  // Get a pushed stream for a given |url|.  If the server initiates a\n  // stream, it might already exist for a given path.  The server\n  // might also not have initiated the stream yet, but indicated it\n  // will via X-Associated-Content.  Returns OK if a stream was found\n  // and put into |spdy_stream|, or if one was not found but it is\n  // okay to create a new stream (in which case |spdy_stream| is\n  // reset).  Returns an error (not ERR_IO_PENDING) otherwise, and\n  // resets |spdy_stream|.\n  int GetPushStream(\n      const GURL& url,\n      base::WeakPtr<SpdyStream>* spdy_stream,\n      const BoundNetLog& stream_net_log);\n\n  // Initialize the session with the given connection. |is_secure|\n  // must indicate whether |connection| uses an SSL socket or not; it\n  // is usually true, but it can be false for testing or when SPDY is\n  // configured to work with non-secure sockets.\n  //\n  // |pool| is the SpdySessionPool that owns us.  Its lifetime must\n  // strictly be greater than |this|.\n  //\n  // |certificate_error_code| must either be OK or less than\n  // ERR_IO_PENDING.\n  //\n  // Returns OK on success, or an error on failure. Never returns\n  // ERR_IO_PENDING. If an error is returned, the session must be\n  // destroyed immediately.\n  Error InitializeWithSocket(scoped_ptr<ClientSocketHandle> connection,\n                             SpdySessionPool* pool,\n                             bool is_secure,\n                             int certificate_error_code);\n\n  // Returns the protocol used by this session. Always between\n  // kProtoSPDY2 and kProtoSPDYMaximumVersion.\n  //\n  // TODO(akalin): Change the lower bound to kProtoSPDYMinimumVersion\n  // once we stop supporting SPDY/1.\n  NextProto protocol() const { return protocol_; }\n\n  // Check to see if this SPDY session can support an additional domain.\n  // If the session is un-authenticated, then this call always returns true.\n  // For SSL-based sessions, verifies that the server certificate in use by\n  // this session provides authentication for the domain and no client\n  // certificate or channel ID was sent to the original server during the SSL\n  // handshake.  NOTE:  This function can have false negatives on some\n  // platforms.\n  // TODO(wtc): rename this function and the Net.SpdyIPPoolDomainMatch\n  // histogram because this function does more than verifying domain\n  // authentication now.\n  bool VerifyDomainAuthentication(const std::string& domain);\n\n  // Pushes the given producer into the write queue for\n  // |stream|. |stream| is guaranteed to be activated before the\n  // producer is used to produce its frame.\n  void EnqueueStreamWrite(const base::WeakPtr<SpdyStream>& stream,\n                          SpdyFrameType frame_type,\n                          scoped_ptr<SpdyBufferProducer> producer);\n\n  // Creates and returns a SYN frame for |stream_id|.\n  scoped_ptr<SpdyFrame> CreateSynStream(\n      SpdyStreamId stream_id,\n      RequestPriority priority,\n      uint8 credential_slot,\n      SpdyControlFlags flags,\n      const SpdyHeaderBlock& headers);\n\n  // Tries to create a CREDENTIAL frame. If successful, fills in\n  // |credential_frame| and returns OK. Returns the error (guaranteed\n  // to not be ERR_IO_PENDING) otherwise.\n  int CreateCredentialFrame(const std::string& origin,\n                            const std::string& key,\n                            const std::string& cert,\n                            RequestPriority priority,\n                            scoped_ptr<SpdyFrame>* credential_frame);\n\n  // Creates and returns a SpdyBuffer holding a data frame with the\n  // given data. May return NULL if stalled by flow control.\n  scoped_ptr<SpdyBuffer> CreateDataBuffer(SpdyStreamId stream_id,\n                                          IOBuffer* data,\n                                          int len,\n                                          SpdyDataFlags flags);\n\n  // Close the stream with the given ID, which must exist and be\n  // active. Note that that stream may hold the last reference to the\n  // session.\n  void CloseActiveStream(SpdyStreamId stream_id, int status);\n\n  // Close the given created stream, which must exist but not yet be\n  // active. Note that |stream| may hold the last reference to the\n  // session.\n  void CloseCreatedStream(const base::WeakPtr<SpdyStream>& stream, int status);\n\n  // Send a RST_STREAM frame with the given status code and close the\n  // stream with the given ID, which must exist and be active. Note\n  // that that stream may hold the last reference to the session.\n  void ResetStream(SpdyStreamId stream_id,\n                   SpdyRstStreamStatus status,\n                   const std::string& description);\n\n  // Check if a stream is active.\n  bool IsStreamActive(SpdyStreamId stream_id) const;\n\n  // The LoadState is used for informing the user of the current network\n  // status, such as \"resolving host\", \"connecting\", etc.\n  LoadState GetLoadState() const;\n\n  // Fills SSL info in |ssl_info| and returns true when SSL is in use.\n  bool GetSSLInfo(SSLInfo* ssl_info,\n                  bool* was_npn_negotiated,\n                  NextProto* protocol_negotiated);\n\n  // Fills SSL Certificate Request info |cert_request_info| and returns\n  // true when SSL is in use.\n  bool GetSSLCertRequestInfo(SSLCertRequestInfo* cert_request_info);\n\n  // Returns the ServerBoundCertService used by this Socket, or NULL\n  // if server bound certs are not supported in this session.\n  ServerBoundCertService* GetServerBoundCertService() const;\n\n  // Send a WINDOW_UPDATE frame for a stream. Called by a stream\n  // whenever receive window size is increased.\n  void SendStreamWindowUpdate(SpdyStreamId stream_id,\n                              uint32 delta_window_size);\n\n  // Whether the stream is closed, i.e. it has stopped processing data\n  // and is about to be destroyed.\n  //\n  // TODO(akalin): This is only used in tests. Remove this function\n  // and have tests test the WeakPtr instead.\n  bool IsClosed() const { return availability_state_ == STATE_CLOSED; }\n\n  // Closes this session. This will close all active streams and mark\n  // the session as permanently closed. Callers must assume that the\n  // session is destroyed after this is called. (However, it may not\n  // be destroyed right away, e.g. when a SpdySession function is\n  // present in the call stack.)\n  //\n  // |err| should be < ERR_IO_PENDING; this function is intended to be\n  // called on error.\n  // |description| indicates the reason for the error.\n  void CloseSessionOnError(Error err, const std::string& description);\n\n  // Retrieves information on the current state of the SPDY session as a\n  // Value.  Caller takes possession of the returned value.\n  base::Value* GetInfoAsValue() const;\n\n  // Indicates whether the session is being reused after having successfully\n  // used to send/receive data in the past.\n  bool IsReused() const;\n\n  // Returns true if the underlying transport socket ever had any reads or\n  // writes.\n  bool WasEverUsed() const {\n    return connection_->socket()->WasEverUsed();\n  }\n\n  // Returns the load timing information from the perspective of the given\n  // stream.  If it's not the first stream, the connection is considered reused\n  // for that stream.\n  //\n  // This uses a different notion of reuse than IsReused().  This function\n  // sets |socket_reused| to false only if |stream_id| is the ID of the first\n  // stream using the session.  IsReused(), on the other hand, indicates if the\n  // session has been used to send/receive data at all.\n  bool GetLoadTimingInfo(SpdyStreamId stream_id,\n                         LoadTimingInfo* load_timing_info) const;\n\n  // Returns true if session is not currently active\n  bool is_active() const {\n    return !active_streams_.empty() || !created_streams_.empty();\n  }\n\n  // Access to the number of active and pending streams.  These are primarily\n  // available for testing and diagnostics.\n  size_t num_active_streams() const { return active_streams_.size(); }\n  size_t num_unclaimed_pushed_streams() const {\n      return unclaimed_pushed_streams_.size();\n  }\n  size_t num_created_streams() const { return created_streams_.size(); }\n\n  size_t pending_create_stream_queue_size(RequestPriority priority) const {\n    DCHECK_LT(priority, NUM_PRIORITIES);\n    return pending_create_stream_queues_[priority].size();\n  }\n\n  // Returns the (version-dependent) flow control state.\n  FlowControlState flow_control_state() const {\n    return flow_control_state_;\n  }\n\n  // Returns the current |stream_initial_send_window_size_|.\n  int32 stream_initial_send_window_size() const {\n    return stream_initial_send_window_size_;\n  }\n\n  // Returns the current |stream_initial_recv_window_size_|.\n  int32 stream_initial_recv_window_size() const {\n    return stream_initial_recv_window_size_;\n  }\n\n  // Returns true if no stream in the session can send data due to\n  // session flow control.\n  bool IsSendStalled() const {\n    return\n        flow_control_state_ == FLOW_CONTROL_STREAM_AND_SESSION &&\n        session_send_window_size_ == 0;\n  }\n\n  const BoundNetLog& net_log() const { return net_log_; }\n\n  int GetPeerAddress(IPEndPoint* address) const;\n  int GetLocalAddress(IPEndPoint* address) const;\n\n  // Returns true if requests on this session require credentials.\n  bool NeedsCredentials() const;\n\n  SpdyCredentialState* credential_state() { return &credential_state_; }\n\n  // Adds |alias| to set of aliases associated with this session.\n  void AddPooledAlias(const SpdySessionKey& alias_key);\n\n  // Returns the set of aliases associated with this session.\n  const std::set<SpdySessionKey>& pooled_aliases() const {\n    return pooled_aliases_;\n  }\n\n  int GetProtocolVersion() const;\n\n  size_t GetDataFrameMinimumSize() const {\n    return buffered_spdy_framer_->GetDataFrameMinimumSize();\n  }\n\n  size_t GetControlFrameHeaderSize() const {\n    return buffered_spdy_framer_->GetControlFrameHeaderSize();\n  }\n\n  size_t GetFrameMinimumSize() const {\n    return buffered_spdy_framer_->GetFrameMinimumSize();\n  }\n\n  size_t GetFrameMaximumSize() const {\n    return buffered_spdy_framer_->GetFrameMaximumSize();\n  }\n\n  size_t GetDataFrameMaximumPayload() const {\n    return buffered_spdy_framer_->GetDataFrameMaximumPayload();\n  }\n\n  // Must be used only by |pool_|.\n  base::WeakPtr<SpdySession> GetWeakPtr();\n\n  // LayeredPool implementation:\n  virtual bool CloseOneIdleConnection() OVERRIDE;\n\n private:\n  friend class base::RefCounted<SpdySession>;\n  friend class SpdyStreamRequest;\n  friend class SpdySessionTest;\n\n  // Allow tests to access our innards for testing purposes.\n  FRIEND_TEST_ALL_PREFIXES(SpdySessionTest, ClientPing);\n  FRIEND_TEST_ALL_PREFIXES(SpdySessionTest, FailedPing);\n  FRIEND_TEST_ALL_PREFIXES(SpdySessionTest, GetActivePushStream);\n  FRIEND_TEST_ALL_PREFIXES(SpdySessionTest, DeleteExpiredPushStreams);\n  FRIEND_TEST_ALL_PREFIXES(SpdySessionTest, ProtocolNegotiation);\n  FRIEND_TEST_ALL_PREFIXES(SpdySessionTest, ClearSettings);\n  FRIEND_TEST_ALL_PREFIXES(SpdySessionTest, AdjustRecvWindowSize);\n  FRIEND_TEST_ALL_PREFIXES(SpdySessionTest, AdjustSendWindowSize);\n  FRIEND_TEST_ALL_PREFIXES(SpdySessionTest, SessionFlowControlInactiveStream);\n  FRIEND_TEST_ALL_PREFIXES(SpdySessionTest, SessionFlowControlNoReceiveLeaks);\n  FRIEND_TEST_ALL_PREFIXES(SpdySessionTest, SessionFlowControlNoSendLeaks);\n  FRIEND_TEST_ALL_PREFIXES(SpdySessionTest, SessionFlowControlEndToEnd);\n\n  typedef std::deque<SpdyStreamRequest*> PendingStreamRequestQueue;\n  typedef std::set<SpdyStreamRequest*> PendingStreamRequestCompletionSet;\n\n  struct ActiveStreamInfo {\n    ActiveStreamInfo();\n    explicit ActiveStreamInfo(SpdyStream* stream);\n    ~ActiveStreamInfo();\n\n    SpdyStream* stream;\n    bool waiting_for_syn_reply;\n  };\n  typedef std::map<SpdyStreamId, ActiveStreamInfo> ActiveStreamMap;\n\n  struct PushedStreamInfo {\n    PushedStreamInfo();\n    PushedStreamInfo(SpdyStreamId stream_id, base::TimeTicks creation_time);\n    ~PushedStreamInfo();\n\n    SpdyStreamId stream_id;\n    base::TimeTicks creation_time;\n  };\n  typedef std::map<GURL, PushedStreamInfo> PushedStreamMap;\n\n  typedef std::set<SpdyStream*> CreatedStreamSet;\n\n  enum AvailabilityState {\n    // The session is available in its socket pool and can be used\n    // freely.\n    STATE_AVAILABLE,\n    // The session can process data on existing streams but will\n    // refuse to create new ones.\n    STATE_GOING_AWAY,\n    // The session has been closed, is waiting to be deleted, and will\n    // refuse to process any more data.\n    STATE_CLOSED\n  };\n\n  enum ReadState {\n    READ_STATE_DO_READ,\n    READ_STATE_DO_READ_COMPLETE,\n  };\n\n  enum WriteState {\n    // There is no in-flight write and the write queue is empty.\n    WRITE_STATE_IDLE,\n    WRITE_STATE_DO_WRITE,\n    WRITE_STATE_DO_WRITE_COMPLETE,\n  };\n\n  // The return value of DoCloseSession() describing what was done.\n  enum CloseSessionResult {\n    // The session was already closed so nothing was done.\n    SESSION_ALREADY_CLOSED,\n    // The session was moved into the closed state but was not removed\n    // from |pool_| (because we're in an IO loop).\n    SESSION_CLOSED_BUT_NOT_REMOVED,\n    // The session was moved into the closed state and removed from\n    // |pool_|.\n    SESSION_CLOSED_AND_REMOVED,\n  };\n\n  // Checks whether a stream for the given |url| can be created or\n  // retrieved from the set of unclaimed push streams. Returns OK if\n  // so. Otherwise, the session is closed and an error <\n  // ERR_IO_PENDING is returned.\n  Error TryAccessStream(const GURL& url);\n\n  // Called by SpdyStreamRequest to start a request to create a\n  // stream. If OK is returned, then |stream| will be filled in with a\n  // valid stream. If ERR_IO_PENDING is returned, then\n  // |request->OnRequestComplete{Success,Failure}()| will be called\n  // when the stream is created (unless it is cancelled). Otherwise,\n  // no stream is created and the error is returned.\n  int TryCreateStream(SpdyStreamRequest* request,\n                      base::WeakPtr<SpdyStream>* stream);\n\n  // Actually create a stream into |stream|. Returns OK if successful;\n  // otherwise, returns an error and |stream| is not filled.\n  int CreateStream(const SpdyStreamRequest& request,\n                   base::WeakPtr<SpdyStream>* stream);\n\n  // Called by SpdyStreamRequest to remove |request| from the stream\n  // creation queue.\n  void CancelStreamRequest(SpdyStreamRequest* request);\n\n  // Called when there is room to create more streams (e.g., a stream\n  // was closed). Processes as many pending stream requests as\n  // possible.\n  void ProcessPendingStreamRequests();\n\n  // Close the stream pointed to by the given iterator. Note that that\n  // stream may hold the last reference to the session.\n  void CloseActiveStreamIterator(ActiveStreamMap::iterator it, int status);\n\n  // Close the stream pointed to by the given iterator. Note that that\n  // stream may hold the last reference to the session.\n  void CloseCreatedStreamIterator(CreatedStreamSet::iterator it, int status);\n\n  // Calls EnqueueResetStreamFrame() and then\n  // CloseActiveStreamIterator().\n  void ResetStreamIterator(ActiveStreamMap::iterator it,\n                           SpdyRstStreamStatus status,\n                           const std::string& description);\n\n  // Send a RST_STREAM frame with the given parameters. There should\n  // either be no active stream with the given ID, or that active\n  // stream should be closed shortly after this function is called.\n  //\n  // TODO(akalin): Rename this to EnqueueResetStreamFrame().\n  void EnqueueResetStreamFrame(SpdyStreamId stream_id,\n                               RequestPriority priority,\n                               SpdyRstStreamStatus status,\n                               const std::string& description);\n\n  // Calls DoReadLoop and then if |availability_state_| is\n  // STATE_CLOSED, calls RemoveFromPool().\n  //\n  // Use this function instead of DoReadLoop when posting a task to\n  // pump the read loop.\n  void PumpReadLoop(ReadState expected_read_state, int result);\n\n  // Advance the ReadState state machine. |expected_read_state| is the\n  // expected starting read state.\n  //\n  // This function must always be called via PumpReadLoop() except for\n  // from InitializeWithSocket().\n  int DoReadLoop(ReadState expected_read_state, int result);\n  // The implementations of the states of the ReadState state machine.\n  int DoRead();\n  int DoReadComplete(int result);\n\n  // Calls DoWriteLoop and then if |availability_state_| is\n  // STATE_CLOSED, calls RemoveFromPool().\n  //\n  // Use this function instead of DoWriteLoop when posting a task to\n  // pump the write loop.\n  void PumpWriteLoop(WriteState expected_write_state, int result);\n\n  // Advance the WriteState state machine. |expected_write_state| is\n  // the expected starting write state.\n  //\n  // This function must always be called via PumpWriteLoop().\n  int DoWriteLoop(WriteState expected_write_state, int result);\n  // The implementations of the states of the WriteState state machine.\n  int DoWrite();\n  int DoWriteComplete(int result);\n\n  // TODO(akalin): Rename the Send* and Write* functions below to\n  // Enqueue*.\n\n  // Send initial data. Called when a connection is successfully\n  // established in InitializeWithSocket() and\n  // |enable_sending_initial_data_| is true.\n  void SendInitialData();\n\n  // Helper method to send a SETTINGS frame.\n  void SendSettings(const SettingsMap& settings);\n\n  // Handle SETTING.  Either when we send settings, or when we receive a\n  // SETTINGS control frame, update our SpdySession accordingly.\n  void HandleSetting(uint32 id, uint32 value);\n\n  // Adjust the send window size of all ActiveStreams and PendingStreamRequests.\n  void UpdateStreamsSendWindowSize(int32 delta_window_size);\n\n  // Send the PING (preface-PING) frame.\n  void SendPrefacePingIfNoneInFlight();\n\n  // Send PING if there are no PINGs in flight and we haven't heard from server.\n  void SendPrefacePing();\n\n  // Send a single WINDOW_UPDATE frame.\n  void SendWindowUpdateFrame(SpdyStreamId stream_id, uint32 delta_window_size,\n                             RequestPriority priority);\n\n  // Send the PING frame.\n  void WritePingFrame(uint32 unique_id);\n\n  // Post a CheckPingStatus call after delay. Don't post if there is already\n  // CheckPingStatus running.\n  void PlanToCheckPingStatus();\n\n  // Check the status of the connection. It calls |CloseSessionOnError| if we\n  // haven't received any data in |kHungInterval| time period.\n  void CheckPingStatus(base::TimeTicks last_check_time);\n\n  // Get a new stream id.\n  int GetNewStreamId();\n\n  // Pushes the given frame with the given priority into the write\n  // queue for the session.\n  void EnqueueSessionWrite(RequestPriority priority,\n                           SpdyFrameType frame_type,\n                           scoped_ptr<SpdyFrame> frame);\n\n  // Puts |producer| associated with |stream| onto the write queue\n  // with the given priority.\n  void EnqueueWrite(RequestPriority priority,\n                    SpdyFrameType frame_type,\n                    scoped_ptr<SpdyBufferProducer> producer,\n                    const base::WeakPtr<SpdyStream>& stream);\n\n  // Inserts a newly-created stream into |created_streams_|.\n  void InsertCreatedStream(scoped_ptr<SpdyStream> stream);\n\n  // Activates |stream| (which must be in |created_streams_|) by\n  // assigning it an ID and returns it.\n  scoped_ptr<SpdyStream> ActivateCreatedStream(SpdyStream* stream);\n\n  // Inserts a newly-activated stream into |active_streams_|.\n  void InsertActivatedStream(scoped_ptr<SpdyStream> stream);\n\n  // Remove all internal references to |stream|, call OnClose() on it,\n  // and process any pending stream requests before deleting it.  Note\n  // that |stream| may hold the last reference to the session.\n  void DeleteStream(scoped_ptr<SpdyStream> stream, int status);\n\n  // Check if we have a pending pushed-stream for this url\n  // Returns the stream if found (and returns it from the pending\n  // list). Returns NULL otherwise.\n  base::WeakPtr<SpdyStream> GetActivePushStream(const GURL& url);\n\n  // Delegates to |stream->OnInitialResponseHeadersReceived()|. If an\n  // error is returned, the last reference to |this| may have been\n  // released.\n  int OnInitialResponseHeadersReceived(const SpdyHeaderBlock& response_headers,\n                                       base::Time response_time,\n                                       base::TimeTicks recv_first_byte_time,\n                                       SpdyStream* stream);\n\n  void RecordPingRTTHistogram(base::TimeDelta duration);\n  void RecordHistograms();\n  void RecordProtocolErrorHistogram(SpdyProtocolErrorDetails details);\n\n  // DCHECKs that |availability_state_| >= STATE_GOING_AWAY, that\n  // there are no pending stream creation requests, and that there are\n  // no created streams.\n  void DcheckGoingAway() const;\n\n  // Calls DcheckGoingAway(), then DCHECKs that |availability_state_|\n  // == STATE_CLOSED, |error_on_close_| has a valid value, that there\n  // are no active streams or unclaimed pushed streams, and that the\n  // write queue is empty.\n  void DcheckClosed() const;\n\n  // Closes all active streams with stream id's greater than\n  // |last_good_stream_id|, as well as any created or pending\n  // streams. Must be called only when |availability_state_| >=\n  // STATE_GOING_AWAY. After this function, DcheckGoingAway() will\n  // pass. May be called multiple times.\n  void StartGoingAway(SpdyStreamId last_good_stream_id, Error status);\n\n  // Must be called only when going away (i.e., DcheckGoingAway()\n  // passes). If there are no more active streams and the session\n  // isn't closed yet, close it.\n  void MaybeFinishGoingAway();\n\n  // If the stream is already closed, does nothing. Otherwise, moves\n  // the session to a closed state. Then, if we're in an IO loop,\n  // returns (as the IO loop will do the pool removal itself when its\n  // done). Otherwise, also removes |this| from |pool_|. The returned\n  // result describes what was done.\n  CloseSessionResult DoCloseSession(Error err, const std::string& description);\n\n  // Remove this session from its pool, which must exist. Must be\n  // called only when the session is closed.\n  //\n  // Must be called only via Pump{Read,Write}Loop() or\n  // DoCloseSession().\n  void RemoveFromPool();\n\n  // Called right before closing a (possibly-inactive) stream for a\n  // reason other than being requested to by the stream.\n  void LogAbandonedStream(SpdyStream* stream, Error status);\n\n  // Called right before closing an active stream for a reason other\n  // than being requested to by the stream.\n  void LogAbandonedActiveStream(ActiveStreamMap::const_iterator it,\n                                Error status);\n\n  // Invokes a user callback for stream creation.  We provide this method so it\n  // can be deferred to the MessageLoop, so we avoid re-entrancy problems.\n  void CompleteStreamRequest(SpdyStreamRequest* pending_request);\n\n  // Remove old unclaimed pushed streams.\n  void DeleteExpiredPushedStreams();\n\n  // BufferedSpdyFramerVisitorInterface:\n  virtual void OnError(SpdyFramer::SpdyError error_code) OVERRIDE;\n  virtual void OnStreamError(SpdyStreamId stream_id,\n                             const std::string& description) OVERRIDE;\n  virtual void OnPing(uint32 unique_id) OVERRIDE;\n  virtual void OnRstStream(SpdyStreamId stream_id,\n                           SpdyRstStreamStatus status) OVERRIDE;\n  virtual void OnGoAway(SpdyStreamId last_accepted_stream_id,\n                        SpdyGoAwayStatus status) OVERRIDE;\n  virtual void OnStreamFrameData(SpdyStreamId stream_id,\n                                 const char* data,\n                                 size_t len,\n                                 bool fin) OVERRIDE;\n  virtual void OnSettings(bool clear_persisted) OVERRIDE;\n  virtual void OnSetting(\n      SpdySettingsIds id, uint8 flags, uint32 value) OVERRIDE;\n  virtual void OnWindowUpdate(SpdyStreamId stream_id,\n                              uint32 delta_window_size) OVERRIDE;\n  virtual void OnPushPromise(SpdyStreamId stream_id,\n                             SpdyStreamId promised_stream_id) OVERRIDE;\n  virtual void OnSynStream(SpdyStreamId stream_id,\n                           SpdyStreamId associated_stream_id,\n                           SpdyPriority priority,\n                           uint8 credential_slot,\n                           bool fin,\n                           bool unidirectional,\n                           const SpdyHeaderBlock& headers) OVERRIDE;\n  virtual void OnSynReply(\n      SpdyStreamId stream_id,\n      bool fin,\n      const SpdyHeaderBlock& headers) OVERRIDE;\n  virtual void OnHeaders(\n      SpdyStreamId stream_id,\n      bool fin,\n      const SpdyHeaderBlock& headers) OVERRIDE;\n\n  // SpdyFramerDebugVisitorInterface\n  virtual void OnSendCompressedFrame(\n      SpdyStreamId stream_id,\n      SpdyFrameType type,\n      size_t payload_len,\n      size_t frame_len) OVERRIDE;\n  virtual void OnReceiveCompressedFrame(\n      SpdyStreamId stream_id,\n      SpdyFrameType type,\n      size_t frame_len) OVERRIDE {}\n\n  // Called when bytes are consumed from a SpdyBuffer for a DATA frame\n  // that is to be written or is being written. Increases the send\n  // window size accordingly if some or all of the SpdyBuffer is being\n  // discarded.\n  //\n  // If session flow control is turned off, this must not be called.\n  void OnWriteBufferConsumed(size_t frame_payload_size,\n                             size_t consume_size,\n                             SpdyBuffer::ConsumeSource consume_source);\n\n  // Called by OnWindowUpdate() (which is in turn called by the\n  // framer) to increase this session's send window size by\n  // |delta_window_size| from a WINDOW_UPDATE frome, which must be at\n  // least 1. If |delta_window_size| would cause this session's send\n  // window size to overflow, does nothing.\n  //\n  // If session flow control is turned off, this must not be called.\n  void IncreaseSendWindowSize(int32 delta_window_size);\n\n  // If session flow control is turned on, called by CreateDataFrame()\n  // (which is in turn called by a stream) to decrease this session's\n  // send window size by |delta_window_size|, which must be at least 1\n  // and at most kMaxSpdyFrameChunkSize.  |delta_window_size| must not\n  // cause this session's send window size to go negative.\n  //\n  // If session flow control is turned off, this must not be called.\n  void DecreaseSendWindowSize(int32 delta_window_size);\n\n  // Called when bytes are consumed by the delegate from a SpdyBuffer\n  // containing received data. Increases the receive window size\n  // accordingly.\n  //\n  // If session flow control is turned off, this must not be called.\n  void OnReadBufferConsumed(size_t consume_size,\n                            SpdyBuffer::ConsumeSource consume_source);\n\n  // Called by OnReadBufferConsume to increase this session's receive\n  // window size by |delta_window_size|, which must be at least 1 and\n  // must not cause this session's receive window size to overflow,\n  // possibly also sending a WINDOW_UPDATE frame. Also called during\n  // initialization to set the initial receive window size.\n  //\n  // If session flow control is turned off, this must not be called.\n  void IncreaseRecvWindowSize(int32 delta_window_size);\n\n  // Called by OnStreamFrameData (which is in turn called by the\n  // framer) to decrease this session's receive window size by\n  // |delta_window_size|, which must be at least 1 and must not cause\n  // this session's receive window size to go negative.\n  //\n  // If session flow control is turned off, this must not be called.\n  void DecreaseRecvWindowSize(int32 delta_window_size);\n\n  // Queue a send-stalled stream for possibly resuming once we're not\n  // send-stalled anymore.\n  void QueueSendStalledStream(const SpdyStream& stream);\n\n  // Go through the queue of send-stalled streams and try to resume as\n  // many as possible.\n  void ResumeSendStalledStreams();\n\n  // Returns the next stream to possibly resume, or 0 if the queue is\n  // empty.\n  SpdyStreamId PopStreamToPossiblyResume();\n\n  // --------------------------\n  // Helper methods for testing\n  // --------------------------\n\n  void set_connection_at_risk_of_loss_time(base::TimeDelta duration) {\n    connection_at_risk_of_loss_time_ = duration;\n  }\n\n  void set_hung_interval(base::TimeDelta duration) {\n    hung_interval_ = duration;\n  }\n\n  int64 pings_in_flight() const { return pings_in_flight_; }\n\n  uint32 next_ping_id() const { return next_ping_id_; }\n\n  base::TimeTicks last_activity_time() const { return last_activity_time_; }\n\n  bool check_ping_status_pending() const { return check_ping_status_pending_; }\n\n  size_t max_concurrent_streams() const { return max_concurrent_streams_; }\n\n  // Returns the SSLClientSocket that this SPDY session sits on top of,\n  // or NULL, if the transport is not SSL.\n  SSLClientSocket* GetSSLClientSocket() const;\n\n  // Used for posting asynchronous IO tasks.  We use this even though\n  // SpdySession is refcounted because we don't need to keep the SpdySession\n  // alive if the last reference is within a RunnableMethod.  Just revoke the\n  // method.\n  base::WeakPtrFactory<SpdySession> weak_factory_;\n\n  // Whether Do{Read,Write}Loop() is in the call stack. Useful for\n  // making sure we don't destroy ourselves prematurely in that case.\n  bool in_io_loop_;\n\n  // The key used to identify this session.\n  const SpdySessionKey spdy_session_key_;\n\n  // Set set of SpdySessionKeys for which this session has serviced\n  // requests.\n  std::set<SpdySessionKey> pooled_aliases_;\n\n  // |pool_| owns us, therefore its lifetime must exceed ours.  We set\n  // this to NULL after we are removed from the pool.\n  SpdySessionPool* pool_;\n  const base::WeakPtr<HttpServerProperties> http_server_properties_;\n\n  // The socket handle for this session.\n  scoped_ptr<ClientSocketHandle> connection_;\n\n  // The read buffer used to read data from the socket.\n  scoped_refptr<IOBuffer> read_buffer_;\n\n  int stream_hi_water_mark_;  // The next stream id to use.\n\n  // Queue, for each priority, of pending stream requests that have\n  // not yet been satisfied.\n  PendingStreamRequestQueue pending_create_stream_queues_[NUM_PRIORITIES];\n\n  // A set of requests that are waiting to be completed (i.e., for the\n  // stream to actually be created). This is necessary since we kick\n  // off the stream creation asynchronously, and so the request may be\n  // cancelled before the asynchronous task to create the stream runs.\n  PendingStreamRequestCompletionSet pending_stream_request_completions_;\n\n  // Map from stream id to all active streams.  Streams are active in the sense\n  // that they have a consumer (typically SpdyNetworkTransaction and regardless\n  // of whether or not there is currently any ongoing IO [might be waiting for\n  // the server to start pushing the stream]) or there are still network events\n  // incoming even though the consumer has already gone away (cancellation).\n  //\n  // |active_streams_| owns all its SpdyStream objects.\n  //\n  // TODO(willchan): Perhaps we should separate out cancelled streams and move\n  // them into a separate ActiveStreamMap, and not deliver network events to\n  // them?\n  ActiveStreamMap active_streams_;\n\n  // (Bijective) map from the URL to the ID of the streams that have\n  // already started to be pushed by the server, but do not have\n  // consumers yet. Contains a subset of |active_streams_|.\n  PushedStreamMap unclaimed_pushed_streams_;\n\n  // Set of all created streams but that have not yet sent any frames.\n  //\n  // |created_streams_| owns all its SpdyStream objects.\n  CreatedStreamSet created_streams_;\n\n  // The write queue.\n  SpdyWriteQueue write_queue_;\n\n  // Data for the frame we are currently sending.\n\n  // The buffer we're currently writing.\n  scoped_ptr<SpdyBuffer> in_flight_write_;\n  // The type of the frame in |in_flight_write_|.\n  SpdyFrameType in_flight_write_frame_type_;\n  // The size of the frame in |in_flight_write_|.\n  size_t in_flight_write_frame_size_;\n  // The stream to notify when |in_flight_write_| has been written to\n  // the socket completely.\n  base::WeakPtr<SpdyStream> in_flight_write_stream_;\n\n  // Flag if we're using an SSL connection for this SpdySession.\n  bool is_secure_;\n\n  // Certificate error code when using a secure connection.\n  int certificate_error_code_;\n\n  // Spdy Frame state.\n  scoped_ptr<BufferedSpdyFramer> buffered_spdy_framer_;\n\n  // The state variables.\n  AvailabilityState availability_state_;\n  ReadState read_state_;\n  WriteState write_state_;\n\n  // If the session was closed (i.e., |availability_state_| is\n  // STATE_CLOSED), then |error_on_close_| holds the error with which\n  // it was closed, which is < ERR_IO_PENDING. Otherwise, it is set to\n  // OK.\n  Error error_on_close_;\n\n  // Limits\n  size_t max_concurrent_streams_;  // 0 if no limit\n  size_t max_concurrent_streams_limit_;\n\n  // Some statistics counters for the session.\n  int streams_initiated_count_;\n  int streams_pushed_count_;\n  int streams_pushed_and_claimed_count_;\n  int streams_abandoned_count_;\n\n  // |total_bytes_received_| keeps track of all the bytes read by the\n  // SpdySession. It is used by the |Net.SpdySettingsCwnd...| histograms.\n  int total_bytes_received_;\n\n  bool sent_settings_;      // Did this session send settings when it started.\n  bool received_settings_;  // Did this session receive at least one settings\n                            // frame.\n  int stalled_streams_;     // Count of streams that were ever stalled.\n\n  // Count of all pings on the wire, for which we have not gotten a response.\n  int64 pings_in_flight_;\n\n  // This is the next ping_id (unique_id) to be sent in PING frame.\n  uint32 next_ping_id_;\n\n  // This is the last time we have sent a PING.\n  base::TimeTicks last_ping_sent_time_;\n\n  // This is the last time we had activity in the session.\n  base::TimeTicks last_activity_time_;\n\n  // This is the next time that unclaimed push streams should be checked for\n  // expirations.\n  base::TimeTicks next_unclaimed_push_stream_sweep_time_;\n\n  // Indicate if we have already scheduled a delayed task to check the ping\n  // status.\n  bool check_ping_status_pending_;\n\n  // Whether to send the (HTTP/2) connection header prefix.\n  bool send_connection_header_prefix_;\n\n  // The (version-dependent) flow control state.\n  FlowControlState flow_control_state_;\n\n  // Initial send window size for this session's streams. Can be\n  // changed by an arriving SETTINGS frame. Newly created streams use\n  // this value for the initial send window size.\n  int32 stream_initial_send_window_size_;\n\n  // Initial receive window size for this session's streams. There are\n  // plans to add a command line switch that would cause a SETTINGS\n  // frame with window size announcement to be sent on startup. Newly\n  // created streams will use this value for the initial receive\n  // window size.\n  int32 stream_initial_recv_window_size_;\n\n  // Session flow control variables. All zero unless session flow\n  // control is turned on.\n  int32 session_send_window_size_;\n  int32 session_recv_window_size_;\n  int32 session_unacked_recv_window_bytes_;\n\n  // A queue of stream IDs that have been send-stalled at some point\n  // in the past.\n  std::deque<SpdyStreamId> stream_send_unstall_queue_[NUM_PRIORITIES];\n\n  BoundNetLog net_log_;\n\n  // Outside of tests, these should always be true.\n  bool verify_domain_authentication_;\n  bool enable_sending_initial_data_;\n  bool enable_credential_frames_;\n  bool enable_compression_;\n  bool enable_ping_based_connection_checking_;\n\n  // The SPDY protocol used. Always between kProtoSPDY2 and\n  // kProtoSPDYMaximumVersion.\n  //\n  // TODO(akalin): Change the lower bound to kProtoSPDYMinimumVersion\n  // once we stop supporting SPDY/1.\n  NextProto protocol_;\n\n  SpdyCredentialState credential_state_;\n\n  // |connection_at_risk_of_loss_time_| is an optimization to avoid sending\n  // wasteful preface pings (when we just got some data).\n  //\n  // If it is zero (the most conservative figure), then we always send the\n  // preface ping (when none are in flight).\n  //\n  // It is common for TCP/IP sessions to time out in about 3-5 minutes.\n  // Certainly if it has been more than 3 minutes, we do want to send a preface\n  // ping.\n  //\n  // We don't think any connection will time out in under about 10 seconds. So\n  // this might as well be set to something conservative like 10 seconds. Later,\n  // we could adjust it to send fewer pings perhaps.\n  base::TimeDelta connection_at_risk_of_loss_time_;\n\n  // The amount of time that we are willing to tolerate with no activity (of any\n  // form), while there is a ping in flight, before we declare the connection to\n  // be hung. TODO(rtenneti): When hung, instead of resetting connection, race\n  // to build a new connection, and see if that completes before we (finally)\n  // get a PING response (http://crbug.com/127812).\n  base::TimeDelta hung_interval_;\n\n  // This SPDY proxy is allowed to push resources from origins that are\n  // different from those of their associated streams.\n  HostPortPair trusted_spdy_proxy_;\n\n  TimeFunc time_func_;\n};\n\n}  // namespace net\n\n#endif  // NET_SPDY_SPDY_SESSION_H_\n\n", "comment_ratio": 0.395979020979021}
{"lang": "c", "code": "#import <UIKitCore/UIKitCore-Structs.h>\n#import <UIKitCore/UIView.h>\n\n@class UILabel, NSMutableDictionary, NSString, NSDictionary, UIColor, _UIBadgeVisualStyle;\n\n@interface _UIBadgeView : UIView {\n\n\tUILabel* _label;\n\tNSMutableDictionary* _mergedTextAttributes;\n\tNSString* _text;\n\tNSDictionary* _textAttributes;\n\tUIColor* _badgeColor;\n\t_UIBadgeVisualStyle* _style;\n\tUIOffset _textOffset;\n\n}\n\n@property (nonatomic,copy) NSString * text;                            //@synthesize text=_text - In the implementation block\n@property (nonatomic,copy) NSDictionary * textAttributes;              //@synthesize textAttributes=_textAttributes - In the implementation block\n@property (nonatomic,copy) UIColor * badgeColor;                       //@synthesize badgeColor=_badgeColor - In the implementation block\n@property (assign,nonatomic) UIOffset textOffset;                      //@synthesize textOffset=_textOffset - In the implementation block\n@property (nonatomic,retain) _UIBadgeVisualStyle * style;              //@synthesize style=_style - In the implementation block\n-(_UIBadgeVisualStyle *)style;\n-(void)setStyle:(_UIBadgeVisualStyle *)arg1 ;\n-(NSString *)text;\n-(void)setText:(NSString *)arg1 ;\n-(CGSize)sizeThatFits:(CGSize)arg1 ;\n-(id)initWithText:(id)arg1 ;\n-(void)layoutSubviews;\n-(void)setTextAttributes:(NSDictionary *)arg1 ;\n-(NSDictionary *)textAttributes;\n-(void)setTextOffset:(UIOffset)arg1 ;\n-(UIOffset)textOffset;\n-(void)setBadgeColor:(UIColor *)arg1 ;\n-(UIColor *)badgeColor;\n-(void)_setUpLabelIfNecessary;\n-(void)_applyTextToLabel;\n@end\n\n\n", "comment_ratio": 0.10416666666666667}
{"lang": "c", "code": "#ifndef OPENFMB_PLUGIN_TIMESCALEDB_CONFIGSTRINGS_H\n#define OPENFMB_PLUGIN_TIMESCALEDB_CONFIGSTRINGS_H\n\nnamespace adapter {\nnamespace timescaledb {\n    namespace keys {\n\n        constexpr const char* const database_url = \"database-url\";\n        constexpr const char* const table_name = \"table-name\";\n        constexpr const char* const store_measurement = \"store-measurement\";\n        constexpr const char* const store_raw_message = \"store-raw-message\";\n        constexpr const char* const raw_table_name = \"raw-table-name\";\n        constexpr const char* const raw_data_format = \"raw-data-format\";\n        constexpr const char* const max_queued_messages = \"max-queued-messages\";\n        constexpr const char* const connect_retry_seconds = \"connect-retry-seconds\";\n    }\n}\n}\n\n#endif\n\n", "comment_ratio": 0.12}
{"lang": "c", "code": "#ifndef STRINGS_STRCAT_H_\n#define STRINGS_STRCAT_H_\n\n#include <string>\nusing std::string;\n\n#include \"gutil/integral_types.h\"\n#include \"gutil/strings/numbers.h\"\n#include \"gutil/strings/stringpiece.h\"\n\n// The AlphaNum type was designed to be used as the parameter type for StrCat().\n// I suppose that any routine accepting either a string or a number could accept\n// it.  The basic idea is that by accepting a \"const AlphaNum &\" as an argument\n// to your function, your callers will automagically convert bools, integers,\n// and floating point values to strings for you.\n//\n// Conversion from 8-bit values is not accepted because if it were, then an\n// attempt to pass ':' instead of \":\" might result in a 58 ending up in your\n// result.\n//\n// Bools convert to \"0\" or \"1\".\n//\n// Floating point values are converted to a string which, if passed to strtod(),\n// would produce the exact same original double (except in case of NaN; all NaNs\n// are considered the same value). We try to keep the string short but it's not\n// guaranteed to be as short as possible.\n//\n// This class has implicit constructors.\n// Style guide exception granted:\n// http://goto/style-guide-exception-20978288\n//\nstruct AlphaNum {\n    StringPiece piece;\n    char digits[kFastToBufferSize];\n\n    // No bool ctor -- bools convert to an integral type.\n    // A bool ctor would also convert incoming pointers (bletch).\n\n    AlphaNum(int32 i32) // NOLINT(runtime/explicit)\n            : piece(digits, FastInt32ToBufferLeft(i32, digits) - &digits[0]) {}\n    AlphaNum(uint32 u32) // NOLINT(runtime/explicit)\n            : piece(digits, FastUInt32ToBufferLeft(u32, digits) - &digits[0]) {}\n    AlphaNum(int64 i64) // NOLINT(runtime/explicit)\n            : piece(digits, FastInt64ToBufferLeft(i64, digits) - &digits[0]) {}\n    AlphaNum(uint64 u64) // NOLINT(runtime/explicit)\n            : piece(digits, FastUInt64ToBufferLeft(u64, digits) - &digits[0]) {}\n\n#if defined(__APPLE__)\n    AlphaNum(size_t size) // NOLINT(runtime/explicit)\n            : piece(digits, FastUInt64ToBufferLeft(size, digits) - &digits[0]) {}\n#endif\n\n    AlphaNum(float f) // NOLINT(runtime/explicit)\n            : piece(digits, strlen(FloatToBuffer(f, digits))) {}\n    AlphaNum(double f) // NOLINT(runtime/explicit)\n            : piece(digits, strlen(DoubleToBuffer(f, digits))) {}\n\n    AlphaNum(const char* c_str) : piece(c_str) {}      // NOLINT(runtime/explicit)\n    AlphaNum(StringPiece pc) : piece(std::move(pc)) {} // NOLINT(runtime/explicit)\n    AlphaNum(const string& s) : piece(s) {}            // NOLINT(runtime/explicit)\n\n    StringPiece::size_type size() const { return piece.size(); }\n    const char* data() const { return piece.data(); }\n\nprivate:\n    // Use \":\" not ':'\n    AlphaNum(char c); // NOLINT(runtime/explicit)\n};\n\nextern AlphaNum gEmptyAlphaNum;\n\n// ----------------------------------------------------------------------\n// StrCat()\n//    This merges the given strings or numbers, with no delimiter.  This\n//    is designed to be the fastest possible way to construct a string out\n//    of a mix of raw C strings, StringPieces, strings, bool values,\n//    and numeric values.\n//\n//    Don't use this for user-visible strings.  The localization process\n//    works poorly on strings built up out of fragments.\n//\n//    For clarity and performance, don't use StrCat when appending to a\n//    string.  In particular, avoid using any of these (anti-)patterns:\n//      str.append(StrCat(...)\n//      str += StrCat(...)\n//      str = StrCat(str, ...)\n//    where the last is the worse, with the potential to change a loop\n//    from a linear time operation with O(1) dynamic allocations into a\n//    quadratic time operation with O(n) dynamic allocations.  StrAppend\n//    is a better choice than any of the above, subject to the restriction\n//    of StrAppend(&str, a, b, c, ...) that none of the a, b, c, ... may\n//    be a reference into str.\n// ----------------------------------------------------------------------\n\nstring StrCat(const AlphaNum& a);\nstring StrCat(const AlphaNum& a, const AlphaNum& b);\nstring StrCat(const AlphaNum& a, const AlphaNum& b, const AlphaNum& c);\nstring StrCat(const AlphaNum& a, const AlphaNum& b, const AlphaNum& c, const AlphaNum& d);\nstring StrCat(const AlphaNum& a, const AlphaNum& b, const AlphaNum& c, const AlphaNum& d,\n              const AlphaNum& e);\nstring StrCat(const AlphaNum& a, const AlphaNum& b, const AlphaNum& c, const AlphaNum& d,\n              const AlphaNum& e, const AlphaNum& f);\nstring StrCat(const AlphaNum& a, const AlphaNum& b, const AlphaNum& c, const AlphaNum& d,\n              const AlphaNum& e, const AlphaNum& f, const AlphaNum& g);\nstring StrCat(const AlphaNum& a, const AlphaNum& b, const AlphaNum& c, const AlphaNum& d,\n              const AlphaNum& e, const AlphaNum& f, const AlphaNum& g, const AlphaNum& h);\n\nnamespace strings {\nnamespace internal {\n\n// Do not call directly - this is not part of the public API.\nstring StrCatNineOrMore(const AlphaNum* a1, ...);\n\n} // namespace internal\n} // namespace strings\n\n// Support 9 or more arguments\ninline string StrCat(const AlphaNum& a, const AlphaNum& b, const AlphaNum& c, const AlphaNum& d,\n                     const AlphaNum& e, const AlphaNum& f, const AlphaNum& g, const AlphaNum& h,\n                     const AlphaNum& i) {\n    const AlphaNum* null_alphanum = NULL;\n    return strings::internal::StrCatNineOrMore(&a, &b, &c, &d, &e, &f, &g, &h, &i, null_alphanum);\n}\n\ninline string StrCat(const AlphaNum& a, const AlphaNum& b, const AlphaNum& c, const AlphaNum& d,\n                     const AlphaNum& e, const AlphaNum& f, const AlphaNum& g, const AlphaNum& h,\n                     const AlphaNum& i, const AlphaNum& j) {\n    const AlphaNum* null_alphanum = NULL;\n    return strings::internal::StrCatNineOrMore(&a, &b, &c, &d, &e, &f, &g, &h, &i, &j,\n                                               null_alphanum);\n}\n\ninline string StrCat(const AlphaNum& a, const AlphaNum& b, const AlphaNum& c, const AlphaNum& d,\n                     const AlphaNum& e, const AlphaNum& f, const AlphaNum& g, const AlphaNum& h,\n                     const AlphaNum& i, const AlphaNum& j, const AlphaNum& k) {\n    const AlphaNum* null_alphanum = NULL;\n    return strings::internal::StrCatNineOrMore(&a, &b, &c, &d, &e, &f, &g, &h, &i, &j, &k,\n                                               null_alphanum);\n}\n\ninline string StrCat(const AlphaNum& a, const AlphaNum& b, const AlphaNum& c, const AlphaNum& d,\n                     const AlphaNum& e, const AlphaNum& f, const AlphaNum& g, const AlphaNum& h,\n                     const AlphaNum& i, const AlphaNum& j, const AlphaNum& k, const AlphaNum& l) {\n    const AlphaNum* null_alphanum = NULL;\n    return strings::internal::StrCatNineOrMore(&a, &b, &c, &d, &e, &f, &g, &h, &i, &j, &k, &l,\n                                               null_alphanum);\n}\n\ninline string StrCat(const AlphaNum& a, const AlphaNum& b, const AlphaNum& c, const AlphaNum& d,\n                     const AlphaNum& e, const AlphaNum& f, const AlphaNum& g, const AlphaNum& h,\n                     const AlphaNum& i, const AlphaNum& j, const AlphaNum& k, const AlphaNum& l,\n                     const AlphaNum& m) {\n    const AlphaNum* null_alphanum = NULL;\n    return strings::internal::StrCatNineOrMore(&a, &b, &c, &d, &e, &f, &g, &h, &i, &j, &k, &l, &m,\n                                               null_alphanum);\n}\n\ninline string StrCat(const AlphaNum& a, const AlphaNum& b, const AlphaNum& c, const AlphaNum& d,\n                     const AlphaNum& e, const AlphaNum& f, const AlphaNum& g, const AlphaNum& h,\n                     const AlphaNum& i, const AlphaNum& j, const AlphaNum& k, const AlphaNum& l,\n                     const AlphaNum& m, const AlphaNum& n) {\n    const AlphaNum* null_alphanum = NULL;\n    return strings::internal::StrCatNineOrMore(&a, &b, &c, &d, &e, &f, &g, &h, &i, &j, &k, &l, &m,\n                                               &n, null_alphanum);\n}\n\ninline string StrCat(const AlphaNum& a, const AlphaNum& b, const AlphaNum& c, const AlphaNum& d,\n                     const AlphaNum& e, const AlphaNum& f, const AlphaNum& g, const AlphaNum& h,\n                     const AlphaNum& i, const AlphaNum& j, const AlphaNum& k, const AlphaNum& l,\n                     const AlphaNum& m, const AlphaNum& n, const AlphaNum& o) {\n    const AlphaNum* null_alphanum = NULL;\n    return strings::internal::StrCatNineOrMore(&a, &b, &c, &d, &e, &f, &g, &h, &i, &j, &k, &l, &m,\n                                               &n, &o, null_alphanum);\n}\n\ninline string StrCat(const AlphaNum& a, const AlphaNum& b, const AlphaNum& c, const AlphaNum& d,\n                     const AlphaNum& e, const AlphaNum& f, const AlphaNum& g, const AlphaNum& h,\n                     const AlphaNum& i, const AlphaNum& j, const AlphaNum& k, const AlphaNum& l,\n                     const AlphaNum& m, const AlphaNum& n, const AlphaNum& o, const AlphaNum& p) {\n    const AlphaNum* null_alphanum = NULL;\n    return strings::internal::StrCatNineOrMore(&a, &b, &c, &d, &e, &f, &g, &h, &i, &j, &k, &l, &m,\n                                               &n, &o, &p, null_alphanum);\n}\n\ninline string StrCat(const AlphaNum& a, const AlphaNum& b, const AlphaNum& c, const AlphaNum& d,\n                     const AlphaNum& e, const AlphaNum& f, const AlphaNum& g, const AlphaNum& h,\n                     const AlphaNum& i, const AlphaNum& j, const AlphaNum& k, const AlphaNum& l,\n                     const AlphaNum& m, const AlphaNum& n, const AlphaNum& o, const AlphaNum& p,\n                     const AlphaNum& q) {\n    const AlphaNum* null_alphanum = NULL;\n    return strings::internal::StrCatNineOrMore(&a, &b, &c, &d, &e, &f, &g, &h, &i, &j, &k, &l, &m,\n                                               &n, &o, &p, &q, null_alphanum);\n}\n\ninline string StrCat(const AlphaNum& a, const AlphaNum& b, const AlphaNum& c, const AlphaNum& d,\n                     const AlphaNum& e, const AlphaNum& f, const AlphaNum& g, const AlphaNum& h,\n                     const AlphaNum& i, const AlphaNum& j, const AlphaNum& k, const AlphaNum& l,\n                     const AlphaNum& m, const AlphaNum& n, const AlphaNum& o, const AlphaNum& p,\n                     const AlphaNum& q, const AlphaNum& r) {\n    const AlphaNum* null_alphanum = NULL;\n    return strings::internal::StrCatNineOrMore(&a, &b, &c, &d, &e, &f, &g, &h, &i, &j, &k, &l, &m,\n                                               &n, &o, &p, &q, &r, null_alphanum);\n}\n\ninline string StrCat(const AlphaNum& a, const AlphaNum& b, const AlphaNum& c, const AlphaNum& d,\n                     const AlphaNum& e, const AlphaNum& f, const AlphaNum& g, const AlphaNum& h,\n                     const AlphaNum& i, const AlphaNum& j, const AlphaNum& k, const AlphaNum& l,\n                     const AlphaNum& m, const AlphaNum& n, const AlphaNum& o, const AlphaNum& p,\n                     const AlphaNum& q, const AlphaNum& r, const AlphaNum& s) {\n    const AlphaNum* null_alphanum = NULL;\n    return strings::internal::StrCatNineOrMore(&a, &b, &c, &d, &e, &f, &g, &h, &i, &j, &k, &l, &m,\n                                               &n, &o, &p, &q, &r, &s, null_alphanum);\n}\n\ninline string StrCat(const AlphaNum& a, const AlphaNum& b, const AlphaNum& c, const AlphaNum& d,\n                     const AlphaNum& e, const AlphaNum& f, const AlphaNum& g, const AlphaNum& h,\n                     const AlphaNum& i, const AlphaNum& j, const AlphaNum& k, const AlphaNum& l,\n                     const AlphaNum& m, const AlphaNum& n, const AlphaNum& o, const AlphaNum& p,\n                     const AlphaNum& q, const AlphaNum& r, const AlphaNum& s, const AlphaNum& t) {\n    const AlphaNum* null_alphanum = NULL;\n    return strings::internal::StrCatNineOrMore(&a, &b, &c, &d, &e, &f, &g, &h, &i, &j, &k, &l, &m,\n                                               &n, &o, &p, &q, &r, &s, &t, null_alphanum);\n}\n\ninline string StrCat(const AlphaNum& a, const AlphaNum& b, const AlphaNum& c, const AlphaNum& d,\n                     const AlphaNum& e, const AlphaNum& f, const AlphaNum& g, const AlphaNum& h,\n                     const AlphaNum& i, const AlphaNum& j, const AlphaNum& k, const AlphaNum& l,\n                     const AlphaNum& m, const AlphaNum& n, const AlphaNum& o, const AlphaNum& p,\n                     const AlphaNum& q, const AlphaNum& r, const AlphaNum& s, const AlphaNum& t,\n                     const AlphaNum& u) {\n    const AlphaNum* null_alphanum = NULL;\n    return strings::internal::StrCatNineOrMore(&a, &b, &c, &d, &e, &f, &g, &h, &i, &j, &k, &l, &m,\n                                               &n, &o, &p, &q, &r, &s, &t, &u, null_alphanum);\n}\n\ninline string StrCat(const AlphaNum& a, const AlphaNum& b, const AlphaNum& c, const AlphaNum& d,\n                     const AlphaNum& e, const AlphaNum& f, const AlphaNum& g, const AlphaNum& h,\n                     const AlphaNum& i, const AlphaNum& j, const AlphaNum& k, const AlphaNum& l,\n                     const AlphaNum& m, const AlphaNum& n, const AlphaNum& o, const AlphaNum& p,\n                     const AlphaNum& q, const AlphaNum& r, const AlphaNum& s, const AlphaNum& t,\n                     const AlphaNum& u, const AlphaNum& v) {\n    const AlphaNum* null_alphanum = NULL;\n    return strings::internal::StrCatNineOrMore(&a, &b, &c, &d, &e, &f, &g, &h, &i, &j, &k, &l, &m,\n                                               &n, &o, &p, &q, &r, &s, &t, &u, &v, null_alphanum);\n}\n\ninline string StrCat(const AlphaNum& a, const AlphaNum& b, const AlphaNum& c, const AlphaNum& d,\n                     const AlphaNum& e, const AlphaNum& f, const AlphaNum& g, const AlphaNum& h,\n                     const AlphaNum& i, const AlphaNum& j, const AlphaNum& k, const AlphaNum& l,\n                     const AlphaNum& m, const AlphaNum& n, const AlphaNum& o, const AlphaNum& p,\n                     const AlphaNum& q, const AlphaNum& r, const AlphaNum& s, const AlphaNum& t,\n                     const AlphaNum& u, const AlphaNum& v, const AlphaNum& w) {\n    const AlphaNum* null_alphanum = NULL;\n    return strings::internal::StrCatNineOrMore(&a, &b, &c, &d, &e, &f, &g, &h, &i, &j, &k, &l, &m,\n                                               &n, &o, &p, &q, &r, &s, &t, &u, &v, &w,\n                                               null_alphanum);\n}\n\ninline string StrCat(const AlphaNum& a, const AlphaNum& b, const AlphaNum& c, const AlphaNum& d,\n                     const AlphaNum& e, const AlphaNum& f, const AlphaNum& g, const AlphaNum& h,\n                     const AlphaNum& i, const AlphaNum& j, const AlphaNum& k, const AlphaNum& l,\n                     const AlphaNum& m, const AlphaNum& n, const AlphaNum& o, const AlphaNum& p,\n                     const AlphaNum& q, const AlphaNum& r, const AlphaNum& s, const AlphaNum& t,\n                     const AlphaNum& u, const AlphaNum& v, const AlphaNum& w, const AlphaNum& x) {\n    const AlphaNum* null_alphanum = NULL;\n    return strings::internal::StrCatNineOrMore(&a, &b, &c, &d, &e, &f, &g, &h, &i, &j, &k, &l, &m,\n                                               &n, &o, &p, &q, &r, &s, &t, &u, &v, &w, &x,\n                                               null_alphanum);\n}\n\ninline string StrCat(const AlphaNum& a, const AlphaNum& b, const AlphaNum& c, const AlphaNum& d,\n                     const AlphaNum& e, const AlphaNum& f, const AlphaNum& g, const AlphaNum& h,\n                     const AlphaNum& i, const AlphaNum& j, const AlphaNum& k, const AlphaNum& l,\n                     const AlphaNum& m, const AlphaNum& n, const AlphaNum& o, const AlphaNum& p,\n                     const AlphaNum& q, const AlphaNum& r, const AlphaNum& s, const AlphaNum& t,\n                     const AlphaNum& u, const AlphaNum& v, const AlphaNum& w, const AlphaNum& x,\n                     const AlphaNum& y) {\n    const AlphaNum* null_alphanum = NULL;\n    return strings::internal::StrCatNineOrMore(&a, &b, &c, &d, &e, &f, &g, &h, &i, &j, &k, &l, &m,\n                                               &n, &o, &p, &q, &r, &s, &t, &u, &v, &w, &x, &y,\n                                               null_alphanum);\n}\n\ninline string StrCat(const AlphaNum& a, const AlphaNum& b, const AlphaNum& c, const AlphaNum& d,\n                     const AlphaNum& e, const AlphaNum& f, const AlphaNum& g, const AlphaNum& h,\n                     const AlphaNum& i, const AlphaNum& j, const AlphaNum& k, const AlphaNum& l,\n                     const AlphaNum& m, const AlphaNum& n, const AlphaNum& o, const AlphaNum& p,\n                     const AlphaNum& q, const AlphaNum& r, const AlphaNum& s, const AlphaNum& t,\n                     const AlphaNum& u, const AlphaNum& v, const AlphaNum& w, const AlphaNum& x,\n                     const AlphaNum& y, const AlphaNum& z) {\n    const AlphaNum* null_alphanum = NULL;\n    return strings::internal::StrCatNineOrMore(&a, &b, &c, &d, &e, &f, &g, &h, &i, &j, &k, &l, &m,\n                                               &n, &o, &p, &q, &r, &s, &t, &u, &v, &w, &x, &y, &z,\n                                               null_alphanum);\n}\n\n// ----------------------------------------------------------------------\n// StrAppend()\n//    Same as above, but adds the output to the given string.\n//    WARNING: For speed, StrAppend does not try to check each of its input\n//    arguments to be sure that they are not a subset of the string being\n//    appended to.  That is, while this will work:\n//\n//    string s = \"foo\";\n//    s += s;\n//\n//    This will not (necessarily) work:\n//\n//    string s = \"foo\";\n//    StrAppend(&s, s);\n//\n//    Note: while StrCat supports appending up to 12 arguments, StrAppend\n//    is currently limited to 9.  That's rarely an issue except when\n//    automatically transforming StrCat to StrAppend, and can easily be\n//    worked around as consecutive calls to StrAppend are quite efficient.\n// ----------------------------------------------------------------------\n\nvoid StrAppend(string* dest, const AlphaNum& a);\nvoid StrAppend(string* dest, const AlphaNum& a, const AlphaNum& b);\nvoid StrAppend(string* dest, const AlphaNum& a, const AlphaNum& b, const AlphaNum& c);\nvoid StrAppend(string* dest, const AlphaNum& a, const AlphaNum& b, const AlphaNum& c,\n               const AlphaNum& d);\n\n// Support up to 9 params by using a default empty AlphaNum.\nvoid StrAppend(string* dest, const AlphaNum& a, const AlphaNum& b, const AlphaNum& c,\n               const AlphaNum& d, const AlphaNum& e, const AlphaNum& f = gEmptyAlphaNum,\n               const AlphaNum& g = gEmptyAlphaNum, const AlphaNum& h = gEmptyAlphaNum,\n               const AlphaNum& i = gEmptyAlphaNum);\n\n#endif // STRINGS_STRCAT_H_\n\n", "comment_ratio": 0.26409495548961426}
{"lang": "c", "code": "//{{NO_DEPENDENCIES}}\r\n// Microsoft Developer Studio generated include file.\r\n// Used by WMarkPS.rc\r\n//\r\n#define IDR_WATERMARK_PROLOGUE          1\r\n#define IDR_WATERMARK_DRAW              2\r\n#define RC_PSCRIPT                      0x5053\r\n\r\n// Next default values for new objects\r\n// \r\n#ifdef APSTUDIO_INVOKED\r\n#ifndef APSTUDIO_READONLY_SYMBOLS\r\n#define _APS_NEXT_RESOURCE_VALUE        105\r\n#define _APS_NEXT_COMMAND_VALUE         40001\r\n#define _APS_NEXT_CONTROL_VALUE         1000\r\n#define _APS_NEXT_SYMED_VALUE           102\r\n#endif\r\n#endif\r\n\n", "comment_ratio": 0.3157894736842105}
{"lang": "c", "code": "#include \"ucg.h\"\n\n//static const uint8_t ucg_dev_ssd1351_128x128_init_seq[] PROGMEM = {\nstatic const ucg_pgm_uint8_t ucg_ft_ssd1351_init_seq[] = {\n\tUCG_CFG_CD(0,1),\t\t\t\t/* DC=0 for command mode, DC=1 for data and args */\n  \tUCG_RST(1),\t\t\t\t\t\n\tUCG_CS(1),\t\t\t\t\t/* disable chip */\n\tUCG_DLY_MS(1),\n  \tUCG_RST(0),\t\t\t\t\t\n\tUCG_DLY_MS(1),\n  \tUCG_RST(1),\n\tUCG_DLY_MS(50),\n\tUCG_CS(0),\t\t\t\t\t/* enable chip */\n\t//UCG_C11(0x0fd, 0x012),\t\t\t/* Unlock normal commands, reset default: unlocked */\n\tUCG_C11(0x0fd, 0x0b1),\t\t\t/* Unlock extra commands, reset default: locked */\n  \n\t//UCG_C10(0x0ae),\t\t\t\t/* Set Display Off */\n  \tUCG_C10(0x0af),\t\t\t\t/* Set Display On */\n\tUCG_C10(0x0a6),\t\t\t\t/* Set Display Mode Reset */\n  \tUCG_C11(0x0a0, 0x0b4),\t\t\t/* Set Colour Depth */\n  \tUCG_C11(0x0a1, 0x000),\t\t\t/* Set Display Start Line */\n  \tUCG_C11(0x0a2, 0x000),\t\t\t/* Set Display Offset */\n  \tUCG_C12(0x015, 0x000, 0x07f),\t/* Set Column Address */\n  \tUCG_C12(0x075, 0x000, 0x07f),\t/* Set Row Address */\n\n  \tUCG_C11(0x0b3, 0x0f1),\t\t\t/* Front Clock Div */\n  \t//UCG_C11(0x0ca, 0x07f),\t\t\t/* Set Multiplex Ratio, reset default: 0x7f */\n  \tUCG_C11(0x0b5, 0x003),\t\t/* Set GPIO for Freetronics OLED Module */\n  \t//UCG_C11(0x0ab, 0x001),\t\t\t/* Set Function Selection, reset default: 0x01  */\n  \tUCG_C11(0x0b1, 0x032),\t\t/* Set Phase Length, reset default: 0x82 */\n  \tUCG_C13(0x0b4, 0xa0,0xb5,0x55),\t\t/* Set Segment Low Voltage, reset default: 0xa2 0xb5 0x55 */\n  \t//UCG_C11(0x0bb, 0x017),\t\t/* Set Precharge Voltage, reset default: 0x17 */\n  \t//UCG_C11(0x0be, 0x005),\t\t\t/* Set VComH Voltage, reset default: 0x05 */\n  \tUCG_C13(0x0c1, 0xc8, 0x80, 0xc8),\t/* Set Contrast */\n  \tUCG_C11(0x0c7, 0x00f),\t\t\t/* Set Master Contrast (0..15), reset default: 0x05 */\n  \tUCG_C11(0x0b6, 0x001),\t\t/* Set Second Precharge Period */\n\n\t// UCG_C10(0x0b8),\t\t\t\t/* Set CMD Grayscale Lookup, 63 Bytes follow */\n\t// UCG_A8(0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c),\n\t// UCG_A8(0x0D,0x0E,0x0F,0x10,0x11,0x12,0x13,0x14),\n\t// UCG_A8(0x15,0x16,0x18,0x1a,0x1b,0x1C,0x1D,0x1F),\n\t// UCG_A8(0x21,0x23,0x25,0x27,0x2A,0x2D,0x30,0x33),\n\t// UCG_A8(0x36,0x39,0x3C,0x3F,0x42,0x45,0x48,0x4C),\n\t// UCG_A8(0x50,0x54,0x58,0x5C,0x60,0x64,0x68,0x6C),\n\t// UCG_A8(0x70,0x74,0x78,0x7D,0x82,0x87,0x8C,0x91),\n\t// UCG_A7(0x96,0x9B,0xA0,0xA5,0xAA,0xAF,0xB4),\n\n\n\tUCG_C10(0x05c),\t\t\t\t/* Write RAM */\n\tUCG_CS(1),\t\t\t\t\t/* disable chip */\n\tUCG_END(),\t\t\t\t\t/* end of sequence */\n};\n\nucg_int_t ucg_dev_ssd1351_18x128x128_ft(ucg_t *ucg, ucg_int_t msg, void *data)\n{\n  switch(msg)\n  {\n    case UCG_MSG_DEV_POWER_UP:\n      /* 1. Call to the controller procedures to setup the com interface */\n      if ( ucg_dev_ic_ssd1351_18(ucg, msg, data) == 0 )\n\treturn 0;\n\n      /* 2. Send specific init sequence for this display module */\n      ucg_com_SendCmdSeq(ucg, ucg_ft_ssd1351_init_seq);\n      return 1;\n      \n    case UCG_MSG_DEV_POWER_DOWN:\n      /* let do power down by the conroller procedures */\n      return ucg_dev_ic_ssd1351_18(ucg, msg, data);  \n    \n    case UCG_MSG_GET_DIMENSION:\n      ((ucg_wh_t *)data)->w = 128;\n      ((ucg_wh_t *)data)->h = 128;\n      return 1;\n  }\n  \n  /* all other messages are handled by the controller procedures */\n  return ucg_dev_ic_ssd1351_18(ucg, msg, data);  \n}\n\n", "comment_ratio": 0.13559322033898305}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n\n#define BITCOIN_PUBKEY_ADDRESS      0\n#define BITCOIN_SCRIPT_ADDRESS      5\n#define BITCOIN_PUBKEY_ADDRESS_TEST 111\n#define BITCOIN_SCRIPT_ADDRESS_TEST 196\n#define BITCOIN_PRIVKEY             128\n#define BITCOIN_PRIVKEY_TEST        239\n\n#define BIP38_NOEC_PREFIX      0x0142\n#define BIP38_EC_PREFIX        0x0143\n#define BIP38_NOEC_FLAG        (0x80 | 0x40)\n#define BIP38_COMPRESSED_FLAG  0x20\n#define BIP38_LOTSEQUENCE_FLAG 0x04\n#define BIP38_INVALID_FLAG     (0x10 | 0x08 | 0x02 | 0x01)\n\nCFAllocatorRef SecureAllocator();\n\n@interface NSString (Base58)\n\n+ (NSString *)base58WithData:(NSData *)d;\n+ (NSString *)base58checkWithData:(NSData *)d;\n+ (NSString *)hexWithData:(NSData *)d;\n+ (NSString *)addressWithScript:(NSData *)script;\n\n- (NSData *)base58ToData;\n- (NSString *)hexToBase58;\n- (NSString *)base58ToHex;\n\n- (NSData *)base58checkToData;\n- (NSString *)hexToBase58check;\n- (NSString *)base58checkToHex;\n\n- (NSData *)hexToData;\n- (NSData *)addressToHash160;\n\n- (BOOL)isValidBitcoinAddress;\n- (BOOL)isValidBitcoinPrivateKey;\n- (BOOL)isValidBitcoinBIP38Key; // BIP38 encrypted keys: https://github.com/bitcoin/bips/blob/master/bip-0038.mediawiki\n\n@end\n\n", "comment_ratio": 0.373134328358209}
{"lang": "c", "code": "#pragma once\n\n#include \"../Container/Ptr.h\"\n\nnamespace Urho3D\n{\n\nclass Graphics;\n\n/// API-specific GPU object representation.\nunion GPUObjectHandle\n{\n    /// Object pointer (Direct3D).\n    void* ptr_;\n    /// Object name (OpenGL).\n    unsigned name_;\n};\n\n/// Base class for GPU resources.\nclass URHO3D_API GPUObject\n{\npublic:\n    /// Construct with graphics subsystem pointer.\n    explicit GPUObject(Graphics* graphics);\n    /// Destruct. Remove from the Graphics.\n    virtual ~GPUObject();\n\n    /// Mark the GPU resource destroyed on graphics context destruction.\n    virtual void OnDeviceLost();\n    /// Recreate the GPU resource and restore data if applicable.\n    virtual void OnDeviceReset();\n    /// Unconditionally release the GPU resource.\n    virtual void Release();\n\n    /// Clear the data lost flag.\n    void ClearDataLost();\n\n    /// Return the graphics subsystem associated with this GPU object.\n    Graphics* GetGraphics() const;\n    /// Return the object pointer. Applicable only on Direct3D.\n    void* GetGPUObject() const { return object_.ptr_; }\n    /// Return the object name. Applicable only on OpenGL.\n    unsigned GetGPUObjectName() const { return object_.name_; }\n    /// Return whether data is lost due to context loss.\n    /// @property\n    bool IsDataLost() const { return dataLost_; }\n    /// Return whether has pending data assigned while graphics context was lost.\n    bool HasPendingData() const { return dataPending_; }\n\nprotected:\n    /// Graphics subsystem.\n    WeakPtr<Graphics> graphics_;\n    /// Object pointer or name.\n    GPUObjectHandle object_{};\n    /// Data lost flag.\n    bool dataLost_{};\n    /// Data pending flag.\n    bool dataPending_{};\n};\n\n}\n\n\n", "comment_ratio": 0.3333333333333333}
{"lang": "c", "code": "#ifndef CHROME_BROWSER_CLIENT_HINTS_CLIENT_HINTS_FACTORY_H_\n#define CHROME_BROWSER_CLIENT_HINTS_CLIENT_HINTS_FACTORY_H_\n\n#include \"base/lazy_instance.h\"\n#include \"components/keyed_service/content/browser_context_keyed_service_factory.h\"\n#include \"content/public/browser/client_hints_controller_delegate.h\"\n\nnamespace content {\nclass BrowserContext;\n}\n\nclass ClientHintsFactory : public BrowserContextKeyedServiceFactory {\n public:\n  static content::ClientHintsControllerDelegate* GetForBrowserContext(\n      content::BrowserContext* context);\n\n  static ClientHintsFactory* GetInstance();\n\n  ClientHintsFactory(const ClientHintsFactory&) = delete;\n  ClientHintsFactory& operator=(const ClientHintsFactory&) = delete;\n\n private:\n  friend struct base::LazyInstanceTraitsBase<ClientHintsFactory>;\n\n  ClientHintsFactory();\n  ~ClientHintsFactory() override;\n\n  // BrowserContextKeyedServiceFactory:\n  KeyedService* BuildServiceInstanceFor(\n      content::BrowserContext* context) const override;\n  content::BrowserContext* GetBrowserContextToUse(\n      content::BrowserContext* context) const override;\n  bool ServiceIsNULLWhileTesting() const override;\n};\n\n#endif  // CHROME_BROWSER_CLIENT_HINTS_CLIENT_HINTS_FACTORY_H_\n\n", "comment_ratio": 0.12195121951219512}
{"lang": "c", "code": "#ifndef LIST_H\n#define LIST_H\n\n#include <stdint.h>\n#include \"object.h\"\n\n\n// A reference counted wrapper of the 'klist'.\n// 'klist' is a very simple list implementation, see klist.h for more details.\n\nstruct list;\ntypedef struct list * plist;\n\n// Creates a list object.\n// Return value: the list object or NULL if error.\nstruct list * list_create(void);\n\n// Appends an object to the list.\n// Parameters: lst - the list itself.\n//             obj - a reference counted object to be added to the list.\nvoid list_append(struct list * lst, pobject obj);\n\n// Returns an iterator to the list's head.\n// Parameters: lst - the list object itself.\n// Return value: an iterator to the begin of the list (the head).\nvoid * list_begin(struct list *  lst);\n\n// Returns an iterator to the list's tail.\n// Parameters: lst - the list object itself.\n// Return value: an iterator to the end of the list (the tail).\nvoid * list_end(struct list * lst);\n\n// Moves forward the iterator, returns the next iterator or NULL if end is reached.\n// Parameters: it - the iterator itself.\n// Return value: the next iterator or NULL if the end is reached.\nvoid * list_next(void * it);\n\n// Returns the underlying object from the iterator or NULL if error.\n// Parameters: it - the iterator itself.\n// Return value: pointer to the underlying object. The object is of type 'object' so a cast is necessary to access the actual data.\npobject list_access(void * it);\n\n// Returns the underlying object from a list, by given index or NULL if error.\n// Parameters: lst - the list itself.\n//             index - the index inside the list (as if the list is an array)\n// Return value: pointer to the underlying object. The object is of type 'object' so a cast is necessary to access the actual data.\npobject list_at(struct list * lst, int index);\n\n// Returns the list size in elements or 0 if error.\n// Parameters: lst - the list itself.\n// Return value: the size of the list in elements. Returns 0 if the list is empty OR if the 'lst' points to a NULL pointer.\nuint64_t list_size(struct list * lst);\n\n#endif // LIST_H\n\n\n", "comment_ratio": 0.32926829268292684}
{"lang": "c", "code": "#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n#include \"vp8enci.h\"\n\n// #define PRINT_MEMORY_INFO\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\n#ifdef PRINT_MEMORY_INFO\n#include <stdio.h>\n#endif\n\n#define MAX_DIMENSION 16384   // maximum width/height allowed by the spec\n\n//-----------------------------------------------------------------------------\n\nint WebPGetEncoderVersion(void) {\n  return (ENC_MAJ_VERSION << 16) | (ENC_MIN_VERSION << 8) | ENC_REV_VERSION;\n}\n\n//-----------------------------------------------------------------------------\n// WebPPicture\n//-----------------------------------------------------------------------------\n\nstatic int DummyWriter(const uint8_t* data, size_t data_size,\n                       const WebPPicture* const picture) {\n  // The following are to prevent 'unused variable' error message.\n  (void)data;\n  (void)data_size;\n  (void)picture;\n  return 1;\n}\n\nint WebPPictureInitInternal(WebPPicture* const picture, int version) {\n  if (version != WEBP_ENCODER_ABI_VERSION) {\n    return 0;   // caller/system version mismatch!\n  }\n  if (picture) {\n    memset(picture, 0, sizeof(*picture));\n    picture->writer = DummyWriter;\n    WebPEncodingSetError(picture, VP8_ENC_OK);\n  }\n  return 1;\n}\n\n//-----------------------------------------------------------------------------\n// VP8Encoder\n//-----------------------------------------------------------------------------\n\nstatic void ResetSegmentHeader(VP8Encoder* const enc) {\n  VP8SegmentHeader* const hdr = &enc->segment_hdr_;\n  hdr->num_segments_ = enc->config_->segments;\n  hdr->update_map_  = (hdr->num_segments_ > 1);\n  hdr->size_ = 0;\n}\n\nstatic void ResetFilterHeader(VP8Encoder* const enc) {\n  VP8FilterHeader* const hdr = &enc->filter_hdr_;\n  hdr->simple_ = 1;\n  hdr->level_ = 0;\n  hdr->sharpness_ = 0;\n  hdr->i4x4_lf_delta_ = 0;\n}\n\nstatic void ResetBoundaryPredictions(VP8Encoder* const enc) {\n  // init boundary values once for all\n  // Note: actually, initializing the preds_[] is only needed for intra4.\n  int i;\n  uint8_t* const top = enc->preds_ - enc->preds_w_;\n  uint8_t* const left = enc->preds_ - 1;\n  for (i = -1; i < 4 * enc->mb_w_; ++i) {\n    top[i] = B_DC_PRED;\n  }\n  for (i = 0; i < 4 * enc->mb_h_; ++i) {\n    left[i * enc->preds_w_] = B_DC_PRED;\n  }\n  enc->nz_[-1] = 0;   // constant\n}\n\n// Map configured quality level to coding tools used.\n//-------------+---+---+---+---+---+---+\n//   Quality   | 0 | 1 | 2 | 3 | 4 | 5 +\n//-------------+---+---+---+---+---+---+\n// dynamic prob| ~ | x | x | x | x | x |\n//-------------+---+---+---+---+---+---+\n// rd-opt modes|   |   | x | x | x | x |\n//-------------+---+---+---+---+---+---+\n// fast i4/i16 | x | x |   |   |   |   |\n//-------------+---+---+---+---+---+---+\n// rd-opt i4/16|   |   | x | x | x | x |\n//-------------+---+---+---+---+---+---+\n// Trellis     |   | x |   |   | x | x |\n//-------------+---+---+---+---+---+---+\n// full-SNS    |   |   |   |   |   | x |\n//-------------+---+---+---+---+---+---+\n\nstatic void MapConfigToTools(VP8Encoder* const enc) {\n  const int method = enc->config_->method;\n  enc->method_ = method;\n  enc->rd_opt_level_ = (method >= 6) ? 3\n                     : (method >= 5) ? 2\n                     : (method >= 3) ? 1\n                     : 0;\n}\n\n// Memory scaling with dimensions:\n//  memory (bytes) ~= 2.25 * w + 0.0625 * w * h\n//\n// Typical memory footprint (768x510 picture)\n// Memory used:\n//              encoder: 33919\n//          block cache: 2880\n//                 info: 3072\n//                preds: 24897\n//          top samples: 1623\n//             non-zero: 196\n//             lf-stats: 2048\n//                total: 68635\n// Transcient object sizes:\n//       VP8EncIterator: 352\n//         VP8ModeScore: 912\n//       VP8SegmentInfo: 532\n//             VP8Proba: 31032\n//              LFStats: 2048\n// Picture size (yuv): 589824\n\nstatic VP8Encoder* InitEncoder(const WebPConfig* const config,\n                               WebPPicture* const picture) {\n  const int use_filter =\n      (config->filter_strength > 0) || (config->autofilter > 0);\n  const int mb_w = (picture->width + 15) >> 4;\n  const int mb_h = (picture->height + 15) >> 4;\n  const int preds_w = 4 * mb_w + 1;\n  const int preds_h = 4 * mb_h + 1;\n  const size_t preds_size = preds_w * preds_h * sizeof(uint8_t);\n  const int top_stride = mb_w * 16;\n  const size_t nz_size = (mb_w + 1) * sizeof(uint32_t);\n  const size_t cache_size = (3 * YUV_SIZE + PRED_SIZE) * sizeof(uint8_t);\n  const size_t info_size = mb_w * mb_h * sizeof(VP8MBInfo);\n  const size_t samples_size = (2 * top_stride +         // top-luma/u/v\n                               16 + 16 + 16 + 8 + 1 +   // left y/u/v\n                               2 * ALIGN_CST)           // align all\n                               * sizeof(uint8_t);\n  const size_t lf_stats_size =\n      config->autofilter ? sizeof(LFStats) + ALIGN_CST : 0;\n  VP8Encoder* enc;\n  uint8_t* mem;\n  size_t size = sizeof(VP8Encoder) + ALIGN_CST  // main struct\n              + cache_size                      // working caches\n              + info_size                       // modes info\n              + preds_size                      // prediction modes\n              + samples_size                    // top/left samples\n              + nz_size                         // coeff context bits\n              + lf_stats_size;                  // autofilter stats\n\n#ifdef PRINT_MEMORY_INFO\n  printf(\"===================================\\n\");\n  printf(\"Memory used:\\n\"\n         \"             encoder: %ld\\n\"\n         \"         block cache: %ld\\n\"\n         \"                info: %ld\\n\"\n         \"               preds: %ld\\n\"\n         \"         top samples: %ld\\n\"\n         \"            non-zero: %ld\\n\"\n         \"            lf-stats: %ld\\n\"\n         \"               total: %ld\\n\",\n         sizeof(VP8Encoder) + ALIGN_CST, cache_size, info_size,\n         preds_size, samples_size, nz_size, lf_stats_size, size);\n  printf(\"Transcient object sizes:\\n\"\n         \"      VP8EncIterator: %ld\\n\"\n         \"        VP8ModeScore: %ld\\n\"\n         \"      VP8SegmentInfo: %ld\\n\"\n         \"            VP8Proba: %ld\\n\"\n         \"             LFStats: %ld\\n\",\n         sizeof(VP8EncIterator), sizeof(VP8ModeScore),\n         sizeof(VP8SegmentInfo), sizeof(VP8Proba),\n         sizeof(LFStats));\n  printf(\"Picture size (yuv): %ld\\n\",\n         mb_w * mb_h * 384 * sizeof(uint8_t));\n  printf(\"===================================\\n\");\n#endif\n  mem = (uint8_t*)malloc(size);\n  if (mem == NULL) {\n    WebPEncodingSetError(picture, VP8_ENC_ERROR_OUT_OF_MEMORY);\n    return NULL;\n  }\n  enc = (VP8Encoder*)mem;\n  mem = (uint8_t*)DO_ALIGN(mem + sizeof(*enc));\n  memset(enc, 0, sizeof(*enc));\n  enc->num_parts_ = 1 << config->partitions;\n  enc->mb_w_ = mb_w;\n  enc->mb_h_ = mb_h;\n  enc->preds_w_ = preds_w;\n  enc->yuv_in_ = (uint8_t*)mem;\n  mem += YUV_SIZE;\n  enc->yuv_out_ = (uint8_t*)mem;\n  mem += YUV_SIZE;\n  enc->yuv_out2_ = (uint8_t*)mem;\n  mem += YUV_SIZE;\n  enc->yuv_p_ = (uint8_t*)mem;\n  mem += PRED_SIZE;\n  enc->mb_info_ = (VP8MBInfo*)mem;\n  mem += info_size;\n  enc->preds_ = ((uint8_t*)mem) + 1 + enc->preds_w_;\n  mem += preds_w * preds_h * sizeof(uint8_t);\n  enc->nz_ = 1 + (uint32_t*)mem;\n  mem += nz_size;\n  enc->lf_stats_ = lf_stats_size ? (LFStats*)DO_ALIGN(mem) : NULL;\n  mem += lf_stats_size;\n\n  // top samples (all 16-aligned)\n  mem = (uint8_t*)DO_ALIGN(mem);\n  enc->y_top_ = (uint8_t*)mem;\n  enc->uv_top_ = enc->y_top_ + top_stride;\n  mem += 2 * top_stride;\n  mem = (uint8_t*)DO_ALIGN(mem + 1);\n  enc->y_left_ = (uint8_t*)mem;\n  mem += 16 + 16;\n  enc->u_left_ = (uint8_t*)mem;\n  mem += 16;\n  enc->v_left_ = (uint8_t*)mem;\n  mem += 8;\n\n  enc->config_ = config;\n  enc->profile_ = use_filter ? ((config->filter_type == 1) ? 0 : 1) : 2;\n  enc->pic_ = picture;\n\n  MapConfigToTools(enc);\n  VP8EncDspInit();\n  VP8DefaultProbas(enc);\n  ResetSegmentHeader(enc);\n  ResetFilterHeader(enc);\n  ResetBoundaryPredictions(enc);\n\n#ifdef WEBP_EXPERIMENTAL_FEATURES\n  VP8EncInitAlpha(enc);\n  VP8EncInitLayer(enc);\n#endif\n\n  return enc;\n}\n\nstatic void DeleteEncoder(VP8Encoder* enc) {\n  if (enc) {\n#ifdef WEBP_EXPERIMENTAL_FEATURES\n    VP8EncDeleteAlpha(enc);\n    VP8EncDeleteLayer(enc);\n#endif\n    free(enc);\n  }\n}\n\n//-----------------------------------------------------------------------------\n\nstatic double GetPSNR(uint64_t err, uint64_t size) {\n  return err ? 10. * log10(255. * 255. * size / err) : 99.;\n}\n\nstatic void FinalizePSNR(const VP8Encoder* const enc) {\n  WebPAuxStats* stats = enc->pic_->stats;\n  const uint64_t size = enc->sse_count_;\n  const uint64_t* const sse = enc->sse_;\n  stats->PSNR[0] = (float)GetPSNR(sse[0], size);\n  stats->PSNR[1] = (float)GetPSNR(sse[1], size / 4);\n  stats->PSNR[2] = (float)GetPSNR(sse[2], size / 4);\n  stats->PSNR[3] = (float)GetPSNR(sse[0] + sse[1] + sse[2], size * 3 / 2);\n}\n\nstatic void StoreStats(VP8Encoder* const enc) {\n  WebPAuxStats* const stats = enc->pic_->stats;\n  if (stats) {\n    int i, s;\n    for (i = 0; i < NUM_MB_SEGMENTS; ++i) {\n      stats->segment_level[i] = enc->dqm_[i].fstrength_;\n      stats->segment_quant[i] = enc->dqm_[i].quant_;\n      for (s = 0; s <= 2; ++s) {\n        stats->residual_bytes[s][i] = enc->residual_bytes_[s][i];\n      }\n    }\n    FinalizePSNR(enc);\n    stats->coded_size = enc->coded_size_;\n    for (i = 0; i < 3; ++i) {\n      stats->block_count[i] = enc->block_count_[i];\n    }\n  }\n}\n\nint WebPEncodingSetError(WebPPicture* const pic, WebPEncodingError error) {\n  assert((int)error <= VP8_ENC_ERROR_BAD_WRITE);\n  assert((int)error >= VP8_ENC_OK);\n  pic->error_code = error;\n  return 0;\n}\n\n//-----------------------------------------------------------------------------\n\nint WebPEncode(const WebPConfig* const config, WebPPicture* const pic) {\n  VP8Encoder* enc;\n  int ok;\n\n  if (pic == NULL)\n    return 0;\n  WebPEncodingSetError(pic, VP8_ENC_OK);  // all ok so far\n  if (config == NULL)  // bad params\n    return WebPEncodingSetError(pic, VP8_ENC_ERROR_NULL_PARAMETER);\n  if (!WebPValidateConfig(config))\n    return WebPEncodingSetError(pic, VP8_ENC_ERROR_INVALID_CONFIGURATION);\n  if (pic->width <= 0 || pic->height <= 0)\n    return WebPEncodingSetError(pic, VP8_ENC_ERROR_BAD_DIMENSION);\n  if (pic->y == NULL || pic->u == NULL || pic->v == NULL)\n    return WebPEncodingSetError(pic, VP8_ENC_ERROR_NULL_PARAMETER);\n  if (pic->width >= MAX_DIMENSION || pic->height >= MAX_DIMENSION)\n    return WebPEncodingSetError(pic, VP8_ENC_ERROR_BAD_DIMENSION);\n\n  enc = InitEncoder(config, pic);\n  if (enc == NULL) return 0;  // pic->error is already set.\n  ok = VP8EncAnalyze(enc)\n    && VP8StatLoop(enc)\n    && VP8EncLoop(enc)\n#ifdef WEBP_EXPERIMENTAL_FEATURES\n    && VP8EncFinishAlpha(enc)\n    && VP8EncFinishLayer(enc)\n#endif\n    && VP8EncWrite(enc);\n  StoreStats(enc);\n  DeleteEncoder(enc);\n\n  return ok;\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}    // extern \"C\"\n#endif\n\n", "comment_ratio": 0.22}
{"lang": "c", "code": "#ifndef __PSFTMAPPER_H__\r\n#define __PSFTMAPPER_H__\r\n\r\nstruct PsftpMapper {\r\n    HMODULE hDll;\r\n    PsftpConnectProcType connect;\r\n    PsftpDoSftpProcType doSftp;\r\n    PsftpGetCurrentDirStructProcType getCurrentDirStruct;\r\n    FARPROC disconnect;\r\n    //\tFARPROC SFTP_DLL_FNCT_psftp_memory_hole__stopfen;\r\n    PsftpGetLastErrorMessageProcType getLastErrorMessage;\r\n    PsftpInitProcsProcType initProgressProc;\r\n    PsftpSetTransferModeProcType setTransferMode;\r\n    PsftpDisconnectedProcType disconnected;\r\n};\r\n\r\n#endif // __PSFTMAPPER_H__\r\n\n", "comment_ratio": 0.1111111111111111}
{"lang": "c", "code": "struct binary_search_tree{\n\n\t//Standard library context.\n\tstandard_library_context* ctx;\n\n\t//Total number of nodes in this tree.\n\tsize_t total;\n\n\t//Root node.\n\tbinary_search_tree_node* root;\n\n};\n\nstruct binary_search_tree_node{\n\n\t//Key of this node.\n\tlong key;\n\n\t//Data pointer.\n\tvoid* data;\n\n\t//Weighting.\n\tsize_t w;\n\n\t//Parent node.\n\tbinary_search_tree_node* parent;\n\n\t//Left child.\n\tbinary_search_tree_node* left;\n\n\t//Right child.\n\tbinary_search_tree_node* right;\n\n};\n", "comment_ratio": 0.17543859649122806}
{"lang": "c", "code": "#ifndef DIALOGINIT_H\n#define DIALOGINIT_H\n\n////////////////////////////////////////////////////////////////////////////////\n\n#include <QDateTime>\n#include <QDialog>\n#include <QDomElement>\n#include <QSettings>\n\n#include <defs.h>\n\n////////////////////////////////////////////////////////////////////////////////\n\nnamespace Ui\n{\n    class DialogInit;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * @brief This is 'Initial Conditions' dialog class.\n */\nclass DialogInit : public QDialog\n{\n    Q_OBJECT\n\npublic:\n\n    /** @brief Constructor. */\n    explicit DialogInit( QWidget *parent = NULLPTR );\n    \n    /** @brief Destructor. */\n    virtual ~DialogInit();\n\n    inline QDateTime getDateTime() const { return _dateTime; }\n\n    inline int getTypeIndex() const { return _typeIndex; }\n\n    inline double getLat() const { return _lat; }\n    inline double getLon() const { return _lon; }\n    inline double getAlt() const { return _alt; }\n    inline double getPsi() const { return _psi; }\n    inline double getIAS() const { return _ias; }\n\n    inline bool getEngine() const { return _engine; }\n\n    void readData();\n    void saveData();\n\nsignals:\n\n    void typeIndexChanged( int );\n\nprivate:\n\n    Ui::DialogInit *_ui;    ///<\n\n    QDateTime _dateTime;    ///<\n\n    int _typeIndex;         ///< aircraft type index\n\n    double _lat;            ///< [rad]\n    double _lon;            ///< [rad]\n    double _alt;            ///< [m] altitude above ground level\n    double _psi;            ///< [rad] heading\n    double _ias;            ///< [m/s] airspeed\n\n    bool _engine;           ///< specifies if engine is on at start\n\n    void settingsRead();\n    void settingsRead_InitData( QSettings &settings );\n    void settingsRead_UnitCombos( QSettings &settings );\n\n    void settingsSave();\n    void settingsSave_InitData( QSettings &settings );\n    void settingsSave_UnitCombos( QSettings &settings );\n\nprivate slots:\n\n    void on_comboAirports_currentIndexChanged( int index );\n    void on_comboLocations_currentIndexChanged( int index );\n\n    void on_spinInitLat_valueChanged( double arg1 );\n    void on_spinInitLon_valueChanged( double arg1 );\n    void on_spinInitAlt_valueChanged( double arg1 );\n    void on_spinInitPsi_valueChanged( double arg1 );\n\n    void on_comboDistance_currentIndexChanged( int index );\n\n    void on_comboInitLat_currentIndexChanged( int index );\n    void on_comboInitLon_currentIndexChanged( int index );\n    void on_comboInitAlt_currentIndexChanged( int index );\n    void on_comboInitPsi_currentIndexChanged( int index );\n    void on_comboInitIAS_currentIndexChanged( int index );\n\n    void on_pushButtonTime_clicked();\n\n    void on_checkBoxEngineOn_toggled( bool checked );\n};\n\n////////////////////////////////////////////////////////////////////////////////\n\n#endif // DIALOGINIT_H\n\n", "comment_ratio": 0.11811023622047244}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n#import <Foundation/Foundation.h>\n#import \"TBMBDefaultRootViewController.h\"\n\n@interface TBMBDefaultRootViewController (TBMBProxy)\n//\u521b\u5efa\u5b83\u7684\u4ee3\u7406\u5bf9\u8c61,\u4f7f\u8c03\u7528\u76f4\u63a5\u6d88\u606f\u5316\n@property(nonatomic, readonly) id proxyObject;\n@end\n", "comment_ratio": 0.19047619047619047}
{"lang": "c", "code": "#include \"precomp.h\"\r\n\r\n\r\nBOOLEAN\r\nCyyGrabWaitFromIsr(\r\n    IN PVOID Context\r\n    );\r\n\r\nBOOLEAN\r\nCyyGiveWaitToIsr(\r\n    IN PVOID Context\r\n    );\r\n\r\nBOOLEAN\r\nCyyFinishOldWait(\r\n    IN PVOID Context\r\n    );\r\n\r\n#ifdef ALLOC_PRAGMA\r\n#pragma alloc_text(PAGESER,CyyStartMask)\r\n#pragma alloc_text(PAGESER,CyyCancelWait)\r\n#pragma alloc_text(PAGESER,CyyGrabWaitFromIsr)\r\n#pragma alloc_text(PAGESER,CyyGiveWaitToIsr)\r\n#pragma alloc_text(PAGESER,CyyFinishOldWait)\r\n#endif\r\n\r\n\f\r\nNTSTATUS\r\nCyyStartMask(\r\n    IN PCYY_DEVICE_EXTENSION Extension\r\n    )\r\n\r\n/*++\r\n\r\nRoutine Description:\r\n\r\n    This routine is used to process the set mask and wait\r\n    mask ioctls.  Calls to this routine are serialized by\r\n    placing irps in the list under the protection of the\r\n    cancel spin lock.\r\n\r\nArguments:\r\n\r\n    Extension - A pointer to the serial device extension.\r\n\r\nReturn Value:\r\n\r\n    Will return pending for everything put the first\r\n    request that we actually process.  Even in that\r\n    case it will return pending unless it can complete\r\n    it right away.\r\n\r\n\r\n--*/\r\n\r\n{\r\n\r\n    //\r\n    // The current stack location.  This contains much of the\r\n    // information we need to process this particular request.\r\n    //\r\n    PIO_STACK_LOCATION IrpSp;\r\n\r\n    PIRP NewIrp;\r\n\r\n    BOOLEAN SetFirstStatus = FALSE;\r\n    NTSTATUS FirstStatus;\r\n\r\n    CYY_LOCKED_PAGED_CODE();\r\n\r\n    CyyDbgPrintEx(CYYDIAG3, \"In CyyStartMask\\n\");\r\n\r\n    ASSERT(Extension->CurrentMaskIrp);\r\n\r\n    do {\r\n\r\n        CyyDbgPrintEx(CYYDIAG4, \"STARTMASK - CurrentMaskIrp: %x\\n\",\r\n                         Extension->CurrentMaskIrp);\r\n        IrpSp = IoGetCurrentIrpStackLocation(Extension->CurrentMaskIrp);\r\n\r\n        ASSERT((IrpSp->Parameters.DeviceIoControl.IoControlCode ==\r\n                IOCTL_SERIAL_WAIT_ON_MASK) ||\r\n               (IrpSp->Parameters.DeviceIoControl.IoControlCode ==\r\n                IOCTL_SERIAL_SET_WAIT_MASK));\r\n\r\n        if (IrpSp->Parameters.DeviceIoControl.IoControlCode ==\r\n            IOCTL_SERIAL_SET_WAIT_MASK) {\r\n\r\n            CyyDbgPrintEx(CYYDIAG4, \"%x is a SETMASK irp\\n\",\r\n                          Extension->CurrentMaskIrp);\r\n\r\n            //\r\n            // Complete the old wait if there is one.\r\n            //\r\n\r\n            KeSynchronizeExecution(\r\n                Extension->Interrupt,\r\n                CyyFinishOldWait,\r\n                Extension\r\n                );\r\n\r\n            //\r\n            // Any current waits should be on its way to completion\r\n            // at this point.  There certainly shouldn't be any\r\n            // irp mask location.\r\n            //\r\n\r\n            ASSERT(!Extension->IrpMaskLocation);\r\n\r\n            Extension->CurrentMaskIrp->IoStatus.Status = STATUS_SUCCESS;\r\n\r\n            if (!SetFirstStatus) {\r\n\r\n                CyyDbgPrintEx(CYYDIAG4, \"%x was the first irp processed by \"\r\n                              \"this\\n\"\r\n                              \"------- invocation of startmask\\n\",\r\n                              Extension->CurrentMaskIrp);\r\n\r\n                FirstStatus = STATUS_SUCCESS;\r\n                SetFirstStatus = TRUE;\r\n\r\n            }\r\n\r\n            //\r\n            // The following call will also cause the current\r\n            // call to be completed.\r\n            //\r\n\r\n            CyyGetNextIrp(\r\n                &Extension->CurrentMaskIrp,\r\n                &Extension->MaskQueue,\r\n                &NewIrp,\r\n                TRUE,\r\n                Extension\r\n                );\r\n            CyyDbgPrintEx(CYYDIAG4, \"Perhaps another mask irp was found in \"\r\n                          \"the queue\\n\"\r\n                          \"------- %x/%x <- values should be the same\\n\",\r\n                          Extension->CurrentMaskIrp,NewIrp);\r\n\r\n        } else {\r\n\r\n            //\r\n            // First make sure that we have a non-zero mask.\r\n            // If the app queues a wait on a zero mask it can't\r\n            // be statisfied so it makes no sense to start it.\r\n            //\r\n\r\n            if ((!Extension->IsrWaitMask) || (Extension->CurrentWaitIrp)) {\r\n\r\n                CyyDbgPrintEx(CYYDIAG4, \"WaitIrp is invalid\\n\"\r\n                              \"------- IsrWaitMask: %x\\n\"\r\n                              \"------- CurrentWaitIrp: %x\\n\",\r\n                              Extension->IsrWaitMask,\r\n                              Extension->CurrentWaitIrp);\r\n\r\n                Extension->CurrentMaskIrp->IoStatus.Status \r\n                   = STATUS_INVALID_PARAMETER;\r\n\r\n                if (!SetFirstStatus) {\r\n\r\n                    CyyDbgPrintEx(CYYDIAG4, \"%x was the first irp processed \"\r\n                                  \"by this\\n\"\r\n                                  \"------- invocation of startmask\\n\",\r\n                                  Extension->CurrentMaskIrp);\r\n\r\n                    FirstStatus = STATUS_INVALID_PARAMETER;\r\n                    SetFirstStatus = TRUE;\r\n\r\n                }\r\n\r\n                CyyGetNextIrp(&Extension->CurrentMaskIrp,\r\n                              &Extension->MaskQueue, &NewIrp, TRUE,\r\n                              Extension);\r\n\r\n                CyyDbgPrintEx(CYYDIAG4, \"Perhaps another mask irp was found \"\r\n                              \"in the queue\\n\"\r\n                              \"------- %x/%x <- values should be the same\\n\",\r\n                              Extension->CurrentMaskIrp,NewIrp);\r\n\r\n            } else {\r\n\r\n                KIRQL OldIrql;\r\n\r\n                //\r\n                // Make the current mask irp the current wait irp and\r\n                // get a new current mask irp.  Note that when we get\r\n                // the new current mask irp we DO NOT complete the\r\n                // old current mask irp (which is now the current wait\r\n                // irp.\r\n                //\r\n                // Then under the protection of the cancel spin lock\r\n                // we check to see if the current wait irp needs to\r\n                // be canceled\r\n                //\r\n\r\n                IoAcquireCancelSpinLock(&OldIrql);\r\n\r\n                if (Extension->CurrentMaskIrp->Cancel) {\r\n\r\n                    CyyDbgPrintEx(CYYDIAG4, \"%x irp was already marked as \"\r\n                                  \"cancelled\\n\", Extension->CurrentMaskIrp);\r\n\r\n                    IoReleaseCancelSpinLock(OldIrql);\r\n                    Extension->CurrentMaskIrp->IoStatus.Status = STATUS_CANCELLED;\r\n\r\n                    if (!SetFirstStatus) {\r\n\r\n                        CyyDbgPrintEx(CYYDIAG4, \"%x was the first irp \"\r\n                                      \"processed by this\\n\"\r\n                                      \"------- invocation of startmask\\n\",\r\n                                      Extension->CurrentMaskIrp);\r\n\r\n                        FirstStatus = STATUS_CANCELLED;\r\n                        SetFirstStatus = TRUE;\r\n\r\n                    }\r\n\r\n                    CyyGetNextIrp(&Extension->CurrentMaskIrp,\r\n                                  &Extension->MaskQueue, &NewIrp, TRUE,\r\n                                  Extension);\r\n\r\n                    CyyDbgPrintEx(CYYDIAG4, \"Perhaps another mask irp was \"\r\n                                  \"found in the queue\\n\"\r\n                                  \"------- %x/%x <- values should be the \"\r\n                                  \"same\\n\", Extension->CurrentMaskIrp,\r\n                                  NewIrp);\r\n\r\n                } else {\r\n\r\n                    CyyDbgPrintEx(CYYDIAG4, \"%x will become the current \"\r\n                                  \"wait irp\\n\", Extension->CurrentMaskIrp);\r\n                    if (!SetFirstStatus) {\r\n\r\n                        CyyDbgPrintEx(CYYDIAG4, \"%x was the first irp \"\r\n                                      \"processed by this\\n\"\r\n                                      \"------- invocation of startmask\\n\",\r\n                                      Extension->CurrentMaskIrp);\r\n\r\n                        FirstStatus = STATUS_PENDING;\r\n                        SetFirstStatus = TRUE;\r\n\r\n                        //\r\n                        // If we haven't already set a first status\r\n                        // then there is a chance that this packet\r\n                        // was never on the queue.  We should mark\r\n                        // it as pending.\r\n                        //\r\n\r\n                        IoMarkIrpPending(Extension->CurrentMaskIrp);\r\n\r\n                    }\r\n\r\n                    //\r\n                    // There should never be a mask location when\r\n                    // there isn't a current wait irp.  At this point\r\n                    // there shouldn't be a current wait irp also.\r\n                    //\r\n\r\n                    ASSERT(!Extension->IrpMaskLocation);\r\n                    ASSERT(!Extension->CurrentWaitIrp);\r\n\r\n                    Extension->CurrentWaitIrp = Extension->CurrentMaskIrp;\r\n                    SERIAL_INIT_REFERENCE(Extension->CurrentWaitIrp);\r\n                    IoSetCancelRoutine(\r\n                        Extension->CurrentWaitIrp,\r\n                        CyyCancelWait\r\n                        );\r\n\r\n                    //\r\n                    // Since the cancel routine has a reference to\r\n                    // the irp we need to update the reference\r\n                    // count.\r\n                    //\r\n\r\n                    SERIAL_SET_REFERENCE(\r\n                        Extension->CurrentWaitIrp,\r\n                        SERIAL_REF_CANCEL\r\n                        );\r\n\r\n                    KeSynchronizeExecution(\r\n                        Extension->Interrupt,\r\n                        CyyGiveWaitToIsr,\r\n                        Extension\r\n                        );\r\n\r\n// Code removed because it was causing blue-screen in the Modem Share \r\n// test case 77. When CurrentMaskIrp is set to NULL, we remove the \r\n// protection that avoid Starter to be called in CyyStartOrQueue.\r\n// We will let CyyGetNextIrp null out that pointer. Fanny.\r\n//\r\n//                    //\r\n//                    // Since it isn't really the mask irp anymore,\r\n//                    // null out that pointer.\r\n//                    //\r\n//\r\n//                    Extension->CurrentMaskIrp = NULL;\r\n\r\n                    Extension->CurrentMaskIrp = NULL; // back in Windows 2000. Fanny\r\n\r\n                    //\r\n                    // This will release the cancel spinlock for us\r\n                    //\r\n\r\n                    CyyGetNextIrpLocked(&Extension->CurrentMaskIrp,\r\n                                        &Extension->MaskQueue, &NewIrp,\r\n                                        FALSE, Extension, OldIrql);\r\n\r\n                    CyyDbgPrintEx(CYYDIAG4, \"Perhaps another mask irp was \"\r\n                                  \"found in the queue\\n\"\r\n                                  \"------- %x/%x <- values should be the \"\r\n                                  \"same\\n\", Extension->CurrentMaskIrp,\r\n                                  NewIrp);\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n    } while (NewIrp);\r\n\r\n    return FirstStatus;\r\n\r\n}\r\n\f\r\nBOOLEAN\r\nCyyGrabWaitFromIsr(\r\n    IN PVOID Context\r\n    )\r\n\r\n/*++\r\n\r\nRoutine Description:\r\n\r\n    This routine will check to see if the ISR still knows about\r\n    a wait irp by checking to see if the IrpMaskLocation is non-null.\r\n    If it is then it will zero the Irpmasklocation (which in effect\r\n    grabs the irp away from the isr).  This routine is only called\r\n    buy the cancel code for the wait.\r\n\r\n    NOTE: This is called by KeSynchronizeExecution.\r\n\r\nArguments:\r\n\r\n    Context - A pointer to the device extension\r\n\r\nReturn Value:\r\n\r\n    Always FALSE.\r\n\r\n--*/\r\n\r\n{\r\n\r\n    PCYY_DEVICE_EXTENSION Extension = Context;\r\n    CYY_LOCKED_PAGED_CODE();\r\n\r\n    CyyDbgPrintEx(CYYDIAG3, \"In CyyGrabWaitFromIsr\\n\");\r\n\r\n    if (Extension->IrpMaskLocation) {\r\n\r\n        CyyDbgPrintEx(CYYDIAG4, \"The isr still owns the irp %x, mask \"\r\n                      \"location is %x\\n\"\r\n                      \"------- and system buffer is %x\\n\",\r\n                      Extension->CurrentWaitIrp,Extension->IrpMaskLocation,\r\n                      Extension->CurrentWaitIrp->AssociatedIrp.SystemBuffer);\r\n\r\n        //\r\n        // The isr still \"owns\" the irp.\r\n        //\r\n\r\n        *Extension->IrpMaskLocation = 0;\r\n        Extension->IrpMaskLocation = NULL;\r\n\r\n        Extension->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);\r\n\r\n        //\r\n        // Since the isr no longer references the irp we need to\r\n        // decrement the reference count.\r\n        //\r\n\r\n        SERIAL_CLEAR_REFERENCE(\r\n            Extension->CurrentWaitIrp,\r\n            SERIAL_REF_ISR\r\n            );\r\n\r\n    }\r\n\r\n    return FALSE;\r\n}\r\n\f\r\nBOOLEAN\r\nCyyGiveWaitToIsr(\r\n    IN PVOID Context\r\n    )\r\n\r\n/*++\r\n\r\nRoutine Description:\r\n\r\n    This routine simply sets a variable in the device extension\r\n    so that the isr knows that we have a wait irp.\r\n\r\n    NOTE: This is called by KeSynchronizeExecution.\r\n\r\n    NOTE: This routine assumes that it is called with the\r\n          cancel spinlock held.\r\n\r\nArguments:\r\n\r\n    Context - Simply a pointer to the device extension.\r\n\r\nReturn Value:\r\n\r\n    Always FALSE.\r\n\r\n--*/\r\n\r\n{\r\n\r\n    PCYY_DEVICE_EXTENSION Extension = Context;\r\n    CYY_LOCKED_PAGED_CODE();\r\n\r\n    CyyDbgPrintEx(CYYDIAG3, \"In CyyGiveWaitToIsr\\n\");\r\n    //\r\n    // There certainly shouldn't be a current mask location at\r\n    // this point since we have a new current wait irp.\r\n    //\r\n\r\n    ASSERT(!Extension->IrpMaskLocation);\r\n\r\n    //\r\n    // The isr may or may not actually reference this irp.  It\r\n    // won't if the wait can be satisfied immediately.  However,\r\n    // since it will then go through the normal completion sequence,\r\n    // we need to have an incremented reference count anyway.\r\n    //\r\n\r\n    SERIAL_SET_REFERENCE(\r\n        Extension->CurrentWaitIrp,\r\n        SERIAL_REF_ISR\r\n        );\r\n\r\n    if (!Extension->HistoryMask) {\r\n\r\n        CyyDbgPrintEx(CYYDIAG4, \"No events occured prior to the wait call\"\r\n                      \"\\n\");\r\n\r\n        //\r\n        // Although this wait might not be for empty transmit\r\n        // queue, it doesn't hurt anything to set it to false.\r\n        //\r\n\r\n        Extension->EmptiedTransmit = FALSE;\r\n\r\n        //\r\n        // Record where the \"completion mask\" should be set.\r\n        //\r\n\r\n        Extension->IrpMaskLocation =\r\n            Extension->CurrentWaitIrp->AssociatedIrp.SystemBuffer;\r\n        CyyDbgPrintEx( CYYDIAG4, \"The isr owns the irp %x, mask location is \"\r\n                       \"%x\\n\"\r\n                       \"------- and system buffer is %x\\n\",\r\n                       Extension->CurrentWaitIrp,Extension->IrpMaskLocation,\r\n                       Extension->CurrentWaitIrp->AssociatedIrp\r\n                       .SystemBuffer);\r\n\r\n    } else {\r\n\r\n        CyyDbgPrintEx(CYYDIAG4, \"%x occurred prior to the wait - starting \"\r\n                      \"the\\n\"\r\n                      \"------- completion code for %x\\n\",\r\n                      Extension->HistoryMask,Extension->CurrentWaitIrp);\r\n\r\n        *((ULONG *)Extension->CurrentWaitIrp->AssociatedIrp.SystemBuffer) =\r\n            Extension->HistoryMask;\r\n        Extension->HistoryMask = 0;\r\n        Extension->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);\r\n        Extension->CurrentWaitIrp->IoStatus.Status = STATUS_SUCCESS;\r\n\r\n        CyyInsertQueueDpc(&Extension->CommWaitDpc, NULL, NULL, Extension);\r\n\r\n    }\r\n\r\n    return FALSE;\r\n}\r\n\f\r\nBOOLEAN\r\nCyyFinishOldWait(\r\n    IN PVOID Context\r\n    )\r\n\r\n/*++\r\n\r\nRoutine Description:\r\n\r\n    This routine will check to see if the ISR still knows about\r\n    a wait irp by checking to see if the Irpmasklocation is non-null.\r\n    If it is then it will zero the Irpmasklocation (which in effect\r\n    grabs the irp away from the isr).  This routine is only called\r\n    buy the cancel code for the wait.\r\n\r\n    NOTE: This is called by KeSynchronizeExecution.\r\n\r\nArguments:\r\n\r\n    Context - A pointer to the device extension\r\n\r\nReturn Value:\r\n\r\n    Always FALSE.\r\n\r\n--*/\r\n\r\n{\r\n\r\n    PCYY_DEVICE_EXTENSION Extension = Context;\r\n    CYY_LOCKED_PAGED_CODE();\r\n\r\n    CyyDbgPrintEx(CYYDIAG3, \"In CyyFinishOldWait\\n\");\r\n\r\n    if (Extension->IrpMaskLocation) {\r\n\r\n        CyyDbgPrintEx(CYYDIAG4, \"The isr still owns the irp %x, mask \"\r\n                      \"location is %x\\n\"\r\n                      \"------- and system buffer is %x\\n\",\r\n                      Extension->CurrentWaitIrp,Extension->IrpMaskLocation,\r\n                      Extension->CurrentWaitIrp->AssociatedIrp.SystemBuffer);\r\n        //\r\n        // The isr still \"owns\" the irp.\r\n        //\r\n\r\n        *Extension->IrpMaskLocation = 0;\r\n        Extension->IrpMaskLocation = NULL;\r\n\r\n        Extension->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);\r\n\r\n        //\r\n        // We don't decrement the reference since the completion routine\r\n        // will do that.\r\n        //\r\n\r\n        CyyInsertQueueDpc(&Extension->CommWaitDpc, NULL, NULL, Extension);\r\n\r\n    }\r\n\r\n    //\r\n    // Don't wipe out any historical data we are still interested in.\r\n    //\r\n\r\n    Extension->HistoryMask &= *((ULONG *)Extension->CurrentMaskIrp->\r\n                                            AssociatedIrp.SystemBuffer);\r\n\r\n    Extension->IsrWaitMask = *((ULONG *)Extension->CurrentMaskIrp->\r\n                                            AssociatedIrp.SystemBuffer);\r\n    CyyDbgPrintEx( CYYDIAG4, \"Set mask location of %x, in irp %x, with \"\r\n                   \"system buffer of %x\\n\",\r\n                   Extension->IrpMaskLocation, Extension->CurrentMaskIrp,\r\n                   Extension->CurrentMaskIrp->AssociatedIrp.SystemBuffer);\r\n    return FALSE;\r\n}\r\n\f\r\nVOID\r\nCyyCancelWait(\r\n    IN PDEVICE_OBJECT DeviceObject,\r\n    IN PIRP Irp\r\n    )\r\n\r\n/*++\r\n\r\nRoutine Description:\r\n\r\n    This routine is used to cancel a irp that is waiting on\r\n    a comm event.\r\n\r\nArguments:\r\n\r\n    DeviceObject - Pointer to the device object for this device\r\n\r\n    Irp - Pointer to the IRP for the current request\r\n\r\nReturn Value:\r\n\r\n    None.\r\n\r\n--*/\r\n\r\n{\r\n\r\n    PCYY_DEVICE_EXTENSION Extension = DeviceObject->DeviceExtension;\r\n    CYY_LOCKED_PAGED_CODE();\r\n\r\n    CyyDbgPrintEx(CYYDIAG3, \"In CyyCancelWait\\n\");\r\n\r\n    CyyDbgPrintEx(CYYDIAG4, \"Canceling wait for irp %x\\n\",\r\n                  Extension->CurrentWaitIrp);\r\n\r\n    CyyTryToCompleteCurrent(Extension, CyyGrabWaitFromIsr,\r\n                            Irp->CancelIrql, STATUS_CANCELLED,\r\n                            &Extension->CurrentWaitIrp, NULL, NULL, NULL,\r\n                            NULL, NULL, SERIAL_REF_CANCEL);\r\n\r\n}\r\n\f\r\nVOID\r\nCyyCompleteWait(\r\n    IN PKDPC Dpc,\r\n    IN PVOID DeferredContext,\r\n    IN PVOID SystemContext1,\r\n    IN PVOID SystemContext2\r\n    )\r\n\r\n{\r\n    PCYY_DEVICE_EXTENSION Extension = DeferredContext;\r\n    KIRQL OldIrql;\r\n\r\n\r\n    CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, \">CyyCompleteWait(%X)\\n\",\r\n                  Extension);\r\n\r\n    CyyDbgPrintEx(CYYDIAG3, \"In CyyCompleteWait\\n\");\r\n\r\n    UNREFERENCED_PARAMETER(SystemContext1);\r\n    UNREFERENCED_PARAMETER(SystemContext2);\r\n\r\n    IoAcquireCancelSpinLock(&OldIrql);\r\n\r\n    CyyDbgPrintEx(CYYDIAG4, \"Completing wait for irp %x\\n\",\r\n                  Extension->CurrentWaitIrp);\r\n\r\n    CyyTryToCompleteCurrent(Extension, NULL, OldIrql, STATUS_SUCCESS,\r\n                            &Extension->CurrentWaitIrp, NULL, NULL, NULL,\r\n                            NULL, NULL, SERIAL_REF_ISR);\r\n\r\n    CyyDpcEpilogue(Extension, Dpc);\r\n\r\n\r\n    CyyDbgPrintEx(DPFLTR_TRACE_LEVEL, \"<CyyCompleteWait\\n\");\r\n}\r\n\u001a\n", "comment_ratio": 0.14413075780089152}
{"lang": "c", "code": "#ifndef CHROMEOS_SERVICES_LIBASSISTANT_AUDIO_FAKE_INPUT_DEVICE_H_\n#define CHROMEOS_SERVICES_LIBASSISTANT_AUDIO_FAKE_INPUT_DEVICE_H_\n\n#include \"base/memory/scoped_refptr.h\"\n\nnamespace media {\nclass AudioCapturerSource;\n}  // namespace media\n\nnamespace chromeos {\nnamespace libassistant {\n\n// Create a fake input device. When asked to record input, it will read the\n// input from an audio file generated by the chromeos/assistant/send-audio.sh\n// script.\nscoped_refptr<media::AudioCapturerSource> CreateFakeInputDevice();\n\n}  // namespace libassistant\n}  // namespace chromeos\n\n#endif  // CHROMEOS_SERVICES_LIBASSISTANT_AUDIO_FAKE_INPUT_DEVICE_H_\n\n", "comment_ratio": 0.38461538461538464}
{"lang": "c", "code": "//\n//  UIImage+Grayscale.h\n//\n//  Created by Andreas Liebschner on 4/13/12.\n//\n\n#import <UIKit/UIKit.h>\n\n@interface UIImage (Grayscale)\n\n- (UIImage *)convertToGrayscale;\n\n@end\n\n", "comment_ratio": 0.35714285714285715}
{"lang": "c", "code": "#pragma once\n\nnamespace fv3jedi {\n  typedef int F90vc_M2G;\n  extern \"C\" {\n  void fv3jedi_vc_model2geovals_create_f90(const F90vc_M2G &, const F90geom &,\n                                           const eckit::Configuration * const *);\n  void fv3jedi_vc_model2geovals_delete_f90(F90vc_M2G &);\n  void fv3jedi_vc_model2geovals_changevar_f90(const F90vc_M2G &, const F90geom &, const F90state &,\n                                              const F90state &);\n  }  // extern \"C\"\n}  // namespace fv3jedi\n\n", "comment_ratio": 0.15}
{"lang": "c", "code": "#include <nds.h>\n#include <maxmod7.h>\n\n//---------------------------------------------------------------------------------\nvoid VblankHandler(void) {\n//---------------------------------------------------------------------------------\n\n}\n\n//---------------------------------------------------------------------------------\nvoid VcountHandler() {\n//---------------------------------------------------------------------------------\n\tinputGetAndSend();\n}\n\nvolatile bool exitflag = false;\n\n//---------------------------------------------------------------------------------\nvoid powerButtonCB() {\n//---------------------------------------------------------------------------------\n\texitflag = true;\n}\n\n//---------------------------------------------------------------------------------\nint main() {\n//---------------------------------------------------------------------------------\n    nocashMessage(\"ARM7 main.c main\");\n\t\n\t// clear sound registers\n\t/*dmaFillWords(0, (void*)0x04000400, 0x100);\n\n\tREG_SOUNDCNT |= SOUND_ENABLE;\n\twritePowerManagement(PM_CONTROL_REG, ( readPowerManagement(PM_CONTROL_REG) & ~PM_SOUND_MUTE ) | PM_SOUND_AMP );\n\tpowerOn(POWER_SOUND);*/\n\n\treadUserSettings();\n\tledBlink(0);\n\n\tirqInit();\n\t// Start the RTC tracking IRQ\n\tinitClockIRQ();\n\t\n\ttouchInit();\n\tfifoInit();\n\t\n\t//mmInstall(FIFO_MAXMOD);\n\tSetYtrigger(80);\n\t\n\t//installSoundFIFO();\n\tinstallSystemFIFO();\n\n\tirqSet(IRQ_VCOUNT, VcountHandler);\n\tirqSet(IRQ_VBLANK, VblankHandler);\n\n\tirqEnable( IRQ_VBLANK | IRQ_VCOUNT );\n\n\tsetPowerButtonCB(powerButtonCB);\n\t\n\tfifoSendValue32(FIFO_USER_07, *(u16*)(0x4004700));\n\n\t// Keep the ARM7 mostly idle\n\twhile (!exitflag) {\n\t\tif ( 0 == (REG_KEYINPUT & (KEY_SELECT | KEY_START | KEY_L | KEY_R))) {\n\t\t\texitflag = true;\n\t\t}\n\t\t// fifocheck();\n\t\tswiWaitForVBlank();\n\t}\n\treturn 0;\n}\n\n\n", "comment_ratio": 0.13861386138613863}
{"lang": "c", "code": "#define _SYSTEM_MM32_C_\n\n// Files includes  -------------------------------------------------------------\n\n/// @addtogroup CMSIS\n/// @{\n\n#include \"mm32_device.h\"\n\n\n/// @}\n\n\n\n/// @}\n\n\n/// Uncomment the line corresponding to the desired System clock (SYSCLK)\n/// frequency (after reset the HSI is used as SYSCLK source)\n///\n/// IMPORTANT NOTE:\n/// ==============\n/// 1. After each device reset the HSI is used as System clock source.\n///\n/// 2. Please make sure that the selected System clock doesn't exceed your device's\n/// maximum frequency.\n///\n/// 3. If none of the define below is enabled, the HSI is used as System clock\n/// source.\n///\n/// 4. The System clock configuration functions provided within this file assume that:\n/// - For Low, Medium and High density Value line devices an external 8MHz\n/// crystal is used to drive the System clock.\n/// - For Low, Medium and High density devices an external 8MHz crystal is\n/// used to drive the System clock.\n/// - For Connectivity line devices an external 25MHz crystal is used to drive\n/// the System clock.\n/// If you are using different crystal you have to adapt those functions accordingly.\n\n\n//#define SYSCLK_FREQ_HSE    HSE_VALUE\n//#define SYSCLK_FREQ_24MHz  24000000\n//#define SYSCLK_FREQ_36MHz  36000000\n//#define SYSCLK_FREQ_48MHz  48000000\n//#define SYSCLK_FREQ_72MHz  72000000\n\n//#define SYSCLK_HSI_24MHz  24000000\n//#define SYSCLK_HSI_36MHz  36000000\n#define SYSCLK_HSI_48MHz  48000000\n//#define SYSCLK_HSI_72MHz  72000000\n\n/// Uncomment the following line if you need to relocate your vector Table in\n/// Internal SRAM.\n///#define VECT_TAB_SRAM\n#define VECT_TAB_OFFSET  0x0\n/// Vector Table base offset field.\n/// This value must be a multiple of 0x200.\n\n\n/// @}\n\n\n///////////////////////////////////////////////////////////////\n///Clock Definitions\n///////////////////////////////////////////////////////////////\n#if defined SYSCLK_FREQ_HSE\nuint32_t SystemCoreClock         = SYSCLK_FREQ_HSE;\n#elif defined SYSCLK_FREQ_24MHz\nuint32_t SystemCoreClock         = SYSCLK_FREQ_24MHz;\n#elif defined SYSCLK_FREQ_36MHz\nuint32_t SystemCoreClock         = SYSCLK_FREQ_36MHz;\n#elif defined SYSCLK_FREQ_48MHz\nuint32_t SystemCoreClock         = SYSCLK_FREQ_48MHz;\n#elif defined SYSCLK_FREQ_72MHz\nuint32_t SystemCoreClock         = SYSCLK_FREQ_72MHz;\n\n\n#elif defined SYSCLK_HSI_24MHz\nuint32_t SystemCoreClock         = SYSCLK_HSI_24MHz;\n#elif defined SYSCLK_HSI_36MHz\nuint32_t SystemCoreClock         = SYSCLK_HSI_36MHz;\n#elif defined SYSCLK_HSI_48MHz\nuint32_t SystemCoreClock         = SYSCLK_HSI_48MHz;\n#elif defined SYSCLK_HSI_72MHz\nuint32_t SystemCoreClock         = SYSCLK_HSI_72MHz;\n#else //HSI Selected as System Clock source \nuint32_t SystemCoreClock         = HSI_VALUE;\n#endif\n\n__I uint8_t AHBPrescTable[16] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 6, 7, 8, 9};\n\n/// @}\n\n\nstatic void SetSysClock(void);\n\n#if defined SYSCLK_FREQ_HSE\nstatic void SetSysClockToHSE(void);\n#elif defined SYSCLK_FREQ_24MHz\nstatic void SetSysClockTo24(void);\n#elif defined SYSCLK_FREQ_36MHz\nstatic void SetSysClockTo36(void);\n#elif defined SYSCLK_FREQ_48MHz\nstatic void SetSysClockTo48(void);\n#elif defined SYSCLK_FREQ_72MHz\nstatic void SetSysClockTo72(void);\n\n#elif defined SYSCLK_HSI_24MHz\nstatic void SetSysClockTo24_HSI(void);\n#elif defined SYSCLK_HSI_36MHz\nstatic void SetSysClockTo36_HSI(void);\n#elif defined SYSCLK_HSI_48MHz\nstatic void SetSysClockTo48_HSI(void);\n#elif defined SYSCLK_HSI_72MHz\nstatic void SetSysClockTo72_HSI(void);\n#endif\n\n#ifdef DATA_IN_ExtSRAM\nstatic void SystemInit_ExtMemCtl(void);\n#endif //DATA_IN_ExtSRAM \n\n\n/// @}\n\n\n\n/// @brief  Setup the microcontroller system\n///         Initialize the Embedded Flash Interface, the PLL and update the\n///         SystemCoreClock variable.\n/// @note   This function should be used only after reset.\n/// @param  None\n/// @retval None\n\nvoid SystemInit (void)\n{\n    //Reset the RCC clock configuration to the default reset state(for debug purpose)\n    //Set HSION bit\n    RCC->CR |= (uint32_t)0x00000001;\n\n    //Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits\n    RCC->CFGR &= (uint32_t)0xF8FFC00C;\n\n    //Reset HSEON, CSSON and PLLON bits\n    RCC->CR &= (uint32_t)0xFEF6FFFF;\n\n    //Reset HSEBYP bit\n    RCC->CR &= (uint32_t)0xFFFBFFFF;\n\n    //Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits\n    RCC->CFGR &= (uint32_t)0xFF3CFFFF;\n    RCC->CR &= (uint32_t)0x008FFFFF;\n\n    //Disable all interrupts and clear pending bits\n    RCC->CIR = 0x009F0000;\n\n    //Configure the System clock frequency, HCLK, PCLK2 and PCLK1 prescalers\n    //Configure the Flash Latency cycles and enable prefetch buffer\n    SetSysClock();\n}\n\n\n/// @brief  use to return the pllm&plln.\n/// @param  pllclkSourceFrq : PLL source clock frquency;\n///         pllclkFrq : Target PLL clock frquency;\n///         plln : PLL factor PLLN\n///         pllm : PLL factor PLLM\n/// @retval amount of error\nu32 AutoCalPllFactor(u32 pllclkSourceFrq, u32 pllclkFrq, u8* plln, u8* pllm)\n{\n    u32 n, m;\n    u32 tempFrq;\n    u32 minDiff = pllclkFrq;\n    u8  flag = 0;\n    for(m = 0; m < 4 ; m++) {\n        for(n = 0; n < 64 ; n++) {\n            tempFrq =  pllclkSourceFrq * (n + 1) / (m + 1);\n            tempFrq = (tempFrq >  pllclkFrq) ? (tempFrq - pllclkFrq) : (pllclkFrq - tempFrq) ;\n\n            if(minDiff > tempFrq) {\n                minDiff =  tempFrq;\n                *plln = n;\n                *pllm = m;\n            }\n            if(minDiff == 0) {\n                flag = 1;\n                break;\n            }\n        }\n        if(flag != 0) {\n            break;\n        }\n    }\n    return  minDiff;\n}\n\n/// @brief  Configures the System clock frequency, HCLK, PCLK2 and PCLK1 prescalers.\n/// @param  None\n/// @retval None\n\nstatic void SetSysClock(void)\n{\n#ifdef SYSCLK_FREQ_HSE\n    SetSysClockToHSE();\n#elif defined SYSCLK_FREQ_24MHz\n    SetSysClockTo24();\n#elif defined SYSCLK_FREQ_36MHz\n    SetSysClockTo36();\n#elif defined SYSCLK_FREQ_48MHz\n    SetSysClockTo48();\n#elif defined SYSCLK_FREQ_72MHz\n    SetSysClockTo72();\n\n#elif defined SYSCLK_HSI_24MHz\n    SetSysClockTo24_HSI();\n#elif defined SYSCLK_HSI_36MHz\n    SetSysClockTo36_HSI();\n#elif defined SYSCLK_HSI_48MHz\n    SetSysClockTo48_HSI();\n#elif defined SYSCLK_HSI_72MHz\n    SetSysClockTo72_HSI();\n#endif\n\n    //If none of the define above is enabled, the HSI is used as System clock\n    //source (default after reset)\n}\n\n#ifdef SYSCLK_FREQ_HSE\n\n/// @brief  Selects HSE as System clock source and configure HCLK, PCLK2\n///         and PCLK1 prescalers.\n/// @note   This function should be used only after reset.\n/// @param  None\n/// @retval None\n\nstatic void SetSysClockToHSE(void)\n{\n    __IO uint32_t StartUpCounter = 0, HSEStatus = 0;\n    int i;\n\n    //SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------\n    //Enable HSE\n    RCC->CR |= ((uint32_t)RCC_CR_HSEON);\n\n    //Wait till HSE is ready and if Time out is reached exit\n    do {\n        HSEStatus = RCC->CR & RCC_CR_HSERDY;\n        StartUpCounter++;\n    } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));\n\n    if ((RCC->CR & RCC_CR_HSERDY) != RESET) {\n        HSEStatus = (uint32_t)0x01;\n        i = 2000; while(i--);\n    }\n    else {\n        HSEStatus = (uint32_t)0x00;\n    }\n\n    if (HSEStatus == (uint32_t)0x01) {\n        //Enable Prefetch Buffer\n        FLASH->ACR |= FLASH_ACR_PRFTBE;\n\n        //Flash 0 wait state ,bit0~2\n        FLASH->ACR &= ~FLASH_ACR_LATENCY;\n        //HCLK = SYSCLK\n        RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;\n\n        //PCLK2 = HCLK\n        RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;\n\n        //PCLK1 = HCLK\n        RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV1;\n\n        //Select HSE as system clock source\n        RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));\n        RCC->CFGR |= (uint32_t)RCC_CFGR_SW_HSE;\n\n        //Wait till HSE is used as system clock source\n        while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x04) {\n        }\n    }\n    else {\n        //If HSE fails to start-up, the application will have wrong clock\n        //configuration. User can add here some code to deal with this error\n    }\n}\n#elif defined SYSCLK_FREQ_24MHz\n\n/// @brief  Sets System clock frequency to 24MHz and configure HCLK, PCLK2\n///         and PCLK1 prescalers.\n/// @note   This function should be used only after reset.\n/// @param  None\n/// @retval None\n\nstatic void SetSysClockTo24(void)\n{\n    __IO uint32_t StartUpCounter = 0, HSEStatus = 0;\n    int i;\n\n    //SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------\n    //Enable HSE\n    RCC->CR |= ((uint32_t)RCC_CR_HSEON);\n\n    //Wait till HSE is ready and if Time out is reached exit\n    do {\n        HSEStatus = RCC->CR & RCC_CR_HSERDY;\n        StartUpCounter++;\n    } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));\n\n    if ((RCC->CR & RCC_CR_HSERDY) != RESET) {\n        HSEStatus = (uint32_t)0x01;\n        i = 2000; while(i--);\n    }\n    else {\n        HSEStatus = (uint32_t)0x00;\n    }\n\n    if (HSEStatus == (uint32_t)0x01) {\n        //Enable Prefetch Buffer\n        FLASH->ACR |= FLASH_ACR_PRFTBE;\n        //Flash 0 wait state ,bit0~2\n        FLASH->ACR &= ~FLASH_ACR_LATENCY;\n        FLASH->ACR |= FLASH_ACR_LATENCY_1;\n        //HCLK = SYSCLK\n        RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;\n\n        //PCLK2 = HCLK\n        RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;\n\n        //PCLK1 = HCLK\n        RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV1;\n\n        // PLL configuration:  = (HSE ) * (2+1) = 24 MHz\n        RCC->CFGR &= ~((uint32_t)(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE));\n        RCC->CR &= ~((uint32_t)(RCC_CR_PLLDIV | RCC_CR_PLLON | RCC_CR_PLLRDY | RCC_CR_PLLMUL));\n\n        RCC->CFGR |= (uint32_t)RCC_CFGR_PLLSRC;\n        RCC->CR   |= (0x02 << RCC_CR_PLLMUL_Pos);\n\n        //Enable PLL\n        RCC->CR |= RCC_CR_PLLON;\n\n        //Wait till PLL is ready\n        while((RCC->CR & RCC_CR_PLLRDY) == 0) {\n        }\n\n        //Select PLL as system clock source\n        RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));\n        RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;\n\n        //Wait till PLL is used as system clock source\n        while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08) {\n        }\n    }\n    else {\n        //If HSE fails to start-up, the application will have wrong clock\n        //configuration. User can add here some code to deal with this error\n    }\n}\n#elif defined SYSCLK_FREQ_36MHz\n\n/// @brief  Sets System clock frequency to 36MHz and configure HCLK, PCLK2\n///         and PCLK1 prescalers.\n/// @note   This function should be used only after reset.\n/// @param  None\n/// @retval None\n\nstatic void SetSysClockTo36(void)\n{\n    int i;\n    __IO uint32_t StartUpCounter = 0, HSEStatus = 0;\n\n    //SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------\n    //Enable HSE\n    RCC->CR |= ((uint32_t)RCC_CR_HSEON);\n\n    //Wait till HSE is ready and if Time out is reached exit\n    do {\n        HSEStatus = RCC->CR & RCC_CR_HSERDY;\n        StartUpCounter++;\n    } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));\n\n    if ((RCC->CR & RCC_CR_HSERDY) != RESET) {\n        HSEStatus = (uint32_t)0x01;\n        i = 2000; while(i--);\n    }\n    else {\n        HSEStatus = (uint32_t)0x00;\n    }\n\n    if (HSEStatus == (uint32_t)0x01) {\n        //Enable Prefetch Buffer\n        FLASH->ACR |= FLASH_ACR_PRFTBE;\n\n        //Flash 0 wait state ,bit0~2\n        FLASH->ACR &= ~FLASH_ACR_LATENCY;\n        FLASH->ACR |= FLASH_ACR_LATENCY_1;\n        //HCLK = SYSCLK\n        RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;\n\n        //PCLK2 = HCLK\n        RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;\n\n        //PCLK1 = HCLK\n        RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV1;\n\n        // PLL configuration:  = (HSE ) * (8+1)/(1+1) = 36 MHz\n        RCC->CFGR &= ~((uint32_t)(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE));\n        RCC->CR &= ~((uint32_t)(RCC_CR_PLLDIV | RCC_CR_PLLON | RCC_CR_PLLRDY | RCC_CR_PLLMUL));\n\n        RCC->CFGR |= (uint32_t)RCC_CFGR_PLLSRC ;\n        RCC->CR   |= ((0x08 << RCC_CR_PLLMUL_Pos) | (0x01 << RCC_CR_PLLDIV_Pos));\n\n        //Enable PLL\n        RCC->CR |= RCC_CR_PLLON;\n\n        //Wait till PLL is ready\n        while((RCC->CR & RCC_CR_PLLRDY) == 0) {\n        }\n\n        //Select PLL as system clock source\n        RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));\n        RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;\n\n        //Wait till PLL is used as system clock source\n        while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08) {\n        }\n    }\n    else {\n        //If HSE fails to start-up, the application will have wrong clock\n        //configuration. User can add here some code to deal with this error\n    }\n}\n#elif defined SYSCLK_FREQ_48MHz\n\n/// @brief  Sets System clock frequency to 48MHz and configure HCLK, PCLK2\n///         and PCLK1 prescalers.\n/// @note   This function should be used only after reset.\n/// @param  None\n/// @retval None\n\nstatic void SetSysClockTo48(void)\n{\n    __IO uint32_t StartUpCounter = 0, HSEStatus = 0;\n    int i;\n    uint8_t plln, pllm;\n    //SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------\n    //Enable HSE\n    RCC->CR |= ((uint32_t)RCC_CR_HSEON);\n\n    //Wait till HSE is ready and if Time out is reached exit\n    do {\n        HSEStatus = RCC->CR & RCC_CR_HSERDY;\n        StartUpCounter++;\n    } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));\n\n    if ((RCC->CR & RCC_CR_HSERDY) != RESET) {\n        HSEStatus = (uint32_t)0x01;\n        i = 2000; while(i--);\n    }\n    else {\n        HSEStatus = (uint32_t)0x00;\n    }\n\n    if (HSEStatus == (uint32_t)0x01) {\n        //Enable Prefetch Buffer\n        FLASH->ACR |= FLASH_ACR_PRFTBE;\n        //Flash 0 wait state ,bit0~2\n        FLASH->ACR &= ~FLASH_ACR_LATENCY;\n        FLASH->ACR |= FLASH_ACR_LATENCY_2;\n        //HCLK = SYSCLK\n        RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;\n\n        //PCLK2 = HCLK\n        RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;\n\n        //PCLK1 = HCLK\n        RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;\n\n        // PLL configuration:  = (HSE ) * (5+1) = 48MHz\n        RCC->CFGR &= ~((uint32_t)(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE));\n        RCC->CR &= ~((uint32_t)(RCC_CR_PLLDIV | RCC_CR_PLLON | RCC_CR_PLLRDY | RCC_CR_PLLMUL));\n\n        RCC->CFGR |= (uint32_t ) RCC_CFGR_PLLSRC;\n        RCC->CR   |= (0x05 << RCC_CR_PLLMUL_Pos);\n\n        //Enable PLL\n        RCC->CR |= RCC_CR_PLLON;\n\n        //Wait till PLL is ready\n        while((RCC->CR & RCC_CR_PLLRDY) == 0) {\n        }\n\n        //Select PLL as system clock source\n        RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));\n        RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;\n\n        //Wait till PLL is used as system clock source\n        while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08) {\n        }\n    }\n    else {\n        //If HSE fails to start-up, the application will have wrong clock\n        //configuration. User can add here some code to deal with this error\n    }\n}\n#elif defined SYSCLK_FREQ_72MHz\n\n/// @brief  Sets System clock frequency to XXMHz and configure HCLK, PCLK2\n///         and PCLK1 prescalers.\n/// @note   This function should be used only after reset.\n/// @param  None\n/// @retval None\n\nstatic void SetSysClockTo72(void)\n{\n    __IO uint32_t StartUpCounter = 0, HSEStatus = 0;\n    int i;\n    uint32_t temp;\n    uint8_t plln, pllm;\n    //SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------\n    //Enable HSE\n    RCC->CR |= ((uint32_t)RCC_CR_HSEON);\n\n    //Wait till HSE is ready and if Time out is reached exit\n    do {\n        HSEStatus = RCC->CR & RCC_CR_HSERDY;\n        StartUpCounter++;\n    } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));\n\n    if ((RCC->CR & RCC_CR_HSERDY) != RESET) {\n        HSEStatus = (uint32_t)0x01;\n        i = 2000; while(i--);\n    }\n    else {\n        HSEStatus = (uint32_t)0x00;\n    }\n\n    if (HSEStatus == (uint32_t)0x01) {\n        SystemCoreClock         = SYSCLK_FREQ_72MHz;\n        //Enable Prefetch Buffer\n        FLASH->ACR |= FLASH_ACR_PRFTBE;\n        //Flash 0 wait state ,bit0~2\n        FLASH->ACR &= ~FLASH_ACR_LATENCY;\n        temp = (SystemCoreClock - 1) / 24000000;\n        FLASH->ACR |= temp;\n\n        RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;\n        //HCLK = SYSCLK\n\n        //PCLK2 = HCLK\n        RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;\n\n        if(SystemCoreClock > 36000000) {\n            //PCLK1 = HCLK/2\n            RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;\n        }\n        else {\n            //PCLK1 = HCLK\n            RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;\n        }\n\n        RCC->CFGR &= ~((uint32_t)(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE));\n        RCC->CR &= ~((uint32_t)(RCC_CR_PLLDIV | RCC_CR_PLLON | RCC_CR_PLLRDY | RCC_CR_PLLMUL));\n\n        RCC->CFGR |= (uint32_t ) RCC_CFGR_PLLSRC ;\n\n        AutoCalPllFactor(8000000, SystemCoreClock, &plln, &pllm);\n        RCC->CR &= ~((uint32_t)(RCC_CR_PLLDIV | RCC_CR_PLLON | RCC_CR_PLLRDY | RCC_CR_PLLMUL));\n        RCC->CR |= (plln << RCC_CR_PLLMUL_Pos) | (pllm << RCC_CR_PLLDIV_Pos);\n\n        //Enable PLL\n        RCC->CR |= RCC_CR_PLLON;\n\n        //Wait till PLL is ready\n        while((RCC->CR & RCC_CR_PLLRDY) == 0) {\n        }\n\n        //Select PLL as system clock source\n        RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));\n        RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;\n\n        //Wait till PLL is used as system clock source\n        while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08) {\n        }\n    }\n    else {\n        //If HSE fails to start-up, the application will have wrong clock\n        //configuration. User can add here some code to deal with this error\n    }\n}\n#elif defined SYSCLK_HSI_24MHz\nvoid SetSysClockTo24_HSI(void)\n{\n    __IO uint32_t StartUpCounter = 0, HSIStatus = 0;\n    int i;\n    unsigned char temp = 0;\n    uint8_t plln, pllm;\n\n    //Enable HSI\n    RCC->CR |= RCC_CR_HSION;\n\n    //Wait till HSI is ready and if Time out is reached exit\n    do {\n        HSIStatus = RCC->CR & RCC_CR_HSIRDY;\n        StartUpCounter++;\n    } while((HSIStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));\n\n    if ((RCC->CR & RCC_CR_HSIRDY) != RESET) {\n        HSIStatus = (uint32_t)0x01;\n        i = 2000; while(i--);\n    }\n    else {\n        HSIStatus = (uint32_t)0x00;\n    }\n\n    if (HSIStatus == (uint32_t)0x01) {\n        SystemCoreClock         = SYSCLK_HSI_24MHz;\n        //Enable Prefetch Buffer\n        FLASH->ACR |= FLASH_ACR_PRFTBE;\n        //Flash 0 wait state ,bit0~2\n        FLASH->ACR &= ~FLASH_ACR_LATENCY;\n\n        temp = (SystemCoreClock - 1) / 24000000;\n\n        FLASH->ACR |= temp;\n\n        //HCLK = SYSCLK\n        RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;\n\n        //PCLK2 = HCLK\n        RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;\n\n        if(SystemCoreClock > 36000000) {\n            //PCLK1 = HCLK/2\n            RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;\n        }\n        else {\n            //PCLK1 = HCLK\n            RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;\n        }\n\n        RCC->CFGR &= ~((uint32_t)(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE));\n        RCC->CR &= ~((uint32_t)(RCC_CR_PLLDIV | RCC_CR_PLLON | RCC_CR_PLLRDY | RCC_CR_PLLMUL));\n\n        AutoCalPllFactor(12000000, SystemCoreClock, &plln, &pllm);\n        RCC->CR &= ~((uint32_t)(RCC_CR_PLLDIV | RCC_CR_PLLON | RCC_CR_PLLRDY | RCC_CR_PLLMUL));\n        RCC->CR |= (plln << RCC_CR_PLLMUL_Pos) | (pllm << RCC_CR_PLLDIV_Pos);\n\n        //Enable PLL\n        RCC->CR |= RCC_CR_PLLON;\n\n        //Wait till PLL is ready\n        while(!(RCC->CR & RCC_CR_PLLRDY)){\n        }\n\n        //Select PLL as system clock source\n        RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));\n        RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;\n\n        //Wait till PLL is used as system clock source\n        while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08) {\n        }\n    }\n    else{\n        //If HSI fails to start-up, the application will have wrong clock\n        //configuration. User can add here some code to deal with this error\n    }\n}\n\n#elif defined SYSCLK_HSI_36MHz\nvoid SetSysClockTo36_HSI(void)\n{\n    __IO uint32_t StartUpCounter = 0, HSIStatus = 0;\n    int i;\n    unsigned char temp = 0;\n    uint8_t plln, pllm;\n\n    //Enable HSI\n    RCC->CR |= RCC_CR_HSION;\n\n    //Wait till HSI is ready and if Time out is reached exit\n    do {\n        HSIStatus = RCC->CR & RCC_CR_HSIRDY;\n        StartUpCounter++;\n    } while((HSIStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));\n\n    if ((RCC->CR & RCC_CR_HSIRDY) != RESET) {\n        HSIStatus = (uint32_t)0x01;\n        i = 2000; while(i--);\n    }\n    else {\n        HSIStatus = (uint32_t)0x00;\n    }\n\n    if (HSIStatus == (uint32_t)0x01) {\n        SystemCoreClock         = SYSCLK_HSI_36MHz;\n        //Enable Prefetch Buffer\n        FLASH->ACR |= FLASH_ACR_PRFTBE;\n        //Flash 0 wait state ,bit0~2\n        FLASH->ACR &= ~FLASH_ACR_LATENCY;\n\n        temp = (SystemCoreClock - 1) / 24000000;\n\n        FLASH->ACR |= temp;\n\n        //HCLK = SYSCLK\n        RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;\n\n        //PCLK2 = HCLK\n        RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;\n\n        if(SystemCoreClock > 36000000) {\n            //PCLK1 = HCLK/2\n            RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;\n        }\n        else {\n            //PCLK1 = HCLK\n            RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;\n        }\n\n        RCC->CFGR &= ~((uint32_t)(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE));\n        RCC->CR &= ~((uint32_t)(RCC_CR_PLLDIV | RCC_CR_PLLON | RCC_CR_PLLRDY | RCC_CR_PLLMUL));\n\n        AutoCalPllFactor(12000000, SystemCoreClock, &plln, &pllm);\n        RCC->CR &= ~((uint32_t)(RCC_CR_PLLDIV | RCC_CR_PLLON | RCC_CR_PLLRDY | RCC_CR_PLLMUL));\n        RCC->CR |= (plln << RCC_CR_PLLMUL_Pos) | (pllm << RCC_CR_PLLDIV_Pos);\n\n        //Enable PLL\n        RCC->CR |= RCC_CR_PLLON;\n\n        //Wait till PLL is ready\n        while(!(RCC->CR & RCC_CR_PLLRDY)){\n        }\n\n        //Select PLL as system clock source\n        RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));\n        RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;\n\n        //Wait till PLL is used as system clock source\n        while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08) {\n        }\n    }\n    else{\n        //If HSI fails to start-up, the application will have wrong clock\n        //configuration. User can add here some code to deal with this error\n    }\n}\n\n#elif defined SYSCLK_HSI_48MHz\nvoid SetSysClockTo48_HSI(void)\n{\n    __IO uint32_t StartUpCounter = 0, HSIStatus = 0;\n    int i;\n    unsigned char temp = 0;\n    uint8_t plln, pllm;\n\n    //Enable HSI\n    RCC->CR |= RCC_CR_HSION;\n\n    //Wait till HSI is ready and if Time out is reached exit\n    do {\n        HSIStatus = RCC->CR & RCC_CR_HSIRDY;\n        StartUpCounter++;\n    } while((HSIStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));\n\n    if ((RCC->CR & RCC_CR_HSIRDY) != RESET) {\n        HSIStatus = (uint32_t)0x01;\n        i = 2000; while(i--);\n    }\n    else {\n        HSIStatus = (uint32_t)0x00;\n    }\n\n    if (HSIStatus == (uint32_t)0x01) {\n        SystemCoreClock         = SYSCLK_HSI_48MHz;\n        //Enable Prefetch Buffer\n        FLASH->ACR |= FLASH_ACR_PRFTBE;\n        //Flash 0 wait state ,bit0~2\n        FLASH->ACR &= ~FLASH_ACR_LATENCY;\n\n        temp = (SystemCoreClock - 1) / 24000000;\n\n        FLASH->ACR |= temp;\n\n        //HCLK = SYSCLK\n        RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;\n\n        //PCLK2 = HCLK\n        RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;\n\n        if(SystemCoreClock > 36000000) {\n            //PCLK1 = HCLK/2\n            RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;\n        }\n        else {\n            //PCLK1 = HCLK\n            RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;\n        }\n\n        RCC->CFGR &= ~((uint32_t)(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE));\n        RCC->CR &= ~((uint32_t)(RCC_CR_PLLDIV | RCC_CR_PLLON | RCC_CR_PLLRDY | RCC_CR_PLLMUL));\n\n        AutoCalPllFactor(12000000, SystemCoreClock, &plln, &pllm);\n        RCC->CR &= ~((uint32_t)(RCC_CR_PLLDIV | RCC_CR_PLLON | RCC_CR_PLLRDY | RCC_CR_PLLMUL));\n        RCC->CR |= (plln << RCC_CR_PLLMUL_Pos) | (pllm << RCC_CR_PLLDIV_Pos);\n\n        //Enable PLL\n        RCC->CR |= RCC_CR_PLLON;\n\n        //Wait till PLL is ready\n        while(!(RCC->CR & RCC_CR_PLLRDY)){\n        }\n\n        //Select PLL as system clock source\n        RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));\n        RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;\n\n        //Wait till PLL is used as system clock source\n        while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08) {\n        }\n    }\n    else{\n        //If HSI fails to start-up, the application will have wrong clock\n        //configuration. User can add here some code to deal with this error\n    }\n}\n#elif defined SYSCLK_HSI_72MHz\nvoid SetSysClockTo72_HSI(void)\n{\n    __IO uint32_t StartUpCounter = 0, HSIStatus = 0;\n    int i;\n    uint32_t temp;\n    uint8_t plln, pllm;\n\n    //Enable HSI\n    RCC->CR |= RCC_CR_HSION;\n\n    //Wait till HSI is ready and if Time out is reached exit\n    do {\n        HSIStatus = RCC->CR & RCC_CR_HSIRDY;\n        StartUpCounter++;\n    } while((HSIStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));\n\n    if ((RCC->CR & RCC_CR_HSIRDY) != RESET) {\n        HSIStatus = (uint32_t)0x01;\n        i = 2000; while(i--);\n    }\n    else {\n        HSIStatus = (uint32_t)0x00;\n    }\n\n    if (HSIStatus == (uint32_t)0x01) {\n        SystemCoreClock         = SYSCLK_HSI_72MHz;\n        //Enable Prefetch Buffer\n        FLASH->ACR |= FLASH_ACR_PRFTBE;\n        //Flash 0 wait state ,bit0~2\n        FLASH->ACR &= ~FLASH_ACR_LATENCY;\n\n        temp = (SystemCoreClock - 1) / 24000000;\n\n        FLASH->ACR |= temp;\n\n        //HCLK = SYSCLK\n        RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;\n\n        //PCLK2 = HCLK\n        RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;\n\n        if(SystemCoreClock > 36000000) {\n            //PCLK1 = HCLK/2\n            RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;\n        }\n        else {\n            //PCLK1 = HCLK\n            RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;\n        }\n\n        RCC->CFGR &= ~((uint32_t)(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE));\n        RCC->CR &= ~((uint32_t)(RCC_CR_PLLDIV | RCC_CR_PLLON | RCC_CR_PLLRDY | RCC_CR_PLLMUL));\n\n        AutoCalPllFactor(12000000, SystemCoreClock, &plln, &pllm);\n        RCC->CR &= ~((uint32_t)(RCC_CR_PLLDIV | RCC_CR_PLLON | RCC_CR_PLLRDY | RCC_CR_PLLMUL));\n        RCC->CR |= (plln << RCC_CR_PLLMUL_Pos) | (pllm << RCC_CR_PLLDIV_Pos);\n\n        //Enable PLL\n        RCC->CR |= RCC_CR_PLLON;\n\n        //Wait till PLL is ready\n        while((RCC->CR & RCC_CR_PLLRDY) == 0) {\n        }\n\n        //Select PLL as system clock source\n        RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));\n        RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;\n\n        //Wait till PLL is used as system clock source\n        while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08) {\n        }\n    }\n    else{\n        //If HSI fails to start-up, the application will have wrong clock\n        //configuration. User can add here some code to deal with this error\n    }\n}\n\n#endif\n\n\n/// @}\n\n\n\n/// @}\n\n\n\n/// @}\n\n\n\n\n", "comment_ratio": 0.26198083067092653}
{"lang": "c", "code": "//\n//  NSObject+AutoAssignment.h\n//  Masonry\n//\n//  Created by \u738b\u6587\u7167 on 2020/7/23.\n//\n\n#import <Foundation/Foundation.h>\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface NSObject (AutoAssignment)\n\n@end\n\n@interface UIImageView (AutoAssignment)\n@property (nonatomic, strong) UIImage * placeHolderImage;\n- (void)wz_setImageWithUrl:(NSString *)url placeHolderImage:(UIImage *)image;\n@end\n\nNS_ASSUME_NONNULL_END\n\n", "comment_ratio": 0.2727272727272727}
{"lang": "c", "code": "#pragma once\n\n#include \"tensorflow/compiler/tf2xla/xla_tensor/reduction.h\"\n#include \"tensorflow/compiler/tf2xla/xla_tensor/tensor.h\"\n\n// Certain tensor operations can be expressed in terms of other tensor\n// operations. Add their implementations here instead of the main XLATensor\n// class.\n\nnamespace swift_xla {\nnamespace tensor_ops {\n\nXLATensor Cross(const XLATensor& input, const XLATensor& other,\n                c10::optional<xla::int64> dim);\n\nXLATensor KlDivBackward(const XLATensor& grad_output, const XLATensor& input,\n                        const XLATensor& target, ReductionMode reduction);\n\nXLATensor MakeMatrixWithDiagonal(const XLATensor& input, xla::int64 diagonal);\n\nXLATensor SmoothL1Loss(const XLATensor& input, const XLATensor& target,\n                       ReductionMode reduction);\n\nXLATensor SmoothL1LossBackward(const XLATensor& grad_output,\n                               const XLATensor& input, const XLATensor& target,\n                               ReductionMode reduction);\n\nXLATensor Softplus(const XLATensor& input, at::Scalar beta,\n                   at::Scalar threshold);\n\nXLATensor SoftplusBackward(const XLATensor& grad_output, const XLATensor& input,\n                           at::Scalar beta, at::Scalar threshold,\n                           const XLATensor& output);\n\nXLATensor Select(const XLATensor& input, xla::int64 dim, xla::int64 index);\n\nXLATensor EmbeddingDenseBackward(const XLATensor& grad_output,\n                                 const XLATensor& indices,\n                                 xla::int64 num_weights, xla::int64 padding_idx,\n                                 bool scale_grad_by_freq);\n\n}  // namespace tensor_ops\n}  // namespace swift_xla\n\n", "comment_ratio": 0.1}
{"lang": "c", "code": "#ifndef SERVICES_VIDEO_CAPTURE_FAKE_DEVICE_TEST_H_\n#define SERVICES_VIDEO_CAPTURE_FAKE_DEVICE_TEST_H_\n\n#include \"services/video_capture/fake_device_descriptor_test.h\"\n\nnamespace video_capture {\n\n// Test fixture that creates a proxy to the fake device provided by the fake\n// device factory.\nclass FakeDeviceTest : public FakeDeviceDescriptorTest {\n public:\n  FakeDeviceTest();\n  ~FakeDeviceTest() override;\n\n  void SetUp() override;\n\n protected:\n  mojom::VideoCaptureDeviceProxyPtr fake_device_proxy_;\n};\n\n}  // namespace video_capture\n\n#endif  // SERVICES_VIDEO_CAPTURE_FAKE_DEVICE_TEST_H_\n\n", "comment_ratio": 0.25}
{"lang": "c", "code": "#pragma once\n\nnamespace helgoboss {\n  // DONE-rust\n  // The most low-level type of a MIDI message\n  enum class MidiMessageType : unsigned char {\n    // Channel messages = channel voice messages + channel mode messages (given value represents channel 0 status byte)\n        NoteOff = 0x80,\n    NoteOn = 0x90,\n    PolyphonicKeyPressure = 0xa0,\n    ControlChange = 0xb0,\n    ProgramChange = 0xc0,\n    ChannelPressure = 0xd0,\n    PitchBendChange = 0xe0,\n    // System exclusive messages\n        SystemExclusiveStart = 0xf0,\n    // System common messages\n        MidiTimeCodeQuarterFrame = 0xf1,\n    SongPositionPointer = 0xf2,\n    SongSelect = 0xf3,\n    TuneRequest = 0xf6,\n    SystemExclusiveEnd = 0xf7,\n    // System real-time messages (given value represents the complete status byte)\n        TimingClock = 0xf8,\n    Start = 0xfa,\n    Continue = 0xfb,\n    Stop = 0xfc,\n    ActiveSensing = 0xfe,\n    SystemReset = 0xff\n  };\n\n  // A somewhat mid-level type of a MIDI message\n  enum class MidiMessageSuperType {\n    // In this enum we don't distinguish between channel voice and channel mode messages because this difference\n    // doesn't solely depend on the MidiMessageType (channel mode messages are just particular ControlChange messages).\n        Channel,\n    SystemCommon,\n    SystemRealTime,\n    SystemExclusive\n  };\n\n  // At the highest level MIDI messages are put into two categories\n  enum class MidiMessageMainCategory {\n    Channel,\n    System\n  };\n\n  namespace util {\n    MidiMessageSuperType getMidiMessageSuperType(MidiMessageType type);\n    MidiMessageMainCategory getMidiMessageMainCategory(MidiMessageSuperType superType);\n  }\n\n  class MidiMessage {\n  private:\n    // DONE-rust\n    unsigned char statusByte_ = 0;\n    unsigned char dataByte1_ = 0;\n    unsigned char dataByte2_ = 0;\n  public:\n    // DONE-rust\n    static constexpr MidiMessage empty() {\n      return MidiMessage();\n    }\n    static MidiMessage noteOn(int channel, int keyNumber, int velocity);\n    static MidiMessage noteOff(int channel, int keyNumber, int velocity);\n    static MidiMessage controlChange(int channel, int controllerNumber, int controlValue);\n    static MidiMessage programChange(int channel, int programNumber);\n    static MidiMessage polyphonicKeyPressure(int channel, int keyNumber, int pressureAmount);\n    static MidiMessage channelPressure(int channel, int pressureAmount);\n    static MidiMessage pitchBendChange(int channel, int pitchBendValue);\n    static MidiMessage timingClock();\n    static MidiMessage start();\n    static MidiMessage continueMessage();\n    static MidiMessage stop();\n    static MidiMessage activeSensing();\n    static MidiMessage systemReset();\n\n    constexpr MidiMessage() = default;\n    // DONE-rust\n    MidiMessage(unsigned char statusByte, unsigned char dataByte1, unsigned char dataByte2);\n    // DONE-rust\n    bool isEmpty() const;\n    // DONE-rust\n    unsigned char getStatusByte() const;\n    // DONE-rust\n    unsigned char getDataByte1() const;\n    // DONE-rust\n    unsigned char getDataByte2() const;\n    // DONE-rust\n    MidiMessageType getType() const;\n    MidiMessageSuperType getSuperType() const;\n    MidiMessageMainCategory getMainCategory() const;\n    int getChannel() const;\n    // Returns false if the message type is NoteOn but the velocity is 0\n    // DONE-rust\n    bool isNoteOn() const;\n    // Also returns true if the message type is NoteOn but the velocity is 0\n    bool isNoteOff() const;\n    bool isNote() const;\n    int getKeyNumber() const;\n    // DONE-rust\n    int getVelocity() const;\n    int getControllerNumber() const;\n    int getControlValue() const;\n    int getProgramNumber() const;\n    int getPressureAmount() const;\n    int getPitchBendValue() const;\n    friend bool operator==(const MidiMessage& lhs, const MidiMessage& rhs);\n    friend bool operator!=(const MidiMessage& lhs, const MidiMessage& rhs);\n  private:\n    static MidiMessage createChannelMessage(MidiMessageType type, int channel, int data1, int data2);\n    static MidiMessage createSystemRealTimeMessage(MidiMessageType type);\n  };\n}\n\n\n\n", "comment_ratio": 0.18803418803418803}
{"lang": "c", "code": "#ifndef SRC4_DYN_VERTEX_STRUCTS_H_\n#define SRC4_DYN_VERTEX_STRUCTS_H_\n\n#include \"defines.h\"\n#include \"../libmcell/api/shared_structs.h\"\n\nnamespace MCell {\n\n\nclass Partition;\n\nstruct WallMoveInfo {\n  bool wall_changes_area;\n  std::vector<VertexMoveInfo*> vertex_moves;\n};\n\ntypedef std::map<wall_index_t, WallMoveInfo> WallsWithTheirMovesMap;\n\nstruct VolumeMoleculeMoveInfo {\n  VolumeMoleculeMoveInfo(const molecule_id_t molecule_id_, const wall_index_t wall_index_, const bool place_above_)\n    : molecule_id(molecule_id_), wall_index(wall_index_), place_above(place_above_) {\n  }\n  // molecule to move\n  molecule_id_t molecule_id;\n  // which wall moved this molecule first\n  wall_index_t wall_index;\n  // above or below\n  bool place_above;\n};\ntypedef std::vector<VolumeMoleculeMoveInfo> VolumeMoleculeMoveInfoVector;\n\nstruct SurfaceMoleculeMoveInfo {\n  SurfaceMoleculeMoveInfo(const molecule_id_t molecule_id_, const wall_index_t wall_index_, const Vec3 pos3d_)\n    : molecule_id(molecule_id_), wall_index(wall_index_), pos3d(pos3d_) {\n  }\n  // molecule to move\n  molecule_id_t molecule_id;\n  // which wall moved this molecule first\n  wall_index_t wall_index;\n  // above or below\n  Vec3 pos3d;\n};\ntypedef std::vector<SurfaceMoleculeMoveInfo> SurfaceMoleculeMoveInfoVector;\n\n} // namespace MCell\n\n#endif /* SRC4_DYN_VERTEX_STRUCTS_H_ */\n\n", "comment_ratio": 0.13333333333333333}
{"lang": "c", "code": "\n#ifndef  _EOKAS_ARCHAISM_MAIN_H_\n#define  _EOKAS_ARCHAISM_MAIN_H_\n\n// Header\n#include \"header.h\"\n\n// Math\n#include \"math.h\"\n\n// Util\n#include \"ascil.h\"\n#include \"access.h\"\n#include \"memory.h\"\n#include \"color.h\"\n#include \"random.h\"\n#include \"time.h\"\n#include \"signal.h\"\n#include \"string.h\"\n#include \"stream.h\"\n#include \"table.h\"\n#include \"pool.h\"\n#include \"logger.h\"\n#include \"dataset.h\"\n#include \"pixels.h\"\n#include \"socket.h\"\n#include \"file.h\"\n#include \"args.h\"\n\n// Platform\n#include \"dll.h\"\n#include \"timer.h\"\n#include \"network.h\"\n\n#endif//_EOKAS_ARCHAISM_MAIN_H_\n\n", "comment_ratio": 0.1388888888888889}
{"lang": "c", "code": "#ifndef _5__Jump_Game_II_h\n#define _5__Jump_Game_II_h\n\nnamespace P45 {\n\nclass Solution {\npublic:\n    int jump(vector<int>& nums) {\n        if (nums.size() == 1) return 0;\n        int ret = 1, pos = 0, size = nums.size();\n        vector<int> nextPos(size, 0);\n        for (int i = 0; i < size; ++i) {\n            nextPos[i] = nums[i] + i;\n        }\n        while (nextPos[pos] < size - 1) {\n            int max = nextPos[pos], j = nextPos[pos];\n            for (int i = pos + 1; i <= nextPos[pos] && i < size; ++i) {\n                if (nextPos[i] > max) {\n                    max = nextPos[i];\n                    j = i;\n                }\n            }\n            pos = j;\n            ++ret;\n        }\n        return ret;\n    }\n};\n\n\n}\n#endif /* _5__Jump_Game_II_h */\n\n", "comment_ratio": 0.17073170731707318}
{"lang": "c", "code": "#ifndef _INTRALASTRUNLEVELH263VLCDECODER_H\r\n#define _INTRALASTRUNLEVELH263VLCDECODER_H\r\n\r\n#include \"IVlcDecoder.h\"\r\n#include \"LastRunLevelTypeStruct.h\"\r\n\r\n/*\r\n---------------------------------------------------------------------------\r\n\tClass constants.\r\n---------------------------------------------------------------------------\r\n*/\r\n#define ILRLH263VD_TABLE_LENGTH 103\r\n\r\n/*\r\n---------------------------------------------------------------------------\r\n\tClass definition.\r\n---------------------------------------------------------------------------\r\n*/\r\nclass IntraLastRunLevelH263VlcDecoder : public IVlcDecoder\r\n{\r\npublic:\r\n\tIntraLastRunLevelH263VlcDecoder();\r\n\tvirtual ~IntraLastRunLevelH263VlcDecoder();\r\n\r\npublic:\r\n\t// Interface implementation.\r\n\tint GetNumDecodedBits(void)\t{ return(_numCodeBits); }\r\n\tint Marker(void)\t\t\t\t\t\t{ return(0); }\t// No markers for this decoder.\r\n\t// Single symbols are not relevant for a last-run-level decoder.\r\n\tvirtual int Decode(IBitStreamReader* bsr) { _numCodeBits = 0; return(0); } \r\n\r\n\t// Optional interface implementation.\r\n\tvirtual int\tDecode3(IBitStreamReader* bsr, int* symbol1, int* symbol2, int* symbol3);\r\n\r\nprotected:\r\n\tint _numCodeBits;\t// Number of coded bits for this symbol.\r\n\r\n\tstatic const LastRunLevelType VLC_TABLE[ILRLH263VD_TABLE_LENGTH];\r\n\r\n};// end class IntraLastRunLevelH263VlcDecoder.\r\n\r\n#endif\t// _INTRALASTRUNLEVELH263VLCDECODER_H\r\n\n", "comment_ratio": 0.1076923076923077}
{"lang": "c", "code": "#ifndef __vtkDataObjectWriter_h\n#define __vtkDataObjectWriter_h\n\n#include \"vtkWriter.h\"\n#include \"vtkDataWriter.h\" // Needs data because it calls methods on it\n#include \"vtkStdString.h\" // For string used in api\n\nclass VTK_IO_EXPORT vtkDataObjectWriter : public vtkWriter\n{\npublic:\n  static vtkDataObjectWriter *New();\n  vtkTypeMacro(vtkDataObjectWriter,vtkWriter);\n  void PrintSelf(ostream& os, vtkIndent indent);\n\n  // Description:\n  // Methods delegated to vtkDataWriter, see vtkDataWriter.\n  void SetFileName(const char *filename) {this->Writer->SetFileName(filename);};\n  char *GetFileName() {return this->Writer->GetFileName();};\n  void SetHeader(const char *header) {this->Writer->SetHeader(header);};\n  char *GetHeader() {return this->Writer->GetHeader();};\n  void SetFileType(int type) {this->Writer->SetFileType(type);};\n  int GetFileType() {return this->Writer->GetFileType();};\n  void SetFileTypeToASCII() {this->Writer->SetFileType(VTK_ASCII);};\n  void SetFileTypeToBinary() {this->Writer->SetFileType(VTK_BINARY);};\n  void SetWriteToOutputString(int b) {this->Writer->SetWriteToOutputString(b);};\n  void WriteToOutputStringOn() {this->Writer->WriteToOutputStringOn();};\n  void WriteToOutputStringOff() {this->Writer->WriteToOutputStringOff();};\n  int GetWriteToOutputString() {return this->Writer->GetWriteToOutputString();};\n  char* GetOutputString() {return this->Writer->GetOutputString();};\n  vtkStdString GetOutputStdString() {return this->Writer->GetOutputStdString();};\n  int GetOutputStringLength() {return this->Writer->GetOutputStringLength();};\n  unsigned char* GetBinaryOutputString() {return this->Writer->GetBinaryOutputString();};\n  void SetFieldDataName(const char *fieldname) {this->Writer->SetFieldDataName(fieldname);};\n  char *GetFieldDataName() {return this->Writer->GetFieldDataName();};\n\nprotected:\n  vtkDataObjectWriter();\n  ~vtkDataObjectWriter();\n\n  void WriteData();\n  vtkDataWriter *Writer;\n\n  virtual int FillInputPortInformation(int port, vtkInformation *info);\n\nprivate:\n  vtkDataObjectWriter(const vtkDataObjectWriter&);  // Not implemented.\n  void operator=(const vtkDataObjectWriter&);  // Not implemented.\n};\n\n#endif\n\n", "comment_ratio": 0.2077922077922078}
{"lang": "c", "code": "#import <SilexWeb/SilexWeb-Structs.h>\n#import <libobjc.A.dylib/NSMutableCopying.h>\n\n@class NSString, NSLocale, NSDictionary, NSURL;\n\n@interface SWConfiguration : NSObject <NSMutableCopying> {\n\n\tNSString* _identifier;\n\tNSString* _storeFront;\n\tNSLocale* _locale;\n\tNSString* _contentSizeCategory;\n\tNSDictionary* _dataSources;\n\tNSURL* _location;\n\tCGSize _canvasSize;\n\tCGRect _contentFrame;\n\n}\n\n@property (nonatomic,copy) NSString * identifier;                       //@synthesize identifier=_identifier - In the implementation block\n@property (nonatomic,copy) NSString * storeFront;                       //@synthesize storeFront=_storeFront - In the implementation block\n@property (nonatomic,copy) NSLocale * locale;                           //@synthesize locale=_locale - In the implementation block\n@property (nonatomic,copy) NSString * contentSizeCategory;              //@synthesize contentSizeCategory=_contentSizeCategory - In the implementation block\n@property (assign,nonatomic) CGSize canvasSize;                         //@synthesize canvasSize=_canvasSize - In the implementation block\n@property (assign,nonatomic) CGRect contentFrame;                       //@synthesize contentFrame=_contentFrame - In the implementation block\n@property (nonatomic,copy) NSDictionary * dataSources;                  //@synthesize dataSources=_dataSources - In the implementation block\n@property (nonatomic,copy) NSURL * location;                            //@synthesize location=_location - In the implementation block\n-(id)copyWithZone:(NSZone*)arg1 ;\n-(id)mutableCopyWithZone:(NSZone*)arg1 ;\n-(void)setLocale:(NSLocale *)arg1 ;\n-(NSLocale *)locale;\n-(NSString *)identifier;\n-(void)setIdentifier:(NSString *)arg1 ;\n-(NSString *)storeFront;\n-(NSURL *)location;\n-(CGRect)contentFrame;\n-(NSDictionary *)dataSources;\n-(void)setLocation:(NSURL *)arg1 ;\n-(void)setContentSizeCategory:(NSString *)arg1 ;\n-(NSString *)contentSizeCategory;\n-(void)setContentFrame:(CGRect)arg1 ;\n-(BOOL)isEqualToConfiguration:(id)arg1 ;\n-(CGSize)canvasSize;\n-(void)setCanvasSize:(CGSize)arg1 ;\n-(void)setDataSources:(NSDictionary *)arg1 ;\n-(void)setStoreFront:(NSString *)arg1 ;\n-(id)initWithStoreFront:(id)arg1 locale:(id)arg2 contentSizeCategory:(id)arg3 canvasSize:(CGSize)arg4 contentFrame:(CGRect)arg5 dataSources:(id)arg6 location:(id)arg7 ;\n@end\n\n\n", "comment_ratio": 0.14035087719298245}
{"lang": "c", "code": "#include \"BaseUefiDecompressLibInternals.h\"\r\n\r\n/**\r\n  Read NumOfBit of bits from source into mBitBuf\r\n\r\n  Shift mBitBuf NumOfBits left. Read in NumOfBits of bits from source.\r\n\r\n  @param  Sd        The global scratch data\r\n  @param  NumOfBits The number of bits to shift and read.\r\n\r\n**/\r\nVOID\r\nGlueFillBuf (\r\n  IN  SCRATCH_DATA  *Sd,\r\n  IN  UINT16        NumOfBits\r\n  )\r\n{\r\n  //\r\n  // Left shift NumOfBits of bits in advance\r\n  //\r\n  Sd->mBitBuf = (UINT32) (Sd->mBitBuf << NumOfBits);\r\n\r\n  //\r\n  // Copy data needed in bytes into mSbuBitBuf\r\n  //\r\n  while (NumOfBits > Sd->mBitCount) {\r\n\r\n    Sd->mBitBuf |= (UINT32) (Sd->mSubBitBuf << (NumOfBits = (UINT16) (NumOfBits - Sd->mBitCount)));\r\n\r\n    if (Sd->mCompSize > 0) {\r\n      //\r\n      // Get 1 byte into SubBitBuf\r\n      //\r\n      Sd->mCompSize--;\r\n      Sd->mSubBitBuf  = Sd->mSrcBase[Sd->mInBuf++];\r\n      Sd->mBitCount   = 8;\r\n\r\n    } else {\r\n      //\r\n      // No more bits from the source, just pad zero bit.\r\n      //\r\n      Sd->mSubBitBuf  = 0;\r\n      Sd->mBitCount   = 8;\r\n\r\n    }\r\n  }\r\n\r\n  //\r\n  // Caculate additional bit count read to update mBitCount\r\n  //\r\n  Sd->mBitCount = (UINT16) (Sd->mBitCount - NumOfBits);\r\n  \r\n  //\r\n  // Copy NumOfBits of bits from mSubBitBuf into mBitBuf\r\n  //\r\n  Sd->mBitBuf |= Sd->mSubBitBuf >> Sd->mBitCount;\r\n}\r\n\r\n/**\r\n  Get NumOfBits of bits out from mBitBuf\r\n\r\n  Get NumOfBits of bits out from mBitBuf. Fill mBitBuf with subsequent \r\n  NumOfBits of bits from source. Returns NumOfBits of bits that are \r\n  popped out.\r\n\r\n  @param  Sd        The global scratch data.\r\n  @param  NumOfBits The number of bits to pop and read.\r\n\r\n  @return The bits that are popped out.\r\n\r\n**/\r\nUINT32\r\nGlueGetBits (\r\n  IN  SCRATCH_DATA  *Sd,\r\n  IN  UINT16        NumOfBits\r\n  )\r\n{\r\n  UINT32  OutBits;\r\n\r\n  //\r\n  // Pop NumOfBits of Bits from Left\r\n  //  \r\n  OutBits = (UINT32) (Sd->mBitBuf >> (BITBUFSIZ - NumOfBits));\r\n\r\n  //\r\n  // Fill up mBitBuf from source\r\n  //\r\n  FillBuf (Sd, NumOfBits);\r\n\r\n  return OutBits;\r\n}\r\n\r\n/**\r\n  Creates Huffman Code mapping table according to code length array.\r\n\r\n  Creates Huffman Code mapping table for Extra Set, Char&Len Set \r\n  and Position Set according to code length array.\r\n\r\n  @param  Sd        The global scratch data\r\n  @param  NumOfChar Number of symbols in the symbol set\r\n  @param  BitLen    Code length array\r\n  @param  TableBits The width of the mapping table\r\n  @param  Table     The table\r\n\r\n  @retval  0 OK.\r\n  @retval  BAD_TABLE The table is corrupted.\r\n\r\n**/\r\nUINT16\r\nGlueMakeTable (\r\n  IN  SCRATCH_DATA  *Sd,\r\n  IN  UINT16        NumOfChar,\r\n  IN  UINT8         *BitLen,\r\n  IN  UINT16        TableBits,\r\n  OUT UINT16        *Table\r\n  )\r\n{\r\n  UINT16  Count[17];\r\n  UINT16  Weight[17];\r\n  UINT16  Start[18];\r\n  UINT16  *Pointer;\r\n  UINT16  Index3;\r\n  UINT16  Index;\r\n  UINT16  Len;\r\n  UINT16  Char;\r\n  UINT16  JuBits;\r\n  UINT16  Avail;\r\n  UINT16  NextCode;\r\n  UINT16  Mask;\r\n  UINT16  WordOfStart;\r\n  UINT16  WordOfCount;\r\n\r\n  //\r\n  // TableBits should not be greater than 16.\r\n  //\r\n  if (TableBits >= (sizeof (Count)/sizeof (UINT16))) {\r\n    return (UINT16) BAD_TABLE;\r\n  }\r\n \r\n  //\r\n  // Initialize Count array starting from Index 0, as there is a possibility of Count array being uninitialized.\r\n  //\r\n  for (Index = 0; Index <= 16; Index++) {\r\n    Count[Index] = 0;\r\n  }\r\n\r\n  for (Index = 0; Index < NumOfChar; Index++) {\r\n    //\r\n    // Count array index should not be greater than or equal to its size.\r\n    //\r\n    if (BitLen[Index] < (sizeof (Count)/sizeof (UINT16))) {\r\n      Count[BitLen[Index]]++;\r\n    } else {\r\n      return (UINT16) BAD_TABLE;\r\n    }\r\n  }\r\n\r\n  Start[0] = 0;\r\n  Start[1] = 0;\r\n\r\n  for (Index = 1; Index <= 16; Index++) {\r\n    WordOfStart = Start[Index];\r\n    WordOfCount = Count[Index];\r\n    Start[Index + 1] = (UINT16) (WordOfStart + (WordOfCount << (16 - Index)));\r\n  }\r\n\r\n  if (Start[17] != 0) {\r\n    /*(1U << 16)*/\r\n    return (UINT16) BAD_TABLE;\r\n  }\r\n\r\n  JuBits = (UINT16) (16 - TableBits);\r\n\r\n  for (Index = 1; Index <= TableBits; Index++) {\r\n    Start[Index] >>= JuBits;\r\n    Weight[Index] = (UINT16) (1U << (TableBits - Index));\r\n  }\r\n\r\n  while (Index <= 16) {\r\n    Weight[Index] = (UINT16) (1U << (16 - Index));\r\n    Index++;    \r\n  }\r\n\r\n  Index = (UINT16) (Start[TableBits + 1] >> JuBits);\r\n\r\n  if (Index != 0) {\r\n    Index3 = (UINT16) (1U << TableBits);\r\n    while (Index != Index3) {\r\n      Table[Index++] = 0;\r\n    }\r\n  }\r\n\r\n  Avail = NumOfChar;\r\n  Mask  = (UINT16) (1U << (15 - TableBits));\r\n\r\n  for (Char = 0; Char < NumOfChar; Char++) {\r\n\r\n    Len = BitLen[Char];\r\n    if (Len == 0 || Len >= 17) {\r\n      continue;\r\n    }\r\n\r\n    NextCode = (UINT16) (Start[Len] + Weight[Len]);\r\n\r\n    if (Len <= TableBits) {\r\n\r\n      for (Index = Start[Len]; Index < NextCode; Index++) {\r\n        Table[Index] = Char;\r\n      }\r\n\r\n    } else {\r\n\r\n      Index3  = Start[Len];\r\n      Pointer = &Table[Index3 >> JuBits];\r\n      Index   = (UINT16) (Len - TableBits);\r\n\r\n      while (Index != 0) {\r\n        //\r\n        // Avail should be lesser than size of mRight and mLeft to prevent buffer overflow.\r\n        //\r\n        if ((*Pointer == 0) && (Avail < sizeof (Sd->mRight)/sizeof (UINT16)) && (Avail < sizeof (Sd->mLeft)/sizeof (UINT16))) {\r\n          Sd->mRight[Avail]                     = Sd->mLeft[Avail] = 0;\r\n          *Pointer = Avail++;\r\n        }\r\n\r\n        //\r\n        // *Pointer should be lesser than size of mRight and mLeft to prevent buffer overflow.\r\n        //\r\n        if ((Index3 & Mask) && (*Pointer < (sizeof (Sd->mRight)/sizeof (UINT16)))) {\r\n          Pointer = &Sd->mRight[*Pointer];\r\n        } else if (*Pointer < (sizeof (Sd->mLeft)/sizeof (UINT16))) {\r\n          Pointer = &Sd->mLeft[*Pointer];\r\n        }\r\n\r\n        Index3 <<= 1;\r\n        Index--;\r\n      }\r\n\r\n      *Pointer = Char;\r\n\r\n    }\r\n\r\n    Start[Len] = NextCode;\r\n  }\r\n  //\r\n  // Succeeds\r\n  //\r\n  return 0;\r\n}\r\n\r\n/**\r\n  Decodes a position value.\r\n\r\n  Get a position value according to Position Huffman Table.\r\n  \r\n  @param  Sd the global scratch data\r\n\r\n  @return The position value decoded.\r\n\r\n**/\r\nUINT32\r\nGlueDecodeP (\r\n  IN  SCRATCH_DATA  *Sd\r\n  )\r\n{\r\n  UINT16  Val;\r\n  UINT32  Mask;\r\n  UINT32  Pos;\r\n\r\n  Val = Sd->mPTTable[Sd->mBitBuf >> (BITBUFSIZ - 8)];\r\n\r\n  if (Val >= MAXNP) {\r\n    Mask = 1U << (BITBUFSIZ - 1 - 8);\r\n\r\n    do {\r\n\r\n      if (Sd->mBitBuf & Mask) {\r\n        Val = Sd->mRight[Val];\r\n      } else {\r\n        Val = Sd->mLeft[Val];\r\n      }\r\n\r\n      Mask >>= 1;\r\n    } while (Val >= MAXNP);\r\n  }\r\n  //\r\n  // Advance what we have read\r\n  //\r\n  FillBuf (Sd, Sd->mPTLen[Val]);\r\n\r\n  Pos = Val;\r\n  if (Val > 1) {\r\n    Pos = (UINT32) ((1U << (Val - 1)) + GetBits (Sd, (UINT16) (Val - 1)));\r\n  }\r\n\r\n  return Pos;\r\n}\r\n\r\n/**\r\n  Reads code lengths for the Extra Set or the Position Set.\r\n\r\n  Read in the Extra Set or Position Set Length Array, then\r\n  generate the Huffman code mapping for them.\r\n\r\n  @param  Sd      The global scratch data.\r\n  @param  nn      Number of symbols.\r\n  @param  nbit    Number of bits needed to represent nn.\r\n  @param  Special The special symbol that needs to be taken care of.\r\n\r\n  @retval  0 OK.\r\n  @retval  BAD_TABLE Table is corrupted.\r\n\r\n**/\r\nUINT16\r\nGlueReadPTLen (\r\n  IN  SCRATCH_DATA  *Sd,\r\n  IN  UINT16        nn,\r\n  IN  UINT16        nbit,\r\n  IN  UINT16        Special\r\n  )\r\n{\r\n  UINT16  Number;\r\n  UINT16  CharC;\r\n  volatile UINT16  Index;\r\n  UINT32  Mask;\r\n\r\n  //\r\n  // Read Extra Set Code Length Array size \r\n  //\r\n  Number = (UINT16) GetBits (Sd, nbit);\r\n\r\n  if ((Number > sizeof (Sd->mPTLen)) || (nn > sizeof (Sd->mPTLen))) {\r\n    //\r\n    // Fail if Number or nn is greater than size of mPTLen\r\n    //\r\n    return (UINT16) BAD_TABLE;\r\n  }\r\n\r\n  if (Number == 0) {\r\n    //\r\n    // This represents only Huffman code used\r\n    //\r\n    CharC = (UINT16) GetBits (Sd, nbit);\r\n\r\n    for (Index = 0; Index < 256; Index++) {\r\n      Sd->mPTTable[Index] = CharC;\r\n    }\r\n\r\n    for (Index = 0; Index < nn; Index++) {\r\n      Sd->mPTLen[Index] = 0;\r\n    }\r\n\r\n    return 0;\r\n  }\r\n\r\n  Index = 0;\r\n\r\n  while (Index < Number) {\r\n\r\n    CharC = (UINT16) (Sd->mBitBuf >> (BITBUFSIZ - 3));\r\n\r\n    //\r\n    // If a code length is less than 7, then it is encoded as a 3-bit\r\n    // value. Or it is encoded as a series of \"1\"s followed by a \r\n    // terminating \"0\". The number of \"1\"s = Code length - 4.\r\n    //\r\n    if (CharC == 7) {\r\n      Mask = 1U << (BITBUFSIZ - 1 - 3);\r\n      while (Mask & Sd->mBitBuf) {\r\n        Mask >>= 1;\r\n        CharC += 1;\r\n      }\r\n    }\r\n    \r\n    FillBuf (Sd, (UINT16) ((CharC < 7) ? 3 : CharC - 3));\r\n\r\n    Sd->mPTLen[Index++] = (UINT8) CharC;\r\n \r\n    //\r\n    // For Code&Len Set, \r\n    // After the third length of the code length concatenation,\r\n    // a 2-bit value is used to indicated the number of consecutive \r\n    // zero lengths after the third length.\r\n    //\r\n    if (Index == Special) {\r\n      CharC = (UINT16) GetBits (Sd, 2);\r\n      while ((INT16) (--CharC) >= 0) {\r\n         if (Index >= sizeof (Sd->mPTLen)) {\r\n          //\r\n          // Fail if Index is greater than or equal to mPTLen\r\n          //\r\n          return (UINT16) BAD_TABLE;\r\n        }\r\n        Sd->mPTLen[Index++] = 0;\r\n      }\r\n    }\r\n  }\r\n\r\n  while (Index < nn) {\r\n    Sd->mPTLen[Index++] = 0;\r\n  }\r\n  \r\n  return MakeTable (Sd, nn, Sd->mPTLen, 8, Sd->mPTTable);\r\n}\r\n\r\n/**\r\n  Reads code lengths for Char&Len Set.\r\n  \r\n  Read in and decode the Char&Len Set Code Length Array, then\r\n  generate the Huffman Code mapping table for the Char&Len Set.\r\n\r\n  @param  Sd the global scratch data\r\n\r\n**/\r\nVOID\r\nGlueReadCLen (\r\n  SCRATCH_DATA  *Sd\r\n  )\r\n{\r\n  UINT16           Number;\r\n  UINT16           CharC;\r\n  volatile UINT16  Index;\r\n  UINT32           Mask;\r\n\r\n  Number = (UINT16) GetBits (Sd, CBIT);\r\n\r\n  if (Number == 0) {\r\n    //\r\n    // This represents only Huffman code used\r\n    //\r\n    CharC = (UINT16) GetBits (Sd, CBIT);\r\n\r\n    for (Index = 0; Index < NC; Index++) {\r\n      Sd->mCLen[Index] = 0;\r\n    }\r\n\r\n    for (Index = 0; Index < 4096; Index++) {\r\n      Sd->mCTable[Index] = CharC;\r\n    }\r\n\r\n    return ;\r\n  }\r\n\r\n  Index = 0;\r\n  while (Index < Number) {\r\n    CharC = Sd->mPTTable[Sd->mBitBuf >> (BITBUFSIZ - 8)];\r\n    if (CharC >= NT) {\r\n      Mask = 1U << (BITBUFSIZ - 1 - 8);\r\n\r\n      do {\r\n\r\n        if (Mask & Sd->mBitBuf) {\r\n          CharC = Sd->mRight[CharC];\r\n        } else {\r\n          CharC = Sd->mLeft[CharC];\r\n        }\r\n\r\n        Mask >>= 1;\r\n\r\n      } while (CharC >= NT);\r\n    }\r\n    //\r\n    // Advance what we have read\r\n    //\r\n    FillBuf (Sd, Sd->mPTLen[CharC]);\r\n\r\n    if (CharC <= 2) {\r\n\r\n      if (CharC == 0) {\r\n        CharC = 1;\r\n      } else if (CharC == 1) {\r\n        CharC = (UINT16) (GetBits (Sd, 4) + 3);\r\n      } else if (CharC == 2) {\r\n        CharC = (UINT16) (GetBits (Sd, CBIT) + 20);\r\n      }\r\n\r\n      while ((INT16) (--CharC) >= 0) {\r\n        Sd->mCLen[Index++] = 0;\r\n      }\r\n\r\n    } else {\r\n\r\n      Sd->mCLen[Index++] = (UINT8) (CharC - 2);\r\n\r\n    }\r\n  }\r\n\r\n  while (Index < NC) {\r\n    Sd->mCLen[Index++] = 0;\r\n  }\r\n\r\n  MakeTable (Sd, NC, Sd->mCLen, 12, Sd->mCTable);\r\n\r\n  return ;\r\n}\r\n\r\n/**\r\n  Decode a character/length value.\r\n  \r\n  Read one value from mBitBuf, Get one code from mBitBuf. If it is at block boundary, generates\r\n  Huffman code mapping table for Extra Set, Code&Len Set and\r\n  Position Set.\r\n\r\n  @param  Sd The global scratch data.\r\n\r\n  @return The value decoded.\r\n\r\n**/\r\nUINT16\r\nGlueDecodeC (\r\n  SCRATCH_DATA  *Sd\r\n  )\r\n{\r\n  UINT16  Index2;\r\n  UINT32  Mask;\r\n\r\n  if (Sd->mBlockSize == 0) {\r\n    //\r\n    // Starting a new block\r\n    // Read BlockSize from block header\r\n    // \r\n    Sd->mBlockSize    = (UINT16) GetBits (Sd, 16);\r\n\r\n    //\r\n    // Read in the Extra Set Code Length Array,\r\n    // Generate the Huffman code mapping table for Extra Set.\r\n    //\r\n    Sd->mBadTableFlag = ReadPTLen (Sd, NT, TBIT, 3);\r\n    if (Sd->mBadTableFlag != 0) {\r\n      return 0;\r\n    }\r\n\r\n    //\r\n    // Read in and decode the Char&Len Set Code Length Array,\r\n    // Generate the Huffman code mapping table for Char&Len Set.\r\n    //\r\n    ReadCLen (Sd);\r\n\r\n    //\r\n    // Read in the Position Set Code Length Array,\r\n    // Generate the Huffman code mapping table for the Position Set.\r\n    //\r\n    Sd->mBadTableFlag = ReadPTLen (Sd, MAXNP, Sd->mPBit, (UINT16) (-1));\r\n    if (Sd->mBadTableFlag != 0) {\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  //\r\n  // Get one code according to Code&Set Huffman Table\r\n  //\r\n  Sd->mBlockSize--;\r\n  Index2 = Sd->mCTable[Sd->mBitBuf >> (BITBUFSIZ - 12)];\r\n\r\n  if (Index2 >= NC) {\r\n    Mask = 1U << (BITBUFSIZ - 1 - 12);\r\n\r\n    do {\r\n      if (Sd->mBitBuf & Mask) {\r\n        Index2 = Sd->mRight[Index2];\r\n      } else {\r\n        Index2 = Sd->mLeft[Index2];\r\n      }\r\n\r\n      Mask >>= 1;\r\n    } while (Index2 >= NC);\r\n  }\r\n  //\r\n  // Advance what we have read\r\n  //\r\n  FillBuf (Sd, Sd->mCLen[Index2]);\r\n\r\n  return Index2;\r\n}\r\n\r\n/**\r\n  Decode the source data and put the resulting data into the destination buffer.\r\n\r\n  Decode the source data and put the resulting data into the destination buffer.\r\n  \r\n  @param  Sd The global scratch data\r\n\r\n**/\r\nVOID\r\nGlueDecode (\r\n  SCRATCH_DATA  *Sd\r\n  )\r\n{\r\n  UINT16  BytesRemain;\r\n  UINT32  DataIdx;\r\n  UINT16  CharC;\r\n\r\n  BytesRemain = (UINT16) (-1);\r\n\r\n  DataIdx     = 0;\r\n\r\n  for (;;) {\r\n    //\r\n    // Get one code from mBitBuf\r\n    // \r\n    CharC = DecodeC (Sd);\r\n    if (Sd->mBadTableFlag != 0) {\r\n      goto Done;\r\n    }\r\n\r\n    if (CharC < 256) {\r\n      //\r\n      // Process an Original character\r\n      //\r\n      if (Sd->mOutBuf >= Sd->mOrigSize) {\r\n        goto Done;\r\n      } else {\r\n        //\r\n        // Write orignal character into mDstBase\r\n        //\r\n        Sd->mDstBase[Sd->mOutBuf++] = (UINT8) CharC;\r\n      }\r\n\r\n    } else {\r\n      //\r\n      // Process a Pointer\r\n      //\r\n      CharC       = (UINT16) (CharC - (UINT8_MAX + 1 - THRESHOLD));\r\n \r\n      //\r\n      // Get string length\r\n      //\r\n      BytesRemain = CharC;\r\n\r\n      //\r\n      // Locate string position\r\n      //\r\n      DataIdx     = Sd->mOutBuf - DecodeP (Sd) - 1;\r\n\r\n      //\r\n      // Write BytesRemain of bytes into mDstBase\r\n      //\r\n      BytesRemain--;\r\n      while ((INT16) (BytesRemain) >= 0) {\r\n        Sd->mDstBase[Sd->mOutBuf++] = Sd->mDstBase[DataIdx++];\r\n        if (Sd->mOutBuf >= Sd->mOrigSize) {\r\n          goto Done;\r\n        }\r\n\r\n        BytesRemain--;\r\n      }\r\n    }\r\n  }\r\n\r\nDone:\r\n  return ;\r\n}\r\n\r\n/**\r\n  Retrieves the size of the uncompressed buffer and the size of the scratch buffer.\r\n\r\n  Retrieves the size of the uncompressed buffer and the temporary scratch buffer \r\n  required to decompress the buffer specified by Source and SourceSize.\r\n  If the size of the uncompressed buffer or the size of the scratch buffer cannot\r\n  be determined from the compressed data specified by Source and SourceData, \r\n  then RETURN_INVALID_PARAMETER is returned.  Otherwise, the size of the uncompressed\r\n  buffer is returned in DestinationSize, the size of the scratch buffer is returned\r\n  in ScratchSize, and RETURN_SUCCESS is returned.\r\n  This function does not have scratch buffer available to perform a thorough \r\n  checking of the validity of the source data.  It just retrieves the \"Original Size\"\r\n  field from the beginning bytes of the source data and output it as DestinationSize.\r\n  And ScratchSize is specific to the decompression implementation.\r\n\r\n  If Source is NULL, then ASSERT().\r\n  If DestinationSize is NULL, then ASSERT().\r\n  If ScratchSize is NULL, then ASSERT().\r\n\r\n  @param  Source          The source buffer containing the compressed data.\r\n  @param  SourceSize      The size, in bytes, of the source buffer.\r\n  @param  DestinationSize A pointer to the size, in bytes, of the uncompressed buffer\r\n                          that will be generated when the compressed buffer specified\r\n                          by Source and SourceSize is decompressed..\r\n  @param  ScratchSize     A pointer to the size, in bytes, of the scratch buffer that\r\n                          is required to decompress the compressed buffer specified \r\n                          by Source and SourceSize.\r\n\r\n  @retval  RETURN_SUCCESS The size of destination buffer and the size of scratch \r\n                          buffer are successfully retrieved.\r\n  @retval  RETURN_INVALID_PARAMETER The source data is corrupted\r\n\r\n**/\r\nRETURN_STATUS\r\nEFIAPI\r\nUefiDecompressGetInfo (\r\n  IN  CONST VOID  *Source,\r\n  IN  UINT32      SourceSize,\r\n  OUT UINT32      *DestinationSize,\r\n  OUT UINT32      *ScratchSize\r\n  )\r\n{\r\n  UINT32  CompressedSize;\r\n\r\n  ASSERT (Source != NULL);\r\n  ASSERT (DestinationSize != NULL);\r\n  ASSERT (ScratchSize != NULL);\r\n\r\n  *ScratchSize  = sizeof (SCRATCH_DATA);\r\n\r\n  if (SourceSize < 8) {\r\n    return RETURN_INVALID_PARAMETER;\r\n  }\r\n\r\n  CopyMem (&CompressedSize, Source, sizeof (UINT32));\r\n  CopyMem (DestinationSize, (VOID *)((UINT8 *)Source + 4), sizeof (UINT32));\r\n\r\n  if (SourceSize < (CompressedSize + 8)) {\r\n    return RETURN_INVALID_PARAMETER;\r\n  }\r\n\r\n  return RETURN_SUCCESS;\r\n}\r\n\r\n/**\r\n  Decompresses a compressed source buffer.\r\n\r\n  This function is designed so that the decompression algorithm can be implemented\r\n  without using any memory services.  As a result, this function is not allowed to\r\n  call any memory allocation services in its implementation.  It is the caller's r\r\n  esponsibility to allocate and free the Destination and Scratch buffers.\r\n  If the compressed source data specified by Source is sucessfully decompressed \r\n  into Destination, then RETURN_SUCCESS is returned.  If the compressed source data \r\n  specified by Source is not in a valid compressed data format,\r\n  then RETURN_INVALID_PARAMETER is returned.\r\n\r\n  If Source is NULL, then ASSERT().\r\n  If Destination is NULL, then ASSERT().\r\n  If the required scratch buffer size > 0 and Scratch is NULL, then ASSERT().\r\n\r\n  @param  Source      The source buffer containing the compressed data.\r\n  @param  Destination The destination buffer to store the decompressed data\r\n  @param  Scratch     A temporary scratch buffer that is used to perform the decompression.\r\n                      This is an optional parameter that may be NULL if the \r\n                      required scratch buffer size is 0.\r\n                     \r\n  @retval  RETURN_SUCCESS Decompression is successfull\r\n  @retval  RETURN_INVALID_PARAMETER The source data is corrupted\r\n\r\n**/\r\nRETURN_STATUS\r\nEFIAPI\r\nUefiDecompress (\r\n  IN CONST VOID  *Source,\r\n  IN OUT VOID    *Destination,\r\n  IN OUT VOID    *Scratch\r\n  )\r\n{\r\n  volatile UINT32  Index;\r\n  UINT32           CompSize;\r\n  UINT32           OrigSize;\r\n  SCRATCH_DATA     *Sd;\r\n  CONST UINT8      *Src;\r\n  UINT8            *Dst;\r\n\r\n  ASSERT (Source != NULL);\r\n  ASSERT (Destination != NULL);\r\n  ASSERT (Scratch != NULL);\r\n\r\n  Src     = Source;\r\n  Dst     = Destination;\r\n\r\n  Sd = (SCRATCH_DATA *) Scratch;\r\n\r\n  CompSize  = Src[0] + (Src[1] << 8) + (Src[2] << 16) + (Src[3] << 24);\r\n  OrigSize  = Src[4] + (Src[5] << 8) + (Src[6] << 16) + (Src[7] << 24);\r\n\r\n  //\r\n  // If compressed file size is 0, return\r\n  //\r\n  if (OrigSize == 0) {\r\n    return RETURN_SUCCESS;\r\n  }\r\n\r\n  Src = Src + 8;\r\n\r\n  for (Index = 0; Index < sizeof (SCRATCH_DATA); Index++) {\r\n    ((UINT8 *) Sd)[Index] = 0;\r\n  }\r\n  //\r\n  // The length of the field 'Position Set Code Length Array Size' in Block Header.\r\n  // For EFI 1.1 de/compression algorithm(Version 1), mPBit = 4\r\n  // For Tiano de/compression algorithm(Version 2), mPBit = 5\r\n  //\r\n  Sd->mPBit     = 4;\r\n  Sd->mSrcBase  = (UINT8 *)Src;\r\n  Sd->mDstBase  = Dst;\r\n  //\r\n  // CompSize and OrigSize are caculated in bytes\r\n  //\r\n  Sd->mCompSize = CompSize;\r\n  Sd->mOrigSize = OrigSize;\r\n\r\n  //\r\n  // Fill the first BITBUFSIZ bits\r\n  //\r\n  FillBuf (Sd, BITBUFSIZ);\r\n\r\n  //\r\n  // Decompress it\r\n  //\r\n  Decode (Sd);\r\n\r\n  if (Sd->mBadTableFlag != 0) {\r\n    //\r\n    // Something wrong with the source\r\n    //\r\n    return RETURN_INVALID_PARAMETER;\r\n  }\r\n\r\n  return RETURN_SUCCESS;\r\n}\r\n\n", "comment_ratio": 0.16467780429594273}
{"lang": "c", "code": "#ifndef SWIFT_ARCHETYPEBUILDER_H\n#define SWIFT_ARCHETYPEBUILDER_H\n\n#include \"swift/AST/Identifier.h\"\n#include \"swift/AST/Types.h\"\n#include \"swift/AST/TypeLoc.h\"\n#include \"swift/Basic/LLVM.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/MapVector.h\"\n#include \"llvm/ADT/TinyPtrVector.h\"\n#include <functional>\n#include <memory>\n\nnamespace swift {\n\nclass AbstractTypeParamDecl;\nclass ArchetypeType;\nclass AssociatedTypeDecl;\nclass DeclContext;\nclass DependentMemberType;\nclass GenericParamList;\nclass GenericSignature;\nclass GenericTypeParamDecl;\nclass GenericTypeParamType;\nclass LazyResolver;\nclass ModuleDecl;\nclass Pattern;\nclass ProtocolConformance;\nclass ProtocolDecl;\nclass Requirement;\nclass RequirementRepr;\nclass SILModule;\nclass SourceLoc;\nclass Type;\nclass TypeRepr;\nclass ASTContext;\nclass DiagnosticEngine;\n\n/// Describes how a requirement was determined.\nclass RequirementSource {\npublic:\n  enum Kind : unsigned char {\n    /// The requirement was explicitly stated in the generic parameter\n    /// clause.\n    Explicit,\n    /// The requirement was inferred from the function's parameter or\n    /// result types.\n    Inferred,\n\n    /// The requirement was part of a protocol requirement on an\n    /// associated type.\n    ///\n    /// These are dropped when building the GenericSignature.\n    Protocol,\n\n    /// The requirement is redundant with some other requirement.\n    ///\n    /// These are dropped when building the GenericSignature.\n    Redundant,\n\n    /// The requirement came from an outer scope.\n    /// FIXME: eliminate this in favor of keeping requirement sources in \n    /// GenericSignatures, at least non-canonical ones?\n    OuterScope,\n  };\n\n  RequirementSource(Kind kind, SourceLoc loc) : StoredKind(kind), Loc(loc) { }\n\n  /// Retrieve the kind of requirement source.\n  Kind getKind() const { return StoredKind; }\n\n  /// Set the kind of the requirement source.\n  void setKind(Kind kind) { StoredKind = kind; }\n\n  /// Retrieve the source location at which the requirement originated.\n  SourceLoc getLoc() const { return Loc; }\n\n  LLVM_ATTRIBUTE_DEPRECATED(\n      void dump(SourceManager *srcMgr) const,\n      \"only for use within the debugger\");\n\n  /// Dump the requirement source.\n  void dump(llvm::raw_ostream &out, SourceManager *srcMgr) const;\n\nprivate:\n  Kind StoredKind;\n  SourceLoc Loc;\n};\n\n/// \\brief Collects a set of requirements of generic parameters, both explicitly\n/// stated and inferred, and determines the set of archetypes for each of\n/// the generic parameters.\nclass ArchetypeBuilder {\npublic:\n  /// Describes a potential archetype, which stands in for a generic parameter\n  /// type or some type derived from it.\n  class PotentialArchetype;\n\nprivate:\n  class InferRequirementsWalker;\n  friend class InferRequirementsWalker;\n\n  ModuleDecl &Mod;\n  ASTContext &Context;\n  DiagnosticEngine &Diags;\n  struct Implementation;\n  std::unique_ptr<Implementation> Impl;\n\n  ArchetypeBuilder(const ArchetypeBuilder &) = delete;\n  ArchetypeBuilder &operator=(const ArchetypeBuilder &) = delete;\n\n  /// \\brief Add a new conformance requirement specifying that the given\n  /// potential archetype conforms to the given protocol.\n  bool addConformanceRequirement(PotentialArchetype *T,\n                                 ProtocolDecl *Proto,\n                                 RequirementSource Source);\n\n  bool addConformanceRequirement(PotentialArchetype *T,\n                                 ProtocolDecl *Proto,\n                                 RequirementSource Source,\n                                llvm::SmallPtrSetImpl<ProtocolDecl *> &Visited);\n\npublic:\n  /// \\brief Add a new conformance requirement specifying that the given\n  /// potential archetypes are equivalent.\n  bool addSameTypeRequirementBetweenArchetypes(PotentialArchetype *T1,\n                                               PotentialArchetype *T2,\n                                               RequirementSource Source);\n  \n  /// \\brief Add a new conformance requirement specifying that the given\n  /// potential archetype is bound to a concrete type.\n  bool addSameTypeRequirementToConcrete(PotentialArchetype *T,\n                                        Type Concrete,\n                                        RequirementSource Source);\n\nprivate:\n  /// \\brief Add a new superclass requirement specifying that the given\n  /// potential archetype has the given type as an ancestor.\n  bool addSuperclassRequirement(PotentialArchetype *T, \n                                Type Superclass,\n                                RequirementSource Source);\n\n  /// \\brief Add a new same-type requirement specifying that the given potential\n  /// archetypes should map to the equivalent archetype.\n  bool addSameTypeRequirement(Type T1, Type T2, RequirementSource Source);\n\n  /// Add the requirements placed on the given abstract type parameter\n  /// to the given potential archetype.\n  bool addAbstractTypeParamRequirements(\n         AbstractTypeParamDecl *decl,\n         PotentialArchetype *pa,\n         RequirementSource::Kind kind,\n         llvm::SmallPtrSetImpl<ProtocolDecl *> &visited);\n\n  /// Visit all of the types that show up in the list of inherited\n  /// types.\n  ///\n  /// \\returns true if any of the invocations of \\c visitor returned true.\n  bool visitInherited(ArrayRef<TypeLoc> inheritedTypes,\n                      llvm::function_ref<bool(Type, SourceLoc)> visitor);\n\n  /// Visit all of the potential archetypes.\n  template<typename F>\n  void visitPotentialArchetypes(F f);\n\npublic:\n  /// Construct a new archetype builder.\n  ///\n  /// \\param mod The module in which the builder will create archetypes.\n  ///\n  /// \\param diags The diagnostics entity to use.\n  ArchetypeBuilder(ModuleDecl &mod, DiagnosticEngine &diags);\n\n  ArchetypeBuilder(ArchetypeBuilder &&);\n  ~ArchetypeBuilder();\n\n  /// Retrieve the AST context.\n  ASTContext &getASTContext() const { return Context; }\n\n  /// Retrieve the module.\n  ModuleDecl &getModule() const { return Mod; }\n\n  /// Retrieve the lazy resolver, if there is one.\n  LazyResolver *getLazyResolver() const;\n\n  /// Enumerate the requirements that describe the signature of this\n  /// archetype builder.\n  ///\n  /// \\param f A function object that will be passed each requirement\n  /// and requirement source.\n  void enumerateRequirements(llvm::function_ref<\n                      void (RequirementKind kind,\n                            PotentialArchetype *archetype,\n                            llvm::PointerUnion<Type, PotentialArchetype *> type,\n                            RequirementSource source)> f);\n  \n\nprivate:\n  PotentialArchetype *addGenericParameter(GenericTypeParamType *GenericParam,\n                                          ProtocolDecl *RootProtocol,\n                                          Identifier ParamName);\n\npublic:\n  /// \\brief Add a new generic parameter for which there may be requirements.\n  void addGenericParameter(GenericTypeParamDecl *GenericParam);\n\n  /// Add the requirements placed on the given abstract type parameter\n  /// to the given potential archetype.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool addGenericParameterRequirements(GenericTypeParamDecl *GenericParam);\n\n  /// \\brief Add a new generic parameter for which there may be requirements.\n  void addGenericParameter(GenericTypeParamType *GenericParam);\n  \n  /// \\brief Add a new requirement.\n  ///\n  /// \\returns true if this requirement makes the set of requirements\n  /// inconsistent, in which case a diagnostic will have been issued.\n  bool addRequirement(const RequirementRepr &Req);\n\n  /// \\brief Add an already-checked requirement.\n  ///\n  /// Adding an already-checked requirement cannot fail. This is used to\n  /// re-inject requirements from outer contexts.\n  void addRequirement(const Requirement &req, RequirementSource source);\n  \n  /// \\brief Add all of a generic signature's parameters and requirements.\n  ///\n  /// FIXME: Requirements from the generic signature are treated as coming from\n  /// an outer scope. Setting \\c treatRequirementsAsExplicit to true disables\n  /// this behavior.\n  void addGenericSignature(GenericSignature *sig,\n                           GenericEnvironment *genericEnv,\n                           bool treatRequirementsAsExplicit = false);\n\n  /// \\brief Build the generic signature.\n  GenericSignature *getGenericSignature();\n\n  /// \\brief Build the generic environment.\n  GenericEnvironment *getGenericEnvironment();\n\n  /// Infer requirements from the given type, recursively.\n  ///\n  /// This routine infers requirements from a type that occurs within the\n  /// signature of a generic function. For example, given:\n  ///\n  /// \\code\n  /// func f<K, V>(dict : Dictionary<K, V>) { ... }\n  /// \\endcode\n  ///\n  /// where \\c Dictionary requires that its key type be \\c Hashable,\n  /// the requirement \\c K : Hashable is inferred from the parameter type,\n  /// because the type \\c Dictionary<K,V> cannot be formed without it.\n  void inferRequirements(TypeLoc type, GenericParamList *genericParams);\n\n  /// Infer requirements from the given pattern, recursively.\n  ///\n  /// This routine infers requirements from a type that occurs within the\n  /// signature of a generic function. For example, given:\n  ///\n  /// \\code\n  /// func f<K, V>(dict : Dictionary<K, V>) { ... }\n  /// \\endcode\n  ///\n  /// where \\c Dictionary requires that its key type be \\c Hashable,\n  /// the requirement \\c K : Hashable is inferred from the parameter type,\n  /// because the type \\c Dictionary<K,V> cannot be formed without it.\n  void inferRequirements(ParameterList *params,GenericParamList *genericParams);\n\n  /// Finalize the set of requirements, performing any remaining checking\n  /// required before generating archetypes.\n  ///\n  /// \\param allowConcreteGenericParams If true, allow generic parameters to\n  /// be made concrete.\n  void finalize(SourceLoc loc, bool allowConcreteGenericParams=false);\n\n  /// \\brief Resolve the given type to the potential archetype it names.\n  ///\n  /// This routine will synthesize nested types as required to refer to a\n  /// potential archetype, even in cases where no requirement specifies the\n  /// requirement for such an archetype. FIXME: The failure to include such a\n  /// requirement will be diagnosed at some point later (when the types in the\n  /// signature are fully resolved).\n  ///\n  /// For any type that cannot refer to an archetype, this routine returns null.\n  PotentialArchetype *resolveArchetype(Type type);\n\n  /// \\brief Resolve the given dependent type using our context archetypes.\n  ///\n  /// Given an arbitrary type, this will substitute dependent type parameters\n  /// structurally with their corresponding archetypes and resolve dependent\n  /// member types to the appropriate associated types.\n  Type substDependentType(Type type);\n\n  /// Map an interface type to a contextual type.\n  static Type mapTypeIntoContext(const DeclContext *dc, Type type);\n\n  /// Map an interface type to a contextual type.\n  static Type mapTypeIntoContext(ModuleDecl *M,\n                                 GenericEnvironment *genericEnv,\n                                 Type type);\n\n  /// Map a contextual type to an interface type.\n  static Type mapTypeOutOfContext(const DeclContext *dc, Type type);\n\n  /// Map a contextual type to an interface type.\n  static Type mapTypeOutOfContext(ModuleDecl *M,\n                                  GenericEnvironment *genericEnv,\n                                  Type type);\n\n  /// \\brief Dump all of the requirements, both specified and inferred.\n  LLVM_ATTRIBUTE_DEPRECATED(\n      void dump(),\n      \"only for use within the debugger\");\n\n  /// Dump all of the requirements to the given output stream.\n  void dump(llvm::raw_ostream &out);\n\n  // In SILFunction.cpp:\n  \n  /// \\brief Resolve the given dependent type using our context archetypes.\n  ///\n  /// Given an arbitrary type, this will substitute dependent type parameters\n  /// structurally with their corresponding archetypes and resolve dependent\n  /// member types to the appropriate associated types. It will reabstract\n  /// dependent types according to the abstraction level of their associated\n  /// type requirements.\n  SILType substDependentType(SILModule &M,\n                             SILType type);\n};\n\nclass ArchetypeBuilder::PotentialArchetype {\n  /// Either the parent of this potential archetype (for an associated\n  /// type) or the generic type parameter type to which this potential\n  /// archetype corresponds.\n  llvm::PointerUnion<PotentialArchetype*, GenericTypeParamType*> ParentOrParam;\n\n  /// The root protocol with which this potential archetype is associated.\n  ProtocolDecl *RootProtocol = nullptr;\n\n  /// \\brief The name of this potential archetype or, for an\n  /// associated type, the declaration of the associated type to which\n  /// this potential archetype has been resolved. Or, for a type alias,\n  /// the type alias decl.\n  llvm::PointerUnion3<Identifier, AssociatedTypeDecl *,\n                      TypeAliasDecl *> NameOrAssociatedType;\n\n  /// \\brief The representative of the equivalent class of potential archetypes\n  /// to which this potential archetype belongs.\n  PotentialArchetype *Representative;\n\n  /// \\brief The source of a same-type requirement.\n  Optional<RequirementSource> SameTypeSource;\n\n  /// \\brief The superclass of this archetype, if specified.\n  Type Superclass;\n\n  /// The source of the superclass requirement.\n  Optional<RequirementSource> SuperclassSource;\n\n  /// \\brief The list of protocols to which this archetype will conform.\n  llvm::MapVector<ProtocolDecl *, RequirementSource> ConformsTo;\n\n  /// \\brief The set of nested types of this archetype.\n  ///\n  /// For a given nested type name, there may be multiple potential archetypes\n  /// corresponding to different associated types (from different protocols)\n  /// that share a name.\n  llvm::MapVector<Identifier, llvm::TinyPtrVector<PotentialArchetype *>>\n    NestedTypes;\n\n  /// \\brief The actual archetype, once it has been assigned, or the concrete\n  /// type that the parameter was same-type constrained to.\n  ArchetypeType::NestedType ArchetypeOrConcreteType;\n\n  /// \\brief Recursively conforms to itself.\n  unsigned IsRecursive : 1;\n\n  /// Whether this potential archetype is invalid, e.g., because it could not\n  /// be resolved.\n  unsigned Invalid : 1;\n\n  /// Whether we are currently substituting into the concrete type of\n  /// this potential archetype.\n  unsigned SubstitutingConcreteType : 1;\n\n  /// Whether we have detected recursion during the substitution of\n  /// the concrete type.\n  unsigned RecursiveConcreteType : 1;\n\n  /// Whether we have detected recursion during the substitution of\n  /// the superclass type.\n  unsigned RecursiveSuperclassType : 1;\n\n  /// Whether we have renamed this (nested) type due to typo correction.\n  unsigned Renamed : 1;\n\n  /// The equivalence class of this potential archetype.\n  llvm::TinyPtrVector<PotentialArchetype *> EquivalenceClass;\n\n  /// \\brief Construct a new potential archetype for an unresolved\n  /// associated type.\n  PotentialArchetype(PotentialArchetype *Parent, Identifier Name)\n    : ParentOrParam(Parent), NameOrAssociatedType(Name), Representative(this),\n      IsRecursive(false), Invalid(false), SubstitutingConcreteType(false),\n      RecursiveConcreteType(false), RecursiveSuperclassType(false),\n      Renamed(false)\n  { \n    assert(Parent != nullptr && \"Not an associated type?\");\n    EquivalenceClass.push_back(this);\n  }\n\n  /// \\brief Construct a new potential archetype for an associated type.\n  PotentialArchetype(PotentialArchetype *Parent, AssociatedTypeDecl *AssocType)\n    : ParentOrParam(Parent), NameOrAssociatedType(AssocType), \n      Representative(this), IsRecursive(false), Invalid(false),\n      SubstitutingConcreteType(false), RecursiveConcreteType(false),\n      RecursiveSuperclassType(false), Renamed(false)\n  { \n    assert(Parent != nullptr && \"Not an associated type?\");\n    EquivalenceClass.push_back(this);\n  }\n\n  /// \\brief Construct a new potential archetype for a type alias.\n  PotentialArchetype(PotentialArchetype *Parent, TypeAliasDecl *TypeAlias)\n    : ParentOrParam(Parent), NameOrAssociatedType(TypeAlias),\n      Representative(this), IsRecursive(false), Invalid(false),\n      SubstitutingConcreteType(false), RecursiveConcreteType(false),\n      RecursiveSuperclassType(false), Renamed(false)\n  {\n    assert(Parent != nullptr && \"Not an associated type?\");\n    EquivalenceClass.push_back(this);\n  }\n\n  /// \\brief Construct a new potential archetype for a generic parameter.\n  PotentialArchetype(GenericTypeParamType *GenericParam, \n                     ProtocolDecl *RootProtocol,\n                     Identifier Name)\n    : ParentOrParam(GenericParam), RootProtocol(RootProtocol), \n      NameOrAssociatedType(Name), Representative(this), IsRecursive(false),\n      Invalid(false), SubstitutingConcreteType(false),\n      RecursiveConcreteType(false), RecursiveSuperclassType(false),\n      Renamed(false)\n  {\n    EquivalenceClass.push_back(this);\n  }\n\n  /// \\brief Recursively build the full name.\n  void buildFullName(bool forDebug, SmallVectorImpl<char> &result) const;\n\npublic:\n  ~PotentialArchetype();\n\n  /// \\brief Retrieve the name of this potential archetype.\n  Identifier getName() const;\n\n  /// \\brief Retrieve the full display name of this potential archetype.\n  std::string getFullName() const;\n\n  /// \\brief Retrieve the debug name of this potential archetype.\n  std::string getDebugName() const;\n\n  /// Retrieve the parent of this potential archetype, which will be non-null\n  /// when this potential archetype is an associated type.\n  PotentialArchetype *getParent() const { \n    return ParentOrParam.dyn_cast<PotentialArchetype *>(); \n  }\n\n  /// Retrieve the generic parameter at the root of this potential archetype.\n  GenericTypeParamType *getRootParam() const {\n    if (auto parent = getParent())\n      return parent->getRootParam();\n\n    return getGenericParam();\n  }\n\n  /// Retrieve the associated type to which this potential archetype\n  /// has been resolved.\n  AssociatedTypeDecl *getResolvedAssociatedType() const {\n    assert(getParent() && \"Not an associated type\");\n    return NameOrAssociatedType.dyn_cast<AssociatedTypeDecl *>();\n  }\n\n  /// Resolve the potential archetype to the given associated type.\n  void resolveAssociatedType(AssociatedTypeDecl *assocType,\n                             ArchetypeBuilder &builder);\n\n  /// Retrieve the generic type parameter for this potential\n  /// archetype, if it corresponds to a generic parameter.\n  GenericTypeParamType *getGenericParam() const {\n    return ParentOrParam.dyn_cast<GenericTypeParamType *>(); \n  }\n  \n  /// Retrieve the type alias.\n  TypeAliasDecl *getTypeAliasDecl() const {\n    return NameOrAssociatedType.dyn_cast<TypeAliasDecl *>();\n  }\n\n  /// Retrieve the set of protocols to which this type conforms.\n  const llvm::MapVector<ProtocolDecl *, RequirementSource> &\n  getConformsTo() const {\n    return ConformsTo;\n  }\n\n  /// Add a conformance to this potential archetype.\n  ///\n  /// \\returns true if the conformance was new, false if it already existed.\n  bool addConformance(ProtocolDecl *proto, bool updateExistingSource,\n                      const RequirementSource &source,\n                      ArchetypeBuilder &builder);\n\n  /// Retrieve the superclass of this archetype.\n  Type getSuperclass() const { return Superclass; }\n\n  /// Retrieve the requirement source for the superclass requirement.\n  const RequirementSource &getSuperclassSource() const {\n    return *SuperclassSource;\n  } \n\n  /// Retrieve the set of nested types.\n  const llvm::MapVector<Identifier, llvm::TinyPtrVector<PotentialArchetype *>> &\n  getNestedTypes() const{\n    return NestedTypes;\n  }\n\n  /// \\brief Determine the nesting depth of this potential archetype, e.g.,\n  /// the number of associated type references.\n  unsigned getNestingDepth() const;\n\n  /// \\brief Retrieve the representative for this archetype, performing\n  /// path compression on the way.\n  PotentialArchetype *getRepresentative();\n\n  /// Retrieve the equivalence class containing this potential archetype.\n  ArrayRef<PotentialArchetype *> getEquivalenceClass() {\n    return getRepresentative()->EquivalenceClass;\n  }\n\n  /// \\brief Retrieve the potential archetype to be used as the anchor for\n  /// potential archetype computations.\n  PotentialArchetype *getArchetypeAnchor();\n\n  /// Retrieve the source of the same-type constraint that applies to this\n  /// potential archetype.\n  const RequirementSource &getSameTypeSource() const {\n    return *SameTypeSource;\n  }\n\n  /// \\brief Retrieve (or create) a nested type with the given name.\n  PotentialArchetype *getNestedType(Identifier Name,\n                                    ArchetypeBuilder &builder);\n\n  /// \\brief Retrieve (or build) the type corresponding to the potential\n  /// archetype.\n  ArchetypeType::NestedType getType(ArchetypeBuilder &builder);\n\n  /// Retrieve the dependent type that describes this potential\n  /// archetype.\n  Type getDependentType(ArchetypeBuilder &builder, bool allowUnresolved);\n\n  /// True if the potential archetype has been bound by a concrete type\n  /// constraint.\n  bool isConcreteType() const {\n    if (Representative != this)\n      return Representative->isConcreteType();\n\n    return ArchetypeOrConcreteType.isConcreteType();\n  }\n  \n  /// Get the concrete type this potential archetype is constrained to.\n  Type getConcreteType() const {\n    assert(isConcreteType());\n    if (Representative != this)\n      return Representative->getConcreteType();\n    return ArchetypeOrConcreteType.getAsConcreteType();\n  }\n\n  void setIsRecursive() { IsRecursive = true; }\n  bool isRecursive() const { return IsRecursive; }\n\n  bool isInvalid() const { return Invalid; }\n\n  void setInvalid() { Invalid = true; }\n\n  /// Determine whether this archetype was renamed due to typo\n  /// correction. If so, \\c getName() retrieves the new name.\n  bool wasRenamed() const { return Renamed; }\n\n  /// Note that this potential archetype was renamed (due to typo\n  /// correction), providing the new name.\n  void setRenamed(Identifier newName) {\n    NameOrAssociatedType = newName;\n    Renamed = true;\n  }\n\n  /// Whether this potential archetype makes a better archetype anchor than\n  /// the given archetype anchor.\n  bool isBetterArchetypeAnchor(PotentialArchetype *other) const;\n\n  void dump(llvm::raw_ostream &Out, SourceManager *SrcMgr,\n            unsigned Indent);\n\n  friend class ArchetypeBuilder;\n\nprivate:\n  bool hasConcreteTypeInPath() const;\n};\n\n} // end namespace swift\n\n#endif\n\n", "comment_ratio": 0.36334913112164297}
{"lang": "c", "code": "#pragma once\n\n//-----------------------------------------------------------------------------\n// mvWindow\n//\n//     - This abstract class is just a light wrapper for a platform specific\n//       window. It's quite lacking so may need to be extended later.\n//\n//     - This class may need to be renamed to remove confusion between this\n//       window and the mvWindowAppItem class (maybe to viewport?)\n//     \n//-----------------------------------------------------------------------------\n\n#include \"mvApp.h\"\n#include \"mvAppLog.h\"\n#include \"mvEvents.h\"\n#include \"mvDrawList.h\"\n\nnamespace Marvel {\n\n\t//-----------------------------------------------------------------------------\n\t// mvWindow\n\t//-----------------------------------------------------------------------------\n\tclass mvWindow : public mvEventHandler\n\t{\n\n\tpublic:\n\n\t\tstatic mvWindow* CreatemvWindow(unsigned width, unsigned height, bool error = false);\n\n\t\tmvWindow(unsigned width, unsigned height, bool error = false);\n\t\tvirtual ~mvWindow() = default;\n\n\t\tbool onEvent (mvEvent& event) override;\n\t\tbool onRender(mvEvent& event);\n\n\t\tmvRef<mvDrawList> getFrontDrawList() { return m_frontDrawList; }\n\t\tmvRef<mvDrawList> getBackDrawList() { return m_backDrawList; }\n\n\t\tvirtual void show       () {}\n\t\tvirtual void run        () {}\n\t\tvirtual void setup      () {}\n\t\tvirtual void prerender  () {}\n\t\tvirtual void render     () {}\n\t\tvirtual void renderFrame() {}\n\t\tvirtual void postrender () {}\n\t\tvirtual void cleanup    () {}\n\t\tvirtual void setWindowText(const std::string& name) {}\n\t\t\n\t\tvoid stop      () { m_running = false; }\n\t\tvoid setupFonts();\n\n\tprotected:\n\n\t\tbool              m_running = true;\n\t\tmvApp*            m_app     = nullptr;\n\t\tbool              m_error   = false;\n\t\tunsigned          m_width;\n\t\tunsigned          m_height;\n\t\tmvRef<mvDrawList> m_frontDrawList;\n\t\tmvRef<mvDrawList> m_backDrawList;\n\n\t};\n\n}\n\n", "comment_ratio": 0.19696969696969696}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n\n@interface MyUndoRecordData : NSObject\n\n@property(nonatomic) NSPoint po;\n@property(nonatomic) unsigned char d;\n\n-(id)initWithPoint:(NSPoint)po data:(unsigned char)d;\n\n@end\n\n", "comment_ratio": 0.3684210526315789}
{"lang": "c", "code": "#include \"rtc_api.h\"\n\n#if DEVICE_RTC\n\n#include \"wait_api.h\"\n\n#define LSE_STARTUP_TIMEOUT ((uint16_t)700) // delay in ms\n\nstatic int rtc_inited = 0;\n\nvoid rtc_init(void) {\n    uint32_t StartUpCounter = 0;\n    uint32_t LSEStatus = 0;\n    uint32_t rtc_freq = 0;\n\n    RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE); // Enable PWR and Backup clock\n\n    PWR_BackupAccessCmd(ENABLE); // Allow access to Backup Domain\n\n    BKP_DeInit(); // Reset Backup Domain\n\n    // Enable LSE clock\n    RCC_LSEConfig(RCC_LSE_ON);\n\n    // Wait till LSE is ready\n    do {\n        LSEStatus = RCC_GetFlagStatus(RCC_FLAG_LSERDY);\n        wait_ms(1);\n        StartUpCounter++;\n    } while ((LSEStatus == 0) && (StartUpCounter <= LSE_STARTUP_TIMEOUT));\n\n    if (StartUpCounter > LSE_STARTUP_TIMEOUT) {\n        // The LSE has not started, use LSI instead.\n        // The RTC Clock may vary due to LSI frequency dispersion.\n        RCC_LSEConfig(RCC_LSE_OFF);\n        RCC_LSICmd(ENABLE); // Enable LSI\n        while (RCC_GetFlagStatus(RCC_FLAG_LSIRDY) == RESET) {} // Wait until ready\n        RCC_RTCCLKConfig(RCC_RTCCLKSource_LSI); // Select the RTC Clock Source\n        rtc_freq = 40000; // [TODO] To be measured precisely using a timer input capture\n    } else {\n        // The LSE has correctly started\n        RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE); // Select the RTC Clock Source\n        rtc_freq = LSE_VALUE;\n    }\n\n    RCC_RTCCLKCmd(ENABLE); // Enable RTC Clock\n\n    RTC_WaitForSynchro(); // Wait for RTC registers synchronization\n\n    RTC_WaitForLastTask(); // Wait until last write operation on RTC registers has finished\n\n    // Set RTC period to 1 sec\n    RTC_SetPrescaler(rtc_freq - 1);\n\n    RTC_WaitForLastTask(); // Wait until last write operation on RTC registers has finished\n\n    rtc_inited = 1;\n}\n\nvoid rtc_free(void) {\n    // Disable RTC, LSE and LSI clocks\n    PWR_BackupAccessCmd(ENABLE); // Allow access to Backup Domain\n    RCC_RTCCLKCmd(DISABLE);\n    RCC_LSEConfig(RCC_LSE_OFF);\n    RCC_LSICmd(DISABLE);\n\n    rtc_inited = 0;\n}\n\nint rtc_isenabled(void) {\n    return rtc_inited;\n}\n\ntime_t rtc_read(void) {\n    return (time_t)RTC_GetCounter();\n}\n\nvoid rtc_write(time_t t) {\n    RTC_WaitForLastTask(); // Wait until last write operation on RTC registers has finished\n    RTC_SetCounter(t); // Change the current time\n    RTC_WaitForLastTask(); // Wait until last write operation on RTC registers has finished\n}\n\n#endif\n\n", "comment_ratio": 0.21052631578947367}
{"lang": "c", "code": "#include <inttypes.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"WAVM/wavm-c/wavm-c.h\"\n#include \"wavm-test.h\"\n\n#define own\n\n// A function to be called from Wasm code.\nown wasm_trap_t* hello_callback(const wasm_val_t args[], wasm_val_t results[])\n{\n\tprintf(\"Calling back...\\n\");\n\tprintf(\"Hello World!\\n\");\n\treturn NULL;\n}\n\nint execCAPITest(int argc, char** argv)\n{\n\t// Initialize.\n\tprintf(\"Initializing...\\n\");\n\twasm_engine_t* engine = wasm_engine_new();\n\twasm_compartment_t* compartment = wasm_compartment_new(engine);\n\twasm_store_t* store = wasm_store_new(compartment);\n\n\t// Load binary.\n\tprintf(\"Loading binary...\\n\");\n\tchar hello_wasm[]\n\t\t= {0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x84, 0x80, 0x80, 0x80, 0x00, 0x01,\n\t\t   0x60, 0x00, 0x00, 0x02, 0x8a, 0x80, 0x80, 0x80, 0x00, 0x01, 0x00, 0x05, 0x68, 0x65, 0x6c,\n\t\t   0x6c, 0x6f, 0x00, 0x00, 0x03, 0x82, 0x80, 0x80, 0x80, 0x00, 0x01, 0x00, 0x07, 0x87, 0x80,\n\t\t   0x80, 0x80, 0x00, 0x01, 0x03, 0x72, 0x75, 0x6e, 0x00, 0x01, 0x0a, 0x8a, 0x80, 0x80, 0x80,\n\t\t   0x00, 0x01, 0x84, 0x80, 0x80, 0x80, 0x00, 0x00, 0x10, 0x00, 0x0b};\n\n\t// Compile.\n\tprintf(\"Compiling module...\\n\");\n\town wasm_module_t* module = wasm_module_new(engine, hello_wasm, sizeof(hello_wasm));\n\tif(!module)\n\t{\n\t\tprintf(\"> Error compiling module!\\n\");\n\t\treturn 1;\n\t}\n\n\t// Create external print functions.\n\tprintf(\"Creating callback...\\n\");\n\town wasm_functype_t* hello_type = wasm_functype_new_0_0();\n\town wasm_func_t* hello_func = wasm_func_new(compartment, hello_type, hello_callback);\n\n\twasm_functype_delete(hello_type);\n\n\t// Instantiate.\n\tprintf(\"Instantiating module...\\n\");\n\tconst wasm_extern_t* imports[1];\n\timports[0] = wasm_func_as_extern(hello_func);\n\town wasm_instance_t* instance = wasm_instance_new(store, module, imports, NULL);\n\tif(!instance)\n\t{\n\t\tprintf(\"> Error instantiating module!\\n\");\n\t\treturn 1;\n\t}\n\n\twasm_func_delete(hello_func);\n\n\t// Extract export.\n\tprintf(\"Extracting export...\\n\");\n\twasm_extern_t* run_extern = wasm_instance_export(instance, 0);\n\tif(run_extern == NULL)\n\t{\n\t\tprintf(\"> Error accessing export!\\n\");\n\t\treturn 1;\n\t}\n\tconst wasm_func_t* run_func = wasm_extern_as_func(run_extern);\n\tif(run_func == NULL)\n\t{\n\t\tprintf(\"> Export is not a function!\\n\");\n\t\treturn 1;\n\t}\n\n\twasm_module_delete(module);\n\twasm_instance_delete(instance);\n\n\t// Call.\n\tprintf(\"Calling export...\\n\");\n\tif(wasm_func_call(store, run_func, NULL, NULL))\n\t{\n\t\tprintf(\"> Error calling function!\\n\");\n\t\treturn 1;\n\t}\n\n\t// Shut down.\n\tprintf(\"Shutting down...\\n\");\n\twasm_store_delete(store);\n\twasm_compartment_delete(compartment);\n\twasm_engine_delete(engine);\n\n\t// All done.\n\tprintf(\"Done.\\n\");\n\treturn 0;\n}\n\n", "comment_ratio": 0.1}
{"lang": "c", "code": "//\n// Created by kaiser on 19-4-15.\n//\n\n#include \"csapp.h\"\n\nvoid sigint_handler(int sig) {\n  printf(\"Caught SIGINT!\\n\");\n  exit(0);\n}\n\nint main(void) {\n  if (signal(SIGINT, sigint_handler) == SIG_ERR) {\n    unix_error(\"signal error\");\n  }\n\n  Pause();\n}\n\n", "comment_ratio": 0.15789473684210525}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n#import \"LRExpectationAction.h\"\n\n@interface LRReturnValueAction : NSObject <LRExpectationAction> {\n  id objectToReturn;\n  NSData *returnValue;\n}\n- (id)initWithObject:(id)object;\n- (id)initWithValue:(void *)value;\n@end\n\nLRReturnValueAction *LRA_returnObject(id object);\nLRReturnValueAction *LRA_returnValue(void *value);\nLRReturnValueAction *LRA_returnInt(int anInt);\nLRReturnValueAction *LRA_returnInteger(NSInteger anInteger);\nLRReturnValueAction *LRA_returnFloat(float aFloat);\nLRReturnValueAction *LRA_returnLong(long aLong);\nLRReturnValueAction *LRA_returnBool(BOOL aBool);\n\n#ifdef LRMOCKY_SHORTHAND\n#define returnObject  LRA_returnObject\n#define returnsObject  LRA_returnObject\n#define returnValue   LRA_returnValue\n#define returnsValue   LRA_returnValue\n#define returnInt     LRA_returnInt\n#define returnsInt     LRA_returnInt\n#define returnInteger LRA_returnInteger\n#define returnsInteger LRA_returnInteger\n#define returnFloat   LRA_returnFloat\n#define returnsFloat   LRA_returnFloat\n#define returnLong    LRA_returnLong\n#define returnsLong    LRA_returnLong\n#define returnBool    LRA_returnBool\n#define returnsBool    LRA_returnBool\n#endif\n\n", "comment_ratio": 0.1590909090909091}
{"lang": "c", "code": "#import <CoreDuet/_DKObject.h>\n\n#import \"_DKHasComparableValue.h\"\n#import \"_DKHasObjectType.h\"\n#import \"_DKHasPrimaryValue.h\"\n\n@class NSString, _DKIdentifierType;\n\n@interface _DKIdentifier : _DKObject <_DKHasComparableValue, _DKHasPrimaryValue, _DKHasObjectType>\n{\n    NSString *_stringValue;\n    _DKIdentifierType *_identifierType;\n}\n\n+ (BOOL)supportsSecureCoding;\n+ (id)identifierWithString:(id)arg1 type:(id)arg2;\n+ (id)fromPBCodable:(id)arg1;\n+ (id)_identifierFromManagedObject:(id)arg1 readMetadata:(BOOL)arg2 cache:(id)arg3;\n+ (id)objectFromManagedObject:(id)arg1 readMetadata:(BOOL)arg2 cache:(id)arg3;\n+ (id)entityName;\n@property(retain) _DKIdentifierType *identifierType; // @synthesize identifierType=_identifierType;\n@property(retain) NSString *stringValue; // @synthesize stringValue=_stringValue;\n- (void).cxx_destruct;\n- (BOOL)isEqual:(id)arg1;\n- (long long)integerValue;\n- (double)doubleValue;\n- (id)primaryValue;\n- (long long)compareValue:(id)arg1;\n- (id)objectType;\n@property(readonly, copy) NSString *description;\n- (void)encodeWithCoder:(id)arg1;\n- (id)initWithCoder:(id)arg1;\n- (id)initWithString:(id)arg1 type:(id)arg2;\n- (id)toPBCodable;\n- (BOOL)copyToManagedObject:(id)arg1;\n- (long long)typeCode;\n\n// Remaining properties\n@property(readonly, copy) NSString *debugDescription;\n@property(readonly) unsigned long long hash;\n@property(readonly) Class superclass;\n\n@end\n\n\n", "comment_ratio": 0.1568627450980392}
{"lang": "c", "code": "#ifndef _GLIBCXX_PARALLEL_CHECKERS_H\n#define _GLIBCXX_PARALLEL_CHECKERS_H 1\n\n#include <functional>\n#include <cstdio>\n#include <bits/stl_algobase.h>\n\nnamespace __gnu_parallel\n{\n  /**\n   * @brief Check whether @c [begin, @c end) is sorted according to @c comp.\n   * @param begin Begin iterator of sequence.\n   * @param end End iterator of sequence.\n   * @param comp Comparator.\n   * @return @c true if sorted, @c false otherwise.\n   */\n  // XXX Comparator default template argument\n  template<typename InputIterator, typename Comparator>\n    bool\n    is_sorted(InputIterator begin, InputIterator end,\n\t      Comparator comp\n\t      = std::less<typename std::iterator_traits<InputIterator>::\n\t      value_type>())\n    {\n      if (begin == end)\n\treturn true;\n\n      InputIterator current(begin), recent(begin);\n\n      unsigned long long position = 1;\n      for (current++; current != end; current++)\n\t{\n\t  if (comp(*current, *recent))\n\t    {\n\t      printf(\"is_sorted: check failed before position %i.\\n\",\n\t\t     position);\n\t      return false;\n\t    }\n\t  recent = current;\n\t  position++;\n\t}\n\n      return true;\n    }\n\n  /**\n   * @brief Check whether @c [begin, @c end) is sorted according to @c comp.\n   * Prints the position in case an unordered pair is found.\n   * @param begin Begin iterator of sequence.\n   * @param end End iterator of sequence.\n   * @param first_failure The first failure is returned in this variable.\n   * @param comp Comparator.\n   * @return @c true if sorted, @c false otherwise.\n   */\n  // XXX Comparator default template argument\n  template<typename InputIterator, typename Comparator>\n    bool\n    is_sorted_failure(InputIterator begin, InputIterator end,\n\t\t      InputIterator& first_failure,\n\t\t      Comparator comp\n\t\t      = std::less<typename std::iterator_traits<InputIterator>::\n\t\t      value_type>())\n    {\n      if (begin == end)\n\treturn true;\n\n      InputIterator current(begin), recent(begin);\n\n      unsigned long long position = 1;\n      for (current++; current != end; current++)\n\t{\n\t  if (comp(*current, *recent))\n\t    {\n\t      first_failure = current;\n\t      printf(\"is_sorted: check failed before position %lld.\\n\",\n\t\t     position);\n\t      return false;\n\t    }\n\t  recent = current;\n\t  position++;\n\t}\n\n      first_failure = end;\n      return true;\n    }\n\n  /**\n   * @brief Check whether @c [begin, @c end) is sorted according to @c comp.\n   * Prints all unordered pair, including the surrounding two elements.\n   * @param begin Begin iterator of sequence.\n   * @param end End iterator of sequence.\n   * @param comp Comparator.\n   * @return @c true if sorted, @c false otherwise.\n   */\n  template<typename InputIterator, typename Comparator>\n    bool\n    // XXX Comparator default template argument\n    is_sorted_print_failures(InputIterator begin, InputIterator end,\n\t\t\t     Comparator comp\n\t\t\t     = std::less<typename std::iterator_traits\n\t\t\t     <InputIterator>::value_type>())\n    {\n      if (begin == end)\n\treturn true;\n\n      InputIterator recent(begin);\n      bool ok = true;\n\n      for (InputIterator pos(begin + 1); pos != end; pos++)\n\t{\n\t  if (comp(*pos, *recent))\n\t    {\n\t      printf(\"%ld: %d %d %d %d\\n\", pos - begin, *(pos - 2),\n\t\t     *(pos- 1), *pos, *(pos + 1));\n\t      ok = false;\n\t    }\n\t  recent = pos;\n\t}\n      return ok;\n    }\n}\n\n#endif /* _GLIBCXX_PARALLEL_CHECKERS_H */\n\n", "comment_ratio": 0.14838709677419354}
{"lang": "c", "code": "#ifndef EE_H\n#define EE_H\n\n#include \"defines.h\"\n\ntypedef unsigned long\tuint64;\ntypedef long\t\t\tint64;\n\ntypedef struct int128\n{\n\tint64 lo, hi;\n} int128 __attribute__((aligned(16)));\n\ntypedef struct uint128\n{\n\tuint64 lo, hi;\n} uint128 __attribute__((aligned(16)));\n\n//typedef int \t\t\tint128 __attribute__(( mode(TI), aligned(16) ));\n//typedef unsigned int \tuint128 __attribute__(( mode(TI), aligned(16) ));\n\n// Timer resolution constants\n#define TIMER_RES_BUS\t\t0\t\t// 2500000 clicks per VBLANK\n#define TIMER_RES_BUS16\t\t1\t\t// 1/16th of BUS = 156250 clicks per VBLANK\n#define TIMER_RES_BUS256\t2\t\t// 1/256th of BUS = 9760 clicks per VBLANK\n#define TIMER_RES_HBLNK\t\t3\t\t// 262 clicks per VBLANK\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nextern void \tee_flush_cache(int blah);\n\nextern void \tee_timer_init(int timer, int resolution);\nextern void \tee_timer_start(int timer);\nextern void \tee_timer_stop(int timer);\nextern uint32\tee_timer_get_ticks(int timer);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // EE_H\n\n", "comment_ratio": 0.3333333333333333}
{"lang": "c", "code": "#ifndef XFA_FXFA_PARSER_CSCRIPT_DATAWINDOW_H_\n#define XFA_FXFA_PARSER_CSCRIPT_DATAWINDOW_H_\n\n#include \"fxjs/xfa/cjx_datawindow.h\"\n#include \"xfa/fxfa/parser/cxfa_object.h\"\n\nclass CScript_DataWindow : public CXFA_Object {\n public:\n  explicit CScript_DataWindow(CXFA_Document* pDocument);\n  ~CScript_DataWindow() override;\n\n  CJX_DataWindow* JSDataWindow() {\n    return static_cast<CJX_DataWindow*>(JSObject());\n  }\n};\n\n#endif  // XFA_FXFA_PARSER_CSCRIPT_DATAWINDOW_H_\n\n", "comment_ratio": 0.20833333333333334}
{"lang": "c", "code": "#import <Sharing/Sharing-Structs.h>\n#import <libobjc.A.dylib/NSSecureCoding.h>\n\n@class NSString, NSDate, SFAppleIDContactInfo, SFAppleIDIdentity, NSData, SFAppleIDValidationRecord;\n\n@interface SFAppleIDAccount : NSObject <NSSecureCoding> {\n\n\tNSString* _altDSID;\n\tNSString* _appleID;\n\tNSString* _certificateToken;\n\tNSDate* _certificateTokenCreationDate;\n\tSFAppleIDContactInfo* _contactInfo;\n\tNSDate* _creationDate;\n\tSFAppleIDIdentity* _identity;\n\tNSData* _privateKeyPersistentReference;\n\tSFAppleIDValidationRecord* _validationRecord;\n\n}\n\n@property (nonatomic,retain) NSString * altDSID;                                        //@synthesize altDSID=_altDSID - In the implementation block\n@property (nonatomic,readonly) NSString * appleID;                                      //@synthesize appleID=_appleID - In the implementation block\n@property (nonatomic,retain) NSString * certificateToken;                               //@synthesize certificateToken=_certificateToken - In the implementation block\n@property (nonatomic,retain) NSDate * certificateTokenCreationDate;                     //@synthesize certificateTokenCreationDate=_certificateTokenCreationDate - In the implementation block\n@property (nonatomic,retain) SFAppleIDContactInfo * contactInfo;                        //@synthesize contactInfo=_contactInfo - In the implementation block\n@property (nonatomic,readonly) NSDate * creationDate;                                   //@synthesize creationDate=_creationDate - In the implementation block\n@property (nonatomic,retain) SFAppleIDIdentity * identity;                              //@synthesize identity=_identity - In the implementation block\n@property (nonatomic,retain) NSData * privateKeyPersistentReference;                    //@synthesize privateKeyPersistentReference=_privateKeyPersistentReference - In the implementation block\n@property (nonatomic,retain) SFAppleIDValidationRecord * validationRecord;              //@synthesize validationRecord=_validationRecord - In the implementation block\n+(BOOL)supportsSecureCoding;\n-(id)copyWithZone:(NSZone*)arg1 ;\n-(NSString *)altDSID;\n-(NSString *)appleID;\n-(NSString *)certificateToken;\n-(NSDate *)certificateTokenCreationDate;\n-(NSData *)privateKeyPersistentReference;\n-(SFAppleIDValidationRecord *)validationRecord;\n-(id)initWithAppleID:(id)arg1 ;\n-(void)setCertificateToken:(NSString *)arg1 ;\n-(void)setCertificateTokenCreationDate:(NSDate *)arg1 ;\n-(void)setContactInfo:(SFAppleIDContactInfo *)arg1 ;\n-(void)setValidationRecord:(SFAppleIDValidationRecord *)arg1 ;\n-(void)setPrivateKeyPersistentReference:(NSData *)arg1 ;\n-(BOOL)isEqualToAccount:(id)arg1 ;\n-(void)setAltDSID:(NSString *)arg1 ;\n-(BOOL)isEqual:(id)arg1 ;\n-(id)initWithCoder:(id)arg1 ;\n-(void)setIdentity:(SFAppleIDIdentity *)arg1 ;\n-(SFAppleIDIdentity *)identity;\n-(NSDate *)creationDate;\n-(void)encodeWithCoder:(id)arg1 ;\n-(id)initWithDictionary:(id)arg1 ;\n-(SFAppleIDContactInfo *)contactInfo;\n-(id)description;\n@end\n\n\n", "comment_ratio": 0.140625}
{"lang": "c", "code": "#pragma once\n#include \"Actor.h\"\n\nclass Bone : public Actor\n{\npublic:\n\tBone(Actor startFrame, Actor endFrame);//!<Create a Bone With a starting position and a ending position\n\t~Bone() {}\n\n\tbool update(double deltaTime) override; //!< Interpolate between Staring Frame and Ending Frame\n\tbool draw() override; //!< Draw each frame of animation\n\nprivate:\n\tActor m_startFrame;//!< The actor at the start of the animation\n\tActor m_endFrame; //!< Actor at the end of the animation\n};\n\n\n", "comment_ratio": 0.2777777777777778}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface CJCollectionModel : NSObject\n\n/** text*/\n@property (nonatomic ,copy) NSString    * text;\n\n@end\n\nNS_ASSUME_NONNULL_END\n\n", "comment_ratio": 0.3333333333333333}
{"lang": "c", "code": "// vim: set tabstop=2 softtabstop=2 shiftwidth=2 autoindent shiftround expandtab:\n/*\n  This file provides a Yorick wrapper around the functionality in triangle.c\n  and triangle.h.\n\n  The triangle.c and triangle.h files are copied from the Triangle program:\n    Triangle\n    A Two-Dimensional Quality Mesh Generator and Delaunay Triangulator.\n    Version 1.6\n\n  Downloaded from:\n    http://www.cs.cmu.edu/~quake/triangle.html\n\n  If a new release of Triangle comes out, it should be safe to replace the 1.6\n  files with the corresponding files from the new release. However, you will\n  have to make one small change to triangle.c in order for it to work with this\n  wrapper. Search for the string '#define TRILIBRARY' in triangle.c. It will be\n  commented out. You must define this symbol so that the software compiles as a\n  callable object library.\n*/\n\n#define REAL double\n#include <stdlib.h>\n#include \"triangle.h\"\n#include \"yapi.h\"\n\n// This will show up in Yorick as _ytriangulate.\n// It expects three arguments: char* opts, double *x, double *y\n// It returns: long *v\nvoid Y__ytriangulate(int argc)\n{\n  long xcount, ycount, dimsv[3], vcount, *v;\n  double *x, *y;\n  struct triangulateio in, out;\n  int i, j, k;\n  char *opts;\n\n  if(argc != 3)\n    y_error(\"triangulate requires exactly three arguments\");\n\n  // Grab the input from the stack\n  opts = ygeta_c(argc-1, 0, 0);\n  x = ygeta_d(argc-2, &xcount, 0);\n  y = ygeta_d(argc-3, &ycount, 0);\n\n  // Initialize input to triangulate\n  in.numberofpoints = xcount;\n  in.numberofpointattributes = 0;\n  in.pointlist = (REAL *) malloc(in.numberofpoints * 2 * sizeof(REAL));\n  in.pointattributelist = (REAL *) NULL;\n  in.pointmarkerlist = (int *) NULL;\n  in.numberofsegments = 0;\n  in.numberofholes = 0;\n  in.numberofregions = 0;\n  in.regionlist = (REAL *) NULL;\n\n  j = 0;\n  for(i = 0; i < xcount; i++) {\n    in.pointlist[j++] = x[i];\n    in.pointlist[j++] = y[i];\n  }\n\n  // Initialize output from triangulate\n  out.pointlist = (REAL *) NULL;\n  out.pointattributelist = (REAL *) NULL;\n  out.pointmarkerlist = (int *) NULL;\n  out.trianglelist = (int *) NULL;\n  out.triangleattributelist = (REAL *) NULL;\n\n  // Call triangulate, from triangle.i\n  triangulate(opts, &in, &out, (struct triangulateio *) NULL);\n\n  // Extract output and stuff in Yorick format\n  dimsv[0] = 2;\n  dimsv[1] = out.numberoftriangles;\n  dimsv[2] = out.numberofcorners;\n  vcount = out.numberoftriangles * out.numberofcorners;\n\n  v = ypush_l(dimsv);\n  k = 0;\n  for(i = 0; i < out.numberofcorners; i++)\n    for(j = i; j < vcount; j += out.numberofcorners)\n      v[k++] = out.trianglelist[j];\n\n  // Free the memory we consumed\n  free(in.pointlist);\n  free(out.pointlist);\n  free(out.pointattributelist);\n  free(out.pointmarkerlist);\n  free(out.trianglelist);\n  free(out.triangleattributelist);\n}\n\n", "comment_ratio": 0.11827956989247312}
{"lang": "c", "code": "// RUN: %bmc -bound 10 \"%s\" | FileCheck \"%s\"\n// RUN: %bmc -bound 10 -math-int \"%s\" | FileCheck \"%s\"\n\n// CHECK: Verification {{(SUCCESSFUL|BOUND REACHED)}}\nextern void __VERIFIER_error() __attribute__ ((__noreturn__));\n\nextern int __VERIFIER_nondet_int();\nint main()\n{\n    int p1 = __VERIFIER_nondet_int();  // condition variable\n    int lk1; // lock variable\n\n    int p2 = __VERIFIER_nondet_int();  // condition variable\n    int lk2; // lock variable\n\n    int p3 = __VERIFIER_nondet_int();  // condition variable\n    int lk3; // lock variable\n\n    int p4 = __VERIFIER_nondet_int();  // condition variable\n    int lk4; // lock variable\n\n    int p5 = __VERIFIER_nondet_int();  // condition variable\n    int lk5; // lock variable\n\n    int p6 = __VERIFIER_nondet_int();  // condition variable\n    int lk6; // lock variable\n\n    int p7 = __VERIFIER_nondet_int();  // condition variable\n    int lk7; // lock variable\n\n    int p8 = __VERIFIER_nondet_int();  // condition variable\n    int lk8; // lock variable\n\n    int p9 = __VERIFIER_nondet_int();  // condition variable\n    int lk9; // lock variable\n\n    int p10 = __VERIFIER_nondet_int();  // condition variable\n    int lk10; // lock variable\n\n    int p11 = __VERIFIER_nondet_int();  // condition variable\n    int lk11; // lock variable\n\n    int p12 = __VERIFIER_nondet_int();  // condition variable\n    int lk12; // lock variable\n\n    int p13 = __VERIFIER_nondet_int();  // condition variable\n    int lk13; // lock variable\n\n    int p14 = __VERIFIER_nondet_int();  // condition variable\n    int lk14; // lock variable\n\n    int p15 = __VERIFIER_nondet_int();  // condition variable\n    int lk15; // lock variable\n\n\n    int cond;\n\n    while(1) {\n        cond = __VERIFIER_nondet_int();\n        if (cond == 0) {\n            goto out;\n        } else {}\n        lk1 = 0; // initially lock is open\n\n        lk2 = 0; // initially lock is open\n\n        lk3 = 0; // initially lock is open\n\n        lk4 = 0; // initially lock is open\n\n        lk5 = 0; // initially lock is open\n\n        lk6 = 0; // initially lock is open\n\n        lk7 = 0; // initially lock is open\n\n        lk8 = 0; // initially lock is open\n\n        lk9 = 0; // initially lock is open\n\n        lk10 = 0; // initially lock is open\n\n        lk11 = 0; // initially lock is open\n\n        lk12 = 0; // initially lock is open\n\n        lk13 = 0; // initially lock is open\n\n        lk14 = 0; // initially lock is open\n\n        lk15 = 0; // initially lock is open\n\n\n    // lock phase\n        if (p1 != 0) {\n            lk1 = 1; // acquire lock\n        } else {}\n\n        if (p2 != 0) {\n            lk2 = 1; // acquire lock\n        } else {}\n\n        if (p3 != 0) {\n            lk3 = 1; // acquire lock\n        } else {}\n\n        if (p4 != 0) {\n            lk4 = 1; // acquire lock\n        } else {}\n\n        if (p5 != 0) {\n            lk5 = 1; // acquire lock\n        } else {}\n\n        if (p6 != 0) {\n            lk6 = 1; // acquire lock\n        } else {}\n\n        if (p7 != 0) {\n            lk7 = 1; // acquire lock\n        } else {}\n\n        if (p8 != 0) {\n            lk8 = 1; // acquire lock\n        } else {}\n\n        if (p9 != 0) {\n            lk9 = 1; // acquire lock\n        } else {}\n\n        if (p10 != 0) {\n            lk10 = 1; // acquire lock\n        } else {}\n\n        if (p11 != 0) {\n            lk11 = 1; // acquire lock\n        } else {}\n\n        if (p12 != 0) {\n            lk12 = 1; // acquire lock\n        } else {}\n\n        if (p13 != 0) {\n            lk13 = 1; // acquire lock\n        } else {}\n\n        if (p14 != 0) {\n            lk14 = 1; // acquire lock\n        } else {}\n\n        if (p15 != 0) {\n            lk15 = 1; // acquire lock\n        } else {}\n\n\n    // unlock phase\n        if (p1 != 0) {\n            if (lk1 != 1) goto ERROR; // assertion failure\n            lk1 = 0;\n        } else {}\n\n        if (p2 != 0) {\n            if (lk2 != 1) goto ERROR; // assertion failure\n            lk2 = 0;\n        } else {}\n\n        if (p3 != 0) {\n            if (lk3 != 1) goto ERROR; // assertion failure\n            lk3 = 0;\n        } else {}\n\n        if (p4 != 0) {\n            if (lk4 != 1) goto ERROR; // assertion failure\n            lk4 = 0;\n        } else {}\n\n        if (p5 != 0) {\n            if (lk5 != 1) goto ERROR; // assertion failure\n            lk5 = 0;\n        } else {}\n\n        if (p6 != 0) {\n            if (lk6 != 1) goto ERROR; // assertion failure\n            lk6 = 0;\n        } else {}\n\n        if (p7 != 0) {\n            if (lk7 != 1) goto ERROR; // assertion failure\n            lk7 = 0;\n        } else {}\n\n        if (p8 != 0) {\n            if (lk8 != 1) goto ERROR; // assertion failure\n            lk8 = 0;\n        } else {}\n\n        if (p9 != 0) {\n            if (lk9 != 1) goto ERROR; // assertion failure\n            lk9 = 0;\n        } else {}\n\n        if (p10 != 0) {\n            if (lk10 != 1) goto ERROR; // assertion failure\n            lk10 = 0;\n        } else {}\n\n        if (p11 != 0) {\n            if (lk11 != 1) goto ERROR; // assertion failure\n            lk11 = 0;\n        } else {}\n\n        if (p12 != 0) {\n            if (lk12 != 1) goto ERROR; // assertion failure\n            lk12 = 0;\n        } else {}\n\n        if (p13 != 0) {\n            if (lk13 != 1) goto ERROR; // assertion failure\n            lk13 = 0;\n        } else {}\n\n        if (p14 != 0) {\n            if (lk14 != 1) goto ERROR; // assertion failure\n            lk14 = 0;\n        } else {}\n\n        if (p15 != 0) {\n            if (lk15 != 1) goto ERROR; // assertion failure\n            lk15 = 0;\n        } else {}\n\n    }\n  out:\n    return 0;\n  ERROR: __VERIFIER_error();\n    return 0;  \n}\n\n\n", "comment_ratio": 0.33472803347280333}
{"lang": "c", "code": "#ifndef SETTINGS_H_\n#define SETTINGS_H_\n\n#include \"outputs.h\"\n\n#define LCD_BACKLIGHT_PARAM_ADDR\t0x0000\n\n#define OUTPUTS_STATE\t\t\t\t0x0001\n\n#define\tOUTPUT1_FROM_HOUR\t\t\t0x0002\n#define\tOUTPUT1_FROM_MINUTE\t\t\t0x0003\n#define\tOUTPUT1_TO_HOUR\t\t\t\t0x0004\n#define\tOUTPUT1_TO_MINUTE\t\t\t0x0005\n\n#define\tOUTPUT2_FROM_HOUR\t\t\t0x0006\n#define\tOUTPUT2_FROM_MINUTE\t\t\t0x0007\n#define\tOUTPUT2_TO_HOUR\t\t\t\t0x0008\n#define\tOUTPUT2_TO_MINUTE\t\t\t0x0009\n\n#define\tOUTPUT3_FROM_HOUR\t\t\t0x000A\n#define\tOUTPUT3_FROM_MINUTE\t\t\t0x000B\n#define\tOUTPUT3_TO_HOUR\t\t\t\t0x000C\n#define\tOUTPUT3_TO_MINUTE\t\t\t0x000D\n\n#define\tOUTPUT4_FROM_HOUR\t\t\t0x000E\n#define\tOUTPUT4_FROM_MINUTE\t\t\t0x000F\n#define\tOUTPUT4_TO_HOUR\t\t\t\t0x0010\n#define\tOUTPUT4_TO_MINUTE\t\t\t0x0011\n\n#define\tOUTPUT5_FROM_HOUR\t\t\t0x0012\n#define\tOUTPUT5_FROM_MINUTE\t\t\t0x0013\n#define\tOUTPUT5_TO_HOUR\t\t\t\t0x0014\n#define\tOUTPUT5_TO_MINUTE\t\t\t0x0015\n\n#define OUTPUT1_MODE\t\t\t\t0x0016\n#define OUTPUT2_MODE\t\t\t\t0x0017\n#define OUTPUT3_MODE\t\t\t\t0x0018\n#define OUTPUT4_MODE\t\t\t\t0x0019\n#define OUTPUT5_MODE\t\t\t\t0x001A\n\n#define OUTPUT1_TEMPERATURE\t\t\t0x001B // 1B 1C 1D 1E\n#define OUTPUT2_TEMPERATURE\t\t\t0x001F // 1F 20 21 22\n#define OUTPUT3_TEMPERATURE\t\t\t0x0023 // 23 24 25 26\n#define OUTPUT4_TEMPERATURE\t\t\t0x0027 // 27 28 29 2A\n#define OUTPUT5_TEMPERATURE\t\t\t0x002B // 2B 2C 2D 2E\n\n#define OUTPUT1_LUMINANCE\t\t\t0x002F // 2F 30\n#define OUTPUT2_LUMINANCE\t\t\t0x0031 // 31 32\n#define OUTPUT3_LUMINANCE\t\t\t0x0033 // 33 34\n#define OUTPUT4_LUMINANCE\t\t\t0x0035 // 35 36\n#define OUTPUT5_LUMINANCE\t\t\t0x0037 // 37 38\n\n#define OUTPUT1_HYSTERESIS\t\t\t0x0043 // 43 44 45 46\n#define OUTPUT2_HYSTERESIS\t\t\t0x0047 // 47 48 49 4A\n#define OUTPUT3_HYSTERESIS\t\t\t0x004B // 4B 4C 4D 4E\n#define OUTPUT4_HYSTERESIS\t\t\t0x004F // 4F 50 51 52\n#define OUTPUT5_HYSTERESIS\t\t\t0x0053 // 53 54 55 56\n\n#define IP_PARAM_ADDR\t\t\t\t0x0057 // 57 58 59 5A\n#define PORT_PARAM_ADDR\t\t\t\t0x005B\n\n// DEFAULT VALUES\n\n#define LCD_BACKLIGHT_DEFAULT_VALUE\t\t\t128\n\n#define\tOUTPUT1_TIMER_DEFAULT_VALUE\t\t\t0x00000000\n#define\tOUTPUT2_TIMER_DEFAULT_VALUE\t\t\t0x00000000\n#define\tOUTPUT3_TIMER_DEFAULT_VALUE\t\t\t0x00000000\n#define\tOUTPUT4_TIMER_DEFAULT_VALUE\t\t\t0x00000000\n#define\tOUTPUT5_TIMER_DEFAULT_VALUE\t\t\t0x00000000\n\n#define OUTPUT1_MODE_DEFAULT_VALUE\t\t\tOUT_MODE_MANUAL\n#define OUTPUT2_MODE_DEFAULT_VALUE\t\t\tOUT_MODE_MANUAL\n#define OUTPUT3_MODE_DEFAULT_VALUE\t\t\tOUT_MODE_MANUAL\n#define OUTPUT4_MODE_DEFAULT_VALUE\t\t\tOUT_MODE_MANUAL\n#define OUTPUT5_MODE_DEFAULT_VALUE\t\t\tOUT_MODE_MANUAL\n\n#define OUTPUT1_TEMPERATURE_DEFAULT_VALUE\t25.00\n#define OUTPUT2_TEMPERATURE_DEFAULT_VALUE\t25.00\n#define OUTPUT3_TEMPERATURE_DEFAULT_VALUE\t25.00\n#define OUTPUT4_TEMPERATURE_DEFAULT_VALUE\t25.00\n#define OUTPUT5_TEMPERATURE_DEFAULT_VALUE\t25.00\n\n#define OUTPUT1_LUMINANCE_DEFAULT_VALUE\t\t20\n#define OUTPUT2_LUMINANCE_DEFAULT_VALUE\t\t20\n#define OUTPUT3_LUMINANCE_DEFAULT_VALUE\t\t20\n#define OUTPUT4_LUMINANCE_DEFAULT_VALUE\t\t20\n#define OUTPUT5_LUMINANCE_DEFAULT_VALUE\t\t20\n\n#define OUTPUT1_HYSTERESIS_DEFAULT_VALUE\t0.5\n#define OUTPUT2_HYSTERESIS_DEFAULT_VALUE\t0.5\n#define OUTPUT3_HYSTERESIS_DEFAULT_VALUE\t0.5\n#define OUTPUT4_HYSTERESIS_DEFAULT_VALUE\t0.5\n#define OUTPUT5_HYSTERESIS_DEFAULT_VALUE\t0.5\n\n#define IP_ADDRESS_DEFAULT_VALUE\t\t\t0xFE01A8C0  //\t192.168.1.254\n#define PORT_DEFAULT_VALUE\t\t\t\t\t0x0A\t\t//\t10\n\nvoid loadDefaultSettings();\n\n#endif /* SETTINGS_H_ */\n\n", "comment_ratio": 0.18627450980392157}
{"lang": "c", "code": "#ifndef FLUTTER_SHELL_PLATFORM_DARWIN_COMMON_BUFFER_CONVERSIONS_H_\n#define FLUTTER_SHELL_PLATFORM_DARWIN_COMMON_BUFFER_CONVERSIONS_H_\n\n#include <Foundation/Foundation.h>\n\n#include <vector>\n\n#include \"flutter/fml/mapping.h\"\n\nnamespace flutter {\n\nfml::MallocMapping CopyNSDataToMapping(NSData* data);\n\nNSData* ConvertMappingToNSData(fml::MallocMapping buffer);\n\nstd::unique_ptr<fml::Mapping> ConvertNSDataToMappingPtr(NSData* data);\n\nNSData* CopyMappingPtrToNSData(std::unique_ptr<fml::Mapping> mapping);\n\n}  // namespace flutter\n\n#endif  // FLUTTER_SHELL_PLATFORM_DARWIN_COMMON_BUFFER_CONVERSIONS_H_\n\n", "comment_ratio": 0.18518518518518517}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n\n#import \"AppCenter+Internal.h\"\n#import \"MSNoAutoAssignSessionIdLog.h\"\n\n@interface MSStartSessionLog : MSAbstractLog <MSNoAutoAssignSessionIdLog>\n\n@end\n\n", "comment_ratio": 0.16666666666666666}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n\n\n@interface UIViewController (LRFViewControllerStyle)\n\n+ (void)lrf_styleAddWithIdentifier:(NSString *)identifier style:(void(^)(UIViewController *vc))style;\n\n+ (void)lrf_styleSetupDefaultIdentifier:(NSString *)identifier;\n\n@property (nonatomic, copy) NSString *lrf_styleIdentifier;\n\n@end\n\n\n", "comment_ratio": 0.3181818181818182}
{"lang": "c", "code": "#ifndef CC_LAYERS_SURFACE_LAYER_IMPL_H_\n#define CC_LAYERS_SURFACE_LAYER_IMPL_H_\n\n#include \"base/macros.h\"\n#include \"base/memory/scoped_ptr.h\"\n#include \"cc/base/cc_export.h\"\n#include \"cc/layers/layer_impl.h\"\n#include \"cc/surfaces/surface_id.h\"\n\nnamespace cc {\n\nclass CC_EXPORT SurfaceLayerImpl : public LayerImpl {\n public:\n  static scoped_ptr<SurfaceLayerImpl> Create(LayerTreeImpl* tree_impl, int id) {\n    return make_scoped_ptr(new SurfaceLayerImpl(tree_impl, id));\n  }\n  ~SurfaceLayerImpl() override;\n\n  void SetSurfaceId(SurfaceId surface_id);\n  void SetSurfaceScale(float scale);\n  void SetSurfaceSize(const gfx::Size& size);\n  SurfaceId surface_id() const { return surface_id_; }\n\n  // LayerImpl overrides.\n  scoped_ptr<LayerImpl> CreateLayerImpl(LayerTreeImpl* tree_impl) override;\n  void PushPropertiesTo(LayerImpl* layer) override;\n  void AppendQuads(RenderPass* render_pass,\n                   AppendQuadsData* append_quads_data) override;\n\n protected:\n  SurfaceLayerImpl(LayerTreeImpl* tree_impl, int id);\n\n private:\n  void GetDebugBorderProperties(SkColor* color, float* width) const override;\n  void AppendRainbowDebugBorder(RenderPass* render_pass);\n  void AsValueInto(base::trace_event::TracedValue* dict) const override;\n  const char* LayerTypeAsString() const override;\n\n  SurfaceId surface_id_;\n  gfx::Size surface_size_;\n  float surface_scale_;\n\n  DISALLOW_COPY_AND_ASSIGN(SurfaceLayerImpl);\n};\n\n}  // namespace cc\n\n#endif  // CC_LAYERS_SURFACE_LAYER_IMPL_H_\n\n", "comment_ratio": 0.11320754716981132}
{"lang": "c", "code": "#import <string>\n\nclass Widget {\n public:\n  Widget(int number, const std::string& name);\n  ~Widget();\n\n  // Public accessors to number data\n  float GetFloatValue() const;\n  int GetIntValue() const;\n\n  // Public accessors to the string data\n  std::string GetStringValue() const;\n  void GetCharPtrValue(char* buffer, size_t max_size) const;\n\n private:\n  // Data members\n  float number_;\n  std::string name_;\n};\n\n", "comment_ratio": 0.18181818181818182}
{"lang": "c", "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <libacars/asn1/FANSATCDownlinkMessage.h>\t// asn_DEF_FANSATCDownlinkMessage\n#include <libacars/asn1/FANSATCUplinkMessage.h>\t\t// asn_DEF_FANSATCUplinkMessage\n#include <libacars/asn1/asn_application.h>\t\t// asn_sprintf()\n#include <libacars/macros.h>\t\t\t\t// la_assert\n#include <libacars/asn1-util.h>\t\t\t\t// la_asn1_decode_as()\n#include <libacars/asn1-format-cpdlc.h>\t\t\t// la_asn1_output_cpdlc()\n#include <libacars/cpdlc.h>\t\t\t\t// la_cpdlc_msg\n#include <libacars/libacars.h>\t\t\t\t// la_proto_node, la_config, la_proto_tree_find_protocol\n#include <libacars/util.h>\t\t\t\t// la_debug_print(), LA_CAST_PTR\n#include <libacars/vstring.h>\t\t\t\t// la_vstring, la_vstring_append_sprintf()\n\nla_proto_node *la_cpdlc_parse(uint8_t *buf, int len, la_msg_dir const msg_dir) {\n\tif(buf == NULL)\n\t\treturn NULL;\n\n\tla_proto_node *node = la_proto_node_new();\n\tla_cpdlc_msg *msg = LA_XCALLOC(1, sizeof(la_cpdlc_msg));\n\tnode->data = msg;\n\tnode->td = &la_DEF_cpdlc_message;\n\n\tif(msg_dir == LA_MSG_DIR_GND2AIR) {\n\t\tmsg->asn_type = &asn_DEF_FANSATCUplinkMessage;\n\t} else if(msg_dir == LA_MSG_DIR_AIR2GND) {\n\t\tmsg->asn_type = &asn_DEF_FANSATCDownlinkMessage;\n\t}\n\tla_assert(msg->asn_type != NULL);\n\tif(len == 0) {\n// empty payload is not an error\n\t\tla_debug_print(\"%s\", \"Empty CPDLC message, decoding skipped\\n\");\n\t\treturn node;\n\t}\n\n\tla_debug_print(\"Decoding as %s, len: %d\\n\", msg->asn_type->name, len);\n\tif(la_asn1_decode_as(msg->asn_type, &msg->data, buf, len) != 0) {\n\t\tmsg->err = true;\n\t} else {\n\t\tmsg->err = false;\n\t}\n\treturn node;\n}\n\nvoid la_cpdlc_format_text(la_vstring *vstr, void const * const data, int indent) {\n\tla_assert(vstr);\n\tla_assert(data);\n\tla_assert(indent >= 0);\n\n\tLA_CAST_PTR(msg, la_cpdlc_msg *, data);\n\tif(msg->err == true) {\n\t\tLA_ISPRINTF(vstr, indent, \"%s\", \"-- Unparseable FANS-1/A message\\n\");\n\t\treturn;\n\t}\n\tif(msg->asn_type != NULL) {\n\t\tif(msg->data != NULL) {\n\t\t\tif(la_config.dump_asn1) {\n\t\t\t\t// asn_fprint does not indent the first line\n\t\t\t\tif(indent > 0) {\n\t\t\t\t\tLA_ISPRINTF(vstr, indent * 4, \"%s\", \"\");\n\t\t\t\t}\n\t\t\t\tasn_sprintf(vstr, msg->asn_type, msg->data, indent+1);\n\t\t\t}\n\t\t\tla_asn1_output_cpdlc_as_text(vstr, msg->asn_type, msg->data, indent);\n\t\t} else {\n\t\t\tLA_ISPRINTF(vstr, indent, \"%s\\n\", \"-- <empty PDU>\");\n\t\t}\n\t}\n}\n\nvoid la_cpdlc_destroy(void *data) {\n\tif(data == NULL) {\n\t\treturn;\n\t}\n\tLA_CAST_PTR(msg, la_cpdlc_msg *, data);\n\tif(msg->asn_type != NULL) {\n\t\tmsg->asn_type->free_struct(msg->asn_type, msg->data, 0);\n\t}\n\tLA_XFREE(data);\n}\n\nla_type_descriptor const la_DEF_cpdlc_message = {\n\t.format_text = la_cpdlc_format_text,\n\t.destroy = la_cpdlc_destroy\n};\n\nla_proto_node *la_proto_tree_find_cpdlc(la_proto_node *root) {\n\treturn la_proto_tree_find_protocol(root, &la_DEF_cpdlc_message);\n}\n\n", "comment_ratio": 0.12371134020618557}
{"lang": "c", "code": "#include \"clockMain.h\"\n#include \"clockspiffs.h\"\n\nstatic const char *TAG=\"clockspiffs\";\n\n/* Function to initialize SPIFFS */\nesp_err_t init_spiffs(void) // from: /home/c/esp/esp-idf/examples/protocols/http_server/file_serving/main/main.c\n{\n    ESP_LOGI(TAG, \"Initializing SPIFFS on core %d\", xPortGetCoreID());\n\n    esp_vfs_spiffs_conf_t conf = {\n      .base_path = \"/spiffs\", // no trailing / ? must match clockServer\n      .partition_label = NULL,\n      // wch: not sure about the following; 10 works even when the package already has ~25\n      .max_files = 30,   // This decides the maximum number of files that can be created on the storage\n      .format_if_mount_failed = false // reformatting can not help, we need these files!\n    };\n\n    esp_err_t ret = esp_vfs_spiffs_register(&conf);\n    if (ret != ESP_OK) {\n        if (ret == ESP_FAIL) {\n            ESP_LOGE(TAG, \"Failed to mount or format filesystem\");\n        } else if (ret == ESP_ERR_NOT_FOUND) {\n            ESP_LOGE(TAG, \"Failed to find SPIFFS partition\");\n        } else {\n            ESP_LOGE(TAG, \"Failed to initialize SPIFFS (%s)\", esp_err_to_name(ret));\n        }\n        return ESP_FAIL;\n    }\n\n//    size_t total = 0, used = 0;\n//    ret = esp_spiffs_info(NULL, &total, &used);\n//    if (ret != ESP_OK) {\n//        ESP_LOGE(TAG, \"Failed to get SPIFFS partition information (%s)\", esp_err_to_name(ret));\n//        return ESP_FAIL;\n//    }\n//\n//    ESP_LOGI(TAG, \"Partition size: total: %d, used: %d  (on core %d)\", total, used, xPortGetCoreID());\n    return ESP_OK;\n}\n\n", "comment_ratio": 0.25}
{"lang": "c", "code": "#include <stdlib.h>\n#include <stdio.h>\n\n#include \"mpegts_pat.h\"\n#include \"mpegts_header.h\"\n#include \"utils.h\"\n\nmpegts_pat* create_pat_from_ts_packet(char* ts_packet){\n    unsigned int x = get_header_from_ts(ts_packet);\n    mpegts_header h;\n    read_ts_packet_header(&h, ts_packet);\n    if(h.pid != 0){\n        fprintf(stderr, \"ts packet does not have PID of 0, corresponding to PAT\\n\");\n        return NULL;\n        }\n    mpegts_pat *p = (mpegts_pat*) malloc(sizeof(mpegts_pat));\n\n    // everything we read is after the header, so we always \n    // add 4 to ts_packet\n\n    // table id, first 8 bits;\n    p->table_id = (unsigned int) (ts_packet[4]);\n    p->section_syntax_indicator = (unsigned int) ((ts_packet[5] & 0x80) >> 7);\n    p->zero = (unsigned int) ((ts_packet[5] & 0x40)) >> 6;\n    // reserved 2 bits\n    // section length is 12 bits long, and starts after bit 12\n    // so bits 13 through 24 after the header\n    unsigned int x_section_length = charptr_to_unsigned_int_big_endian(ts_packet + 5);\n    p->section_length = (x_section_length & 0x0FFF0000) >> 16;\n\n    // ts is are bytes 7 and 8 from the beginning of the packet\n    p->transport_stream_id = charptr_to_unsigned_int_big_endian(ts_packet + 7) >> 16;\n\n    // 2nd reserved field = first 2 bits of byte 9\n    p->reserved2 = (unsigned int) ((ts_packet[9] & 0xC0) >> 6);\n\n    // version number = bits 3 to 7 of byte 9\n    p->version_number = (unsigned int) ((ts_packet[9] & 0x3E) >> 1);\n\n    // current next indicator = last bit of byte 9;\n    p->current_next_indicator = (unsigned int) ts_packet[9] & 0x01;\n\n    // section number is byte 10, last section is byte 11;\n    p->section_number = ((unsigned int) ts_packet[10]) & 0xFF;\n    p->last_section_number = (unsigned int) ts_packet[11] & 0xFF;\n\n    // \n\n    return p;\n}\n\nvoid print_pat(mpegts_pat* p){\n    printf(\"table_id: %x\\n\", p->table_id);\n    printf(\"section_syntax: %x\\n\", p->section_syntax_indicator);\n    printf(\"zero: %x\\n\", p->zero);\n    printf(\"section_length: %x\\n\", p->section_length);\n    printf(\"transport stream id: %x\\n\", p->transport_stream_id);\n    printf(\"version number: %x\\n\",p->version_number);\n    printf(\"current next indicator: %x\\n\",p->current_next_indicator);\n\n    printf(\"section number: %x\\n\", p->section_number);\n    printf(\"last section number: %x\\n\", p->last_section_number);\n\n    return;\n}\n\nvoid delete_pat(mpegts_pat* p){\n    if(p && p->programs)\n        free(p->programs);\n    if(p)\n        free(p);\n    return;\n}\n\n", "comment_ratio": 0.16216216216216217}
{"lang": "c", "code": "@class NSArray, NSSet;\n\n@protocol NSPrintPanelAccessorizing\n- (NSArray *)localizedSummaryItems;\n\n@optional\n- (NSSet *)keyPathsForValuesAffectingPreview;\n@end\n\n\n", "comment_ratio": 0.3125}
{"lang": "c", "code": "#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_READABILITY_FUNCTIONSIZECHECK_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_READABILITY_FUNCTIONSIZECHECK_H\n\n#include \"../ClangTidy.h\"\n\nnamespace clang {\nnamespace tidy {\nnamespace readability {\n\n/// \\brief Checks for large functions based on various metrics.\nclass FunctionSizeCheck : public ClangTidyCheck {\npublic:\n  FunctionSizeCheck(StringRef Name, ClangTidyContext *Context);\n\n  void storeOptions(ClangTidyOptions::OptionMap &Opts) override;\n  void registerMatchers(ast_matchers::MatchFinder *Finder) override;\n  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;\n  void onEndOfTranslationUnit() override;\n\nprivate:\n  struct FunctionInfo {\n    FunctionInfo() : Lines(0), Statements(0), Branches(0) {}\n    unsigned Lines;\n    unsigned Statements;\n    unsigned Branches;\n  };\n\n  const unsigned LineThreshold;\n  const unsigned StatementThreshold;\n  const unsigned BranchThreshold;\n\n  llvm::DenseMap<const FunctionDecl *, FunctionInfo> FunctionInfos;\n};\n\n} // namespace readability\n} // namespace tidy\n} // namespace clang\n\n#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_READABILITY_FUNCTIONSIZECHECK_H\n\n", "comment_ratio": 0.2653061224489796}
{"lang": "c", "code": "#ifndef ONNC_IR_COMPUTE_OPERATOR_MAXROIPOOL_H\n#define ONNC_IR_COMPUTE_OPERATOR_MAXROIPOOL_H\n#include <onnc/IR/ComputeOperator.h>\n#include <onnc/IR/ComputeVisitor.h>\n#include <onnc/IR/Compute/Attributes.h>\n#include <onnc/Support/IOStream.h>\n\nnamespace onnc {\n\nclass MaxRoiPool : public ComputeOperator\n{\npublic:\n  enum IOConst {\n    kX = 0,\n    kRois = 1,\n    kY = 0\n  };\n\n  static char ID;\n\npublic:\n  MaxRoiPool(const IntsAttr& pPooledShape);\n\n  // clang-format off\n  MaxRoiPool(const IntsAttr& pPooledShape,\n             const FloatAttr& pSpatialScale);\n\n  // clang-format on\n\n  // shallow copy constructor.\n  MaxRoiPool(const MaxRoiPool &pCopy);\n\n  virtual ~MaxRoiPool() { }\n\n  // clang-format off\n  // Attributes getters\n  const IntsAttr& getPooledShape() const { return m_PooledShape; }\n\n  const FloatAttr& getSpatialScale() const { return m_SpatialScale; }\n\n\n  // Attributes setters\n  void setPooledShape(const IntsAttr& pPooledShape) { m_PooledShape = pPooledShape; }\n\n  void setSpatialScale(const FloatAttr& pSpatialScale) { m_SpatialScale = pSpatialScale; }\n\n  // clang-format on\n\n  Tensor* getInput(unsigned int pIdx) override { return static_cast<Tensor*>(m_Inputs[pIdx]); }\n\n  const Tensor* getInput(unsigned int pIdx) const override { return static_cast<Tensor*>(m_Inputs[pIdx]); }\n\n  Tensor* getOutput(unsigned int pIdx) override { return static_cast<Tensor*>(m_Outputs[pIdx]); }\n\n  const Tensor* getOutput(unsigned int pIdx) const override { return static_cast<Tensor*>(m_Outputs[pIdx]); }\n\n  // clang-format off\n  // Inputs getters\n  const Tensor* getX() const { return getInput(kX); }\n\n  const Tensor* getRois() const { return getInput(kRois); }\n\n  Tensor* getX() { return getInput(kX); }\n\n  Tensor* getRois() { return getInput(kRois); }\n\n\n  // Outputs getters\n  const Tensor* getY() const { return getOutput(kY); }\n\n  Tensor* getY() { return getOutput(kY); }\n\n\n  // Inputs setters\n  void setX(Tensor& pTensor) { m_Inputs[kX] = &pTensor; }\n\n  void setRois(Tensor& pTensor) { m_Inputs[kRois] = &pTensor; }\n\n\n  // Outputs setters\n  void setY(Tensor& pTensor) { m_Outputs[kY] = &pTensor; }\n\n  // clang-format on\n\n  void printAttributes(std::ostream& pOS) const override;\n\n  void accept(ComputeVisitor& pVisitor) override { pVisitor.visit(*this); }\n\n  void accept(ComputeVisitor& pVisitor) const override { pVisitor.visit(*this); }\n\n  static bool classof(const ComputeOperator* pOp);\n\nprotected:\n  // clang-format off\n  IntsAttr m_PooledShape;\n  FloatAttr m_SpatialScale;\n  // clang-format on\n};\n\n} // namespace of onnc\n\n#endif\n\n", "comment_ratio": 0.20909090909090908}
{"lang": "c", "code": "#pragma once\n\n#include \"Components/ActorComponent.h\"\n#include \"CoverPropertiesComponent.generated.h\"\n\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass SOFTDESIGNTRAINING_API UCoverPropertiesComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this component's properties\n\tUCoverPropertiesComponent();\n\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\t\n\t// Called every frame\n\tvirtual void TickComponent( float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction ) override;\n\n    UPROPERTY(EditAnywhere)\n    bool CoverEnabled;\n\n    UPROPERTY(EditAnywhere)\n    float CoverCostMS;\n\t\n};\n\n", "comment_ratio": 0.12903225806451613}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n\n@interface AppDelegate : UIResponder <UIApplicationDelegate>\n\n@property (strong, nonatomic) UIWindow *window;\n\n\n@end\n\n\n", "comment_ratio": 0.3888888888888889}
{"lang": "c", "code": "////////////////////////////////////////////////////////////////////////////////\n// Filename: FSpotLight.h\n////////////////////////////////////////////////////////////////////////////////\n#ifndef _FSpotLight_H_\n#define _FSpotLight_H_\n\n/////////////\n// LINKING //\n/////////////\n\n//////////////\n// INCLUDES //\n//////////////\n#include \"..\\..\\..\\Core\\Entity\\Actor\\FActor.h\"\n\n// Say that the FLight class exist\nclass FLight;\n\n/////////////\n// DEFINES //\n/////////////\n\n////////////////////////////////////////////////////////////////////////////////\n// Class name: FSpotLight\n////////////////////////////////////////////////////////////////////////////////\nclass FSpotLight : public FActor\n{\nprivate:\n\n\t// Actor is a friend class\n\tfriend FActor;\n\tfriend IEntity;\n\npublic:\n\n\t// Set the light color\n\tvoid SetColor(WVector3 _color);\n\nprotected:\n\n\t// Constructor and destructor are private and we can only share ptrs (copy-constructor is private too)\n\tFSpotLight();\n\tFSpotLight(const FSpotLight&);\n\t~FSpotLight();\n\n\t// Update this ship\n\tvirtual void Update(float _time);\n\n\t// Set the light\n\tvoid SetLight(FLight* _light);\n\n\t// Return if we should keep track of this (if false, no pick or collision functions will have effect on this object)\n\tbool ShouldKeepTrack(){ return false; };\n\nprivate:\n\n\t// The light\n\tFLight* m_Light;\n\n};\n\n#endif\n\n", "comment_ratio": 0.36507936507936506}
{"lang": "c", "code": "#include \"config.h\"\n#include \"extern_variable.h\"\n\n\n\nchar SysClock;       //\u7533\u8bf7\u5b58\u50a8\u7cfb\u7edf\u65f6\u949f\u53d8\u91cf\uff0c\u5355\u4f4dMHz\n\n/********************************************\n           \u7cfb\u7edf\u4e2d\u65ad\u4f18\u5148\u7ea7\u914d\u7f6e\n\u529f\u80fd\uff1a\n1.\u5404\u4e2a\u4e2d\u65ad\u4f18\u5148\u7ea7\u914d\u7f6e\u51fd\u6570\u7edf\u4e00\u5c01\u88c5\u4e3a\uff1a\u4e2d\u65ad\u4f18\u5148\u7ea7\u914d\u7f6e\u521d\u59cb\u5316\n********************************************/\nvoid NVIC_INIT(void)\n{\n    TimerNVIC_Configuration();//\u5b9a\u65f6\u5668\u4e2d\u65ad\u914d\u7f6e\n    UART1NVIC_Configuration();//\u4e32\u53e31\u4e2d\u65ad\u914d\u7f6e\n}\n//\u4e0d\u80fd\u5728\u8fd9\u91cc\u6267\u884c\u6240\u6709\u5916\u8bbe\u590d\u4f4d!\u5426\u5219\u81f3\u5c11\u5f15\u8d77\u4e32\u53e3\u4e0d\u5de5\u4f5c.\n//\u628a\u6240\u6709\u65f6\u949f\u5bc4\u5b58\u5668\u590d\u4f4d\nvoid MYRCC_DeInit(void)\n{\n    RCC->APB1RSTR = 0x00000000;//\u590d\u4f4d\u7ed3\u675f\n    RCC->APB2RSTR = 0x00000000;\n\n    RCC->AHBENR = 0x00000014;  //\u7761\u7720\u6a21\u5f0f\u95ea\u5b58\u548cSRAM\u65f6\u949f\u4f7f\u80fd.\u5176\u4ed6\u5173\u95ed.\n    RCC->APB2ENR = 0x00000000; //\u5916\u8bbe\u65f6\u949f\u5173\u95ed.\n    RCC->APB1ENR = 0x00000000;\n    RCC->CR |= 0x00000001;     //\u4f7f\u80fd\u5185\u90e8\u9ad8\u901f\u65f6\u949fHSION\n    RCC->CFGR &= 0xF8FF0000;   //\u590d\u4f4dSW[1:0],HPRE[3:0],PPRE1[2:0],PPRE2[2:0],ADCPRE[1:0],MCO[2:0]\n    RCC->CR &= 0xFEF6FFFF;     //\u590d\u4f4dHSEON,CSSON,PLLON\n    RCC->CR &= 0xFFFBFFFF;     //\u590d\u4f4dHSEBYP\n    RCC->CFGR &= 0xFF80FFFF;   //\u590d\u4f4dPLLSRC, PLLXTPRE, PLLMUL[3:0] and USBPRE\n    RCC->CIR = 0x00000000;     //\u5173\u95ed\u6240\u6709\u4e2d\u65ad\n}\n\n\n/********************************************\n           \u4f7f\u7528\u5185\u90e8DCO\u914d\u7f6e\u7cfb\u7edf\u65f6\u949f\n\u529f\u80fd\uff1a\n1.\u4f7f\u7528\u5185\u90e8HSI\u65f6\u949f\u4e8c\u5206\u9891\uff084MHz\uff09\u4f5c\u4e3aPLL\u8f93\u5165\n2.PLL\u500d\u9891\u7cfb\u6570PLLMUL<=9(\u5b9e\u9645\u5230\u8fbe13\u65f6\uff0c\u8fd8\u80fd\u6b63\u5e38\u500d\u9891\u5185\u90e8\u65f6\u949f)\n3.\u8f93\u5165\u53c2\u6570\uff1aPLLMUL\uff0cPLL\u500d\u9891\u7cfb\u6570\n4.\u5907\u6ce8\uff1a\u5b98\u65b9\u624b\u518c\u4e0a\u8bf4\uff0c\u4f7f\u7528HSI\u65f6\uff0c\u6700\u9ad8\u5230\u8fbe\u523036M\uff0c\u5b9e\u9645\u53ef\u4ee5\u8fbe\u523052M\u3002\n********************************************/\nchar SystemClock_HSI(u8 PLL)\n{\n    RCC->CR|=1<<0;              //\u5185\u90e8\u9ad8\u901f\u65f6\u949f\u4f7f\u80fd\n    RCC->CR|=0<<16;              //\u5916\u90e8\u9ad8\u901f\u65f6\u949f\u5173\u95ed\n    RCC->CR|=1<<18;\n    while(!((RCC->CR)&(1<<1))); //\u7b49\u5f85\u5185\u90e8\u65f6\u949f\u7a33\u5b9a\u5c31\u7eea\n    RCC->CFGR|=(PLL-2)<<18;     //PPL\u500d\u9891\u7cfb\u6570\n    RCC->CFGR|=0<<16;           //PPL\u8f93\u5165\u65f6\u949f\u6e90,HSI\u4e8c\u5206\u9891\u540e\u4f5c\u4e3aPLL\u8f93\u5165\u6e90=4MHz\n    RCC->CR|=1<<24;             //PLL\u4f7f\u80fd\n    while(!((RCC->CR)&(1<<25)));//\u7b49\u5f85PLL\u7a33\u5b9a\n    RCC->CFGR|=2<<0;            //\u7cfb\u7edf\u65f6\u949f\u6e90\u914d\u7f6e\uff0cPLL\u8f93\u51fa\u4f5c\u4e3a\u7cfb\u7edf\u65f6\u949f\n    SysClock=4*PLL;             //\u8fd4\u56de\u7cfb\u7edf\u65f6\u949f\uff0c\u5355\u4f4dMHz\n    return SysClock;\n}\n\n\n/********************************************\n           \u4f7f\u7528\u5916\u90e8\u6676\u4f53\u4f5c\u4e3a\u7cfb\u7edf\u65f6\u949f\u6e90\n\u529f\u80fd\uff1a\n1.\u4f7f\u7528\u5916\u90e8HSE\u65f6\u949f8M\u4f5c\u4e3aPLL\u8f93\u5165\n2.PLL\u500d\u9891\u7cfb\u6570PLLMUL<=9(\u5b9e\u9645\u5230\u8fbe16\u65f6\uff0c\u8fd8\u80fd\u6b63\u5e38\u500d\u9891\u5916\u90e8\u65f6\u949f)\n3.\u8f93\u5165\u53c2\u6570\uff1aPLLMUL\uff0cPLL\u500d\u9891\u7cfb\u6570\n4.\u5907\u6ce8\uff1a\u5b98\u65b9\u624b\u518c\u4e0a\u8bf4\uff0c\u4f7f\u7528HSE\u4f5c\u4e3a\u7cfb\u7edf\u65f6\u949f\u6e90\u65f6\uff0c\u6700\u9ad8\u53ef\u500d\u9891\u523072MHz\uff0c\u4f46\u662f\u5b9e\u9645\u53ef\u4ee5\u500d\u9891\u5230128M\u7cfb\u7edf\u8fd8\u7b97\u7a33\u5b9a\n********************************************/\n//\u7cfb\u7edf\u65f6\u949f\u521d\u59cb\u5316\u51fd\u6570\n//pll:\u9009\u62e9\u7684\u500d\u9891\u6570\uff0c\u4ece2\u5f00\u59cb\uff0c\u6700\u5927\u503c\u4e3a16\n//\u65f6\u949f\u6e90\u4e3a\u5916\u90e8\u6676\u632f\n//\u5907\u6ce8\uff1a\u5f53\u673a\u8eab\u710a\u63a5\u4e868M\u6676\u632f\u65f6\uff0c\u5c31\u53ea\u80fd\u4f7f\u7528\u5916\u90e88M\u6676\u632f\u4f5c\u4e3a\u65f6\u949f\u6e90\uff0c\n//      \u7528\u5185\u90e8\u7684HSI\u4e0d\u597d\u4f7f\uff0c\u6211\u53cd\u6b63\u6ca1\u8c03\u51fa\u6765\uff0c\u770b\u5404\u4f4d\u6709\u5565\u529e\u6cd5\u6ca1\nchar SystemClock_HSE(u8 PLL)\n{\n    unsigned char temp=0;\n    MYRCC_DeInit();\t\t    //\u590d\u4f4d\u5e76\u914d\u7f6e\u5411\u91cf\u8868\n    RCC->CR|=1<<16;       //\u5916\u90e8\u9ad8\u901f\u65f6\u949f\u4f7f\u80fdHSEON\n    while(!(RCC->CR>>17));//\u7b49\u5f85\u5916\u90e8\u65f6\u949f\u5c31\u7eea\n    RCC->CFGR=0X00000400; //APB1=DIV2;APB2=DIV1;AHB=DIV1;\n    PLL-=2;//\u62b5\u6d882\u4e2a\u5355\u4f4d\n    RCC->CFGR|=PLL<<18;   //\u8bbe\u7f6ePLL\u503c 2~16\n    RCC->CFGR|=1<<16;\t    //PLLSRC ON\n    FLASH->ACR|=0x32;\t    //FLASH 2\u4e2a\u5ef6\u65f6\u5468\u671f\n    RCC->CR|=0x01000000;  //PLLON\n    while(!(RCC->CR>>25));//\u7b49\u5f85PLL\u9501\u5b9a\n    RCC->CFGR|=0x00000002;//PLL\u4f5c\u4e3a\u7cfb\u7edf\u65f6\u949f\n    while(temp!=0x02)     //\u7b49\u5f85PLL\u4f5c\u4e3a\u7cfb\u7edf\u65f6\u949f\u8bbe\u7f6e\u6210\u529f\n    {\n        temp=RCC->CFGR>>2;\n        temp&=0x03;\n    }\n\n    SysClock=(PLL+2)*8;\n    return SysClock;\n}\n\n/********************************************\n              \u5f00\u673aLED\u7684\u5404\u79cd\u72b6\u6001\n********************************************/\nvoid PowerOn()\n{\n    char i;            //\u5faa\u73af\u53d8\u91cf\n\n    for(i=0; i<4; i++) //\u5faa\u73af\u95ea\u70c14\u6b21\n    {\n        LedA_on;\n        LedB_off;\n        LedC_off;\n        LedD_off;\n        Delay(900000);\n        LedA_off;\n        LedB_on;\n        LedC_off;\n        LedD_off;\n        Delay(900000);\n        LedA_off;\n        LedB_off;\n        LedC_on;\n        LedD_off;\n        Delay(900000);\n        LedA_off;\n        LedB_off;\n        LedC_off;\n        LedD_on;\n        Delay(900000);\n    }\n\n    for(i=0; i<3; i++) //\u89e3\u9501\u6210\u529f\uff0c\u5feb\u901f\u95ea\u70c13\u6b21\u63d0\u793a\n    {\n        LedA_on;\n        LedB_on;\n        LedC_on;\n        LedD_on;\n        Delay(900000);\n        LedA_off;\n        LedB_off;\n        LedC_off;\n        LedD_off;\n        Delay(900000);\n    }\n    printf(\"Armed success...\\r\\n\");\n}\n\n\n\n\n\n\n\n\n\n\n\n\n", "comment_ratio": 0.27741935483870966}
{"lang": "c", "code": "#pragma once\n\n// reference: https://docs.microsoft.com/en-us/windows/win32/gdi/capturing-an-image\n\n#include <string>\n#include <windows.h>\n#include <d3d12.h>\n#include <wrl/client.h>\n#include <vector>\n#include \"d3dx12.h\"\n#include \"DXSampleHelper.h\"\n\n#pragma warning(push, 0)\n#include <gdiplus.h>\n#pragma warning(pop)\n#pragma comment( lib, \"gdiplus.lib\" ) \n\nnamespace WindowCapture\n{\n    template<typename T> using ComPtr = Microsoft::WRL::ComPtr<T>;\n    //-----------------------------------------------------------------------------\n    // from MSDN:\n    // https://docs.microsoft.com/en-us/windows/desktop/gdiplus/-gdiplus-retrieving-the-class-identifier-for-an-encoder-use\n    //-----------------------------------------------------------------------------\n    int GetEncoderClsid(const WCHAR* format, CLSID* pClsid)\n    {\n        UINT  num = 0;          // number of image encoders\n        UINT  size = 0;         // size of the image encoder array in bytes\n\n        Gdiplus::ImageCodecInfo* pImageCodecInfo = NULL;\n\n        Gdiplus::GetImageEncodersSize(&num, &size);\n        if (size == 0)\n            return -1;  // Failure\n\n        pImageCodecInfo = (Gdiplus::ImageCodecInfo*)(malloc(size));\n        if (pImageCodecInfo == NULL)\n            return -1;  // Failure\n\n        Gdiplus::GetImageEncoders(num, size, pImageCodecInfo);\n\n        for (UINT j = 0; j < num; ++j)\n        {\n            if (wcscmp(pImageCodecInfo[j].MimeType, format) == 0)\n            {\n                *pClsid = pImageCodecInfo[j].Clsid;\n                free(pImageCodecInfo);\n                return j;  // Success\n            }\n        }\n\n        free(pImageCodecInfo);\n        return -1;  // Failure\n    }\n\n    void CaptureRenderTarget(ID3D12Resource* in_pRsrc, ID3D12CommandQueue* in_pQ, const std::wstring& in_filename)\n    {\n        ComPtr<ID3D12Device> device;\n        in_pRsrc->GetDevice(IID_PPV_ARGS(&device));\n\n        ComPtr<ID3D12CommandAllocator> commandAllocator;\n        ComPtr<ID3D12GraphicsCommandList> commandList;\n        ComPtr<ID3D12Fence> renderFence;\n        ComPtr<ID3D12Resource> stagingResource;\n\n        ThrowIfFailed(device->CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT, IID_PPV_ARGS(&commandAllocator)));\n        device->CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_DIRECT, commandAllocator.Get(), nullptr, IID_PPV_ARGS(&commandList));\n        D3D12_COMMAND_QUEUE_DESC queueDesc = {};\n        queueDesc.Flags = D3D12_COMMAND_QUEUE_FLAG_NONE;\n        queueDesc.Type = D3D12_COMMAND_LIST_TYPE_DIRECT;\n        ThrowIfFailed(device->CreateFence(0, D3D12_FENCE_FLAG_NONE, IID_PPV_ARGS(&renderFence)));\n\n        auto srcDesc = in_pRsrc->GetDesc();\n\n        UINT64 bufferSize = 0;\n        D3D12_PLACED_SUBRESOURCE_FOOTPRINT layout{};\n        device->GetCopyableFootprints(&srcDesc, 0, 1, 0, &layout, nullptr, nullptr, &bufferSize);\n\n        D3D12_RESOURCE_DESC bufferDesc = CD3DX12_RESOURCE_DESC::Buffer(bufferSize);\n        const auto heapDesc = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_READBACK);\n        ThrowIfFailed(device->CreateCommittedResource(\n            &heapDesc, D3D12_HEAP_FLAG_NONE,\n            &bufferDesc, D3D12_RESOURCE_STATE_COPY_DEST, nullptr, IID_PPV_ARGS(&stagingResource)));\n\n        D3D12_RESOURCE_BARRIER b = CD3DX12_RESOURCE_BARRIER::Transition(in_pRsrc, D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_COPY_SOURCE);\n        commandList->ResourceBarrier(1, &b);\n\n        const auto dstLocation = CD3DX12_TEXTURE_COPY_LOCATION(stagingResource.Get(), layout);\n        const auto srcLocation = CD3DX12_TEXTURE_COPY_LOCATION(in_pRsrc, 0);\n        commandList->CopyTextureRegion(&dstLocation, 0, 0, 0, &srcLocation, nullptr);\n\n        std::swap(b.Transition.StateBefore, b.Transition.StateAfter);\n        commandList->ResourceBarrier(1, &b);\n\n        // submit all our initialization commands\n        commandList->Close();\n        ID3D12CommandList* ppCommandLists[] = { commandList.Get() };\n        in_pQ->ExecuteCommandLists(_countof(ppCommandLists), ppCommandLists);\n\n        HANDLE renderFenceEvent = ::CreateEvent(nullptr, FALSE, FALSE, nullptr);\n        if (renderFenceEvent == nullptr)\n        {\n            ThrowIfFailed(HRESULT_FROM_WIN32(GetLastError()));\n        }\n\n        ThrowIfFailed(in_pQ->Signal(renderFence.Get(), 1));\n        ThrowIfFailed(renderFence->SetEventOnCompletion(1, renderFenceEvent));\n        WaitForSingleObject(renderFenceEvent, INFINITE);\n        ::CloseHandle(renderFenceEvent);\n\n        BYTE* pData = nullptr;\n        stagingResource->Map(0, nullptr, (void**)&pData);\n\n        std::vector<BYTE> bytes(layout.Footprint.RowPitch * layout.Footprint.Height, 0);\n        for (UINT y = 0; y < layout.Footprint.Height; y++)\n        {\n            UINT i = y * layout.Footprint.RowPitch;\n            for (UINT x = 0; x < layout.Footprint.Width; x++)\n            {\n\n                bytes[i + 0] = pData[i + 2];\n                bytes[i + 1] = pData[i + 1];\n                bytes[i + 2] = pData[i + 0];\n                i += 4;\n            }\n\n        }\n\n        // Start Gdiplus \n        Gdiplus::GdiplusStartupInput gdi;\n        ULONG_PTR token;\n        Gdiplus::GdiplusStartup(&token, &gdi, nullptr);\n\n        Gdiplus::Bitmap bitmap(layout.Footprint.Width, layout.Footprint.Height, layout.Footprint.RowPitch, PixelFormat32bppRGB, bytes.data());\n\n        // Get the class identifier for the PNG encoder.\n        CLSID pngClsid{};\n        GetEncoderClsid(L\"image/png\", &pngClsid);\n\n        // Save image1 as a stream in the compound file.\n        Gdiplus::Status status = bitmap.Save(in_filename.c_str(), &pngClsid, nullptr);\n        if (Gdiplus::Ok != status)\n        {\n            MessageBox(0, L\"Image save failed\", L\"Failed\", MB_OK);\n            exit(-1);\n        }\n\n        //Gdiplus::GdiplusShutdown(token);\n\n        stagingResource->Unmap(0, nullptr);\n    }\n};\n\n\n", "comment_ratio": 0.22905027932960895}
{"lang": "c", "code": "#ifndef NVPTX_FRAMELOWERING_H\n#define NVPTX_FRAMELOWERING_H\n\n#include \"llvm/Target/TargetFrameLowering.h\"\n\nnamespace llvm {\nclass NVPTXTargetMachine;\n\nclass NVPTXFrameLowering : public TargetFrameLowering {\n  NVPTXTargetMachine &tm;\n  bool is64bit;\n\npublic:\n  explicit NVPTXFrameLowering(NVPTXTargetMachine &_tm, bool _is64bit)\n      : TargetFrameLowering(TargetFrameLowering::StackGrowsUp, 8, 0), tm(_tm),\n        is64bit(_is64bit) {}\n\n  virtual bool hasFP(const MachineFunction &MF) const;\n  virtual void emitPrologue(MachineFunction &MF) const;\n  virtual void emitEpilogue(MachineFunction &MF, MachineBasicBlock &MBB) const;\n\n  void eliminateCallFramePseudoInstr(MachineFunction &MF,\n                                     MachineBasicBlock &MBB,\n                                     MachineBasicBlock::iterator I) const;\n};\n\n} // End llvm namespace\n\n#endif\n\n", "comment_ratio": 0.3023255813953488}
{"lang": "c", "code": "#pragma once\n//*******************************************************\n// Purpose: Class for a emitting an assembly statement\n//\n// Author: Philip Howard\n// Email:  phil.howard@oit.edu\n//\n// Date: 4/11/2015\n//\n//*******************************************************\n\n#include <string>\n\n#include \"cStmtNode.h\"\n#include \"cParamNode.h\"\n#include \"codegen.h\"\n\nclass cAsmNode : public cStmtNode\n{\n  public:\n    cAsmNode(int code, cParamNode *params) : cStmtNode()\n    {\n        mCode = code;\n        mCode2 = 0;\n        mParams = params;\n        mTwoWord = false;\n    }\n\n    cAsmNode(int code, int code2, cParamNode *params) : cStmtNode()\n    {\n        mCode = code;\n        mCode2 = code2;\n        mParams = params;\n        mTwoWord = true;\n    }\n\n    virtual std::string toString()\n    {\n        std::string result(\"ASM \");\n        result += std::to_string(mCode);\n        if (mParams != NULL) result += \" \" + mParams->toString();\n        return result;\n    }\n\n    virtual int ComputeOffsets(int base)\n    {\n        if (mParams != NULL) mParams->ComputeOffsets(base);\n        return base;\n    }\n\n    virtual void GenerateCode()\n    {\n        if (mParams != NULL) mParams->GenerateCode();\n        EmitInt(mCode);\n        if (mTwoWord) EmitInt(mCode2);\n    }\n  protected:\n    int mCode;              // the opcode to be emitted\n    int mCode2;             // 2nd opcode for 2 word instructions\n    bool mTwoWord;          // true of 2 word instruction\n    cParamNode *mParams;    // items to push onto the stack prior to emitting\n                            // the opcode\n};\n\n\n", "comment_ratio": 0.2153846153846154}
{"lang": "c", "code": "#include \"LAGraph_test.h\"\n\n//------------------------------------------------------------------------------\n// global variables\n//------------------------------------------------------------------------------\n\nLAGraph_Graph G = NULL ;\nchar msg [LAGRAPH_MSG_LEN] ;\nGrB_Matrix A = NULL ;\nGrB_Type atype = NULL ;\n#define LEN 512\nchar filename [LEN+1] ;\n\n//------------------------------------------------------------------------------\n// setup: start a test\n//------------------------------------------------------------------------------\n\nvoid setup (void)\n{\n    OK (LAGraph_Init (msg)) ;\n}\n\n//------------------------------------------------------------------------------\n// teardown: finalize a test\n//------------------------------------------------------------------------------\n\nvoid teardown (void)\n{\n    OK (LAGraph_Finalize (msg)) ;\n}\n\n//------------------------------------------------------------------------------\n// test_DeleteProperties:  test LAGraph_DeleteProperties\n//------------------------------------------------------------------------------\n\ntypedef struct\n{\n    LAGraph_Kind kind ;\n    const char *name ;\n}\nmatrix_info ;\n\nconst matrix_info files [ ] =\n{\n    LAGRAPH_ADJACENCY_DIRECTED,   \"cover.mtx\",\n    LAGRAPH_ADJACENCY_DIRECTED,   \"ldbc-directed-example.mtx\",\n    LAGRAPH_ADJACENCY_UNDIRECTED, \"ldbc-undirected-example.mtx\",\n    LAGRAPH_ADJACENCY_UNDIRECTED, \"A.mtx\",\n    LAGRAPH_ADJACENCY_UNDIRECTED, \"bcsstk13.mtx\",\n    LAGRAPH_UNKNOWN,              \"\"\n} ;\n\nvoid test_DeleteProperties (void)\n{\n    setup ( ) ;\n\n    for (int k = 0 ; ; k++)\n    {\n\n        // load the matrix as A\n        const char *aname = files [k].name ;\n        if (strlen (aname) == 0) break;\n        LAGraph_Kind kind = files [k].kind ;\n        TEST_CASE (aname) ;\n        snprintf (filename, LEN, LG_DATA_DIR \"%s\", aname) ;\n        FILE *f = fopen (filename, \"r\") ;\n        TEST_CHECK (f != NULL) ;\n        OK (LAGraph_MMRead (&A, &atype, f, msg)) ;\n        OK (fclose (f)) ;\n        TEST_MSG (\"Loading of adjacency matrix failed\") ;\n\n        // construct the graph G with adjacency matrix A\n        OK (LAGraph_New (&G, &A, atype, kind, msg)) ;\n        TEST_CHECK (A == NULL) ;\n\n        // create all properties (see test_Property_* for tests of content)\n        OK (LAGraph_Property_RowDegree (G, msg)) ;\n        OK (LAGraph_Property_ColDegree (G, msg)) ;\n        OK (LAGraph_Property_AT (G, msg)) ;\n        OK (LAGraph_Property_ASymmetricPattern (G, msg)) ;\n\n        // print them\n        printf (\"\\nGraph: ndiag %ld, symmetric pattern: %d\\n\", G->ndiag,\n            G->A_pattern_is_symmetric) ;\n        printf (\"  adj matrix: \") ;\n        OK (LAGraph_Matrix_print_type (G->A, atype, 2, stdout, msg)) ;\n        printf (\"  row degree: \") ;\n        OK (LAGraph_Vector_print_type (G->rowdegree, G->rowdegree_type, 2,\n            stdout, msg)) ;\n        if (kind == LAGRAPH_ADJACENCY_DIRECTED)\n        {\n            printf (\"  adj transposed: \") ;\n            OK (LAGraph_Matrix_print_type (G->AT, atype, 2, stdout, msg)) ;\n            printf (\"  col degree: \") ;\n            OK (LAGraph_Vector_print_type (G->coldegree, G->coldegree_type, 2,\n                stdout, msg)) ;\n        }\n        else\n        {\n            TEST_CHECK (G->AT == NULL) ;\n            TEST_CHECK (G->coldegree == NULL) ;\n        }\n\n        for (int trial = 0 ; trial <= 1 ; trial++)\n        {\n            // delete all the properties\n            OK (LAGraph_DeleteProperties (G, msg)) ;\n            TEST_CHECK (G->AT == NULL) ;\n            TEST_CHECK (G->rowdegree == NULL) ;\n            TEST_CHECK (G->rowdegree_type == NULL) ;\n            TEST_CHECK (G->coldegree == NULL) ;\n            TEST_CHECK (G->coldegree_type == NULL) ;\n        }\n\n        OK (LAGraph_Delete (&G, msg)) ;\n    }\n\n    OK (LAGraph_DeleteProperties (NULL, msg)) ;\n\n    teardown ( ) ;\n}\n\n//-----------------------------------------------------------------------------\n// TEST_LIST: the list of tasks for this entire test\n//-----------------------------------------------------------------------------\n\nTEST_LIST =\n{\n    { \"Property_DeleteProperties\", test_DeleteProperties },\n    { NULL, NULL }\n} ;\n\n\n", "comment_ratio": 0.2}
{"lang": "c", "code": "#ifndef _myBmpGris_h_\n#define _myBmpGris_h_\n\n#include <stdlib.h>\n#include <stdio.h>\n\ntypedef struct BmpImg_s BmpImg;\nstruct BmpImg_s {\n\tunsigned char** img;\t// Image en niveaux de gris\n\tunsigned int dimX;\t\t// Dimension en x (hauteur)\n\tunsigned int dimY;\t\t// Dimension en y (largeur)\n\t\n\tchar* nomImg;\t\t\t\t// Nom de l'image\n\tunsigned int fileSize;\t\t// Taille du fichier en octet\n\tunsigned int headerSize;\t// Taille de l'header en octet\n    unsigned int bmpSize;\t\t// Taille de l'header BMP en octet\n\tunsigned int dibSize;\t\t// Taille de l'header DIB en octet\n\tunsigned int imgSize;\t\t// Taille de l'image en octet\n\t\n\tunsigned char* dibHeader;\t// La taille du DIB varie selon que l'on stocke ou non la colormap\n\tunsigned char bmpHeader[14];\t// Bmp Header fait toujours 14 octets (soit 14 char)\n};\n\n\n// Constructeur et Destructeur\n/** Methode de creation d'une image Bmp \"standard\" (pas de LUT, pas d'alpha, codage sur 24 bits)\n  * @param dimX nombre de lignes de l'image\n  * @param dimY nombre de colonnes de l'image\n  * @return une image prete a l'emploi (plans couleur a remplir)\n  */\nBmpImg createBmpImg( char* str, int dimX, int dimY );\n\n/** Methode de creation d'un header Bmp \"standard\" (14 octets, pas de LUT, pas d'alpha, codage sur 24 bits)\n  * @param bmpImg une struct BmpImg ou les champs dimX, dimY et de taille (xxSize) sont deja remplis\n  */\nvoid createBmpHeader( BmpImg* bmpImg );\n\n/** Methode de creation d'un header DIB \"standard\" (40 octets, pas de LUT, pas d'alpha, codage sur 24 bits)\n  * @param bmpImg une struct BmpImg ou les champs dimX, dimY et de taille (xxSize) sont deja remplis\n  */\nvoid createDibHeader( BmpImg* bmpImg );\n\n/** Methode d'initialisation d'une image Bmp\n  * Met toutes les tailles a 0 et tous les pointeurs a NULL\n  * @return une image initialisee\n  */\nBmpImg initImg( );\n\n/** Methode de destruction d'une image\n  * @param bmpImg image a detruire / desallouer\n  */\nvoid freeBmpImg( BmpImg* bmpImg );\n\n\n\n// Methode de lecture / ecriture\n/** Methode de lecture d'une image bitmap\n  * @param imgName nom de l'image\n  * @return l'image\n  */\nBmpImg readBmpImage( char* imgPath, char* imgName);\n\n/** Methode auxiliaire de lecture d'une image bitmap\n  * Sert a lire le header (14 premiers octets) et le dib header\n  * @param fImg le fichier image (deja ouvert)\n  * @param bmpImg pointeur vers une structure d'image. Apres appel a la fonction, \n  * \til contiendra les champs:\n  * \t\tfileSize, headerSize, dibSize et imgSize\n  * \t\tbmpHeader et dibHeader\n  * \t\tdimX et dimY\n  */\nvoid readHeader( FILE* fImg, BmpImg* bmpImg );\n\n/** Methode auxiliaire de lecture d'une image bitmap\n  * Sert a lire les 3 plans couleurs (en codage direct)\n  * @param fImg le fichier image (deja ouvert)\n  * @param bmpImg pointeur vers une structure d'image. Apres appel a la fonction, \n  * \til contiendra les champs imgR, imgG et imgB\n  */\nvoid readImg( FILE* fImg, BmpImg* bmpImg );\n\n\n/** Methode d'ecriture d'une image bitmap\n  * @param imgName nom de l'image\n  * @param bmpImg pointeur vers une structure d'image.\n  */\nvoid writeBmpImage( char* imgName, BmpImg* bmpImg );\n\n\n\n// Methodes de copie\n/** Methode effectuant la copie complete d'une image (header et plan couleur)\n  * @param bmpImg image a copier\n  * @return la copie de l'image\n  */\nBmpImg copyBmpAll( BmpImg bmpImg );\n\n/** Methode effectuant la copie du header d'une image bitmap\n  * @param origImg image a copier\n  * @param copyImg copie de l'image\n  */\nvoid copyBmpHeader( BmpImg origImg, BmpImg* copyImg );\n\n/** Methode effectuant la copie des plans couleur d'une image bitmap\n  * Ne fait rien si les tailles d'image sont differentes\n  * @param origImg image a copier\n  * @param copyImg copie de l'image\n  */\nvoid copyBmpImg( BmpImg origImg, BmpImg* copyImg );\n\n\n\n// Getter et Setter\n/** Methode renvoyant la couleur (r, g, b) d'un pixel\n  * @param bmpImg une structure image bmp\n  * @param x la coordonnee x (ligne) du pixel\n  * @param y la coordonnee y (colonne) du pixel\n  * @return un entier correspondant au niveau de gris du pixel (0-255)\n  * \tou a -1 si en dehors de l'image\n  */\nint getPixel( BmpImg bmpImg, int x, int y );\n\n/** Methode stockant la couleur (r, g, b) d'un pixel\n  * @param bmpImg une structure image bmp\n  * @param clr un entier correspondant au niveau de gris du pixel (0-255)\n  * @param x la coordonnee x (ligne) du pixel\n  * @param y la coordonnee y (colonne) du pixel\n  */\nvoid setPixel( BmpImg bmpImg, int clr, int x, int y );\n\n\n\n// Methodes diverses\n/** Methode desallouant une matrice de char apres avoir verifie si elle est allouee\n  * @param mat la matrice a desallouer\n  * @param dimX le nombre de lignes de la matrice\n  */\nvoid freeMat( unsigned char** mat, int dimX );\n\n/** Methode allouant l'espace memoire necessaire au plan d'intensite d'une image Bmp\n  * @param bmpImg une struct BmpImg ou les champs dimX, dimY sont remplis\n  */\nvoid createImg( BmpImg* bmpImg );\n\n/** Methode de conversion d'un tableau de char vers un entier non signe\n  * @param buffer le tableau de char a convertir\n  * @param pos la position du char de poids faible\n  * @return entier non signe correspondant aux char entre pos+3 et pos\n  */\nunsigned int char2UInt( unsigned char* buffer, int pos );\n\n/** Methode de conversion d'un entier non signe vers un tableau de char\n  * @param entier non signe a convertir\n  * @param buffer le tableau de char ou stocke l'entier\n  * @param pos la position du char de poids faible\n  */\nvoid uInt2Char( unsigned int n, unsigned char* buffer, int pos );\n\n#endif\n\n", "comment_ratio": 0.1}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n#import \"ZJPickerViewProperty.h\"\n#import \"ZJPickerViewConfig.h\"\n\n\n@interface ZJPickerView : UIView\n\n/**\n Show pickerView\uff08\u663e\u793apickerView\uff09\n The first way, customization pickerView style\uff08\u65b9\u5f0f\u4e00\uff1a\u901a\u8fc7\u8bbe\u7f6e\u6837\u5f0f\uff0c\u63a8\u8350\uff09\n\n @param dataList Must pass by value\uff0c if not show. The object type of list is support NSString\u3001NSNumber\uff08basic data type\uff09\u3001NSDictionary\uff08\u4f20\u5165\u7684\u6570\u636e\uff0c\u5fc5\u4f20\uff0c\u5426\u5219\u4e0d\u663e\u793a\uff09\n @param config Custom config, user default config if value is nil\uff08\u81ea\u5b9a\u4e49\u6837\u5f0f\uff0c\u5982\u679c\u4f20\u7a7a\u5219\u7528\u9ed8\u8ba4\u914d\u7f6e\uff09\n @param completion Click sure button callback\uff08\u70b9\u51fb\u786e\u5b9a\u6309\u94ae\u65f6\u56de\u8c03\uff09\n */\n+ (void)zj_showWithDataList:(nonnull NSArray *)dataList\n                     config:(nullable ZJPickerViewConfig *)config\n                 completion:(nullable void(^)(NSString * _Nullable selectContent))completion;\n\n/**\n Show pickerView\uff08\u663e\u793apickerView\uff09\n The second way, customization property dictionary\uff08\u65b9\u5f0f\u4e8c\uff1a\u901a\u8fc7\u5c5e\u6027\u5b57\u5178\uff09\n\n @param dataList Must pass by value\uff0c if not show. The object type of list is support NSString\u3001NSNumber\uff08basic data type\uff09\u3001NSDictionary\uff08\u4f20\u5165\u7684\u6570\u636e\uff0c\u5fc5\u4f20\uff0c\u5426\u5219\u4e0d\u663e\u793a\uff09\n @param propertyDict Custom property, user default config if value is nil\uff08\u81ea\u5b9a\u4e49\u5c5e\u6027\u53c2\u6570\uff0c\u5982\u679c\u4f20\u7a7a\u5219\u7528\u9ed8\u8ba4\u5c5e\u6027\u914d\u7f6e\uff09\n @param completion Click sure button callback\uff08\u70b9\u51fb\u786e\u5b9a\u6309\u94ae\u65f6\u56de\u8c03\uff09\n */\n+ (void)zj_showWithDataList:(nonnull NSArray *)dataList\n               propertyDict:(nullable NSDictionary *)propertyDict\n                 completion:(nullable void(^)(NSString * _Nullable selectContent))completion;\n@end\n\n", "comment_ratio": 0.23255813953488372}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n\n@protocol FibonacciTableDelegate <NSObject>\n\n- (void)fibonacciTableDidSelectIndex:(int)index;\n\n@end\n\n@interface FibonnacciTableController : UITableViewController\n\n@property (nonatomic, weak) id<FibonacciTableDelegate> eventDelegate;\n\n@end\n\n", "comment_ratio": 0.3181818181818182}
{"lang": "c", "code": "#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <termios.h>\n\n#include <math.h>\n\nint open_port(const char* port_address)\n{\n\tint fd;\n\tfd = open(port_address, O_RDWR | O_NOCTTY | O_NDELAY);\n\tif(fd == -1)\n\t\tprintf(\"open_port: Unable to open %s\", port_address);\n\telse\n\t\tfcntl(fd, F_SETFL, 0);\n\n\treturn fd;\n}\n\t\n\n\nvoid config_port(int fd)\n{\n\tstruct termios options;\n\t\n\ttcgetattr(fd, &options);\n\t\n\tcfsetispeed(&options, B9600);\n\tcfsetospeed(&options, B9600);\n\n\toptions.c_cflag |= (CLOCAL | CREAD);\n\n\toptions.c_cflag &= ~PARENB;\n  options.c_cflag &= ~CSTOPB;\n\toptions.c_cflag &= ~CSIZE;\n\toptions.c_cflag |= CS8;\n\n\ttcsetattr(fd, TCSANOW, &options);\n}\n\n//received hex number should be sparsed, the method is proposed from instruction book\ndouble sparse_hex(unsigned char* buffer, int size){\n\tint decimal[size];\n\tfor(int i = 0; i<size; i++)\n\t\tdecimal[i]=*(buffer+i);\n\n\tdouble sum = 0;\n\tprintf(\"decimal[0]=%d\\n\", decimal[3]);\n\tfor(int i = 1; !(i > decimal[2]); i++)\n\t{\t\n\t\t\t\tsum += decimal[2+i]*pow(16, 2*(decimal[2]-i));\n\t\n\t}\n\n\treturn sum/10000.0; //return the measured distance (unit: meter)\n}\t\n\t\n\nint main(int argc, char** argv)\n{\n\tif(argc < 2)\n\t{\n\t\t\tprintf(\"Needed port address\\n\");\n\t\t\treturn 0;\n\t}\n\n  int fd = open_port(argv[1]);\n\t\n\tconfig_port(fd);\n\n\tchar st_buffer[8];\n\tunsigned char rec_buffer[255];\n\tunsigned char valid_buffer[9];\n\tst_buffer[0]=0x01;\n\tst_buffer[1]=0x03;\n\tst_buffer[2]=0x00;\n\tst_buffer[3]=0x15;\n\tst_buffer[4]=0x00;\n\tst_buffer[5]=0x02;\n\tst_buffer[6]=0xd5;\n\tst_buffer[7]=0xcf;//the message to acquire the measured distance.\n  //st_buffer[8]=0xb9;\n\t\n\twrite(fd, st_buffer, sizeof(st_buffer)); \n\n\tint length = 0;\n\twhile(1){\n\t\tint t = read(fd, rec_buffer, sizeof(rec_buffer)); //read the received message\n\t\t//printf(\"bytes_read= %d\\n\", t);\n\t\tif(t>0){\t\n\t\t\t\tfor(int i=0; i<t; i++){\n\t\t\t\t\tprintf(\"received %dth buffer: %d\\n\", i, rec_buffer[i]);\n\t\t\t\t\tvalid_buffer[length + i]=rec_buffer[i];//extract valid data from received messaged, for the laser each time transmitted 3 bytes,\n\t\t\t\t}\n\t\t      length+=t;\n\t\t}\n\t\tif(length > 8)//get all data, finished.\n\t\t\tbreak;\n\t}\n\n\tprintf(\"measured distance = %lf\\n\", sparse_hex(valid_buffer, sizeof(valid_buffer)));\n\n\treturn 0;\n}\n\n", "comment_ratio": 0.10714285714285714}
{"lang": "c", "code": "#ifndef CHROME_BROWSER_UI_AUTOFILL_AUTOFILL_DIALOG_CONTROLLER_H_\n#define CHROME_BROWSER_UI_AUTOFILL_AUTOFILL_DIALOG_CONTROLLER_H_\n\n#include <string>\n\n#include \"base/callback.h\"\n#include \"base/memory/weak_ptr.h\"\n#include \"base/strings/string16.h\"\n#include \"chrome/browser/ui/autofill/autofill_dialog_types.h\"\n#include \"components/autofill/content/browser/autocheckout_steps.h\"\n#include \"components/autofill/core/browser/form_structure.h\"\n\nclass GURL;\n\nnamespace content {\nclass WebContents;\n}\n\nnamespace user_prefs {\nclass PrefRegistrySyncable;\n}\n\nnamespace autofill {\n\n// This class defines the interface to the controller for TabAutofillManager.\nclass AutofillDialogController {\n public:\n  virtual ~AutofillDialogController();\n\n  // Creates the AutofillDialogController.\n  static base::WeakPtr<AutofillDialogController> Create(\n      content::WebContents* contents,\n      const FormData& form_structure,\n      const GURL& source_url,\n      const DialogType dialog_type,\n      const base::Callback<void(const FormStructure*,\n                                const std::string&)>& callback);\n\n  // Registers profile preferences.\n  static void RegisterProfilePrefs(user_prefs::PrefRegistrySyncable* registry);\n\n  // Shows the Autofill dialog.\n  virtual void Show() = 0;\n\n  // Hides the Autofill dialog.\n  virtual void Hide() = 0;\n\n  // Called when the tab hosting this dialog is activated by a user gesture.\n  // Used to trigger a refresh of the user's Wallet data.\n  virtual void TabActivated() = 0;\n\n  // Adds a step in the flow to the Autocheckout UI.\n  virtual void AddAutocheckoutStep(AutocheckoutStepType step_type) = 0;\n\n  // Updates the status of a step in the Autocheckout UI.\n  virtual void UpdateAutocheckoutStep(\n      AutocheckoutStepType step_type,\n      AutocheckoutStepStatus step_status) = 0;\n\n  // Called when there is an error in an active Autocheckout flow.\n  virtual void OnAutocheckoutError() = 0;\n\n  // Called when an Autocheckout flow completes successfully.\n  virtual void OnAutocheckoutSuccess() = 0;\n\n  // Returns the dialog type.\n  virtual DialogType GetDialogType() const = 0;\n};\n\n}  // namespace autofill\n\n#endif  // CHROME_BROWSER_UI_AUTOFILL_AUTOFILL_DIALOG_CONTROLLER_H_\n\n", "comment_ratio": 0.22077922077922077}
{"lang": "c", "code": "#include \"speaker.h\"\r\n\r\nstatic volatile TIM2_5 * const pTimer3 = (TIM2_5 *)TIM3_BASE;\r\n\r\nvoid Speaker_Init()\r\n{\r\n\t//enable GPIOB\r\n\t*RCC_AHB1ENR |= GPIOB_EN;\r\n\r\n\t//enable TIM3\r\n\t*RCC_APB1ENR |= TIM3_EN;\r\n\r\n\t//setup PB4 for AF2\r\n\tGpioB->AFRL = (GpioB->AFRL & ~AFRL4_MASK) | AFRL4_AF2;\r\n\tGpioB->MODER.MOD4 = MODERx_AFM;\r\n\r\n\t//set TIM3_ARR value\r\n\tpTimer3->ARR = 8000;\r\n\t//set TIM3_CCR1 value (1KHZ default)\r\n\tpTimer3->CCR1 = 8000;\r\n\r\n\t//set to toggle on match in TIM3_CCMR1\r\n\tpTimer3->CCMR1 &= ~OC1M_MASK;\r\n\tpTimer3->CCMR1 |= OC1M_TOGGLE;\r\n\r\n\t//enable output in TIM3_CCER\r\n\tpTimer3->CCER = (pTimer3->CCER & ~(CCER_CC1P|CCER_CC1NP)) | CCER_CC1E;\r\n}\r\n\r\nvoid Speaker_Tone(unsigned freq)\r\n{\r\n\t//get length of half-period in ticks\r\n\tunsigned ticks = 8000000/freq;\r\n\r\n\t//set TIM3_ARR value\r\n\tpTimer3->ARR = ticks;\r\n\r\n\t//set TIM3_CCR1 value\r\n\tpTimer3->CCR1 = ticks;\r\n\r\n\t//enable counter in TIM3_CR1\r\n\tpTimer3->CR1.CEN = 1;\r\n}\r\n\r\nvoid Speaker_Mute()\r\n{\r\n\t//disable counter in TIM3_CR1 (better to disable just channel 1)\r\n\tpTimer3->CR1.CEN = 0;\r\n}\r\n\n", "comment_ratio": 0.24}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n#import <KirinKit/JSContext.h>\n#import <KirinKit/KirinExtensionOnMainThread.h>\n#import <KirinKit/JSExecutor.h>\n\n@interface DummyJSContext : JSContext <KirinExtensionOnMainThread, JSExecutor> {\n}\n\n@property(retain) NSString* lastCall;\n        \n@property(retain) NSMutableArray* jsCalls;\n\n- (void) reset;\n\n@end\n\n", "comment_ratio": 0.2916666666666667}
{"lang": "c", "code": "#ifndef CALL_PROTOCOL_LEDGERFORMATS_H_INCLUDED\n#define CALL_PROTOCOL_LEDGERFORMATS_H_INCLUDED\n\n#include <call/protocol/KnownFormats.h>\n\nnamespace call {\n\n/** Ledger entry types.\n\n    These are stored in serialized data.\n\n    @note Changing these values results in a hard fork.\n\n    @ingroup protocol\n*/\n// Used as the type of a transaction or the type of a ledger entry.\nenum LedgerEntryType\n{\n    /** Special type, anything\n        This is used when the type in the Keylet is unknown,\n        such as when building metadata.\n    */\n    ltANY = -3,\n\n    /** Special type, anything not a directory\n        This is used when the type in the Keylet is unknown,\n        such as when iterating\n    */\n    ltCHILD             = -2,\n\n    ltINVALID           = -1,\n\n    //---------------------------------------------------------------------------\n\n    ltACCOUNT_ROOT      = 'a',\n\n    /** Directory node.\n\n        A directory is a vector 256-bit values. Usually they represent\n        hashes of other objects in the ledger.\n\n        Used in an append-only fashion.\n\n        (There's a little more information than this, see the template)\n    */\n    ltDIR_NODE          = 'd',\n\n    ltCALL_STATE        = 'r',\n\n    ltTICKET            = 'T',\n\n    ltSIGNER_LIST       = 'S',\n\n    ltOFFER             = 'o',\n\n    ltLEDGER_HASHES     = 'h',\n\n    ltAMENDMENTS        = 'f',\n\n    ltFEE_SETTINGS      = 's',\n\n    ltESCROW            = 'u',\n\n    // Simple unidirection call channel\n    ltPAYCHAN           = 'x',\n\n    // No longer used or supported. Left here to prevent accidental\n    // reassignment of the ledger type.\n    ltNICKNAME          = 'n',\n\n    ltNotUsed01         = 'c',\n    \n    ltISSUEROOT         = 'i',\n    ltFeeRoot           = 'F',\n    ltINVOICE           = 'v'\n};\n\n/**\n    @ingroup protocol\n*/\n// Used as a prefix for computing ledger indexes (keys).\nenum LedgerNameSpace\n{\n    spaceAccount        = 'a',\n    spaceDirNode        = 'd',\n    spaceGenerator      = 'g',\n    spaceCall           = 'r',\n    spaceOffer          = 'o',  // Entry for an offer.\n    spaceOwnerDir       = 'O',  // Directory of things owned by an account.\n    spaceBookDir        = 'B',  // Directory of order books.\n    spaceContract       = 'c',\n    spaceSkipList       = 's',\n    spaceEscrow         = 'u',\n    spaceAmendment      = 'f',\n    spaceFee            = 'e',\n    spaceTicket         = 'T',\n    spaceSignerList     = 'S',\n    spaceCALLUChannel   = 'x',\n\n    // No longer used or supported. Left here to reserve the space and\n    // avoid accidental reuse of the space.\n\n    spaceNickname       = 'n',\n    spaceIssue          = 'i',\n    spaceFees           = 'F',\n    spaceInvoice        = 'v'\n};\n\n/**\n    @ingroup protocol\n*/\nenum LedgerSpecificFlags\n{\n    // ltACCOUNT_ROOT\n    lsfPasswordSpent    = 0x00010000,   // True, if password set fee is spent.\n    lsfRequireDestTag   = 0x00020000,   // True, to require a DestinationTag for payments.\n    lsfRequireAuth      = 0x00040000,   // True, to require a authorization to hold IOUs.\n    lsfDisallowCALL     = 0x00080000,   // True, to disallow sending CALL.\n    lsfDisableMaster    = 0x00100000,   // True, force regular key\n    lsfNoFreeze         = 0x00200000,   // True, cannot freeze call states\n    lsfGlobalFreeze     = 0x00400000,   // True, all assets frozen\n    lsfDefaultCall      = 0x00800000,   // True, trust lines allow rippling by default\n\n    // ltOFFER\n    lsfPassive          = 0x00010000,\n    lsfSell             = 0x00020000,   // True, offer was placed as a sell.\n\n    // ltCALL_STATE\n    lsfLowReserve       = 0x00010000,   // True, if entry counts toward reserve.\n    lsfHighReserve      = 0x00020000,\n    lsfLowAuth          = 0x00040000,\n    lsfHighAuth         = 0x00080000,\n    lsfLowNoCall        = 0x00100000,\n    lsfHighNoCall       = 0x00200000,\n    lsfLowFreeze        = 0x00400000,   // True, low side has set freeze flag\n    lsfHighFreeze       = 0x00800000,   // True, high side has set freeze flag\n};\n\n//------------------------------------------------------------------------------\n\n/** Holds the list of known ledger entry formats.\n*/\nclass LedgerFormats : public KnownFormats <LedgerEntryType>\n{\nprivate:\n    LedgerFormats ();\n\npublic:\n    static LedgerFormats const& getInstance ();\n\nprivate:\n    void addCommonFields (Item& item);\n};\n\n} // call\n\n#endif\n\n", "comment_ratio": 0.16666666666666666}
{"lang": "c", "code": "#ifndef __WATCHDOG__\n#define __WATCHDOG__\n#include <iostream>\n#include <vector>\n\n#include <stdlib.h>\n#include <unistd.h>\n\n// Watchdog shuts down the program when too much time has passed.\nclass Watchdog {\npublic:\n\t// initialize the Watchdog library to avoid registering threads.\n\tstatic void initialize(int n);\n\n\t// destroy the Watchdog library to release resources.\n\tstatic void destroy();\n\t\n\t// create a watchdog with a certain timeout. Throws an exception if \n\t// too many watchdogs are created.\n\tWatchdog(std::chrono::milliseconds timeout);\n\tWatchdog(std::chrono::milliseconds timeout, const std::string& name);\n\t\n\t// ok resets the watchdog timer.\n\tvoid ok();\n\n\t// start starts the watchdog timer.\n\tvoid start();\n\n\t// stop stops the watchdog timer.\n\tvoid stop();\nprivate:\n\t// no construction without registration\n\tWatchdog();\n\t\n\t// no copying\n\tWatchdog( const Watchdog& );\n\tWatchdog& operator=( const Watchdog& );\n\n\t// static thread for checking wthe code\n\tstatic void check_thread();\n\n\tstatic uint64_t m_nWatchdogs;\n\tstatic std::atomic<uint64_t> m_nextThreadID;\n\tstatic std::atomic<uint64_t> *m_counts;\n\tstatic uint64_t* m_maxes;\n\tstatic std::thread m_thread;\n\tstatic std::atomic<bool> m_shutdown;\n\tstatic const std::chrono::milliseconds EPOCH;\n\tstatic std::vector<std::string> m_names;\n\t\n\tconst std::string m_name;\n\tuint64_t m_id;\n\tstd::chrono::milliseconds m_duration;\n};\n\n#endif /* __WATCHDOG__ */\n\n", "comment_ratio": 0.19298245614035087}
{"lang": "c", "code": "#include \"hdwwiz.h\"\r\n\r\n//\r\n// Define and initialize all device class GUIDs.\r\n// (This must only be done once per module!)\r\n//\r\n#include <initguid.h>\r\n#include <devguid.h>\r\n\r\n\r\n//\r\n// Define and initialize a global variable, GUID_NULL\r\n// (from coguid.h)\r\n//\r\nDEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\r\n\r\nTCHAR szUnknownDevice[64];\r\nUSHORT LenUnknownDevice;\r\n\r\nTCHAR szUnknown[64];\r\nUSHORT LenUnknown;\r\n\r\nPTCHAR\r\nBuildFriendlyName(\r\n   DEVINST DevInst,\r\n   HMACHINE hMachine\r\n   )\r\n{\r\n    PTCHAR Location;\r\n    PTCHAR FriendlyName;\r\n    CONFIGRET ConfigRet;\r\n    ULONG ulSize;\r\n    TCHAR szBuffer[MAX_PATH];\r\n\r\n    //\r\n    // Try the registry for FRIENDLYNAME\r\n    //\r\n\r\n    ulSize = sizeof(szBuffer);\r\n    ConfigRet = CM_Get_DevNode_Registry_Property_Ex(DevInst,\r\n                                                    CM_DRP_FRIENDLYNAME,\r\n                                                    NULL,\r\n                                                    szBuffer,\r\n                                                    &ulSize,\r\n                                                    0,\r\n                                                    hMachine\r\n                                                    );\r\n    if (ConfigRet != CR_SUCCESS || !*szBuffer) {\r\n        //\r\n        // Try the registry for DEVICEDESC\r\n        //\r\n\r\n        ulSize = sizeof(szBuffer);\r\n        ConfigRet = CM_Get_DevNode_Registry_Property_Ex(DevInst,\r\n                                                        CM_DRP_DEVICEDESC,\r\n                                                        NULL,\r\n                                                        szBuffer,\r\n                                                        &ulSize,\r\n                                                        0,\r\n                                                        hMachine\r\n                                                        );\r\n        if (ConfigRet != CR_SUCCESS || !*szBuffer) {\r\n            GUID ClassGuid;\r\n\r\n            //\r\n            // Try the registry for CLASSNAME\r\n            //\r\n\r\n            ulSize = sizeof(szBuffer);\r\n            ConfigRet = CM_Get_DevNode_Registry_Property_Ex(DevInst,\r\n                                                            CM_DRP_CLASSGUID,\r\n                                                            NULL,\r\n                                                            szBuffer,\r\n                                                            &ulSize,\r\n                                                            0,\r\n                                                            hMachine\r\n                                                            );\r\n\r\n\r\n            if (ConfigRet == CR_SUCCESS) {\r\n                pSetupGuidFromString(szBuffer, &ClassGuid);\r\n                }\r\n\r\n\r\n            if (!IsEqualGUID(&ClassGuid, &GUID_NULL) &&\r\n                !IsEqualGUID(&ClassGuid, &GUID_DEVCLASS_UNKNOWN))\r\n              {\r\n                ulSize = sizeof(szBuffer);\r\n                ConfigRet = CM_Get_DevNode_Registry_Property_Ex(DevInst,\r\n                                                                CM_DRP_CLASS,\r\n                                                                NULL,\r\n                                                                szBuffer,\r\n                                                                &ulSize,\r\n                                                                0,\r\n                                                                hMachine\r\n                                                                );\r\n                }\r\n            else {\r\n                ConfigRet = ~CR_SUCCESS;\r\n                }\r\n\r\n\r\n            }\r\n        }\r\n\r\n\r\n    if (ConfigRet == CR_SUCCESS && *szBuffer) {\r\n        FriendlyName = LocalAlloc(LPTR, ulSize);\r\n        if (FriendlyName) {\r\n            memcpy(FriendlyName, szBuffer, ulSize);\r\n            }\r\n        }\r\n    else {\r\n        FriendlyName = NULL;\r\n        }\r\n\r\n\r\n    return FriendlyName;\r\n}\r\n\r\nvoid\r\nAddItemToListView(\r\n    PHARDWAREWIZ HardwareWiz,\r\n    HWND hwndListView,\r\n    DEVINST DevInst,\r\n    DWORD Problem,\r\n    BOOL HiddenDevice,\r\n    DEVINST SelectedDevInst\r\n    )\r\n{\r\n    INT Index;\r\n    LV_ITEM lviItem;\r\n    PTCHAR FriendlyName;\r\n    PTCHAR LocationInfo;\r\n    GUID ClassGuid;\r\n    ULONG ulSize;\r\n    CONFIGRET ConfigRet;\r\n    TCHAR szBuffer[MAX_PATH];\r\n\r\n\r\n    lviItem.mask = LVIF_TEXT | LVIF_PARAM;\r\n    lviItem.iSubItem = 0;\r\n    lviItem.lParam = DevInst;\r\n\r\n    //\r\n    // Devices with problems need to go at the top of the list\r\n    //\r\n    if (Problem) {\r\n    \r\n        lviItem.iItem = 0;\r\n\r\n    } else {\r\n\r\n        lviItem.iItem = ListView_GetItemCount(hwndListView);\r\n    }\r\n    \r\n    //\r\n    // fetch a name for this device\r\n    //\r\n\r\n    FriendlyName = BuildFriendlyName(DevInst, HardwareWiz->hMachine);\r\n    if (FriendlyName) {\r\n    \r\n        lviItem.pszText = FriendlyName;\r\n\r\n    } else {\r\n    \r\n        lviItem.pszText = szUnknown;\r\n    }\r\n\r\n    //\r\n    // Fetch the class icon for this device.\r\n    //\r\n\r\n    ulSize = sizeof(szBuffer);\r\n    ConfigRet = CM_Get_DevNode_Registry_Property_Ex(DevInst,\r\n                                                    CM_DRP_CLASSGUID,\r\n                                                    NULL,\r\n                                                    szBuffer,\r\n                                                    &ulSize,\r\n                                                    0,\r\n                                                    HardwareWiz->hMachine\r\n                                                    );\r\n\r\n\r\n    if (ConfigRet == CR_SUCCESS) {\r\n    \r\n        pSetupGuidFromString(szBuffer, &ClassGuid);\r\n\r\n    } else {\r\n    \r\n        ClassGuid = GUID_DEVCLASS_UNKNOWN;\r\n    }\r\n\r\n    if (SetupDiGetClassImageIndex(&HardwareWiz->ClassImageList,\r\n                                  &ClassGuid,\r\n                                  &lviItem.iImage\r\n                                  ))\r\n    {\r\n        lviItem.mask |= (LVIF_IMAGE | LVIF_STATE);\r\n\r\n        if (Problem) {\r\n        \r\n            lviItem.state = (Problem == CM_PROB_DISABLED) ?\r\n                            INDEXTOOVERLAYMASK(IDI_DISABLED_OVL - IDI_CLASSICON_OVERLAYFIRST + 1) :\r\n                            INDEXTOOVERLAYMASK(IDI_PROBLEM_OVL - IDI_CLASSICON_OVERLAYFIRST + 1);\r\n\r\n        } else {\r\n\r\n            lviItem.state = INDEXTOOVERLAYMASK(0);\r\n        }\r\n\r\n        lviItem.stateMask = LVIS_OVERLAYMASK;\r\n\r\n        if (HiddenDevice) {\r\n\r\n            lviItem.state |= LVIS_CUT;\r\n            lviItem.stateMask |= LVIS_CUT;\r\n        }\r\n    }\r\n\r\n    Index = ListView_InsertItem(hwndListView, &lviItem);\r\n\r\n    if ((Index != -1) && (SelectedDevInst == DevInst)) {\r\n\r\n        ListView_SetItemState(hwndListView,\r\n                              Index,\r\n                              LVIS_SELECTED|LVIS_FOCUSED,\r\n                              LVIS_SELECTED|LVIS_FOCUSED\r\n                              );\r\n    }\r\n\r\n\r\n    if (FriendlyName) {\r\n    \r\n        LocalFree(FriendlyName);\r\n    }\r\n\r\n    return;\r\n}\r\n\r\n\r\nBOOL\r\nBuildDeviceListView(\r\n    PHARDWAREWIZ HardwareWiz,\r\n    HWND hwndListView,\r\n    BOOL ShowHiddenDevices,\r\n    DEVINST SelectedDevInst,\r\n    DWORD *DevicesDetected,\r\n    ADDDEVNODETOLIST_CALLBACK AddDevNodeToListCallBack\r\n    )\r\n{\r\n    HDEVINFO hDeviceInfo;\r\n    DWORD Index;\r\n    ULONG DevNodeStatus, DevNodeProblem;\r\n    SP_DEVINFO_DATA DevInfoData;\r\n    BOOL HiddenDevice;\r\n\r\n    *DevicesDetected = 0;\r\n\r\n    hDeviceInfo = SetupDiGetClassDevsEx(NULL,   // classguid\r\n                                        NULL,   // enumerator\r\n                                        NULL,   // hdwnParent\r\n                                        ShowHiddenDevices ? DIGCF_ALLCLASSES : DIGCF_ALLCLASSES | DIGCF_PRESENT,\r\n                                        NULL,   // existing HDEVINFO set\r\n                                        HardwareWiz->hMachine ? HardwareWiz->MachineName : NULL,\r\n                                        0\r\n                                        );\r\n                                        \r\n    if (hDeviceInfo == INVALID_HANDLE_VALUE) {\r\n    \r\n        return FALSE;\r\n    }\r\n\r\n    DevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);\r\n    Index = 0;\r\n    while (SetupDiEnumDeviceInfo(hDeviceInfo, Index++, &DevInfoData)) {\r\n\r\n        if (CM_Get_DevNode_Status_Ex(&DevNodeStatus,\r\n                                     &DevNodeProblem,\r\n                                     DevInfoData.DevInst,\r\n                                     0,\r\n                                     HardwareWiz->hMachine\r\n                                     ) != CR_SUCCESS) {\r\n        \r\n            DevNodeProblem = 0;\r\n        }\r\n\r\n        HiddenDevice = IsDeviceHidden(HardwareWiz, &DevInfoData);\r\n\r\n        //\r\n        // Only call AddItemToListView if the device is not a hidden device.\r\n        //\r\n        // If ProblemDevices is TRUE then only call the callback if this device\r\n        // has a problem.  If ProblemDevices is FALSE then only call the callback\r\n        // if this device does NOT have a problem.  \r\n        //\r\n        if (ShowHiddenDevices || !HiddenDevice) {\r\n        \r\n            //\r\n            // Check the callback to see if we should add this devnode to the list.\r\n            //\r\n            if (!AddDevNodeToListCallBack || AddDevNodeToListCallBack(HardwareWiz, &DevInfoData)) {\r\n                \r\n                *DevicesDetected += 1;\r\n\r\n                //\r\n                // Add the item to the ListView\r\n                //\r\n                AddItemToListView(HardwareWiz,\r\n                                  hwndListView,\r\n                                  DevInfoData.DevInst,\r\n                                  DevNodeProblem,\r\n                                  HiddenDevice,\r\n                                  SelectedDevInst);\r\n            }\r\n        }\r\n\r\n        DevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);\r\n    }\r\n    \r\n    SetupDiDestroyDeviceInfoList(hDeviceInfo);\r\n    \r\n    return TRUE;\r\n}\r\n\n", "comment_ratio": 0.15476190476190477}
{"lang": "c", "code": "\ufeff// ----------------------------------------------------------------------------------------\n//                              COPYRIGHT NOTICE\n// ----------------------------------------------------------------------------------------\n//\n// The Source Code Store LLC\n// ACTIVEGANTT SCHEDULER COMPONENT FOR C++ - ActiveGanttVC\n// ActiveX Control\n// Copyright (c) 2002-2017 The Source Code Store LLC\n//\n// All Rights Reserved. No parts of this file may be reproduced, modified or transmitted \n// in any form or by any means without the written permission of the author.\n//\n// ----------------------------------------------------------------------------------------\n#pragma once\n\n\n\nclass WorkingTime : public clsItemBase\n{\n\tDECLARE_DYNCREATE(WorkingTime)\n\npublic:\n\n\tWorkingTime();\n\tvirtual ~WorkingTime();\n\tvirtual void OnFinalRelease();\n\n\tclsCollectionBase* mp_oCollection;\n\tTime* mp_oFromTime;\n\tTime* mp_oToTime;\n\n\tIDispatch* odl_GetFromTime(void);\n\tTime* GetFromTime(void);\n\n\tIDispatch* odl_GetToTime(void);\n\tTime* GetToTime(void);\n\n\tBSTR odl_GetKey(void);\n\tCString GetKey(void);\n\tvoid odl_SetKey(LPCTSTR newVal);\n\tvoid SetKey(CString newVal);\n\n\n\tBSTR odl_GetXML(void);\n\tCString GetXML(void);\n\n\tvoid odl_SetXML(LPCTSTR sXML);\n\tvoid SetXML(CString sXML);\n\n\tBOOL IsNull(void);\n\n\tvoid Initialize(void);\n\n\tvoid InitVars(void);\n\nprotected:\n\tDECLARE_DISPATCH_MAP()\n\tDECLARE_MESSAGE_MAP()\n\tDECLARE_OLECREATE(WorkingTime)\n\tDECLARE_INTERFACE_MAP()\n\n};\n", "comment_ratio": 0.20967741935483872}
{"lang": "c", "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"diag/Trace.h\"\n\n#include \"SDCard.h\"\n#include \"stm32f769i_discovery_sd.h\"\n#include \"ff_gen_drv.h\"\n#include \"sd_diskio.h\"\n#include \"ILDA.h\"\n\nstatic FATFS FileSystem;\nstatic char SD_Path[4];\n\nstatic uint32_t FileCount = 0;\n\nstatic const ILDA_FORMAT_2 IldaColors[] =\n{\n#include \"ildacolors.inc\"\n\t\t};\n\nvoid sdCard_Init()\n{\n\t// Try to attach the driver\n\tif (FATFS_LinkDriver(&SD_Driver, SD_Path) == FR_OK)\n\t{\n\t\ttrace_puts(\"SD Driver linked\");\n\n\t\tif (f_mount(&FileSystem, (TCHAR const*) \"\", 0) == FR_OK)\n\t\t{\n\t\t\ttrace_puts(\"SD Mounted.\");\n\t\t}\n\t}\n}\n\nuint32_t sdCard_GetFileCount()\n{\n\tstatic uint8_t firstCount = 0;\n\n\tif (!firstCount)\n\t{\n\t\tFRESULT res;\n\t\tFileCount = 0;\n\t\tFILINFO fno;\n\t\tDIR dir;\n\n\t\tFileCount = 0;\n\n\t\tres = f_findfirst(&dir, &fno, \"/Graphics\", \"*.ild\");\n\n\t\twhile (fno.fname[0])\n\t\t{\n\t\t\tif (res == FR_OK)\n\t\t\t{\n\t\t\t\t// Visible and not a subdirectory or volume\n\t\t\t\tif ((fno.fattrib & 0xE) == 0)\n\t\t\t\t{\n\t\t\t\t\t++FileCount;\n//\t\t\t\t\ttrace_printf(\"File %d: %s\\n\", FileCount, fno.fname);\n\t\t\t\t}\n\t\t\t\tres = f_findnext(&dir, &fno);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tFileCount = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tf_closedir(&dir);\n\t\ttrace_printf(\"Files found: %d\\n\", FileCount);\n\t\tfirstCount = 1;\n\t}\n\n\treturn FileCount;\n}\n\nuint8_t sdCard_LoadIldaFile(uint32_t index, SD_FRAME_TABLE *table,\n\t\tSD_FRAME *frames)\n{\n\tSD_FRAME *nextFrame = frames;\n\tILDA_FORMAT_4 *nextPoint = &(nextFrame->points);\n\n\t// Valid index?\n\tif (index == 0 || index > FileCount) return 0;\n\n\t// Walk the directory until we find the index;\n\tFRESULT res;\n\tFILINFO fno;\n\tDIR dir;\n\tuint32_t idx = 0;\n\tres = f_findfirst(&dir, &fno, \"/Graphics\", \"*.ild\");\n\n\twhile (fno.fname[0])\n\t{\n\t\tif (res == FR_OK)\n\t\t{\n\t\t\t// Visible and not a subdirectory or volume\n\t\t\tif ((fno.fattrib & 0xE) == 0)\n\t\t\t{\n\t\t\t\t++idx;\n\t\t\t\tif (idx == index) break;\n\t\t\t}\n\t\t\tres = f_findnext(&dir, &fno);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tidx = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tf_closedir(&dir);\n\n\tif (idx != index) return 0;\n\n\ttrace_printf(\"Load ILDA %d (%s) found\\n\", index, fno.fname);\n\n\tchar outstr[280];\n\tstrcpy(outstr, \"/Graphics/\");\n\tstrcat(outstr, fno.fname);\n\n\tFIL fil;\n\tif (f_open(&fil, outstr, FA_READ) != FR_OK) return 0;\n\n\t// Set the frame count to 0;\n\ttable->frameCount = 0;\n\t// Save the name\n\tstrcpy((char*) table->fname, (char*) fno.fname);\n\tstrcpy((char*) table->altname, (char*) fno.altname);\n\n\t// Loop until we are out of frames\n\tdo\n\t{\n\t\tUINT b;\n\t\tILDA_HEADER header;\n\n\t\t// Read the header\n\t\tif (f_read(&fil, &header, sizeof(header), &b) != FR_OK) break;\n\n\t\tif (b != sizeof(header)) break;\n\n\t\t// Valid?\n\t\tif (header.ilda[0] != 'I' || header.ilda[1] != 'L'\n\t\t\t\t|| header.ilda[2] != 'D' || header.ilda[3] != 'A') break;\n\n\t\tuint16_t rCount;\n\t\trCount = header.numRecords.b[0];\n\t\trCount <<= 8;\n\t\trCount += header.numRecords.b[1];\n\n\t\t// 0 records marks end\n\t\tif (!rCount) break;\n\n\t\tint n;\n\t\tfor (n = 0; n < rCount; ++n)\n\t\t{\n\t\t\t// We have 5 different handlers for the 5 different\n\t\t\t// ILDA data formats (ugh)\n\t\t\tif (header.format == 0)\n\t\t\t{\n\t\t\t\tILDA_FORMAT_0 in;\n\n\t\t\t\t// Try to read the next point\n\t\t\t\tif (f_read(&fil, &in, sizeof(in), &b) != FR_OK) break;\n\t\t\t\tif (b != sizeof(in)) break;\n\n\t\t\t\t// Change endian and store X, Y and Z\n\t\t\t\tnextPoint[n].x.b[1] = in.x.b[0];\n\t\t\t\tnextPoint[n].x.b[0] = in.x.b[1];\n\t\t\t\tnextPoint[n].y.b[1] = in.y.b[0];\n\t\t\t\tnextPoint[n].y.b[0] = in.y.b[1];\n\t\t\t\tnextPoint[n].z.b[1] = in.z.b[0];\n\t\t\t\tnextPoint[n].z.b[0] = in.z.b[1];\n\n\t\t\t\t// Store status\n\t\t\t\tnextPoint[n].status = in.status;\n\n\t\t\t\t// Lookup and store colors\n\t\t\t\tnextPoint[n].red = IldaColors[in.colorIdx].red;\n\t\t\t\tnextPoint[n].green = IldaColors[in.colorIdx].green;\n\t\t\t\tnextPoint[n].blue = IldaColors[in.colorIdx].blue;\n\t\t\t}\n\t\t\telse if (header.format == 1)\n\t\t\t{\n\t\t\t\tILDA_FORMAT_1 in1;\n\n\t\t\t\t// Try to read the next point\n\t\t\t\tif (f_read(&fil, &in1, sizeof(in1), &b) != FR_OK) break;\n\t\t\t\tif (b != sizeof(in1)) break;\n\n\t\t\t\t// Change endian and store X, Y and Z\n\t\t\t\tnextPoint[n].x.b[1] = in1.x.b[0];\n\t\t\t\tnextPoint[n].x.b[0] = in1.x.b[1];\n\t\t\t\tnextPoint[n].y.b[1] = in1.y.b[0];\n\t\t\t\tnextPoint[n].y.b[0] = in1.y.b[1];\n\n\t\t\t\tnextPoint[n].z.w = 0;\n\n\t\t\t\t// Store status\n\t\t\t\tnextPoint[n].status = in1.status;\n\n\t\t\t\t// Lookup and store colors\n\t\t\t\tnextPoint[n].red = IldaColors[in1.colorIdx].red;\n\t\t\t\tnextPoint[n].green = IldaColors[in1.colorIdx].green;\n\t\t\t\tnextPoint[n].blue = IldaColors[in1.colorIdx].blue;\n\t\t\t}\n\t\t\telse if (header.format == 2)\n\t\t\t{\n\t\t\t\t// Color Palette\n\t\t\t\tILDA_FORMAT_2 in2;\n\t\t\t\tif (f_read(&fil, &in2, sizeof(in2), &b) != FR_OK) break;\n\t\t\t\tif (b != sizeof(in2)) break;\n\t\t\t}\n\t\t\telse if (header.format == 4)\n\t\t\t{\n\t\t\t\tILDA_FORMAT_4 in4;\n\n\t\t\t\t// Try to read the next point\n\t\t\t\tif (f_read(&fil, &in4, sizeof(in4), &b) != FR_OK) break;\n\t\t\t\tif (b != sizeof(in4)) break;\n\n\t\t\t\t// Change endian and store X, Y and Z\n\t\t\t\tnextPoint[n].x.b[1] = in4.x.b[0];\n\t\t\t\tnextPoint[n].x.b[0] = in4.x.b[1];\n\t\t\t\tnextPoint[n].y.b[1] = in4.y.b[0];\n\t\t\t\tnextPoint[n].y.b[0] = in4.y.b[1];\n\t\t\t\tnextPoint[n].z.b[1] = in4.z.b[0];\n\t\t\t\tnextPoint[n].z.b[0] = in4.z.b[1];\n\n\t\t\t\t// Store status\n\t\t\t\tnextPoint[n].status = in4.status;\n\n\t\t\t\t// Store colors\n\t\t\t\tnextPoint[n].red = in4.red;\n\t\t\t\tnextPoint[n].green = in4.green;\n\t\t\t\tnextPoint[n].blue = in4.blue;\n\t\t\t}\n\t\t\telse if (header.format == 5)\n\t\t\t{\n\t\t\t\tILDA_FORMAT_5 in5;\n\n\t\t\t\t// Try to read the next point\n\t\t\t\tif (f_read(&fil, &in5, sizeof(in5), &b) != FR_OK) break;\n\t\t\t\tif (b != sizeof(in5)) break;\n\n\t\t\t\t// Change endian and store X, Y and Z\n\t\t\t\tnextPoint[n].x.b[1] = in5.x.b[0];\n\t\t\t\tnextPoint[n].x.b[0] = in5.x.b[1];\n\t\t\t\tnextPoint[n].y.b[1] = in5.y.b[0];\n\t\t\t\tnextPoint[n].y.b[0] = in5.y.b[1];\n\n\t\t\t\tnextPoint[n].z.w = 0;\n\n\t\t\t\t// Store status\n\t\t\t\tnextPoint[n].status = in5.status;\n\n\t\t\t\t// Store colors\n\t\t\t\tnextPoint[n].red = in5.red;\n\t\t\t\tnextPoint[n].green = in5.green;\n\t\t\t\tnextPoint[n].blue = in5.blue;\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (n != rCount) break;\n\n\t\t// Don't store palletes!\n\t\tif (header.format != 2)\n\t\t{\n\t\t\t// Update the count\n\t\t\tnextFrame->numPoints = rCount;\n\n\t\t\t// Store the frame pointer in the table\n\t\t\ttable->frameCount++;\n\t\t\ttable->frames[table->frameCount - 1] = nextFrame;\n\n\t\t\t// Advance the frame pointer\n\t\t\t// DWORD align\n\t\t\tuint32_t p = (uint32_t) (&(nextPoint[rCount]));\n\t\t\tif (p & 3)\n\t\t\t{\n\t\t\t\tp += 3;\n\t\t\t\tp &= 0xFFFFFFFC;\n\t\t\t}\n\t\t\tnextFrame = (SD_FRAME*) p;\n\n\t\t\t// Reset the point data pointer\n\t\t\tnextPoint = &(nextFrame->points);\n\t\t}\n\n\t}\n\twhile (1);\n\n\t// Close the file\n\tf_close(&fil);\n\n\t// Nothing read?\n\tif (!table->frameCount) return 0;\n\n//\ttrace_printf(\"Loaded %d frames at:\\n\", table->frameCount);\n//\tfor (uint32_t i = 0; i < table->frameCount; ++i)\n//\t\ttrace_printf(\"  %08x\\n\", table->frames[i]);\n\n\treturn 1;\n}\n\n", "comment_ratio": 0.13149847094801223}
{"lang": "c", "code": "#ifndef _LOGIT_H_\n#define _LOGIT_H_\n\n#include <cmath>\n\ntemplate <typename T>\ninline T _logit(T x) {\n    x /= 1 - x;\n    return std::log(x);\n};\n\n\ntemplate <typename T>\ninline T _expit(T x) {\n    return 1 / (1 + std::exp(-x));\n};\n\n\n//\n// The logistic sigmoid function 'expit' is\n//\n//     S(x) = 1/(1 + exp(-x))     = exp(x)/(exp(x) + 1)\n//\n// so\n//\n// log S(x) = -log(1 + exp(-x))   = x - log(exp(x) + 1)\n//          = -log1p(exp(-x))     = x - log1p(exp(x))\n//\n// By using -log1p(exp(-x)) for x >= 0 and x - log1p(exp(x))\n// for x < 0, we extend the range of x values for which we\n// obtain accurate results (compared to the naive implementation\n// log(expit(x))).\n//\ntemplate <typename T>\ninline T _log_expit(T x) {\n    if (x < 0.0) {\n        return x - std::log1p(std::exp(x));\n    }\n    else {\n        return -std::log1p(std::exp(-x));\n    }\n};\n\n\nnpy_float logitf(npy_float x)  {return _logit(x);};\nnpy_double logit(npy_double x) {return _logit(x);};\nnpy_longdouble logitl(npy_longdouble x) {return _logit(x);};\n\nnpy_float expitf(npy_float x) {return _expit(x);};\nnpy_double expit(npy_double x) {return _expit(x);};\nnpy_longdouble expitl(npy_longdouble x) {return _expit(x);};\n\nnpy_float log_expitf(npy_float x) {return _log_expit(x);};\nnpy_double log_expit(npy_double x) {return _log_expit(x);};\nnpy_longdouble log_expitl(npy_longdouble x) {return _log_expit(x);};\n\n#endif\n\n", "comment_ratio": 0.25862068965517243}
{"lang": "c", "code": "#ifndef __E_DRIVER_CHOICE_H_INCLUDED__\r\n#define __E_DRIVER_CHOICE_H_INCLUDED__\r\n\r\n#include <iostream>\r\n#include <cstdio>\r\n#include \"EDriverTypes.h\"\r\n#include \"irr/core/Types.h\"\r\n#include \"IrrlichtDevice.h\"\r\n\r\nnamespace irr\r\n{\r\n\r\n//! ask user for driver\r\nstatic irr::video::E_DRIVER_TYPE driverChoiceConsole(bool allDrivers=true)\r\n{\r\n\tconst char* const names[] = {\"NullDriver\",\"OpenGL 4.3+\",\"Vulkan\"};\r\n\tprintf(\"Please select the driver you want:\\n\");\r\n\tuint32_t i=0;\r\n\tfor (i=irr::video::EDT_COUNT; i>0; --i)\r\n\t{\r\n\t\tif (allDrivers || (irr::IrrlichtDevice::isDriverSupported(irr::video::E_DRIVER_TYPE(i-1))))\r\n\t\t\tprintf(\" (%c) %s\\n\", 'a'+irr::video::EDT_COUNT-i, names[i-1]);\r\n\t}\r\n\r\n\tchar c;\r\n\tstd::cin >> c;\r\n\tc = irr::video::EDT_COUNT+'a'-c;\r\n\r\n\tfor (i=irr::video::EDT_COUNT; i>0; --i)\r\n\t{\r\n\t\tif (!(allDrivers || (irr::IrrlichtDevice::isDriverSupported(irr::video::E_DRIVER_TYPE(i-1)))))\r\n\t\t\t--c;\r\n\t\tif ((char)i==c)\r\n\t\t\treturn irr::video::E_DRIVER_TYPE(i-1);\r\n\t}\r\n\treturn irr::video::EDT_COUNT;\r\n}\r\n\r\n} // end namespace irr\r\n\r\n#endif\r\n\n", "comment_ratio": 0.10869565217391304}
{"lang": "c", "code": "#ifndef OPCODEONE_H_\n#define OPCODEONE_H_\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <functional>\n\n#define VERSION \"0.0.1\"\n\n#define ENDIANESS \"Big endian\"\n\n\n\n// MACROS\n\n#define FL (reg[0x0c])\n#define SB (reg[0x0d])\n#define SP (reg[0x0e])\n#define PC (reg[0x0f])\n\n\n#define READPRI(addr) primary_address_bus[addr]\n#define WRITEPRI(addr, val) { primary_address_bus[addr] = (val); }\n\n#define READSEC(addr) secondary_address_bus[addr]\n#define WRITESEC(addr, val) { secondary_address_bus[addr] = (val); }\n\n\n#define OPCODE (READPRI(PC) >> 16)\n\n#define MODE ((READPRI(PC) >> 12) & 0x0f)\n\n#define REG_3 reg[READPRI(PC) & 0x0f]\n\n#define REG_2 reg[(READPRI(PC) >> 4) & 0x0f]\n\n#define REG_1 reg[(READPRI(PC) >> 8) & 0x0f]\n\n#define ADDR READPRI(PC+1)\n\n#define OFFSET1 READPRI(PC+1)\n\n#define OFFSET2 READPRI(PC+2)\n\n#define VALUE READPRI(PC+1)\n\n#define IMM_OFFSET (READPRI(PC >> 8) & 0x0f)\n\n\n#define REG_PLUS_IMM_D (REG_1 + NEAR_OFFSET)\n#define REG_MINUS_IMM_D (REG_1 - NEAR_OFFSET)\n#define REG_PLUS_IMM_S (REG_2 + NEAR_OFFSET)\n#define REG_MINUS_IMM_S (REG_2 - NEAR_OFFSET)\n\n#define REG_PLUS_REG_OFFSET_D (REG_1 + REG_3)\n#define REG_MINUS_REG_OFFSET_D (REG_1 - REG_3)\n#define REG_PLUS_REG_OFFSET_S (REG_2 + REG_3)\n#define REG_MINUS_REG_OFFSET_S (REG_2 - REG_3)\n\n#define REG_PLUS_OFFSET_D (REG_1 + OFFSET1)\n#define REG_MINUS_OFFSET_D (REG_1 - OFFSET1)\n#define REG_PLUS_OFFSET_S (REG_2 + OFFSET1)\n#define REG_MINUS_OFFSET_S (REG_2 - OFFSET1)\n\n#define ADDR_PLUS_IMM_IMM_OFFSET (ADDR + NEAR_OFFSET)\n#define ADDR_MINUS_IMM_OFFSET (ADDR - NEAR_OFFSET)\n\n#define ADDR_PLUS_OFFSET (ADDR + OFFSET2)\n#define ADDR_MINUS_OFFSET (ADDR - OFFSET2)\n\n#define ADDR_PLUS_REG_OFFSET (ADDR + REG_3)\n#define ADDR_MINUS_REG_OFFSET (ADDR - REG_3)\n\n\n\n\nclass OpcodeOne {\n\npublic:\n\n\tuint32_t *primary_address_bus;\n\tuint32_t *secondary_address_bus;\n\n\tuint32_t reg[16]; // Registers\n\t/*\n\t\t\"A\": \t\t0x00,\n\t\t\"B\": \t\t0x01,\n\t\t\"C\": \t\t0x02,\n\t\t\"D\": \t\t0x03,\n\t\t\"unused1\":\t0x04,\n\t\t\"unused2\":\t0x05,\n\t\t\"unused3\":\t0x06,\n\t\t\"unused4\":\t0x07,\n\t\t\"unused5\":\t0x08,\n\t\t\"unused6\":\t0x09,\n\t\t\"unused7\":\t0x0a,\n\t\t\"unused8\":\t0x0b,\n\t\t\"FL\":\t\t0x0c,\n\t\t\"SB\":\t\t0x0d,\n\t\t\"SP\":\t\t0x0e,\n\t\t\"PC\":\t\t0x0f\n\t}\n\t*/\n\t\n\n\tuint8_t halted = 0; // Indicates the machine is halted\n\n\tOpcodeOne();\n\t~OpcodeOne();\n\n\tvoid Run();\n\n\t\n\n\tvoid SetIOReadCallback(std::function<uint32_t(uint32_t)> cb);\n\tvoid SetIOWriteCallback(std::function<void(uint32_t, uint32_t)> cb);\n\n\t\n\tvoid Reset();\n\n\t// Pin out\n\n\tuint8_t GetHLT();\n\tuint8_t GetABS();\n\n\nprivate:\n\n\n\tstd::function<uint32_t(uint32_t)> IOReadCallback;\n\tstd::function<void(uint32_t, uint32_t)> IOWriteCallback;\n\n\tuint32_t ReadIO(uint32_t addr);\n\tvoid WriteIO(uint32_t addr, uint32_t val);\n\n\tuint32_t IOReadPlaceholder(uint32_t addr);\n\tvoid IOWritePlaceholder(uint32_t addr, uint32_t data);\n\n\n\t// --- Instruction methods ---\n\n\n\tvoid Inst_ABT();\t// ABT (Address Bus Transfer)\n\tvoid Inst_ADD();\t// ADD (ADDition)\n\tvoid Inst_AND();\t// AND\n\tvoid Inst_BIT();\t// BIT\n\tvoid Inst_CALL();\t// CALL\n\tvoid Inst_CMP();\t// CMP (CoMPare)\n\tvoid Inst_CP();\t\t// CP (CoPy)\n\tvoid Inst_DEC();\t// DEC (DECrement)\n\tvoid Inst_DIV();\t// DIV (DIVision)\n\tvoid Inst_HALT();\t// HALT\n\tvoid Inst_IN();\t\t// IN (INput)\n\tvoid Inst_INC();\t// INC (INCrease)\n\tvoid Inst_JMP();\t// JMP (JuMP)\n\tvoid Inst_LD();\t\t// LD (LoaD)\n\tvoid Inst_MUL();\t// MUL (MULtiplication)\n\tvoid Inst_NAND();\t// NAND (Not AND)\n\tvoid Inst_NEG();\t// NEG (NEGative)\n\tvoid Inst_OR();\t\t// OR\n\tvoid Inst_OUT();\t// OUT (OUTput)\n\tvoid Inst_PAR();\t// PAR (Primary Address Read)\n\tvoid Inst_PAW();\t// PAW (Primary Address Write)\n\tvoid Inst_POP();\t// POP\n\tvoid Inst_PUSH();\t// PUSH\n\tvoid Inst_RET();\t// RET (REturn)\n\tvoid Inst_ROT();\t// ROT (ROTate)\n\tvoid Inst_SAR();\t// SAR (Secondary Address Read)\n\tvoid Inst_SAW();\t// SAW (Secondary Address Write)\n\tvoid Inst_SH();\t\t// SH (SHift)\n\tvoid Inst_SUB();\t// SUB (SUBtraction)\n\tvoid Inst_SWP();\t// SWP (SWaP)\n\tvoid Inst_XCHG();\t// XCHG (eXCHanGe)\n\tvoid Inst_XOR();\t// XOR\n\t\n};\n\n#endif\n", "comment_ratio": 0.20670391061452514}
{"lang": "c", "code": "#ifndef CALL_CONSENSUS_CONSENSUS_PARMS_H_INCLUDED\n#define CALL_CONSENSUS_CONSENSUS_PARMS_H_INCLUDED\n\n#include <chrono>\n#include <cstddef>\n\nnamespace call {\n\nusing namespace std::chrono_literals;\n\n/** Consensus algorithm parameters\n\n    Parameters which control the consensus algorithm.  This are not\n    meant to be changed arbitrarily.\n*/\nstruct ConsensusParms\n{\n\n    //-------------------------------------------------------------------------\n    // Validation and proposal durations are relative to NetClock times, so use\n    // second resolution\n    /** The duration a validation remains current after its ledger's\n       close time.\n\n        This is a safety to protect against very old validations and the time\n        it takes to adjust the close time accuracy window.\n    */\n    std::chrono::seconds validationVALID_WALL = 5min;\n\n    /** Duration a validation remains current after first observed.\n\n       The duration a validation remains current after the time we\n       first saw it. This provides faster recovery in very rare cases where the\n       number of validations produced by the network is lower than normal\n    */\n    std::chrono::seconds validationVALID_LOCAL = 3min;\n\n    /**  Duration pre-close in which validations are acceptable.\n\n        The number of seconds before a close time that we consider a validation\n        acceptable. This protects against extreme clock errors\n    */\n    std::chrono::seconds validationVALID_EARLY = 3min;\n\n\n    //! How long we consider a proposal fresh\n    std::chrono::seconds proposeFRESHNESS = 20s;\n\n    //! How often we force generating a new proposal to keep ours fresh\n    std::chrono::seconds proposeINTERVAL = 12s;\n\n\n    //-------------------------------------------------------------------------\n    // Consensus durations are relative to the internal Consenus clock and use\n    // millisecond resolution.\n\n    //! The percentage threshold above which we can declare consensus.\n    std::size_t minCONSENSUS_PCT = 80;\n\n    //! The duration a ledger may remain idle before closing\n    std::chrono::milliseconds ledgerIDLE_INTERVAL = 15s;\n\n    //! The number of seconds we wait minimum to ensure participation\n    std::chrono::milliseconds ledgerMIN_CONSENSUS = 1950ms;\n\n    //! Minimum number of seconds to wait to ensure others have computed the LCL\n    std::chrono::milliseconds ledgerMIN_CLOSE = 2s;\n\n    //! How often we check state or change positions\n    std::chrono::milliseconds ledgerGRANULARITY = 1s;\n\n    /** The minimum amount of time to consider the previous round\n        to have taken.\n\n        The minimum amount of time to consider the previous round\n        to have taken. This ensures that there is an opportunity\n        for a round at each avalanche threshold even if the\n        previous consensus was very fast. This should be at least\n        twice the interval between proposals (0.7s) divided by\n        the interval between mid and late consensus ([85-50]/100).\n    */\n    std::chrono::milliseconds avMIN_CONSENSUS_TIME = 5s;\n\n    //------------------------------------------------------------------------------\n    // Avalanche tuning\n    // As a function of the percent this round's duration is of the prior round,\n    // we increase the threshold for yes vots to add a tranasaction to our\n    // position.\n\n    //! Percentage of nodes on our UNL that must vote yes\n    std::size_t avINIT_CONSENSUS_PCT = 50;\n\n    //! Percentage of previous round duration before we advance\n    std::size_t avMID_CONSENSUS_TIME = 50;\n\n    //! Percentage of nodes that most vote yes after advancing\n    std::size_t avMID_CONSENSUS_PCT = 65;\n\n    //! Percentage of previous round duration before we advance\n    std::size_t avLATE_CONSENSUS_TIME = 85;\n\n    //! Percentage of nodes that most vote yes after advancing\n    std::size_t avLATE_CONSENSUS_PCT = 70;\n\n    //! Percentage of previous round duration before we are stuck\n    std::size_t avSTUCK_CONSENSUS_TIME = 200;\n\n    //! Percentage of nodes that must vote yes after we are stuck\n    std::size_t avSTUCK_CONSENSUS_PCT = 95;\n\n    //! Percentage of nodes required to reach agreement on ledger close time\n    std::size_t avCT_CONSENSUS_PCT = 75;\n\n    //--------------------------------------------------------------------------\n\n    /** Whether to use roundCloseTime or effCloseTime for reaching close time\n        consensus.\n        This was added to migrate from effCloseTime to roundCloseTime on the\n        live network. The desired behavior (as given by the default value) is\n        to use roundCloseTime during consensus voting and then use effCloseTime\n        when accepting the consensus ledger.\n    */\n    bool useRoundedCloseTime = true;\n};\n\n}  // call\n#endif\n\n", "comment_ratio": 0.19753086419753085}
{"lang": "c", "code": "#ifndef _HOST_DEVICE_SHARED_MACROS_H\n#define _HOST_DEVICE_SHARED_MACROS_H\n\n/*******************************************************************\n                    Common structures & routines\n*******************************************************************/\n\n\n/*******************************************************************\n                    Glue code for CPU/GPU compilation\n*******************************************************************/\n\n#if (defined(__STDC_HOSTED__) || defined(__cplusplus)) && !defined(__CUDACC__)    // we're in C-compliant compiler, probably host\n#    define HOST_CODE 1\n#elif defined(__CUDACC__)\n#   define CUDA_CODE\n#else\n#   define HLSL_CODE\n#define FALCOR_SHADER_CODE\n#endif\n\n#ifdef HLSL_CODE\n//#extension GL_NV_shader_buffer_load : enable\n#endif\n\n#ifdef HOST_CODE\n\n/*******************************************************************\n                    CPU declarations\n*******************************************************************/\n#define loop_unroll\n#define v2 vec2\n#define v3 vec3\n#define v4 vec4\n#define _fn\n#define DEFAULTS(x_) = ##x_\n#define SamplerState std::shared_ptr<Sampler>\n#define Texture2D std::shared_ptr<Texture>\n#elif defined(CUDA_CODE)\n/*******************************************************************\n                    CUDA declarations\n*******************************************************************/\n// Modifiers\n#define DEFAULTS(x_)\n#define in\n#define out &\n#define _ref(__x) __x&\n#define discard\n#define sampler2D int\n#define inline __forceinline\n#define _fn inline __device__\n// Types\n#define int32_t int\n#define uint unsigned int\n#define uint32_t uint\n// Vector math\n#define vec2 float2\n#define vec3 float3\n#define vec4 float4\n#ifndef mat4\n#define mat4 mat4_t\n#endif\n#ifndef mat3\n#define mat3 mat3_t\n#endif\n#define mul(mx, v) ((v) * (mx))\n#define v2 make_float2\n#define v3 make_float3\n#define v4 make_float4\n#else\n/*******************************************************************\n                    HLSL declarations\n*******************************************************************/\n#define loop_unroll [unroll]\n#define _fn \n#define __device__ \n#define inline \n#define _ref(__x) inout __x\n#define DEFAULTS(x_)\n#endif\n\n/*******************************************************************\n                    Lights\n*******************************************************************/\n\n/**\n    Types of light sources. Used in LightData structure.\n*/\n#define LightPoint           0    ///< Point light source, can be a spot light if its opening angle is < 2pi\n#define LightDirectional     1    ///< Directional light source\n#define LightArea            2    ///< Area light source, potentially with arbitrary geometry\n//#define LightVolume        3    ///< Volumetric light source\n\n#define MAX_LIGHT_SOURCES 16\n\n/*******************************************************************\n                    Material\n*******************************************************************/\n\n/** Type of the material layer:\n    Diffuse (Lambert model, can be Oren-Nayar if roughness is not 1),\n    Reflective material (conductor),\n    Refractive material (dielectric)\n*/\n#define     MatNone            0            ///< A \"null\" material. Used to end the list of layers\n#define     MatLambert         1            ///< A simple diffuse Lambertian BRDF layer\n#define     MatConductor       2            ///< A conductor material, metallic reflection, no refraction nor subscattering\n#define     MatDielectric      3            ///< A refractive dielectric material, if applied on top of others acts like a coating\n#define     MatEmissive        4            ///< An emissive material. Can be assigned to a geometry to create geometric a light source (will be supported only with ray tracing)\n#define     MatUser            5            ///< User-defined material, should be parsed and processed by user\n#define     MatNumTypes        (MatUser+1)  ///< Number of material types\n\n/** Type of used Normal Distribution Function (NDF). Options so far\n    Beckmann distribution (original Blinn-Phong)\n    GGX distribution (smoother highlight, better fit for some materials, default)\n*/\n#define     NDFBeckmann        0    ///< Beckmann distribution for NDF\n#define     NDFGGX             1    ///< GGX distribution for NDF\n#define     NDFUser            2    ///< User-defined distribution for NDF, should be processed by user\n\n#define     BlendFresnel       0    ///< Material layer is blended according to Fresnel\n#define     BlendConstant      1    ///< Material layer is blended according to a constant factor stored in w component of constant color\n#define     BlendAdd           2    ///< Material layer is added to the previous layers\n\n/**\n    This number specifies a maximum possible number of layers in a material.\n    There seems to be a good trade-off between performance and flexibility.\n    With three layers, we can represent e.g. a base conductor material with diffuse component, coated with a dielectric.\n    If this number is changed, the scene serializer should make sure the new number of layers is saved/loaded correctly.\n*/\n#define     MatMaxLayers    3\n\n#define ROUGHNESS_CHANNEL_BIT 2\n\n#endif //_HOST_DEVICE_SHARED_MACROS_H\n\n", "comment_ratio": 0.1411042944785276}
{"lang": "c", "code": "#pragma once\n\n#include <stddef.h>                             // size_t parameter.\n#include <vector>                               // std::vector return value.\n\n#include \"BitFunnel/BitFunnelTypes.h\"           // Rank parameter.\n#include \"BitFunnel/Index/RowId.h\"              // RowId parameter.\n#include \"BitFunnel/Plan/IResultsProcessor.h\"   // Base class.\n\n\nnamespace BitFunnel\n{\n    class ByteCodeGenerator;\n    class IShard;\n    class ISimpleIndex;\n\n    //*************************************************************************\n    //\n    // ByteCodeVerifier\n    //\n    // This class verifies the correctness of a matching algorithm that invokes\n    // methods on an IResultsProcessor.\n    //\n    // Verifies that a sequence of calls to IResultsProcessor::AddResult() and\n    // IResultsProcessor::FinishIteration() match an expect sequence of calls.\n    //\n    //*************************************************************************\n    class ByteCodeVerifier : public IResultsProcessor\n    {\n    public:\n        ByteCodeVerifier(ISimpleIndex const & index, Rank initialRank);\n\n\n        void VerboseMode(bool mode);\n\n        void ExpectNoResults();\n\n        std::vector<size_t> const & GetIterations() const;\n\n        size_t GetSliceNumber(size_t iteration) const;\n\n        size_t GetOffset(size_t iteration) const;\n\n        size_t GetIterationsPerSlice() const;\n\n        void DeclareRow(char const * text);\n\n        uint64_t GetRowData(size_t row, size_t offset, size_t slice);\n\n        // The class is configured by adding a sequence of of records\n        // describing the expected interactions betweeen the matcher and its\n        // IResultsProcessor. Each call to Add() corresponds to expectation\n        // that the matcher will invoke IResultsProcessor::AddResult(). The\n        // accumulator and offset parameters to Add() are the expected\n        // parameters to AddResult().\n        //\n        // The usage pattern for IResultsProcessor is a sequence of calls\n        // to AddResult() interspersed with calls to FinishIteration().\n        // The call to FinishIteration() provides the void* slice buffer\n        // pointer that is applicable to the sequence of calls to AddResult()\n        // since the previous call to FinishIteration() (or the start of\n        // the matching algorithm if there was no previous call to\n        // FinishIteration().\n        //\n        // The third parameter of the Add() method indicates the slice\n        // that expected to be passed on the next call to FinishIteration.\n        // The slice parameter is a size_t index into an array of slice\n        // buffer pointers associated with the index.\n        //\n        void ExpectResult(uint64_t accumulator,\n                          size_t offset,\n                          size_t slice);\n\n        void Verify(char const * codeText);\n\n        //\n        // IResultsProcessor methods.\n        //\n\n        void AddResult(uint64_t accumulator,\n                       size_t offset) override;\n\n\n        bool FinishIteration(void const * sliceBuffer) override;\n\n\n        bool TerminatedEarly() const override;\n\n\n\n    private:\n        static void GenerateCode(char const * rowPlanText,\n                                 ByteCodeGenerator& code);\n\n\n        static RowId GetFirstRow(ITermTable const & termTable,\n                                 Term term);\n\n        static ptrdiff_t GetRowOffset(char const * text,\n                                      Term::StreamId stream,\n                                      IConfiguration const & config,\n                                      ITermTable const & termTable,\n                                      IShard const & shard);\n\n\n        ISimpleIndex const & m_index;\n        Rank m_initialRank;\n        std::vector<void *> const & m_slices;\n\n        std::vector<size_t> m_iterationValues;\n\n        std::vector<ptrdiff_t> m_rowOffsets;\n\n        size_t m_resultsCount;\n\n        bool m_verboseMode;\n        bool m_expectNoResults;\n\n        struct Expected\n        {\n            uint64_t m_accumulator;\n            size_t m_offset;\n            size_t m_slice;\n        };\n\n        std::vector<Expected> m_expectedResults;\n\n        struct Observed\n        {\n            uint64_t m_accumulator;\n            size_t m_offset;\n        };\n\n        std::vector<Observed> m_observed;\n    };\n}\n\n", "comment_ratio": 0.3522012578616352}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n#import \"QVPackage.h\"\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface QVPackageManager : NSObject\n\n@property (nonatomic, strong) NSArray<QVMenu*> *menuItems;\n@property (nonatomic, strong) NSDictionary<NSString*,QVPackage*> *packageMap; // <command id, package>\n\n+ (instancetype)sharedManager;\n\n- (BOOL)load;\n\n@end\n\nNS_ASSUME_NONNULL_END\n\n", "comment_ratio": 0.3076923076923077}
{"lang": "c", "code": "#include \"AGESA.h\"\n#include \"amdlib.h\"\n#include \"Ids.h\"\n#include \"mport.h\"\n#include \"mm.h\"\n#include \"mn.h\"\n#include \"mt.h\"\n#include \"mu.h\"\n#include \"OptionMemory.h\"\n#include \"PlatformMemoryConfiguration.h\"\n#include \"mnkb.h\"\n#include \"mftds.h\"\n#include \"merrhdl.h\"\n#include \"cpuFamRegisters.h\"\n#include \"GeneralServices.h\"\n#include \"cpuFamilyTranslation.h\"\n#include \"cpuF16Utilities.h\"\n#include \"IdsF16KbAllService.h\"\n#include \"Filecode.h\"\nCODE_GROUP (G3_DXE)\nRDATA_GROUP (G3_DXE)\n\n\n#define FILECODE PROC_MEM_NB_KB_MNDCTKB_FILECODE\n\n/*----------------------------------------------------------------------------\n *                          DEFINITIONS AND MACROS\n *\n *----------------------------------------------------------------------------\n */\n#define UNUSED_CLK 4\n\nCONST BIT_FIELD_NAME MemPstateBF[4] = {BFMemPstate0, BFMemPstate1, BFMemPstate2, BFMemPstate3};\n/*----------------------------------------------------------------------------\n *                           TYPEDEFS AND STRUCTURES\n *\n *----------------------------------------------------------------------------\n */\n\n/*----------------------------------------------------------------------------\n *                        PROTOTYPES OF LOCAL FUNCTIONS\n *\n *----------------------------------------------------------------------------\n */\nUINT32\nSTATIC\nMemNTotalSyncComponentsKB (\n  IN OUT   MEM_NB_BLOCK *NBPtr\n  );\n\n/*----------------------------------------------------------------------------\n *                            EXPORTED FUNCTIONS\n *\n *----------------------------------------------------------------------------\n */\n\nextern BUILD_OPT_CFG UserOptions;\n\n/* -----------------------------------------------------------------------------*/\n/**\n *\n *\n *      This function programs the memory controller with configuration parameters\n *\n *\n *     @param[in,out]   *NBPtr   - Pointer to the MEM_NB_BLOCK\n *\n *     @return          TRUE - An Error value lower than AGESA_FATAL may have occurred\n *     @return          FALSE - An Error value greater than or equal to AGESA_FATAL may have occurred\n *     @return          NBPtr->MCTPtr->ErrCode - Contains detailed AGESA_STATUS value\n */\n\nBOOLEAN\nMemNAutoConfigKB (\n  IN OUT   MEM_NB_BLOCK *NBPtr\n  )\n{\n  UINT8 i;\n  DIE_STRUCT *MCTPtr;\n  DCT_STRUCT *DCTPtr;\n  MEM_PARAMETER_STRUCT *RefPtr;\n  UINT32 PowerDownMode;\n  UINT32 Tstag;\n\n  RefPtr = NBPtr->RefPtr;\n  MCTPtr = NBPtr->MCTPtr;\n  DCTPtr = NBPtr->DCTPtr;\n\n  //\n  //======================================================================\n  // Build Dram Config Lo Register Value\n  //======================================================================\n  MemNSetBitFieldNb (NBPtr, BFUnBuffDimm, 1);\n  MemNSetBitFieldNb (NBPtr, BFPendRefPaybackS3En, 1);\n  MemNSetBitFieldNb (NBPtr, BFStagRefEn, 1);\n  //\n  // DimmEccEn\n  //\n  if (MCTPtr->Status[SbEccDimms]) {\n    MemNSetBitFieldNb (NBPtr, BFDimmEccEn, 1);\n  }\n  //\n  //======================================================================\n  // Build Dram Config Hi Register Value\n  //======================================================================\n  //\n  //\n  // MemClkFreq\n  //\n  MemNSetBitFieldNb (NBPtr, BFMemClkFreq, MemNGetMemClkFreqIdUnb (NBPtr, DCTPtr->Timings.Speed));\n\n  PowerDownMode = 1;\n  IDS_OPTION_HOOK (IDS_POWERDOWN_MODE, &PowerDownMode, &(NBPtr->MemPtr->StdHeader));\n  MemNSetBitFieldNb (NBPtr, BFPowerDownMode, PowerDownMode);\n\n  if (NBPtr->MemPstateStage == MEMORY_PSTATE_1ST_STAGE) {\n    MemNBrdcstSetNb (NBPtr, BFM1MemClkFreq, MemNGetMemClkFreqIdUnb (NBPtr, DDR667_FREQUENCY));\n    MemNSetBitFieldNb (NBPtr, BFDphyMemPsSelEn, 0);\n    MemNBrdcstSetNb (NBPtr, BFRate, MemNGetMemClkFreqIdUnb (NBPtr, DDR667_FREQUENCY) | 0x8);\n    MemNBrdcstSetNb (NBPtr, BFMxMrsEn, 7);\n  }\n\n  MemNSetBitFieldNb (NBPtr, BFDphyMemPsSelEn, 1);\n  //\n  //======================================================================\n  // Build Dram MRS Register Value\n  //======================================================================\n  //\n  MemNSetBitFieldNb (NBPtr, BFPchgPDModeSel, 1);\n  MemNSetBitFieldNb (NBPtr, BFBurstCtrl, 1);\n\n  //======================================================================\n  // DRAM Controller Miscellaneous 2\n  //======================================================================\n  MemNSetBitFieldNb (NBPtr, BFPerRankTimingEn, 1);\n  IDS_HDT_CONSOLE (MEM_FLOW, \"\\n\\nEnable Per Rank Training....\\n\\n\");\n  MemNSetBitFieldNb (NBPtr, BFPrtlChPDEnhEn, 0);\n  MemNSetBitFieldNb (NBPtr, BFAggrPDEn, 1);\n  MemNSetBitFieldNb (NBPtr, BFDctSelBankSwap, 1);\n\n  //======================================================================\n  // Trace Buffer Extended Address Initialization\n  //======================================================================\n  MemNSetBitFieldNb (NBPtr, BFTrcBufAdrPtrHi, 0);\n  MemNSetBitFieldNb (NBPtr, BFTrcBufDramLimitHi, 0);\n  MemNSetBitFieldNb (NBPtr, BFTrcBufDramBaseHi, 0);\n\n  //======================================================================\n  // GMC to DCT control\n  //======================================================================\n  MemNSetBitFieldNb (NBPtr, BFGmcTokenLimit, 4);\n  MemNSetBitFieldNb (NBPtr, BFMctTokenLimit, 4);\n  MemNSetBitFieldNb (NBPtr, BFGmcToDctControl1, 0x04040404);\n  MemNSetBitFieldNb (NBPtr, BFCpuElevPrioPeriod, 0xC);\n  MemNSetBitFieldNb (NBPtr, BFCpuElevPrioDis, 0);\n\n  //======================================================================\n  // Other Registers\n  //======================================================================\n  //\n  //\n  // Non-SPD Timings\n  //\n  MemNSetBitFieldNb (NBPtr, BFTrwtWB, 0x17);\n  MemNSetBitFieldNb (NBPtr, BFTrwtTO, 0x16);\n  MemNSetBitFieldNb (NBPtr, BFTwrrd, 0xB );\n\n  MemNSetBitFieldNb (NBPtr, BFTrdrdSdSc, 0xB);\n  MemNSetBitFieldNb (NBPtr, BFTrdrdSdDc, 0xB);\n  MemNSetBitFieldNb (NBPtr, BFTrdrdDd, 0xB);\n\n  MemNSetBitFieldNb (NBPtr, BFTwrwrSdSc, 0xB);\n  MemNSetBitFieldNb (NBPtr, BFTwrwrSdDc, 0xB);\n  MemNSetBitFieldNb (NBPtr, BFTwrwrDd, 0xB);\n\n  MemNSetBitFieldNb (NBPtr, BFWrOdtOnDuration, DEFAULT_WR_ODT_KB);\n  MemNSetBitFieldNb (NBPtr, BFRdOdtOnDuration, DEFAULT_RD_ODT_KB);\n  MemNSetBitFieldNb (NBPtr, BFWrOdtTrnOnDly, DEFAULT_RD_ODT_TRNONDLY_KB);\n\n  // Tstag = BIOS: MAX(D18F2x204_dct[0]_mp[1:0][Trrd], CEIL(D18F2x204_dct[0]_mp[1:0][FourActWindow]/4))\n  Tstag = MAX (MemNGetBitFieldNb (NBPtr, BFTrrd), (MemNGetBitFieldNb (NBPtr, BFFourActWindow) + 3) / 4);\n  for (i = 0; i < 4; i++) {\n    MemNSetBitFieldNb (NBPtr, BFTstag0 + i, Tstag);\n  }\n\n  MemNSetBitFieldNb (NBPtr, BFTmrd, 4);\n  MemNSetBitFieldNb (NBPtr, BFFlushWrOnS3StpGnt, 1);\n  MemNSetBitFieldNb (NBPtr, BFFastSelfRefEntryDis, 0);\n\n  return (BOOLEAN) (MCTPtr->ErrCode < AGESA_FATAL);\n}\n\n/* -----------------------------------------------------------------------------*/\n/**\n *\n *\n *   This function caps speed based on battery life check.\n *\n *     @param[in,out]   *NBPtr   - Pointer to the MEM_NB_BLOCK\n */\nVOID\nMemNCapSpeedBatteryLifeKB (\n  IN OUT   MEM_NB_BLOCK *NBPtr\n  )\n{\n  CONST UINT16 SupportedFreq[] = {\n    DDR2133_FREQUENCY,\n    DDR1866_FREQUENCY,\n    DDR1600_FREQUENCY,\n    DDR1333_FREQUENCY,\n    DDR1066_FREQUENCY,\n    DDR800_FREQUENCY,\n    DDR667_FREQUENCY\n  };\n\n  UINT32 FreqNumeratorInMHz;\n  UINT32 FreqDivisor;\n  UINT32 VoltageInuV;\n  UINT32 NBFreq;\n  UINT16 DdrFreq;\n  UINT16 j;\n  UINT8 Dct;\n  INT8   NbPs;\n  CPU_SPECIFIC_SERVICES *FamilySpecificServices;\n\n  FamilySpecificServices = NULL;\n  GetCpuServicesOfSocket (NBPtr->MCTPtr->SocketId, (CONST CPU_SPECIFIC_SERVICES **)&FamilySpecificServices, &(NBPtr->MemPtr->StdHeader));\n\n\n  // Find the lowest supported NB Pstate\n  NBFreq = 0;\n  for (NbPs = 3; NbPs >= 0; NbPs--) {\n    if (FamilySpecificServices->GetNbPstateInfo (FamilySpecificServices,\n                                                  NBPtr->MemPtr->PlatFormConfig,\n                                                  &NBPtr->PciAddr,\n                                                  (UINT32) NbPs,\n                                                  &FreqNumeratorInMHz,\n                                                  &FreqDivisor,\n                                                  &VoltageInuV,\n                                                  &(NBPtr->MemPtr->StdHeader))) {\n      if (MemNGetBitFieldNb (NBPtr, MemPstateBF[NbPs]) == 0) {\n        NBFreq = FreqNumeratorInMHz / FreqDivisor;\n        break;\n      }\n    }\n  }\n\n  ASSERT (NBFreq > 0);\n\n  // Pick Max MEMCLK that is less than or equal to NCLK\n  DdrFreq = DDR800_FREQUENCY;\n  for (j = 0; j < GET_SIZE_OF (SupportedFreq); j++) {\n    if (NBFreq >= ((UINT32) SupportedFreq[j]) && NBFreq <= ((UINT32) SupportedFreq[j] * 2)) {\n      DdrFreq = SupportedFreq[j];\n      break;\n    }\n  }\n  ASSERT (j < GET_SIZE_OF (SupportedFreq));\n\n  // Cap MemClk frequency to lowest NCLK frequency\n  for (Dct = 0; Dct < MAX_DCTS_PER_NODE_KB; Dct++) {\n    MemNSwitchDCTNb (NBPtr, Dct);\n    if (NBPtr->DCTPtr->Timings.TargetSpeed > DdrFreq) {\n      NBPtr->DCTPtr->Timings.TargetSpeed = DdrFreq;\n    }\n  }\n\n  // Initialize NbPsCtlReg\n  NBPtr->NbPsCtlReg = 0;\n}\n\n/* -----------------------------------------------------------------------------*/\n/**\n *\n *\n *   This function retrieves the Max latency parameters\n *\n *     @param[in,out]   *NBPtr   - Pointer to the MEM_NB_BLOCK\n *\n *     @param[in]  *MinDlyPtr - Pointer to variable to store the Minimum Delay value\n *     @param[in]  *MaxDlyPtr - Pointer to variable to store the Maximum Delay value\n *     @param[in]  *DlyBiasPtr - Pointer to variable to store Delay Bias value\n *     @param[in]  MaxRcvEnDly - Maximum receiver enable delay value\n */\n\nVOID\nMemNGetMaxLatParamsKB (\n  IN OUT   MEM_NB_BLOCK *NBPtr,\n  IN       UINT16 MaxRcvEnDly,\n  IN OUT   UINT16 *MinDlyPtr,\n  IN OUT   UINT16 *MaxDlyPtr,\n  IN OUT   UINT16 *DlyBiasPtr\n  )\n{\n  UINT32 N;\n  UINT32 T;\n  UINT32 P;\n  UINT32 MemClkPeriod;\n\n  // 1. P = N = T = 0.\n  P = N = T = 0;\n\n  // Get all sync components BKDG steps 3,4,6\n  P = MemNTotalSyncComponentsKB (NBPtr);\n\n  // 8. P = P + CEIL(MAX(D18F2x9C_x0000_00[2A:10]_dct[1:0][DqsRcvEnGrossDelay, DqsRcvEnFineDelay] +\n  //    D18F2x9C_x0000_0[3:0]0[7:5]_dct[1:0][RdDqsTime] PCLKs)) + 1\n  P = P + (MaxRcvEnDly + 31) / 32 + 1;\n\n  // 11. N = (P/(MemClkFreq * 2) + T) * NclkFreq; Convert from PCLKs plus time to NCLKs.\n  MemClkPeriod = 1000000 / ((NBPtr->MemPstate == MEMORY_PSTATE0) ? NBPtr->DCTPtr->Timings.Speed : DDR667_FREQUENCY);\n  N = ((((P * MemClkPeriod + 1) / 2) + T) * NBPtr->NBClkFreq + 999999) / 1000000;\n\n  // Calculate a starting MaxRdLatency delay value with steps 5, 9, and 12 excluded\n  *MinDlyPtr = (UINT16) N;\n\n  *MaxDlyPtr = 0x3FF;\n\n  // Program D18F2x210_dct[0]_nbp[3:0][MaxRdLatency] = CEIL(current value + 1 NCLK + 1.5 MEMCLK +\n  // IF (NclkFreq/MemClkFreq < 2) THEN 1 MEMCLK ELSE 0 ENDIF)\n  N = 1;\n  P = 3 + (((NBPtr->NBClkFreq / ((NBPtr->MemPstate == MEMORY_PSTATE0) ? NBPtr->DCTPtr->Timings.Speed : DDR667_FREQUENCY)) < 2) ? 2 : 0);\n  N += (((P * MemClkPeriod + 1) / 2) * NBPtr->NBClkFreq + 999999) / 1000000;\n  *DlyBiasPtr = (UINT16) N;\n}\n\n/* -----------------------------------------------------------------------------*/\n/**\n *\n *\n *   This function  sets the maximum round-trip latency in the system from the processor to the DRAM\n *   devices and back.\n *\n *\n *     @param[in,out]   *NBPtr   - Pointer to the MEM_NB_BLOCK\n *     @param[in]     MaxRcvEnDly - Maximum receiver enable delay value\n *\n */\n\nVOID\nMemNSetMaxLatencyKB (\n  IN OUT   MEM_NB_BLOCK *NBPtr,\n  IN       UINT16 MaxRcvEnDly\n  )\n{\n  UINT32 N;\n  UINT32 T;\n  UINT32 P;\n  UINT32 Px2;\n  UINT32 MemClkPeriod;\n\n  AGESA_TESTPOINT (TpProcMemRcvrCalcLatency, &(NBPtr->MemPtr->StdHeader));\n\n  //\n  // Initial value for MaxRdLat used in training\n  //\n  N = 0x55;\n\n  if (MaxRcvEnDly != 0xFFFF) {\n    // 1. P = N = T = 0.\n    P = N = T = 0;\n\n    // Get all sync components BKDG steps 3,4,6\n    P = MemNTotalSyncComponentsKB (NBPtr);\n\n    // 5. P = P + 6\n    P += 6;\n\n    // 8. P = P + CEIL(MAX(D18F2x9C_x0000_00[2A:10]_dct[1:0][DqsRcvEnGrossDelay, DqsRcvEnFineDelay] +\n    //    D18F2x9C_x0000_0[3:0]0[6:5]_dct[1:0][RdDqsTime] PCLKs)) + 1\n    P = P + (MaxRcvEnDly + 31) / 32 + 1;\n\n    // 9. If (NclkFreq/MemClkFreq < 2) then P = P + 4.5 Else P = P + 2.5\n    if ((NBPtr->NBClkFreq / NBPtr->DCTPtr->Timings.Speed) < 2) {\n      Px2 = P * 2 + 9;\n    } else {\n      Px2 = P * 2 + 5;\n    }\n\n    // 10. T = T + 1050 ps\n    T += 1050;\n\n    // 11. N = (P/(MemClkFreq * 2) + T) * NclkFreq; Convert from PCLKs plus time to NCLKs.\n    MemClkPeriod = 1000000 / NBPtr->DCTPtr->Timings.Speed;\n    N = ((((Px2 * MemClkPeriod + 3) / 4) + T) * NBPtr->NBClkFreq + 999999) / 1000000;\n\n    // 12. D18F2x210_dct[1:0]_nbp[3:0][MaxRdLatency] = CEIL(N) + 1\n    N = N + 1;\n  }\n\n  NBPtr->DCTPtr->Timings.MaxRdLat = (UINT16) N;\n  IDS_HDT_CONSOLE (MEM_FLOW, \"\\t\\tMaxRdLat: %03x\\n\", N);\n  MemNSetBitFieldNb (NBPtr, BFMaxLatency, N);\n}\n\n/*-----------------------------------------------------------------------------\n *\n *\n *     This function set MaxRdLat after HW receiver enable training is completed\n *\n *     @param[in,out]  *NBPtr     - Pointer to the MEM_NB_BLOCK\n *     @param[in,out]  OptParam   - Optional parameter\n *\n *     @return    TRUE\n * ----------------------------------------------------------------------------\n */\nBOOLEAN\nMemNExitPhyAssistedTrainingKB (\n  IN OUT   MEM_NB_BLOCK *NBPtr,\n  IN OUT   VOID *OptParam\n  )\n{\n  UINT8 Dct;\n  UINT8 ChipSel;\n  MEM_TECH_BLOCK  *TechPtr;\n\n  TechPtr = NBPtr->TechPtr;\n\n  // Calculate Max Latency for both channels to prepare for position training\n  for (Dct = 0; Dct < MAX_DCTS_PER_NODE_KB ; Dct++) {\n    IDS_HDT_CONSOLE (MEM_STATUS, \"\\tDct %d\\n\", Dct);\n    NBPtr->SwitchDCT (NBPtr, Dct);\n\n    // Reset DisAutoRefresh and ZqcsInterval for position training.\n    if (NBPtr->DCTPtr->Timings.DctMemSize != 0) {\n      MemNSetBitFieldNb (NBPtr, BFDisAutoRefresh, 1);\n      MemNSetBitFieldNb (NBPtr, BFZqcsInterval, 0);\n      MemNSetBitFieldNb (NBPtr, BFRxDqInsDly, 0);\n    }\n\n    if (TechPtr->FindMaxDlyForMaxRdLat (TechPtr, &ChipSel)) {\n      NBPtr->SetMaxLatency (NBPtr, TechPtr->MaxDlyForMaxRdLat);\n    }\n  }\n\n  return (BOOLEAN) (NBPtr->MCTPtr->ErrCode < AGESA_FATAL);\n}\n\n/*----------------------------------------------------------------------------\n *                              LOCAL FUNCTIONS\n *\n *----------------------------------------------------------------------------\n */\n\n/* -----------------------------------------------------------------------------*/\n/**\n *\n *\n *   This function gets the total of sync components for Max Read Latency calculation\n *\n *     @param[in,out]   *NBPtr   - Pointer to the MEM_NB_BLOCK\n *\n *     @return      Total in PCLKs\n */\nUINT32\nSTATIC\nMemNTotalSyncComponentsKB (\n  IN OUT   MEM_NB_BLOCK *NBPtr\n  )\n{\n  UINT32 P;\n\n  P = 0;\n\n  // 3. If (D18F2x9C_x0000_0004_dct[1:0][AddrCmdSetup] = 0 & D18F2x9C_x0000_0004_dct[1:0][CsOdt-\n  // Setup] = 0 & D18F2x9C_x0000_0004_dct[1:0][CkeSetup] = 0)\n  // then P = P + 1\n  // else P = P + 2\n  if ((MemNGetBitFieldNb (NBPtr, BFAddrTmgControl) & 0x0202020) == 0) {\n    P += 1;\n  } else {\n    P += 2;\n  }\n\n  // 4. P = P + (8 - D18F2x210_dct[1:0]_nbp[3:0][RdPtrInit])\n  P = P + (8 - (UINT16) MemNGetBitFieldNb (NBPtr, BFRdPtrInit));\n\n  // 7. P = P + (2 * (D18F2x200_dct[1:0][Tcl] - 1 clocks))\n  P = P + (2 * (MemNGetBitFieldNb (NBPtr, BFTcl) - 1));\n\n  return P;\n}\n\n/* -----------------------------------------------------------------------------*/\n/**\n *\n *  This function obtains the memory frequency in the current context\n *\n *     @param[in,out]   *NBPtr   - Pointer to the MEM_NB_BLOCK\n *\n */\nUINT16\nMemNGetMemClkFreqInCurrentContextKB (\n  IN OUT   MEM_NB_BLOCK *NBPtr\n  )\n{\n  UINT8 Dct;\n  UINT16 MemClkSpeed;\n\n  for (Dct = 0; Dct < MAX_DCTS_PER_NODE_KB; Dct++) {\n    MemNSwitchDCTNb (NBPtr, Dct);\n    if (NBPtr->DCTPtr->Timings.DctMemSize != 0) {\n      break;\n    }\n  }\n\n  if (MemNGetBitFieldNb (NBPtr, MemPstateBF[MemNGetBitFieldNb (NBPtr, BFNbPsSel)]) == 0) {\n    MemClkSpeed = NBPtr->DCTPtr->Timings.Speed;\n  } else {\n    MemClkSpeed = MemNGetMemClkFreqUnb (NBPtr, (UINT8) MemNGetBitFieldNb (NBPtr, BFM1MemClkFreq));\n  }\n  IDS_HDT_CONSOLE (MEM_FLOW, \"\\t\\tMemclk Freq: %d\\n\", MemClkSpeed);\n\n  return MemClkSpeed;\n}\n\n/* -----------------------------------------------------------------------------*/\n/**\n *\n *  This function calculates and programs NB P-state dependent registers\n *\n *     @param[in,out]   *NBPtr   - Pointer to the MEM_NB_BLOCK\n *\n */\n\nVOID\nMemNProgramNbPstateDependentRegistersKB (\n  IN OUT   MEM_NB_BLOCK *NBPtr\n  )\n{\n  UINT8 RdPtrInit;\n  UINT8 Dct;\n  UINT8 *DimmsPerChPtr;\n  UINT8 MaxSolderedDownDimmPerCh;\n  UINT32 MemClkSpeed;\n\n  MemClkSpeed = NBPtr->GetMemClkFreqInCurrentContext (NBPtr);\n\n  // IF (((NBCOF >= DdrRate) == FALSE) THEN\n  //   RdPtrInit = 0010b\n  // ELSE IF (((NBCOF >= DdrRate) == TRUE) && (DdrRate == 667 || DdrRate == 800 || DdrRate == 1600))THEN\n  //   RdPtrInit = 0110b\n  // ELSE IF (((NBCOF >= DdrRate) == TRUE) && (DdrRate == 1866 || DdrRate ==2133))THEN\n  //   RdPtrInit = 0101b\n  // ELSE IF (((NBCOF >= DdrRate) == TRUE) && (DdrRate == 2400))THEN\n  //   RdPtrInit = 0100b\n  // ENDIF\n  if (NBPtr->NBClkFreq < (UINT32) (MemClkSpeed * 2)) {\n    RdPtrInit = 2;\n  } else {\n    RdPtrInit = (MemClkSpeed < DDR1600_FREQUENCY) ? 6 : ((MemClkSpeed < DDR2400_FREQUENCY) ? 5 : 4);\n  }\n  MemNBrdcstSetNb (NBPtr, BFRdPtrInit, RdPtrInit);\n  IDS_HDT_CONSOLE (MEM_FLOW, \"\\t\\tRdPtr: %d\\n\", RdPtrInit);\n\n  for (Dct = 0; Dct < MAX_DCTS_PER_NODE_KB; Dct++) {\n    MemNSwitchDCTNb (NBPtr, Dct);\n    if (NBPtr->DCTPtr->Timings.DctMemSize != 0) {\n      // Set ProcOdtAdv\n      // BIOS:IF(Solder-down DRAM || SODIMM) && DdrRate <= 1333) THEN 0 ELSE 1 ENDIF.\n      MaxSolderedDownDimmPerCh = GetMaxSolderedDownDimmsPerChannel (NBPtr->RefPtr->PlatformMemoryConfiguration,\n                                                                    NBPtr->MCTPtr->SocketId, NBPtr->ChannelPtr->ChannelID);\n      DimmsPerChPtr = FindPSOverrideEntry (NBPtr->RefPtr->PlatformMemoryConfiguration,\n                                           PSO_SOLDERED_DOWN_SODIMM_TYPE,\n                                           NBPtr->MCTPtr->SocketId,\n                                           NBPtr->ChannelPtr->ChannelID,\n                                           0, NULL, NULL);\n      if (((DimmsPerChPtr != NULL) || (MaxSolderedDownDimmPerCh != 0) || (NBPtr->ChannelPtr->SODimmPresent != 0)) &&\n         (NBPtr->DCTPtr->Timings.Speed <= DDR1333_FREQUENCY)) {\n        MemNSetBitFieldNb (NBPtr, BFProcOdtAdv, 0);\n      } else {\n        MemNSetBitFieldNb (NBPtr, BFProcOdtAdv, 0x4000);\n      }\n      MemNSetBitFieldNb (NBPtr, BFDataTxFifoWrDly, 0);\n      if (NBPtr->DCTPtr->Timings.Speed >= DDR1600_FREQUENCY) {\n        MemNSetBitFieldNb (NBPtr, BFReducedLoop, (2 << 13));\n      }\n    }\n  }\n\n  IDS_OPTION_HOOK (IDS_NBPS_REG_OVERRIDE, NBPtr, &NBPtr->MemPtr->StdHeader);\n  MemFInitTableDrive (NBPtr, MTAfterNbPstateChange);\n}\n\n/* -----------------------------------------------------------------------------*/\n/**\n *\n *\n *   This is a general purpose function that executes before DRAM init\n *\n *     @param[in,out]   *NBPtr   - Pointer to the MEM_NB_BLOCK\n *\n */\n\nVOID\nMemNBeforeDramInitKB (\n  IN OUT   MEM_NB_BLOCK *NBPtr\n  )\n{\n  // c. Program DCT training specific configuration.\n  MemNConfigureDctTrainingKB (NBPtr);\n  // d. Program the remaining DCT registers not covered by an explicit sequence dependency.\n  MemNProgramNonSeqDependentRegistersKB (NBPtr);\n}\n\n/* -----------------------------------------------------------------------------*/\n/**\n *\n *     This function programs the memory controller for training\n *\n *     @param[in,out]   *NBPtr   - Pointer to the MEM_NB_BLOCK\n *\n */\n\nVOID\nMemNConfigureDctTrainingKB (\n  IN OUT   MEM_NB_BLOCK *NBPtr\n  )\n{\n  UINT8 Dct;\n\n  for (Dct = 0; Dct < MAX_DCTS_PER_NODE_KB; Dct++) {\n    MemNSwitchDCTNb (NBPtr, Dct);\n    if (NBPtr->DCTPtr->Timings.DctMemSize != 0) {\n      //\n      // 2.10.6.7 DCT Training Specific Configuration\n      //\n      MemNSetBitFieldNb (NBPtr, BFAddrCmdTriEn, 0);\n      MemNSetBitFieldNb (NBPtr, BFDisAutoRefresh, 1);\n      MemNSetBitFieldNb (NBPtr, BFForceAutoPchg, 0);\n      MemNSetBitFieldNb (NBPtr, BFDynPageCloseEn, 0);\n      MemNSetBitFieldNb (NBPtr, BFBankSwizzleMode, 0);\n      MemNSetBitFieldNb (NBPtr, BFDcqBypassMax, 0);\n      MemNSetBitFieldNb (NBPtr, BFPowerDownEn, 0);\n      MemNSetBitFieldNb (NBPtr, BFZqcsInterval, 0);\n      MemNSetBitFieldNb (NBPtr, BFRxMaxDurDllNoLock, 0);\n      MemNSetBitFieldNb (NBPtr, BFTxMaxDurDllNoLock, 0);\n      MemNSetBitFieldNb (NBPtr, BFEnRxPadStandby, 0);\n      MemNSetBitFieldNb (NBPtr, BFBankSwap, 0);\n      MemNSetBitFieldNb (NBPtr, BFODTSEn, 0);\n      MemNSetBitFieldNb (NBPtr, BFCmdThrottleMode, 0);\n      MemNSetBitFieldNb (NBPtr, BFBwCapEn, 0);\n      MemNSetBitFieldNb (NBPtr, BFDramScrub, 0);\n      MemNSetBitFieldNb (NBPtr, BFScrubReDirEn, 0);\n    }\n  }\n}\n\n/* -----------------------------------------------------------------------------*/\n/**\n *\n *     This function programs the remaining DCT registers not covered by\n *     an explicit sequence dependency.\n *\n *     @param[in,out]   *NBPtr   - Pointer to the MEM_NB_BLOCK\n *\n */\n\nVOID\nMemNProgramNonSeqDependentRegistersKB (\n  IN OUT   MEM_NB_BLOCK *NBPtr\n  )\n{\n  UINT8 Dct;\n\n  for (Dct = 0; Dct < MAX_DCTS_PER_NODE_KB; Dct++) {\n    MemNSwitchDCTNb (NBPtr, Dct);\n    if (NBPtr->DCTPtr->Timings.DctMemSize != 0) {\n      MemNSetBitFieldNb (NBPtr, BFDllCSRBiasTrim, 0x1000);\n\n      IEM_INSERT_CODE (IEM_BEFORE_DRAM_INIT, IemBeforeDramInitOverrideKB, (NBPtr));\n    }\n  }\n}\n\n\n/* -----------------------------------------------------------------------------*/\n/**\n *\n *     This function programs the memory controller for normal operation\n *\n *     @param[in,out]   *NBPtr   - Pointer to the MEM_NB_BLOCK\n *\n */\n\nVOID\nMemNConfigureDctNormalKB (\n  IN OUT   MEM_NB_BLOCK *NBPtr\n  )\n{\n  UINT8 Dct;\n  BOOLEAN DllShutDownEn;\n\n  DllShutDownEn = TRUE;\n  IDS_OPTION_HOOK (IDS_DLL_SHUT_DOWN, &DllShutDownEn, &(NBPtr->MemPtr->StdHeader));\n\n  for (Dct = 0; Dct < MAX_DCTS_PER_NODE_KB; Dct++) {\n    MemNSwitchDCTNb (NBPtr, Dct);\n    if (NBPtr->DCTPtr->Timings.DctMemSize != 0) {\n      //\n      // 2.10.6.7 DCT Training Specific Configuration\n      //\n      MemNSetBitFieldNb (NBPtr, BFAddrCmdTriEn, 1);\n      MemNSetBitFieldNb (NBPtr, BFDisAutoRefresh, 0);\n      if (DllShutDownEn && NBPtr->IsSupported[SetDllShutDown]) {\n        MemNSetBitFieldNb (NBPtr, BFDisDllShutdownSR, 0);\n      }\n      MemNSetBitFieldNb (NBPtr , BFForceAutoPchg, 0);\n      MemNSetBitFieldNb (NBPtr , BFDynPageCloseEn, 0);\n      if (NBPtr->RefPtr->EnableBankSwizzle) {\n        MemNSetBitFieldNb (NBPtr, BFBankSwizzleMode, 1);\n      }\n      MemNSetBitFieldNb (NBPtr, BFDcqBypassMax, 0x01F);\n      MemNPowerDownCtlKB (NBPtr);\n      MemNSetBitFieldNb (NBPtr, BFZqcsInterval, 2);\n      MemNSetBitFieldNb (NBPtr, BFBankSwap, 1);\n      //\n      // Post Training values for BFRxMaxDurDllNoLock, BFTxMaxDurDllNoLock,\n      //  and BFEnRxPadStandby are handled by Power savings code\n      //\n      // BFBwCapEn and BFODTSEn are handled by OnDimmThermal Code\n      //\n    }\n  }\n}\n\n/* -----------------------------------------------------------------------------*/\n/**\n *\n *      This function modifies CS interleaving low address according to several conditions for KB.\n *\n *     @param[in,out]  *NBPtr    - Pointer to the MEM_NB_BLOCK\n *     @param[in,out]  *LowBit   - Pointer to low bit\n *\n */\n\nBOOLEAN\nMemNCSIntLvLowAddrAdjKB (\n  IN OUT   MEM_NB_BLOCK *NBPtr,\n  IN OUT   VOID *LowBit\n  )\n{\n  UINT8 DctSelBankSwap;\n\n  DctSelBankSwap = (UINT8) MemNGetBitFieldNb (NBPtr, BFDctSelBankSwap);\n  //\n  //D18F2x[5C:40]_dct[1:0][15:5] = BaseAddr[21:11] &&\n  //D18F2x[6C:60]_dct[1:0][15:5] = AddrMask[21:11], so *LowBit needs to be added with 2.\n  //\n  *(UINT8 *) LowBit += 2;\n\n  if (MemNGetBitFieldNb (NBPtr, BFBankSwap) == 1) {\n    if (DctSelBankSwap == 1) {\n      *(UINT8 *) LowBit = 5;\n    } else {\n      *(UINT8 *) LowBit = 6;\n    }\n  }\n  return TRUE;\n}\n\n/* -----------------------------------------------------------------------------*/\n/**\n *\n *\n *   This function releases the NB P-state force.\n *\n *     @param[in,out]   *NBPtr   - Pointer to the MEM_NB_BLOCK\n *     @param[in,out]   OptParam - Optional parameter\n *\n *     @return    TRUE\n */\nBOOLEAN\nMemNReleaseNbPstateKB (\n  IN OUT   MEM_NB_BLOCK *NBPtr,\n  IN OUT   VOID *OptParam\n  )\n{\n  CPU_SPECIFIC_SERVICES *FamilySpecificServices;\n  GetCpuServicesOfCurrentCore ((CONST CPU_SPECIFIC_SERVICES **)&FamilySpecificServices, &NBPtr->MemPtr->StdHeader);\n\n  // 6. Restore the initial D18F5x170[SwNbPstateLoDis, NbPstateDisOnP0] values.\n  MemNSetBitFieldNb (NBPtr, BFNbPstateCtlReg, (MemNGetBitFieldNb (NBPtr, BFNbPstateCtlReg) & 0xFFFF9FFF) | (NBPtr->NbPsCtlReg & 0x6000));\n  // 7. Restore the initial D18F5x170[NbPstateThreshold, NbPstateHi] values.\n  MemNSetBitFieldNb (NBPtr, BFNbPstateCtlReg, (MemNGetBitFieldNb (NBPtr, BFNbPstateCtlReg) & 0xFFFFF13F) | (NBPtr->NbPsCtlReg & 0x0EC0));\n  // 8. Restore the initial D18F5x170[NbPstateLo] values.\n  MemNSetBitFieldNb (NBPtr, BFNbPstateLo, (NBPtr->NbPsCtlReg >> 3) & 3);\n\n  // Clear NbPsSel to 0\n  MemNSetBitFieldNb (NBPtr, BFNbPsSel, 0);\n  // Update TSC rate\n  FamilySpecificServices->GetTscRate (FamilySpecificServices, &NBPtr->MemPtr->TscRate, &NBPtr->MemPtr->StdHeader);\n\n  if (MemNGetBitFieldNb (NBPtr, BFMemPsSel) != 0) {\n    MemNChangeMemPStateContextNb (NBPtr, 0);\n  }\n\n  return TRUE;\n}\n\n/* -----------------------------------------------------------------------------*/\n/**\n *\n *\n *      This function handles multiple stage of training when multiple Mem Pstate is enabled\n *\n *     @param[in,out]  *NBPtr     - Pointer to the MEM_NB_BLOCK\n *     @param[in,out]  OptParam   - Optional parameter\n *\n *     @return    TRUE\n *\n */\n\nBOOLEAN\nMemNMemPstateStageChangeKB (\n  IN OUT   MEM_NB_BLOCK *NBPtr,\n  IN OUT   VOID *OptParam\n  )\n{\n  BOOLEAN RetVal;\n  TRN_DLY_TYPE AccessType;\n  UINT8 Dct;\n  UINT8 ChipSel;\n  UINT8 ByteLane;\n  UINT16 CsEnabled;\n  UINT16 TrnDly;\n  UINT8 Tcl;\n\n  RetVal = FALSE;\n\n  if (NBPtr->MemPstateStage == MEMORY_PSTATE_1ST_STAGE) {\n    MemNChangeMemPStateContextNb (NBPtr, 1);\n    // Load memory registers in M1 context from data saved in the heap\n    IDS_HDT_CONSOLE (MEM_FLOW, \"\\nLoad Training registers for M1 with DDR667 training result\\n\");\n    for (Dct = 0; Dct < MAX_DCTS_PER_NODE_KB; Dct++) {\n      MemNSwitchDCTNb (NBPtr, Dct);\n      if (NBPtr->DCTPtr->Timings.DctMemSize != 0) {\n        // Save MemPstate 1 data in output data structures\n        LibAmdMemCopy  (NBPtr->ChannelPtr->RcvEnDlysMemPs1, NBPtr->ChannelPtr->RcvEnDlys, (MAX_DIMMS * MAX_DELAYS) * 2, &(NBPtr->MemPtr->StdHeader));\n        LibAmdMemCopy  (NBPtr->ChannelPtr->RdDqsDlysMemPs1, NBPtr->ChannelPtr->RdDqsDlys, MAX_DIMMS * MAX_DELAYS, &(NBPtr->MemPtr->StdHeader));\n        LibAmdMemCopy  (NBPtr->ChannelPtr->WrDqsDlysMemPs1, NBPtr->ChannelPtr->WrDqsDlys, MAX_DIMMS * MAX_DELAYS, &(NBPtr->MemPtr->StdHeader));\n        LibAmdMemCopy  (NBPtr->ChannelPtr->WrDatDlysMemPs1, NBPtr->ChannelPtr->WrDatDlys, MAX_DIMMS * MAX_DELAYS, &(NBPtr->MemPtr->StdHeader));\n        LibAmdMemCopy  (NBPtr->ChannelPtr->RdDqs2dDlysMemPs1, NBPtr->ChannelPtr->RdDqs2dDlys, MAX_DIMMS * MAX_NUMBER_LANES, &(NBPtr->MemPtr->StdHeader));\n        LibAmdMemCopy  (NBPtr->ChannelPtr->RdDqsMinDlysMemPs1, NBPtr->ChannelPtr->RdDqsMinDlys, MAX_DIMMS * MAX_DELAYS, &(NBPtr->MemPtr->StdHeader));\n        LibAmdMemCopy  (NBPtr->ChannelPtr->RdDqsMaxDlysMemPs1, NBPtr->ChannelPtr->RdDqsMaxDlys, MAX_DIMMS * MAX_DELAYS, &(NBPtr->MemPtr->StdHeader));\n        LibAmdMemCopy  (NBPtr->ChannelPtr->WrDatMinDlysMemPs1, NBPtr->ChannelPtr->WrDatMinDlys, MAX_DIMMS * MAX_DELAYS, &(NBPtr->MemPtr->StdHeader));\n        LibAmdMemCopy  (NBPtr->ChannelPtr->WrDatMaxDlysMemPs1, NBPtr->ChannelPtr->WrDatMaxDlys, MAX_DIMMS * MAX_DELAYS, &(NBPtr->MemPtr->StdHeader));\n        LibAmdMemCopy  (NBPtr->ChannelPtr->FailingBitMaskMemPs1, NBPtr->ChannelPtr->FailingBitMask, MAX_CS_PER_CHANNEL * MAX_DELAYS, &(NBPtr->MemPtr->StdHeader));\n\n        CsEnabled = NBPtr->DCTPtr->Timings.CsEnabled;\n        // Set Memory Pstate 1 training value into registers\n        for (AccessType = AccessRcvEnDly; AccessType <= AccessWrDqsDly; AccessType ++) {\n          for (ChipSel = 0; ChipSel < MAX_CS_PER_CHANNEL_KB; ChipSel = ChipSel + NBPtr->CsPerDelay) {\n            if ((CsEnabled & ((UINT16) ((NBPtr->CsPerDelay == 2)? 3 : 1) << ChipSel)) != 0) {\n              for (ByteLane = 0; ByteLane < (NBPtr->MCTPtr->Status[SbEccDimms] ? 9 : 8); ByteLane++) {\n                TrnDly = (UINT16) GetTrainDlyFromHeapNb (NBPtr, AccessType, DIMM_BYTE_ACCESS (ChipSel / NBPtr->CsPerDelay, ByteLane));\n                NBPtr->SetTrainDly (NBPtr, AccessType, DIMM_BYTE_ACCESS (ChipSel / NBPtr->CsPerDelay, ByteLane), TrnDly);\n              }\n            }\n          }\n        }\n\n        if (NBPtr->RefPtr->EnablePowerDown) {\n          MemNSetTxpNb (NBPtr);\n          //\n          // BFPchgPDEnDelay =\n          // IF (D18F2xA8_dct[0][AggrPDEn]) THEN\n          // (D18F2x200_dct[0]_mp[1:0][Tcl] + 5  +\n          // CEIL((MAX(D18F2x9C_x0000_00[2A:10]_dct[0]_mp[1:0][DqsRcvEnGrossDelay])\n          // + 0.5) / 2)) ELSE 00h ENDIF.\n          //\n          if (MemNGetBitFieldNb (NBPtr, BFAggrPDEn) == 1) {\n            Tcl = NBPtr->DCTPtr->Timings.CasL;\n            MemNSetBitFieldNb (NBPtr, BFPchgPDEnDelay, Tcl + 5 + NBPtr->TechPtr->GetMinMaxGrossDly (NBPtr->TechPtr, AccessRcvEnDly, TRUE) / 2 + 1);\n          } else {\n            MemNSetBitFieldNb (NBPtr, BFPchgPDEnDelay, 0);\n          }\n          MemNSetBitFieldNb (NBPtr, BFAggrPDDelay, 0x20);\n        }\n        MemNSetOtherTimingKB (NBPtr);\n        // Save timing data structure for memory Pstate 1\n        LibAmdMemCopy  (NBPtr->DCTPtr->TimingsMemPs1, &(NBPtr->DCTPtr->Timings), sizeof (CH_TIMING_STRUCT), &(NBPtr->MemPtr->StdHeader));\n\n        MemFInitTableDrive (NBPtr, MTAfterMemPstate1PartialTrn);\n      }\n    }\n\n    // Switch back to M0 context\n    MemNChangeMemPStateContextNb (NBPtr, 0);\n\n    // Load memory registers in M1 context from data saved in the heap\n    IDS_HDT_CONSOLE (MEM_FLOW, \"\\nGoing into training stage 2. Complete training at DDR667 is done.\\n\");\n    NBPtr->MemPstateStage = MEMORY_PSTATE_2ND_STAGE;\n  } else if ((NBPtr->MemPstateStage == MEMORY_PSTATE_2ND_STAGE) && (NBPtr->DCTPtr->Timings.TargetSpeed == NBPtr->DCTPtr->Timings.Speed)) {\n    IDS_HDT_CONSOLE (MEM_FLOW, \"\\nGoing into training stage 3. Partial training at all frequencies is done.\\n\");\n    NBPtr->MemPstateStage = MEMORY_PSTATE_3RD_STAGE;\n    RetVal = TRUE;\n  } else {\n    // MemPstate is disabled. Do not go through the MemPstate handling flow.\n    RetVal = TRUE;\n  }\n\n  return RetVal;\n}\n\n/* -----------------------------------------------------------------------------*/\n/**\n *\n *\n *   This function Sets Power Down options and enables Power Down\n *\n *     @param[in,out]   *NBPtr   - Pointer to the MEM_NB_BLOCK\n *\n *     The following registers are set:\n *      BFPowerDownMode         BFPrtlChPDEnhEn\n *      BFTxp                   BFAggrPDDelay\n *      BFTxpDll                BFAggrPDEn\n *      BFPchgPDEnDelay         BFPowerDownEn\n *\n * NOTE:  Delay values must be set before turning on the associated Enable bit\n */\nVOID\nMemNPowerDownCtlKB (\n  IN OUT   MEM_NB_BLOCK *NBPtr\n  )\n{\n  UINT8 PowerDownMode;\n  CONST UINT32 PwrMngm1[] = {0, 0, 0x05050403, 0x05050403, 0x06060403, 0x07070504, 0x08080504, 0x0A0A0605, 0x0B0B0706};\n  UINT8 i;\n  UINT16 Speed;\n  UINT8 Tcl;\n\n  if (NBPtr->RefPtr->EnablePowerDown) {\n    //\n    // PowerDownMode\n    //\n    PowerDownMode = (UINT8) UserOptions.CfgPowerDownMode;\n    PowerDownMode = (!NBPtr->IsSupported[ChannelPDMode]) ? PowerDownMode : 0;\n    IDS_OPTION_HOOK (IDS_POWERDOWN_MODE, &PowerDownMode, &(NBPtr->MemPtr->StdHeader));\n    if (PowerDownMode == 1) {\n      MemNSetBitFieldNb (NBPtr, BFPowerDownMode, 1);\n    }\n    //\n    // Txp\n    //\n    MemNSetTxpNb (NBPtr);\n    //\n    // PchgPDModeSel is set elswhere.\n    //\n    // Partial Channel Power Down\n    //\n    MemNSetBitFieldNb (NBPtr, BFPrtlChPDDynDly, 4);\n    MemNSetBitFieldNb (NBPtr, BFPrtlChPDEnhEn, 0);\n    //\n    // Aggressive PowerDown\n    //\n    MemNSetBitFieldNb (NBPtr, BFAggrPDDelay, 0x20);\n    MemNSetBitFieldNb (NBPtr, BFAggrPDEn, 1);\n    //\n    // BFPchgPDEnDelay =\n    // IF (D18F2xA8_dct[0][AggrPDEn]) THEN\n    // (D18F2x200_dct[0]_mp[1:0][Tcl] + 5  +\n    // CEIL((MAX(D18F2x9C_x0000_00[2A:10]_dct[0]_mp[1:0][DqsRcvEnGrossDelay])\n    // + 0.5) / 2)) ELSE 00h ENDIF.\n    //\n    if (MemNGetBitFieldNb (NBPtr, BFAggrPDEn) == 1) {\n      Tcl = NBPtr->DCTPtr->Timings.CasL;\n      MemNSetBitFieldNb (NBPtr, BFPchgPDEnDelay, Tcl + 5 + NBPtr->TechPtr->GetMinMaxGrossDly (NBPtr->TechPtr, AccessRcvEnDly, TRUE) / 2 + 1);\n    } else {\n      MemNSetBitFieldNb (NBPtr, BFPchgPDEnDelay, 0);\n    }\n\n    // Program DRAM Power Management 1 register\n    Speed = NBPtr->DCTPtr->Timings.Speed;\n    i = (UINT8) ((Speed < DDR800_FREQUENCY) ? ((Speed / 66) - 3) : (Speed / 133));\n    ASSERT ((i > 1) && (i < sizeof (PwrMngm1)));\n    MemNSetBitFieldNb (NBPtr, BFDramPwrMngm1Reg, PwrMngm1[i]);\n  }\n}\n\n/* -----------------------------------------------------------------------------*/\n/**\n *\n *\n *   Always set upper 2 bits of CKETri bitfield\n *\n *     @param[in,out]   *NBPtr   - Pointer to the MEM_NB_BLOCK\n *\n */\nVOID\nMemNBeforePlatformSpecKB (\n  IN OUT   MEM_NB_BLOCK *NBPtr\n  )\n{\n  MemNSetBitFieldNb (NBPtr, BFCSMapCKE, 0x08040201);\n}\n\n/* -----------------------------------------------------------------------------*/\n/**\n *\n *\n *      This function programs MaxRdLatency based on the seeded value of RxEnDly\n *      prior to DQS Receiver Enable Training\n *\n *     @param[in,out]  *NBPtr     - Pointer to the MEM_NB_BLOCK\n *     @param[in,out]  OptParam   - Optional parameter\n *\n *     @return    TRUE\n *\n */\n\nBOOLEAN\nMemNSetMaxRdLatBasedOnSeededRxEnDlyKB (\n  IN OUT   MEM_NB_BLOCK *NBPtr,\n  IN OUT   VOID *OptParam\n  )\n{\n  MEM_TECH_BLOCK  *TechPtr;\n  UINT8 ChipSel;\n\n  TechPtr = NBPtr->TechPtr;\n\n  if (TechPtr->FindMaxDlyForMaxRdLat (TechPtr, &ChipSel)) {\n    NBPtr->SetMaxLatency (NBPtr, TechPtr->MaxDlyForMaxRdLat);\n  }\n\n  return TRUE;\n}\n\n/* -----------------------------------------------------------------------------*/\n/**\n *\n *\n *      This function uses calculated values from DCT.Timings structure to\n *      program its registers for KB\n *\n *\n *     @param[in,out]   *NBPtr   - Pointer to the MEM_NB_BLOCK\n *\n */\n\nVOID\nMemNProgramCycTimingsKB (\n  IN OUT   MEM_NB_BLOCK *NBPtr\n  )\n{\n  CONST CTENTRY TmgAdjTab[] = {\n    // BitField, Min, Max, Bias, Ratio_x2\n    {BFTcl, 5, 14, 0, 2},\n    {BFTrcd, 2, 19, 0, 2},\n    {BFTrp, 2, 19, 0, 2},\n    {BFTrtp, 4, 10, 0, 2},\n    {BFTras, 8, 40, 0, 2},\n    {BFTrc, 10, 56, 0, 2},\n    {BFTwrDDR3, 5, 16, 0, 2},\n    {BFTrrd, 4, 9, 0, 2},\n    {BFTwtr, 4, 9, 0, 2},\n    {BFFourActWindow, 6, 42, 0, 2}\n  };\n\n  DCT_STRUCT *DCTPtr;\n  UINT8  *MiniMaxTmg;\n  UINT8  *MiniMaxTrfc;\n  UINT8  Value8;\n  UINT8  ValFAW;\n  UINT8  ValTrrd;\n  UINT8  j;\n  UINT8  Tcwl;\n  UINT8 RdOdtTrnOnDly;\n  BIT_FIELD_NAME BitField;\n  MEM_PARAMETER_STRUCT *RefPtr;\n\n  DCTPtr = NBPtr->DCTPtr;\n  RefPtr = NBPtr->RefPtr;\n\n  ValFAW = 0;\n  ValTrrd = 0;\n\n  //======================================================================\n  // Program DRAM Timing values\n  //======================================================================\n  //\n  MiniMaxTmg = &DCTPtr->Timings.CasL;\n  for (j = 0; j < GET_SIZE_OF (TmgAdjTab); j++) {\n    BitField = TmgAdjTab[j].BitField;\n\n    if (BitField == BFTrp) {\n      if (NBPtr->IsSupported[AdjustTrp]) {\n        MiniMaxTmg[j] ++;\n        if (MiniMaxTmg[j] < 5) {\n          MiniMaxTmg[j] = 5;\n        }\n      }\n    }\n\n    if (MiniMaxTmg[j] < TmgAdjTab[j].Min) {\n      MiniMaxTmg[j] = TmgAdjTab[j].Min;\n    } else if (MiniMaxTmg[j] > TmgAdjTab[j].Max) {\n      MiniMaxTmg[j] = TmgAdjTab[j].Max;\n    }\n\n    Value8 = (UINT8) MiniMaxTmg[j];\n\n    if (BitField == BFTwrDDR3) {\n      if ((Value8 > 8) && ((Value8 & 1) != 0)) {\n        Value8++;\n      }\n    } else if (BitField == BFTrrd) {\n      ValTrrd = Value8;\n    } else if (BitField == BFFourActWindow) {\n      ValFAW = Value8;\n    }\n\n    MemNSetBitFieldNb (NBPtr, BitField, Value8);\n  }\n\n  MiniMaxTrfc = &DCTPtr->Timings.Trfc0;\n  for (j = 0; j < 4; j++) {\n    if ((NBPtr->DCTPtr->Timings.DctDimmValid & (1 << j)) != 0) {\n      ASSERT (MiniMaxTrfc[j] <= 4);\n      MemNSetBitFieldNb (NBPtr, BFTrfc0 + j, MiniMaxTrfc[j]);\n    }\n  }\n\n  Tcwl = (UINT8) (DCTPtr->Timings.Speed / 133) + 2;\n  Tcwl = (Tcwl > 5) ? Tcwl : 5;\n  MemNSetBitFieldNb (NBPtr, BFTcwl, Tcwl);\n\n  if (RefPtr->DramDoubleRefreshRate) {\n    MemNSetBitFieldNb (NBPtr, BFTref, 3);      // 3.9 us\n  } else {\n    MemNSetBitFieldNb (NBPtr, BFTref, 2);      // 7.8 us\n  }\n\n  RdOdtTrnOnDly = (DCTPtr->Timings.CasL > Tcwl) ? (DCTPtr->Timings.CasL - Tcwl) : 0;\n  MemNSetBitFieldNb (NBPtr, BFRdOdtTrnOnDly, RdOdtTrnOnDly);\n  NBPtr->FamilySpecificHook[ProgOdtControl] (NBPtr, NULL);\n\n  //\n  // Program Tstag\n  //\n  if (NBPtr->MemPstate == 0) {\n    for (j = 0; j < 4; j++) {\n      MemNSetBitFieldNb (NBPtr, BFTstag0 + j, MAX (ValTrrd,  (ValFAW + 3) / 4));\n    }\n  }\n\n  //\n  // Program Tmod\n  //\n  MemNSetBitFieldNb (NBPtr, BFTmod, (DCTPtr->Timings.Speed < DDR1866_FREQUENCY) ? 0x0C :\n                                    (DCTPtr->Timings.Speed > DDR1866_FREQUENCY) ? 0x10 : 0x0E);\n  //\n  // Program Tzqcs and Tzqoper\n  //\n  // Tzqcs max(64nCK, 80ns)\n  MemNSetBitFieldNb (NBPtr, BFTzqcs, MIN (6, (MAX (64, MemUnsToMemClk (NBPtr->DCTPtr->Timings.Speed, 80)) + 15) / 16));\n  // Tzqoper max(256nCK, 320ns)\n  MemNSetBitFieldNb (NBPtr, BFTzqoper, MIN (0xC, (MAX (256, MemUnsToMemClk (NBPtr->DCTPtr->Timings.Speed, 320)) + 31) / 32));\n\n  // Program power management timing\n  MemNDramPowerMngTimingNb (NBPtr);\n}\n\n", "comment_ratio": 0.1297208538587849}
{"lang": "c", "code": "#ifndef ZIRCON_KERNEL_PLATFORM_PC_INTERRUPT_MANAGER_H_\n#define ZIRCON_KERNEL_PLATFORM_PC_INTERRUPT_MANAGER_H_\n\n#include <align.h>\n#include <pow2.h>\n#include <trace.h>\n#include <zircon/errors.h>\n#include <zircon/types.h>\n\n#include <arch/x86/apic.h>\n#include <arch/x86/interrupts.h>\n#include <bitmap/raw-bitmap.h>\n#include <bitmap/storage.h>\n#include <dev/interrupt.h>\n#include <kernel/lockdep.h>\n#include <kernel/spinlock.h>\n\n#define MAX_IRQ_BLOCK_SIZE MAX_MSI_IRQS\n\n// PC implementation of interrupt management.  This is templated on an IoApic\n// implementation to allow for mocking it out during tests.\ntemplate <typename IoApic>\nclass InterruptManager {\n public:\n  InterruptManager() = default;\n  ~InterruptManager() = default;\n  InterruptManager(const InterruptManager&) = delete;\n  InterruptManager(InterruptManager&&) = delete;\n  InterruptManager& operator=(InterruptManager&&) = delete;\n  InterruptManager& operator=(const InterruptManager&) = delete;\n\n  static constexpr unsigned int kNumCpuVectors = X86_INT_PLATFORM_MAX - X86_INT_PLATFORM_BASE + 1;\n\n  // Initialize the x86 IRQ vector allocator and add the range of vectors to manage.\n  zx_status_t Init() {\n    // This is a statically allocated vector so reset should not fail.\n    Guard<SpinLock, IrqSave> guard{&lock_};\n    return handler_allocated_.Reset(X86_INT_COUNT);\n  }\n\n  zx_status_t MaskInterrupt(unsigned int global_irq) {\n    IoApic::MaskIrq(global_irq, IO_APIC_IRQ_MASK);\n    return ZX_OK;\n  }\n\n  zx_status_t UnmaskInterrupt(unsigned int global_irq) {\n    IoApic::MaskIrq(global_irq, IO_APIC_IRQ_UNMASK);\n    return ZX_OK;\n  }\n\n  zx_status_t ConfigureInterrupt(unsigned int global_irq, enum interrupt_trigger_mode tm,\n                                 enum interrupt_polarity pol) {\n    Guard<SpinLock, IrqSave> guard{&lock_};\n    IoApic::ConfigureIrq(global_irq, tm, pol, DELIVERY_MODE_FIXED, IO_APIC_IRQ_MASK,\n                         DST_MODE_PHYSICAL, apic_bsp_id(), 0);\n    return ZX_OK;\n  }\n\n  zx_status_t GetInterruptConfig(unsigned int global_irq, enum interrupt_trigger_mode* tm,\n                                 enum interrupt_polarity* pol) {\n    Guard<SpinLock, IrqSave> guard{&lock_};\n    return IoApic::FetchIrqConfig(global_irq, tm, pol);\n  }\n\n  void GetEntryByX86Vector(uint8_t x86_vector, int_handler* handler, void** arg) {\n    handler_table_[x86_vector].GetHandler(handler, arg);\n  }\n\n  // Returns true if the handler was present.  Must be called with\n  // interrupts disabled.\n  bool InvokeX86Vector(uint8_t x86_vector) { return handler_table_[x86_vector].InvokeIfPresent(); }\n\n  // Register a handler for an external interrupt.\n  // |global_irq| is a \"global IRQ\" number used by the IOAPIC module.\n  //\n  // If |handler| is nullptr, |arg| is ignored and the specified |vector| has\n  // its current handler removed.\n  //\n  // If |handler| is not nullptr and no handler is currently installed for\n  // |vector|, |handler| will be installed and will be invoked with argument\n  // |arg| whenever that interrupt fires.\n  //\n  // If |handler| is not nullptr and a handler is already installed, this will\n  // return ZX_ERR_ALREADY_BOUND.\n  //\n  // If no more CPU interrupt vectors are available, returns\n  // ZX_ERR_NO_RESOURCES.\n  zx_status_t RegisterInterruptHandler(unsigned int global_irq, int_handler handler, void* arg,\n                                       bool permanent = false) {\n    if (!IoApic::IsValidInterrupt(global_irq, 0 /* flags */)) {\n      return ZX_ERR_INVALID_ARGS;\n    }\n\n    Guard<SpinLock, IrqSave> guard{&lock_};\n    zx_status_t result = ZX_OK;\n\n    /* Fetch the x86 vector currently configured for this global irq.  Force\n     * its value to zero if it is currently invalid */\n    uint8_t x86_vector = IoApic::FetchIrqVector(global_irq);\n    if (x86_vector < X86_INT_PLATFORM_BASE || x86_vector > X86_INT_PLATFORM_MAX) {\n      x86_vector = 0;\n    }\n\n    if (x86_vector == 0 && handler == nullptr) {\n      return ZX_OK;\n    }\n\n    // If the vector already exists make sure it's not permanent and that we're allowed to modify it\n    if (x86_vector && handler_table_[x86_vector].permanent()) {\n      return ZX_ERR_ALREADY_BOUND;\n    }\n\n    if (x86_vector && !handler) {\n      /* If the x86 vector is valid, and we are unregistering the handler,\n       * return the x86 vector to the pool. */\n      FreeHandler(x86_vector, 1);\n    } else if (!x86_vector && handler) {\n      /* If the x86 vector is invalid, and we are registering a handler,\n       * attempt to get a new x86 vector from the pool. */\n      uint range_start = 0;\n\n      /* Right now, there is not much we can do if the allocation fails.  In\n       * debug builds, we ASSERT that everything went well.  In release\n       * builds, we log a message and then silently ignore the request to\n       * register a new handler. */\n\n      result = AllocHandler(1, &range_start);\n\n      if (result != ZX_OK) {\n        TRACEF(\n            \"Failed to allocate x86 IRQ vector for global IRQ (%u) when \"\n            \"registering new handler (%p, %p)\\n\",\n            global_irq, handler, arg);\n        return result;\n      }\n\n      DEBUG_ASSERT((range_start >= X86_INT_PLATFORM_BASE) && (range_start <= X86_INT_PLATFORM_MAX));\n      x86_vector = (uint8_t)range_start;\n    }\n\n    DEBUG_ASSERT(x86_vector != 0);\n\n    // Update the handler table and register the x86 vector with the io_apic.\n    bool set = handler_table_[x86_vector].SetHandler(handler, arg, permanent);\n    if (!set) {\n      // If we're here, then RegisterInterruptHandler() was called on the\n      // same vector twice to set the handler without clearing the handler\n      // in-between.\n      return ZX_ERR_ALREADY_BOUND;\n    }\n\n    IoApic::ConfigureIrqVector(global_irq, handler != nullptr ? x86_vector : 0);\n\n    return ZX_OK;\n  }\n\n  zx_status_t MsiAllocBlock(uint requested_irqs, bool can_target_64bit, bool is_msix,\n                            msi_block_t* out_block) {\n    if (!out_block) {\n      return ZX_ERR_INVALID_ARGS;\n    }\n\n    if (out_block->allocated) {\n      return ZX_ERR_BAD_STATE;\n    }\n\n    if (!requested_irqs || (requested_irqs > MAX_MSI_IRQS)) {\n      return ZX_ERR_INVALID_ARGS;\n    }\n\n    zx_status_t res;\n    uint alloc_start = 0;\n    uint alloc_size = 1u << log2_uint_ceil(requested_irqs);\n\n    {\n      Guard<SpinLock, IrqSave> guard{&lock_};\n      res = AllocHandler(alloc_size, &alloc_start);\n    }\n    if (res == ZX_OK) {\n      // Compute the target address.\n      // See section 10.11.1 of the Intel 64 and IA-32 Architectures Software\n      // Developer's Manual Volume 3A.\n      //\n      // TODO(johngro) : don't just bind this block to the Local APIC of the\n      // processor which is active when calling msi_alloc_block.  Instead,\n      // there should either be a system policy (like, always send to any\n      // processor, or just processor 0, or something), or the decision of\n      // which CPUs to bind to should be left to the caller.\n      uint32_t tgt_addr = 0xFEE00000;               // base addr\n      tgt_addr |= ((uint32_t)apic_bsp_id()) << 12;  // Dest ID == the BSP APIC ID\n      tgt_addr |= 0x08;                             // Redir hint == 1\n      tgt_addr &= ~0x04;                            // Dest Mode == Physical\n\n      // Compute the target data.\n      // See section 10.11.2 of the Intel 64 and IA-32 Architectures Software\n      // Developer's Manual Volume 3A.\n      //\n      // delivery mode == 0 (fixed)\n      // trigger mode  == 0 (edge)\n      // vector == start of block range\n      DEBUG_ASSERT(!(alloc_start & ~0xFF));\n      DEBUG_ASSERT(!(alloc_start & (alloc_size - 1)));\n      uint32_t tgt_data = alloc_start;\n\n      /* Success!  Fill out the bookkeeping and we are done */\n      out_block->is_32bit = false;\n      out_block->base_irq_id = alloc_start;\n      out_block->num_irq = alloc_size;\n      out_block->tgt_addr = tgt_addr;\n      out_block->tgt_data = tgt_data;\n      out_block->allocated = true;\n    }\n\n    return res;\n  }\n\n  void MsiFreeBlock(msi_block_t* block) {\n    DEBUG_ASSERT(block);\n    DEBUG_ASSERT(block->allocated);\n    {\n      Guard<SpinLock, IrqSave> guard{&lock_};\n      FreeHandler(block->base_irq_id, block->num_irq);\n    }\n    memset(block, 0, sizeof(*block));\n  }\n\n  void MsiRegisterHandler(const msi_block_t* block, uint msi_id, int_handler handler, void* ctx) {\n    DEBUG_ASSERT(block && block->allocated);\n    DEBUG_ASSERT(msi_id < block->num_irq);\n\n    uint x86_vector = msi_id + block->base_irq_id;\n    DEBUG_ASSERT((x86_vector >= X86_INT_PLATFORM_BASE) && (x86_vector <= X86_INT_PLATFORM_MAX));\n\n    handler_table_[x86_vector].OverwriteHandler(handler, ctx);\n  }\n\n private:\n  // Representation of a single entry in the interrupt table, including a\n  // lock to ensure a consistent view of the entry.\n  class InterruptTableEntry {\n   public:\n    void GetHandler(int_handler* handler, void** arg) {\n      Guard<SpinLock, IrqSave> guard{&lock_};\n      *handler = handler_;\n      *arg = arg_;\n    }\n\n    bool permanent() const {\n      // Permanent handlers do not get modified once set, and are only set on startup, so we can use\n      // relaxed loads.\n      return permanent_.load(ktl::memory_order_relaxed);\n    }\n\n    // Returns true if the handler was present.  Must be called with\n    // interrupts disabled.\n    bool InvokeIfPresent() {\n      if (permanent()) {\n        // Once permanent is set to true we know that handler and arg are immutable and so it is\n        // safe to read them without holding the lock.\n        [this]() TA_NO_THREAD_SAFETY_ANALYSIS {\n          DEBUG_ASSERT(handler_);\n          handler_(arg_);\n        }();\n        return true;\n      } else {\n        Guard<SpinLock, NoIrqSave> guard{&lock_};\n        if (handler_) {\n          handler_(arg_);\n          return true;\n        }\n        return false;\n      }\n    }\n\n    // Set the handler for this entry.  If |handler| is nullptr, |arg| is\n    // ignored.  Makes no change and returns false if |handler| is not\n    // nullptr and this entry already has a handler assigned.\n    bool SetHandler(int_handler handler, void* arg, bool make_permanent) {\n      Guard<SpinLock, IrqSave> guard{&lock_};\n      // Cannot modify existing permanent handlers.\n      if (permanent()) {\n        return false;\n      }\n      if (handler && handler_) {\n        return false;\n      }\n\n      handler_ = handler;\n      arg_ = handler ? arg : nullptr;\n      permanent_.store(make_permanent, ktl::memory_order_relaxed);\n      return true;\n    }\n\n    // Set the handler for this entry.  If |handler| is nullptr, |arg| is\n    // ignored.\n    void OverwriteHandler(int_handler handler, void* arg) {\n      Guard<SpinLock, IrqSave> guard{&lock_};\n      DEBUG_ASSERT(!permanent());\n      handler_ = handler;\n      arg_ = handler ? arg : nullptr;\n    }\n\n   private:\n    mutable DECLARE_SPINLOCK(InterruptTableEntry) lock_;\n\n    int_handler handler_ TA_GUARDED(lock_) = nullptr;\n    void* arg_ TA_GUARDED(lock_) = nullptr;\n    ktl::atomic<bool> permanent_ = false;\n  };\n\n  void FreeHandler(uint base, uint count) TA_REQ(lock_) {\n    handler_allocated_.Clear(base, base + count);\n  }\n\n  // Allocates a range of handlers that are also aligned by the count, which must be a power of 2.\n  zx_status_t AllocHandler(uint count, uint* start) TA_REQ(lock_) {\n    DEBUG_ASSERT(fbl::is_pow2(count));\n    // This is the anchor of our search. We always start at the beginning.\n    size_t bitoff = X86_INT_PLATFORM_BASE;\n\n    zx_status_t result;\n    do {\n      // Round the start of our search up to count (which is also our alignment).\n      // Find will return an error if bitoff has exceeded the end of the range.\n      bitoff = ROUNDUP(bitoff, count);\n      result = handler_allocated_.Find(false, bitoff, X86_INT_PLATFORM_MAX + 1, count, &bitoff);\n      // Bail early if we get any kind of error.\n      if (result != ZX_OK) {\n        return result;\n      }\n    } while ((bitoff % count) != 0);\n    // Loop only exits if we found a valid range.\n    *start = (uint)bitoff;\n    return handler_allocated_.Set(bitoff, bitoff + count);\n  }\n  friend bool TestHandlerAllocationAlignment();\n\n  // This lock guards against concurrent access to the IOAPIC and handler allocation bitmap.\n  DECLARE_SPINLOCK(InterruptManager) lock_;\n\n  // Handler table with one entry per CPU interrupt vector.\n  InterruptTableEntry handler_table_[X86_INT_COUNT] = {};\n\n  // Bitmap to track what entries in handler_table_ are in use.\n  bitmap::RawBitmapGeneric<bitmap::FixedStorage<X86_INT_COUNT>> handler_allocated_\n      TA_GUARDED(lock_);\n};\n\n#endif  // ZIRCON_KERNEL_PLATFORM_PC_INTERRUPT_MANAGER_H_\n\n", "comment_ratio": 0.21508379888268156}
{"lang": "c", "code": "#pragma once\n#include <aws/gamelift/GameLift_EXPORTS.h>\n#include <aws/core/utils/memory/stl/AWSString.h>\n\nnamespace Aws\n{\nnamespace GameLift\n{\nnamespace Model\n{\n  enum class FleetStatus\n  {\n    NOT_SET,\n    NEW_,\n    DOWNLOADING,\n    VALIDATING,\n    BUILDING,\n    ACTIVATING,\n    ACTIVE,\n    DELETING,\n    ERROR_,\n    TERMINATED\n  };\n\nnamespace FleetStatusMapper\n{\nAWS_GAMELIFT_API FleetStatus GetFleetStatusForName(const Aws::String& name);\n\nAWS_GAMELIFT_API Aws::String GetNameForFleetStatus(FleetStatus value);\n} // namespace FleetStatusMapper\n} // namespace Model\n} // namespace GameLift\n} // namespace Aws\n\n", "comment_ratio": 0.10256410256410256}
{"lang": "c", "code": "#pragma once\n\n#include \"rand_state.h\"\n#include \"reductions_fwd.h\"\n#include \"distributionally_robust.h\"\n#include \"metric_sink.h\"\n#include \"action_score.h\"\n#include \"learner.h\"\n#include \"array_parameters_dense.h\"\n#include \"scored_config.h\"\n#include \"vw_string_view.h\"\n#include <map>\n#include <memory>\n#include <set>\n#include <queue>\n#include <fmt/format.h>\n\nusing namespace VW::config;\nusing namespace VW::LEARNER;\n\nnamespace VW\n{\nnamespace automl\n{\nusing namespace_index = unsigned char;\nusing interaction_vec_t = std::vector<std::vector<namespace_index>>;\n\nVW::LEARNER::base_learner* automl_setup(VW::setup_base_i&);\n\nnamespace details\n{\nvoid fail_if_enabled(VW::workspace&, const std::set<std::string>&);\n// void print_weights_nonzero(VW::workspace*, uint64, dense_parameters&);\n}  // namespace details\n\nconstexpr uint64_t MAX_CONFIGS = 10;\nconstexpr uint64_t CONFIGS_PER_CHAMP_CHANGE = 5;\nconst std::vector<unsigned char> NS_EXCLUDE_LIST = {ccb_slot_namespace, ccb_id_namespace};\n\nstruct aml_score : VW::scored_config\n{\n  aml_score() : VW::scored_config() {}\n  aml_score(double alpha, double tau) : VW::scored_config(alpha, tau) {}\n  uint64_t config_index = 0;\n  bool eligible_to_inactivate = false;\n  interaction_vec_t live_interactions;  // Live pre-allocated vectors in use\n\n  void persist(metric_sink&, const std::string&, bool);\n};\n\n// all possible states of exclusion config\nenum class config_state\n{\n  New,\n  Live,\n  Inactive,\n  Removed\n};\n\nstruct exclusion_config\n{\n  std::map<namespace_index, std::set<namespace_index>> exclusions;\n  uint64_t lease;\n  float ips = 0.f;\n  float lower_bound = std::numeric_limits<float>::infinity();\n  config_state state = VW::automl::config_state::New;\n\n  exclusion_config(uint64_t lease = 10) : lease(lease) {}\n};\n\n// all possible states of automl\nenum class automl_state\n{\n  Collecting,\n  Experimenting\n};\n\nstruct config_manager\n{\n  // This fn is responsible for applying a config\n  // tracked by 'live_slot' into the example.\n  // the impl is responsible of tracking this config-live_slot mapping\n  void apply_config(example*, uint64_t);\n  // This fn is the 'undo' of configure_interactions\n  void revert_config(example*);\n  void persist(metric_sink&, bool);\n\n  // Public Chacha functions\n  void config_oracle();\n  void pre_process(const multi_ex&);\n  void schedule();\n  void update_champ();\n};\n\nusing priority_func = float(const exclusion_config&, const std::map<namespace_index, uint64_t>&);\n\nstruct interaction_config_manager : config_manager\n{\n  uint64_t total_champ_switches = 0;\n  uint64_t total_learn_count = 0;\n  uint64_t current_champ = 0;\n  uint64_t global_lease;\n  uint64_t max_live_configs;\n  std::shared_ptr<VW::rand_state> random_state;\n  uint64_t priority_challengers;\n  uint64_t valid_config_size = 0;\n  bool keep_configs;\n  std::string oracle_type;\n  dense_parameters& weights;\n  priority_func* calc_priority;\n  double automl_alpha;\n  double automl_tau;\n\n  // Stores all namespaces currently seen -- Namespace switch could we use array, ask Jack\n  std::map<namespace_index, uint64_t> ns_counter;\n\n  // Stores all configs in consideration (Map allows easy deletion unlike vector)\n  std::map<uint64_t, exclusion_config> configs;\n\n  // Stores scores of live configs, size will never exceed max_live_configs\n  std::vector<aml_score> scores;\n\n  // Maybe not needed with oracle, maps priority to config index, unused configs\n  std::priority_queue<std::pair<float, uint64_t>> index_queue;\n\n  interaction_config_manager(uint64_t, uint64_t, std::shared_ptr<VW::rand_state>, uint64_t, bool, std::string,\n      dense_parameters&, float (*)(const exclusion_config&, const std::map<namespace_index, uint64_t>&), double,\n      double);\n\n  void apply_config(example*, uint64_t);\n  void revert_config(example*);\n  void persist(metric_sink&, bool);\n\n  // Public Chacha functions\n  void config_oracle();\n  void pre_process(const multi_ex&);\n  void schedule();\n  void update_champ();\n\n  // Public for save_load\n  void gen_quadratic_interactions(uint64_t);\n\nprivate:\n  bool better(const exclusion_config&, const exclusion_config&) const;\n  bool worse(const exclusion_config&, const exclusion_config&) const;\n  uint64_t choose();\n  bool repopulate_index_queue();\n  bool swap_eligible_to_inactivate(uint64_t);\n  void insert_config(std::map<namespace_index, std::set<namespace_index>>&&);\n};\n\ntemplate <typename CMType>\nstruct automl\n{\n  automl_state current_state = automl_state::Collecting;\n  std::unique_ptr<CMType> cm;\n  LEARNER::multi_learner* adf_learner = nullptr;  //  re-use print from cb_explore_adf\n  automl(std::unique_ptr<CMType> cm) : cm(std::move(cm)) {}\n  // This fn gets called before learning any example\n  void one_step(multi_learner&, multi_ex&, CB::cb_class&, uint64_t);\n  void offset_learn(multi_learner&, multi_ex&, CB::cb_class&, uint64_t);\n\nprivate:\n  ACTION_SCORE::action_scores champ_a_s;  // a sequence of classes with scores.  Also used for probabilities.\n};\n\n}  // namespace automl\n\nVW::string_view to_string(automl::automl_state state);\nVW::string_view to_string(automl::config_state state);\n\nnamespace model_utils\n{\ntemplate <typename CMType>\nsize_t write_model_field(io_buf&, const VW::automl::automl<CMType>&, const std::string&, bool);\nsize_t read_model_field(io_buf&, VW::automl::exclusion_config&);\nsize_t read_model_field(io_buf&, VW::automl::aml_score&);\nsize_t read_model_field(io_buf&, VW::automl::interaction_config_manager&);\ntemplate <typename CMType>\nsize_t read_model_field(io_buf&, VW::automl::automl<CMType>&);\nsize_t write_model_field(io_buf&, const VW::automl::exclusion_config&, const std::string&, bool);\nsize_t write_model_field(io_buf&, const VW::automl::aml_score&, const std::string&, bool);\nsize_t write_model_field(io_buf&, const VW::automl::interaction_config_manager&, const std::string&, bool);\n}  // namespace model_utils\n}  // namespace VW\n\nnamespace fmt\n{\ntemplate <>\nstruct formatter<VW::automl::automl_state> : formatter<std::string>\n{\n  auto format(VW::automl::automl_state c, format_context& ctx) -> decltype(ctx.out())\n  {\n    return formatter<std::string>::format(std::string{VW::to_string(c)}, ctx);\n  }\n};\n\ntemplate <>\nstruct formatter<VW::automl::config_state> : formatter<std::string>\n{\n  auto format(VW::automl::config_state c, format_context& ctx) -> decltype(ctx.out())\n  {\n    return formatter<std::string>::format(std::string{VW::to_string(c)}, ctx);\n  }\n};\n}  // namespace fmt\n", "comment_ratio": 0.12440191387559808}
{"lang": "c", "code": "#ifndef LIB__KEY_FUNCTIONS__COMMON_h\n\t#define LIB__KEY_FUNCTIONS__COMMON_h\n\n\t#include <stdbool.h>\n\t#include <stdint.h>\n\n\t// --------------------------------------------------------------------\n\n\t// basic\n\tvoid kbfun_press_release (void);\n\tvoid kbfun_press_release_preserve_sticky (void);\n\tvoid kbfun_toggle        (void);\n\tvoid kbfun_transparent   (void);\n\t// --- layer push/pop functions\n\tvoid kbfun_layer_push_1  (void);\n\tvoid kbfun_layer_push_2  (void);\n\tvoid kbfun_layer_push_3  (void);\n\tvoid kbfun_layer_push_4  (void);\n\tvoid kbfun_layer_push_5  (void);\n\tvoid kbfun_layer_push_6  (void);\n\tvoid kbfun_layer_push_7  (void);\n\tvoid kbfun_layer_push_8  (void);\n\tvoid kbfun_layer_push_9  (void);\n\tvoid kbfun_layer_push_10 (void);\n\tvoid kbfun_layer_sticky_1  (void);\n\tvoid kbfun_layer_sticky_2  (void);\n\tvoid kbfun_layer_sticky_3  (void);\n\tvoid kbfun_layer_sticky_4  (void);\n\tvoid kbfun_layer_sticky_5  (void);\n\tvoid kbfun_layer_sticky_6  (void);\n\tvoid kbfun_layer_sticky_7  (void);\n\tvoid kbfun_layer_sticky_8  (void);\n\tvoid kbfun_layer_sticky_9  (void);\n\tvoid kbfun_layer_sticky_10 (void);\n\tvoid kbfun_layer_pop_1   (void);\n\tvoid kbfun_layer_pop_2   (void);\n\tvoid kbfun_layer_pop_3   (void);\n\tvoid kbfun_layer_pop_4   (void);\n\tvoid kbfun_layer_pop_5   (void);\n\tvoid kbfun_layer_pop_6   (void);\n\tvoid kbfun_layer_pop_7   (void);\n\tvoid kbfun_layer_pop_8   (void);\n\tvoid kbfun_layer_pop_9   (void);\n\tvoid kbfun_layer_pop_10  (void);\n\tvoid kbfun_layer_toggle_1   (void);\n\tvoid kbfun_layer_toggle_2   (void);\n\tvoid kbfun_layer_toggle_3   (void);\n\tvoid kbfun_layer_toggle_4   (void);\n\tvoid kbfun_layer_toggle_5   (void);\n\tvoid kbfun_layer_toggle_6   (void);\n\tvoid kbfun_layer_toggle_7   (void);\n\tvoid kbfun_layer_toggle_8   (void);\n\tvoid kbfun_layer_toggle_9   (void);\n\tvoid kbfun_layer_toggle_10  (void);\n\t// ---\n\n\t// device\n\tvoid kbfun_jump_to_bootloader (void);\n\n\t// special\n\tvoid kbfun_shift_press_release           (void);\n\tvoid kbfun_2_keys_capslock_press_release (void);\n\tvoid kbfun_layer_push_numpad             (void);\n\tvoid kbfun_layer_pop_numpad              (void);\n\tvoid kbfun_mediakey_press_release        (void);\n\n\t// custom\n\tvoid kbfun_altgr_press_release           (void);\n    void kbfun_altgr_n_pc_press_release      (void);\n    void kbfun_altgr_n_mac_press_release     (void);\n\n    void kbfun_tilde_pc_press_release\t\t (void);\n    void kbfun_tilde_mac_press_release\t\t (void);\n    void kbfun_dieresis_mac_press_release\t (void);\n    void kbfun_dieresis_pc_press_release\t (void);\n\n    // copy, cut, and paste\n    void kbfun_mod_mac_press_release         (void);\n    void kbfun_mod_wl_press_release          (void);\n\n    // alt + gui\n    void kbfun_mod_mac_alt_press_release\t (void);\n    // ctr + gui\n    void kbfun_mod_mac_ctr_press_release   (void);\n\n    // macro\n    void kbfun_vim_save                      (void);\n    void kbfun_vim_save_and_quit             (void);\n    void macro_f2_ctrl_mod\t\t\t\t\t (void);\n#endif\n\n\n", "comment_ratio": 0.1188118811881188}
{"lang": "c", "code": "#include <stdio.h>\n#include BOSS_OPENSSL_U_internal__cryptlib_h //original-code:\"internal/cryptlib.h\"\n\n#ifndef OPENSSL_NO_RMD160\n\n# include BOSS_OPENSSL_V_openssl__ripemd_h //original-code:<openssl/ripemd.h>\n# include BOSS_OPENSSL_V_openssl__evp_h //original-code:<openssl/evp.h>\n# include BOSS_OPENSSL_V_openssl__objects_h //original-code:<openssl/objects.h>\n# include BOSS_OPENSSL_V_openssl__x509_h //original-code:<openssl/x509.h>\n# include BOSS_OPENSSL_V_openssl__rsa_h //original-code:<openssl/rsa.h>\n# include BOSS_OPENSSL_U_internal__evp_int_h //original-code:\"internal/evp_int.h\"\n\nstatic int init(EVP_MD_CTX *ctx)\n{\n    return RIPEMD160_Init(EVP_MD_CTX_md_data(ctx));\n}\n\nstatic int update(EVP_MD_CTX *ctx, const void *data, size_t count)\n{\n    return RIPEMD160_Update(EVP_MD_CTX_md_data(ctx), data, count);\n}\n\nstatic int final(EVP_MD_CTX *ctx, unsigned char *md)\n{\n    return RIPEMD160_Final(md, EVP_MD_CTX_md_data(ctx));\n}\n\nstatic const EVP_MD ripemd160_md = {\n    NID_ripemd160,\n    NID_ripemd160WithRSA,\n    RIPEMD160_DIGEST_LENGTH,\n    0,\n    init,\n    update,\n    final,\n    NULL,\n    NULL,\n    RIPEMD160_CBLOCK,\n    sizeof(EVP_MD *) + sizeof(RIPEMD160_CTX),\n};\n\nconst EVP_MD *EVP_ripemd160(void)\n{\n    return (&ripemd160_md);\n}\n#endif\n\n", "comment_ratio": 0.14285714285714285}
{"lang": "c", "code": "#ifndef VROARObjectTargetiOS_h\n#define VROARObjectTargetiOS_h\n\n#include \"VROARObjectTarget.h\"\n\n@class ARReferenceObject;\n\nclass VROARObjectTargetiOS : public VROARObjectTarget {\n    \npublic:\n    VROARObjectTargetiOS(NSURL *localFileUrl);\n\n    virtual ~VROARObjectTargetiOS();\n\n    NSURL *getLocalFileUrl() {\n        return _localFileUrl;\n    }\n\n#if __IPHONE_OS_VERSION_MAX_ALLOWED >= 120000\n    ARReferenceObject *getARReferenceObject();\n#endif\n\nprivate:\n    NSURL *_localFileUrl;\n    \n#if __IPHONE_OS_VERSION_MAX_ALLOWED >= 120000\n    ARReferenceObject *_referenceObject;\n#endif\n};\n\n\n#endif /* VROARObjectTargetiOS_h */\n\n", "comment_ratio": 0.17073170731707318}
{"lang": "c", "code": "// HEADER file\n\n#pragma once\n#include <iostream>\n#include \"SparseSolvers.h\"\n#include \"SparseSolvers.cpp\"\n\ntemplate <class T>\nclass DenseSolver\n{\npublic:\n    // Constructor\n    DenseSolver();\n\n    // Destructor\n    ~DenseSolver();\n\n    // Regular dense matrix solvers\n    void GaussSolver(Matrix<T>& A, T *b);\n    void LUsolver(Matrix<T>& A, T *b);\n    void LUpartialPivot(Matrix<T>& A, T *b);\n\n    // Iterative dense matrix solvers\n    void GaussSeidel(Matrix<T>& A, T *b, T*x, int iter, double tol);\n    void Jacobi(Matrix<T>& A, T *b, T*x, int iter, double tol);\n\n};\n\n", "comment_ratio": 0.17857142857142858}
{"lang": "c", "code": "#import <Cocoa/Cocoa.h>\n\n\n@interface NNWTabThumbnailCache : NSObject {\n\t}\n\n\n+ (id)sharedCache;\n\n- (NSImage *)imageForURLString:(NSString *)urlString;\n- (void)setImage:(NSImage *)image forURLString:(NSString *)urlString;\n\n- (NSString *)pathForURLString:(NSString *)urlString;\n\n- (void)startupCache;\n\n\n@end\n\n", "comment_ratio": 0.25925925925925924}
{"lang": "c", "code": "#include \"wrappointer.h\"\n\n//////////////////////////////////////////////////////////////////////////\n/**\n\n  Implements set method for Pointer types. The reference\n  system allows to assign lua strings and userdata and keeps\n  them alive during the lifetime of the outer object.\n\n*////////////////////////////////////////////////////////////////////////\nstatic int luacwrap_pointer_set(luacwrap_BasicType* self, lua_State *L, PBYTE pData, int offset)\n{\n  PBYTE* v = (PBYTE*)pData;\n\n  switch (lua_type(L, -1))\n  {\n    case LUA_TLIGHTUSERDATA:\n    case LUA_TUSERDATA:\n      {\n        *v = (PBYTE)lua_touserdata(L, -1);\n        \n        if (*v)\n        {\n          // store reference in outer value\n          luacwrap_mobj_set_reference(L, 1, abs_index(L, -1), offset);\n        }\n        else\n        {\n          // remove a possible reference value (from a previously assigned value)\n          luacwrap_mobj_remove_reference(L, 1, offset);\n        }\n      }\n      break;\n    case LUA_TSTRING:\n      {\n        *v = (PBYTE)lua_tostring(L, -1);\n\n        // store reference in outer value\n        luacwrap_mobj_set_reference(L, 1, abs_index(L, -1), offset);\n      }\n      break;\n    case LUA_TNUMBER:\n    case LUA_TNIL:\n      {\n        *v = (PBYTE)lua_tointeger(L, -1);\n        \n        // remove a possible reference value (from a previously assigned value)\n        luacwrap_mobj_remove_reference(L, 1, offset);\n      }\n      break;\n    default:\n      {\n        luaL_error(L, \"userdata, string or number expected, got %s\", luaL_typename(L, 4));\n      }\n      break;\n  }\n\n  return 0;\n}\n\n//////////////////////////////////////////////////////////////////////////\n/**\n\n  Implements get method for Pointer types. This checks first\n  the reference system to get the lua type behind the pointer.\n  Otherwise it returns the pointer as a lightuserdata.\n\n*////////////////////////////////////////////////////////////////////////\nstatic int luacwrap_pointer_get(luacwrap_BasicType* self, lua_State *L, PBYTE pData, int offset)\n{\n  // try to get referenced lua value from outer struct\n  if (!luacwrap_mobj_get_reference(L, 1, offset))\n  {\n    // otherwise return raw pointer as light userdata\n    PBYTE* v = (PBYTE*)pData;\n    if (*v)\n    {\n      lua_pushlightuserdata(L, *v);\n    }\n    else\n    {\n      lua_pushnil(L);\n    }\n  }\n\n  return 1;\n}\n\nluacwrap_BasicType regType_Pointer =\n{\n  {\n    LUACWRAP_TC_BASIC,\n    \"$ptr\"\n  },\n  sizeof(PBYTE),\n  luacwrap_pointer_get,\n  luacwrap_pointer_set\n};\n\n", "comment_ratio": 0.15178571428571427}
{"lang": "c", "code": "#if !defined( C_HL2_PLAYERLOCALDATA_H )\n#define C_HL2_PLAYERLOCALDATA_H\n#ifdef _WIN32\n#pragma once\n#endif\n\n\n#include \"dt_recv.h\"\n\n#include \"hl2/hl_movedata.h\"\n\nEXTERN_RECV_TABLE( DT_HL2Local );\n\n\nclass C_HL2PlayerLocalData\n{\npublic:\n\tDECLARE_PREDICTABLE();\n\tDECLARE_CLASS_NOBASE( C_HL2PlayerLocalData );\n\tDECLARE_EMBEDDED_NETWORKVAR();\n\n\tC_HL2PlayerLocalData();\n\n\tfloat\tm_flSuitPower;\n\tbool\tm_bZooming;\n\tint\t\tm_bitsActiveDevices;\n\tint\t\tm_iSquadMemberCount;\n\tint\t\tm_iSquadMedicCount;\n\tbool\tm_fSquadInFollowMode;\n\tbool\tm_bWeaponLowered;\n\tEHANDLE m_hAutoAimTarget;\n\tVector\tm_vecAutoAimPoint;\n\tbool\tm_bDisplayReticle;\n\tbool\tm_bStickyAutoAim;\n\tbool\tm_bAutoAimTarget;\n#ifdef HL2_EPISODIC\n\tfloat\tm_flFlashBattery;\n\tVector\tm_vecLocatorOrigin;\n#endif\n\n\t// Ladder related data\n\tEHANDLE\t\t\tm_hLadder;\n\tLadderMove_t\tm_LadderMove;\n\n\tlong m_nFlares;\n};\n\n\n#endif\n\n", "comment_ratio": 0.13793103448275862}
{"lang": "c", "code": "//\n//  DSError.h\n//  Pods\n//\n//  Created by Stan Liu on 14/06/2017.\n//\n//\n\n#import <Foundation/Foundation.h>\n\n@interface DSError : NSError\n\n+(DSError *)mergePushFailed;\n+(DSError *)forcePushFailed;\n+(DSError *)pullFailed;\n+(DSError *)remoteDataNil;\n+(DSError *)noInternet;\n\n\n@end\n\n", "comment_ratio": 0.3333333333333333}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n\ntypedef void(^HWUIGestureRecognizerHandler)(__kindof UIGestureRecognizer *ges);\n\n@interface UIGestureRecognizer (Block)\n\n+ (instancetype)gestureRecognizerWithHandler:(HWUIGestureRecognizerHandler)handler;\n\n- (void)addGestureRecognizerHandler:(HWUIGestureRecognizerHandler)handler;\n\n// \u79fb\u9664handler, \u5982\u679c handler == nil, \u6240\u6709\u5df2\u6dfb\u52a0\u7684handler\u5c06\u88ab\u79fb\u9664\n- (void)removeGestureRecognizerHandler:(HWUIGestureRecognizerHandler)handler;\n\n@end\n\n", "comment_ratio": 0.34782608695652173}
{"lang": "c", "code": "#ifndef vtkm_worklet_cosmotools_cosmotools_halofinder_h\n#define vtkm_worklet_cosmotools_cosmotools_halofinder_h\n\n#include <vtkm/worklet/cosmotools/CosmoTools.h>\n\n#include <vtkm/cont/ArrayGetValues.h>\n\nnamespace vtkm\n{\nnamespace worklet\n{\nnamespace cosmotools\n{\n\n///////////////////////////////////////////////////////////////////////////////////////////\n//\n// Halo finder for all particles in domain\n//\n///////////////////////////////////////////////////////////////////////////////////////////\n\ntemplate <typename T, typename StorageType>\nvoid CosmoTools<T, StorageType>::HaloFinder(vtkm::cont::ArrayHandle<vtkm::Id>& resultHaloId,\n                                            vtkm::cont::ArrayHandle<vtkm::Id>& resultMBP,\n                                            vtkm::cont::ArrayHandle<T>& resultPot)\n{\n  // Package locations for worklets\n  using CompositeLocationType =\n    typename vtkm::cont::ArrayHandleCompositeVector<LocationType, LocationType, LocationType>;\n  CompositeLocationType location;\n  location = make_ArrayHandleCompositeVector(xLoc, yLoc, zLoc);\n\n  vtkm::cont::ArrayHandle<vtkm::Id> leftNeighbor;  // lower particle id to check for linking length\n  vtkm::cont::ArrayHandle<vtkm::Id> rightNeighbor; // upper particle id to check for linking length\n  vtkm::cont::ArrayHandle<vtkm::UInt32>\n    activeMask;                             // mask per particle indicating active neighbor bins\n  vtkm::cont::ArrayHandle<vtkm::Id> partId; // index into all particles\n  vtkm::cont::ArrayHandle<vtkm::Id> binId;  // bin id for each particle in each FOF halo\n\n  leftNeighbor.Allocate(NUM_NEIGHBORS * nParticles);\n  rightNeighbor.Allocate(NUM_NEIGHBORS * nParticles);\n\n  vtkm::cont::ArrayHandleConstant<bool> trueArray(true, nParticles);\n  vtkm::cont::ArrayHandleIndex indexArray(nParticles);\n\n  // Bin all particles in domain into bins of size linking length\n  BinParticlesAll(partId, binId, leftNeighbor, rightNeighbor);\n\n  // Mark active neighbor bins, meaning at least one particle in the bin\n  // is within linking length of the given particle indicated by mask\n  MarkActiveNeighbors<T> markActiveNeighbors(numBinsX, numBinsY, numBinsZ, NUM_NEIGHBORS, linkLen);\n  vtkm::worklet::DispatcherMapField<MarkActiveNeighbors<T>> markActiveNeighborsDispatcher(\n    markActiveNeighbors);\n  markActiveNeighborsDispatcher.Invoke(\n    indexArray,    // (input) index into all particles\n    partId,        // (input) particle id sorted by bin\n    binId,         // (input) bin id sorted\n    partId,        // (input) particle id (whole array)\n    location,      // (input) location on original particle order\n    leftNeighbor,  // (input) first partId for neighbor vector\n    rightNeighbor, // (input) last partId for neighbor vector\n    activeMask);   // (output) mask per particle indicating valid neighbors\n\n  // Initialize halo id of each particle to itself\n  vtkm::cont::ArrayHandle<vtkm::Id> haloIdCurrent;\n  vtkm::cont::ArrayHandle<vtkm::Id> haloIdLast;\n  DeviceAlgorithm::Copy(indexArray, haloIdCurrent);\n  DeviceAlgorithm::Copy(indexArray, haloIdLast);\n\n  // rooted star is nchecked each iteration for all particles being rooted in a halo\n  vtkm::cont::ArrayHandle<bool> rootedStar;\n\n  // Iterate over particles graft together to form halos\n  while (true)\n  {\n    // Connect each particle to another close particle to build halos\n    GraftParticles<T> graftParticles(numBinsX, numBinsY, numBinsZ, NUM_NEIGHBORS, linkLen);\n    vtkm::worklet::DispatcherMapField<GraftParticles<T>> graftParticlesDispatcher(graftParticles);\n\n    graftParticlesDispatcher.Invoke(indexArray,   // (input) index into particles\n                                    partId,       // (input) particle id sorted by bin\n                                    binId,        // (input) bin id sorted by bin\n                                    activeMask,   // (input) flag indicates if neighor range is used\n                                    partId,       // (input) particle id (whole array)\n                                    location,     // (input) location on original particle order\n                                    leftNeighbor, // (input) first partId for neighbor\n                                    rightNeighbor,  // (input) last partId for neighbor\n                                    haloIdCurrent); // (output)\n#ifdef DEBUG_PRINT\n    DebugPrint(\"haloIdCurrent\", haloIdCurrent);\n#endif\n\n    // Reininitialize rootedStar for each pass\n    DeviceAlgorithm::Copy(trueArray, rootedStar);\n\n    // By comparing the haloIds from the last pass and this one\n    // determine if any particles are still migrating to halos\n    IsStar isStar;\n    vtkm::worklet::DispatcherMapField<IsStar> isStarDispatcher(isStar);\n    isStarDispatcher.Invoke(indexArray,\n                            haloIdCurrent, // input (whole array)\n                            haloIdLast,    // input (whole array)\n                            rootedStar);   // output (whole array)\n\n    // If all vertices are in rooted stars, algorithm is complete\n    bool allStars = DeviceAlgorithm::Reduce(rootedStar, true, vtkm::LogicalAnd());\n    if (allStars)\n    {\n      break;\n    }\n    else\n    // Otherwise copy current halo ids to last pass halo ids\n    {\n      PointerJump pointerJump;\n      vtkm::worklet::DispatcherMapField<PointerJump> pointerJumpDispatcher(pointerJump);\n      pointerJumpDispatcher.Invoke(indexArray, haloIdCurrent); // input (whole array)\n      DeviceAlgorithm::Copy(haloIdCurrent, haloIdLast);\n    }\n  }\n\n  // Index into final halo id is the original particle ordering\n  // not the particles sorted by bin\n  DeviceAlgorithm::Copy(indexArray, partId);\n#ifdef DEBUG_PRINT\n  DebugPrint(\"FINAL haloId\", haloIdCurrent);\n  DebugPrint(\"FINAL partId\", partId);\n#endif\n\n  // Call center finding on all halos using method with ReduceByKey and Scatter\n  DeviceAlgorithm::Copy(haloIdCurrent, resultHaloId);\n  MBPCenterFindingByHalo(partId, resultHaloId, resultMBP, resultPot);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Bin all particles in the system for halo finding\n//\n///////////////////////////////////////////////////////////////////////////////\ntemplate <typename T, typename StorageType>\nvoid CosmoTools<T, StorageType>::BinParticlesAll(vtkm::cont::ArrayHandle<vtkm::Id>& partId,\n                                                 vtkm::cont::ArrayHandle<vtkm::Id>& binId,\n                                                 vtkm::cont::ArrayHandle<vtkm::Id>& leftNeighbor,\n                                                 vtkm::cont::ArrayHandle<vtkm::Id>& rightNeighbor)\n{\n  // Compute number of bins and ranges for each bin\n  vtkm::Vec<T, 2> result;\n  vtkm::Vec<T, 2> xInit(vtkm::cont::ArrayGetValue(0, xLoc));\n  vtkm::Vec<T, 2> yInit(vtkm::cont::ArrayGetValue(0, yLoc));\n  vtkm::Vec<T, 2> zInit(vtkm::cont::ArrayGetValue(0, zLoc));\n  result = DeviceAlgorithm::Reduce(xLoc, xInit, vtkm::MinAndMax<T>());\n  T minX = result[0];\n  T maxX = result[1];\n  result = DeviceAlgorithm::Reduce(yLoc, yInit, vtkm::MinAndMax<T>());\n  T minY = result[0];\n  T maxY = result[1];\n  result = DeviceAlgorithm::Reduce(zLoc, zInit, vtkm::MinAndMax<T>());\n  T minZ = result[0];\n  T maxZ = result[1];\n\n  vtkm::Id maxBins = 1048576;\n  vtkm::Id minBins = 1;\n\n  numBinsX = static_cast<vtkm::Id>(vtkm::Floor((maxX - minX) / linkLen));\n  numBinsY = static_cast<vtkm::Id>(vtkm::Floor((maxY - minY) / linkLen));\n  numBinsZ = static_cast<vtkm::Id>(vtkm::Floor((maxZ - minZ) / linkLen));\n\n  numBinsX = std::min(maxBins, numBinsX);\n  numBinsY = std::min(maxBins, numBinsY);\n  numBinsZ = std::min(maxBins, numBinsZ);\n\n  numBinsX = std::max(minBins, numBinsX);\n  numBinsY = std::max(minBins, numBinsY);\n  numBinsZ = std::max(minBins, numBinsZ);\n\n  // Compute which bin each particle is in\n  ComputeBins<T> computeBins(minX,\n                             maxX, // Physical range on domain\n                             minY,\n                             maxY,\n                             minZ,\n                             maxZ,\n                             numBinsX,\n                             numBinsY,\n                             numBinsZ); // Size of superimposed mesh\n  vtkm::worklet::DispatcherMapField<ComputeBins<T>> computeBinsDispatcher(computeBins);\n  computeBinsDispatcher.Invoke(xLoc,   // input\n                               yLoc,   // input\n                               zLoc,   // input\n                               binId); // output\n\n  vtkm::cont::ArrayHandleIndex indexArray(nParticles);\n  DeviceAlgorithm::Copy(indexArray, partId);\n\n#ifdef DEBUG_PRINT\n  std::cout << std::endl\n            << \"** BinParticlesAll (\" << numBinsX << \", \" << numBinsY << \", \" << numBinsZ << \")\"\n            << std::endl;\n  DebugPrint(\"xLoc\", xLoc);\n  DebugPrint(\"yLoc\", yLoc);\n  DebugPrint(\"zLoc\", zLoc);\n  DebugPrint(\"partId\", partId);\n  DebugPrint(\"binId\", binId);\n  std::cout << std::endl;\n#endif\n\n  // Sort the particles by bin (remember that xLoc and yLoc are not sorted)\n  DeviceAlgorithm::SortByKey(binId, partId);\n#ifdef DEBUG_PRINT\n  DebugPrint(\"partId\", partId);\n  DebugPrint(\"binId\", binId);\n#endif\n\n  // Compute indices of all left neighbor bins\n  vtkm::cont::ArrayHandleIndex countArray(nParticles);\n  ComputeNeighborBins computeNeighborBins(numBinsX, numBinsY, numBinsZ, NUM_NEIGHBORS);\n  vtkm::worklet::DispatcherMapField<ComputeNeighborBins> computeNeighborBinsDispatcher(\n    computeNeighborBins);\n  computeNeighborBinsDispatcher.Invoke(countArray, binId, leftNeighbor);\n\n  // Compute indices of all right neighbor bins\n  ComputeBinRange computeBinRange(numBinsX);\n  vtkm::worklet::DispatcherMapField<ComputeBinRange> computeBinRangeDispatcher(computeBinRange);\n  computeBinRangeDispatcher.Invoke(leftNeighbor, rightNeighbor);\n\n  // Convert bin range to particle range within the bins\n  DeviceAlgorithm::LowerBounds(binId, leftNeighbor, leftNeighbor);\n  DeviceAlgorithm::UpperBounds(binId, rightNeighbor, rightNeighbor);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Center finder for all particles given location, particle id and halo id\n// MBP (Most Bound Particle) is particle with the minimum potential energy\n// Method uses ReduceByKey() and Scatter()\n//\n///////////////////////////////////////////////////////////////////////////////\ntemplate <typename T, typename StorageType>\nvoid CosmoTools<T, StorageType>::MBPCenterFindingByHalo(vtkm::cont::ArrayHandle<vtkm::Id>& partId,\n                                                        vtkm::cont::ArrayHandle<vtkm::Id>& haloId,\n                                                        vtkm::cont::ArrayHandle<vtkm::Id>& mbpId,\n                                                        vtkm::cont::ArrayHandle<T>& minPotential)\n{\n  // Sort particles into groups according to halo id using an index into WholeArrays\n  DeviceAlgorithm::SortByKey(haloId, partId);\n#ifdef DEBUG_PRINT\n  DebugPrint(\"Sorted haloId\", haloId);\n  DebugPrint(\"Sorted partId\", partId);\n#endif\n\n  // Find the particle in each halo with the lowest potential\n  // Compute starting and ending indices of each halo\n  vtkm::cont::ArrayHandleConstant<vtkm::Id> constArray(1, nParticles);\n  vtkm::cont::ArrayHandleIndex indexArray(nParticles);\n  vtkm::cont::ArrayHandle<vtkm::Id> uniqueHaloIds;\n  vtkm::cont::ArrayHandle<vtkm::Id> particlesPerHalo;\n  vtkm::cont::ArrayHandle<vtkm::Id> minParticle;\n  vtkm::cont::ArrayHandle<vtkm::Id> maxParticle;\n  vtkm::cont::ArrayHandle<T> potential;\n  vtkm::cont::ArrayHandle<vtkm::Id> tempI;\n  vtkm::cont::ArrayHandle<T> tempT;\n\n  // Halo ids have been sorted, reduce to find the number of particles per halo\n  DeviceAlgorithm::ReduceByKey(haloId, constArray, uniqueHaloIds, particlesPerHalo, vtkm::Add());\n#ifdef DEBUG_PRINT\n  DebugPrint(\"uniqueHaloId\", uniqueHaloIds);\n  DebugPrint(\"partPerHalo\", particlesPerHalo);\n  std::cout << std::endl;\n#endif\n\n  // Setup the ScatterCounting worklets needed to expand the ReduceByKeyResults\n  vtkm::worklet::ScatterCounting scatter(particlesPerHalo);\n  vtkm::cont::Invoker invoke;\n\n  // Calculate the minimum particle index per halo id and scatter\n  DeviceAlgorithm::ScanExclusive(particlesPerHalo, tempI);\n  invoke(ScatterWorklet<vtkm::Id>{}, scatter, tempI, minParticle);\n\n  // Calculate the maximum particle index per halo id and scatter\n  DeviceAlgorithm::ScanInclusive(particlesPerHalo, tempI);\n  invoke(ScatterWorklet<vtkm::Id>{}, scatter, tempI, maxParticle);\n\n  using IdArrayType = vtkm::cont::ArrayHandle<vtkm::Id>;\n  vtkm::cont::ArrayHandleTransform<IdArrayType, ScaleBiasFunctor<vtkm::Id>> scaleBias =\n    vtkm::cont::make_ArrayHandleTransform<IdArrayType>(maxParticle,\n                                                       ScaleBiasFunctor<vtkm::Id>(1, -1));\n\n  DeviceAlgorithm::Copy(scaleBias, maxParticle);\n#ifdef DEBUG_PRINT\n  DebugPrint(\"minParticle\", minParticle);\n  DebugPrint(\"maxParticle\", maxParticle);\n#endif\n\n  // Compute potentials\n  ComputePotential<T> computePotential(particleMass);\n  vtkm::worklet::DispatcherMapField<ComputePotential<T>> computePotentialDispatcher(\n    computePotential);\n\n  computePotentialDispatcher.Invoke(indexArray,\n                                    partId,      // input (whole array)\n                                    xLoc,        // input (whole array)\n                                    yLoc,        // input (whole array)\n                                    zLoc,        // input (whole array)\n                                    minParticle, // input (whole array)\n                                    maxParticle, // input (whole array)\n                                    potential);  // output\n\n  // Find minimum potential for all particles in a halo and scatter\n  DeviceAlgorithm::ReduceByKey(haloId, potential, uniqueHaloIds, tempT, vtkm::Minimum());\n  invoke(ScatterWorklet<T>{}, scatter, tempT, minPotential);\n#ifdef DEBUG_PRINT\n  DebugPrint(\"potential\", potential);\n  DebugPrint(\"minPotential\", minPotential);\n#endif\n\n  // Find the particle id matching the minimum potential (Worklet)\n  EqualsMinimumPotential<T> equalsMinimumPotential;\n  vtkm::worklet::DispatcherMapField<EqualsMinimumPotential<T>> equalsMinimumPotentialDispatcher(\n    equalsMinimumPotential);\n\n  equalsMinimumPotentialDispatcher.Invoke(partId, potential, minPotential, mbpId);\n\n  // Fill out entire array with center index, another reduce and scatter\n  vtkm::cont::ArrayHandle<vtkm::Id> minIndx;\n  minIndx.Allocate(nParticles);\n  DeviceAlgorithm::ReduceByKey(haloId, mbpId, uniqueHaloIds, minIndx, vtkm::Maximum());\n  invoke(ScatterWorklet<vtkm::Id>{}, scatter, minIndx, mbpId);\n\n  // Resort particle ids and mbpId to starting order\n  vtkm::cont::ArrayHandle<vtkm::Id> savePartId;\n  DeviceAlgorithm::Copy(partId, savePartId);\n\n  DeviceAlgorithm::SortByKey(partId, haloId);\n  DeviceAlgorithm::Copy(savePartId, partId);\n  DeviceAlgorithm::SortByKey(partId, mbpId);\n  DeviceAlgorithm::Copy(savePartId, partId);\n  DeviceAlgorithm::SortByKey(partId, minPotential);\n\n#ifdef DEBUG_PRINT\n  std::cout << std::endl;\n  DebugPrint(\"partId\", partId);\n  DebugPrint(\"xLoc\", xLoc);\n  DebugPrint(\"yLoc\", yLoc);\n  DebugPrint(\"haloId\", haloId);\n  DebugPrint(\"mbpId\", mbpId);\n  DebugPrint(\"minPotential\", minPotential);\n#endif\n}\n}\n}\n}\n#endif\n\n", "comment_ratio": 0.34663341645885287}
{"lang": "c", "code": "#ifndef DEVTOOLS_GOMA_CLIENT_CXX_INCLUDE_PROCESSOR_CPP_INCLUDE_PROCESSOR_UNITTEST_HELPER_H_\n#define DEVTOOLS_GOMA_CLIENT_CXX_INCLUDE_PROCESSOR_CPP_INCLUDE_PROCESSOR_UNITTEST_HELPER_H_\n\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\n\nnamespace devtools_goma {\n\nvoid CompareFiles(const std::string& compiler,\n                  const std::string& include_file,\n                  const std::set<std::string>& expected_files,\n                  const std::set<std::string>& actual_files,\n                  const std::set<std::string>& allowed_extra_files);\n\nbool CreateHeaderMapFile(\n    const std::string& hmap_filename,\n    const std::vector<std::pair<std::string, std::string>>& entries);\n\n}  // namespace devtools_goma\n\n#endif  // DEVTOOLS_GOMA_CLIENT_CXX_INCLUDE_PROCESSOR_CPP_INCLUDE_PROCESSOR_UNITTEST_HELPER_H_\n\n", "comment_ratio": 0.17857142857142858}
{"lang": "c", "code": "#pragma once\n\n#include <cfg/cs_Boards.h>\n#include <drivers/cs_ADC.h>\n#include <events/cs_EventListener.h>\n#include <storage/cs_State.h>\n#include <structs/buffer/cs_CircularBuffer.h>\n#include <structs/buffer/cs_AdcBuffer.h>\n#include <third/Median.h>\n#include <cstdint>\n\ntypedef void (*ps_zero_crossing_cb_t) ();\n\n\nclass PowerSampling : EventListener {\npublic:\n\t//! Gets a static singleton (no dynamic memory allocation)\n\tstatic PowerSampling& getInstance() {\n\t\tstatic PowerSampling instance;\n\t\treturn instance;\n\t}\n\n\tvoid init(const boards_config_t& boardConfig);\n\n\t/** Initializes and starts the ADC, also starts interval timer.\n\t */\n\tvoid powerSampleFirstStart();\n\n\t/** Starts a new power sample burst.\n\t *  Called at a low interval.\n\t */\n\tvoid startSampling();\n\n\t/** Called when the sample burst is finished.\n\t *  Calculates the power usage, updates the state.\n\t *  Sends the samples if the central is subscribed for that.\n\t */\n\tvoid powerSampleAdcDone(adc_buffer_id_t bufIndex);\n\n\t/** Fill up the current curve and send it out over bluetooth\n\t * @type specifies over which characteristic the current curve should be sent.\n\t */\n\tvoid sampleCurrentDone(uint8_t type);\n\n\t/** Enable zero crossing detection on given channel, generating interrupts.\n\t *\n\t * @param[in] callback             Function to be called on a zero crossing event. This function will run at interrupt level!\n\t */\n\tvoid enableZeroCrossingInterrupt(ps_zero_crossing_cb_t callback);\n\n\t/** handle (crownstone) events\n\t */\n\tvoid handleEvent(event_t & event);\n\n\t/**\n\t * Struct that defines the buffer received from the ADC sampler in scanning mode.\n\t */\n\ttypedef struct {\n\t\tadc_sample_value_t* buf;\n\t\tuint16_t bufSize;\n\t\tuint16_t numChannels;\n\t\tuint16_t voltageIndex;\n\t\tuint16_t currentIndex;\n\t\tuint32_t sampleIntervalUs;\n\t\tuint32_t acPeriodUs;\n\t} power_t;\n\n\nprivate:\n\tPowerSampling();\n\n\t// Number of filtered buffers for processing.\n\t// Should be at least as large as number of buffers required for recognize switch.\n\tconst static uint8_t numFilteredBuffersForProcessing = 4;\n\n\t// Currently hard coded at 1.\n\tconst static uint8_t numUnfilteredBuffers = 1;\n\n\t// Number of switch states to keep up.\n\tconst static uint8_t switchHistSize = 3;\n\n\t//! Variable to keep up whether power sampling is initialized.\n\tbool _isInitialized = false;\n\n\t//! Reference to the ADC instance\n\tADC* _adc;\n\n\t//! Operation mode of this device.\n\tOperationMode _operationMode;\n\n\t/**\n\t * Queue of buffers we can use for processing.\n\t *\n\t * If queue size == 1:\n\t * - buffer[0] = last filtered.\n\t * If queue size > 1:\n\t * - buffer[size] = last unfiltered.\n\t * - buffer[size-1] = last filtered.\n\t * - buffer[size-2] = previous filtered.\n\t */\n\tCircularBuffer<adc_buffer_id_t> _bufferQueue;\n\n\tcs_power_samples_header_t _lastSoftfuse;\n\tadc_sample_value_t _lastSoftfuseSamples[AdcBuffer::getChannelLength()] = {0};\n\n\tCircularBuffer<switch_state_t> _switchHist;\n\tcs_power_samples_header_t _lastSwitchSamplesHeader;\n\n\tconst static uint8_t numSwitchSamplesBuffers = 6; // 3 voltage and 3 current buffers.\n\tadc_sample_value_t _lastSwitchSamples[numSwitchSamplesBuffers * AdcBuffer::getChannelLength()] = {0};\n\n\tTYPIFY(CONFIG_VOLTAGE_MULTIPLIER) _voltageMultiplier; //! Voltage multiplier from settings.\n\tTYPIFY(CONFIG_CURRENT_MULTIPLIER) _currentMultiplier; //! Current multiplier from settings.\n\tTYPIFY(CONFIG_VOLTAGE_ADC_ZERO) _voltageZero; //! Voltage zero from settings.\n\tTYPIFY(CONFIG_CURRENT_ADC_ZERO) _currentZero; //! Current zero from settings.\n\tTYPIFY(CONFIG_POWER_ZERO) _powerZero; //! Power zero from settings.\n\n\tuint16_t _avgZeroCurrentDiscount;\n\tuint16_t _avgZeroVoltageDiscount;\n\tuint16_t _avgPowerDiscount;\n\n\t// Slow averaging of power\n\tfloat _slowAvgPowerDiscount;\n\tfloat _slowAvgPowerMilliWatt = 0.0f;\n\tuint16_t _slowAvgPowerCount; // Number of values that have been used for slow averaging.\n\tconst uint16_t slowAvgPowerConvergedCount = 1000;\n\tfloat _powerDiffThresholdPart;  // When difference is 10% larger or smaller, consider it a significant change.\n\tfloat _powerDiffThresholdMinMilliWatt; // But the difference must also be at least so many Watts.\n\tfloat _negativePowerThresholdMilliWatt; // Only if power is below threshold, it may be negative.\n\n\n\tint32_t _boardPowerZero; //! Measured power when there is no load for this board (mW).\n\tint32_t _avgZeroVoltage; //! Used for storing and calculating the average zero voltage value (times 1024).\n\tint32_t _avgZeroCurrent; //! Used for storing and calculating the average zero current value (times 1024).\n\tbool _recalibrateZeroVoltage; //! Whether or not the zero voltage value should be recalculated.\n\tbool _recalibrateZeroCurrent; //! Whether or not the zero current value should be recalculated.\n//\tbool _zeroVoltageInitialized; //! True when zero of voltage has been initialized.\n//\tbool _zeroCurrentInitialized; //! True when zero of current has been initialized.\n\tuint16_t _zeroVoltageCount; //! Number of times the zero voltage has been calculated.\n\tuint16_t _zeroCurrentCount; //! Number of times the zero current has been calculated.\n\n\tint32_t _avgPowerMilliWatt; //! Used to send out the average power (in mW).\n\tint32_t _avgCurrentRmsMilliAmp; //! Used for storing the average rms current (in mA).\n\tint32_t _avgVoltageRmsMilliVolt; //! Used for storing the average rms voltage (in mV).\n\n\tPowerVector* _inputSamples;  //! Used for storing the samples to be filtered.\n\tPowerVector* _outputSamples; //! Used for storing the filtered samples.\n\tMedianFilter* _filterParams;  //! Stores the parameters for the moving median filter.\n\n\tCircularBuffer<int32_t>* _powerMilliWattHist;      //! Used to store a history of the power\n\tCircularBuffer<int32_t>* _currentRmsMilliAmpHist;  //! Used to store a history of the current_rms\n\tCircularBuffer<int32_t>* _filteredCurrentRmsHistMA; //! Used to store a history of the filtered current_rms\n\tCircularBuffer<int32_t>* _voltageRmsMilliVoltHist; //! Used to store a history of the voltage_rms\n\tint32_t _histCopy[POWER_SAMPLING_RMS_WINDOW_SIZE]; //! Used to copy a history to (so it can be used to calculate the median)\n\tuint16_t _consecutiveDimmerOvercurrent = 0;\n\tuint16_t _consecutiveOvercurrent = 0;\n\n\n\tTYPIFY(CONFIG_SOFT_FUSE_CURRENT_THRESHOLD) _currentMilliAmpThreshold;    //! Current threshold from settings.\n\tTYPIFY(CONFIG_SOFT_FUSE_CURRENT_THRESHOLD_DIMMER) _currentMilliAmpThresholdDimmer; //! Current threshold when using dimmer from settings.\n\n\tint64_t _energyUsedmicroJoule = 0; //! Energy used in micro joule\n\n\tswitch_state_t _lastSwitchState; //! Stores the last seen switch state.\n\tuint32_t _lastSwitchOffTicks;    //! RTC ticks when the switch was last turned off.\n\tbool _lastSwitchOffTicksValid = false;   //! Keep up whether the last switch off time is valid.\n\tbool _dimmerFailureDetectionStarted = false; //! Keep up whether the IGBT failure detection has started yet.\n\tuint32_t _calibratePowerZeroCountDown = 4000 / TICK_INTERVAL_MS;\n\n\t//! Store the adc config, so that the actual adc config can be changed.\n\tstruct __attribute__((packed)) {\n\t\tuint16_t rangeMilliVolt[2];       //! For both channels\n\t\tuint8_t currentPinGainHigh;       //! Stores the current pin\n\t\tuint8_t currentPinGainMed;        //! Stores the current pin with medium gain\n\t\tuint8_t currentPinGainLow;        //! Stores the current pin with lowest gain\n\t\tuint8_t voltagePin;               //! Stores the voltage pin\n\t\tuint8_t zeroReferencePin;         //! Stores the zero reference pin\n\t\tuint8_t voltageChannelPin;        //! Stores which pin is currently set on the voltage channel.\n\t\tuint8_t voltageChannelUsedAs : 4; //! 0 for voltage, 1 for reference, 2 for VDD, 3 for current1, 4 for current2.\n\t\tbool currentDifferential     : 1; //! True when differential mode is used for current channel (if possible).\n\t\tbool voltageDifferential     : 1; //! True when differential mode is used for voltage channel (if possible).\n\t} _adcConfig;\n\n\tunion {\n\t\tstruct __attribute__((packed)) {\n\t\t\tbool power : 1;\n\t\t\tbool current : 1;\n\t\t\tbool voltage : 1;\n\t\t\tbool filteredCurrent : 1;\n\t\t} flags;\n\t\tuint32_t asInt;\n\t} _logsEnabled;\n\n\tadc_buffer_seq_nr_t _lastBufSeqNr = 0;\n\tadc_buffer_id_t _lastBufIndex = 0;\n\tadc_buffer_id_t _lastFilteredBufIndex = 0;\n\n\tcs_adc_restarts_t _adcRestarts;\n\tcs_adc_channel_swaps_t _adcChannelSwaps;\n\n\n\t/** Initialize the moving averages\n\t */\n\tvoid initAverages();\n\n\t/**\n\t * Whether the given buffer is valid.\n\t *\n\t * This can change at any moment (set in interrupt).\n\t */\n\tbool isValidBuf(adc_buffer_id_t bufIndex);\n\n\t/**\n\t * Whether the given sequence nr follows directly after the previous sequence nr.\n\t *\n\t * This can change at any moment (set in interrupt).\n\t */\n\tbool isConsecutiveBuf(adc_buffer_seq_nr_t seqNr, adc_buffer_seq_nr_t prevSeqNr);\n\n\t/**\n\t * Remove all buffers from queue that are older than the newest invalid buffer.\n\t *\n\t * What remains is a queue of consecutive valid buffers.\n\t */\n\tvoid removeInvalidBufs();\n\n\t/**\n\t * Calculate the value of the zero line of the voltage samples (the offset).\n\t */\n\tvoid calculateVoltageZero(adc_buffer_id_t bufIndex);\n\n\t/** Calculate the value of the zero line of the current samples\n\t */\n\tvoid calculateCurrentZero(adc_buffer_id_t bufIndex);\n\n\t/** Filter the samples\n\t */\n\tvoid filter(adc_buffer_id_t bufIndexIn, adc_buffer_id_t bufIndexOut, adc_channel_id_t channel_id);\n\n\t/**\n\t * Checks if voltage and current index are swapped.\n\t *\n\t * Checks if previous voltage samples look more like this buffer voltage samples or current samples.\n\t * Assumes previous buffer is valid, and of same size as this buffer.\n\t */\n\tbool isVoltageAndCurrentSwapped(adc_buffer_id_t bufIndex, adc_buffer_id_t prevBufIndex);\n\n\t/**\n\t * Calculate the average power usage\n\t *\n\t * @return true when calculation was successful.\n\t */\n\tbool calculatePower(adc_buffer_id_t bufIndex);\n\n\tvoid calculateSlowAveragePower(float powerMilliWatt, float fastAvgPowerMilliWatt);\n\n\t/**\n\t * Determines measured power usage with no load.\n\t *\n\t * When successful, sets the value in state.\n\t *\n\t * Careful: make sure this doesn't interfere with dimmer on failure detection.\n\t */\n\tvoid calibratePowerZero(int32_t powerMilliWatt);\n\n\t/** Calculate the energy used\n\t */\n\tvoid calculateEnergy();\n\n\t/**\n\t * Check if the current goes above a threshold (for long enough).\n\t *\n\t * Emits an event when a softfuse triggers.\n\t * Stores the current buffer of the last buffer that's above threshold, before the softfuse triggered.\n\t *\n\t * @param[in] currentRmsMilliAmp             RMS current in mA of the last AC period.\n\t * @param[in] currentRmsMilliAmpFiltered     Filtered (averaged or so) RMS current in mA.\n\t * @param[in] voltageRmsMilliVolt            RMS voltage in mV of the last AC period.\n\t * @param[in] power                          Struct that holds the buffers.\n\t */\n\tvoid checkSoftfuse(int32_t currentRmsMilliAmp, int32_t currentRmsMilliAmpFiltered, int32_t voltageRmsMilliVolt, adc_buffer_id_t bufIndex);\n\n\tvoid handleGetPowerSamples(PowerSamplesType type, uint8_t index, cs_result_t& result);\n\n\tvoid toggleVoltageChannelInput();\n\n\tvoid enableDifferentialModeCurrent(bool enable);\n\n\tvoid enableDifferentialModeVoltage(bool enable);\n\n\tvoid changeRange(uint8_t channel, int32_t amount);\n\n\tvoid enableSwitchcraft(bool enable);\n\n\tvoid printBuf(adc_buffer_id_t bufIndex);\n};\n\n\n", "comment_ratio": 0.19078947368421054}
{"lang": "c", "code": "#import <Cocoa/Cocoa.h>\n#import \"ZMButton.h\"\n#import \"ZMTextField.h\"\n\ntypedef enum : NSUInteger {\n    ZMButtonStyleRoundFillBlue,\n    ZMButtonStyleRoundFillRed,\n    ZMButtonStyleRoundBorderHoverBlue,\n    ZMButtonStyleRoundNoBorer,\n} ZMButtonStyle;\n\n@interface NSTextField (Create)\n\n\n/**\n create TextField\n\n @return NSTextField instance and need release\n */\n+ (instancetype)createTextField;\n\n@end\n\n@interface ZMTextField(Create)\n\n+ (instancetype)createActiveBuleInputTextField;\n\n@end\n\n\n@interface ZMButton (Create)\n\n\n/**\n create button by ZMButtonStyle ,this style is from design : < https://www.figma.com/file/QuGWPtIB5YPfh4hzUHr8Occ4/\ud83c\udf0e-All-Components?node-id=8%3A4831 >\n \n @param style\n @return ZMButton instance and need release\n */\n+ (instancetype)createButtonByStyle:(ZMButtonStyle)style;\n\n\n/**\n create button by ZMButtonStyleRoundBorderHoverBlue style and\n title is \"cancle\",\n keyEquivalent is esc,\n\n @return ZMButton instance\n */\n+ (instancetype)createCancelButton;\n\n\n/**\n create button by ZMButtonStyleRoundFillBlue style and\n keyEquivalent is enter,\n \n @return ZMButton instance\n */\n+ (instancetype)createComfirmButton;\n\n\n/**\n create button by ZMButtonStyleRoundFillBlue style \n \n @return ZMButton instance\n */\n+ (instancetype)createBorderFillBlueButton;\n\n@end\n\n", "comment_ratio": 0.10256410256410256}
{"lang": "c", "code": "#ifndef BITCOIN_CHAINPARAMSSEEDS_H\n#define BITCOIN_CHAINPARAMSSEEDS_H\n/**\n * List of fixed seed nodes for the bitcoin network\n * AUTOGENERATED by contrib/seeds/generate-seeds.py\n *\n * Each line contains a 16-byte IPv6 address and a port.\n * IPv4 as well as onion addresses are wrapped inside a IPv6 address accordingly.\n */\nstatic SeedSpec6 pnSeed6_main[] = {\n    //{{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0x05,0x84,0x9f,0xb5}, 36801},\n\n};\n\nstatic SeedSpec6 pnSeed6_test[] = {\n};\n#endif // BITCOIN_CHAINPARAMSSEEDS_H\n\n", "comment_ratio": 0.1111111111111111}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n#import \"Parse.h\"\n\n@interface ProfileViewController : UIViewController <UITableViewDelegate, UITableViewDataSource, UIImagePickerControllerDelegate, UINavigationControllerDelegate, UIScrollViewDelegate>\n\n- (IBAction)didTapProfile:(id)sender;\n- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary<NSString *,id> *)info;\n- (void)fetchPosts;\n- (PFFile *)getPFFileFromImage: (UIImage * _Nullable)image;\n\n@end\n\n", "comment_ratio": 0.35}
{"lang": "c", "code": "#ifndef Fennel_CircularSegment_Included\n#define Fennel_CircularSegment_Included\n\n#include \"fennel/segment/DelegatingSegment.h\"\n\nFENNEL_BEGIN_NAMESPACE\n\n/**\n * CircularSegment implements circular page allocation in terms of an\n * underlying LINEAR_ALLOCATION segment.  See <a\n * href=\"structSegmentDesign.html#CircularSegment\">the design docs</a> for more\n * detail.\n *\n *<p>\n *\n * Deallocation of individual pages is not supported; however, the caller may\n * deallocate runs of oldest pages by calling deallocatePageRange with\n * NULL_PAGE_ID for startPageId; all pages up to and including the specified\n * endPageId will be deallocated.  This must be done periodically to prevent\n * the allocation point from wrapping around to the oldest allocated page, or\n * an assertion violation results.\n */\nclass FENNEL_SEGMENT_EXPORT CircularSegment\n    : public DelegatingSegment\n{\n    friend class SegmentFactory;\n\n    SharedCheckpointProvider pCheckpointProvider;\n\n    BlockNum oldestPageNum;\n\n    // TODO:  change design doc diagram from newestPageId to nextPageId\n    BlockNum nextPageNum;\n\n    BlockNum nPages;\n\n    BlockNum checkpointThreshold1, checkpointThreshold2;\n\n    explicit CircularSegment(\n        SharedSegment delegateSegment,\n        SharedCheckpointProvider pCheckpointProvider,\n        PageId oldestPageId,\n        PageId newestPageId);\n\npublic:\n    virtual ~CircularSegment();\n\n    // implement the Segment interface\n    virtual BlockNum getAllocatedSizeInPages();\n    virtual BlockId translatePageId(PageId);\n    virtual PageId translateBlockId(BlockId);\n    virtual PageId allocatePageId(PageOwnerId ownerId = ANON_PAGE_OWNER_ID);\n    virtual void deallocatePageRange(PageId startPageId, PageId endPageId);\n    virtual bool isPageIdAllocated(PageId pageId);\n    virtual AllocationOrder getAllocationOrder() const;\n    virtual PageId getPageSuccessor(PageId pageId);\n    virtual void setPageSuccessor(PageId pageId, PageId successorId);\n};\n\nFENNEL_END_NAMESPACE\n\n#endif\n\n// End CircularSegment.h\n\n", "comment_ratio": 0.20238095238095238}
{"lang": "c", "code": "#ifndef OMAFMPDPARSER_H\n#define OMAFMPDPARSER_H\n\n#include \"OmafDashParser/OmafXMLParser.h\"\n#include \"OmafMediaStream.h\"\n#include \"general.h\"\n\n#include <mutex>\n\nusing namespace VCD::OMAF;\nusing namespace VCD::VRVideo;\n\nVCD_OMAF_BEGIN\n\ntypedef enum {\n  MPD_NONE = 0,\n  MPD_STATIC,\n  MPD_DYNAMIC,\n} MPD_TYPE;\n\ntypedef std::vector<AdaptationSetElement*> ADAPTATIONSETS;\ntypedef std::vector<OmafMediaStream*> OMAFSTREAMS;\ntypedef std::vector<OmafAdaptationSet*> OMAFADAPTATIONSETS;\ntypedef std::map<std::string, OMAFADAPTATIONSETS> TYPE_OMAFADAPTATIONSETS;\n\n//!\n//! \\class:   OmafMPDParser\n//! \\brief:   the parser for MPD file using libdash\n//!\nclass OmafMPDParser {\n public:\n  //!\n  //! \\brief  construct\n  //!\n  OmafMPDParser();\n\n  //!\n  //! \\brief  de-construct\n  //!\n  virtual ~OmafMPDParser();\n\n public:\n  //!\n  //! \\brief  parse MPD and get construct media streams\n  //!\n  int ParseMPD(std::string mpd_file, OMAFSTREAMS& listStream);\n\n  //!\n  //! \\brief  update MPD and get construct media streams for live if needed.\n  //!\n  int UpdateMPD(OMAFSTREAMS& listStream);\n\n  //!\n  //! \\brief  Get MPD information.\n  //!\n  MPDInfo* GetMPDInfo();\n\n  //!\n  //! \\brief  Set cache dir.\n  //!\n  void SetCacheDir(string cache_dir) { mCacheDir = cache_dir; };\n\n  void SetExtractorEnabled(bool isExtractorEnabled) { mExtractorEnabled = isExtractorEnabled; };\n\n  bool GetExtractorEnabled() { return mExtractorEnabled; };\n  void SetOmafDashParams(const OmafDashParams& params) { omaf_dash_params_ = params; }\n  ProjectionFormat GetProjectionFmt() { return mPF; };\n\n private:\n  //!\n  //! \\brief construct media streams.\n  //!\n  int ParseStreams(OMAFSTREAMS& listStream);\n\n  //!\n  //! \\brief Parse MPD information\n  //!\n  int ParseMPDInfo();\n\n  //!\n  //! \\brief group all adaptationSet based on the dependency.\n  //!\n  int GroupAdaptationSet(PeriodElement* pPeriod, TYPE_OMAFADAPTATIONSETS& mapAdaptationSets);\n\n  //!\n  //! \\brief build up OmafMediaStreams based on the grouped AdaptationSets.\n  //!\n  int BuildStreams(TYPE_OMAFADAPTATIONSETS mapAdaptationSets, OMAFSTREAMS& listStream);\n\n  //!\n  //! \\brief Create OmafAdaptationSet based on libDash AdaptationSetElement.\n  //! \\param [in] pAS AdaptationSetElement\n  //! \\return\n  //!\n  OmafAdaptationSet* CreateAdaptationSet(AdaptationSetElement* pAS, ProjectionFormat pf);\n\n  //!\n  //! \\brief Judge the type of the AdaptationSet.\n  //!\n  bool ExtractorJudgement(AdaptationSetElement* pAS);\n\nprivate:\n    OmafMPDParser& operator=(const OmafMPDParser& other) { return *this; };\n    OmafMPDParser(const OmafMPDParser& other) { /* do not create copies */ };\n\n private:\n  OmafXMLParser* mParser = nullptr;\n  MPDElement* mMpd = nullptr;  //!< the PTR for libdash MPD\n  std::string mMPDURL;         //!< url of MPD\n  // ThreadLock*                    mLock;\n  std::mutex mLock;\n  MPDInfo* mMPDInfo;  //!< the information of MPD\n  std::vector<BaseUrlElement*> mBaseUrls;\n  ProjectionFormat mPF;            //!< the projection format of the video content\n  std::string mCacheDir;           //!< cache directory\n  bool mExtractorEnabled = false;  //!< if extractor track is enabled\n  OmafDashParams omaf_dash_params_;\n  OmafAdaptationSet *mTmpAS;\n  OmafMediaStream* mTmpStream;\n};\n\nVCD_OMAF_END;\n\n#endif /* MPDPARSER_H */\n\n", "comment_ratio": 0.34591194968553457}
{"lang": "c", "code": "#ifndef D3DHANDLER_H\n#define D3DHANDLER_H\n\n//external\n#include <windows.h>\n#include <windowsx.h>\n#include <d3d10.h>\n#include <d3dx10.h>\n#include <vector>\n\n// include the Direct3D Library file\n#pragma comment (lib, \"d3d10.lib\")\n#pragma comment (lib, \"d3dx10.lib\")\n\n//stuph\n#include \"Timer.h\"\n#include \"InputHandler.h\"\n#include \"cBuffers.h\"\n#include \"Camera.h\"\n#include \"Light.h\"\n\n//objects\n#include \"D3DObject.h\"\n#include \"Triangle.h\"\n#include \"Hypercraft.h\"\n#include \"Cube.h\"\n#include \"HeightMap.h\"\n#include \"ObjObject.h\"\n#include \"Group.h\"\n\n//particles\n#include \"PaprikaFlame.h\"\n#include \"WaterFountain.h\"\n#include \"SuperNova.h\"\n\n#include\"Node.h\"\n\nusing namespace std;\n\nclass D3DHandler\n{\nprivate:\n\t//window settings\n\tint wndWidth;\n\tint wndHeight;\n\tHINSTANCE hInstance;\n\tHWND hWnd;\n\n\t//Direct3D\n\tID3D10Device* device;\n\tID3D10RenderTargetView* rtv;\n\tID3D10DepthStencilView* dsv;    //depth stencil view - z/depth buffer\n\tIDXGISwapChain* swapchain; \n\n\t//stuph\n\tTimer timer;\n\tInputHandler* input;\n\tCamera* camera;\n\tCamera* camera2; //for frustum culling debug\n\tvector<Light> lights;\n\tNode* node;\n\n\t//CBuffer, isn't used\n\t//ID3D10Buffer *cBuffer;\n\n\t//Effect (.fx)\n\tID3D10Effect* effect;\n\n\t//FX-vars\n\tID3D10EffectVariable* lightVariable;\n\t\n\t//rasterizer states\n\tID3D10RasterizerState *rastStateDefault;\t\t// the default rasterizer state\n\tID3D10RasterizerState *rastStateWireframe;\t\t//Debug rasterizer\n\n\t//stuff to render\n\tHeightMap* world;\n\tvector<D3DObject*> objects;\n\tvector<Group*> groups;\n\tvector<ParticleSystem*> particleSystems;\n\n\t//Debug\n\tDWORD shaderFlags;\n\tHRESULT hr;\n\n\t//internal functions\n\tvoid initWindow();\n\tvoid initD3D();\n\tvoid initEffect();\n\tvoid initFXvars();\n\tvoid initStates();\n\n\tvoid initLights();\n\tvoid initObjects();\n\tvoid initParticles();\n\npublic:\n\tD3DHandler(HINSTANCE _hInstance);\n\t~D3DHandler();\n\tvoid init();\n\n\tint run();\n\tvoid update(float _dt);\n\tvoid draw();\n\tvoid resize();\n\n\t//LRESULT CALLBACK msgProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);\n\t//LRESULT msgProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);\n};\n\n#endif //D3DHANDLER_H\n", "comment_ratio": 0.2072072072072072}
{"lang": "c", "code": "#include \"kktypes.h\"\n#include \"sysdefs.h\"\n#include \"keyh.h\"\n#include \"sparc_mem.h\"\n#include \"memomdh.h\"\n#include \"wsh.h\"\n// #include \"iommu.h\"\n#include \"realkermap.h\"\n#include \"sparc_asm.h\"\n\nME *WindowPageTable = 0;\n/* The above is the kernel's virtual address for a portion\nof a page table which is modified as the kernel runs,\nto provide the kernel with access to varying locations, \noften in some domain's address space.\nThere are TOTAL_MAPWIN_SIZE windows for the kernel to use.\nThey cost very little. They tend to be allocated one per\nkernel function needing such access. There is little economy\nin sharing them. */\n// There was interesting code here but it has been largely supplanted\n// by the micro_loader.s stuff.\n\nuchar * map_any_window(int window, uint32 busaddr, int rw)\n{ if((uint32)window >= TOTAL_MAPWIN_SIZE) crash(\"Invalid kernel window\");\n  WindowPageTable[window] = (busaddr >> 4) | (rw ? 0x7E : 0x7A);\n//  WindowPageTable[window] = (busaddr >> 4) | (rw ? 0xFE : 0xFA);\n  {uchar * vw = vWindows + (window<<12);\n  sta03((int)vw, 0); return vw;}}\n\n\nuchar * map_uncached_window(int window, uint32 busaddr36, int rw)\n{ if((uint32)window >= TOTAL_MAPWIN_SIZE) crash(\"Invalid kernel window\");\n  WindowPageTable[window] = busaddr36 | (rw ? 0x7E : 0x7A);\n  {uchar * vw = vWindows + (window<<12);\n  sta03((int)vw, 0); return vw;}}\n\n", "comment_ratio": 0.15384615384615385}
{"lang": "c", "code": "#ifndef TOOLS_GN_POOL_H_\n#define TOOLS_GN_POOL_H_\n\n#include <string>\n\n#include \"tools/gn/item.h\"\n\n// Represents a named pool in the dependency graph.\n//\n// A pool is used to limit the parallelism of task invocation in the\n// generated ninja build. Pools are referenced by toolchains.\nclass Pool : public Item {\n public:\n  using Item::Item;\n  ~Pool() override;\n\n  Pool(const Pool&) = delete;\n  Pool& operator=(const Pool&) = delete;\n\n  // Item implementation.\n  Pool* AsPool() override;\n  const Pool* AsPool() const override;\n\n  // The pool depth (number of task to run simultaneously).\n  int64_t depth() const { return depth_; }\n  void set_depth(int64_t depth) { depth_ = depth; }\n\n  // The pool name in generated ninja files.\n  std::string GetNinjaName(const Label& default_toolchain) const;\n\n private:\n  std::string GetNinjaName(bool include_toolchain) const;\n\n  int64_t depth_ = 0;\n};\n\n#endif  // TOOLS_GN_POOL_H_\n\n", "comment_ratio": 0.2619047619047619}
{"lang": "c", "code": "@interface DRSDampeningEnforcementSettings : NSObject {\n\n\tBOOL _enforcesResourceHysteresis;\n\tBOOL _enforcesResourceCap;\n\tBOOL _enforcesResourceDownsampling;\n\tBOOL _enforcesSignatureHysteresis;\n\tBOOL _enforcesSignatureCap;\n\tBOOL _enforcesSignatureDownsampling;\n\tBOOL _enforcesTotalCap;\n\n}\n\n@property (assign,nonatomic) BOOL enforcesResourceHysteresis;                 //@synthesize enforcesResourceHysteresis=_enforcesResourceHysteresis - In the implementation block\n@property (assign,nonatomic) BOOL enforcesResourceCap;                        //@synthesize enforcesResourceCap=_enforcesResourceCap - In the implementation block\n@property (assign,nonatomic) BOOL enforcesResourceDownsampling;               //@synthesize enforcesResourceDownsampling=_enforcesResourceDownsampling - In the implementation block\n@property (assign,nonatomic) BOOL enforcesSignatureHysteresis;                //@synthesize enforcesSignatureHysteresis=_enforcesSignatureHysteresis - In the implementation block\n@property (assign,nonatomic) BOOL enforcesSignatureCap;                       //@synthesize enforcesSignatureCap=_enforcesSignatureCap - In the implementation block\n@property (assign,nonatomic) BOOL enforcesSignatureDownsampling;              //@synthesize enforcesSignatureDownsampling=_enforcesSignatureDownsampling - In the implementation block\n@property (assign,nonatomic) BOOL enforcesTotalCap;                           //@synthesize enforcesTotalCap=_enforcesTotalCap - In the implementation block\n-(id)debugDescription;\n-(id)init;\n-(BOOL)isEqual:(id)arg1 ;\n-(void)setAllEnforcement:(BOOL)arg1 ;\n-(void)setEnforcesResourceHysteresis:(BOOL)arg1 ;\n-(void)setEnforcesResourceCap:(BOOL)arg1 ;\n-(void)setEnforcesResourceDownsampling:(BOOL)arg1 ;\n-(void)setEnforcesSignatureHysteresis:(BOOL)arg1 ;\n-(void)setEnforcesSignatureCap:(BOOL)arg1 ;\n-(void)setEnforcesSignatureDownsampling:(BOOL)arg1 ;\n-(void)setEnforcesTotalCap:(BOOL)arg1 ;\n-(id)initWithMO:(id)arg1 ;\n-(BOOL)enforcesResourceHysteresis;\n-(BOOL)enforcesResourceCap;\n-(BOOL)enforcesResourceDownsampling;\n-(BOOL)enforcesSignatureHysteresis;\n-(BOOL)enforcesSignatureCap;\n-(BOOL)enforcesSignatureDownsampling;\n-(BOOL)enforcesTotalCap;\n-(id)jsonCompatibleDictRepresentation;\n-(id)_moRepresentation:(id)arg1 ;\n@end\n\n\n", "comment_ratio": 0.1346153846153846}
{"lang": "c", "code": "/* IBM_PROLOG_BEGIN_TAG                                                   */\n/* This is an automatically generated prolog.                             */\n/*                                                                        */\n/* $Source: import/chips/p9/procedures/ppe/iota/ppe42.h $                 */\n/*                                                                        */\n/* OpenPOWER HCODE Project                                                */\n/*                                                                        */\n/* COPYRIGHT 2017                                                         */\n/* [+] International Business Machines Corp.                              */\n/*                                                                        */\n/*                                                                        */\n/* Licensed under the Apache License, Version 2.0 (the \"License\");        */\n/* you may not use this file except in compliance with the License.       */\n/* You may obtain a copy of the License at                                */\n/*                                                                        */\n/*     http://www.apache.org/licenses/LICENSE-2.0                         */\n/*                                                                        */\n/* Unless required by applicable law or agreed to in writing, software    */\n/* distributed under the License is distributed on an \"AS IS\" BASIS,      */\n/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        */\n/* implied. See the License for the specific language governing           */\n/* permissions and limitations under the License.                         */\n/*                                                                        */\n/* IBM_PROLOG_END_TAG                                                     */\n#ifndef __PPE42_H__\n#define __PPE42_H__\n\n// pk/ppe42/ppe42.h is polluted with pk dependencies.\n// This file is to override that in IOTA\n// GOAL Make ppe42 kernel independent\n#include \"iota_ppe42.h\"\n\n#endif\n\n", "comment_ratio": 0.11764705882352941}
{"lang": "c", "code": "#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Modules/ModuleInterface.h\"\n\n//////////////////////////////////////////////////////////////////////////\n// IStructBoxModuleInterface\n\nclass IStructBoxModuleInterface : public IModuleInterface\n{\n};\n\n", "comment_ratio": 0.21428571428571427}
{"lang": "c", "code": "\ufeff#pragma once\n\n#include \"il2cpp-config.h\"\n\n#ifndef _MSC_VER\n# include <alloca.h>\n#else\n# include <malloc.h>\n#endif\n\n#include <stdint.h>\n#include <assert.h>\n#include <exception>\n\n// UnityEngine.Events.UnityEvent\nstruct UnityEvent_t1266085011;\n// UnityEngine.Events.UnityAction\nstruct UnityAction_t594794173;\n// System.Reflection.MethodInfo\nstruct MethodInfo_t;\n// System.String\nstruct String_t;\n// System.Object\nstruct Il2CppObject;\n// UnityEngine.Events.BaseInvokableCall\nstruct BaseInvokableCall_t1559630662;\n\n#include \"codegen/il2cpp-codegen.h\"\n#include \"UnityEngine_UnityEngine_Events_UnityAction594794173.h\"\n#include \"mscorlib_System_String7231557.h\"\n#include \"mscorlib_System_Object4170816371.h\"\n#include \"mscorlib_System_Reflection_MethodInfo318736065.h\"\n\n// System.Void UnityEngine.Events.UnityEvent::.ctor()\nextern \"C\"  void UnityEvent__ctor_m1715209183 (UnityEvent_t1266085011 * __this, const MethodInfo* method) IL2CPP_METHOD_ATTR;\n// System.Void UnityEngine.Events.UnityEvent::AddListener(UnityEngine.Events.UnityAction)\nextern \"C\"  void UnityEvent_AddListener_m4099140869 (UnityEvent_t1266085011 * __this, UnityAction_t594794173 * ___call0, const MethodInfo* method) IL2CPP_METHOD_ATTR;\n// System.Reflection.MethodInfo UnityEngine.Events.UnityEvent::FindMethod_Impl(System.String,System.Object)\nextern \"C\"  MethodInfo_t * UnityEvent_FindMethod_Impl_m2897220818 (UnityEvent_t1266085011 * __this, String_t* ___name0, Il2CppObject * ___targetObj1, const MethodInfo* method) IL2CPP_METHOD_ATTR;\n// UnityEngine.Events.BaseInvokableCall UnityEngine.Events.UnityEvent::GetDelegate(System.Object,System.Reflection.MethodInfo)\nextern \"C\"  BaseInvokableCall_t1559630662 * UnityEvent_GetDelegate_m2043983920 (UnityEvent_t1266085011 * __this, Il2CppObject * ___target0, MethodInfo_t * ___theFunction1, const MethodInfo* method) IL2CPP_METHOD_ATTR;\n// UnityEngine.Events.BaseInvokableCall UnityEngine.Events.UnityEvent::GetDelegate(UnityEngine.Events.UnityAction)\nextern \"C\"  BaseInvokableCall_t1559630662 * UnityEvent_GetDelegate_m1012258596 (Il2CppObject * __this /* static, unused */, UnityAction_t594794173 * ___action0, const MethodInfo* method) IL2CPP_METHOD_ATTR;\n// System.Void UnityEngine.Events.UnityEvent::Invoke()\nextern \"C\"  void UnityEvent_Invoke_m2672830205 (UnityEvent_t1266085011 * __this, const MethodInfo* method) IL2CPP_METHOD_ATTR;\n\n", "comment_ratio": 0.2608695652173913}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n\n@interface BankCardSearch : NSObject\n\n/**\n *  \u67e5\u8be2\u662f\u54ea\u4e2a\u94f6\u884c\n *\n *  @param numbers \u83b7\u53d6\u7684numbers\n *  @param nCount  \u6570\u7ec4\u4e2a\u6570\n *\n *  @return \u6240\u5c5e\u94f6\u884c\n */\n+ (NSString *)getBankNameByBin:(char *)numbers count:(int)nCount;\n\n@end\n\n", "comment_ratio": 0.2916666666666667}
{"lang": "c", "code": "//\n//  LRUCache.h\n//  Pods\n//\n//  Created by Prabodh Prakash on 01/09/15.\n//\n//\n\n#import <Foundation/Foundation.h>\n#import \"Node.h\"\n#import \"CachingDatabaseHandler.h\"\n#import \"CachingDiskHandler.h\"\n#import \"BaseCache.h\"\n\n/*!\n This class provides standard implementation of LRU Cache.\n */\n@interface LRUCache : BaseCache\n\n/*!\n The maximum number of elements that can be stored in memory.\n */\n@property (nonatomic, assign) NSInteger maxElementsInMemory;\n\n/*!\n The maximum memory that can be used to store elements\n */\n@property (nonatomic, assign) float maxMemoryAllocated;\n\n@end\n\n", "comment_ratio": 0.22580645161290322}
{"lang": "c", "code": "#ifndef SERIALIZE_SETUP_H\n#define SERIALIZE_SETUP_H\n\nclass CommonExampleInterface*    SerializeBulletCreateFunc(struct PhysicsInterface* pint, struct GUIHelperInterface* helper, int option);\n\n\n#endif //SERIALIZE_SETUP_H\n\n", "comment_ratio": 0.125}
{"lang": "c", "code": "#ifndef CORE_FXGE_CFX_GLYPHBITMAP_H_\n#define CORE_FXGE_CFX_GLYPHBITMAP_H_\n\n#include <vector>\n\n#include \"core/fxcrt/retain_ptr.h\"\n\nclass CFX_DIBitmap;\n\nclass CFX_GlyphBitmap {\n public:\n  CFX_GlyphBitmap(int left, int top);\n  ~CFX_GlyphBitmap();\n\n  CFX_GlyphBitmap(const CFX_GlyphBitmap&) = delete;\n  CFX_GlyphBitmap& operator=(const CFX_GlyphBitmap&) = delete;\n\n  const RetainPtr<CFX_DIBitmap>& GetBitmap() const { return m_pBitmap; }\n  int left() const { return m_Left; }\n  int top() const { return m_Top; }\n\n private:\n  const int m_Left;\n  const int m_Top;\n  RetainPtr<CFX_DIBitmap> m_pBitmap;\n};\n\n#endif  // CORE_FXGE_CFX_GLYPHBITMAP_H_\n\n", "comment_ratio": 0.14285714285714285}
{"lang": "c", "code": "#ifdef FEATURE_PERFTRACING_STANDALONE_PAL\n#define EP_NO_RT_DEPENDENCY\n#endif\n\n#include \"ds-rt-config.h\"\n\n#ifdef ENABLE_PERFTRACING\n#ifdef HOST_WIN32\n\n#define DS_IMPL_IPC_PAL_NAMEDPIPE_GETTER_SETTER\n#include \"ds-ipc-pal-namedpipe.h\"\n\n#include <assert.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#ifndef FEATURE_PERFTRACING_STANDALONE_PAL\n#include \"ds-rt.h\"\n#else\n#ifndef ep_raise_error_if_nok\n#define ep_raise_error_if_nok(expr) do { if (!(expr)) goto ep_on_error; } while (0)\n#endif\n\n#ifndef ep_raise_error\n#define ep_raise_error() do { goto ep_on_error; } while (0)\n#endif\n\n#ifndef ep_exit_error_handler\n#define ep_exit_error_handler() do { goto ep_on_exit; } while (0)\n#endif\n\n#ifndef EP_ASSERT\n#define EP_ASSERT assert\n#endif\n\n#ifndef DS_ENTER_BLOCKING_PAL_SECTION\n#define DS_ENTER_BLOCKING_PAL_SECTION\n#endif\n\n#ifndef DS_EXIT_BLOCKING_PAL_SECTION\n#define DS_EXIT_BLOCKING_PAL_SECTION\n#endif\n\n#undef ep_rt_object_alloc\n#define ep_rt_object_alloc(obj_type) ((obj_type *)calloc(1, sizeof(obj_type)))\n\nstatic\ninline\nvoid\nep_rt_object_free (void *ptr)\n{\n\tif (ptr)\n\t\tfree (ptr);\n}\n#endif /* !FEATURE_PERFTRACING_STANDALONE_PAL */\n\n/*\n * Forward declares of all static functions.\n */\n\nstatic\nvoid\nipc_stream_free_func (void *object);\n\nstatic\nbool\nipc_stream_read_func (\n\tvoid *object,\n\tuint8_t *buffer,\n\tuint32_t bytes_to_read,\n\tuint32_t *bytes_read,\n\tuint32_t timeout_ms);\n\nstatic\nbool\nipc_stream_write_func (\n\tvoid *object,\n\tconst uint8_t *buffer,\n\tuint32_t bytes_to_write,\n\tuint32_t *bytes_written,\n\tuint32_t timeout_ms);\n\nstatic\nbool\nipc_stream_flush_func (void *object);\n\nstatic\nbool\nipc_stream_close_func (void *object);\n\nstatic\nDiagnosticsIpcStream *\nipc_stream_alloc (\n\tHANDLE pipe,\n\tDiagnosticsIpcConnectionMode mode);\n\n/*\n * DiagnosticsIpc.\n */\n\nbool\nds_ipc_pal_init (void)\n{\n\treturn true;\n}\n\nbool\nds_ipc_pal_shutdown (void)\n{\n\treturn true;\n}\n\nDiagnosticsIpc *\nds_ipc_alloc (\n\tconst ep_char8_t *ipc_name,\n\tDiagnosticsIpcConnectionMode mode,\n\tds_ipc_error_callback_func callback)\n{\n\tint32_t characters_written = -1;\n\n\tDiagnosticsIpc *instance = ep_rt_object_alloc (DiagnosticsIpc);\n\tep_raise_error_if_nok (instance != NULL);\n\n\tinstance->mode = mode;\n\tinstance->is_listening = false;\n\n\t// All memory zeroed on alloc.\n\t//memset (&instance->overlap, 0, sizeof (instance->overlap));\n\n\tinstance->overlap.hEvent = INVALID_HANDLE_VALUE;\n\tinstance->pipe = INVALID_HANDLE_VALUE;\n\n\tif (ipc_name) {\n\t\tcharacters_written = sprintf_s (\n\t\t\t(char *)&instance->pipe_name,\n\t\t\t(size_t)DS_IPC_WIN32_MAX_NAMED_PIPE_LEN,\n\t\t\t(const char *)\"\\\\\\\\.\\\\pipe\\\\%s\",\n\t\t\tipc_name);\n\t} else {\n\t\tcharacters_written = sprintf_s (\n\t\t\t(char *)&instance->pipe_name,\n\t\t\t(size_t)DS_IPC_WIN32_MAX_NAMED_PIPE_LEN,\n\t\t\t(const char *)\"\\\\\\\\.\\\\pipe\\\\dotnet-diagnostic-%d\",\n\t\t\tGetCurrentProcessId ());\n\t}\n\n\tif (characters_written <= 0 || characters_written >= DS_IPC_WIN32_MAX_NAMED_PIPE_LEN) {\n\t\tif (callback)\n\t\t\tcallback (\"Failed to generate the named pipe name\", characters_written);\n\t\tep_raise_error ();\n\t}\n\nep_on_exit:\n\treturn instance;\n\nep_on_error:\n\tds_ipc_free (instance);\n\tinstance = NULL;\n\tep_exit_error_handler ();\n}\n\nvoid\nds_ipc_free (DiagnosticsIpc *ipc)\n{\n\tif (!ipc)\n\t\treturn;\n\n\tds_ipc_close (ipc, false, NULL);\n\tep_rt_object_free (ipc);\n}\n\nint32_t\nds_ipc_poll (\n\tDiagnosticsIpcPollHandle *poll_handles_data,\n\tsize_t poll_handles_data_len,\n\tuint32_t timeout_ms,\n\tds_ipc_error_callback_func callback)\n{\n\tEP_ASSERT (poll_handles_data != NULL);\n\n\tint32_t result = 1;\n\tEP_ASSERT (poll_handles_data_len <= MAXIMUM_WAIT_OBJECTS);\n\n\tHANDLE handles [MAXIMUM_WAIT_OBJECTS];\n\tfor (size_t i = 0; i < poll_handles_data_len; ++i) {\n\t\tpoll_handles_data [i].events = 0; // ignore any input on events.\n\t\tif (poll_handles_data [i].ipc) {\n\t\t\t// SERVER\n\t\t\tEP_ASSERT (poll_handles_data [i].ipc->mode == DS_IPC_CONNECTION_MODE_LISTEN);\n\t\t\thandles [i] = poll_handles_data [i].ipc->overlap.hEvent;\n\t\t} else {\n\t\t\t// CLIENT\n\t\t\tbool success = true;\n\t\t\tDWORD bytes_read = 1;\n\t\t\tif (!poll_handles_data [i].stream->is_test_reading) {\n\t\t\t\t// check for data by doing an asynchronous 0 byte read.\n\t\t\t\t// This will signal if the pipe closes (hangup) or the server\n\t\t\t\t// sends new data\n\t\t\t\tsuccess = ReadFile (\n\t\t\t\t\tpoll_handles_data [i].stream->pipe,                                   // handle\n\t\t\t\t\tNULL,                                                                 // null buffer\n\t\t\t\t\t0,                                                                    // read 0 bytesd\n\t\t\t\t\t&bytes_read,                                                          // dummy variable\n\t\t\t\t\t&poll_handles_data [i].stream->overlap);    // overlap object to use\n\n\t\t\t\tpoll_handles_data [i].stream->is_test_reading = true;\n\t\t\t\tif (!success) {\n\t\t\t\t\tDWORD error = GetLastError ();\n\t\t\t\t\tswitch (error) {\n\t\t\t\t\tcase ERROR_IO_PENDING:\n\t\t\t\t\t\thandles [i] = poll_handles_data [i].stream->overlap.hEvent;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ERROR_PIPE_NOT_CONNECTED:\n\t\t\t\t\t\tpoll_handles_data [i].events = (uint8_t)DS_IPC_POLL_EVENTS_HANGUP;\n\t\t\t\t\t\tresult = -1;\n\t\t\t\t\t\tep_raise_error ();\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tif (callback)\n\t\t\t\t\t\t\tcallback (\"0 byte async read on client connection failed\", error);\n\t\t\t\t\t\tresult = -1;\n\t\t\t\t\t\tep_raise_error ();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// there's already data to be read\n\t\t\t\t\thandles [i] = poll_handles_data [i].stream->overlap.hEvent;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\thandles [i] = poll_handles_data [i].stream->overlap.hEvent;\n\t\t\t}\n\t\t}\n\t}\n\n\t// call wait for multiple obj\n\tDWORD wait = WAIT_FAILED;\n\tDS_ENTER_BLOCKING_PAL_SECTION;\n\twait = WaitForMultipleObjects (\n\t\t(DWORD)poll_handles_data_len,      // count\n\t\thandles,                           // handles\n\t\tfalse,                             // don't wait all\n\t\t(DWORD)timeout_ms);\n\tDS_EXIT_BLOCKING_PAL_SECTION;\n\n\tif (wait == WAIT_TIMEOUT) {\n\t\t// we timed out\n\t\tresult = 0;\n\t\tep_raise_error ();\n\t}\n\n\tif (wait == WAIT_FAILED) {\n\t\t// we errored\n\t\tif (callback)\n\t\t\tcallback (\"WaitForMultipleObjects failed\", GetLastError());\n\t\tresult = -1;\n\t\tep_raise_error ();\n\t}\n\n\t// determine which of the streams signaled\n\tDWORD index = wait - WAIT_OBJECT_0;\n\t// error check the index\n\tif (index < 0 || index > (poll_handles_data_len - 1)) {\n\t\t// check if we abandoned something\n\t\tDWORD abandonedIndex = wait - WAIT_ABANDONED_0;\n\t\tif (abandonedIndex > 0 || abandonedIndex < (poll_handles_data_len - 1)) {\n\t\t\tpoll_handles_data [abandonedIndex].events = (uint8_t)DS_IPC_POLL_EVENTS_HANGUP;\n\t\t\tresult = -1;\n\t\t\tep_raise_error ();\n\t\t} else {\n\t\t\tif (callback)\n\t\t\t\tcallback (\"WaitForMultipleObjects failed\", GetLastError());\n\t\t\tresult = -1;\n\t\t\tep_raise_error ();\n\t\t}\n\t}\n\n\t// Set revents depending on what signaled the stream\n\tif (!poll_handles_data [index].ipc) {\n\t\t// CLIENT\n\t\t// check if the connection got hung up\n\t\t// Start with quick none blocking completion check.\n\t\tDWORD dummy = 0;\n\t\tBOOL success = GetOverlappedResult(\n\t\t\tpoll_handles_data [index].stream->pipe,\n\t\t\t&poll_handles_data [index].stream->overlap,\n\t\t\t&dummy,\n\t\t\tfalse);\n\t\tif (!success && GetLastError () == ERROR_IO_INCOMPLETE) {\n\t\t\t// IO still incomplete, wait for completion.\n\t\t\tdummy = 0;\n\t\t\tDS_ENTER_BLOCKING_PAL_SECTION;\n\t\t\tsuccess = GetOverlappedResult(\n\t\t\t\tpoll_handles_data [index].stream->pipe,\n\t\t\t\t&poll_handles_data [index].stream->overlap,\n\t\t\t\t&dummy,\n\t\t\t\ttrue);\n\t\t\tDS_EXIT_BLOCKING_PAL_SECTION;\n\t\t}\n\t\tpoll_handles_data [index].stream->is_test_reading = false;\n\t\tif (!success) {\n\t\t\tDWORD error = GetLastError();\n\t\t\tif (error == ERROR_PIPE_NOT_CONNECTED || error == ERROR_BROKEN_PIPE) {\n\t\t\t\tpoll_handles_data [index].events = (uint8_t)DS_IPC_POLL_EVENTS_HANGUP;\n\t\t\t} else {\n\t\t\t\tif (callback)\n\t\t\t\t\tcallback (\"Client connection error\", error);\n\t\t\t\tpoll_handles_data [index].events = (uint8_t)DS_IPC_POLL_EVENTS_ERR;\n\t\t\t\tresult = -1;\n\t\t\t\tep_raise_error ();\n\t\t\t}\n\t\t} else {\n\t\t\tpoll_handles_data [index].events = (uint8_t)DS_IPC_POLL_EVENTS_SIGNALED;\n\t\t}\n\t} else {\n\t\t// SERVER\n\t\tpoll_handles_data [index].events = (uint8_t)DS_IPC_POLL_EVENTS_SIGNALED;\n\t}\n\n\tresult = 1;\n\nep_on_exit:\n\treturn result;\n\nep_on_error:\n\n\tif (result == 1)\n\t\tresult = -1;\n\n\tep_exit_error_handler ();\n}\n\nbool\nds_ipc_listen (\n\tDiagnosticsIpc *ipc,\n\tds_ipc_error_callback_func callback)\n{\n\tbool result = false;\n\n\tEP_ASSERT (ipc != NULL);\n\tEP_ASSERT (ipc->mode == DS_IPC_CONNECTION_MODE_LISTEN);\n\tif (ipc->mode != DS_IPC_CONNECTION_MODE_LISTEN) {\n\t\tif (callback)\n\t\t\tcallback (\"Cannot call Listen on a client connection\", -1);\n\t\treturn false;\n\t}\n\n\tif (ipc->is_listening)\n\t\treturn true;\n\n\tEP_ASSERT (ipc->pipe == INVALID_HANDLE_VALUE);\n\n\tconst uint32_t in_buffer_size = 16 * 1024;\n\tconst uint32_t out_buffer_size = 16 * 1024;\n\n\tDS_ENTER_BLOCKING_PAL_SECTION;\n\tipc->pipe = CreateNamedPipeA (\n\t\tipc->pipe_name,                                             // pipe name\n\t\tPIPE_ACCESS_DUPLEX |                                        // read/write access\n\t\tFILE_FLAG_OVERLAPPED,                                       // async listening\n\t\tPIPE_TYPE_BYTE | PIPE_WAIT | PIPE_REJECT_REMOTE_CLIENTS,    // message type pipe, message-read and blocking mode\n\t\tPIPE_UNLIMITED_INSTANCES,                                   // max. instances\n\t\tout_buffer_size,                                            // output buffer size\n\t\tin_buffer_size,                                             // input buffer size\n\t\t0,                                                          // default client time-out\n\t\tNULL);                                                      // default security attribute\n\tDS_EXIT_BLOCKING_PAL_SECTION;\n\n\tif (ipc->pipe == INVALID_HANDLE_VALUE) {\n\t\tif (callback)\n\t\t\tcallback (\"Failed to create an instance of a named pipe.\", GetLastError());\n\t\tep_raise_error ();\n\t}\n\n\tEP_ASSERT (ipc->overlap.hEvent == INVALID_HANDLE_VALUE);\n\n\tipc->overlap.hEvent = CreateEventW (NULL, true, false, NULL);\n\tif (!ipc->overlap.hEvent) {\n\t\tif (callback)\n\t\t\tcallback (\"Failed to create overlap event\", GetLastError());\n\t\tep_raise_error ();\n\t}\n\n\tif (ConnectNamedPipe (ipc->pipe, &ipc->overlap) == FALSE) {\n\t\tconst DWORD error_code = GetLastError ();\n\t\tswitch (error_code) {\n\t\tcase ERROR_IO_PENDING:\n\t\t\t// There was a pending connection that can be waited on (will happen in poll)\n\t\tcase ERROR_PIPE_CONNECTED:\n\t\t\t// Occurs when a client connects before the function is called.\n\t\t\t// In this case, there is a connection between client and\n\t\t\t// server, even though the function returned zero.\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tif (callback)\n\t\t\t\tcallback (\"A client process failed to connect.\", error_code);\n\t\t\tep_raise_error ();\n\t\t}\n\t}\n\n\tipc->is_listening = true;\n\tresult = true;\n\nep_on_exit:\n\treturn result;\n\nep_on_error:\n\tds_ipc_close (ipc, false, callback);\n\tresult = false;\n\tep_exit_error_handler ();\n}\n\nDiagnosticsIpcStream *\nds_ipc_accept (\n\tDiagnosticsIpc *ipc,\n\tds_ipc_error_callback_func callback)\n{\n\tEP_ASSERT (ipc != NULL);\n\tEP_ASSERT (ipc->mode == DS_IPC_CONNECTION_MODE_LISTEN);\n\n\tDiagnosticsIpcStream *stream = NULL;\n\n\t// Start with quick none blocking completion check.\n\tDWORD dummy = 0;\n\tBOOL success = GetOverlappedResult (\n\t\tipc->pipe,      // handle\n\t\t&ipc->overlap,  // overlapped\n\t\t&dummy,         // throw-away dword\n\t\tfalse);         // wait till event signals\n\n\tif (!success && GetLastError () == ERROR_IO_INCOMPLETE) {\n\t\t// IO still incomplete, wait for completion.\n\t\tdummy = 0;\n\t\tDS_ENTER_BLOCKING_PAL_SECTION;\n\t\tsuccess = GetOverlappedResult (\n\t\t\tipc->pipe,      // handle\n\t\t\t&ipc->overlap,  // overlapped\n\t\t\t&dummy,         // throw-away dword\n\t\t\ttrue);          // wait till event signals\n\t\tDS_EXIT_BLOCKING_PAL_SECTION;\n\t}\n\n\tif (!success) {\n\t\tif (callback)\n\t\t\tcallback (\"Failed to GetOverlappedResults for NamedPipe server\", GetLastError());\n\t\t// close the pipe (cleanup and reset below)\n\t\tCloseHandle (ipc->pipe);\n\t} else {\n\t\t// create new IpcStream using handle (passes ownership to pStream)\n\t\tstream = ipc_stream_alloc (ipc->pipe, DS_IPC_CONNECTION_MODE_LISTEN);\n\t\tep_raise_error_if_nok (stream != NULL);\n\t}\n\n\t// reset the server\n\tipc->pipe = INVALID_HANDLE_VALUE;\n\tipc->is_listening = false;\n\tCloseHandle (ipc->overlap.hEvent);\n\tmemset(&ipc->overlap, 0, sizeof(OVERLAPPED)); // clear the overlapped objects state\n\tipc->overlap.hEvent = INVALID_HANDLE_VALUE;\n\n\tep_raise_error_if_nok (ds_ipc_listen (ipc, callback));\n\nep_on_exit:\n\treturn stream;\n\nep_on_error:\n\tds_ipc_stream_free (stream);\n\tstream = NULL;\n\tep_exit_error_handler ();\n}\n\nDiagnosticsIpcStream *\nds_ipc_connect (\n\tDiagnosticsIpc *ipc,\n\tuint32_t timeout_ms,\n\tds_ipc_error_callback_func callback,\n\tbool *timed_out)\n{\n\tEP_ASSERT (ipc != NULL);\n\tEP_ASSERT (timed_out != NULL);\n\tEP_ASSERT (ipc->mode == DS_IPC_CONNECTION_MODE_CONNECT);\n\n\tDiagnosticsIpcStream *stream = NULL;\n\tHANDLE pipe = INVALID_HANDLE_VALUE;\n\n\tif (ipc->mode != DS_IPC_CONNECTION_MODE_CONNECT) {\n\t\tif (callback)\n\t\t\tcallback (\"Cannot call connect on a server connection\", 0);\n\t\tep_raise_error ();\n\t}\n\n\tDS_ENTER_BLOCKING_PAL_SECTION;\n\tpipe = CreateFileA(\n\t\tipc->pipe_name,         // pipe name\n\t\tPIPE_ACCESS_DUPLEX,     // read/write access\n\t\t0,                      // no sharing\n\t\tNULL,                   // default security attributes\n\t\tOPEN_EXISTING,          // opens existing pipe\n\t\tFILE_FLAG_OVERLAPPED,   // overlapped\n\t\tNULL);                  // no template file\n\tDS_EXIT_BLOCKING_PAL_SECTION;\n\n\tif (pipe == INVALID_HANDLE_VALUE) {\n\t\tif (callback)\n\t\t\tcallback (\"Failed to connect to named pipe.\", GetLastError ());\n\t\tep_raise_error ();\n\t}\n\n\tstream = ipc_stream_alloc (pipe, ipc->mode);\n\tep_raise_error_if_nok (stream);\n\n\tpipe = INVALID_HANDLE_VALUE;\n\nep_on_exit:\n\treturn stream;\n\nep_on_error:\n\tds_ipc_stream_free (stream);\n\tstream = NULL;\n\n\tif (pipe != INVALID_HANDLE_VALUE) {\n\t\tCloseHandle (pipe);\n\t}\n\n\tep_exit_error_handler ();\n}\n\nvoid\nds_ipc_close (\n\tDiagnosticsIpc *ipc,\n\tbool is_shutdown,\n\tds_ipc_error_callback_func callback)\n{\n\tEP_ASSERT (ipc != NULL);\n\n\t// don't attempt cleanup on shutdown and let the OS handle it\n\tif (is_shutdown) {\n\t\tif (callback)\n\t\t\tcallback (\"Closing without cleaning underlying handles\", 100);\n\t\treturn;\n\t}\n\n\tif (ipc->pipe != INVALID_HANDLE_VALUE) {\n\t\tif (ipc->mode == DS_IPC_CONNECTION_MODE_LISTEN) {\n\t\t\tBOOL success_disconnect = FALSE;\n\t\t\tDS_ENTER_BLOCKING_PAL_SECTION;\n\t\t\tsuccess_disconnect = DisconnectNamedPipe (ipc->pipe);\n\t\t\tDS_EXIT_BLOCKING_PAL_SECTION;\n\t\t\tif (success_disconnect != TRUE && callback)\n\t\t\t\tcallback (\"Failed to disconnect NamedPipe\", GetLastError());\n\t\t}\n\n\t\tconst BOOL success_close_pipe = CloseHandle (ipc->pipe);\n\t\tif (success_close_pipe != TRUE && callback)\n\t\t\tcallback (\"Failed to close pipe handle\", GetLastError());\n\t\tipc->pipe = INVALID_HANDLE_VALUE;\n\t}\n\n\tif (ipc->overlap.hEvent != INVALID_HANDLE_VALUE) {\n\t\tconst BOOL success_close_event = CloseHandle (ipc->overlap.hEvent);\n\t\tif (success_close_event != TRUE && callback)\n\t\t\tcallback (\"Failed to close overlap event handle\", GetLastError());\n\t\tmemset(&ipc->overlap, 0, sizeof(OVERLAPPED)); // clear the overlapped objects state\n\t\tipc->overlap.hEvent = INVALID_HANDLE_VALUE;\n\t}\n}\n\nint32_t\nds_ipc_to_string (\n\tDiagnosticsIpc *ipc,\n\tep_char8_t *buffer,\n\tuint32_t buffer_len)\n{\n\tEP_ASSERT (ipc != NULL);\n\tEP_ASSERT (buffer != NULL);\n\tEP_ASSERT (buffer_len <= DS_IPC_MAX_TO_STRING_LEN);\n\tint32_t result = sprintf_s (buffer, buffer_len, \"{ _hPipe = %d, _oOverlap.hEvent = %d }\", (int32_t)(size_t)ipc->pipe, (int32_t)(size_t)ipc->overlap.hEvent);\n\treturn (result > 0 && result < (int32_t)buffer_len) ? result : 0;\n}\n\n/*\n * DiagnosticsIpcStream.\n */\n\nstatic\nvoid\nipc_stream_free_func (void *object)\n{\n\tEP_ASSERT (object != NULL);\n\tDiagnosticsIpcStream *ipc_stream = (DiagnosticsIpcStream *)object;\n\tds_ipc_stream_free (ipc_stream);\n}\n\nstatic\nbool\nipc_stream_read_func (\n\tvoid *object,\n\tuint8_t *buffer,\n\tuint32_t bytes_to_read,\n\tuint32_t *bytes_read,\n\tuint32_t timeout_ms)\n{\n\tEP_ASSERT (object != NULL);\n\tEP_ASSERT (buffer != NULL);\n\tEP_ASSERT (bytes_read != NULL);\n\n\tDiagnosticsIpcStream *ipc_stream = (DiagnosticsIpcStream *)object;\n\tDWORD read = 0;\n\tLPOVERLAPPED overlap = &ipc_stream->overlap;\n\n\tbool success = ReadFile (\n\t\tipc_stream->pipe,   // handle to pipe\n\t\tbuffer,             // buffer to receive data\n\t\tbytes_to_read,      // size of buffer\n\t\t&read,              // number of bytes read\n\t\toverlap) != FALSE;  // overlapped I/O\n\n\tif (!success) {\n\t\tDWORD error = GetLastError ();\n\t\tif (error == ERROR_IO_PENDING) {\n\t\t\t// if we're waiting infinitely, only make one syscall\n\t\t\tif (timeout_ms == DS_IPC_TIMEOUT_INFINITE) {\n\t\t\t\tDS_ENTER_BLOCKING_PAL_SECTION;\n\t\t\t\tsuccess = GetOverlappedResult (\n\t\t\t\t\tipc_stream->pipe,   // pipe\n\t\t\t\t\toverlap,            // overlapped\n\t\t\t\t\t&read,              // out actual number of bytes read\n\t\t\t\t\ttrue) != FALSE;     // block until async IO completes\n\t\t\t\tDS_EXIT_BLOCKING_PAL_SECTION;\n\t\t\t} else {\n\t\t\t\t// Wait on overlapped IO event (triggers when async IO is complete regardless of success)\n\t\t\t\t// or timeout\n\t\t\t\tDS_ENTER_BLOCKING_PAL_SECTION;\n\t\t\t\tDWORD wait = WaitForSingleObject (ipc_stream->overlap.hEvent, (DWORD)timeout_ms);\n\t\t\t\tif (wait == WAIT_OBJECT_0) {\n\t\t\t\t\t// async IO compelted, get the result\n\t\t\t\t\tsuccess = GetOverlappedResult (\n\t\t\t\t\t\tipc_stream->pipe,   // pipe\n\t\t\t\t\t\toverlap,            // overlapped\n\t\t\t\t\t\t&read,              // out actual number of bytes read\n\t\t\t\t\t\ttrue) != FALSE;     // block until async IO completes\n\t\t\t\t} else {\n\t\t\t\t\t// We either timed out or something else went wrong.\n\t\t\t\t\t// For any error, attempt to cancel IO and ensure the cancel happened\n\t\t\t\t\tif (CancelIoEx (ipc_stream->pipe, overlap) != FALSE) {\n\t\t\t\t\t\t// check if the async write beat the cancellation\n\t\t\t\t\t\tsuccess = GetOverlappedResult (\n\t\t\t\t\t\t\tipc_stream->pipe,   // pipe\n\t\t\t\t\t\t\toverlap,            // overlapped\n\t\t\t\t\t\t\t&read,              // out actual number of bytes read\n\t\t\t\t\t\t\ttrue) != FALSE;     // block until async IO completes\n\t\t\t\t\t\t// Failure here isn't recoverable, so return as such\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tDS_EXIT_BLOCKING_PAL_SECTION;\n\t\t\t}\n\t\t}\n\t\t// error is unrecoverable, so return as such\n\t}\n\n\t*bytes_read = (uint32_t)read;\n\treturn success;\n}\n\nstatic\nbool\nipc_stream_write_func (\n\tvoid *object,\n\tconst uint8_t *buffer,\n\tuint32_t bytes_to_write,\n\tuint32_t *bytes_written,\n\tuint32_t timeout_ms)\n{\n\tEP_ASSERT (object != NULL);\n\tEP_ASSERT (buffer != NULL);\n\tEP_ASSERT (bytes_written != NULL);\n\n\tDiagnosticsIpcStream *ipc_stream = (DiagnosticsIpcStream *)object;\n\tDWORD written = 0;\n\tLPOVERLAPPED overlap = &ipc_stream->overlap;\n\n\tbool success = WriteFile (\n\t\tipc_stream->pipe,   // handle to pipe\n\t\tbuffer,             // buffer to write from\n\t\tbytes_to_write,     // number of bytes to write\n\t\t&written,           // number of bytes written\n\t\toverlap) != FALSE;  // overlapped I/O\n\n\tif (!success) {\n\t\tDWORD error = GetLastError ();\n\t\tif (error == ERROR_IO_PENDING) {\n\t\t\t// if we're waiting infinitely, only make one syscall\n\t\t\tif (timeout_ms == DS_IPC_TIMEOUT_INFINITE) {\n\t\t\t\tDS_ENTER_BLOCKING_PAL_SECTION;\n\t\t\t\tsuccess = GetOverlappedResult (\n\t\t\t\t\tipc_stream->pipe,   // pipe\n\t\t\t\t\toverlap,            // overlapped\n\t\t\t\t\t&written,           // out actual number of bytes written\n\t\t\t\t\ttrue) != FALSE;     // block until async IO completes\n\t\t\t\tDS_EXIT_BLOCKING_PAL_SECTION;\n\t\t\t} else {\n\t\t\t\t// Wait on overlapped IO event (triggers when async IO is complete regardless of success)\n\t\t\t\t// or timeout\n\t\t\t\tDS_ENTER_BLOCKING_PAL_SECTION;\n\t\t\t\tDWORD wait = WaitForSingleObject (ipc_stream->overlap.hEvent, (DWORD)timeout_ms);\n\t\t\t\tif (wait == WAIT_OBJECT_0) {\n\t\t\t\t\t// async IO compelted, get the result\n\t\t\t\t\tsuccess = GetOverlappedResult (\n\t\t\t\t\t\tipc_stream->pipe,   // pipe\n\t\t\t\t\t\toverlap,            // overlapped\n\t\t\t\t\t\t&written,           // out actual number of bytes written\n\t\t\t\t\t\ttrue) != FALSE;     // block until async IO completes\n\t\t\t\t} else {\n\t\t\t\t\t// We either timed out or something else went wrong.\n\t\t\t\t\t// For any error, attempt to cancel IO and ensure the cancel happened\n\t\t\t\t\tif (CancelIoEx (ipc_stream->pipe, overlap) != FALSE) {\n\t\t\t\t\t\t// check if the async write beat the cancellation\n\t\t\t\t\t\tsuccess = GetOverlappedResult (\n\t\t\t\t\t\t\tipc_stream->pipe,   // pipe\n\t\t\t\t\t\t\toverlap,            // overlapped\n\t\t\t\t\t\t\t&written,           // out actual number of bytes written\n\t\t\t\t\t\t\ttrue) != FALSE;         // block until async IO completes\n\t\t\t\t\t\t// Failure here isn't recoverable, so return as such\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tDS_EXIT_BLOCKING_PAL_SECTION;\n\t\t\t}\n\t\t}\n\t\t// error is unrecoverable, so return as such\n\t}\n\n\t*bytes_written = (uint32_t)written;\n\treturn success;\n}\n\nstatic\nbool\nipc_stream_flush_func (void *object)\n{\n\tEP_ASSERT (object != NULL);\n\n\tDiagnosticsIpcStream *ipc_stream = (DiagnosticsIpcStream *)object;\n\tbool success = false;\n\n\tDS_ENTER_BLOCKING_PAL_SECTION;\n\tsuccess = FlushFileBuffers (ipc_stream->pipe) != FALSE;\n\tDS_EXIT_BLOCKING_PAL_SECTION;\n\n\t// TODO: Add error handling.\n\treturn success;\n}\n\nstatic\nbool\nipc_stream_close_func (void *object)\n{\n\tEP_ASSERT (object != NULL);\n\tDiagnosticsIpcStream *ipc_stream = (DiagnosticsIpcStream *)object;\n\treturn ds_ipc_stream_close (ipc_stream, NULL);\n}\n\nstatic IpcStreamVtable ipc_stream_vtable = {\n\tipc_stream_free_func,\n\tipc_stream_read_func,\n\tipc_stream_write_func,\n\tipc_stream_flush_func,\n\tipc_stream_close_func };\n\nstatic\nDiagnosticsIpcStream *\nipc_stream_alloc (\n\tHANDLE pipe,\n\tDiagnosticsIpcConnectionMode mode)\n{\n\tDiagnosticsIpcStream *instance = ep_rt_object_alloc (DiagnosticsIpcStream);\n\tep_raise_error_if_nok (instance != NULL);\n\n\tinstance->stream.vtable = &ipc_stream_vtable;\n\tinstance->pipe = pipe;\n\tinstance->mode = mode;\n\n\t// All memory zeroed on alloc.\n\t//memset (&instance->overlap, 0, sizeof (OVERLAPPED));\n\n\tinstance->overlap.hEvent = CreateEventW (NULL, true, false, NULL);\n\nep_on_exit:\n\treturn instance;\n\nep_on_error:\n\tds_ipc_stream_free (instance);\n\tinstance = NULL;\n\tep_exit_error_handler ();\n}\n\nint32_t\nds_ipc_stream_get_handle_int32_t (DiagnosticsIpcStream *ipc_stream)\n{\n\treturn (int32_t)(size_t)ipc_stream->pipe;\n}\n\nIpcStream *\nds_ipc_stream_get_stream_ref (DiagnosticsIpcStream *ipc_stream)\n{\n\treturn &ipc_stream->stream;\n}\n\nvoid\nds_ipc_stream_free (DiagnosticsIpcStream *ipc_stream)\n{\n\tif (!ipc_stream)\n\t\treturn;\n\n\tds_ipc_stream_close (ipc_stream, NULL);\n\tep_rt_object_free (ipc_stream);\n}\n\nbool\nds_ipc_stream_read (\n\tDiagnosticsIpcStream *ipc_stream,\n\tuint8_t *buffer,\n\tuint32_t bytes_to_read,\n\tuint32_t *bytes_read,\n\tuint32_t timeout_ms)\n{\n\treturn ipc_stream_read_func (\n\t\tipc_stream,\n\t\tbuffer,\n\t\tbytes_to_read,\n\t\tbytes_read,\n\t\ttimeout_ms);\n}\n\nbool\nds_ipc_stream_write (\n\tDiagnosticsIpcStream *ipc_stream,\n\tconst uint8_t *buffer,\n\tuint32_t bytes_to_write,\n\tuint32_t *bytes_written,\n\tuint32_t timeout_ms)\n{\n\treturn ipc_stream_write_func (\n\t\tipc_stream,\n\t\tbuffer,\n\t\tbytes_to_write,\n\t\tbytes_written,\n\t\ttimeout_ms);\n}\n\nbool\nds_ipc_stream_flush (DiagnosticsIpcStream *ipc_stream)\n{\n\treturn ipc_stream_flush_func (ipc_stream);\n}\n\nbool\nds_ipc_stream_close (\n\tDiagnosticsIpcStream *ipc_stream,\n\tds_ipc_error_callback_func callback)\n{\n\tEP_ASSERT (ipc_stream != NULL);\n\n\tif (ipc_stream->pipe != INVALID_HANDLE_VALUE) {\n\t\tds_ipc_stream_flush (ipc_stream);\n\t\tif (ipc_stream->mode == DS_IPC_CONNECTION_MODE_LISTEN) {\n\t\t\tBOOL success_disconnect = FALSE;\n\t\t\tDS_ENTER_BLOCKING_PAL_SECTION;\n\t\t\tsuccess_disconnect = DisconnectNamedPipe (ipc_stream->pipe);\n\t\t\tDS_EXIT_BLOCKING_PAL_SECTION;\n\t\t\tif (success_disconnect != TRUE && callback)\n\t\t\t\tcallback (\"Failed to disconnect NamedPipe\", GetLastError());\n\t\t}\n\n\t\tconst BOOL success_close_pipe = CloseHandle (ipc_stream->pipe);\n\t\tif (success_close_pipe != TRUE && callback)\n\t\t\tcallback (\"Failed to close pipe handle\", GetLastError());\n\t\tipc_stream->pipe = INVALID_HANDLE_VALUE;\n\t}\n\n\tif (ipc_stream->overlap.hEvent != INVALID_HANDLE_VALUE) {\n\t\tconst BOOL success_close_event = CloseHandle (ipc_stream->overlap.hEvent);\n\t\tif (success_close_event != TRUE && callback)\n\t\t\tcallback (\"Failed to close overlapped event handle\", GetLastError());\n\t\tmemset(&ipc_stream->overlap, 0, sizeof(OVERLAPPED)); // clear the overlapped objects state\n\t\tipc_stream->overlap.hEvent = INVALID_HANDLE_VALUE;\n\t}\n\n\tipc_stream->is_test_reading = false;\n\n\treturn true;\n}\n\nint32_t\nds_ipc_stream_to_string (\n\tDiagnosticsIpcStream *ipc_stream,\n\tep_char8_t *buffer,\n\tuint32_t buffer_len)\n{\n\tEP_ASSERT (ipc_stream != NULL);\n\tEP_ASSERT (buffer != NULL);\n\tEP_ASSERT (buffer_len <= DS_IPC_MAX_TO_STRING_LEN);\n\tint32_t result = sprintf_s (buffer, buffer_len, \"{ _hPipe = %d, _oOverlap.hEvent = %d }\", (int32_t)(size_t)ipc_stream->pipe, (int32_t)(size_t)ipc_stream->overlap.hEvent);\n\treturn (result > 0 && result < (int32_t)buffer_len) ? result : 0;\n}\n#endif /* HOST_WIN32 */\n#endif /* ENABLE_PERFTRACING */\n\n#ifndef DS_INCLUDE_SOURCE_FILES\nextern const char quiet_linker_empty_file_warning_diagnostics_ipc_win32;\nconst char quiet_linker_empty_file_warning_diagnostics_ipc_win32 = 0;\n#endif\n\n", "comment_ratio": 0.13472070098576122}
{"lang": "c", "code": "// ############# VARIABLES ############### //\r\n//#define SERVER_IP \"10.0.1.7:9080\" // PC address with emulation on host\r\n#define SERVER_IP \"192.168.1.4\"\r\n\r\n\r\nvoid sendMSG(String cartao){\r\n      if ((WiFi.status() == WL_CONNECTED)){\r\n   \r\n      WiFiClient client;\r\n      HTTPClient http;\r\n  \r\n      Serial.print(\"[HTTP] begin...\\n\");\r\n      // configure traged server and url\r\n      http.begin(client, \"http://\" SERVER_IP \":3000/sensors\"); //HTTP\r\n      http.addHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\r\n  \r\n      Serial.print(\"[HTTP] POST...\\n\");\r\n      // start connection and send HTTP header and body\r\n      String body = \"id=7890&name=SENSORS&type=RFID&value=\"+cartao;\r\n      int httpCode = http.POST(body);\r\n  \r\n      // httpCode will be negative on error\r\n      if (httpCode > 0) {\r\n        // HTTP header has been send and Server response header has been handled\r\n        Serial.printf(\"[HTTP] POST... code: %d\\n\", httpCode);\r\n  \r\n        // file found at server\r\n        if (httpCode == HTTP_CODE_OK) {\r\n          const String& payload = http.getString();\r\n          Serial.println(\"received payload:\\n<<\");\r\n          Serial.println(payload);\r\n          Serial.println(\">>\");\r\n        }\r\n      } else {\r\n        Serial.printf(\"[HTTP] POST... failed, error: %s\\n\", http.errorToString(httpCode).c_str());\r\n      }\r\n  \r\n      http.end();\r\n    }\r\n  }\r\n\n", "comment_ratio": 0.1951219512195122}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n\n@class AppDelegate_iPhone;\n@class NewsViewController;\n\n@interface DetailViewController : UIViewController <UIWebViewDelegate>{\n\t\n\tNewsViewController *newsViewController;\n\tIBOutlet UIButton *backButton;\n\n}\n\n@property (nonatomic, retain) NSString *contentString;\n@property (nonatomic, retain) NSString *titleString;\n@property (nonatomic, retain) IBOutlet UIWebView *contentView;\n@property (nonatomic, retain) NewsViewController *newsViewController;\n\n- (IBAction) backButtonPressed:(id)sender;\n\n@end\n\n", "comment_ratio": 0.2413793103448276}
{"lang": "c", "code": "// This is automatically generated by PlayFab SDKGenerator. DO NOT modify this manually!\n#pragma once\n#include \"OnlineBlueprintCallProxyBase.h\"\n\n#include \"Core/PlayFabAdminAPI.h\"\n#include \"Core/PlayFabAdminDataModels.h\"\n#include \"Proxy/PlayFabAdminBPDataModels.h\"\n#include \"PFAdminListVirtualCurrencyTypes.generated.h\"\n\nUCLASS()\nclass PLAYFABPROXY_API UPFAdminListVirtualCurrencyTypes : public UOnlineBlueprintCallProxyBase\n{\n\tGENERATED_UCLASS_BODY()\npublic:\n\n\tUPROPERTY(BlueprintAssignable)\n\tFBPAdminListVirtualCurrencyTypesResultDelegate OnSuccess;\n\n\tUPROPERTY(BlueprintAssignable)\n\tFBPAdminListVirtualCurrencyTypesResultDelegate OnFailure;\n\t\n\t// Retuns the list of all defined virtual currencies for the title\n\tUFUNCTION(BlueprintCallable, meta = (BlueprintInternalUseOnly = \"true\", WorldContext = \"WorldContextObject\"), Category = \"PlayFab|Admin|Title-Wide Data Management\")\n\tstatic UPFAdminListVirtualCurrencyTypes* ListVirtualCurrencyTypes(UObject* WorldContextObject, class APlayerController* PlayerController);\n\n\t// UOnlineBlueprintCallProxyBase interface\n\tvirtual void Activate() override;\n\t// End of UOnlineBlueprintCallProxyBase interface\n\nprivate:\n\n\t\n\n\tPlayFab::UPlayFabAdminAPI::FListVirtualCurrencyTypesDelegate\tSuccessDelegate;\n\tPlayFab::FPlayFabErrorDelegate\t\t\t\t\t\t\tErrorDelegate;\n\n\tvoid OnSuccessCallback(const PlayFab::AdminModels::FListVirtualCurrencyTypesResult& Result);\n\tvoid OnErrorCallback(const PlayFab::FPlayFabError& Error);\n};\n\n", "comment_ratio": 0.1}
{"lang": "c", "code": "#include <assert.h>\n#include <stdlib.h>\n\n#include <cunit/CUnit.h>\n\n#include <Driver/TSTssdoConfig.h>\n\n//============================================================================//\n//            G L O B A L   D E F I N I T I O N S                             //\n//============================================================================//\n\n//------------------------------------------------------------------------------\n// const defines\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// module global vars\n//------------------------------------------------------------------------------\n\n\n//------------------------------------------------------------------------------\n// global function prototypes\n//------------------------------------------------------------------------------\n\n//============================================================================//\n//            P R I V A T E   D E F I N I T I O N S                           //\n//============================================================================//\n\n//------------------------------------------------------------------------------\n// const defines\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// local types\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// local vars\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// local function prototypes\n//------------------------------------------------------------------------------\n\n#if (((PSI_MODULE_INTEGRATION) & (PSI_MODULE_SSDO)) != 0)\n\n/* Empty cleanup function for the tests */\nstatic int TST_defaultClean(void)\n{\n    return 0;\n}\n\nstatic CU_TestInfo ssdoProcessSuite[] = {\n    { \"Simple initialization tests\", TST_ssdoInit },\n    { \"Module process test\", TST_ssdoProcess },\n    CU_TEST_INFO_NULL,\n};\n\nstatic CU_TestInfo ssdoInitInvalidSuite[] = {\n    { \"Test with invalid stream module initialization\", TST_ssdoInitFail },\n    CU_TEST_INFO_NULL,\n};\n\nstatic CU_TestInfo ssdoReadWriteSuite[] = {\n    { \"Test write payload API functions\", TST_ssdoWritePayload },\n    { \"Receive payload tests\", TST_receivePayload },\n    { \"Receive payload with invalid user handler\", TST_receivePayloadInvalidHandler },\n    CU_TEST_INFO_NULL,\n};\n\nstatic CU_TestInfo ssdoSuite[] = {\n    { \"Test ssdo process function of internal module\", TST_internalProcess },\n    { \"Test ssdo process function of failing receive handler\", TST_internalProcessRxHandlerFail },\n    CU_TEST_INFO_NULL,\n};\n\nstatic CU_SuiteInfo suites[] = {\n    { \"Process suite\", TST_streamInit, TST_defaultClean, ssdoProcessSuite },\n    { \"Buffer rx address invalid\", TST_initSsdoRxAddrInvalid, TST_defaultClean, ssdoInitInvalidSuite },\n    { \"Buffer tx address invalid\", TST_initSsdoTxAddrInvalid, TST_defaultClean, ssdoInitInvalidSuite },\n    { \"Buffer rx size invalid\", TST_initSsdoRxSizeInvalid, TST_defaultClean, ssdoInitInvalidSuite },\n    { \"Buffer tx size invalid\", TST_initSsdoTxSizeInvalid, TST_defaultClean, ssdoInitInvalidSuite },\n    { \"Buffer rx post action list full\", TST_initRxPostActionListFull, TST_defaultClean, ssdoInitInvalidSuite },\n    { \"Buffer tx with no timeout instance available\", TST_initTxTimeoutInitFails, TST_defaultClean, ssdoInitInvalidSuite },\n    { \"Test read write API functions\", TST_initFull, TST_defaultClean, ssdoReadWriteSuite },\n    { \"Ssdo module suite\", TST_initInternal, TST_defaultClean, ssdoSuite },\n    CU_SUITE_INFO_NULL,\n};\n#else\n  // Pass empty suite to cunit\n  static CU_SuiteInfo suites[] = { { NULL, NULL, NULL, NULL } };\n#endif // #if (((PSI_MODULE_INTEGRATION) & (PSI_MODULE_SSDO)) != 0)\n\n//============================================================================//\n//            P U B L I C   F U N C T I O N S                                 //\n//============================================================================//\n\n//------------------------------------------------------------------------------\n/**\n\\brief    Add tests to the suites\n\n\\ingroup module_unittests\n*/\n//------------------------------------------------------------------------------\nvoid TST_AddTests(void)\n{\n    assert(NULL != CU_get_registry());\n    assert(!CU_is_test_running());\n\n    /* Register suites. */\n    if (CU_register_suites(suites) != CUE_SUCCESS) {\n            fprintf(stderr, \"suite registration failed - %s\\n\",\n                    CU_get_error_msg());\n            exit(EXIT_FAILURE);\n    }\n} /*TST_AddTests()*/\n\n", "comment_ratio": 0.22424242424242424}
{"lang": "c", "code": "#ifndef SYNC_NOTIFIER_INVALIDATION_STATE_TRACKER_H_\n#define SYNC_NOTIFIER_INVALIDATION_STATE_TRACKER_H_\n\n#include <map>\n#include <string>\n\n#include \"base/basictypes.h\"\n#include \"base/callback_forward.h\"\n#include \"base/memory/ref_counted.h\"\n#include \"google/cacheinvalidation/include/types.h\"\n#include \"sync/base/sync_export.h\"\n#include \"sync/internal_api/public/base/invalidation.h\"\n#include \"sync/notifier/invalidation_util.h\"\n#include \"sync/notifier/unacked_invalidation_set.h\"\n\nnamespace base {\nclass TaskRunner;\n}  // namespace base\n\nnamespace syncer {\n\nclass InvalidationStateTracker {\n public:\n  InvalidationStateTracker() {}\n\n  // The per-client unique ID used to register the invalidation client with the\n  // server.  This is used to squelch invalidation notifications that originate\n  // from changes made by this client.\n  virtual void SetInvalidatorClientId(const std::string& data) = 0;\n  virtual std::string GetInvalidatorClientId() const = 0;\n\n  // Used by invalidation::InvalidationClient for persistence. |data| is an\n  // opaque blob that an invalidation client can use after a restart to\n  // bootstrap itself. |data| is binary data (not valid UTF8, embedded nulls,\n  // etc).\n  virtual void SetBootstrapData(const std::string& data) = 0;\n  virtual std::string GetBootstrapData() const = 0;\n\n  // Used to store invalidations that have been acked to the server, but not yet\n  // handled by our clients.  We store these invalidations on disk so we won't\n  // lose them if we need to restart.\n  virtual void SetSavedInvalidations(const UnackedInvalidationsMap& states) = 0;\n  virtual UnackedInvalidationsMap GetSavedInvalidations() const = 0;\n\n  // Erases invalidation versions, client ID, and state stored on disk.\n  virtual void Clear() = 0;\n\n protected:\n  virtual ~InvalidationStateTracker() {}\n};\n\n}  // namespace syncer\n\n#endif  // SYNC_NOTIFIER_INVALIDATION_STATE_TRACKER_H_\n\n", "comment_ratio": 0.36363636363636365}
{"lang": "c", "code": "#include \"vk_shader_info_amd.h\"\n\n#include <inttypes.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n//\n//\n//\n\nvoid\nvk_shader_info_amd_statistics(VkDevice           device,\n                              VkPipeline         p[],\n                              char const * const names[],\n                              uint32_t const     count)\n{\n#ifndef VK_SHADER_INFO_AMD_STATISTICS_DISABLE\n\n  PFN_vkGetShaderInfoAMD vkGetShaderInfoAMD =\n    (PFN_vkGetShaderInfoAMD)vkGetDeviceProcAddr(device, \"vkGetShaderInfoAMD\");\n\n  if (vkGetShaderInfoAMD == NULL)\n    return;\n\n  fprintf(stdout,\n          \"                                   PHY   PHY  AVAIL AVAIL\\n\"\n          \"VGPRs SGPRs LDS_MAX LDS/WG  SPILL VGPRs SGPRs VGPRs SGPRs  WORKGROUP_SIZE  NAME\\n\");\n\n  for (uint32_t ii = 0; ii < count; ii++)\n    {\n      VkShaderStatisticsInfoAMD ssi_amd;\n      size_t                    ssi_amd_size = sizeof(ssi_amd);\n\n      if (vkGetShaderInfoAMD(device,\n                             p[ii],\n                             VK_SHADER_STAGE_COMPUTE_BIT,\n                             VK_SHADER_INFO_TYPE_STATISTICS_AMD,\n                             &ssi_amd_size,\n                             &ssi_amd) == VK_SUCCESS)\n        {\n          fprintf(stdout,\n                  \"%5\" PRIu32 \" \"\n                  \"%5\" PRIu32 \"   \"\n                  \"%5\" PRIu32 \" \"\n\n                  \"%6zu \"\n                  \"%6zu \"\n\n                  \"%5\" PRIu32 \" \"\n                  \"%5\" PRIu32 \" \"\n                  \"%5\" PRIu32 \" \"\n                  \"%5\" PRIu32 \"  \"\n\n                  \"( %6\" PRIu32 \", \"\n                  \"%6\" PRIu32 \", \"\n                  \"%6\" PRIu32 \" )  \",\n                  ssi_amd.resourceUsage.numUsedVgprs,\n                  ssi_amd.resourceUsage.numUsedSgprs,\n                  ssi_amd.resourceUsage.ldsSizePerLocalWorkGroup,\n                  ssi_amd.resourceUsage.ldsUsageSizeInBytes,     // size_t\n                  ssi_amd.resourceUsage.scratchMemUsageInBytes,  // size_t\n                  ssi_amd.numPhysicalVgprs,\n                  ssi_amd.numPhysicalSgprs,\n                  ssi_amd.numAvailableVgprs,\n                  ssi_amd.numAvailableSgprs,\n                  ssi_amd.computeWorkGroupSize[0],\n                  ssi_amd.computeWorkGroupSize[1],\n                  ssi_amd.computeWorkGroupSize[2]);\n\n          if (names != NULL)\n            fprintf(stdout, \"%s\\n\", names[ii]);\n          else\n            fprintf(stdout, \"---\\n\");\n        }\n    }\n\n#endif\n}\n\n//\n//\n//\n\nvoid\nvk_shader_info_amd_disassembly(VkDevice           device,\n                               VkPipeline         p[],\n                               char const * const names[],\n                               uint32_t const     count)\n{\n#ifndef VK_SHADER_INFO_AMD_DISASSEMBLY_DISABLE\n\n  PFN_vkGetShaderInfoAMD vkGetShaderInfoAMD =\n    (PFN_vkGetShaderInfoAMD)vkGetDeviceProcAddr(device, \"vkGetShaderInfoAMD\");\n\n  if (vkGetShaderInfoAMD == NULL)\n    return;\n\n  for (uint32_t ii = 0; ii < count; ii++)\n    {\n      size_t disassembly_amd_size;\n\n      if (vkGetShaderInfoAMD(device,\n                             p[ii],\n                             VK_SHADER_STAGE_COMPUTE_BIT,\n                             VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD,\n                             &disassembly_amd_size,\n                             NULL) == VK_SUCCESS)\n        {\n          void * disassembly_amd = malloc(disassembly_amd_size);\n\n          if (vkGetShaderInfoAMD(device,\n                                 p[ii],\n                                 VK_SHADER_STAGE_COMPUTE_BIT,\n                                 VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD,\n                                 &disassembly_amd_size,\n                                 disassembly_amd) == VK_SUCCESS)\n            {\n              if (names != NULL)\n                fprintf(stdout, \"SHADER: %s\\n\", names[ii]);\n\n              fprintf(stdout, \"%s\", (char *)disassembly_amd);\n            }\n\n          free(disassembly_amd);\n        }\n    }\n\n#endif\n}\n\n//\n//\n//\n\n", "comment_ratio": 0.11971830985915492}
{"lang": "c", "code": "#ifndef floyd_llvm_runtime_hpp\n#define floyd_llvm_runtime_hpp\n\n#include \"value_backend.h\"\n#include \"floyd_llvm_types.h\"\n#include \"value_thunking.h\"\n#include <llvm/IR/IRBuilder.h>\n\n#include <string>\n#include <vector>\n\nnamespace llvm {\n\tstruct ExecutionEngine;\n}\n\n//??? make floyd_llvm-namespace. Reduces collisions with byte code interpreter.\n\nnamespace floyd {\n\nstruct llvm_ir_program_t;\nstruct runtime_handler_i;\nstruct run_output_t;\nstruct floyd_runtime_t;\nstruct llvm_instance_t;\n\n\nstatic const bool k_trace_process_messaging = false;\n\n\n////////////////////////////////\t\tllvm_bind_t\n\nstruct llvm_bind_t {\n\tlink_name_t link_name;\n\tvoid* address;\n\ttype_t type;\n};\n\n\n\n////////////////////////////////\t\tfunction_bind_t\n\n\n\nstruct function_bind_t {\n\tstd::string name;\n\tllvm::FunctionType* llvm_function_type;\n\tvoid* native_f;\n};\n\n\n\n////////////////////////////////\t\tfunction_link_entry_t\n\n\n\nstruct function_link_entry_t {\n\tstd::string module;\n\n\tlink_name_t link_name;\n\n\tllvm::FunctionType* llvm_function_type;\n\n\t//\tOnly valid during codegen\n\t//??? Rename llvm_function_node;\n\tllvm::Function* llvm_codegen_f;\n\n\ttype_t function_type_or_undef;\n\n\t//??? better to use vector<string>\n\tstd::vector<member_t> arg_names_or_empty;\n\n\tvoid* native_f;\n};\n\nvoid trace_function_link_map(const types_t& types, const std::vector<function_link_entry_t>& defs);\n\n\n\n\n\n\n\n////////////////////////////////\t\tllvm_execution_engine_t\n\n\n\n//https://en.wikipedia.org/wiki/Hexspeak\nconst uint64_t k_debug_magic = 0xFACEFEED05050505;\n\n\nstruct llvm_execution_engine_t {\n\t~llvm_execution_engine_t();\n\tbool check_invariant() const;\n\n\n\t////////////////////////////////\t\tSTATE\n\n\t//\tMust be first member, checked by LLVM code.\n\tuint64_t debug_magic;\n\n\tvalue_backend_t backend;\n\tllvm_type_lookup type_lookup;\n\n\tcontainer_t container_def;\n\n\tllvm_instance_t* instance;\n\tstd::shared_ptr<llvm::ExecutionEngine> ee;\n\tsymbol_table_t global_symbols;\n\tstd::vector<function_link_entry_t> function_link_map;\n\tpublic: std::vector<std::string> _print_output;\n\n\tpublic: runtime_handler_i* _handler;\n\n\tpublic: const std::chrono::time_point<std::chrono::high_resolution_clock> _start_time;\n\n\n\tllvm_bind_t main_function;\n\tbool inited;\n\tconfig_t config;\n};\n\n\n\n////////////////////////////////\t\tFUNCTION POINTERS\n\n\ntypedef int64_t (*FLOYD_RUNTIME_INIT)(floyd_runtime_t* frp);\ntypedef int64_t (*FLOYD_RUNTIME_DEINIT)(floyd_runtime_t* frp);\n\n//??? remove\ntypedef void (*FLOYD_RUNTIME_HOST_FUNCTION)(floyd_runtime_t* frp, int64_t arg);\n\n\n//\tfunc int main([string] args) impure\ntypedef int64_t (*FLOYD_RUNTIME_MAIN_ARGS_IMPURE)(floyd_runtime_t* frp, runtime_value_t args);\n\n//\tfunc int main() impure\ntypedef int64_t (*FLOYD_RUNTIME_MAIN_NO_ARGS_IMPURE)(floyd_runtime_t* frp);\n\n//\tfunc int main([string] args) pure\ntypedef int64_t (*FLOYD_RUNTIME_MAIN_ARGS_PURE)(floyd_runtime_t* frp, runtime_value_t args);\n\n//\tfunc int main() impure\ntypedef int64_t (*FLOYD_RUNTIME_MAIN_NO_ARGS_PURE)(floyd_runtime_t* frp);\n\n\n//\t\tfunc my_gui_state_t my_gui__init() impure { }\ntypedef runtime_value_t (*FLOYD_RUNTIME_PROCESS_INIT)(floyd_runtime_t* frp);\n\n//\t\tfunc my_gui_state_t my_gui(my_gui_state_t state, json message) impure{\ntypedef runtime_value_t (*FLOYD_RUNTIME_PROCESS_MESSAGE)(floyd_runtime_t* frp, runtime_value_t state, runtime_value_t message);\n\ntypedef runtime_value_t (*FLOYD_BENCHMARK_F)(floyd_runtime_t* frp);\n\n\n\n////////////////////////////////\tCLIENT ACCESS OF RUNNING PROGRAM\n\n\nconst function_link_entry_t& find_function_def_from_link_name(const std::vector<function_link_entry_t>& function_link_map, const link_name_t& link_name);\n\nvoid* get_global_ptr(const llvm_execution_engine_t& ee, const std::string& name);\n\n\nstd::pair<void*, type_t> bind_global(const llvm_execution_engine_t& ee, const std::string& name);\nvalue_t load_global(const llvm_execution_engine_t& ee, const std::pair<void*, type_t>& v);\n\nvoid store_via_ptr(llvm_execution_engine_t& runtime, const type_t& member_type, void* value_ptr, const value_t& value);\n\nllvm_bind_t bind_function2(llvm_execution_engine_t& ee, const link_name_t& name);\n\n\ninline llvm_execution_engine_t& get_floyd_runtime(floyd_runtime_t* frp);\n\n\n\n////////////////////////////////\t\tVALUES\n\n\n\ninline value_t from_runtime_value(const llvm_execution_engine_t& runtime, const runtime_value_t encoded_value, const type_t& type){\n\treturn from_runtime_value2(runtime.backend, encoded_value, type);\n}\n\ninline runtime_value_t to_runtime_value(llvm_execution_engine_t& runtime, const value_t& value){\n\treturn to_runtime_value2(runtime.backend, value);\n}\n\ninline std::string from_runtime_string(const llvm_execution_engine_t& runtime, runtime_value_t encoded_value){\n\treturn from_runtime_string2(runtime.backend, encoded_value);\n}\ninline runtime_value_t to_runtime_string(llvm_execution_engine_t& runtime, const std::string& s){\n\treturn to_runtime_string2(runtime.backend, s);\n}\n\n\n////////////////////////////////\t\tHIGH LEVEL\n\n\n\n//\tReturns a complete list of all functions: programmed in floyd, runtime functions, init() deinit().\nstd::vector<function_link_entry_t> make_function_link_map1(\n\tllvm::LLVMContext& context,\n\tconst llvm_type_lookup& type_lookup,\n\tconst std::vector<floyd::function_definition_t>& ast_function_defs,\n\tconst intrinsic_signatures_t& intrinsic_signatures\n);\n\n\nint64_t llvm_call_main(llvm_execution_engine_t& ee, const llvm_bind_t& f, const std::vector<std::string>& main_args);\n\n\n\n//\tCalls init() and will perform deinit() when engine is destructed later.\nstd::unique_ptr<llvm_execution_engine_t> init_llvm_jit(llvm_ir_program_t& program);\n\n\n//\tCalls main() if it exists, else runs the floyd processes. Returns when execution is done.\nrun_output_t run_program(llvm_execution_engine_t& ee, const std::vector<std::string>& main_args);\n\n\n\nstruct bench_t {\n\tbenchmark_id_t benchmark_id;\n\tlink_name_t f;\n};\ninline bool operator==(const bench_t& lhs, const bench_t& rhs){ return lhs.benchmark_id == rhs.benchmark_id && lhs.f == rhs.f; }\n\nstd::vector<bench_t> collect_benchmarks(llvm_execution_engine_t& ee);\nstd::vector<benchmark_result2_t> run_benchmarks(llvm_execution_engine_t& ee, const std::vector<bench_t>& tests);\nstd::vector<bench_t> filter_benchmarks(const std::vector<bench_t>& b, const std::vector<std::string>& run_tests);\n\n\n\n\n\n//\tInlines\n////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n\ninline llvm_execution_engine_t& get_floyd_runtime(floyd_runtime_t* frp){\n\tQUARK_ASSERT(frp != nullptr);\n\n\tauto ptr = reinterpret_cast<llvm_execution_engine_t*>(frp);\n\tQUARK_ASSERT(ptr != nullptr);\n\tQUARK_ASSERT(ptr->debug_magic == k_debug_magic);\n\tQUARK_ASSERT(ptr->check_invariant());\n\treturn *ptr;\n}\n\n\n}\t//\tnamespace floyd\n\n\n#endif /* floyd_llvm_runtime_hpp */\n\n", "comment_ratio": 0.1320754716981132}
{"lang": "c", "code": "#include <kernel/serial.h>\n\n/** \n * This file defines helper functions to use the serial port(read/write to it), \n * and a routine to initialize a serial port. The serial port is currently only \n * used for debugging, as it is connected to qemu's stdout, but might come in handy \n * in the future. \n**/\n\n// http://wiki.osdev.org/Serial_ports was super useful\n\nvoid serial_init(int port){\n   outb(port + 1, 0x00);    // Disable all interrupts\n   outb(port + 3, 0x80);    // Enable DLAB (set baud rate divisor)\n   outb(port + 0, 0x03);    // Set divisor to 3 (lo byte) 38400 baud\n   outb(port + 1, 0x00);    //                  (hi byte)\n   outb(port + 3, 0x03);    // 8 bits, no parity, one stop bit\n   outb(port + 2, 0xC7);    // Enable FIFO, clear them, with 14-byte threshold\n   outb(port + 4, 0x0B);    // IRQs enabled, RTS/DSR set\n}\n\nint serial_received(int port) {\n   return inb(port + 5) & 1;\n}\n\nuint8_t read_serial(int port){\n    while (serial_received(port) == 0);\n \n    return inb(port);\n}\n\nint is_transmit_empty(int port) {\n   return inb(port + 5) & 0x20;\n}\n\nvoid write_serial(uint8_t chr, int port){\n    while (is_transmit_empty(port) == 0);\n \n    outb(port, chr); \n}\n\nvoid puts_serial(char* str, int port){\n    while(*str){\n        write_serial(*str, port);\n        str++;\n    }\n}\n\n", "comment_ratio": 0.16666666666666666}
{"lang": "c", "code": "#ifndef THERMOFAN_H\n#define THERMOFAN_H\n\n#include <PID_v1.h>\n#include \"ThermofanDef.h\"\n#include \"rus.h\"\n#include <U8g2lib.h>\n#include <SPI.h>\n#include <Wire.h>\n#include <EEPROM.h>\n\nclass State;\n\nclass Thermofan {\n    // \u0421\u043e\u0441\u0442\u043e\u044f\u043d\u0438\u0435\n    State* state;\n    State* newstate;\n  public:\n    // \u0417\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u044b \u043d\u0430\u0433\u0440\u0435\u0432\u0430\n    int thermocoupleValue = 0;\n    // \u041f\u0438\u043d \u0433\u0435\u0440\u043a\u043e\u043d\u0430\n    const int hermeticContactPin = 10;\n    // \u0417\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u0433\u0435\u0440\u043a\u043e\u043d\u0430\n    bool hermeticContactState = false;\n    bool oldhermeticContactState = true;\n    bool changeEncoderButton = true;\n    bool encButtonChange = 0;\n    //\u0432\u043a\u043b\u044e\u0447\u0435\u043d \u043b\u0438 \u043d\u0430\u0433\u0440\u0435\u0432 \u0444\u0435\u043d\u0430\n    bool warmingFan = true;\n    // \u0414\u043b\u044f \u043f\u0438\u0434 \u0440\u0435\u0433\u0443\u043b\u0438\u0440\u043e\u0432\u043a\u0438\n    double Input , Setpoint, Output;\n    // \u041e\u043f\u0442\u0438\u043c\u0430\u043b\u044c\u043d\u044b\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f 0.5 0 0.7\n    PID* fanpid;\n    int speedfan, echospeedfan;\n\n  public:\n    Thermofan();\n    static void attachEncoder();\n    static void attachFun();\n    unsigned long int getOversampled(int pin);\n    bool getOversampledDigital(int pin);\n    bool getOversampledDigitalLow(int pin);\n    void getTenTemperature();\n    int correction(int x);\n    void readhermeticContactState();\n    void saveButton();\n    void readEncoderButtonState();\n    void echo();\n    void echoDisplay(int i);\n    void echoDisplay(int i, int str);\n    void echoDisplay(int i, int str, int x);\n    void echoDisplay(char* i, int str);\n    void echoDisplay(String i, int str, int x);\n    void ReadPins();\n    void loopth();\n    void EndLoop();\n    void SetState(State* state);\n    void ReadEEPROM();\n    void ResetEEPROM();\n};\n#endif\n\n", "comment_ratio": 0.11290322580645161}
{"lang": "c", "code": "#import \"NSObject.h\"\n\n@interface IFlyContact : NSObject\n{\n}\n\n- (id)toString:(id)arg1;\n- (id)contact;\n\n@end\n\n\n", "comment_ratio": 0.2777777777777778}
{"lang": "c", "code": "#ifndef NOTELIB_UTIL_CIRCULAR_BUFFER_H_\r\n#define NOTELIB_UTIL_CIRCULAR_BUFFER_H_\r\n\r\n#include \"circular_buffer_interface.h\"\r\n\r\n#include \"../internal/circular_buffer.h\"\r\n\r\n#include <stdalign.h>\r\n#include <stdbool.h>\r\n#include <stddef.h>\r\n#include \"stdint.h\"\r\n\r\n#ifndef NOTELIB_UTIL_CIRCULAR_BUFFER_DATA_ALIGNMENT\r\n#define NOTELIB_UTIL_CIRCULAR_BUFFER_DATA_ALIGNMENT alignof(max_align_t)\r\n#endif//#ifndef NOTELIB_UTIL_CIRCULAR_BUFFER_DATA_ALIGNMENT\r\n\r\n///These are two thread-safe lock-free queue-like data structures.\r\n///Please note: Due to a current design flaw/oddity (it's not that big of a deal) they require one buffer element, and so don't support taking advantage of all their data space (\"empty\" and \"full\" states were not differentiated).\r\n\r\n//Data size is always an integer multiple of element_size and only one element can be read and written at a time => guarantees contiguous memory.\r\nstruct circular_buffer{\r\n\t//customization idea: \"perfect solution\" algorithm (halving max element_count) by \"collaborative\" \"everything written\" bit of XORed top bits of both positions\r\n\t_Atomic uint16_t reader_position;\r\n\t_Atomic uint16_t writer_position;\r\n\tuint16_t  element_size;\r\n\tuint16_t element_count;\r\n\talignas(NOTELIB_UTIL_CIRCULAR_BUFFER_DATA_ALIGNMENT)\r\n\tunsigned char data[];\r\n};\r\n\r\nenum {circular_buffer_header_size =\r\n\toffsetof(struct circular_buffer, data)};\r\n\r\n//Data size is arbitrary; reading always happens by memcpy-ing into a caller-provided buffer.\r\nstruct circular_buffer_liberal_reader_unsynchronized{\r\n\t_Atomic uint32_t reader_position;\r\n\tuint32_t writer_position;\r\n\tuint32_t data_size;\r\n\tunsigned char data[];\r\n};\r\n\r\nenum {circular_buffer_liberal_reader_unsynchronized_header_size =\r\n\toffsetof(struct circular_buffer_liberal_reader_unsynchronized, data)};\r\n\r\n#endif//#ifndef NOTELIB_UTIL_CIRCULAR_BUFFER_H_\r\n\n", "comment_ratio": 0.15217391304347827}
{"lang": "c", "code": "#ifndef MMLUA4ANDROID_MMBRIDGE_H\n#define MMLUA4ANDROID_MMBRIDGE_H\n\n#include \"lua.h\"\n\nvoid mm_openlibs(lua_State *L, int debug);\n\n#endif //MMLUA4ANDROID_MMBRIDGE_H\n", "comment_ratio": 0.21052631578947367}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n\n@protocol FilterViewControllerDelegate <NSObject>\n\n-(void) didPickedFromDate:(NSDate *)fromDate andToDate:(NSDate *)toDate;\n-(void) didPressCancel;\n@end\n\n@interface FilterViewController : UIViewController\n@property (nonatomic, weak) id <FilterViewControllerDelegate> delegate;\n@end\n\n", "comment_ratio": 0.35}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n#import <pthread.h>\n#import \"STKDataSource.h\"\n#import <AudioToolbox/AudioToolbox.h>\n\n#if TARGET_OS_IPHONE\n#include \"UIKit/UIApplication.h\"\n#endif\n\nNS_ASSUME_NONNULL_BEGIN\n\ntypedef NS_OPTIONS(NSInteger, STKAudioPlayerState)\n{\n    STKAudioPlayerStateReady,\n    STKAudioPlayerStateRunning = 1,\n    STKAudioPlayerStatePlaying = (1 << 1) | STKAudioPlayerStateRunning,\n    STKAudioPlayerStateBuffering = (1 << 2) | STKAudioPlayerStateRunning,\n    STKAudioPlayerStatePaused = (1 << 3) | STKAudioPlayerStateRunning,\n    STKAudioPlayerStateStopped = (1 << 4),\n    STKAudioPlayerStateError = (1 << 5),\n    STKAudioPlayerStateDisposed = (1 << 6)\n};\n\ntypedef NS_ENUM(NSInteger, STKAudioPlayerStopReason)\n{\n\tSTKAudioPlayerStopReasonNone = 0,\n\tSTKAudioPlayerStopReasonEof,\n\tSTKAudioPlayerStopReasonUserAction,\n\tSTKAudioPlayerStopReasonPendingNext,\n\tSTKAudioPlayerStopReasonDisposed,\n\tSTKAudioPlayerStopReasonError = 0xffff\n};\n\ntypedef NS_ENUM(NSInteger, STKAudioPlayerErrorCode)\n{\n\tSTKAudioPlayerErrorNone = 0,\n\tSTKAudioPlayerErrorDataSource,\n    STKAudioPlayerErrorStreamParseBytesFailed,\n    STKAudioPlayerErrorAudioSystemError,\n    STKAudioPlayerErrorCodecError,\n    STKAudioPlayerErrorDataNotFound,\n    STKAudioPlayerErrorOther = 0xffff\n};\n\n///\n/// Options to initiailise the Audioplayer with.\n/// By default if you set buffer size or seconds to 0, the non-zero default will be used\n/// If you would like to disable the buffer option completely set to STK_DISABLE_BUFFER\n///\ntypedef struct\n{\n    /// If YES then seeking a track will cause all pending items to be flushed from the queue\n    BOOL flushQueueOnSeek;\n    /// If YES then volume control will be enabled on iOS\n    BOOL enableVolumeMixer;\n    /// A pointer to a 0 terminated array of band frequencies (iOS 5.0 and later, OSX 10.9 and later)\n    Float32 equalizerBandFrequencies[24];\n\t/// The size of the internal I/O read buffer. This data in this buffer is transient and does not need to be larger.\n    UInt32 readBufferSize;\n    /// The size of the decompressed buffer (Default is 10 seconds which uses about 1.7MB of RAM)\n    Float32 bufferSizeInSeconds;\n    /// Number of seconds of decompressed audio is required before playback first starts for each item (Default is 0.5 seconds. Must be larger than bufferSizeInSeconds)\n    Float32 secondsRequiredToStartPlaying;\n\t/// Seconds after a seek is performed before data needs to come in (after which the state will change to playing/buffering)\n    Float32 gracePeriodAfterSeekInSeconds;\n    /// Number of seconds of decompressed audio required before playback resumes after a buffer underrun (Default is 5 seconds. Must be larger than bufferSizeinSeconds)\n    Float32 secondsRequiredToStartPlayingAfterBufferUnderun;\n}\nSTKAudioPlayerOptions;\n\n#define STK_DISABLE_BUFFER (0xffffffff)\n\ntypedef void(^STKFrameFilter)(UInt32 channelsPerFrame, UInt32 bytesPerFrame, UInt32 frameCount, void* frames);\n\n@interface STKFrameFilterEntry : NSObject\n@property (readonly) NSString* name;\n@property (readonly) STKFrameFilter filter;\n@end\n\n@class STKAudioPlayer;\n\n@protocol STKAudioPlayerDelegate <NSObject>\n\n/// Raised when an item has started playing\n-(void) audioPlayer:(STKAudioPlayer*)audioPlayer didStartPlayingQueueItemId:(NSObject*)queueItemId;\n/// Raised when an item has finished buffering (may or may not be the currently playing item)\n/// This event may be raised multiple times for the same item if seek is invoked on the player\n-(void) audioPlayer:(STKAudioPlayer*)audioPlayer didFinishBufferingSourceWithQueueItemId:(NSObject*)queueItemId;\n/// Raised when the state of the player has changed\n-(void) audioPlayer:(STKAudioPlayer*)audioPlayer stateChanged:(STKAudioPlayerState)state previousState:(STKAudioPlayerState)previousState;\n/// Raised when an item has finished playing\n-(void) audioPlayer:(STKAudioPlayer*)audioPlayer didFinishPlayingQueueItemId:(NSObject*)queueItemId withReason:(STKAudioPlayerStopReason)stopReason andProgress:(double)progress andDuration:(double)duration;\n/// Raised when an unexpected and possibly unrecoverable error has occured (usually best to recreate the STKAudioPlauyer)\n-(void) audioPlayer:(STKAudioPlayer*)audioPlayer unexpectedError:(STKAudioPlayerErrorCode)errorCode;\n@optional\n/// Optionally implemented to get logging information from the STKAudioPlayer (used internally for debugging)\n-(void) audioPlayer:(STKAudioPlayer*)audioPlayer logInfo:(NSString*)line;\n/// Raised when items queued items are cleared (usually because of a call to play, setDataSource or stop)\n-(void) audioPlayer:(STKAudioPlayer*)audioPlayer didCancelQueuedItems:(NSArray*)queuedItems;\n\n/// Raised when datasource read stream metadata. Called from the non-main thread.\n-(void) audioPlayer:(STKAudioPlayer*)audioPlayer didReadStreamMetadata:(NSDictionary*)dictionary;\n\n@end\n\n@interface STKAudioPlayer : NSObject<STKDataSourceDelegate>\n\n/// Gets or sets the volume (ranges 0 - 1.0).\n/// On iOS the STKAudioPlayerOptionEnableMultichannelMixer option must be enabled for volume to work.\n@property (readwrite) Float32 volume;\n/// Gets or sets the player muted state\n@property (readwrite) BOOL muted;\n/// Gets the current item duration in seconds\n@property (readonly) double duration;\n/// Gets the current item progress in seconds\n@property (readonly) double progress;\n/// Gets or sets the playback rate (default is 1.0)\n@property(readwrite) float rate;\n// Gets or sets the playback overlap (default is 8.0)\n@property(readwrite) float overlap;\n/// Enables or disables peak and average decibel meteting\n@property (readwrite) BOOL meteringEnabled;\n/// Enables or disables the EQ\n@property (readwrite) BOOL equalizerEnabled;\n/// Returns an array of STKFrameFilterEntry objects representing the filters currently in use\n@property (readonly, nullable) NSArray* frameFilters;\n/// Returns the items pending to be played (includes buffering and upcoming items but does not include the current item)\n@property (readonly) NSArray* pendingQueue;\n/// The number of items pending to be played (includes buffering and upcoming items but does not include the current item)\n@property (readonly) NSUInteger pendingQueueCount;\n/// Gets the most recently queued item that is still pending to play\n@property (readonly, nullable) NSObject* mostRecentlyQueuedStillPendingItem;\n/// Gets the current state of the player\n@property (readwrite) STKAudioPlayerState state;\n/// Gets the options provided to the player on startup\n@property (readonly) STKAudioPlayerOptions options;\n/// Gets the reason why the player is stopped (if any)\n@property (readonly) STKAudioPlayerStopReason stopReason;\n/// Gets and sets the delegate used for receiving events from the STKAudioPlayer\n@property (readwrite, weak) id<STKAudioPlayerDelegate> delegate;\n\n/// Creates a datasource from a given URL.\n/// URLs with FILE schemes will return an STKLocalFileDataSource.\n/// URLs with HTTP schemes will return an STKHTTPDataSource wrapped within an STKAutoRecoveringHTTPDataSource.\n/// URLs with unrecognised schemes will return nil.\n+(STKDataSource*) dataSourceFromURL:(NSURL*)url;\n\n/// Returns canonical audio format used by STKFrameFilter blocks.\n+(AudioStreamBasicDescription)canonicalAudioStreamBasicDescription;\n\n/// Initializes a new STKAudioPlayer with the default options\n-(instancetype) init;\n\n/// Initializes a new STKAudioPlayer with the given options\n-(instancetype) initWithOptions:(STKAudioPlayerOptions)optionsIn;\n\n/// Plays an item from the given URL string (all pending queued items are removed).\n/// The NSString is used as the queue item ID\n-(void) play:(NSString*)urlString;\n\n/// Plays an item from the given URL (all pending queued items are removed)\n-(void) play:(NSString*)urlString withQueueItemID:(NSObject*)queueItemId;\n\n/// Plays an item from the given URL (all pending queued items are removed)\n/// The NSURL is used as the queue item ID\n-(void) playURL:(NSURL*)url;\n\n/// Plays an item from the given URL (all pending queued items are removed)\n-(void) playURL:(NSURL*)url withQueueItemID:(NSObject*)queueItemId;\n\n/// Plays the given item (all pending queued items are removed)\n/// The STKDataSource is used as the queue item ID\n-(void) playDataSource:(STKDataSource*)dataSource;\n\n/// Plays the given item (all pending queued items are removed)\n-(void) playDataSource:(STKDataSource*)dataSource withQueueItemID:(NSObject*)queueItemId;\n\n/// Queues the URL string for playback and uses the NSString as the queueItemID\n-(void) queue:(NSString*)urlString;\n\n/// Queues the URL string for playback with the given queueItemID\n-(void) queue:(NSString*)urlString withQueueItemId:(NSObject*)queueItemId;\n\n/// Queues the URL for playback and uses the NSURL as the queueItemID\n-(void) queueURL:(NSURL*)url;\n\n/// Queues the URL for playback with the given queueItemID\n-(void) queueURL:(NSURL*)url withQueueItemId:(NSObject*)queueItemId;\n\n/// Queues a DataSource with the given queueItemId\n-(void) queueDataSource:(STKDataSource*)dataSource withQueueItemId:(NSObject*)queueItemId;\n\n/// Plays the given item (all pending queued items are removed)\n-(void) setDataSource:(STKDataSource*)dataSourceIn withQueueItemId:(NSObject*)queueItemId;\n\n/// Seeks to a specific time (in seconds)\n-(void) seekToTime:(double)value;\n\n/// Clears any upcoming items already queued for playback (does not stop the current item).\n/// The didCancelItems event will be raised for the items removed from the queue.\n-(void) clearQueue;\n\n/// Pauses playback\n-(void) pause;\n\n/// Resumes playback from pause\n-(void) resume;\n\n/// Stops playback of the current file, flushes all the buffers and removes any pending queued items\n-(void) stop;\n\n/// Mutes playback\n-(void) mute;\n\n/// Unmutes playback\n-(void) unmute;\n\n/// Disposes the STKAudioPlayer and frees up all resources before returning\n-(void) dispose;\n\n/// The QueueItemId of the currently playing item\n-(NSObject*) currentlyPlayingQueueItemId;\n\n/// Removes a frame filter with the given name\n-(void) removeFrameFilterWithName:(NSString*)name;\n\n/// Appends a frame filter with the given name and filter block to the end of the filter chain\n-(void) appendFrameFilterWithName:(NSString*)name block:(STKFrameFilter)block;\n\n/// Appends a frame filter with the given name and filter block just after the filter with the given name.\n/// If the given name is nil, the filter will be inserted at the beginning of the filter change\n-(void) addFrameFilterWithName:(NSString*)name afterFilterWithName:(nullable NSString*)afterFilterWithName block:(STKFrameFilter)block;\n\n/// Reads the peak power in decibals for the given channel (0 or 1).\n/// Return values are between -60 (low) and 0 (high).\n-(float) peakPowerInDecibelsForChannel:(NSUInteger)channelNumber;\n\n/// Reads the average power in decibals for the given channel (0 or 1)\n/// Return values are between -60 (low) and 0 (high).\n-(float) averagePowerInDecibelsForChannel:(NSUInteger)channelNumber;\n\n/// Sets the gain value (from -96 low to +24 high) for an equalizer band (0 based index)\n-(void) setGain:(float)gain forEqualizerBand:(int)bandIndex;\n\n@end\n\nNS_ASSUME_NONNULL_END\n\n", "comment_ratio": 0.28771929824561404}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface UIColor (Hex)\n\n/**\n 16\u8fdb\u5236\u989c\u8272\u8f6c\u6362\u4e3aUIColor\n \n @param hexColor 16\u8fdb\u5236\u5b57\u7b26\u4e32\uff08\u53ef\u4ee5\u4ee50x\u5f00\u5934\uff0c\u53ef\u4ee5\u4ee5#\u5f00\u5934\uff0c\u4e5f\u53ef\u4ee5\u5c31\u662f6\u4f4d\u768416\u8fdb\u5236\uff09\n @param opacity \u900f\u660e\u5ea6\n @return 16\u8fdb\u5236\u5b57\u7b26\u4e32\u5bf9\u5e94\u7684\u989c\u8272\n */\n+ (UIColor *)colorWithHexString:(NSString *)hexColor alpha:(float)opacity;\n\n@end\n\nNS_ASSUME_NONNULL_END\n\n", "comment_ratio": 0.25925925925925924}
{"lang": "c", "code": "#import \"NSOperation.h\"\n\n@class KHLayout, NSImage, NSString;\n\n@interface KHLayoutThumbnailer : NSOperation\n{\n    KHLayout *_layout;\n    struct CGRect _thumbRect;\n    NSImage *_gutterArt;\n    NSImage *_image;\n    int _shadowStyle;\n    unsigned long long _renderingIntent;\n    id <KHLayoutThumbnailerDelegate> _delegate;\n    id _userInfo;\n    struct CGImage *_CGImage;\n    NSString *_placeHolderContrast;\n    int _facing;\n    BOOL _shouldIgnoreDrawingBadges;\n    BOOL _shouldIgnoreDrawingTexts;\n    double _renderScaleMultiplier;\n}\n\n+ (struct CGRect)frameForLayout:(id)arg1 inThumbRect:(struct CGRect)arg2 shadowStyle:(int)arg3;\n@property(nonatomic) double renderScaleMultiplier; // @synthesize renderScaleMultiplier=_renderScaleMultiplier;\n@property(nonatomic) BOOL shouldIgnoreDrawingTexts; // @synthesize shouldIgnoreDrawingTexts=_shouldIgnoreDrawingTexts;\n@property(nonatomic) BOOL shouldIgnoreDrawingBadges; // @synthesize shouldIgnoreDrawingBadges=_shouldIgnoreDrawingBadges;\n- (void)main;\n- (int)shadowStyle;\n- (id)layout;\n- (id)userInfo;\n- (struct CGImage *)CGImage;\n- (id)image;\n- (id)initWithLayout:(id)arg1 thumbRect:(struct CGRect)arg2 shadowStyle:(int)arg3 gutterArt:(id)arg4 placeHolderContrast:(id)arg5 facing:(int)arg6 renderingIntent:(unsigned long long)arg7 delegate:(id)arg8 userInfo:(id)arg9;\n- (id)initWithLayout:(id)arg1 thumbRect:(struct CGRect)arg2 shadowStyle:(int)arg3 gutterArt:(id)arg4 placeHolderContrast:(id)arg5 facing:(int)arg6 renderingIntent:(unsigned long long)arg7;\n- (void)dealloc;\n\n@end\n\n\n", "comment_ratio": 0.17777777777777778}
{"lang": "c", "code": "#ifndef TENSORFLOW_LITE_DELEGATES_GPU_CL_KERNELS_POOLING_H_\n#define TENSORFLOW_LITE_DELEGATES_GPU_CL_KERNELS_POOLING_H_\n\n#include \"tensorflow/lite/delegates/gpu/cl/cl_kernel.h\"\n#include \"tensorflow/lite/delegates/gpu/cl/kernels/gpu_operation.h\"\n#include \"tensorflow/lite/delegates/gpu/cl/tensor.h\"\n#include \"tensorflow/lite/delegates/gpu/common/operations.h\"\n#include \"tensorflow/lite/delegates/gpu/common/status.h\"\n#include \"tensorflow/lite/delegates/gpu/common/types.h\"\n\nnamespace tflite {\nnamespace gpu {\nnamespace cl {\n\nGPUOperation CreatePooling(const OperationDef& definition,\n                           const Pooling2DAttributes& attr);\n\nGPUOperation CreatePooling(const OperationDef& definition,\n                           const Pooling3DAttributes& attr);\n\n}  // namespace cl\n}  // namespace gpu\n}  // namespace tflite\n\n#endif  // TENSORFLOW_LITE_DELEGATES_GPU_CL_KERNELS_POOLING_H_\n\n", "comment_ratio": 0.12195121951219512}
{"lang": "c", "code": "#ifndef __CRYPTOOL_TOOLS_H\n#define __CRYPTOOL_TOOLS_H\n\n#include \"stdafx.h\"\n#include \"CrypToolApp.h\"\n\nBOOL CheckAlphabet (int minSize = 1);\nBOOL CheckTextSize (SymbolArray &text, int Threshold = 1);\nvoid LoadText      (const char *infile, SymbolArray &text);\nvoid GetNewDocTitle(const char* keyStr, const char* OldTitle, \n\t\t\t\t\tint IDS_STRING_ID, char* title, long titleLength, BOOL Decrypt = FALSE, \n\t\t\t\t\tint KeyType = SCHLUESSEL_LINEAR );\n\nvoid OpenNewDoc    (const char *outfile, const char* keyStr, const char* OldTitle, \n\t\t\t\t\tint IDS_STRING_ID, BOOL Decrypt = FALSE, int KeyType = SCHLUESSEL_LINEAR );\n\nchar* itoa_fmt(int i_num, char *c_buffer = NULL, int i_base = 10 );\nchar* itoa_fmt(__int64 i_num, char *c_buffer = NULL, int i_base = 10 );\nchar* double_fmt(double d_num, char *c_buffer, int prec = 2);\n\nunsigned long CT_OPEN_REGISTRY_SETTINGS\t(unsigned long MODE_ACCESS, int ID_REGISTRY_PATH, const char *SUB_FOLDER = 0);\nvoid CT_CLOSE_REGISTRY();\nBOOL CT_READ_REGISTRY\t\t\t(unsigned long &value,\t\t const char *ID);\nBOOL CT_READ_REGISTRY\t\t\t(char *value,               const char *ID, unsigned long &length);\nBOOL CT_READ_REGISTRY_DEFAULT\t(unsigned long &value,\t\t const char *ID, const unsigned long default_value);\nBOOL CT_READ_REGISTRY_DEFAULT\t(char *value,               const char *ID, \n                               const char *default_value, unsigned long &length ); \nBOOL CT_WRITE_REGISTRY\t\t\t(const unsigned long value, const char *ID);\nBOOL CT_WRITE_REGISTRY\t\t\t(const char *value,         const char *ID);\n\n// see implementation\nCString extractValueFromStringByKey(CString _key, CString _string);\n\n// see implementation\nstd::vector<CString> splitString(const CString &_string, const CString &_separator);\n\n// see implementation\nbool isAppDataDirectoryDefined();\n// see implementation\nbool isJavaAvailable(const CString &_version);\n// see implementation\nvoid ShellExecuteJava(const CString &_javaProgram, const CString &_javaProgramCompleteCall, const CString &_path);\n\n// see implementation\nCString adaptKeyToAlphabet(const CString _key);\n\n// see implementation(s)\nchar getIntegralNumberSeparator();\nchar getFractionalNumberSeparator();\nCString createStringNumberWithDigitGrouping(const int &_number);\nCString createStringNumberWithDigitGrouping(const unsigned int &_number);\nCString createStringNumberWithDigitGrouping(const long &_number);\nCString createStringNumberWithDigitGrouping(const unsigned long &_number);\nCString createStringNumberWithDigitGrouping(const float &_number, const unsigned int &_numberOfDecimalPlaces = 2);\nCString createStringNumberWithDigitGrouping(const double &_number, const unsigned int &_numberOfDecimalPlaces = 2);\nCString createStringNumberWithDigitGrouping(const CString &_number);\n\n// see implementation\nCString removeNonAlphabetCharacters(CString &_text, const CString &_alphabet);\n\n#endif\n\n\n\n", "comment_ratio": 0.10714285714285714}
{"lang": "c", "code": "#ifndef SRC_MEDIA_AUDIO_AUDIO_CORE_AUDIO_PLUG_DETECTOR_IMPL_H_\n#define SRC_MEDIA_AUDIO_AUDIO_CORE_AUDIO_PLUG_DETECTOR_IMPL_H_\n\n#include <memory>\n#include <vector>\n\n#include \"src/lib/fsl/io/device_watcher.h\"\n#include \"src/media/audio/audio_core/audio_plug_detector.h\"\n\nnamespace media::audio {\n\nclass AudioPlugDetectorImpl : public AudioPlugDetector {\n public:\n  zx_status_t Start(Observer o) final;\n  void Stop() final;\n\n private:\n  void AddAudioDevice(int dir_fd, const std::string& name, bool is_input);\n\n  Observer observer_;\n  std::vector<std::unique_ptr<fsl::DeviceWatcher>> watchers_;\n};\n\n}  // namespace media::audio\n\n#endif  // SRC_MEDIA_AUDIO_AUDIO_CORE_AUDIO_PLUG_DETECTOR_IMPL_H_\n\n", "comment_ratio": 0.16129032258064516}
{"lang": "c", "code": "#ifndef GPOPT_CPhysicalFullMergeJoin_H\n#define GPOPT_CPhysicalFullMergeJoin_H\n\n#include \"gpos/base.h\"\n#include \"gpopt/operators/CPhysicalJoin.h\"\n\nnamespace gpopt\n{\n\n\tclass CPhysicalFullMergeJoin : public CPhysicalJoin\n\t{\n\n\t\tprivate:\n\n\t\t\t// private copy ctor\n\t\t\tCPhysicalFullMergeJoin(const CPhysicalFullMergeJoin &);\n\n\t\t\tCExpressionArray *m_outer_merge_clauses;\n\n\t\t\tCExpressionArray *m_inner_merge_clauses;\n\n\t\tpublic:\n\n\t\t\t// ctor\n\t\t\texplicit\n\t\t\tCPhysicalFullMergeJoin(CMemoryPool *mp,\n\t\t\t\t\t\t\t\t   CExpressionArray *outer_merge_clauses,\n\t\t\t\t\t\t\t\t   CExpressionArray *inner_merge_clauses);\n\n\t\t\t// dtor\n\t\t\tvirtual\n\t\t\t~CPhysicalFullMergeJoin();\n\n\t\t\t// ident accessors\n\t\t\tvirtual\n\t\t\tEOperatorId Eopid() const\n\t\t\t{\n\t\t\t\treturn EopPhysicalFullMergeJoin;\n\t\t\t}\n\n\t\t\t // return a string for operator name\n\t\t\tvirtual\n\t\t\tconst CHAR *SzId() const\n\t\t\t{\n\t\t\t\treturn \"CPhysicalFullMergeJoin\";\n\t\t\t}\n\n\t\t\t// conversion function\n\t\t\tstatic\n\t\t\tCPhysicalFullMergeJoin *PopConvert\n\t\t\t\t(\n\t\t\t\tCOperator *pop\n\t\t\t\t)\n\t\t\t{\n\t\t\t\tGPOS_ASSERT(EopPhysicalFullMergeJoin == pop->Eopid());\n\n\t\t\t\treturn dynamic_cast<CPhysicalFullMergeJoin*>(pop);\n\t\t\t}\n\n\t\t\tvirtual\n\t\t\tCDistributionSpec *PdsRequired\n\t\t\t\t(\n\t\t\t\tCMemoryPool *mp,\n\t\t\t\tCExpressionHandle &exprhdl,\n\t\t\t\tCDistributionSpec *pdsRequired,\n\t\t\t\tULONG child_index,\n\t\t\t\tCDrvdProp2dArray *pdrgpdpCtxt,\n\t\t\t\tULONG ulOptReq\n\t\t\t\t)\n\t\t\t\tconst;\n\n\t\t\tvirtual\n\t\t\tCOrderSpec *PosRequired\n\t\t\t\t(\n\t\t\t\tCMemoryPool *mp,\n\t\t\t\tCExpressionHandle &exprhdl,\n\t\t\t\tCOrderSpec *posInput,\n\t\t\t\tULONG child_index,\n\t\t\t\tCDrvdProp2dArray *pdrgpdpCtxt,\n\t\t\t\tULONG ulOptReq\n\t\t\t\t)\n\t\t\t\tconst;\n\n\t\t\t// compute required rewindability of the n-th child\n\t\t\tvirtual\n\t\t\tCRewindabilitySpec *PrsRequired\n\t\t\t\t(\n\t\t\t\tCMemoryPool *mp,\n\t\t\t\tCExpressionHandle &exprhdl,\n\t\t\t\tCRewindabilitySpec *prsRequired,\n\t\t\t\tULONG child_index,\n\t\t\t\tCDrvdProp2dArray *pdrgpdpCtxt,\n\t\t\t\tULONG ulOptReq\n\t\t\t\t)\n\t\t\t\tconst;\n\n\t\t\t// return order property enforcing type for this operator\n\t\t\tvirtual\n\t\t\tCEnfdProp::EPropEnforcingType EpetOrder\n\t\t\t\t(\n\t\t\t\tCExpressionHandle &exprhdl,\n\t\t\t\tconst CEnfdOrder *peo\n\t\t\t\t) const;\n\n\t\t\tvirtual\n\t\t\tCEnfdDistribution::EDistributionMatching Edm\n\t\t\t\t(\n\t\t\t\tCReqdPropPlan *, // prppInput\n\t\t\t\tULONG , //child_index,\n\t\t\t\tCDrvdProp2dArray *, // pdrgpdpCtxt,\n\t\t\t\tULONG // ulOptReq\n\t\t\t\t);\n\n\t\t\tvirtual\n\t\t\tCDistributionSpec *PdsDerive\n\t\t\t\t(\n\t\t\t\t\tCMemoryPool *mp,\n\t\t\t\t\tCExpressionHandle &exprhdl\n\t\t\t\t) const;\n\n\t}; // class CPhysicalFullMergeJoin\n\n}\n\n#endif // !GPOPT_CPhysicalFullMergeJoin_H\n\n// EOF\n\n", "comment_ratio": 0.1297709923664122}
{"lang": "c", "code": "#ifndef V8_HEAP_MARK_COMPACT_H_\n#define V8_HEAP_MARK_COMPACT_H_\n\n#include <atomic>\n#include <vector>\n\n#include \"src/heap/concurrent-marking.h\"\n#include \"src/heap/marking-visitor.h\"\n#include \"src/heap/marking.h\"\n#include \"src/heap/spaces.h\"\n#include \"src/heap/sweeper.h\"\n\nnamespace v8 {\nnamespace internal {\n\n// Forward declarations.\nclass EvacuationJobTraits;\nclass HeapObjectVisitor;\nclass ItemParallelJob;\nclass MigrationObserver;\nclass RecordMigratedSlotVisitor;\nclass UpdatingItem;\nclass YoungGenerationMarkingVisitor;\n\nclass MarkBitCellIterator {\n public:\n  MarkBitCellIterator(MemoryChunk* chunk, Bitmap* bitmap) : chunk_(chunk) {\n    last_cell_index_ =\n        Bitmap::IndexToCell(chunk_->AddressToMarkbitIndex(chunk_->area_end()));\n    cell_base_ = chunk_->address();\n    cell_index_ =\n        Bitmap::IndexToCell(chunk_->AddressToMarkbitIndex(cell_base_));\n    cells_ = bitmap->cells();\n  }\n\n  inline bool Done() { return cell_index_ >= last_cell_index_; }\n\n  inline bool HasNext() { return cell_index_ < last_cell_index_ - 1; }\n\n  inline MarkBit::CellType* CurrentCell() {\n    DCHECK_EQ(cell_index_, Bitmap::IndexToCell(Bitmap::CellAlignIndex(\n                               chunk_->AddressToMarkbitIndex(cell_base_))));\n    return &cells_[cell_index_];\n  }\n\n  inline Address CurrentCellBase() {\n    DCHECK_EQ(cell_index_, Bitmap::IndexToCell(Bitmap::CellAlignIndex(\n                               chunk_->AddressToMarkbitIndex(cell_base_))));\n    return cell_base_;\n  }\n\n  V8_WARN_UNUSED_RESULT inline bool Advance() {\n    cell_base_ += Bitmap::kBitsPerCell * kTaggedSize;\n    return ++cell_index_ != last_cell_index_;\n  }\n\n  inline bool Advance(unsigned int new_cell_index) {\n    if (new_cell_index != cell_index_) {\n      DCHECK_GT(new_cell_index, cell_index_);\n      DCHECK_LE(new_cell_index, last_cell_index_);\n      unsigned int diff = new_cell_index - cell_index_;\n      cell_index_ = new_cell_index;\n      cell_base_ += diff * (Bitmap::kBitsPerCell * kTaggedSize);\n      return true;\n    }\n    return false;\n  }\n\n  // Return the next mark bit cell. If there is no next it returns 0;\n  inline MarkBit::CellType PeekNext() {\n    if (HasNext()) {\n      return cells_[cell_index_ + 1];\n    }\n    return 0;\n  }\n\n private:\n  MemoryChunk* chunk_;\n  MarkBit::CellType* cells_;\n  unsigned int last_cell_index_;\n  unsigned int cell_index_;\n  Address cell_base_;\n};\n\nenum LiveObjectIterationMode { kBlackObjects, kGreyObjects, kAllLiveObjects };\n\ntemplate <LiveObjectIterationMode mode>\nclass LiveObjectRange {\n public:\n  class iterator {\n   public:\n    using value_type = std::pair<HeapObject, int /* size */>;\n    using pointer = const value_type*;\n    using reference = const value_type&;\n    using iterator_category = std::forward_iterator_tag;\n\n    inline iterator(MemoryChunk* chunk, Bitmap* bitmap, Address start);\n\n    inline iterator& operator++();\n    inline iterator operator++(int);\n\n    bool operator==(iterator other) const {\n      return current_object_ == other.current_object_;\n    }\n\n    bool operator!=(iterator other) const { return !(*this == other); }\n\n    value_type operator*() {\n      return std::make_pair(current_object_, current_size_);\n    }\n\n   private:\n    inline void AdvanceToNextValidObject();\n\n    MemoryChunk* const chunk_;\n    Map const one_word_filler_map_;\n    Map const two_word_filler_map_;\n    Map const free_space_map_;\n    MarkBitCellIterator it_;\n    Address cell_base_;\n    MarkBit::CellType current_cell_;\n    HeapObject current_object_;\n    int current_size_;\n  };\n\n  LiveObjectRange(MemoryChunk* chunk, Bitmap* bitmap)\n      : chunk_(chunk),\n        bitmap_(bitmap),\n        start_(chunk_->area_start()),\n        end_(chunk->area_end()) {\n    DCHECK(!chunk->IsLargePage());\n  }\n\n  inline iterator begin();\n  inline iterator end();\n\n private:\n  MemoryChunk* const chunk_;\n  Bitmap* bitmap_;\n  Address start_;\n  Address end_;\n};\n\nclass LiveObjectVisitor : AllStatic {\n public:\n  enum IterationMode {\n    kKeepMarking,\n    kClearMarkbits,\n  };\n\n  // Visits black objects on a MemoryChunk until the Visitor returns |false| for\n  // an object. If IterationMode::kClearMarkbits is passed the markbits and\n  // slots for visited objects are cleared for each successfully visited object.\n  template <class Visitor, typename MarkingState>\n  static bool VisitBlackObjects(MemoryChunk* chunk, MarkingState* state,\n                                Visitor* visitor, IterationMode iteration_mode,\n                                HeapObject* failed_object);\n\n  // Visits black objects on a MemoryChunk. The visitor is not allowed to fail\n  // visitation for an object.\n  template <class Visitor, typename MarkingState>\n  static void VisitBlackObjectsNoFail(MemoryChunk* chunk, MarkingState* state,\n                                      Visitor* visitor,\n                                      IterationMode iteration_mode);\n\n  // Visits black objects on a MemoryChunk. The visitor is not allowed to fail\n  // visitation for an object.\n  template <class Visitor, typename MarkingState>\n  static void VisitGreyObjectsNoFail(MemoryChunk* chunk, MarkingState* state,\n                                     Visitor* visitor,\n                                     IterationMode iteration_mode);\n\n  template <typename MarkingState>\n  static void RecomputeLiveBytes(MemoryChunk* chunk, MarkingState* state);\n};\n\nenum PageEvacuationMode { NEW_TO_NEW, NEW_TO_OLD };\nenum MarkingTreatmentMode { KEEP, CLEAR };\nenum class RememberedSetUpdatingMode { ALL, OLD_TO_NEW_ONLY };\n\n// Base class for minor and full MC collectors.\nclass MarkCompactCollectorBase {\n public:\n  static const int kMainThread = 0;\n\n  virtual ~MarkCompactCollectorBase() = default;\n\n  virtual void SetUp() = 0;\n  virtual void TearDown() = 0;\n  virtual void CollectGarbage() = 0;\n\n  inline Heap* heap() const { return heap_; }\n  inline Isolate* isolate();\n\n protected:\n  explicit MarkCompactCollectorBase(Heap* heap)\n      : heap_(heap), old_to_new_slots_(0) {}\n\n  // Marking operations for objects reachable from roots.\n  virtual void MarkLiveObjects() = 0;\n  // Mark objects reachable (transitively) from objects in the marking\n  // work list.\n  virtual void ProcessMarkingWorklist() = 0;\n  // Clear non-live references held in side data structures.\n  virtual void ClearNonLiveReferences() = 0;\n  virtual void EvacuatePrologue() = 0;\n  virtual void EvacuateEpilogue() = 0;\n  virtual void Evacuate() = 0;\n  virtual void EvacuatePagesInParallel() = 0;\n  virtual void UpdatePointersAfterEvacuation() = 0;\n  virtual UpdatingItem* CreateToSpaceUpdatingItem(MemoryChunk* chunk,\n                                                  Address start,\n                                                  Address end) = 0;\n  virtual UpdatingItem* CreateRememberedSetUpdatingItem(\n      MemoryChunk* chunk, RememberedSetUpdatingMode updating_mode) = 0;\n\n  template <class Evacuator, class Collector>\n  void CreateAndExecuteEvacuationTasks(Collector* collector,\n                                       ItemParallelJob* job,\n                                       MigrationObserver* migration_observer,\n                                       const intptr_t live_bytes);\n\n  // Returns whether this page should be moved according to heuristics.\n  bool ShouldMovePage(Page* p, intptr_t live_bytes);\n\n  int CollectToSpaceUpdatingItems(ItemParallelJob* job);\n  template <typename IterateableSpace>\n  int CollectRememberedSetUpdatingItems(ItemParallelJob* job,\n                                        IterateableSpace* space,\n                                        RememberedSetUpdatingMode mode);\n\n  int NumberOfParallelCompactionTasks(int pages);\n  int NumberOfParallelPointerUpdateTasks(int pages, int slots);\n  int NumberOfParallelToSpacePointerUpdateTasks(int pages);\n\n  Heap* heap_;\n  // Number of old to new slots. Should be computed during MarkLiveObjects.\n  // -1 indicates that the value couldn't be computed.\n  int old_to_new_slots_;\n};\n\nclass MinorMarkingState final\n    : public MarkingStateBase<MinorMarkingState, AccessMode::ATOMIC> {\n public:\n  ConcurrentBitmap<AccessMode::ATOMIC>* bitmap(const MemoryChunk* chunk) const {\n    return chunk->young_generation_bitmap<AccessMode::ATOMIC>();\n  }\n\n  void IncrementLiveBytes(MemoryChunk* chunk, intptr_t by) {\n    chunk->young_generation_live_byte_count_ += by;\n  }\n\n  intptr_t live_bytes(MemoryChunk* chunk) const {\n    return chunk->young_generation_live_byte_count_;\n  }\n\n  void SetLiveBytes(MemoryChunk* chunk, intptr_t value) {\n    chunk->young_generation_live_byte_count_ = value;\n  }\n};\n\nclass MinorNonAtomicMarkingState final\n    : public MarkingStateBase<MinorNonAtomicMarkingState,\n                              AccessMode::NON_ATOMIC> {\n public:\n  ConcurrentBitmap<AccessMode::NON_ATOMIC>* bitmap(\n      const MemoryChunk* chunk) const {\n    return chunk->young_generation_bitmap<AccessMode::NON_ATOMIC>();\n  }\n\n  void IncrementLiveBytes(MemoryChunk* chunk, intptr_t by) {\n    chunk->young_generation_live_byte_count_.fetch_add(\n        by, std::memory_order_relaxed);\n  }\n\n  intptr_t live_bytes(MemoryChunk* chunk) const {\n    return chunk->young_generation_live_byte_count_.load(\n        std::memory_order_relaxed);\n  }\n\n  void SetLiveBytes(MemoryChunk* chunk, intptr_t value) {\n    chunk->young_generation_live_byte_count_.store(value,\n                                                   std::memory_order_relaxed);\n  }\n};\n\n// This marking state is used when concurrent marking is running.\nclass IncrementalMarkingState final\n    : public MarkingStateBase<IncrementalMarkingState, AccessMode::ATOMIC> {\n public:\n  ConcurrentBitmap<AccessMode::ATOMIC>* bitmap(const MemoryChunk* chunk) const {\n    DCHECK_EQ(reinterpret_cast<intptr_t>(&chunk->marking_bitmap_) -\n                  reinterpret_cast<intptr_t>(chunk),\n              MemoryChunk::kMarkBitmapOffset);\n    return chunk->marking_bitmap<AccessMode::ATOMIC>();\n  }\n\n  // Concurrent marking uses local live bytes so we may do these accesses\n  // non-atomically.\n  void IncrementLiveBytes(MemoryChunk* chunk, intptr_t by) {\n    chunk->live_byte_count_ += by;\n  }\n\n  intptr_t live_bytes(MemoryChunk* chunk) const {\n    return chunk->live_byte_count_;\n  }\n\n  void SetLiveBytes(MemoryChunk* chunk, intptr_t value) {\n    chunk->live_byte_count_ = value;\n  }\n};\n\nclass MajorAtomicMarkingState final\n    : public MarkingStateBase<MajorAtomicMarkingState, AccessMode::ATOMIC> {\n public:\n  ConcurrentBitmap<AccessMode::ATOMIC>* bitmap(const MemoryChunk* chunk) const {\n    DCHECK_EQ(reinterpret_cast<intptr_t>(&chunk->marking_bitmap_) -\n                  reinterpret_cast<intptr_t>(chunk),\n              MemoryChunk::kMarkBitmapOffset);\n    return chunk->marking_bitmap<AccessMode::ATOMIC>();\n  }\n\n  void IncrementLiveBytes(MemoryChunk* chunk, intptr_t by) {\n    std::atomic_fetch_add(\n        reinterpret_cast<std::atomic<intptr_t>*>(&chunk->live_byte_count_), by);\n  }\n};\n\nclass MajorNonAtomicMarkingState final\n    : public MarkingStateBase<MajorNonAtomicMarkingState,\n                              AccessMode::NON_ATOMIC> {\n public:\n  ConcurrentBitmap<AccessMode::NON_ATOMIC>* bitmap(\n      const MemoryChunk* chunk) const {\n    DCHECK_EQ(reinterpret_cast<intptr_t>(&chunk->marking_bitmap_) -\n                  reinterpret_cast<intptr_t>(chunk),\n              MemoryChunk::kMarkBitmapOffset);\n    return chunk->marking_bitmap<AccessMode::NON_ATOMIC>();\n  }\n\n  void IncrementLiveBytes(MemoryChunk* chunk, intptr_t by) {\n    chunk->live_byte_count_ += by;\n  }\n\n  intptr_t live_bytes(MemoryChunk* chunk) const {\n    return chunk->live_byte_count_;\n  }\n\n  void SetLiveBytes(MemoryChunk* chunk, intptr_t value) {\n    chunk->live_byte_count_ = value;\n  }\n};\n\n// Collector for young and old generation.\nclass MarkCompactCollector final : public MarkCompactCollectorBase {\n public:\n#ifdef V8_CONCURRENT_MARKING\n  using MarkingState = IncrementalMarkingState;\n#else\n  using MarkingState = MajorNonAtomicMarkingState;\n#endif  // V8_CONCURRENT_MARKING\n\n  using NonAtomicMarkingState = MajorNonAtomicMarkingState;\n\n  // Wrapper for the shared worklist.\n  class MarkingWorklist {\n   public:\n    using ConcurrentMarkingWorklist = Worklist<HeapObject, 64>;\n    using EmbedderTracingWorklist = Worklist<HeapObject, 16>;\n\n    // The heap parameter is not used but needed to match the sequential case.\n    explicit MarkingWorklist(Heap* heap) {}\n\n    void Push(HeapObject object) {\n      bool success = shared_.Push(kMainThread, object);\n      USE(success);\n      DCHECK(success);\n    }\n\n    HeapObject Pop() {\n      HeapObject result;\n      if (shared_.Pop(kMainThread, &result)) return result;\n#ifdef V8_CONCURRENT_MARKING\n      // The expectation is that this work list is empty almost all the time\n      // and we can thus avoid the emptiness checks by putting it last.\n      if (on_hold_.Pop(kMainThread, &result)) return result;\n#endif\n      return HeapObject();\n    }\n\n    void Clear() {\n      shared_.Clear();\n      on_hold_.Clear();\n      embedder_.Clear();\n    }\n\n    bool IsEmpty() {\n      return shared_.IsLocalEmpty(kMainThread) &&\n             on_hold_.IsLocalEmpty(kMainThread) &&\n             shared_.IsGlobalPoolEmpty() && on_hold_.IsGlobalPoolEmpty();\n    }\n\n    bool IsEmbedderEmpty() {\n      return embedder_.IsLocalEmpty(kMainThread) &&\n             embedder_.IsGlobalPoolEmpty();\n    }\n\n    int Size() {\n      return static_cast<int>(shared_.LocalSize(kMainThread) +\n                              on_hold_.LocalSize(kMainThread));\n    }\n\n    // Calls the specified callback on each element of the deques and replaces\n    // the element with the result of the callback. If the callback returns\n    // nullptr then the element is removed from the deque.\n    // The callback must accept HeapObject and return HeapObject.\n    template <typename Callback>\n    void Update(Callback callback) {\n      shared_.Update(callback);\n      on_hold_.Update(callback);\n      embedder_.Update(callback);\n    }\n\n    void ShareWorkIfGlobalPoolIsEmpty() {\n      if (!shared_.IsLocalEmpty(kMainThread) && shared_.IsGlobalPoolEmpty()) {\n        shared_.FlushToGlobal(kMainThread);\n      }\n    }\n\n    ConcurrentMarkingWorklist* shared() { return &shared_; }\n    ConcurrentMarkingWorklist* on_hold() { return &on_hold_; }\n    EmbedderTracingWorklist* embedder() { return &embedder_; }\n\n    void Print() {\n      PrintWorklist(\"shared\", &shared_);\n      PrintWorklist(\"on_hold\", &on_hold_);\n    }\n\n   private:\n    // Prints the stats about the global pool of the worklist.\n    void PrintWorklist(const char* worklist_name,\n                       ConcurrentMarkingWorklist* worklist);\n\n    // Worklist used for most objects.\n    ConcurrentMarkingWorklist shared_;\n\n    // Concurrent marking uses this worklist to bail out of marking objects\n    // in new space's linear allocation area. Used to avoid black allocation\n    // for new space. This allow the compiler to remove write barriers\n    // for freshly allocatd objects.\n    ConcurrentMarkingWorklist on_hold_;\n\n    // Worklist for objects that potentially require embedder tracing, i.e.,\n    // these objects need to be handed over to the embedder to find the full\n    // transitive closure.\n    EmbedderTracingWorklist embedder_;\n  };\n\n  class RootMarkingVisitor;\n  class CustomRootBodyMarkingVisitor;\n\n  enum IterationMode {\n    kKeepMarking,\n    kClearMarkbits,\n  };\n\n  MarkingState* marking_state() { return &marking_state_; }\n\n  NonAtomicMarkingState* non_atomic_marking_state() {\n    return &non_atomic_marking_state_;\n  }\n\n  void SetUp() override;\n  void TearDown() override;\n  // Performs a global garbage collection.\n  void CollectGarbage() override;\n\n  void CollectEvacuationCandidates(PagedSpace* space);\n\n  void AddEvacuationCandidate(Page* p);\n\n  // Prepares for GC by resetting relocation info in old and map spaces and\n  // choosing spaces to compact.\n  void Prepare();\n\n  // Stop concurrent marking (either by preempting it right away or waiting for\n  // it to complete as requested by |stop_request|).\n  void FinishConcurrentMarking(ConcurrentMarking::StopRequest stop_request);\n\n  bool StartCompaction();\n\n  void AbortCompaction();\n\n  static inline bool IsOnEvacuationCandidate(Object obj) {\n    return Page::FromAddress(obj.ptr())->IsEvacuationCandidate();\n  }\n\n  static bool IsOnEvacuationCandidate(MaybeObject obj);\n\n  struct RecordRelocSlotInfo {\n    MemoryChunk* memory_chunk;\n    SlotType slot_type;\n    bool should_record;\n    uint32_t offset;\n  };\n  static RecordRelocSlotInfo PrepareRecordRelocSlot(Code host, RelocInfo* rinfo,\n                                                    HeapObject target);\n  static void RecordRelocSlot(Code host, RelocInfo* rinfo, HeapObject target);\n  V8_INLINE static void RecordSlot(HeapObject object, ObjectSlot slot,\n                                   HeapObject target);\n  V8_INLINE static void RecordSlot(HeapObject object, HeapObjectSlot slot,\n                                   HeapObject target);\n  V8_INLINE static void RecordSlot(MemoryChunk* source_page,\n                                   HeapObjectSlot slot, HeapObject target);\n  void RecordLiveSlotsOnPage(Page* page);\n\n  void UpdateSlots(SlotsBuffer* buffer);\n  void UpdateSlotsRecordedIn(SlotsBuffer* buffer);\n\n  bool is_compacting() const { return compacting_; }\n\n  // Ensures that sweeping is finished.\n  //\n  // Note: Can only be called safely from main thread.\n  V8_EXPORT_PRIVATE void EnsureSweepingCompleted();\n\n  // Checks if sweeping is in progress right now on any space.\n  bool sweeping_in_progress() const { return sweeper_->sweeping_in_progress(); }\n\n  void set_evacuation(bool evacuation) { evacuation_ = evacuation; }\n\n  bool evacuation() const { return evacuation_; }\n\n  MarkingWorklist* marking_worklist() { return &marking_worklist_; }\n\n  WeakObjects* weak_objects() { return &weak_objects_; }\n\n  inline void AddTransitionArray(TransitionArray array);\n\n  void AddEphemeronHashTable(EphemeronHashTable table) {\n    weak_objects_.ephemeron_hash_tables.Push(kMainThread, table);\n  }\n\n  void AddEphemeron(HeapObject key, HeapObject value) {\n    weak_objects_.discovered_ephemerons.Push(kMainThread,\n                                             Ephemeron{key, value});\n  }\n\n  void AddWeakReference(HeapObject host, HeapObjectSlot slot) {\n    weak_objects_.weak_references.Push(kMainThread, std::make_pair(host, slot));\n  }\n\n  void AddWeakObjectInCode(HeapObject object, Code code) {\n    weak_objects_.weak_objects_in_code.Push(kMainThread,\n                                            std::make_pair(object, code));\n  }\n\n  void AddWeakRef(JSWeakRef weak_ref) {\n    weak_objects_.js_weak_refs.Push(kMainThread, weak_ref);\n  }\n\n  void AddWeakCell(WeakCell weak_cell) {\n    weak_objects_.weak_cells.Push(kMainThread, weak_cell);\n  }\n\n  inline void AddBytecodeFlushingCandidate(SharedFunctionInfo flush_candidate);\n  inline void AddFlushedJSFunction(JSFunction flushed_function);\n\n  void AddNewlyDiscovered(HeapObject object) {\n    if (ephemeron_marking_.newly_discovered_overflowed) return;\n\n    if (ephemeron_marking_.newly_discovered.size() <\n        ephemeron_marking_.newly_discovered_limit) {\n      ephemeron_marking_.newly_discovered.push_back(object);\n    } else {\n      ephemeron_marking_.newly_discovered_overflowed = true;\n    }\n  }\n\n  void ResetNewlyDiscovered() {\n    ephemeron_marking_.newly_discovered_overflowed = false;\n    ephemeron_marking_.newly_discovered.clear();\n  }\n\n  Sweeper* sweeper() { return sweeper_; }\n\n#ifdef DEBUG\n  // Checks whether performing mark-compact collection.\n  bool in_use() { return state_ > PREPARE_GC; }\n  bool are_map_pointers_encoded() { return state_ == UPDATE_POINTERS; }\n#endif\n\n  void VerifyMarking();\n#ifdef VERIFY_HEAP\n  void VerifyValidStoreAndSlotsBufferEntries();\n  void VerifyMarkbitsAreClean();\n  void VerifyMarkbitsAreDirty(ReadOnlySpace* space);\n  void VerifyMarkbitsAreClean(PagedSpace* space);\n  void VerifyMarkbitsAreClean(NewSpace* space);\n  void VerifyMarkbitsAreClean(LargeObjectSpace* space);\n#endif\n\n  unsigned epoch() const { return epoch_; }\n\n  explicit MarkCompactCollector(Heap* heap);\n  ~MarkCompactCollector() override;\n\n  // Used by wrapper tracing.\n  V8_INLINE void MarkExternallyReferencedObject(HeapObject obj);\n\n private:\n  void ComputeEvacuationHeuristics(size_t area_size,\n                                   int* target_fragmentation_percent,\n                                   size_t* max_evacuated_bytes);\n\n  void RecordObjectStats();\n\n  // Finishes GC, performs heap verification if enabled.\n  void Finish();\n\n  void MarkLiveObjects() override;\n\n  // Marks the object black and adds it to the marking work list.\n  // This is for non-incremental marking only.\n  V8_INLINE void MarkObject(HeapObject host, HeapObject obj);\n\n  // Marks the object black and adds it to the marking work list.\n  // This is for non-incremental marking only.\n  V8_INLINE void MarkRootObject(Root root, HeapObject obj);\n\n  // Mark the heap roots and all objects reachable from them.\n  void MarkRoots(RootVisitor* root_visitor,\n                 ObjectVisitor* custom_root_body_visitor);\n\n  // Mark the string table specially.  References to internalized strings from\n  // the string table are weak.\n  void MarkStringTable(ObjectVisitor* visitor);\n\n  // Marks object reachable from harmony weak maps and wrapper tracing.\n  void ProcessEphemeronMarking();\n\n  // If the call-site of the top optimized code was not prepared for\n  // deoptimization, then treat embedded pointers in the code as strong as\n  // otherwise they can die and try to deoptimize the underlying code.\n  void ProcessTopOptimizedFrame(ObjectVisitor* visitor);\n\n  // Drains the main thread marking work list. Will mark all pending objects\n  // if no concurrent threads are running.\n  void ProcessMarkingWorklist() override;\n\n  enum class MarkingWorklistProcessingMode {\n    kDefault,\n    kTrackNewlyDiscoveredObjects\n  };\n\n  template <MarkingWorklistProcessingMode mode>\n  void ProcessMarkingWorklistInternal();\n\n  // Implements ephemeron semantics: Marks value if key is already reachable.\n  // Returns true if value was actually marked.\n  bool ProcessEphemeron(HeapObject key, HeapObject value);\n\n  // Marks ephemerons and drains marking worklist iteratively\n  // until a fixpoint is reached.\n  void ProcessEphemeronsUntilFixpoint();\n\n  // Drains ephemeron and marking worklists. Single iteration of the\n  // fixpoint iteration.\n  bool ProcessEphemerons();\n\n  // Mark ephemerons and drain marking worklist with a linear algorithm.\n  // Only used if fixpoint iteration doesn't finish within a few iterations.\n  void ProcessEphemeronsLinear();\n\n  // Perform Wrapper Tracing if in use.\n  void PerformWrapperTracing();\n\n  // Callback function for telling whether the object *p is an unmarked\n  // heap object.\n  static bool IsUnmarkedHeapObject(Heap* heap, FullObjectSlot p);\n\n  // Clear non-live references in weak cells, transition and descriptor arrays,\n  // and deoptimize dependent code of non-live maps.\n  void ClearNonLiveReferences() override;\n  void MarkDependentCodeForDeoptimization();\n  // Checks if the given weak cell is a simple transition from the parent map\n  // of the given dead target. If so it clears the transition and trims\n  // the descriptor array of the parent if needed.\n  void ClearPotentialSimpleMapTransition(Map dead_target);\n  void ClearPotentialSimpleMapTransition(Map map, Map dead_target);\n\n  // Flushes a weakly held bytecode array from a shared function info.\n  void FlushBytecodeFromSFI(SharedFunctionInfo shared_info);\n\n  // Clears bytecode arrays that have not been executed for multiple\n  // collections.\n  void ClearOldBytecodeCandidates();\n\n  // Resets any JSFunctions which have had their bytecode flushed.\n  void ClearFlushedJsFunctions();\n\n  // Compact every array in the global list of transition arrays and\n  // trim the corresponding descriptor array if a transition target is non-live.\n  void ClearFullMapTransitions();\n  void TrimDescriptorArray(Map map, DescriptorArray descriptors);\n  void TrimEnumCache(Map map, DescriptorArray descriptors);\n  bool CompactTransitionArray(Map map, TransitionArray transitions,\n                              DescriptorArray descriptors);\n\n  // After all reachable objects have been marked those weak map entries\n  // with an unreachable key are removed from all encountered weak maps.\n  // The linked list of all encountered weak maps is destroyed.\n  void ClearWeakCollections();\n\n  // Goes through the list of encountered weak references and clears those with\n  // dead values. If the value is a dead map and the parent map transitions to\n  // the dead map via weak cell, then this function also clears the map\n  // transition.\n  void ClearWeakReferences();\n\n  // Goes through the list of encountered JSWeakRefs and WeakCells and clears\n  // those with dead values.\n  void ClearJSWeakRefs();\n\n  void AbortWeakObjects();\n\n  // Starts sweeping of spaces by contributing on the main thread and setting\n  // up other pages for sweeping. Does not start sweeper tasks.\n  void StartSweepSpaces();\n  void StartSweepSpace(PagedSpace* space);\n\n  void EvacuatePrologue() override;\n  void EvacuateEpilogue() override;\n  void Evacuate() override;\n  void EvacuatePagesInParallel() override;\n  void UpdatePointersAfterEvacuation() override;\n\n  UpdatingItem* CreateToSpaceUpdatingItem(MemoryChunk* chunk, Address start,\n                                          Address end) override;\n  UpdatingItem* CreateRememberedSetUpdatingItem(\n      MemoryChunk* chunk, RememberedSetUpdatingMode updating_mode) override;\n\n  int CollectNewSpaceArrayBufferTrackerItems(ItemParallelJob* job);\n  int CollectOldSpaceArrayBufferTrackerItems(ItemParallelJob* job);\n\n  void ReleaseEvacuationCandidates();\n  void PostProcessEvacuationCandidates();\n  void ReportAbortedEvacuationCandidate(HeapObject failed_object,\n                                        MemoryChunk* chunk);\n\n  static const int kEphemeronChunkSize = 8 * KB;\n\n  int NumberOfParallelEphemeronVisitingTasks(size_t elements);\n\n  void RightTrimDescriptorArray(DescriptorArray array, int descriptors_to_trim);\n\n  base::Mutex mutex_;\n  base::Semaphore page_parallel_job_semaphore_;\n\n#ifdef DEBUG\n  enum CollectorState{IDLE,\n                      PREPARE_GC,\n                      MARK_LIVE_OBJECTS,\n                      SWEEP_SPACES,\n                      ENCODE_FORWARDING_ADDRESSES,\n                      UPDATE_POINTERS,\n                      RELOCATE_OBJECTS};\n\n  // The current stage of the collector.\n  CollectorState state_;\n#endif\n\n  bool was_marked_incrementally_;\n\n  bool evacuation_;\n\n  // True if we are collecting slots to perform evacuation from evacuation\n  // candidates.\n  bool compacting_;\n\n  bool black_allocation_;\n\n  bool have_code_to_deoptimize_;\n\n  MarkingWorklist marking_worklist_;\n  WeakObjects weak_objects_;\n  EphemeronMarking ephemeron_marking_;\n\n  // Candidates for pages that should be evacuated.\n  std::vector<Page*> evacuation_candidates_;\n  // Pages that are actually processed during evacuation.\n  std::vector<Page*> old_space_evacuation_pages_;\n  std::vector<Page*> new_space_evacuation_pages_;\n  std::vector<std::pair<HeapObject, Page*>> aborted_evacuation_candidates_;\n\n  Sweeper* sweeper_;\n\n  MarkingState marking_state_;\n  NonAtomicMarkingState non_atomic_marking_state_;\n\n  // Counts the number of major mark-compact collections. The counter is\n  // incremented right after marking. This is used for:\n  // - marking descriptor arrays. See NumberOfMarkedDescriptors. Only the lower\n  //   two bits are used, so it is okay if this counter overflows and wraps\n  //   around.\n  unsigned epoch_ = 0;\n\n  friend class FullEvacuator;\n  friend class RecordMigratedSlotVisitor;\n};\n\ntemplate <FixedArrayVisitationMode fixed_array_mode,\n          TraceRetainingPathMode retaining_path_mode, typename MarkingState>\nclass MarkingVisitor final\n    : public HeapVisitor<\n          int,\n          MarkingVisitor<fixed_array_mode, retaining_path_mode, MarkingState>> {\n public:\n  using Parent = HeapVisitor<\n      int, MarkingVisitor<fixed_array_mode, retaining_path_mode, MarkingState>>;\n\n  V8_INLINE MarkingVisitor(MarkCompactCollector* collector,\n                           MarkingState* marking_state);\n\n  V8_INLINE bool ShouldVisitMapPointer() { return false; }\n\n  V8_INLINE int VisitBytecodeArray(Map map, BytecodeArray object);\n  V8_INLINE int VisitDescriptorArray(Map map, DescriptorArray object);\n  V8_INLINE int VisitEphemeronHashTable(Map map, EphemeronHashTable object);\n  V8_INLINE int VisitFixedArray(Map map, FixedArray object);\n  V8_INLINE int VisitJSApiObject(Map map, JSObject object);\n  V8_INLINE int VisitJSArrayBuffer(Map map, JSArrayBuffer object);\n  V8_INLINE int VisitJSFunction(Map map, JSFunction object);\n  V8_INLINE int VisitJSDataView(Map map, JSDataView object);\n  V8_INLINE int VisitJSTypedArray(Map map, JSTypedArray object);\n  V8_INLINE int VisitMap(Map map, Map object);\n  V8_INLINE int VisitSharedFunctionInfo(Map map, SharedFunctionInfo object);\n  V8_INLINE int VisitTransitionArray(Map map, TransitionArray object);\n  V8_INLINE int VisitWeakCell(Map map, WeakCell object);\n  V8_INLINE int VisitJSWeakRef(Map map, JSWeakRef object);\n\n  // ObjectVisitor implementation.\n  V8_INLINE void VisitPointer(HeapObject host, ObjectSlot p) final {\n    VisitPointerImpl(host, p);\n  }\n  V8_INLINE void VisitPointer(HeapObject host, MaybeObjectSlot p) final {\n    VisitPointerImpl(host, p);\n  }\n  V8_INLINE void VisitPointers(HeapObject host, ObjectSlot start,\n                               ObjectSlot end) final {\n    VisitPointersImpl(host, start, end);\n  }\n  V8_INLINE void VisitPointers(HeapObject host, MaybeObjectSlot start,\n                               MaybeObjectSlot end) final {\n    VisitPointersImpl(host, start, end);\n  }\n  V8_INLINE void VisitEmbeddedPointer(Code host, RelocInfo* rinfo) final;\n  V8_INLINE void VisitCodeTarget(Code host, RelocInfo* rinfo) final;\n\n  // Weak list pointers should be ignored during marking. The lists are\n  // reconstructed after GC.\n  void VisitCustomWeakPointers(HeapObject host, ObjectSlot start,\n                               ObjectSlot end) final {}\n\n  V8_INLINE void VisitDescriptors(DescriptorArray descriptors,\n                                  int number_of_own_descriptors);\n  // Marks the descriptor array black without pushing it on the marking work\n  // list and visits its header.\n  V8_INLINE void MarkDescriptorArrayBlack(HeapObject host,\n                                          DescriptorArray descriptors);\n\n private:\n  // Granularity in which FixedArrays are scanned if |fixed_array_mode|\n  // is true.\n  static const int kProgressBarScanningChunk = 32 * KB;\n\n  template <typename TSlot>\n  V8_INLINE void VisitPointerImpl(HeapObject host, TSlot p);\n\n  template <typename TSlot>\n  V8_INLINE void VisitPointersImpl(HeapObject host, TSlot start, TSlot end);\n\n  V8_INLINE int VisitFixedArrayIncremental(Map map, FixedArray object);\n\n  template <typename T>\n  V8_INLINE int VisitEmbedderTracingSubclass(Map map, T object);\n\n  // Marks the object grey and pushes it on the marking work list.\n  V8_INLINE void MarkObject(HeapObject host, HeapObject obj);\n\n  MarkingState* marking_state() { return marking_state_; }\n\n  MarkCompactCollector::MarkingWorklist* marking_worklist() const {\n    return collector_->marking_worklist();\n  }\n\n  Heap* const heap_;\n  MarkCompactCollector* const collector_;\n  MarkingState* const marking_state_;\n  const unsigned mark_compact_epoch_;\n};\n\nclass EvacuationScope {\n public:\n  explicit EvacuationScope(MarkCompactCollector* collector)\n      : collector_(collector) {\n    collector_->set_evacuation(true);\n  }\n\n  ~EvacuationScope() { collector_->set_evacuation(false); }\n\n private:\n  MarkCompactCollector* collector_;\n};\n\n#ifdef ENABLE_MINOR_MC\n\n// Collector for young-generation only.\nclass MinorMarkCompactCollector final : public MarkCompactCollectorBase {\n public:\n  using MarkingState = MinorMarkingState;\n  using NonAtomicMarkingState = MinorNonAtomicMarkingState;\n\n  explicit MinorMarkCompactCollector(Heap* heap);\n  ~MinorMarkCompactCollector() override;\n\n  MarkingState* marking_state() { return &marking_state_; }\n\n  NonAtomicMarkingState* non_atomic_marking_state() {\n    return &non_atomic_marking_state_;\n  }\n\n  void SetUp() override;\n  void TearDown() override;\n  void CollectGarbage() override;\n\n  void MakeIterable(Page* page, MarkingTreatmentMode marking_mode,\n                    FreeSpaceTreatmentMode free_space_mode);\n  void CleanupSweepToIteratePages();\n\n private:\n  using MarkingWorklist = Worklist<HeapObject, 64 /* segment size */>;\n  class RootMarkingVisitor;\n\n  static const int kNumMarkers = 8;\n  static const int kMainMarker = 0;\n\n  inline MarkingWorklist* worklist() { return worklist_; }\n\n  inline YoungGenerationMarkingVisitor* main_marking_visitor() {\n    return main_marking_visitor_;\n  }\n\n  void MarkLiveObjects() override;\n  void MarkRootSetInParallel(RootMarkingVisitor* root_visitor);\n  V8_INLINE void MarkRootObject(HeapObject obj);\n  void ProcessMarkingWorklist() override;\n  void ClearNonLiveReferences() override;\n\n  void EvacuatePrologue() override;\n  void EvacuateEpilogue() override;\n  void Evacuate() override;\n  void EvacuatePagesInParallel() override;\n  void UpdatePointersAfterEvacuation() override;\n\n  UpdatingItem* CreateToSpaceUpdatingItem(MemoryChunk* chunk, Address start,\n                                          Address end) override;\n  UpdatingItem* CreateRememberedSetUpdatingItem(\n      MemoryChunk* chunk, RememberedSetUpdatingMode updating_mode) override;\n\n  int CollectNewSpaceArrayBufferTrackerItems(ItemParallelJob* job);\n\n  int NumberOfParallelMarkingTasks(int pages);\n\n  MarkingWorklist* worklist_;\n\n  YoungGenerationMarkingVisitor* main_marking_visitor_;\n  base::Semaphore page_parallel_job_semaphore_;\n  std::vector<Page*> new_space_evacuation_pages_;\n  std::vector<Page*> sweep_to_iterate_pages_;\n\n  MarkingState marking_state_;\n  NonAtomicMarkingState non_atomic_marking_state_;\n\n  friend class YoungGenerationMarkingTask;\n  friend class YoungGenerationMarkingVisitor;\n};\n\n#endif  // ENABLE_MINOR_MC\n\n}  // namespace internal\n}  // namespace v8\n\n#endif  // V8_HEAP_MARK_COMPACT_H_\n\n", "comment_ratio": 0.12312312312312312}
{"lang": "c", "code": "#import <objc/NSObject.h>\n\n@class NSString;\n\n@interface ZipArchive : NSObject\n{\n    void *_zipFile;\n    void *_unzFile;\n    NSString *_unzipFilePath;\n    NSString *_password;\n    id _delegate;\n}\n\n@property(nonatomic) id delegate; // @synthesize delegate=_delegate;\n- (void).cxx_destruct;\n- (id)Date1980;\n- (_Bool)OverWrite:(id)arg1;\n- (void)OutputErrorMessage:(id)arg1;\n- (_Bool)UnzipCloseFile;\n- (_Bool)UnzipHasRelativeDir:(_Bool *)arg1;\n- (_Bool)UnzipFileTo:(id)arg1 overWrite:(_Bool)arg2;\n- (_Bool)UnzipOpenFile:(id)arg1 Password:(id)arg2;\n- (_Bool)UnzipOpenFile:(id)arg1;\n- (_Bool)CloseZipFile2;\n- (_Bool)addFileToZip:(id)arg1 newname:(id)arg2;\n- (_Bool)addSingleFileToZip:(id)arg1 fileNameInZip:(id)arg2;\n- (_Bool)CreateZipFile2:(id)arg1 Password:(id)arg2;\n- (_Bool)CreateZipFile2:(id)arg1;\n- (void)dealloc;\n- (id)init;\n\n@end\n\n\n", "comment_ratio": 0.15}
{"lang": "c", "code": "#pragma once\n\n#include <Mathematics/FIQuery.h>\n#include <Mathematics/TIQuery.h>\n#include <Mathematics/Cone.h>\n#include <Mathematics/Hypersphere.h>\n#include <Mathematics/Vector3.h>\n\n// The test-intersection query is based on the document\n// https://www.geometrictools.com/Documentation/IntersectionSphereCone.pdf\n//\n// The find-intersection returns a single point in the set of intersection\n// when that intersection is not empty.\n\nnamespace gte\n{\n    template <typename T>\n    class TIQuery<T, Sphere3<T>, Cone3<T>>\n    {\n    public:\n        struct Result\n        {\n            Result()\n                :\n                intersect(false)\n            {\n            }\n\n            bool intersect;\n        };\n\n        Result operator()(Sphere3<T> const& sphere, Cone3<T> const& cone)\n        {\n            Result result{};\n            if (cone.GetMinHeight() > (T)0)\n            {\n                if (cone.IsFinite())\n                {\n                    result.intersect = DoQueryConeFrustum(sphere, cone);\n                }\n                else\n                {\n                    result.intersect = DoQueryInfiniteTruncatedCone(sphere, cone);\n                }\n            }\n            else\n            {\n                if (cone.IsFinite())\n                {\n                    result.intersect = DoQueryFiniteCone(sphere, cone);\n                }\n                else\n                {\n                    result.intersect = DoQueryInfiniteCone(sphere, cone);\n                }\n            }\n            return result;\n        }\n\n    private:\n        bool DoQueryInfiniteCone(Sphere3<T> const& sphere, Cone3<T> const& cone)\n        {\n            Vector3<T> U = cone.ray.origin - (sphere.radius * cone.invSinAngle) * cone.ray.direction;\n            Vector3<T> CmU = sphere.center - U;\n            T AdCmU = Dot(cone.ray.direction, CmU);\n            if (AdCmU > (T)0)\n            {\n                T sqrLengthCmU = Dot(CmU, CmU);\n                if (AdCmU * AdCmU >= sqrLengthCmU * cone.cosAngleSqr)\n                {\n                    Vector3<T> CmV = sphere.center - cone.ray.origin;\n                    T AdCmV = Dot(cone.ray.direction, CmV);\n                    if (AdCmV < -sphere.radius)\n                    {\n                        return false;\n                    }\n\n                    T rSinAngle = sphere.radius * cone.sinAngle;\n                    if (AdCmV >= -rSinAngle)\n                    {\n                        return true;\n                    }\n\n                    T sqrLengthCmV = Dot(CmV, CmV);\n                    return sqrLengthCmV <= sphere.radius * sphere.radius;\n                }\n            }\n\n            return false;\n        }\n\n        bool DoQueryInfiniteTruncatedCone(Sphere3<T> const& sphere, Cone3<T> const& cone)\n        {\n            Vector3<T> U = cone.ray.origin - (sphere.radius * cone.invSinAngle) * cone.ray.direction;\n            Vector3<T> CmU = sphere.center - U;\n            T AdCmU = Dot(cone.ray.direction, CmU);\n            if (AdCmU > (T)0)\n            {\n                T sqrLengthCmU = Dot(CmU, CmU);\n                if (AdCmU * AdCmU >= sqrLengthCmU * cone.cosAngleSqr)\n                {\n                    Vector3<T> CmV = sphere.center - cone.ray.origin;\n                    T AdCmV = Dot(cone.ray.direction, CmV);\n                    T minHeight = cone.GetMinHeight();\n                    if (AdCmV < minHeight - sphere.radius)\n                    {\n                        return false;\n                    }\n\n                    T rSinAngle = sphere.radius * cone.sinAngle;\n                    if (AdCmV >= -rSinAngle)\n                    {\n                        return true;\n                    }\n\n                    Vector3<T> D = CmV - minHeight * cone.ray.direction;\n                    T lengthAxD = Length(Cross(cone.ray.direction, D));\n                    T hminTanAngle = minHeight * cone.tanAngle;\n                    if (lengthAxD <= hminTanAngle)\n                    {\n                        return true;\n                    }\n\n                    T AdD = AdCmV - minHeight;\n                    T diff = lengthAxD - hminTanAngle;\n                    T sqrLengthCmK = AdD * AdD + diff * diff;\n                    return sqrLengthCmK <= sphere.radius * sphere.radius;\n                }\n            }\n\n            return false;\n        }\n\n        bool DoQueryFiniteCone(Sphere3<T> const& sphere, Cone3<T> const& cone)\n        {\n            Vector3<T> U = cone.ray.origin - (sphere.radius * cone.invSinAngle) * cone.ray.direction;\n            Vector3<T> CmU = sphere.center - U;\n            T AdCmU = Dot(cone.ray.direction, CmU);\n            if (AdCmU > (T)0)\n            {\n                T sqrLengthCmU = Dot(CmU, CmU);\n                if (AdCmU * AdCmU >= sqrLengthCmU * cone.cosAngleSqr)\n                {\n                    Vector3<T> CmV = sphere.center - cone.ray.origin;\n                    T AdCmV = Dot(cone.ray.direction, CmV);\n                    if (AdCmV < -sphere.radius)\n                    {\n                        return false;\n                    }\n\n                    T maxHeight = cone.GetMaxHeight();\n                    if (AdCmV > cone.GetMaxHeight() + sphere.radius)\n                    {\n                        return false;\n                    }\n\n                    T rSinAngle = sphere.radius * cone.sinAngle;\n                    if (AdCmV >= -rSinAngle)\n                    {\n                        if (AdCmV <= maxHeight - rSinAngle)\n                        {\n                            return true;\n                        }\n                        else\n                        {\n                            Vector3<T> barD = CmV - maxHeight * cone.ray.direction;\n                            T lengthAxBarD = Length(Cross(cone.ray.direction, barD));\n                            T hmaxTanAngle = maxHeight * cone.tanAngle;\n                            if (lengthAxBarD <= hmaxTanAngle)\n                            {\n                                return true;\n                            }\n\n                            T AdBarD = AdCmV - maxHeight;\n                            T diff = lengthAxBarD - hmaxTanAngle;\n                            T sqrLengthCmBarK = AdBarD * AdBarD + diff * diff;\n                            return sqrLengthCmBarK <= sphere.radius * sphere.radius;\n                        }\n                    }\n                    else\n                    {\n                        T sqrLengthCmV = Dot(CmV, CmV);\n                        return sqrLengthCmV <= sphere.radius * sphere.radius;\n                    }\n                }\n            }\n\n            return false;\n        }\n\n        bool DoQueryConeFrustum(Sphere3<T> const& sphere, Cone3<T> const& cone)\n        {\n            Vector3<T> U = cone.ray.origin - (sphere.radius * cone.invSinAngle) * cone.ray.direction;\n            Vector3<T> CmU = sphere.center - U;\n            T AdCmU = Dot(cone.ray.direction, CmU);\n            if (AdCmU > (T)0)\n            {\n                T sqrLengthCmU = Dot(CmU, CmU);\n                if (AdCmU * AdCmU >= sqrLengthCmU * cone.cosAngleSqr)\n                {\n                    Vector3<T> CmV = sphere.center - cone.ray.origin;\n                    T AdCmV = Dot(cone.ray.direction, CmV);\n                    T minHeight = cone.GetMinHeight();\n                    if (AdCmV < minHeight - sphere.radius)\n                    {\n                        return false;\n                    }\n\n                    T maxHeight = cone.GetMaxHeight();\n                    if (AdCmV > maxHeight + sphere.radius)\n                    {\n                        return false;\n                    }\n\n                    T rSinAngle = sphere.radius * cone.sinAngle;\n                    if (AdCmV >= minHeight - rSinAngle)\n                    {\n                        if (AdCmV <= maxHeight - rSinAngle)\n                        {\n                            return true;\n                        }\n                        else\n                        {\n                            Vector3<T> barD = CmV - maxHeight * cone.ray.direction;\n                            T lengthAxBarD = Length(Cross(cone.ray.direction, barD));\n                            T hmaxTanAngle = maxHeight * cone.tanAngle;\n                            if (lengthAxBarD <= hmaxTanAngle)\n                            {\n                                return true;\n                            }\n\n                            T AdBarD = AdCmV - maxHeight;\n                            T diff = lengthAxBarD - hmaxTanAngle;\n                            T sqrLengthCmBarK = AdBarD * AdBarD + diff * diff;\n                            return sqrLengthCmBarK <= sphere.radius * sphere.radius;\n                        }\n                    }\n                    else\n                    {\n                        Vector3<T> D = CmV - minHeight * cone.ray.direction;\n                        T lengthAxD = Length(Cross(cone.ray.direction, D));\n                        T hminTanAngle = minHeight * cone.tanAngle;\n                        if (lengthAxD <= hminTanAngle)\n                        {\n                            return true;\n                        }\n\n                        T AdD = AdCmV - minHeight;\n                        T diff = lengthAxD - hminTanAngle;\n                        T sqrLengthCmK = AdD * AdD + diff * diff;\n                        return sqrLengthCmK <= sphere.radius * sphere.radius;\n                    }\n                }\n            }\n\n            return false;\n        }\n    };\n\n    template <typename T>\n    class FIQuery<T, Sphere3<T>, Cone3<T>>\n    {\n    public:\n        struct Result\n        {\n            Result()\n                :\n                intersect(false),\n                point(Vector3<T>::Zero())\n            {\n            }\n\n            // If an intersection occurs, it is potentially an infinite set.\n            // If the cone vertex is inside the sphere, 'point' is set to the\n            // cone vertex.  If the sphere center is inside the cone, 'point'\n            // is set to the sphere center. Otherwise, 'point' is set to the\n            // cone point that is closest to the cone vertex and inside the\n            // sphere.\n            bool intersect;\n            Vector3<T> point;\n        };\n\n        Result operator()(Sphere3<T> const& sphere, Cone3<T> const& cone)\n        {\n            Result result{};\n\n            // Test whether the cone vertex is inside the sphere.\n            Vector3<T> diff = sphere.center - cone.ray.origin;\n            T rSqr = sphere.radius * sphere.radius;\n            T lenSqr = Dot(diff, diff);\n            if (lenSqr <= rSqr)\n            {\n                // The cone vertex is inside the sphere, so the sphere and\n                // cone intersect.\n                result.intersect = true;\n                result.point = cone.ray.origin;\n                return result;\n            }\n\n            // Test whether the sphere center is inside the cone.\n            T dot = Dot(diff, cone.ray.direction);\n            T dotSqr = dot * dot;\n            if (dotSqr >= lenSqr * cone.cosAngleSqr && dot > (T)0)\n            {\n                // The sphere center is inside cone, so the sphere and cone\n                // intersect.\n                result.intersect = true;\n                result.point = sphere.center;\n                return result;\n            }\n\n            // The sphere center is outside the cone.  The problem now reduces\n            // to computing an intersection between the circle and the ray in\n            // the plane containing the cone vertex and spanned by the cone\n            // axis and vector from the cone vertex to the sphere center.\n\n            // The ray is parameterized by t * D + V with t >= 0, |D| = 1 and\n            // dot(A,D) = cos(angle).  Also, D = e * A + f * (C - V).\n            // Substituting the ray equation into the sphere equation yields\n            // R^2 = |t * D + V - C|^2, so the quadratic for intersections is\n            // t^2 - 2 * dot(D, C - V) * t + |C - V|^2 - R^2 = 0.  An\n            // intersection occurs if and only if the discriminant is\n            // nonnegative.  This test becomes\n            //     dot(D, C - V)^2 >= dot(C - V, C - V) - R^2\n            // Note that if the right-hand side is nonpositive, then the\n            // inequality is true (the sphere contains V).  This is already\n            // ruled out in the first block of code in this function.\n\n            T uLen = std::sqrt(std::max(lenSqr - dotSqr, (T)0));\n            T test = cone.cosAngle * dot + cone.sinAngle * uLen;\n            T discr = test * test - lenSqr + rSqr;\n\n            if (discr >= (T)0 && test >= (T)0)\n            {\n                // Compute the point of intersection closest to the cone\n                // vertex.\n                result.intersect = true;\n                T t = test - std::sqrt(std::max(discr, (T)0));\n                Vector3<T> B = diff - dot * cone.ray.direction;\n                T tmp = cone.sinAngle / uLen;\n                result.point = t * (cone.cosAngle * cone.ray.direction + tmp * B);\n            }\n            else\n            {\n                result.intersect = false;\n            }\n\n            return result;\n        }\n    };\n}\n\n", "comment_ratio": 0.11142061281337047}
{"lang": "c", "code": "#ifndef __LWNX_H__\n#define __LWNX_H__\n\n#include <stdint.h>\n\n#define PACKET_START_BYTE\t0xAA\n#define PACKET_TIMEOUT\t\t200\n#define PACKET_RETRIES\t\t4\n\ntypedef int32_t (*writeCallbackFuncPtr)(uint8_t* Data, int32_t BufferSize);\ntypedef int32_t (*readCallbackFuncPtr)(uint8_t* Data, int32_t BufferSize);\ntypedef int32_t (*timeCallbackFuncPtr)();\n\ntypedef struct {\n\twriteCallbackFuncPtr writeCallback;\n\treadCallbackFuncPtr readCallback;\n\ttimeCallbackFuncPtr timeCallback;\n\n} lwEndpoint;\n\ntypedef struct {\t\n\tuint8_t data[1024];\n\tint32_t size;\n\tint32_t payloadSize;\n\tuint8_t parseState;\n\tuint8_t cmdId;\n\n} lwResponsePacket;\n\n//----------------------------------------------------------------------------------------------------------------------------------\n// Helper utilities.\n//----------------------------------------------------------------------------------------------------------------------------------\n// Create a CRC-16-CCITT 0x1021 hash of the specified data.\nuint16_t lwnxCreateCrc(uint8_t* Data, uint16_t Size);\n\n// Breaks an integer firmware version into Major, Minor, and Patch.\nvoid lwnxConvertFirmwareVersionToStr(uint32_t Version, char* String);\n\n//----------------------------------------------------------------------------------------------------------------------------------\n// LWNX protocol implementation.\n//----------------------------------------------------------------------------------------------------------------------------------\n// Prepare a response packet for a new incoming response.\nvoid lwnxInitResponsePacket(lwResponsePacket* Response);\n\n// Waits to receive a packet of specific command id.\n// Does not return until a response is received or a timeout occurs.\nuint8_t lwnxRecvPacket(lwEndpoint* Endpoint, uint8_t CommandId, lwResponsePacket* Response, uint32_t TimeoutMs);\n\n// Waits to receive any packet.\n// Does not return until a response is received or a timeout occurs.\nuint8_t lwnxRecvPacketAny(lwEndpoint* Endpoint, lwResponsePacket* Response, uint32_t TimeoutMs);\n\n// Returns true if full packet was received, otherwise finishes immediately and returns false while waiting for more data.\nuint8_t lwnxRecvPacketNoBlock(lwEndpoint* Endpoint, uint8_t CommandId, lwResponsePacket* Response);\n\n// Composes and sends a packet.\nvoid lwnxSendPacketBytes(lwEndpoint* Endpoint, uint8_t CommandId, uint8_t Write, uint8_t* Data, uint32_t DataSize);\n\n// Handle both the sending and receving of a command. \n// Does not return until a response is received or all retries have expired.\nuint8_t lwnxHandleManagedCmd(lwEndpoint* Endpoint, uint8_t CommandId, uint8_t* Response, uint32_t ResponseSize, uint8_t Write, uint8_t* WriteData, uint32_t WriteSize);\n\n//----------------------------------------------------------------------------------------------------------------------------------\n// Command functions.\n//----------------------------------------------------------------------------------------------------------------------------------\n// Issue read commands.\nuint8_t lwnxCmdReadInt8(lwEndpoint* Endpoint, uint8_t CommandId, int8_t* Response);\nuint8_t lwnxCmdReadInt16(lwEndpoint* Endpoint, uint8_t CommandId, int16_t* Response);\nuint8_t lwnxCmdReadInt32(lwEndpoint* Endpoint, uint8_t CommandId, int32_t* Response);\n\nuint8_t lwnxCmdReadUInt8(lwEndpoint* Endpoint, uint8_t CommandId, uint8_t* Response);\nuint8_t lwnxCmdReadUInt16(lwEndpoint* Endpoint, uint8_t CommandId, uint16_t* Response);\nuint8_t lwnxCmdReadUInt32(lwEndpoint* Endpoint, uint8_t CommandId, uint32_t* Response);\n\nuint8_t lwnxCmdReadString(lwEndpoint* Endpoint, uint8_t CommandId, char* Response);\nuint8_t lwnxCmdReadData(lwEndpoint* Endpoint, uint8_t CommandId, uint8_t* Response, uint32_t ResponseSize);\n\n// Issue write commands.\nuint8_t lwnxCmdWriteInt8(lwEndpoint* Endpoint, uint8_t CommandId, int8_t Value);\nuint8_t lwnxCmdWriteInt16(lwEndpoint* Endpoint, uint8_t CommandId, int16_t Value);\nuint8_t lwnxCmdWriteInt32(lwEndpoint* Endpoint, uint8_t CommandId, int32_t Value);\n\nuint8_t lwnxCmdWriteUInt8(lwEndpoint* Endpoint, uint8_t CommandId, uint8_t Value);\nuint8_t lwnxCmdWriteUInt16(lwEndpoint* Endpoint, uint8_t CommandId, uint16_t Value);\nuint8_t lwnxCmdWriteUInt32(lwEndpoint* Endpoint, uint8_t CommandId, uint32_t Value);\n\nuint8_t lwnxCmdWriteString(lwEndpoint* Endpoint, uint8_t CommandId, char* String);\nuint8_t lwnxCmdWriteData(lwEndpoint* Endpoint, uint8_t CommandId, uint8_t* Data, uint32_t DataSize);\n\n#endif\n", "comment_ratio": 0.24444444444444444}
{"lang": "c", "code": "#ifndef CHROME_BROWSER_CHROMEOS_NET_NETWORK_DIAGNOSTICS_CAPTIVE_PORTAL_ROUTINE_H_\n#define CHROME_BROWSER_CHROMEOS_NET_NETWORK_DIAGNOSTICS_CAPTIVE_PORTAL_ROUTINE_H_\n\n#include <vector>\n\n#include \"base/callback.h\"\n#include \"chrome/browser/chromeos/net/network_diagnostics/network_diagnostics_routine.h\"\n#include \"chromeos/services/network_config/public/mojom/cros_network_config.mojom.h\"\n#include \"mojo/public/cpp/bindings/remote.h\"\n\nnamespace chromeos {\nnamespace network_diagnostics {\n\n// Tests whether the internet connection is trapped behind a captive portal.\nclass CaptivePortalRoutine : public NetworkDiagnosticsRoutine {\n public:\n  using CaptivePortalRoutineCallback =\n      mojom::NetworkDiagnosticsRoutines::CaptivePortalCallback;\n\n  CaptivePortalRoutine();\n  CaptivePortalRoutine(const CaptivePortalRoutine&) = delete;\n  CaptivePortalRoutine& operator=(const CaptivePortalRoutine&) = delete;\n  ~CaptivePortalRoutine() override;\n\n  // NetworkDiagnosticsRoutine:\n  void AnalyzeResultsAndExecuteCallback() override;\n\n  // Run the core logic of this routine. Set |callback| to\n  // |routine_completed_callback_|, which is to be executed in\n  // AnalyzeResultsAndExecuteCallback().\n  void RunRoutine(CaptivePortalRoutineCallback callback);\n\n private:\n  void FetchActiveNetworks();\n  void FetchManagedProperties(const std::string& guid);\n  void OnNetworkStateListReceived(\n      std::vector<chromeos::network_config::mojom::NetworkStatePropertiesPtr>\n          networks);\n  void OnManagedPropertiesReceived(\n      network_config::mojom::ManagedPropertiesPtr managed_properties);\n\n  bool no_active_networks_ = false;\n  chromeos::network_config::mojom::PortalState portal_state_ =\n      chromeos::network_config::mojom::PortalState::kUnknown;\n  mojo::Remote<chromeos::network_config::mojom::CrosNetworkConfig>\n      remote_cros_network_config_;\n  std::vector<mojom::CaptivePortalProblem> problems_;\n  CaptivePortalRoutineCallback routine_completed_callback_;\n};\n\n}  // namespace network_diagnostics\n}  // namespace chromeos\n\n#endif  // CHROME_BROWSER_CHROMEOS_NET_NETWORK_DIAGNOSTICS_CAPTIVE_PORTAL_ROUTINE_H_\n\n", "comment_ratio": 0.1864406779661017}
{"lang": "c", "code": "#ifndef __INTEL_VT_X_H__\r\n#define __INTEL_VT_X_H__\r\n\r\n#include \"ntdatatypes.h\"\r\n#include \"msr64.h\"\r\n#include \"cr64.h\"\r\n\r\n// Disable 'warning C4214: nonstandard extension used: bit field types other than int'\r\n// Disable 'warning C4201: nonstandard extension used: nameless struct/union'\r\n#pragma warning(push)\r\n#pragma warning( disable : 4214)\r\n#pragma warning( disable : 4201)\r\n#pragma pack(push, 1)\r\n\r\n//! Vol 3C, Table 21-16. Structure of VMCS Component Encoding\r\ntypedef union _VMCS_COMPONENT_ENCODING\r\n{\r\n    UINT32 AccessType : 1;    //!< 0        Access type (0 = full; 1 = high); must be full \r\n                            //            for 16-bit, 32-bit, and natural-width fields\r\n    UINT32 Index : 8;        //!< 1-9    Index\r\n    UINT32 Reserved0 : 12;    //!< 12        0\r\n    UINT32 Width : 2;        //!< 13-14    0: 16-bit, 1: 64-bit, 2: 32-bit, 3: natural-width\r\n    UINT32 Reserved1 : 17;    //!< 15-31    0\r\n} VMCS_COMPONENT_ENCODING, *PVMCS_COMPONENT_ENCODING;\r\nC_ASSERT(sizeof(UINT32) == sizeof(VMCS_COMPONENT_ENCODING));\r\n\r\n//! Vol 3C, APPENDIX B FIELD ENCODING IN VMCS\r\ntypedef enum _VMCS_FIELD_ENCODING\r\n{\r\n    //! Vol 3C, Table B-1. Encoding for 16-Bit Control Fields (0000_00xx_xxxx_xxx0B)\r\n    VMCS_FIELD_VPID = 0x00000000,\r\n    VMCS_FIELD_POSTED_INTR_NOTIFICATION_VECTOR = 0x00000002,\r\n    VMCS_FIELD_EPTP_INDEX = 0x00000004,\r\n\r\n    //! Vol 3C, Table B-2. Encodings for 16-Bit Guest-State Fields (0000_10xx_xxxx_xxx0B)\r\n    VMCS_FIELD_GUEST_ES_SELECTOR = 0x00000800,\r\n    VMCS_FIELD_GUEST_CS_SELECTOR = 0x00000802,\r\n    VMCS_FIELD_GUEST_SS_SELECTOR = 0x00000804,\r\n    VMCS_FIELD_GUEST_DS_SELECTOR = 0x00000806,\r\n    VMCS_FIELD_GUEST_FS_SELECTOR = 0x00000808,\r\n    VMCS_FIELD_GUEST_GS_SELECTOR = 0x0000080a,\r\n    VMCS_FIELD_GUEST_LDTR_SELECTOR = 0x0000080c,\r\n    VMCS_FIELD_GUEST_TR_SELECTOR = 0x0000080e,\r\n    VMCS_FIELD_GUEST_INTR_STATUS = 0x00000810,\r\n    VMCS_FIELD_GUEST_PML_INDEX = 0x00000812,\r\n\r\n    //! Vol 3C, Table B-3. Encodings for 16-Bit Host-State Fields (0000_11xx_xxxx_xxx0B)\r\n    VMCS_FIELD_HOST_ES_SELECTOR = 0x00000c00,\r\n    VMCS_FIELD_HOST_CS_SELECTOR = 0x00000c02,\r\n    VMCS_FIELD_HOST_SS_SELECTOR = 0x00000c04,\r\n    VMCS_FIELD_HOST_DS_SELECTOR = 0x00000c06,\r\n    VMCS_FIELD_HOST_FS_SELECTOR = 0x00000c08,\r\n    VMCS_FIELD_HOST_GS_SELECTOR = 0x00000c0a,\r\n    VMCS_FIELD_HOST_TR_SELECTOR = 0x00000c0c,\r\n\r\n    //! Vol 3C, Table B-3. Encodings for 16-Bit Host-State Fields (0000_11xx_xxxx_xxx0B)\r\n    VMCS_FIELD_IO_BITMAP_A_FULL = 0x00002000,\r\n    VMCS_FIELD_IO_BITMAP_A_HIGH = 0x00002001,\r\n    VMCS_FIELD_IO_BITMAP_B_FULL = 0x00002002,\r\n    VMCS_FIELD_IO_BITMAP_B_HIGH = 0x00002003,\r\n    VMCS_FIELD_MSR_BITMAP_FULL = 0x00002004,\r\n    VMCS_FIELD_MSR_BITMAP_HIGH = 0x00002005,\r\n    VMCS_FIELD_VM_EXIT_MSR_STORE_ADDR_FULL = 0x00002006,\r\n    VMCS_FIELD_VM_EXIT_MSR_STORE_ADDR_HIGH = 0x00002007,\r\n    VMCS_FIELD_VM_EXIT_MSR_LOAD_ADDR_FULL = 0x00002008,\r\n    VMCS_FIELD_VM_EXIT_MSR_LOAD_ADDR_HIGH = 0x00002009,\r\n    VMCS_FIELD_VM_ENTRY_MSR_LOAD_ADDR_FULL = 0x0000200a,\r\n    VMCS_FIELD_VM_ENTRY_MSR_LOAD_ADDR_HIGH = 0x0000200b,\r\n    VMCS_FIELD_EXECUTIVE_VMCS_PTR_FULL = 0x0000200c,\r\n    VMCS_FIELD_EXECUTIVE_VMCS_PTR_HIGH = 0x0000200d,\r\n    VMCS_FIELD_PML_ADDRESS_FULL = 0x0000200e,\r\n    VMCS_FIELD_PML_ADDRESS_HIGH = 0x0000200f,\r\n    VMCS_FIELD_TSC_OFFSET_FULL = 0x00002010,\r\n    VMCS_FIELD_TSC_OFFSET_HIGH = 0x00002011,\r\n    VMCS_FIELD_VIRTUAL_APIC_PAGE_ADDR_FULL = 0x00002012,\r\n    VMCS_FIELD_VIRTUAL_APIC_PAGE_ADDR_HIGH = 0x00002013,\r\n    VMCS_FIELD_APIC_ACCESS_ADDR_FULL = 0x00002014,\r\n    VMCS_FIELD_APIC_ACCESS_ADDR_HIGH = 0x00002015,\r\n    VMCS_FIELD_PI_DESC_ADDR_FULL = 0x00002016,\r\n    VMCS_FIELD_PI_DESC_ADDR_HIGH = 0x00002017,\r\n    VMCS_FIELD_VM_FUNCTION_CONTROL_FULL = 0x00002018,\r\n    VMCS_FIELD_VM_FUNCTION_CONTROL_HIGH = 0x00002019,\r\n    VMCS_FIELD_EPT_POINTER_FULL = 0x0000201a,\r\n    VMCS_FIELD_EPT_POINTER_HIGH = 0x0000201b,\r\n    VMCS_FIELD_EOI_EXIT_BITMAP0_FULL = 0x0000201c,\r\n    VMCS_FIELD_EOI_EXIT_BITMAP0_HIGH = 0x0000201d,\r\n    VMCS_FIELD_EPTP_LIST_ADDR_FULL = 0x00002024,\r\n    VMCS_FIELD_EPTP_LIST_ADDR_HIGH = 0x00002025,\r\n    VMCS_FIELD_VMREAD_BITMAP_FULL = 0x00002026,\r\n    VMCS_FIELD_VMREAD_BITMAP_HIGH = 0x00002027,\r\n    VMCS_FIELD_VMWRITE_BITMAP_FULL = 0x00002028,\r\n    VMCS_FIELD_VMWRITE_BITMAP_HIGH = 0x00002029,\r\n    VMCS_FIELD_VIRT_EXCEPTION_INFO_FULL = 0x0000202a,\r\n    VMCS_FIELD_VIRT_EXCEPTION_INFO_HIGH = 0x0000202b,\r\n    VMCS_FIELD_XSS_EXIT_BITMAP_FULL = 0x0000202c,\r\n    VMCS_FIELD_XSS_EXIT_BITMAP_HIGH = 0x0000202d,\r\n    VMCS_FIELD_TSC_MULTIPLIER_FULL = 0x00002032,\r\n    VMCS_FIELD_TSC_MULTIPLIER_HIGH = 0x00002033,\r\n    \r\n    //! Vol 3C, Table B-5. Encodings for 64-Bit Read-Only Data Field (0010_01xx_xxxx_xxxAb)\r\n    VMCS_FIELD_GUEST_PHYSICAL_ADDRESS_FULL = 0x00002400,\r\n    VMCS_FIELD_GUEST_PHYSICAL_ADDRESS_HIGH = 0x00002401,\r\n    \r\n    //! Vol 3C, Table B-6. Encodings for 64-Bit Guest-State Fields (0010_10xx_xxxx_xxxAb)\r\n    VMCS_FIELD_VMCS_LINK_POINTER_FULL = 0x00002800,\r\n    VMCS_FIELD_VMCS_LINK_POINTER_HIGH = 0x00002801,\r\n    VMCS_FIELD_GUEST_IA32_DEBUGCTL_FULL = 0x00002802,\r\n    VMCS_FIELD_GUEST_IA32_DEBUGCTL_HIGH = 0x00002803,\r\n    VMCS_FIELD_GUEST_PAT_FULL = 0x00002804,\r\n    VMCS_FIELD_GUEST_PAT_HIGH = 0x00002805,\r\n    VMCS_FIELD_GUEST_EFER_FULL = 0x00002806,\r\n    VMCS_FIELD_GUEST_EFER_HIGH = 0x00002807,\r\n    VMCS_FIELD_GUEST_PERF_GLOBAL_CTRL_FULL = 0x00002808,\r\n    VMCS_FIELD_GUEST_PERF_GLOBAL_CTRL_HIGH = 0x00002809,\r\n    VMCS_FIELD_GUEST_PDPTE0_FULL = 0x0000280a,\r\n    VMCS_FIELD_GUEST_PDPTE0_HIGH = 0x0000280b,\r\n    VMCS_FIELD_GUEST_PDPTE1_FULL = 0x0000280c,\r\n    VMCS_FIELD_GUEST_PDPTE1_HIGH = 0x0000280d,\r\n    VMCS_FIELD_GUEST_PDPTE2_FULL = 0x0000280e,\r\n    VMCS_FIELD_GUEST_PDPTE2_HIGH = 0x0000280f,\r\n    VMCS_FIELD_GUEST_PDPTE3_FULL = 0x00002810,\r\n    VMCS_FIELD_GUEST_PDPTE3_HIGH = 0x00002811,\r\n    VMCS_FIELD_GUEST_BNDCFGS_FULL = 0x00002812,\r\n    VMCS_FIELD_GUEST_BNDCFGS_HIGH = 0x00002813,\r\n    \r\n    //! Vol 3C, Table B-7. Encodings for 64-Bit Host-State Fields (0010_11xx_xxxx_xxxAb)\r\n    VMCS_FIELD_HOST_PAT_FULL = 0x00002c00,\r\n    VMCS_FIELD_HOST_PAT_HIGH = 0x00002c01,\r\n    VMCS_FIELD_HOST_EFER_FULL = 0x00002c02,\r\n    VMCS_FIELD_HOST_EFER_HIGH = 0x00002c03,\r\n    VMCS_FIELD_HOST_PERF_GLOBAL_CTRL_FULL = 0x00002c04,\r\n    VMCS_FIELD_HOST_PERF_GLOBAL_CTRL_HIGH = 0x00002c05,\r\n\r\n    //! Vol 3C, Table B-8. Encodings for 32-Bit Control Fields (0100_00xx_xxxx_xxx0B)\r\n    VMCS_FIELD_PINBASED_CTLS = 0x00004000,\r\n    VMCS_FIELD_PROCBASED_CTLS = 0x00004002,\r\n    VMCS_FIELD_EXCEPTION_BITMAP = 0x00004004,\r\n    VMCS_FIELD_PAGE_FAULT_ERROR_CODE_MASK = 0x00004006,\r\n    VMCS_FIELD_PAGE_FAULT_ERROR_CODE_MATCH = 0x00004008,\r\n    VMCS_FIELD_CR3_TARGET_COUNT = 0x0000400a,\r\n    VMCS_FIELD_VMEXIT_CTLS = 0x0000400c,\r\n    VMCS_FIELD_VM_EXIT_MSR_STORE_COUNT = 0x0000400e,\r\n    VMCS_FIELD_VM_EXIT_MSR_LOAD_COUNT = 0x00004010,\r\n    VMCS_FIELD_VMENTRY_CTLS = 0x00004012,\r\n    VMCS_FIELD_VM_ENTRY_MSR_LOAD_COUNT = 0x00004014,\r\n    VMCS_FIELD_VM_ENTRY_INTR_INFO = 0x00004016,\r\n    VMCS_FIELD_VM_ENTRY_EXCEPTION_ERROR_CODE = 0x00004018,\r\n    VMCS_FIELD_VM_ENTRY_INSTRUCTION_LEN = 0x0000401a,\r\n    VMCS_FIELD_TPR_THRESHOLD = 0x0000401c,\r\n    VMCS_FIELD_PROCBASED_CTLS2 = 0x0000401e,\r\n    VMCS_FIELD_PLE_GAP = 0x00004020,\r\n    VMCS_FIELD_PLE_WINDOW = 0x00004022,\r\n\r\n    //! Vol 3C, Table B-9. Encodings for 32-Bit Read-Only Data Fields (0100_01xx_xxxx_xxx0B)\r\n    VMCS_FIELD_VM_INSTRUCTION_ERROR = 0x00004400,\r\n    VMCS_FIELD_VM_EXIT_REASON = 0x00004402,\r\n    VMCS_FIELD_VM_EXIT_INTR_INFO = 0x00004404,\r\n    VMCS_FIELD_VM_EXIT_INTR_ERROR_CODE = 0x00004406,\r\n    VMCS_FIELD_IDT_VECTORING_INFO = 0x00004408,\r\n    VMCS_FIELD_IDT_VECTORING_ERROR_CODE = 0x0000440a,\r\n    VMCS_FIELD_VM_EXIT_INSTRUCTION_LEN = 0x0000440c,\r\n    VMCS_FIELD_INSTRUCTION_INFO = 0x0000440e,\r\n\r\n    //! Vol 3C, Table B-10. Encodings for 32-Bit Guest-State Fields (0100_10xx_xxxx_xxx0B)\r\n    VMCS_FIELD_GUEST_ES_LIMIT = 0x00004800,\r\n    VMCS_FIELD_GUEST_CS_LIMIT = 0x00004802,\r\n    VMCS_FIELD_GUEST_SS_LIMIT = 0x00004804,\r\n    VMCS_FIELD_GUEST_DS_LIMIT = 0x00004806,\r\n    VMCS_FIELD_GUEST_FS_LIMIT = 0x00004808,\r\n    VMCS_FIELD_GUEST_GS_LIMIT = 0x0000480a,\r\n    VMCS_FIELD_GUEST_LDTR_LIMIT = 0x0000480c,\r\n    VMCS_FIELD_GUEST_TR_LIMIT = 0x0000480e,\r\n    VMCS_FIELD_GUEST_GDTR_LIMIT = 0x00004810,\r\n    VMCS_FIELD_GUEST_IDTR_LIMIT = 0x00004812,\r\n    VMCS_FIELD_GUEST_ES_AR_BYTES = 0x00004814,\r\n    VMCS_FIELD_GUEST_CS_AR_BYTES = 0x00004816,\r\n    VMCS_FIELD_GUEST_SS_AR_BYTES = 0x00004818,\r\n    VMCS_FIELD_GUEST_DS_AR_BYTES = 0x0000481a,\r\n    VMCS_FIELD_GUEST_FS_AR_BYTES = 0x0000481c,\r\n    VMCS_FIELD_GUEST_GS_AR_BYTES = 0x0000481e,\r\n    VMCS_FIELD_GUEST_LDTR_AR_BYTES = 0x00004820,\r\n    VMCS_FIELD_GUEST_TR_AR_BYTES = 0x00004822,\r\n    VMCS_FIELD_GUEST_INTERRUPTIBILITY_INFO = 0x00004824,\r\n    VMCS_FIELD_GUEST_ACTIVITY_STATE = 0x00004826,\r\n    VMCS_FIELD_GUEST_SMBASE = 0x00004828,\r\n    VMCS_FIELD_GUEST_SYSENTER_CS = 0x0000482a,\r\n    VMCS_FIELD_GUEST_PREEMPTION_TIMER = 0x0000482e,\r\n\r\n    //! Vol 3C, Table B-11. Encoding for 32-Bit Host-State Field (0100_11xx_xxxx_xxx0B)\r\n    VMCS_FIELD_HOST_SYSENTER_CS = 0x00004c00,\r\n\r\n    //! Vol 3C, Table B-12. Encodings for Natural-Width Control Fields (0110_00xx_xxxx_xxx0B)\r\n    VMCS_FIELD_CR0_GUEST_HOST_MASK = 0x00006000,\r\n    VMCS_FIELD_CR4_GUEST_HOST_MASK = 0x00006002,\r\n    VMCS_FIELD_CR0_READ_SHADOW = 0x00006004,\r\n    VMCS_FIELD_CR4_READ_SHADOW = 0x00006006,\r\n    VMCS_FIELD_CR3_TARGET_VALUE0 = 0x00006008,\r\n    VMCS_FIELD_CR3_TARGET_VALUE1 = 0x0000600a,\r\n    VMCS_FIELD_CR3_TARGET_VALUE2 = 0x0000600c,\r\n    VMCS_FIELD_CR3_TARGET_VALUE3 = 0x0000600e,\r\n\r\n    //! Vol 3C, Table B-13. Encodings for Natural-Width Read-Only Data Fields (0110_01xx_xxxx_xxx0B)\r\n    VMCS_FIELD_EXIT_QUALIFICATION = 0x00006400,\r\n    VMCS_FIELD_IO_RCX = 0x00006402,\r\n    VMCS_FIELD_IO_RSI = 0x00006404,\r\n    VMCS_FIELD_IO_RDI = 0x00006406,\r\n    VMCS_FIELD_IO_RIP = 0x00006408,\r\n    VMCS_FIELD_GUEST_LINEAR_ADDRESS = 0x0000640a,\r\n\r\n    //! Vol 3C, Table B-14. Encodings for Natural-Width Guest-State Fields (0110_10xx_xxxx_xxx0B)\r\n    VMCS_FIELD_GUEST_CR0 = 0x00006800,\r\n    VMCS_FIELD_GUEST_CR3 = 0x00006802,\r\n    VMCS_FIELD_GUEST_CR4 = 0x00006804,\r\n    VMCS_FIELD_GUEST_ES_BASE = 0x00006806,\r\n    VMCS_FIELD_GUEST_CS_BASE = 0x00006808,\r\n    VMCS_FIELD_GUEST_SS_BASE = 0x0000680a,\r\n    VMCS_FIELD_GUEST_DS_BASE = 0x0000680c,\r\n    VMCS_FIELD_GUEST_FS_BASE = 0x0000680e,\r\n    VMCS_FIELD_GUEST_GS_BASE = 0x00006810,\r\n    VMCS_FIELD_GUEST_LDTR_BASE = 0x00006812,\r\n    VMCS_FIELD_GUEST_TR_BASE = 0x00006814,\r\n    VMCS_FIELD_GUEST_GDTR_BASE = 0x00006816,\r\n    VMCS_FIELD_GUEST_IDTR_BASE = 0x00006818,\r\n    VMCS_FIELD_GUEST_DR7 = 0x0000681a,\r\n    VMCS_FIELD_GUEST_RSP = 0x0000681c,\r\n    VMCS_FIELD_GUEST_RIP = 0x0000681e,\r\n    VMCS_FIELD_GUEST_RFLAGS = 0x00006820,\r\n    VMCS_FIELD_GUEST_PENDING_DBG_EXCEPTIONS = 0x00006822,\r\n    VMCS_FIELD_GUEST_SYSENTER_ESP = 0x00006824,\r\n    VMCS_FIELD_GUEST_SYSENTER_EIP = 0x00006826,\r\n    \r\n    //! Vol 3C, Table B-15. Encodings for Natural-Width Host-State Fields (0110_11xx_xxxx_xxx0B)\r\n    VMCS_FIELD_HOST_CR0 = 0x00006c00,\r\n    VMCS_FIELD_HOST_CR3 = 0x00006c02,\r\n    VMCS_FIELD_HOST_CR4 = 0x00006c04,\r\n    VMCS_FIELD_HOST_FS_BASE = 0x00006c06,\r\n    VMCS_FIELD_HOST_GS_BASE = 0x00006c08,\r\n    VMCS_FIELD_HOST_TR_BASE = 0x00006c0a,\r\n    VMCS_FIELD_HOST_GDTR_BASE = 0x00006c0c,\r\n    VMCS_FIELD_HOST_IDTR_BASE = 0x00006c0e,\r\n    VMCS_FIELD_HOST_SYSENTER_ESP = 0x00006c10,\r\n    VMCS_FIELD_HOST_SYSENTER_EIP = 0x00006c12,\r\n    VMCS_FIELD_HOST_RSP = 0x00006c14,\r\n    VMCS_FIELD_HOST_RIP = 0x00006c16,\r\n} VMCS_FIELD_ENCODING, *PVMCS_FIELD_ENCODING;\r\n\r\n//! Vol 3C, Table C-1. Basic Exit Reasons\r\ntypedef enum _VMEXIT_REASON\r\n{\r\n    VMEXIT_REASON_EXCEPTION_NMI = 0,\r\n    VMEXIT_REASON_EXTERNAL_INTERRUPT = 1,\r\n    VMEXIT_REASON_TRIPLE_FAULT = 2,\r\n    VMEXIT_REASON_INIT = 3,\r\n    VMEXIT_REASON_SIPI = 4,\r\n    VMEXIT_REASON_IO_SMI = 5,\r\n    VMEXIT_REASON_OTHER_SMI = 6,\r\n    VMEXIT_REASON_PENDING_VIRT_INTR = 7,\r\n    VMEXIT_REASON_PENDING_VIRT_NMI = 8,\r\n    VMEXIT_REASON_TASK_SWITCH = 9,\r\n    VMEXIT_REASON_CPUID = 10,\r\n    VMEXIT_REASON_GETSEC = 11,\r\n    VMEXIT_REASON_HLT = 12,\r\n    VMEXIT_REASON_INVD = 13,\r\n    VMEXIT_REASON_INVLPG = 14,\r\n    VMEXIT_REASON_RDPMC = 15,\r\n    VMEXIT_REASON_RDTSC = 16,\r\n    VMEXIT_REASON_RSM = 17,\r\n    VMEXIT_REASON_VMCALL = 18,\r\n    VMEXIT_REASON_VMCLEAR = 19,\r\n    VMEXIT_REASON_VMLAUNCH = 20,\r\n    VMEXIT_REASON_VMPTRLD = 21,\r\n    VMEXIT_REASON_VMPTRST = 22,\r\n    VMEXIT_REASON_VMREAD = 23,\r\n    VMEXIT_REASON_VMRESUME = 24,\r\n    VMEXIT_REASON_VMWRITE = 25,\r\n    VMEXIT_REASON_VMXOFF = 26,\r\n    VMEXIT_REASON_VMXON = 27,\r\n    VMEXIT_REASON_CR_ACCESS = 28,\r\n    VMEXIT_REASON_DR_ACCESS = 29,\r\n    VMEXIT_REASON_IO_INSTRUCTION = 30,\r\n    VMEXIT_REASON_MSR_READ = 31,\r\n    VMEXIT_REASON_MSR_WRITE = 32,\r\n    VMEXIT_REASON_INVALID_GUEST_STATE = 33,\r\n    VMEXIT_REASON_MSR_LOADING = 34,\r\n    VMEXIT_REASON_MWAIT_INSTRUCTION = 36,\r\n    VMEXIT_REASON_MONITOR_TRAP_FLAG = 37,\r\n    VMEXIT_REASON_MONITOR_INSTRUCTION = 39,\r\n    VMEXIT_REASON_PAUSE_INSTRUCTION = 40,\r\n    VMEXIT_REASON_MCE_DURING_VMENTRY = 41,\r\n    VMEXIT_REASON_TPR_BELOW_THRESHOLD = 43,\r\n    VMEXIT_REASON_APIC_ACCESS = 44,\r\n    VMEXIT_REASON_ACCESS_GDTR_OR_IDTR = 46,\r\n    VMEXIT_REASON_ACCESS_LDTR_OR_TR = 47,\r\n    VMEXIT_REASON_EPT_VIOLATION = 48,\r\n    VMEXIT_REASON_EPT_MISCONFIG = 49,\r\n    VMEXIT_REASON_INVEPT = 50,\r\n    VMEXIT_REASON_RDTSCP = 51,\r\n    VMEXIT_REASON_VMX_PREEMPTION_TIMER_EXPIRED = 52,\r\n    VMEXIT_REASON_INVVPID = 53,\r\n    VMEXIT_REASON_WBINVD = 54,\r\n    VMEXIT_REASON_XSETBV = 55,\r\n    VMEXIT_REASON_APIC_WRITE = 56,\r\n    VMEXIT_REASON_RDRAND = 57,\r\n    VMEXIT_REASON_INVPCID = 58,\r\n    VMEXIT_REASON_RDSEED = 61,\r\n    VMEXIT_REASON_PML_FULL = 62,\r\n    VMEXIT_REASON_XSAVES = 63,\r\n    VMEXIT_REASON_XRSTORS = 64,\r\n    VMEXIT_REASON_PCOMMIT = 65,\r\n    VMEXIT_REASONS_MAX\r\n} VMEXIT_REASON, *PVMEXIT_REASON;\r\n\r\n//! Vol 3C, 24.4.2 Guest Non-Register State\r\n// (VMCS_FIELD_GUEST_ACTIVITY_STATE)\r\ntypedef enum _VMX_GUEST_ACTIVITY_STATE\r\n{\r\n    VMX_GUEST_ACTIVITY_STATE_ACTIVE = 0,\r\n    VMX_GUEST_ACTIVITY_STATE_HLT = 1,\r\n    VMX_GUEST_ACTIVITY_STATE_SHUTDOWN = 2,\r\n    VMX_GUEST_ACTIVITY_STATE_WAIT_FOR_SIPI = 3,\r\n} VMX_GUEST_ACTIVITY_STATE, *PVMX_GUEST_ACTIVITY_STATE;\r\n\r\n//! Vol 3C, Table 24-5. Definitions of Pin-Based VM-Execution Controls\r\n// (VMCS_FIELD_PINBASED_CTLS)\r\ntypedef union _VMX_PINBASED_CTLS\r\n{\r\n    UINT32 dwValue;\r\n    struct {\r\n        UINT32 ExternalIntExit : 1;      //!< 0    External interrupts cause VM exits\r\n        UINT32 Reserved0 : 2;            //!< 1-2\r\n        UINT32 NmiExit : 1;              //!< 3    Non-maskable interrupts (NMIs) cause VM exits\r\n        UINT32 Reserved1 : 1;            //!< 4\r\n        UINT32 VirtNmiExit : 1;          //!< 5    NMIs are never blocked and the \"blocking by NMI\"\r\n                                         //        bit(bit 3) in the interruptibility - state field \r\n                                         //        indicates \"virtual - NMI blocking\"\r\n        UINT32 PreemptionTimer : 1;      //!< 6    Use VMX-preemption timer counts down in VMX non-root operation\r\n        UINT32 ProcessApicInts : 1;      //!< 7    Write posted interrupts to virtual APIC page\r\n        UINT32 Reserved2 : 24;           //!< 8-31\r\n    };\r\n} VMX_PINBASED_CTLS, *PVMX_PINBASED_CTLS;\r\nC_ASSERT(sizeof(UINT32) == sizeof(VMX_PINBASED_CTLS));\r\n\r\n//! Vol 3C, Table 24-6. Definitions of Primary Processor-Based VM-Execution Controls\r\n// (VMCS_FIELD_PROCBASED_CTLS)\r\ntypedef union _VMX_PROCBASED_CTLS\r\n{\r\n    UINT32 dwValue;\r\n    struct {\r\n        UINT32 Reserved0 : 2;           //!< 0-1\r\n        UINT32 IntWindowExit : 1;       //!< 2        A VM exit occurs at the beginning of any instruction \r\n                                        //            if RFLAGS.IF = 1\r\n        UINT32 UseTscOffseting : 1;     // 3        RDTSC, RDTSCP and IA32_TIME_STAMP_COUNTER MSR return \r\n                                        //            a value modified by the TSC offset field\r\n        UINT32 Reserved1 : 3;           //!< 4-6\r\n        UINT32 HltExit : 1;             //!< 7        HLT causes a VM exit\r\n        UINT32 Reserved2 : 1;           //!< 8\r\n        UINT32 InvlpgExit : 1;          //!< 9        INVLPG causes a VM exit\r\n        UINT32 MwaitExit : 1;           //!< 10        MWAIT causes a VM exit\r\n        UINT32 RdpmcExit : 1;           //!< 11        RDPMC causes a VM exit\r\n        UINT32 RdtscExit : 1;           //!< 12        RDTSC causes a VM exit\r\n        UINT32 Reserved3 : 2;           //!< 13-14\r\n        UINT32 Cr3LoadExit : 1;         //!< 15        MOV to CR3 causes a VM exit\r\n        UINT32 Cr3StoreExit : 1;        //!< 16        MOV from CR3 causes a VM exit\r\n        UINT32 Reserved4 : 2;           //!< 17-18\r\n        UINT32 Cr8LoadExit : 1;         //!< 19        MOV to CR8 causes a VM exit\r\n        UINT32 Cr8StoreExit : 1;        //!< 20        MOV from CR8 causes a VM exit\r\n        UINT32 UseTprShadow : 1;        //!< 21        Activates the TPR shadow\r\n        UINT32 NmiWindowExit : 1;       //!< 22        VM exit occurs at the beginning of any instruction\r\n                                        //            if there is no virtual - NMI blocking\r\n        UINT32 MovDrExit : 1;           //!< 23        MOV to/from DR causes a VM exit\r\n        UINT32 UncondIoExit : 1;        //!< 24        I/O instruction cause a VM exit, ignored if using I/O bitmaps\r\n        UINT32 UseIoBitmaps : 1;        //!< 25        Use I/O bitmaps\r\n        UINT32 Reserved5 : 1;           //!< 26\r\n        UINT32 MonitorTrapFlag : 1;     // 27        Monitor trap flag debugging feature is enabled\r\n        UINT32 UseMsrBitmaps : 1;       //!< 28        Use MSR bitmaps\r\n        UINT32 MonitorExit : 1;         //!< 29        MONITOR causes a VM exit\r\n        UINT32 PauseExit : 1;           //!< 30        PAUSE causes a VM exit\r\n        UINT32 UseProcbased2 : 1;       //!< 31        Determines whether to use VMX_PROCBASED_CTLS2 or not\r\n    };\r\n} VMX_PROCBASED_CTLS, *PVMX_PROCBASED_CTLS;\r\nC_ASSERT(sizeof(UINT32) == sizeof(VMX_PROCBASED_CTLS));\r\n\r\n//! Vol 3C, Table 24-7. Definitions of Secondary Processor-Based VM-Execution Controls\r\n// (VMCS_FIELD_PROCBASED_CTLS2)\r\ntypedef union _VMX_PROCBASED_CTLS2\r\n{\r\n    UINT32 dwValue;\r\n    struct {\r\n        UINT32 VirtApicAccess : 1;      //!< 0        a VM exit occurs on any attempt to access\r\n                                        //            data on the page with the APIC - access address\r\n        UINT32 EnableEpt : 1;           //!< 1        Enable Extended Page Tables\r\n        UINT32 DescriptorTableExit : 1; //!< 2        LGDT, LIDT, LLDT, LTR, SGDT, SIDT, SLDT, and STR cause VM exits\r\n        UINT32 EnableRdtscp : 1;        //!< 3        When clear RTSCP causes an Invalid Opcode fault\r\n        UINT32 VirtX2ApicAccess : 1;    //!< 4        Causes RDMSR and WRMSR to IA32_X2APIC_TPR to use the TPR shadow\r\n        UINT32 EnableVpid : 1;          //!< 5        cached translations of linear addresses \r\n                                        //            are associated with a virtual - processor identifier\r\n        UINT32 WbinvdExit : 1;          //!< 6        WBINVD causes a VM exit\r\n        UINT32 UnrestrictedGuest : 1;   //!< 7        Guest software may run in unpaged protected mode or \r\n                                        //            in real - address mode\r\n        UINT32 ApicRegister : 1;        //!< 8        If 1, virtualize certain APIC accesses\r\n        UINT32 VirtIntExit : 1;         //!< 9        Enable VM-Exits on virtual interrupts and writes \r\n                                        //            to the APIC registers\r\n        UINT32 PauseLoopExit : 1;       //!< 10        A series of executions of PAUSE can cause a VM exit\r\n        UINT32 RdrandExit : 1;          //!< 11        RDRAND causes a VM-Exit\r\n        UINT32 InvpcidExit : 1;         //!< 12        INVPCID causes a VM-Exit\r\n        UINT32 EnableVmFunc : 1;        //!< 13        Enable VMFUNC in non-root mode\r\n        UINT32 EnableShadowVmcs : 1;    //!< 14        VMREAD/VMWRITE access a shadow in non-root mode\r\n        UINT32 Reserved0 : 1;           //!< 15        0\r\n        UINT32 RdseedExit : 1;          //!< 16        RDSEED causes a VM-Exit\r\n        UINT32 EnablePml : 1;           //!< 17        Memory access that sets EPT dirty bit will \r\n                                        //            also add an entry to page-modification log\r\n        UINT32 EnableEptVe: 1;          //!< 18        EPT Violations may cause a #VE fault instead of a VM-Exit\r\n        UINT32 Reserved1 : 1;           //!< 19        0\r\n        UINT32 XSaveStorExit : 1;       //!< 20        XSAVES and XRSTORS cause a VM-Exit\r\n        UINT32 Reserved2 : 4;           //!< 21-24    0\r\n        UINT32 TscScaling : 1;          //!< 25        Reads of timestamp counter are modified by VMCS_FIELD_TSC_MULTIPLIER\r\n        UINT32 Reserved3 : 6;           //!< 26-31\r\n    };\r\n} VMX_PROCBASED_CTLS2, *PVMX_PROCBASED_CTLS2;\r\nC_ASSERT(sizeof(UINT32) == sizeof(VMX_PROCBASED_CTLS2));\r\n\r\n//! Vol 3C, Table 21-9. Definitions of VM-Exit Controls (VMCS_FIELD_VMEXIT_CTLS)\r\ntypedef union _VMX_EXIT_CTLS\r\n{\r\n    UINT32 dwValue;\r\n    struct {\r\n        UINT32 Reserved0 : 2;               //!< 0-1\r\n        UINT32 SaveDebugControls : 1;       //!< 2        DR7 and the IA32_DEBUGCTL MSR are saved on VM exit\r\n        UINT32 Reserved1 : 6;               //!< 3-8\r\n        UINT32 IsHost64bit : 1;             //!< 9        Is host in 64bit mode\r\n        UINT32 Reserved2 : 2;               //!< 10-11\r\n        UINT32 LoadIa32PerfGlobalCtrl : 1;  //!< 12        IA32_PERF_GLOBAL_CTRL MSR is loaded on VM exit\r\n        UINT32 Reserved3 : 2;               //!< 13-14\r\n        UINT32 AckIntOnExit : 1;            //!< 15        Acknowledge the interrupt, acquiring the vector data\r\n        UINT32 Reserved4 : 2;               //!< 16-17\r\n        UINT32 SaveIa32Pat : 1;             //!< 18        IA32_PAT MSR is saved on VM exit\r\n        UINT32 LoadIa32Pat : 1;             //!< 19        IA32_PAT MSR is loaded on VM exit\r\n        UINT32 SaveIa32Efer : 1;            //!< 20        IA32_EFER MSR is saved on VM exit\r\n        UINT32 LoadIa32Efer : 1;            //!< 21        IA32_EFER MSR is loaded on VM exit\r\n        UINT32 SavePreemtptionTimer : 1;    //!< 22        Save the current value of VMX preemption timer\r\n        UINT32 Reserved5 : 9;               //!< 23-31\r\n    };\r\n} VMX_EXIT_CTLS, *PVMX_EXIT_CTLS;\r\nC_ASSERT(sizeof(UINT32) == sizeof(VMX_EXIT_CTLS));\r\n\r\n//! Vol 3C, Table 21-11. Definitions of VM-Entry Controls (VMCS_FIELD_VMENTRY_CTLS)\r\ntypedef union _VMX_ENTRY_CTLS\r\n{\r\n    UINT32 dwValue;\r\n    struct {\r\n        UINT32 Reserved0 : 2;               //!< 0-1\r\n        UINT32 LoadDebugControls : 1;       //!< 2    DR7 and the IA32_DEBUGCTL MSR are loaded on VM exit\r\n        UINT32 Reserved1 : 6;               //!< 3-8\r\n        UINT32 IsGuest64bit : 1;            //!< 9    Is guest in 64bit mode\r\n        UINT32 EnterSmm : 1;                //!< 10    Is guest in SMM mode\r\n        UINT32 DisableDualMonitor : 1;      //!< 11    Restore default behavior for SMM after VM entry\r\n        UINT32 Reserved2 : 1;               //!< 12\r\n        UINT32 LoadIa32PerfGlobalCtrl : 1;  //!< 13    IA32_PERF_GLOBAL_CTRL MSR is loaded on VM entry\r\n        UINT32 LoadIa32Pat : 1;             //!< 14    IA32_PAT is loaded on VM entry\r\n        UINT32 LoadIa32Efer : 1;            //!< 15    IA32_EFER is loaded on VM entry\r\n        UINT32 Reserved3 : 16;              //!< 16-31\r\n    };\r\n} VMX_ENTRY_CTLS, *PVMX_ENTRY_CTLS;\r\nC_ASSERT(sizeof(UINT32) == sizeof(VMX_ENTRY_CTLS));\r\n\r\n//! Vol 3C, 21.6.3 Exception Bitmap (VMCS_FIELD_EXCEPTION_BITMAP)\r\ntypedef union _VMX_EXCEPTION_BITMAP\r\n{\r\n    UINT32 dwValue;\r\n    struct {\r\n        UINT32 De : 1;            //!< 0    Divide - by - zero Error #DE\r\n        UINT32 Db : 1;            //!< 1    Debug Fault/Trap #DB\r\n        UINT32 Nmi : 1;           //!< 2    Non Maskable Interrupt\r\n        UINT32 Bp : 1;            //!< 3    Breakpoint #BP\r\n        UINT32 Of : 1;            //!< 4    Overflow #OF\r\n        UINT32 Br : 1;            //!< 5    Bound Range Exceeded #BR\r\n        UINT32 Ud : 1;            //!< 6    Invalid Opcode #UD\r\n        UINT32 Nm : 1;            //!< 7    Device Not Available #NM\r\n        UINT32 Df : 1;            //!< 8    Double Fault #DF\r\n        UINT32 So : 1;            //!< 9    Coprocessor Segment Overrun Fault\r\n        UINT32 Ts : 1;            //!< 10    Invalid TSS #TS\r\n        UINT32 Np : 1;            //!< 11    Segment Not Present #NP\r\n        UINT32 Ss : 1;            //!< 12    Stack - Segment Fault #SS\r\n        UINT32 Gp : 1;            //!< 13    General Protection Fault #GP\r\n        UINT32 Pf : 1;            //!< 14    Page Fault #PF\r\n        UINT32 Reserved0 : 1;     //!< 15\r\n        UINT32 Mf : 1;            //!< 16    x87 Floating - Point Exception\r\n        UINT32 Ac : 1;            //!< 17    Alignment Check Fault #AC\r\n        UINT32 Mc : 1;            //!< 18    Machine Check #MC\r\n        UINT32 Xm : 1;            //!< 19    SIMD Floating - Point Exception #XM / #XF\r\n        UINT32 Ve : 1;            //!< 20    Virtualization Exception #VE\r\n        UINT32 Reserved1 : 9;     //!< 21-29\r\n        UINT32 Sx : 1;            //!< 30    Security Exception #SX\r\n        UINT32 Reserved2 : 1;     //!< 31\r\n    };\r\n} VMX_EXCEPTION_BITMAP, *PVMX_EXCEPTION_BITMAP;\r\nC_ASSERT(sizeof(UINT32) == sizeof(VMX_EXCEPTION_BITMAP));\r\n\r\n//! Vol 3C, 21.6.4 I/O-Bitmap Addresses (VMCS_FIELD_IO_BITMAP_A_FULL)\r\ntypedef struct DECLSPEC_ALIGN(PAGE_SIZE) _VMX_IO_BITMAPS\r\n{\r\n    UINT8 tIoBitmapA[PAGE_SIZE]; //!< 0 - 0x7FFF\r\n    UINT8 tIoBitmapB[PAGE_SIZE]; //!< 0x8000 - 0xFFFF\r\n} VMX_IO_BITMAPS, *PVMX_IO_BITMAPS;\r\nC_ASSERT((2 * PAGE_SIZE) == sizeof(VMX_IO_BITMAPS));\r\n\r\n//! Vol 3C, 21.6.9 MSR-Bitmap Address (VMCS_FIELD_MSR_BITMAP_FULL)\r\ntypedef struct DECLSPEC_ALIGN(PAGE_SIZE) _VMX_MSR_BITMAPS\r\n{\r\n    UINT8 tRdmsrL[PAGE_SIZE / 4]; //!< RDMSR 0 - 0x1FFF\r\n    UINT8 tRdmsrH[PAGE_SIZE / 4]; //!< RDMSR 0xC0000000 - 0xC0001FFF\r\n    UINT8 tWrmsrL[PAGE_SIZE / 4]; //!< WRMSR 0 - 0x1FFF\r\n    UINT8 tWrmsrH[PAGE_SIZE / 4]; //!< WRMSR 0xC0000000 - 0xC0001FFF\r\n} VMX_MSR_BITMAPS, *PVMX_MSR_BITMAPS;\r\nC_ASSERT(PAGE_SIZE == sizeof(VMX_MSR_BITMAPS));\r\n\r\ntypedef enum _VMX_ADDRESS_SIZE\r\n{\r\n    VMX_ADDRESS_SIZE_16BIT = 0,\r\n    VMX_ADDRESS_SIZE_32BIT = 1,\r\n    VMX_ADDRESS_SIZE_64BIT = 2\r\n} VMX_ADDRESS_SIZE, *PVMX_ADDRESS_SIZE;\r\n\r\ntypedef enum _VMX_OPERAND_SIZE\r\n{\r\n    VMX_OPERAND_SIZE_16BIT = 0,\r\n    VMX_OPERAND_SIZE_32BIT = 1\r\n} VMX_OPERAND_SIZE, *PVMX_OPERAND_SIZE;\r\n\r\ntypedef enum _VMX_SEGMENT_REGISTER_INDEX\r\n{\r\n    VMX_ES_SELECTOR_INDEX = 0,\r\n    VMX_CS_SELECTOR_INDEX = 1,\r\n    VMX_SS_SELECTOR_INDEX = 2,\r\n    VMX_DS_SELECTOR_INDEX = 3,\r\n    VMX_FS_SELECTOR_INDEX = 4,\r\n    VMX_GS_SELECTOR_INDEX = 5\r\n} VMX_SEGMENT_REGISTER_INDEX, *PVMX_SEGMENT_REGISTER_INDEX;\r\n\r\ntypedef enum _VMX_GP_REGISTER_INDEX\r\n{\r\n    VMX_RAX_INDEX = 0,\r\n    VMX_RCX_INDEX = 1,\r\n    VMX_RDX_INDEX = 2,\r\n    VMX_RBX_INDEX = 3,\r\n    VMX_RSP_INDEX = 4,\r\n    VMX_RBP_INDEX = 5,\r\n    VMX_RSI_INDEX = 6,\r\n    VMX_RDI_INDEX = 7,\r\n    VMX_R8_INDEX = 8,\r\n    VMX_R9_INDEX = 9,\r\n    VMX_R10_INDEX = 10,\r\n    VMX_R11_INDEX = 11,\r\n    VMX_R12_INDEX = 12,\r\n    VMX_R13_INDEX = 13,\r\n    VMX_R14_INDEX = 14,\r\n    VMX_R15_INDEX = 15,\r\n} VMX_GP_REGISTER_INDEX, *PVMX_GP_REGISTER_INDEX;\r\n\r\ntypedef enum _VMX_SCALING\r\n{\r\n    VMX_NO_SCALING = 0,\r\n    VMX_SCALE_BY_2 = 1,\r\n    VMX_SCALE_BY_4 = 2,\r\n    VMX_SCALE_BY_8 = 3\r\n} VMX_SCALING, *PVMX_SCALING;\r\n\r\n//! Vol 3C, 23.5 EVENT INJECTION\r\ntypedef enum _VMX_INTERRUPTION_TYPE\r\n{\r\n    VMX_INT_TYPE_EXTERNAL = 0,\r\n    VMX_INT_TYPE_NMI = 2,\r\n    VMX_INT_TYPE_HW_EXCEPTION = 3,\r\n    VMX_INT_TYPE_SW_INTERRUPT = 4,\r\n    VMX_INT_TYPE_PRIVILEGED_SW = 5,\r\n    VMX_INT_TYPE_SW_EXCEPTION = 6,\r\n    VMX_INT_TYPE_OTHER = 7,\r\n} VMX_INTERRUPTION_TYPE, *PVMX_INTERRUPTION_TYPE;\r\n\r\n//! Vol 3C, Table 24-13. Format of the VM-Entry Interruption-Information Field\r\n// (VMCS_FIELD_VM_ENTRY_INTR_INFO)\r\ntypedef union _VMX_VM_ENTRY_INTR_INFO\r\n{\r\n    UINT32 dwValue;\r\n    struct {\r\n        UINT32 Vector : 8;              //!< 0-7    Vector of interrupt or exception\r\n        UINT32 InterruptionType : 3;    //!< 8-10    See VMX_INTERRUPTION_TYPE\r\n        UINT32 ErrorCodeValid : 1;      //!< 11        0=invalid, 1=valid\r\n        UINT32 Reserved0 : 18;          //!< 12-30    0\r\n        UINT32 Valid : 1;               //!< 31        Is structure valid\r\n    };\r\n} VMX_VM_ENTRY_INTR_INFO, *PVMX_VM_ENTRY_INTR_INFO;\r\nC_ASSERT(sizeof(UINT32) == sizeof(VMX_VM_ENTRY_INTR_INFO));\r\n\r\n//! Vol 3C, Table 24-14. Format of Exit Reason (VMCS_FIELD_VM_EXIT_REASON)\r\ntypedef union _VMX_VMEXIT_REASON\r\n{\r\n    UINT32 dwValue;\r\n    struct {\r\n        UINT32 ExitReason : 16;         //!< 0-15    Exit reason, see VMEXIT_REASON\r\n        UINT32 Reserved0 : 12;          //!< 16-27    0\r\n        UINT32 PendingMtf : 1;          //!< 28        Pending MTF VM-Exit\r\n        UINT32 ExitFromRoot : 1;        //!< 29        VM-Exit from root operation\r\n        UINT32 Reserved1 : 1;           //!< 30        0\r\n        UINT32 EntryFailed : 1;         //!< 31        VM-Entry failed\r\n    };\r\n} VMX_VMEXIT_REASON, *PVMX_VMEXIT_REASON;\r\nC_ASSERT(sizeof(UINT32) == sizeof(VMX_VMEXIT_REASON));\r\n\r\n//! Vol 3C, Table 24-15. Format of the VM-Exit Interruption-Information Field\r\n// (VMCS_FIELD_VM_EXIT_INTR_INFO)\r\ntypedef union _VMX_VM_EXIT_INTR_INFO\r\n{\r\n    UINT32 dwValue;\r\n    struct {\r\n        UINT32 Vector : 8;              //!< 0-7    Vector of interrupt or exception\r\n        UINT32 InterruptionType : 3;    //!< 8-10    See VMX_INTERRUPTION_TYPE\r\n        UINT32 ErrorCodeValid : 1;      //!< 11        0=invalid, 1=valid\r\n        UINT32 NmiUnblocking : 1;       //!< 12        NMI unblocking due to IRET\r\n        UINT32 Reserved0 : 18;          //!< 13-30    0\r\n        UINT32 Valid : 1;               //!< 31        Is structure valid\r\n    };\r\n} VMX_VM_EXIT_INTR_INFO, *PVMX_VM_EXIT_INTR_INFO;\r\nC_ASSERT(sizeof(UINT32) == sizeof(VMX_VM_EXIT_INTR_INFO));\r\n\r\n//! Vol 3C, Table 24-16. Format of the IDT-Vectoring Information Field (VMCS_FIELD_IDT_VECTORING_INFO)\r\ntypedef union _VMX_IDT_VECTORING_INFO\r\n{\r\n    UINT32 dwValue;\r\n    struct {\r\n        UINT32 Vector : 8;              //!< 0-7    Vector of interrupt or exception\r\n        UINT32 InterruptionType : 3;    //!< 8-10    See VMX_INTERRUPTION_TYPE\r\n        UINT32 ErrorCodeValid : 1;      //!< 11        0=invalid, 1=valid\r\n        UINT32 Undefined0 : 1;          //!< 12\r\n        UINT32 Reserved0 : 18;          //!< 13-30    0\r\n        UINT32 Valid : 1;               //!< 31        Is structure valid\r\n    };\r\n} VMX_IDT_VECTORING_INFO, *PVMX_IDT_VECTORING_INFO;\r\nC_ASSERT(sizeof(UINT32) == sizeof(VMX_IDT_VECTORING_INFO));\r\n\r\n//! Vol 3C, Table 27-1. Exit Qualification for Debug Exceptions (VMCS_FIELD_EXIT_QUALIFICATION)\r\ntypedef union _VMX_DEBUG_EXCEPTION_EXIT_QUALIFICATION\r\n{\r\n    UINT64 qwValue;\r\n    struct {\r\n        UINT64 Breakpoint : 4;  //!< 0-3    B0-B3. Indicates which breakpoint condition was met\r\n        UINT64 Reserved0 : 9;   //!< 4-12\r\n        UINT64 Bd : 1;          //!< 13        Debug exception due to debug register access\r\n        UINT64 Bs : 1;          //!< 14        Debug exception due to opcode/branch\r\n        UINT64 Reserved1 : 49;  //!< 15-63\r\n    };\r\n} VMX_DEBUG_EXCEPTION_EXIT_QUALIFICATION, *PVMX_DEBUG_EXCEPTION_EXIT_QUALIFICATION;\r\nC_ASSERT(sizeof(UINT64) == sizeof(VMX_DEBUG_EXCEPTION_EXIT_QUALIFICATION));\r\n\r\ntypedef enum _VMX_TASK_SWITCH_CAUSE\r\n{\r\n    VMX_TASK_SWITCH_CAUSE_CALL = 0,\r\n    VMX_TASK_SWITCH_CAUSE_IRET = 1,\r\n    VMX_TASK_SWITCH_CAUSE_JMP = 2,\r\n    VMX_TASK_SWITCH_CAUSE_TASK_GATE = 3\r\n} VMX_TASK_SWITCH_CAUSE, *PVMX_TASK_SWITCH_CAUSE;\r\n\r\n//! Vol 3C, Table 27-2. Exit Qualification for Task Switch (VMCS_FIELD_EXIT_QUALIFICATION)\r\ntypedef union _VMX_TASK_SWITCH_EXIT_QUALIFICATION\r\n{\r\n    UINT64 qwValue;\r\n    struct {\r\n        UINT64 TssSelector : 16;    //!< 0-15    TSS to which the guest attempted to switch\r\n        UINT64 Reserved0 : 14;      //!< 16-29\r\n        UINT64 TaskSwitchCause : 2; //!< 30-31    See VMX_TASK_SWITCH_CAUSE\r\n        UINT64 Reserved1 : 32;      //!< 32-63\r\n    };\r\n} VMX_TASK_SWITCH_EXIT_QUALIFICATION, *PVMX_TASK_SWITCH_EXIT_QUALIFICATION;\r\nC_ASSERT(sizeof(UINT64) == sizeof(VMX_TASK_SWITCH_EXIT_QUALIFICATION));\r\n\r\n//! Vol 3C, Table 27-3. Exit Qualification for Control-Register Accesses\r\ntypedef enum _VMX_MOV_CR_ACCESS_TYPE\r\n{\r\n    VMX_MOV_CR_ACCESS_TYPE_TO_CR = 0,\r\n    VMX_MOV_CR_ACCESS_TYPE_FROM_CR,\r\n    VMX_MOV_CR_ACCESS_TYPE_CLTS,\r\n    VMX_MOV_CR_ACCESS_TYPE_LMSW,\r\n} VMX_MOV_CR_ACCESS_TYPE, *PVMX_MOV_CR_ACCESS_TYPE;\r\n\r\n//! Vol 3C, Table 27-3. Exit Qualification for Control-Register Accesses (VMCS_FIELD_EXIT_QUALIFICATION)\r\ntypedef union _VMX_MOV_CR_EXIT_QUALIFICATION\r\n{\r\n    UINT64 qwValue;\r\n    struct {\r\n        UINT64 ControlRegister : 4; //!< 0-3    Number of control register (0 for CLTS and LMSW)\r\n        UINT64 AccessType : 2;      //!< 4-5    See VMX_MOV_CR_ACCESS_TYPE\r\n        UINT64 LmswOperandType : 1; //!< 6        MSW operand type: 0=register, 1=memory\r\n        UINT64 Reserved0 : 1;       //!< 7\r\n        UINT64 GpRegister : 4;      //!< 8-11    See VMX_GP_REGISTER_INDEX\r\n        UINT64 Reserved1 : 4;       //!< 12-15\r\n        UINT64 LmswSourceData : 16; //!< 16-31    LMSW source data, or 0 for CTLS and MOV CRx\r\n        UINT64 Reserved2 : 32;      //!< 32-63\r\n    };\r\n} VMX_MOV_CR_EXIT_QUALIFICATION, *PVMX_MOV_CR_EXIT_QUALIFICATION;\r\nC_ASSERT(sizeof(UINT64) == sizeof(VMX_MOV_CR_EXIT_QUALIFICATION));\r\n\r\n//! Vol 3C, 27-4. Exit Qualification for MOV DR (VMCS_FIELD_EXIT_QUALIFICATION)\r\ntypedef union _VMX_MOV_DR_EXIT_QUALIFICATION\r\n{\r\n    UINT64 qwValue;\r\n    struct {\r\n        UINT64 DebugRegister : 3;    //!< 0-2    Number of debug register\r\n        UINT64 Reserved0 : 1;        //!< 3\r\n        UINT64 Direction : 1;        //!< 4        0=MOV to DR, 1=MOV from DR\r\n        UINT64 Reserved1 : 3;        //!< 5-7\r\n        UINT64 GpRegister : 4;       //!< 8-11    See VMX_GP_REGISTER_INDEX\r\n        UINT64 Reserved2 : 52;       //!< 12-63\r\n    };\r\n} VMX_MOV_DR_EXIT_QUALIFICATION, *PVMX_MOV_DR_EXIT_QUALIFICATION;\r\nC_ASSERT(sizeof(UINT64) == sizeof(VMX_MOV_DR_EXIT_QUALIFICATION));\r\n\r\ntypedef enum _VMX_IO_ACCESS_SIZE\r\n{\r\n    VMX_IO_ACCESS_SIZE_1 = 0,\r\n    VMX_IO_ACCESS_SIZE_2 = 1,\r\n    VMX_IO_ACCESS_SIZE_4 = 3\r\n} VMX_IO_ACCESS_SIZE, *PVMX_IO_ACCESS_SIZE;\r\n\r\n//! Vol 3C, Table 27-5. Exit Qualification for I/O Instructions (VMCS_FIELD_EXIT_QUALIFICATION)\r\ntypedef union _VMX_IO_OPCODE_EXIT_QUALIFICATION\r\n{\r\n    UINT64 qwValue;\r\n    struct {\r\n        UINT64 AccessSize : 3;      //!< 0-2    See VMX_IO_ACCESS_SIZE\r\n        UINT64 Direction : 1;       //!< 3        0=OUT, 1=IN\r\n        UINT64 IsString : 1;        //!< 4        0=Not a string, 1=String\r\n        UINT64 RepPrefixed : 1;     //!< 5        0=not REP, 1=REP        \r\n        UINT64 Reserved0 : 9;       //!< 7-15\r\n        UINT64 PortNumber : 8;      //!< 16-31    Port number (DX)\r\n        UINT64 Reserved1 : 32;      //!< 32-63\r\n    };\r\n} VMX_IO_OPCODE_EXIT_QUALIFICATION, *PVMX_IO_OPCODE_EXIT_QUALIFICATION;\r\nC_ASSERT(sizeof(UINT64) == sizeof(VMX_IO_OPCODE_EXIT_QUALIFICATION));\r\n\r\ntypedef enum _VMX_APIC_ACCESS_TYPE\r\n{\r\n    VMX_APIC_ACCESS_TYPE_LINEAR_READ = 0,            //!< linear access for a data read during instruction execution\r\n    VMX_APIC_ACCESS_TYPE_LINEAR_WRITE = 1,           //!< linear access for a data write during instruction execution\r\n    VMX_APIC_ACCESS_TYPE_LINEAR_FETCH = 2,           //!< linear access for an instruction fetch\r\n    VMX_APIC_ACCESS_TYPE_LINEAR_RW_EVENT = 3,        //!< linear access (read or write) during event delivery\r\n    VMX_APIC_ACCESS_TYPE_GUEST_PHYSICAL = 10,        //!< guest-physical access during event delivery\r\n    VMX_APIC_ACCESS_TYPE_GUEST_PHYSICAL_FETCH = 15,  //!< guest-physical access for an instruction fetch or during instruction execution\r\n} VMX_APIC_ACCESS_TYPE, *PVMX_APIC_ACCESS_TYPE;\r\n\r\n//!    Vol 3C, Table 27-6. Exit Qualification for APIC-Access VM Exits from Linear Accesses \r\n//    and Guest - Physical Accesses (VMCS_FIELD_EXIT_QUALIFICATION)\r\ntypedef union _VMX_APIC_ACCESS_EXIT_QUALIFICATION\r\n{\r\n    UINT64 qwValue;\r\n    struct {\r\n        UINT64 Offset : 12;       //!< 0-11    Offset within APIC page\r\n        UINT64 AccessType : 4;    //!< 12-15    See VMX_APIC_ACCESS_TYPE\r\n        UINT64 Reserved0 : 48;    //!< 16-63\r\n    };\r\n} VMX_APIC_ACCESS_EXIT_QUALIFICATION, *PVMX_APIC_ACCESS_EXIT_QUALIFICATION;\r\nC_ASSERT(sizeof(UINT64) == sizeof(VMX_APIC_ACCESS_EXIT_QUALIFICATION));\r\n\r\n//! Vol 3C, Table 27-7. Exit Qualification for EPT Violations (VMCS_FIELD_EXIT_QUALIFICATION)\r\ntypedef union _VMX_EPT_EXIT_QUALIFICATION\r\n{\r\n    UINT64 qwValue;\r\n    struct {\r\n        UINT64 ReadAccess : 1;          //!< 0        EPT violation was a data read\r\n        UINT64 WriteAccess : 1;         //!< 1        EPT violation was a data write\r\n        UINT64 ExecuteAccess : 1;       //!< 2        EPT violation was an instruction fetch\r\n        UINT64 GuestAllowRead : 1;      //!< 3        Guest page table allows read\r\n        UINT64 GuestAllowWrite : 1;     //!< 4        Guest page table allows write\r\n        UINT64 GuestAllowExecute : 1;   //!< 5        Guest page table allows execute\r\n        UINT64 Reserved0 : 1;           //!< 6\r\n        UINT64 AddressValid : 1;        //!< 7        Valid for all EPT-violations, except those resulting from \r\n                                        //            an attempt to load the guest PDPTEs as part of the execution of\r\n                                        //            the MOV CR instruction\r\n        UINT64 IsMemoryAccess : 1;      //!< 8        0=Change to PTE access/dirty bit, 1=access to memory\r\n        UINT64 Reserved1 : 3;           //!< 9-11\r\n        UINT64 NmiUnblocking : 1;       //!< 12        NMI unblocking due to IRET\r\n        UINT64 Reserved2 : 51;          //!< 13-63\r\n    };\r\n} VMX_EPT_EXIT_QUALIFICATION, *PVMX_EPT_EXIT_QUALIFICATION;\r\nC_ASSERT(sizeof(UINT64) == sizeof(VMX_EPT_EXIT_QUALIFICATION));\r\n\r\n//! Vol 3C, Table 27-8. Format of the VM-Exit Instruction-Information Field \r\n// as Used for INS and OUTS (VMCS_FIELD_INSTRUCTION_INFO)\r\ntypedef union _VMX_IO_INSTRUCTION_INFO\r\n{\r\n    UINT32 dwValue;\r\n    struct {\r\n        UINT32 Undefined0 : 7;          //!< 0-6    \r\n        UINT32 AddressSize : 3;         //!< 7-9    See VMX_ADDRESS_SIZE\r\n        UINT32 Undefined1 : 5;          //!< 10-14\r\n        UINT32 SegmentRegister : 3;     //!< 15-17    See VMX_SEGMENT_REGISTER_INDEX\r\n        UINT32 Undefined2 : 14;         //!< 18-31\r\n    };\r\n} VMX_IO_INSTRUCTION_INFO, *PVMX_IO_INSTRUCTION_INFO;\r\nC_ASSERT(sizeof(UINT32) == sizeof(VMX_IO_INSTRUCTION_INFO));\r\n\r\ntypedef enum _VMX_IDT_OR_GDT_INSTRUCTION_ID\r\n{\r\n    VMX_SGDT_ID = 0,\r\n    VMX_SIDT_ID = 1,\r\n    VMX_LGDT_ID = 2,\r\n    VMX_LIDT_ID = 3\r\n} VMX_IDT_OR_GDT_INSTRUCTION_ID, *PVMX_IDT_OR_GDT_INSTRUCTION_ID;\r\n\r\n//! Vol 3C, Table 27-9. Format of the VM-Exit Instruction-Information Field as Used for\r\n// INVEPT, INVPCID, and INVVPID (VMCS_FIELD_INSTRUCTION_INFO)\r\ntypedef union _VMX_INVEPT_OR_INVVPID_INSTRUCTION_INFO\r\n{\r\n    UINT32 dwValue;\r\n    struct {\r\n        UINT32 Scalling : 2;                //!<  0-1    See VMX_SCALING\r\n        UINT32 Undefined0 : 5;              //!<  2-6\r\n        UINT32 AddressSize : 3;             //!<  7-9    See VMX_ADDRESS_SIZE\r\n        UINT32 Zero0 : 1;                   //!<  10    0\r\n        UINT32 Undefined1 : 4;              //!<  11-14\r\n        UINT32 SegmentRegister : 3;         //!<  15-17 See VMX_SEGMENT_REGISTER_INDEX\r\n        UINT32 IndexRegister : 4;           //!<  18-21 See VMX_GP_REGISTER_INDEX\r\n        UINT32 IndexRegisterInvalid : 1;    //!<  22    0=valid, 1=invalid\r\n        UINT32 BaseRegister : 4;            //!<  23-26 BaseReg (encoded as IndexRegister above)\r\n        UINT32 BaseRegisterInvalid : 1;     //!<  27    0=valid, 1=invalid\r\n        UINT32 GpRegister2 : 4;             //!<  28-31 See VMX_GP_REGISTER_INDEX\r\n    };\r\n} VMX_INVEPT_OR_INVVPID_INSTRUCTION_INFO, *PVMX_INVEPT_OR_INVVPID_INSTRUCTION_INFO;\r\nC_ASSERT(sizeof(UINT32) == sizeof(VMX_INVEPT_OR_INVVPID_INSTRUCTION_INFO));\r\n\r\n//! Vol 3C, Table 27-10. Format of the VM-Exit Instruction-Information Field as Used for \r\n//    LIDT, LGDT, SIDT, or SGDT (VMCS_FIELD_INSTRUCTION_INFO)\r\ntypedef union _VMX_IDT_OR_GDT_ACCESS_INSTRUCTION_INFO\r\n{\r\n    UINT32 dwValue;\r\n    struct {\r\n        UINT32 Scalling : 2;                //!<  0-1    See VMX_SCALING\r\n        UINT32 Reserved1 : 5;               //!<  2-6\r\n        UINT32 AddressSize : 3;             //!<  7-9    See VMX_ADDRESS_SIZE\r\n        UINT32 Reserved2 : 1;               //!<  10\r\n        UINT32 OperandSize : 1;             //!<  11    See VMX_OPERAND_SIZE\r\n        UINT32 Reserved3 : 3;               //!<  12-14\r\n        UINT32 SegmentRegister : 3;         //!<  15-17 See VMX_SEGMENT_REGISTER_INDEX\r\n        UINT32 IndexRegister : 4;           //!<  18-21 See VMX_GP_REGISTER_INDEX\r\n        UINT32 IndexRegisterInvalid : 1;    //!<  22    0=valid, 1=invalid\r\n        UINT32 BaseRegister : 4;            //!<  23-26 BaseReg (encoded as IndexRegister above)\r\n        UINT32 BaseRegisterInvalid : 1;     //!<  27    0=valid, 1=invalid\r\n        UINT32 InstructionIdentity : 2;     //!<  28-29 See VMX_IDT_OR_GDT_INSTRUCTION_ID\r\n        UINT32 Reserved4 : 2;               //!<  30-31\r\n    };\r\n} VMX_IDT_OR_GDT_ACCESS_INSTRUCTION_INFO, *PVMX_IDT_OR_GDT_ACCESS_INSTRUCTION_INFO;\r\nC_ASSERT(sizeof(UINT32) == sizeof(VMX_IDT_OR_GDT_ACCESS_INSTRUCTION_INFO));\r\n\r\ntypedef enum _VMX_LDT_OR_TR_INSTRUCTION_ID\r\n{\r\n    VMX_SLDT_ID = 0,\r\n    VMX_STR_ID = 1,\r\n    VMX_LLDT_ID = 2,\r\n    VMX_LTR_ID = 3\r\n} VMX_LDT_OR_TR_INSTRUCTION_ID, *PVMX_LDT_OR_TR_INSTRUCTION_ID;\r\n\r\n//! Vol 3C, Table 27-11. Format of the VM-Exit Instruction-Information Field \r\n// as Used for LLDT, LTR, SLDT, and STR (VMCS_FIELD_INSTRUCTION_INFO)\r\ntypedef union _VMX_LDT_OR_TR_ACCESS_INSTRUCTION_INFO\r\n{\r\n    UINT32 dwValue;\r\n    struct {\r\n        UINT32 Scalling : 2;                //!<  0-1    See VMX_SCALING\r\n        UINT32 Undefined0 : 1;              //!<  2\r\n        UINT32 GpRegister : 4;              //!<  3-6    See VMX_GP_REGISTER_INDEX\r\n        UINT32 AddressSize : 3;             //!<  7-9    See VMX_ADDRESS_SIZE\r\n        UINT32 IsRegister : 1;              //!<  10    0=memory, 1=register\r\n        UINT32 Undefined1 : 4;              //!<  11-14\r\n        UINT32 SegmentRegister : 3;         //!<  15-17 See VMX_SEGMENT_REGISTER_INDEX\r\n        UINT32 IndexRegister : 4;           //!<  18-21 See VMX_GP_REGISTER_INDEX\r\n        UINT32 IndexRegisterInvalid : 1;    //!<  22    0=valid, 1=invalid\r\n        UINT32 BaseRegister : 4;            //!<  23-26 BaseReg (encoded as IndexRegister above)\r\n        UINT32 BaseRegisterInvalid : 1;     //!<  27    0=valid, 1=invalid\r\n        UINT32 InstructionIdentity : 2;     //!<  28-29 See VMX_LDT_OR_TR_INSTRUCTION_ID\r\n        UINT32 Undefined2 : 2;              //!<  30-31\r\n    };\r\n} VMX_LDT_OR_TR_ACCESS_INSTRUCTION_INFO, *PVMX_LDT_OR_TR_ACCESS_INSTRUCTION_INFO;\r\nC_ASSERT(sizeof(UINT32) == sizeof(VMX_LDT_OR_TR_ACCESS_INSTRUCTION_INFO));\r\n\r\n// TODO: Vol 3C, Table 27-12. Format of the VM-Exit Instruction-Information Field as Used for RDRAND and RDSEED\r\n\r\n//! Vol 3C, Table 27-13. Format of the VM-Exit Instruction-Information Field as Used for\r\n// VMCLEAR, VMPTRLD, VMPTRST, VMXON, XRSTORS, and XSAVES (VMCS_FIELD_INSTRUCTION_INFO)\r\ntypedef union _VMX_VMCS_PTR_OPCODES_INSTRUCTION_INFO\r\n{\r\n    UINT32 dwValue;\r\n    struct {\r\n        UINT32 Scalling : 2;                //!<  0-1    See VMX_SCALING\r\n        UINT32 Undefined0 : 5;              //!<  2-6\r\n        UINT32 AddressSize : 3;             //!<  7-9    See VMX_ADDRESS_SIZE\r\n        UINT32 Zero0 : 1;                   //!<  10    0\r\n        UINT32 Undefined1 : 4;              //!<  11-14\r\n        UINT32 SegmentRegister : 3;         //!<  15-17 See VMX_SEGMENT_REGISTER_INDEX\r\n        UINT32 IndexRegister : 4;           //!<  18-21 See VMX_GP_REGISTER_INDEX\r\n        UINT32 IndexRegisterInvalid : 1;    //!<  22    0=valid, 1=invalid\r\n        UINT32 BaseRegister : 4;            //!<  23-26 BaseReg (encoded as IndexRegister above)\r\n        UINT32 BaseRegisterInvalid : 1;     //!<  27    0=valid, 1=invalid\r\n        UINT32 Undefined2 : 4;              //!<  28-31\r\n    };\r\n} VMX_VMCS_OPCODES_INSTRUCTION_INFO, *PVMX_VMCS_OPCODES_INSTRUCTION_INFO;\r\nC_ASSERT(sizeof(UINT32) == sizeof(VMX_VMCS_OPCODES_INSTRUCTION_INFO));\r\n\r\n//! Vol 3C, Table 27-14. Format of the VM-Exit Instruction-Information Field\r\n// as Used for VMREAD and VMWRITE (VMCS_FIELD_INSTRUCTION_INFO)\r\ntypedef union _VMX_VMCS_RW_OPCODES_INSTRUCTION_INFO\r\n{\r\n    UINT32 dwValue;\r\n    struct {\r\n        UINT32 Scalling : 2;                //!<  0-1    See VMX_SCALING\r\n        UINT32 Undefined0 : 1;              //!<  2\r\n        UINT32 GpRegister1 : 4;             //!<  3-6    See VMX_GP_REGISTER_INDEX\r\n        UINT32 AddressSize : 3;             //!<  7-9    See VMX_ADDRESS_SIZE\r\n        UINT32 IsRegister : 1;              //!<  10    0=memory, 1=register\r\n        UINT32 Undefined1 : 4;              //!<  11-14\r\n        UINT32 SegmentRegister : 3;         //!<  15-17 See VMX_SEGMENT_REGISTER_INDEX\r\n        UINT32 IndexRegister : 4;           //!<  18-21 See VMX_GP_REGISTER_INDEX\r\n        UINT32 IndexRegisterInvalid : 1;    //!<  22    0=valid, 1=invalid\r\n        UINT32 BaseRegister : 4;            //!<  23-26 BaseReg (encoded as IndexRegister above)\r\n        UINT32 BaseRegisterInvalid : 1;     //!<  27    0=valid, 1=invalid\r\n        UINT32 GpRegister2 : 4;             //!<  28-31 See VMX_GP_REGISTER_INDEX\r\n    };\r\n} VMX_VMCS_RW_OPCODES_INSTRUCTION_INFO, *PVMX_VMCS_RW_OPCODES_INSTRUCTION_INFO;\r\nC_ASSERT(sizeof(UINT32) == sizeof(VMX_VMCS_RW_OPCODES_INSTRUCTION_INFO));\r\n\r\n#define VMX_EPT_PML4E_ENTRY_COUNT   512\r\n#define VMX_EPT_PDPTE_ENTRY_COUNT   512\r\n#define VMX_EPT_PDE_ENTRY_COUNT     512\r\n#define VMX_EPT_PTE_ENTRY_COUNT     512\r\n\r\ntypedef enum _VMX_EPT_MEMORY_TYPE\r\n{\r\n    VMX_EPT_MEMORY_TYPE_UC = 0,     // Uncachable\r\n    VMX_EPT_MEMORY_TYPE_WC = 1,     // Write-combined\r\n    VMX_EPT_MEMORY_TYPE_WT = 4,     // Write-through\r\n    VMX_EPT_MEMORY_TYPE_WP = 5,     // Write-Protected\r\n    VMX_EPT_MEMORY_TYPE_WB = 6      // Write-back\r\n} VMX_EPT_MEMORY_TYPE, *PVMX_EPT_MEMORY_TYPE;\r\n\r\n//! Vol 3C, Table 28-1. Format of an EPT PML4 Entry (PML4E) that References\r\n// an EPT Page-Directory-Pointer Table\r\ntypedef union _VMX_EPT_PML4E\r\n{\r\n    UINT64 qwValue;\r\n    struct {\r\n        UINT64 Read : 1;        //!< 0      Allow read\r\n        UINT64 Write : 1;       //!< 1      Allow write\r\n        UINT64 Execute : 1;     //!< 2      Allow execute\r\n        UINT64 Reserved0 : 5;   //!< 3-7    0\r\n        UINT64 Ignored0 : 4;    //!< 8-11\r\n        UINT64 Address : 40;    //!< 12-51  Address of VMX_EPT_PDPTE\r\n        UINT64 Ignored1 : 12;   //!< 52-63\r\n    };\r\n} VMX_EPT_PML4E, *PVMX_EPT_PML4E;\r\nC_ASSERT(sizeof(UINT64) == sizeof(VMX_EPT_PML4E));\r\n\r\n//! Vol 3C, Table 28-2. Format of an EPT Page-Directory-Pointer-Table Entry (PDPTE)\r\n// that Maps a 1 - GByte Page\r\ntypedef union _VMX_EPT_PDPTE1GB\r\n{\r\n    UINT64 qwValue;\r\n    struct {\r\n        UINT64 Read : 1;        //!< 0        Allow read\r\n        UINT64 Write : 1;       //!< 1        Allow write\r\n        UINT64 Execute : 1;     //!< 2        Allow execute\r\n        UINT64 MemoryType : 3;  //!< 3-5    See VMX_EPT_MEMORY_TYPE\r\n        UINT64 IgnorePat : 1;   //!< 6        Ignore PAT memory type\r\n        UINT64 Large : 1;       //!< 7        Must be 1 for 1GB pages\r\n        UINT64 Ignored0 : 4;    //!< 8-11\r\n        UINT64 Reserved0 : 18;  //!< 12-29    0\r\n        UINT64 Address : 22;    //!< 30-51    Address of 1GB page\r\n        UINT64 Ignored1 : 12;   //!< 52-63\r\n    };\r\n} VMX_EPT_PDPTE1GB, *PVMX_EPT_PDPTE1GB;\r\nC_ASSERT(sizeof(UINT64) == sizeof(VMX_EPT_PDPTE1GB));\r\n\r\n//! Vol 3C, Table 28-3. Format of an EPT Page-Directory-Pointer-Table Entry (PDPTE)\r\n// that References an EPT Page Directory\r\ntypedef union _VMX_EPT_PDPTE\r\n{\r\n    UINT64 qwValue;\r\n    struct     {\r\n        UINT64 Read : 1;        //!< 0      Allow read\r\n        UINT64 Write : 1;       //!< 1      Allow write\r\n        UINT64 Execute : 1;     //!< 2      Allow execute\r\n        UINT64 Reserved0 : 5;   //!< 3-7    0\r\n        UINT64 Ignored0 : 4;    //!< 8-11\r\n        UINT64 Address : 40;    //!< 12-51  Address of VMX_EPT_PDE\r\n        UINT64 Ignored2 : 12;   //!< 52-63\r\n    };\r\n} VMX_EPT_PDPTE, *PVMX_EPT_PDPTE;\r\nC_ASSERT(sizeof(UINT64) == sizeof(VMX_EPT_PDPTE));\r\n\r\n//! Vol 3C, Table 28-4. Format of an EPT Page-Directory Entry (PDE)\r\n// that Maps a 2-MByte Page\r\ntypedef union _VMX_EPT_PDE2MB\r\n{\r\n    UINT64 qwValue;\r\n    struct {\r\n        UINT64 Read : 1;        //!< 0      Allow read\r\n        UINT64 Write : 1;       //!< 1      Allow write\r\n        UINT64 Execute : 1;     //!< 2      Allow execute\r\n        UINT64 MemoryType : 3;  //!< 3-5    See VMX_EPT_MEMORY_TYPE\r\n        UINT64 IgnorePat : 1;   //!< 6      Ignore PAT memory type\r\n        UINT64 Large : 1;       //!< 7      Must be 1 for 2MB pages\r\n        UINT64 Ignored0 : 1;    //!< 8-11\r\n        UINT64 Reserved0 : 9;   //!< 12-20  0\r\n        UINT64 Address : 31;    //!< 21-51  Address of 2MB page\r\n        UINT64 Ignored1 : 12;   //!< 52-63\r\n    };\r\n} VMX_EPT_PDE2MB, *PVMX_EPT_PDE2MB;\r\nC_ASSERT(sizeof(UINT64) == sizeof(VMX_EPT_PDE2MB));\r\n\r\n//! Vol 3C, Table 28-5. Format of an EPT Page-Directory Entry (PDE)\r\n// that References an EPT Page Table\r\ntypedef union _VMX_EPT_PDE\r\n{\r\n    UINT64 qwValue;\r\n    struct {\r\n        UINT64 Read : 1;        //!< 0      Allow read\r\n        UINT64 Write : 1;       //!< 1      Allow write\r\n        UINT64 Execute : 1;     //!< 2      Allow execute\r\n        UINT64 Reserved0 : 5;   //!< 3-7    0\r\n        UINT64 Ignored0 : 4;    //!< 8-11\r\n        UINT64 Address : 40;    //!< 12-51  Address of PTE\r\n        UINT64 Ignored1 : 12;   //!< 52-63\r\n    };\r\n} VMX_EPT_PDE, *PVMX_EPT_PDE;\r\nC_ASSERT(sizeof(UINT64) == sizeof(VMX_EPT_PDE));\r\n\r\n//! Vol 3C, Table 28-6. Format of an EPT Page-Table Entry\r\ntypedef union _VMX_EPT_PTE\r\n{\r\n    UINT64 qwValue;\r\n    struct {\r\n        UINT64 Read : 1;        //!< 0      Allow read\r\n        UINT64 Write : 1;       //!< 1      Allow write\r\n        UINT64 Execute : 1;     //!< 2      Allow execute\r\n        UINT64 MemoryType : 3;  //!< 3-5    See VMX_EPT_MEMORY_TYPE\r\n        UINT64 IgnorePat : 1;   //!< 6      Ignore PAT memory type\r\n        UINT64 Ignored0 : 5;    //!< 7-11\r\n        UINT64 Address : 40;    //!< 12-51  Address of page\r\n        UINT64 Ignored1 : 12;   //!< 52-63\r\n    };\r\n} VMX_EPT_PTE, *PVMX_EPT_PTE;\r\n\r\n// An example of a VMX EPT table\r\ntypedef struct _VMX_EPT_TABLE\r\n{\r\n    DECLSPEC_ALIGN(PAGE_SIZE) VMX_EPT_PML4E atPml4[VMX_EPT_PML4E_ENTRY_COUNT];\r\n    DECLSPEC_ALIGN(PAGE_SIZE) VMX_EPT_PDPTE atPdpte[VMX_EPT_PDPTE_ENTRY_COUNT];\r\n    DECLSPEC_ALIGN(PAGE_SIZE) VMX_EPT_PDE2MB atPde[VMX_EPT_PDE_ENTRY_COUNT][VMX_EPT_PTE_ENTRY_COUNT];\r\n} VMX_EPT_TABLE, *PVMX_EPT_TABLE;\r\n\r\n//! Vol 3C, Table 34-9. Exit Qualification for SMIs That Arrive Immediately\r\n// After the Retirement of an I/O Instruction (VMCS_FIELD_EXIT_QUALIFICATION)\r\ntypedef union _VMX_SMI_AFTER_IO_EXIT_QUALIFICATION\r\n{\r\n    UINT64 qwValue;\r\n    struct {\r\n        UINT64 AccessSize : 3;  //!< 0-2    See VMX_IO_ACCESS_SIZE\r\n        UINT64 Direction : 1;   //!< 3      0=OUT, 1=IN\r\n        UINT64 IsString : 1;    //!< 4      0=Not string, 1=String\r\n        UINT64 RepPrefixed : 1; //!< 5      0=Not REP, 1=REP\r\n        UINT64 Operand : 1;     //!< 6      0=DX, 1=Immediate\r\n        UINT64 Reserved0 : 8;   //!< 7-15   0\r\n        UINT64 PortNumber : 16; //!< 16-31  IO Port number\r\n        UINT64 Reserved1 : 32;  //!< 32-63  0\r\n    };\r\n} VMX_SMI_AFTER_IO_EXIT_QUALIFICATION, *PVMX_SMI_AFTER_IO_EXIT_QUALIFICATION;\r\nC_ASSERT(sizeof(UINT64) == sizeof(VMX_SMI_AFTER_IO_EXIT_QUALIFICATION));\r\n\r\n//! Vol 3C, 34.15.5 Enabling the Dual-Monitor Treatment\r\ntypedef union _VMX_SMM_MONITOR_FEATURES\r\n{\r\n    UINT32 dwValue;\r\n    struct {\r\n        UINT32 Is64bit : 1;     //!< 0      Will SMM monitor run in 64bit\r\n        UINT32 Reserved0 : 31;  //!< 1-31   0\r\n    };\r\n} VMX_SMM_MONITOR_FEATURES, *PVMX_SMM_MONITOR_FEATURES;\r\nC_ASSERT(sizeof(UINT32) == sizeof(VMX_SMM_MONITOR_FEATURES));\r\n\r\n//! Vol 3C, Table 34-10. Format of MSEG Header (Monitor SEGment)\r\ntypedef struct _VMX_MSEG_HEADER\r\n{\r\n    UINT32 dwRevision;\r\n    VMX_SMM_MONITOR_FEATURES tMonitorFeatures;\r\n    UINT32 dwGdtrLimit;\r\n    UINT32 dwGdtrBaseOffset;\r\n    UINT32 dwCsSelector;\r\n    UINT32 dwEipOffset;\r\n    UINT32 dwEspOffset;\r\n    UINT32 dwCr3Offset;\r\n} VMX_MSEG_HEADER, *PVMX_MSEG_HEADER;\r\n\r\ntypedef enum _VMX_OPCODE_RC\r\n{\r\n    VMX_SUCCESS = 0,    //!< Opcode succeeded\r\n    VMX_ERROR,          //!< Opcode failed - read VMCS_FIELD_VM_INSTRUCTION_ERROR for info\r\n    VMX_ERROR_NO_INFO   //!< Opcode failed - no information available on error\r\n} VMX_OPCODE_RC, *PVMX_OPCODE_RC;\r\n\r\n//! Vol 3C, Table 30-1. VM-Instruction Error Numbers\r\n// Define VM_INSTRUCTION_ERROR enum and error message array using X-Macros\r\n#define VM_INSTRUCTION_ERRORS \\\r\n        X(VMERROR_VMCALL_IN_ROOT, 1, \"VMCALL executed in VMX root operation\") \\\r\n        X(VMERROR_VMCLEAR_INVALID_ADDR, 2, \"VMCLEAR with invalid physical address\") \\\r\n        X(VMERROR_VMCLEAR_WITH_VMXON, 3, \"VMCLEAR with VMXON pointer\") \\\r\n        X(VMERROR_VMLAUNCH_VMCS_UNCLEAR, 4, \"VMLAUNCH with non - clear VMCS\") \\\r\n        X(VMERROR_VMRESUME_VMCS_NOT_LAUNCHED, 5, \"VMRESUME with non - launched VMCS\") \\\r\n        X(VMERROR_VMRESUME_AFTER_VMXOFF, 6, \"VMRESUME after VMXOFF(VMXOFF and VMXON between VMLAUNCH and VMRESUME)\") \\\r\n        X(VMERROR_VMENTRY_INVALID_CONTROLS, 7, \"VM entry with invalid control field(s)\") \\\r\n        X(VMERROR_VMENTRY_INVALID_STATE, 8, \"VM entry with invalid host - state field(s)\") \\\r\n        X(VMERROR_VMPTRLD_INVALID_ADDR, 9, \"VMPTRLD with invalid physical address\") \\\r\n        X(VMERROR_VMPTRLD_WITH_VMXON, 10, \"VMPTRLD with VMXON pointer\") \\\r\n        X(VMERROR_VMPTRLD_BAD_REVISION, 11, \"VMPTRLD with incorrect VMCS revision identifier\") \\\r\n        X(VMERROR_VM_RW_BAD_FIELD, 12, \"VMREAD / VMWRITE from / to unsupported VMCS component\") \\\r\n        X(VMERROR_VMWRITE_TO_READONLY_FIELD, 13, \"VMWRITE to read - only VMCS component\") \\\r\n        X(VMERROR_VMXON_IN_ROOT, 15, \"VMXON executed in VMX root operation\") \\\r\n        X(VMERROR_VMENTRY_BAD_VMCS_PTR, 16, \"VM entry with invalid executive - VMCS pointer\") \\\r\n        X(VMERROR_VMENTRY_VMCS_PTR_NOT_LAUNCHED, 17, \"VM entry with non - launched executive VMCS\") \\\r\n        X(VMERROR_VMENTRY_DURING_DUAL_MONITOR_SHUTDOWN, 18, \"VM entry with executive - VMCS pointer not VMXON pointer(when attempting to deactivate the dual - monitor treatment of, SMIs and SMM)\") \\\r\n        X(VMERROR_VMCALL_VMCS_UNCLEAR, 19, \"VMCALL with non - clear VMCS(when attempting to activate the dual - monitor treatment of SMIs and SMM)\") \\\r\n        X(VMERROR_VMCALL_INVALID_CONTROLS, 20, \"VMCALL with invalid VM - exit control fields\") \\\r\n        X(VMERROR_VMCALL_BAD_REVISION, 22, \"VMCALL with incorrect MSEG revision identifier(when attempting to activate the dual - monitor treatment of SMIs and SMM)\") \\\r\n        X(VMERROR_VMXOFF_IN_DUAL_MONITOR, 23, \"VMXOFF under dual - monitor treatment of SMIs and SMM\") \\\r\n        X(VMERROR_VMCALL_INVALID_FEATURE, 24, \"VMCALL with invalid SMM - monitor features(when attempting to activate the dual - monitor treatment of SMIs and SMM)\") \\\r\n        X(VMERROR_VMENTRY_INVALID_CONTROLS_SMM, 25, \"VM entry with invalid VM-execution control fields in executive VMCS (when attempting to return from SMM)\") \\\r\n        X(VMERROR_VMENTRY_EVENTS_BLOCKED, 26, \"VM entry with events blocked by MOV SS.\") \\\r\n        X(VMERROR_INV_BAD_OPERAND, 28, \"Invalid operand to INVEPT / INVVPID.\")\r\n\r\ntypedef enum _VM_INSTRUCTION_ERROR\r\n{\r\n#define X(EnumName,EnumValue,ErrorMsg) EnumName = EnumValue,\r\n    VM_INSTRUCTION_ERRORS\r\n#undef X\r\n    VM_INSTRUCTION_ERROR_MAX,\r\n    VM_INSTRUCTION_ERROR_INVALID = VM_INSTRUCTION_ERROR_MAX\r\n} VM_INSTRUCTION_ERROR, *PVM_INSTRUCTION_ERROR;\r\n\r\n/**\r\n* Get the error messages string for the VM instruction error\r\n* @param eVmError - value of VMCS_FIELD_VM_INSTRUCTION_ERROR after a VMX_ERROR\r\n* @return Error message string\r\n*/\r\nLPCSTR\r\nVTX_GetVmInstructionErrorMsg(\r\n    IN const VM_INSTRUCTION_ERROR eVmError\r\n);\r\n\r\n//! Vol 3C, 31.5 VMM SETUP & TEAR DOWN\r\n/**\r\n* Adjust the value of CR0 according to the FIXED MSRs\r\n* to clear/set bits that the CPU doesn't/must support\r\n* @param ptCr0 - value to edit\r\n*/\r\nVOID\r\nVTX_AdjustCr0(\r\n    OUT PCR0_REG ptCr0\r\n);\r\n\r\n/**\r\n* Adjust the value of CR4 according to the FIXED MSRs\r\n* to clear/set bits that the CPU doesn't/must support\r\n* @param ptCr4 - value to edit\r\n*/\r\nVOID\r\nVTX_AdjustCr4(\r\n    OUT PCR4_REG ptCr4\r\n);\r\n\r\n/**\r\n* Adjust the value of the VMX execution control according to the MSR\r\n* to clear/set bits that the CPU doesn't/must support.\r\n* @param dwAdjustMsrCode - MSR code of MSR used to adjust the VMX control\r\n* @param pdwCtlValue - VMX execution control to adjust\r\n*/\r\nVOID\r\nVTX_AdjustCtl(\r\n    IN    const UINT32 dwAdjustMsrCode,\r\n    OUT    PUINT32    pdwCtlValue\r\n);\r\n\r\n/**\r\n* Log VMX instruction error on the line it occurred in code\r\n* (hence we a macro and not a function)\r\n* @param ptLog - initialized LOG_HANDLE\r\n* @param eModule - module where the error occurred (LOG_MODULE enum)\r\n* @param eRc - local VTX_RC variable\r\n*/\r\n#define LOG_VMX_INSTRUCTION_ERROR(ptLog, eModule, eRc) \\\r\n    do \\\r\n    { \\\r\n        if (VTX_SUCCESS != (eRc)) \\\r\n        { \\\r\n            LPCSTR pszVmxErrorMsg = NULL; \\\r\n            VM_INSTRUCTION_ERROR eVmxError = VM_INSTRUCTION_ERROR_INVALID; \\\r\n            if (VTX_FAIL_VALID == (eRc)) \\\r\n            { \\\r\n                (VOID)ASM64_Vmread32(VMCS_FIELD_VM_INSTRUCTION_ERROR, (PUINT32)&eVmxError); \\\r\n                pszVmxErrorMsg = VTX_GetVmInstructionErrorMsg(eVmxError); \\\r\n                LOG_ERROR((ptLog), (eModule), \"VMX instruction error %d - %s\", \\\r\n                    eVmxError, pszVmxErrorMsg); \\\r\n            } \\\r\n            else \\\r\n            { \\\r\n                LOG_ERROR((ptLog), (eModule), \"VMX instruction error - no data\"); \\\r\n            } \\\r\n        } \\\r\n    } while (FALSE);\r\n\r\n/**\r\n* Write to a VMCS field and goto label if VMWRITE failed\r\n* NOTE: Don't use this macro directly! Use the below macros instead\r\n* @param Bits - VMCS field bits 16/32/64\r\n* @param dwVmcsField - VMCS field encoding to write to\r\n* @param Value - value to assign VMCS field\r\n* @param eRc - local VTX_RC variable\r\n* @param label - label to goto on failure\r\n*/\r\n#ifndef __VMWRITE_ON_ERROR_GOTO\r\n#define __VMWRITE_ON_ERROR_GOTO(Bits, dwVmcsField, Value, label) \\\r\n    do \\\r\n    { \\\r\n        VTX_RC __eVtxRc = VTX_FAIL_INVALID; \\\r\n        __eVtxRc = ASM64_Vmwrite##Bits((dwVmcsField), (Value)); \\\r\n        if (VTX_SUCCESS != __eVtxRc) \\\r\n        { \\\r\n            goto label; \\\r\n        } \\\r\n    } while (FALSE);\r\n#endif\r\n#define VMWRITE16_ON_ERROR_GOTO(dwVmcsField, wValue, label) \\\r\n    __VMWRITE_ON_ERROR_GOTO(16, (dwVmcsField), (wValue), label)\r\n#define VMWRITE32_ON_ERROR_GOTO(dwVmcsField, dwValue, label) \\\r\n    __VMWRITE_ON_ERROR_GOTO(32, (dwVmcsField), (dwValue), label)\r\n#define VMWRITE64_ON_ERROR_GOTO(dwVmcsField, qwValue, label) \\\r\n    __VMWRITE_ON_ERROR_GOTO(64, (dwVmcsField), (qwValue), label)\r\n\r\n/**\r\n* Read a VMCS field and goto label if VMREAD failed\r\n* NOTE: Don't use this macro directly! Use the below macros instead\r\n* @param Bits - VMCS field bits 16/32/64\r\n* @param dwVmcsField - VMCS field encoding to write to\r\n* @param Value - value to assign VMCS field\r\n* @param eRc - local VTX_RC variable\r\n* @param label - label to goto on failure\r\n*/\r\n#ifndef __VMREAD_ON_ERROR_GOTO\r\n#define __VMREAD_ON_ERROR_GOTO(Bits, dwVmcsField, ptValue, label) \\\r\n    do \\\r\n    { \\\r\n        VTX_RC __eVtxRc = VTX_FAIL_INVALID; \\\r\n        __eVtxRc = ASM64_Vmread##Bits((dwVmcsField), (ptValue)); \\\r\n        if (VTX_SUCCESS != __eVtxRc) \\\r\n        { \\\r\n            goto label; \\\r\n        } \\\r\n    } while (FALSE);\r\n#endif\r\n#define VMREAD16_ON_ERROR_GOTO(dwVmcsField, pwValue, label) \\\r\n    __VMREAD_ON_ERROR_GOTO(16, (dwVmcsField), (pwValue), label);\r\n#define VMREAD32_ON_ERROR_GOTO(dwVmcsField, pdwValue, label) \\\r\n    __VMREAD_ON_ERROR_GOTO(32, (dwVmcsField), (pdwValue), label)\r\n#define VMREAD64_ON_ERROR_GOTO(dwVmcsField, pqwValue, label) \\\r\n    __VMREAD_ON_ERROR_GOTO(64, (dwVmcsField), (pqwValue), label)\r\n\r\n//! Vol 3C, 24.6 VM-EXECUTION CONTROL FIELDS\r\n#define VMX_ADJUST_PINBASED_CTLS(pdwCtlValue) \\\r\n    VTX_AdjustCtl(MSR_CODE_IA32_VMX_PINBASED_CTLS, (pdwCtlValue))\r\n#define VMX_ADJUST_PROCBASED_CTLS(pdwCtlValue) \\\r\n    VTX_AdjustCtl(MSR_CODE_IA32_VMX_PROCBASED_CTLS, (pdwCtlValue))\r\n#define VMX_ADJUST_PROCBASED_CTLS2(pdwCtlValue) \\\r\n    VTX_AdjustCtl(MSR_CODE_IA32_VMX_PROCBASED_CTLS2, (pdwCtlValue))\r\n#define VMX_ADJUST_EXIT_CTLS(pdwCtlValue) \\\r\n    VTX_AdjustCtl(MSR_CODE_IA32_VMX_EXIT_CTLS, (pdwCtlValue))\r\n#define VMX_ADJUST_ENTRY_CTLS(pdwCtlValue) \\\r\n    VTX_AdjustCtl(MSR_CODE_IA32_VMX_ENTRY_CTLS, (pdwCtlValue))\r\n\r\n#pragma pack(pop)\r\n#pragma warning(pop)\r\n#endif /* __INTEL_VT_X_H__ */\r\n\n", "comment_ratio": 0.3203957382039574}
{"lang": "c", "code": "@import Foundation;\n#import \"SCLAlertView.h\"\n\n@interface SCLAlertViewResponder : NSObject\n\n/** TODO\n *\n * TODO\n */\n- (instancetype)init:(SCLAlertView *)alertview;\n\n/** TODO\n *\n * TODO\n */\n- (void)close;\n\n@end\n\n", "comment_ratio": 0.25925925925925924}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\ntypedef void (^FXDeallocBlock)(void);\n\n/**\n *  This class can be used to monitor an object's release, to check memory leak(especially when you are using ReactiveCocoa, too many strong weak dances, nested blocks, etc...Xcode Instrument can't detect all retain cycles every time, but FXDeallocMonitor is capable to do it).\n *  Inspired by my mentor DarwinRie(\u8fbe\u6587\u54e5) \ud83d\ude01\n */\n@interface FXDeallocMonitor : NSObject\n\n/**\n *  Print object when it is being deallocated(before object_dispose())\n */\n+ (void)addMonitorToObj:(id)obj;\n\n/**\n *  Print object with description when it is being deallocated\n *\n *  @param obj  object\n *  @param desc description\n */\n+ (void)addMonitorToObj:(id)obj withDesc:(NSString *)desc;\n\n/**\n *  Print object and excute deallocBlock when it is being deallocated\n *\n *  @param obj          object\n *  @param deallocBlock a block will run when object is being deallocated. For example, remove KVO in this block\n */\n+ (void)addMonitorToObj:(id)obj withDeallocBlock:(FXDeallocBlock)deallocBlock;\n\n/**\n *  Print object with description and and excute deallocBlock when it is being deallocated\n *\n *  @param obj          object\n *  @param desc         description\n *  @param deallocBlock a block will run when object is being deallocated\n */\n+ (void)addMonitorToObj:(id)obj withDesc:(NSString *)desc deallocBlock:(FXDeallocBlock)deallocBlock;\n\n@end\n\n", "comment_ratio": 0.14285714285714285}
{"lang": "c", "code": "#pragma once\n//------------------------------------------------------------------------------\n/**\n    @class OSX::OSXThread\n\n    OSX implementation of Threading::Thread. Uses the pthread API.\n \n    (C) 2010 Radon Labs GmbH\n    (C) 2013-2018 Individual contributors, see AUTHORS file\n*/\n#include \"core/refcounted.h\"\n#include \"threading/threadid.h\"\n#include \"system/cpu.h\"\n\n//------------------------------------------------------------------------------\nnamespace OSX\n{\nclass OSXThread : public Core::RefCounted\n{\n    __DeclareClass(OSXThread);\npublic:\n    /// thread priorities\n    enum Priority\n    {\n        Low,\n        Normal,\n        High,\n    };\n    \n    /// constructor\n    OSXThread();\n    /// destructor\n    virtual ~OSXThread();\n    /// set the thread priority\n    void SetPriority(Priority p);\n    /// get the thread priority\n    Priority GetPriority() const;\n    /// set cpu core on which the thread should be running\n    void SetCoreId(System::Cpu::CoreId coreId);\n    /// get the cpu core on which the thread should be running\n    System::Cpu::CoreId GetCoreId() const;\n    /// set stack size in bytes (default is 4 KByte)\n    void SetStackSize(SizeT s);\n    /// get stack size\n    SizeT GetStackSize() const;\n    /// set thread name\n    void SetName(const Util::String& n);\n    /// get thread name\n    const Util::String& GetName() const;\n    /// start executing the thread code, returns when thread has actually started\n    void Start();\n    /// request threading code to stop, returns when thread has actually finished\n    void Stop();\n    /// return true if thread has been started\n    bool IsRunning() const;\n    \n    /// yield the thread (gives up current time slice)\n    static void YieldThread();\n    /// get the thread ID of this thread\n    static Threading::ThreadId GetMyThreadId();\n    \n    #if NEBULA_DEBUG\n    /*\n    struct ThreadDebugInfo\n    {\n        Util::String threadName;\n        PS3Thread::Priority threadPriority;\n        System::Cpu::CoreId threadCoreId;\n        SizeT threadStackSize;\n    };\n    /// query thread stats (debug mode only)\n    static Util::Array<ThreadDebugInfo> GetRunningThreadDebugInfos();        \n    */\n    #endif\n    \nprotected:\n    /// override this method if your thread loop needs a wakeup call before stopping\n    virtual void EmitWakeupSignal();\n    /// this method runs in the thread context\n    virtual void DoWork();\n    /// check if stop is requested, call from DoWork() to see if the thread proc should quit\n    bool ThreadStopRequested() const;\n    \nprivate:\n    /// thread states\n    enum ThreadState\n    {\n        Initial,\n        Running,\n        Stopped,\n    };\n    \n    pthread_t thread;\n    Priority priority;\n    SizeT stackSize;\n    Util::String name;\n    System::Cpu::CoreId coreId;\n    ThreadState volatile threadState;\n    \n#if NEBULA_DEBUG\n    static Threading::CriticalSection criticalSection;\n    static Util::List<OSXThread*> ThreadList;\n    Util::List<OSXThread*>::Iterator threadListIterator;\n#endif\n};\n    \n//------------------------------------------------------------------------------\n/**\n*/\ninline void\nOSXThread::SetPriority(Priority p)\n{\n    this->priority = p;\n}\n    \n//------------------------------------------------------------------------------\n/**\n */\ninline OSXThread::Priority\nOSXThread::GetPriority() const\n{\n    return this->priority;\n}\n    \n//------------------------------------------------------------------------------\n/**\n */\ninline void\nOSXThread::SetStackSize(SizeT s)\n{\n    this->stackSize = s;\n}\n    \n//------------------------------------------------------------------------------\n/**\n */\ninline SizeT\nOSXThread::GetStackSize() const\n{\n    return this->stackSize;\n}\n    \n//------------------------------------------------------------------------------\n/**\n    If the derived DoWork() method is running in a loop it must regularly\n    check if the process wants the thread to terminate by calling\n    ThreadStopRequested() and simply return if the result is true. This\n    will cause the thread to shut down.\n */\ninline bool\nOSXThread::ThreadStopRequested() const\n{\nn_error(\"IMPLEMENT ME!\");\nreturn false;\n    //return this->stopRequestEvent.Peek();\n}\n    \n//------------------------------------------------------------------------------\n/**\n    Set the thread's name.\n*/\ninline void\nOSXThread::SetName(const Util::String& n)\n{\n    n_assert(n.IsValid());\n    this->name = n;\n}\n    \n//------------------------------------------------------------------------------\n/**\n    Get the thread's name. This is the vanilla method which\n    returns the name member.\n*/\ninline const Util::String&\nOSXThread::GetName() const\n{\n    return this->name;\n}\n    \n//------------------------------------------------------------------------------\n/**\n*/\ninline void\nOSXThread::SetCoreId(System::Cpu::CoreId id)\n{\n    this->coreId = id;\n}\n    \n//------------------------------------------------------------------------------\n/**\n */\ninline System::Cpu::CoreId\nOSXThread::GetCoreId() const\n{\n    return this->coreId;\n}\n    \n} // namespace OSX\n//------------------------------------------------------------------------------\n\n", "comment_ratio": 0.175}
{"lang": "c", "code": "#include <stdio.h>\n#include <string.h>\n\n#define TRUE 1\n#define FALSE 0\n\nchar A[20] = \"how is everything?\";\nchar B[20] = \"ssasasassassaaa\";\n\n// This function iterates through the character string \"str\" (which is of\n// length \"str_len\" and counts how many instances there are of the\n// character \"c\".\nint\ncount_letters(char str[], int str_len, char c) {\n  int count = 0;\n  for (int i = 0 ; i < str_len ; ++ i) {\n\t if (str[i] == c) {\n\t\tcount ++;\n\t }\n  }\n  return count;\n}\n\n// This function iterates through the character string \"str\" (which is of\n// length \"str_len\" and counts how many instances there are of the\n// string \"sub_str\" (which is of length \"substr_len\"). \nint\ncount_substring(char str[], int str_len, char sub_str[], int substr_len) {\n  int count = 0;\n  for (int i = 0 ; i < (str_len - substr_len) ; ++ i) {\n    int match = TRUE;\n    for (int j = 0 ; j < substr_len ; ++ j) {\n      if (str[i+j] != sub_str[j]) {\n        match = FALSE;\n        break;\n      }\n    }\n    if (match) {\n      count ++;\n    }      \n  }\n  return count;\n}\n\nint\nmain(int argc, char *argv[]) {\n  int v = count_letters(A, strlen(A), 'v');\n  printf(\"%d, %d\\n\", v, strlen(A));\n  int w = count_substring(B, strlen(B), \"sa\", 2);\n  printf(\"%d %d\\n\", w, strlen(B));\n  return 0;\n}\n\n", "comment_ratio": 0.11320754716981132}
{"lang": "c", "code": "#ifndef STB_MIDI_FILE_H\n#define STB_MIDI_FILE_H\n\n#include <cstddef>\n#include <cstdint>\n#include <cstdio>\n\n#include <string>\n\n#include \"STB/Endian.h\"\n#include \"STB/MidiDecoder.h\"\n\nnamespace STB {\n\nnamespace MIDI {\n\n//! A MIDI File\nclass File\n{\npublic:\n   File() = default;\n\n   ~File()\n   {\n      delete[] data;\n   }\n\n   bool load(const std::string& filename)\n   {\n      // Open file\n      FILE* fp = fopen(filename.c_str(), \"r\");\n      if (fp == nullptr) return error(\"Failed to open file\");\n\n      // Get size (bytes)\n      if (fseek(fp, 0, SEEK_END) != 0) return error(\"Failed to fseek\");\n      long size = ftell(fp);\n      if (size <= 0)                   return error(\"Failed to ftell\");\n      if (fseek(fp, 0, SEEK_SET) != 0) return error(\"Failed to fseek\");\n\n      if (data != nullptr)\n      {\n         delete[] data;\n      }\n\n      data = (Header*) new uint8_t[size];\n\n      // Read file\n      if (fread((void*)data, size, 1, fp) != 1) return error(\"Failed to fread\");\n\n      fclose(fp);\n      fp = nullptr;\n\n      return true;\n   }\n\n   //! MIDI file format\n   //  0 => single multi-channel track\n   //  1 => one or more simultanious tracks\n   //  2 => one or more independant tracks\n   unsigned getFormat() const { return data->format; }\n\n   //! Get number of tracks\n   unsigned getNumTracks() const { return data->ntrks; }\n\n   //! Get time division\n   uint16_t getDivision() const { return data->division; }\n\n   //! Get raw data for a track\n   const uint8_t* getTrackData(unsigned track_no, size_t& size) const\n   {\n      const Chunk* chunk = &data->chunk;\n\n      for(unsigned i=0; i<getNumTracks(); i++)\n      {\n         chunk = chunk->getNext();\n         if (i == track_no)\n         {\n            size = chunk->size();\n            return chunk->data();\n         }\n      }\n\n      size = 0;\n      return nullptr; \n   }\n\n   void decodeTrack(unsigned track_no, Decoder* decoder) const\n   {\n      decoder->resetState();\n\n      size_t size;\n      const uint8_t* ptr = getTrackData(track_no, size);\n      const uint8_t* end = ptr + size;\n\n      while(ptr < end)\n      {\n         ptr += decoder->decodeDeltaT(ptr);\n         ptr += decoder->decode(ptr, end - ptr);\n      }\n   }\n\nprivate:\n   //! The header for a MIDI file chunk\n   //  Should only be used to decode a MIDI file that is stored in a single contiguous\n   //  block of memory\n   class Chunk\n   {\n   public:\n      Chunk(bool is_header)\n      {\n         type[0] = 'M';\n         type[1] = 'T';\n         type[2] = is_header ? 'h' : 'r';\n         type[3] = is_header ? 'd' : 'k';\n      }\n\n      //! Get raw size of track (bytes)\n      size_t size() const { return length; }\n\n      //! Return a pointer to the data for the chunk\n      const uint8_t* data() const { return (const uint8_t*)this + sizeof(Chunk); }\n\n      //! Return a pointer to the byte after the last data byte in the chunk\n      const uint8_t* end() const { return data() + size(); }\n\n      //! Return a pointer to the next chunk\n      const Chunk* getNext() const { return (const Chunk*)end(); }\n\n   private:\n      uint8_t    type[4];\n      STB::Big32 length{0};\n   };\n\n   //! The header for a MIDI file\n   struct Header\n   {\n      Chunk      chunk{/* is_header */true};\n      STB::Big16 format{0};\n      STB::Big16 ntrks{0};\n      STB::Big16 division{0};\n   };\n\n   FILE*   fp{nullptr};\n   Header* data{nullptr};\n\n   bool error(const std::string& message)\n   {\n      fprintf(stderr, \"ERR: MIDI %s\\n\", message.c_str());\n      if (fp != nullptr)\n      {\n         fclose(fp);\n         fp = nullptr;\n      }\n      return false;\n   }\n};\n\n} // namespace MIDI\n\n} // namespace STB\n\n#endif\n\n", "comment_ratio": 0.22702702702702704}
{"lang": "c", "code": "#pragma once\n#include \"fern/core/data_types.h\"\n#include \"fern/core/value_types.h\"\n\n\nnamespace fern {\n\n//! ExpressionType instances keep track of the data and value types of an expression.\n/*!\n  Once evaluated, an expression results in data with one data type and one\n  value type. Before evaluation, it may not be clear yet what the data- and/or\n  value type of the expression's result will be. At that time, the\n  ExpressionType instance can store multiple data types and value types.\n\n  \\sa        ExpressionTypes\n*/\nclass ExpressionType\n{\n\npublic:\n\n                   ExpressionType      ()=default;\n\n                   ExpressionType      (DataTypes const& data_types,\n                                        ValueTypes const& value_types);\n\n                   ExpressionType      (ExpressionType&&)=default;\n\n    ExpressionType& operator=          (ExpressionType&&)=default;\n\n                   ExpressionType      (ExpressionType const&)=default;\n\n    ExpressionType& operator=          (ExpressionType const&)=default;\n\n                   ~ExpressionType     ()=default;\n\n    DataTypes      data_type           () const;\n\n    ValueTypes     value_type          () const;\n\n    bool           defined             () const;\n\n    bool           fixed               () const;\n\n    bool           is_satisfied_by     (\n                                  ExpressionType const& expression_type) const;\n\nprivate:\n\n    DataTypes      _data_types;\n\n    ValueTypes     _value_types;\n\n};\n\n\nbool               operator==          (ExpressionType const& lhs,\n                                        ExpressionType const& rhs);\n\nbool               operator!=          (ExpressionType const& lhs,\n                                        ExpressionType const& rhs);\n\nstd::ostream&      operator<<          (std::ostream& stream,\n                                        ExpressionType const& expression_type);\n\n} // namespace fern\n\n", "comment_ratio": 0.13333333333333333}
{"lang": "c", "code": "#import <objc/NSObject.h>\n\n@class NSArray, NSMutableSet;\n\n@interface GADMediationServerConfiguration : NSObject\n{\n    NSMutableSet *_credentials;\n}\n\n- (void).cxx_destruct;\n- (void)addMediationCredentials:(id)arg1;\n@property(readonly, nonatomic) NSArray *credentials;\n- (id)initWithDictionary:(id)arg1;\n- (id)init;\n\n@end\n\n\n", "comment_ratio": 0.20833333333333334}
{"lang": "c", "code": "#pragma once\n\n#include \"nlopt.h\"\n#include <string>\n#include <vector>\n\nextern \"C\" {\n#include \"gofuncs.h\"\n}\n\nnamespace gosat {\n\nclass GOFuncsMap {\n    using FuncEntry = std::pair<nlopt_func, unsigned>;\npublic:\n    GOFuncsMap()\n    {\n        m_global_func_vec =\n                {\n#include \"gofuncs.api\"\n\n                        {\"_dummy_func\", {m_dummy_func, 1}}\n                };\n        m_global_func_vec.pop_back();\n    }\n\n    virtual ~GOFuncsMap() = default;\n\n    const std::vector<std::pair<std::string, FuncEntry>>&\n    getFuncMap() const noexcept\n    { return m_global_func_vec; };\n\nprivate:\n    nlopt_func m_dummy_func;\n    std::vector<std::pair<std::string, FuncEntry>> m_global_func_vec;\n};\n}\n\n", "comment_ratio": 0.1702127659574468}
{"lang": "c", "code": "#include <driver/ledc.h>\n\n#define LED_RED_PIN 26\n#define LED_GREEN_PIN 25\n\nvoid led_set(bool red, bool green) {\n  // set duties\n  ESP_ERROR_CHECK(ledc_set_duty(LEDC_HIGH_SPEED_MODE, LEDC_CHANNEL_0, red ? 512 : 0));\n  ESP_ERROR_CHECK(ledc_set_duty(LEDC_HIGH_SPEED_MODE, LEDC_CHANNEL_1, green ? 512 : 0));\n\n  // update channels\n  ESP_ERROR_CHECK(ledc_update_duty(LEDC_HIGH_SPEED_MODE, LEDC_CHANNEL_0));\n  ESP_ERROR_CHECK(ledc_update_duty(LEDC_HIGH_SPEED_MODE, LEDC_CHANNEL_1));\n}\n\nvoid led_init() {\n  // prepare ledc timer config\n  ledc_timer_config_t t = {\n      .bit_num = LEDC_TIMER_10_BIT, .freq_hz = 5000, .speed_mode = LEDC_HIGH_SPEED_MODE, .timer_num = LEDC_TIMER_0};\n\n  // configure ledc timer\n  ESP_ERROR_CHECK(ledc_timer_config(&t));\n\n  // prepare ledc channel config\n  ledc_channel_config_t c = {\n      .duty = 0, .intr_type = LEDC_INTR_DISABLE, .speed_mode = LEDC_HIGH_SPEED_MODE, .timer_sel = LEDC_TIMER_0};\n\n  // configure red led\n  c.gpio_num = LED_RED_PIN;\n  c.channel = LEDC_CHANNEL_0;\n  ESP_ERROR_CHECK(ledc_channel_config(&c));\n\n  // configure green led\n  c.gpio_num = LED_GREEN_PIN;\n  c.channel = LEDC_CHANNEL_1;\n  ESP_ERROR_CHECK(ledc_channel_config(&c));\n}\n\n", "comment_ratio": 0.18421052631578946}
{"lang": "c", "code": "#pragma once\n\n#include <numeric>\n\nnamespace rtl\n{\n  template <typename Iterator>\n  [[nodiscard]] constexpr typename Iterator::value_type average(const Iterator first, const Iterator last)\n  {\n    using underlying_type = typename Iterator::value_type;\n\n    underlying_type value = std::accumulate(first, last, underlying_type());\n    auto diff = std::distance(first, last);\n    return value /= clamp_min(diff, 1);\n  }\n}\n", "comment_ratio": 0.32}
{"lang": "c", "code": "#ifndef __MEDIA_LIBVA_CAPS_XEHP_SDV_H__\n#define __MEDIA_LIBVA_CAPS_XEHP_SDV_H__\n\n#include \"media_libva.h\"\n#include \"media_libva_caps_factory.h\"\n\n#include \"media_libva_caps_g12.h\"\n#include \"linux_system_info.h\"\n\n//!\n//! \\class  MediaLibvaCapsXeHP\n//! \\brief  Media libva caps XeHP\n//!\nclass MediaLibvaCapsXeHP : public MediaLibvaCapsG12\n{\npublic:\n    //!\n    //! \\brief    Constructor\n    //!\n    MediaLibvaCapsXeHP(DDI_MEDIA_CONTEXT *mediaCtx) : MediaLibvaCapsG12(mediaCtx)\n    {\n        return;\n    }\n\n    //!\n    //! \\brief    Destructor\n    //!\n    virtual ~MediaLibvaCapsXeHP() {};\n\n protected:\n    static const uint32_t m_hevcDPEncMaxHeight = 4320;\n    virtual VAStatus GetPlatformSpecificAttrib(VAProfile profile,\n                                               VAEntrypoint entrypoint,\n                                               VAConfigAttribType type,\n                                               unsigned int *value) override;\n\n    virtual VAStatus CheckEncodeResolution(VAProfile profile, uint32_t width, uint32_t height) override;\n};\n#endif\n\n", "comment_ratio": 0.208955223880597}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n#import \"TuyaSmartMultiControlParentRuleModel.h\"\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface TuyaSmartMultiControlGroupDetailModel : NSObject\n\n@property (copy, nonatomic) NSString *detailId;\n@property (copy, nonatomic) NSString *multiControlId;///< Multi-control group id.\n@property (copy, nonatomic) NSString *devId;///< Attachment device id.\n@property (copy, nonatomic) NSString *devName;///< Name of attached device.\n@property (copy, nonatomic) NSString *dpId;///< The dp id of the associated attached device.\n@property (copy, nonatomic) NSString *dpName;///< The dp name of the associated attached device.\n@property (assign, nonatomic) BOOL enabled;///< Whether affiliated devices that have been associated can be controlled by the multi-control function.\n@property (strong, nonatomic) NSArray<TuyaSmartMultiControlDatapointModel *> *datapoints;\n\n@end\n\n\n@interface TuyaSmartMultiControlGroupModel : NSObject\n\n@property (copy, nonatomic) NSString *multiControlId;///< Multi-control group id.\n@property (copy, nonatomic) NSString *groupName;///< Multi-control group name.\n@property (strong, nonatomic) NSArray<TuyaSmartMultiControlGroupDetailModel *> *groupDetail;///< Multi-control group details.\n\n@property (assign, nonatomic) BOOL enabled;\n@property (assign, nonatomic) NSInteger groupType;///< Multi-control group type.\n@property (copy, nonatomic) NSString *multiRuleId;\n@property (copy, nonatomic) NSString *ownerId;///< Family id.\n@property (copy, nonatomic) NSString *uid;///< User id.\n\n@end\n\n\n@interface TuyaSmartMultiControlLinkModel : NSObject\n\n@property (strong, nonatomic) TuyaSmartMultiControlGroupModel *multiGroup;\n@property (strong, nonatomic) NSArray<TuyaSmartMultiControlParentRuleModel *> *parentRules;\n\n@end\n\nNS_ASSUME_NONNULL_END\n\n", "comment_ratio": 0.3469387755102041}
{"lang": "c", "code": "#ifndef CHROME_BROWSER_SYNC_SYNCABLE_AUTOFILL_MIGRATION_H_\n#define CHROME_BROWSER_SYNC_SYNCABLE_AUTOFILL_MIGRATION_H_\n#pragma once\n\nnamespace syncable {\nenum AutofillMigrationState {\n\n  // Indicates the default state. After first run the state would change to\n  // one of the following.\n  NOT_DETERMINED,\n\n  // The autofill profile is not migrated. Current sync should migrate the data\n  // by syncing down the old autofill and syncing profiles back up to the server\n  // as new autofill.\n  NOT_MIGRATED,\n\n  // We have migrated the autofill profile data. From now on autofill and\n  // autofill profiles are 2 seperate data types.\n  MIGRATED,\n\n  // The autofill datatype is being synced new.(either because this is a new\n  // client or the user just enabled them for syncing). In which case if\n  // someother client had migrated the data already then our new state after\n  // first sync would be MIGRATED. Else we would be responsible for migrating\n  // the data.\n  INSUFFICIENT_INFO_TO_DETERMINE\n};\n\nstruct AutofillMigrationDebugInfo {\n  enum PropertyToSet {\n    MIGRATION_TIME,\n    BOOKMARK_ADDED,\n    ENTRIES_ADDED,\n    PROFILES_ADDED\n  };\n  int64 autofill_migration_time;\n  int bookmarks_added_during_migration;\n  int autofill_entries_added_during_migration;\n  int autofill_profile_added_during_migration;\n};\n\n}  // namespace syncable\n\n#endif  // CHROME_BROWSER_SYNC_SYNCABLE_AUTOFILL_MIGRATION_H_\n\n\n", "comment_ratio": 0.34}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n\n@interface AppDelegate : UIResponder <UIApplicationDelegate>\n\n@property (strong, nonatomic) UIWindow *window;\n\n\n@end\n\n\n", "comment_ratio": 0.3888888888888889}
{"lang": "c", "code": "#ifndef CHROME_BROWSER_ANDROID_EXPLORE_SITES_CLEAR_ACTIVITIES_TASK_H_\n#define CHROME_BROWSER_ANDROID_EXPLORE_SITES_CLEAR_ACTIVITIES_TASK_H_\n\n#include \"base/memory/raw_ptr.h\"\n#include \"base/time/time.h\"\n#include \"chrome/browser/android/explore_sites/explore_sites_store.h\"\n#include \"chrome/browser/android/explore_sites/explore_sites_types.h\"\n#include \"components/offline_pages/task/task.h\"\n\nusing offline_pages::Task;\n\nnamespace explore_sites {\n\n// Takes a URL that the user has asked us to remove, and adds it to a blocklist\n// of sites we will stop showing in Explore on Sites.\nclass ClearActivitiesTask : public Task {\n public:\n  ClearActivitiesTask(ExploreSitesStore* store,\n                      base::Time begin,\n                      base::Time end,\n                      BooleanCallback callback);\n  ~ClearActivitiesTask() override;\n\n private:\n  // Task implementation:\n  void Run() override;\n\n  void DoneExecuting(bool result);\n\n  raw_ptr<ExploreSitesStore> store_;  // outlives this class.\n  base::Time begin_;\n  base::Time end_;\n  BooleanCallback callback_;\n  base::WeakPtrFactory<ClearActivitiesTask> weak_factory_{this};\n};\n\n}  // namespace explore_sites\n\n#endif  // CHROME_BROWSER_ANDROID_EXPLORE_SITES_CLEAR_ACTIVITIES_TASK_H_\n\n", "comment_ratio": 0.20454545454545456}
{"lang": "c", "code": "// -------------------------------------------------- //\n// This file is autogenerated by pioasm; do not edit! //\n// -------------------------------------------------- //\n\n#if !PICO_NO_HARDWARE\n#include \"hardware/pio.h\"\n#endif\n\n// ------ //\n// tft_io //\n// ------ //\n\n#define tft_io_wrap_target 0\n#define tft_io_wrap 9\n\n#define tft_io_offset_start_16 0u\n#define tft_io_offset_start_8 7u\n\nstatic const uint16_t tft_io_program_instructions[] = {\n            //     .wrap_target\n    0x98a0, //  0: pull   block           side 1     \n    0x6028, //  1: out    x, 8                       \n    0x7108, //  2: out    pins, 8         side 0 [1] \n    0xb842, //  3: nop                    side 1     \n    0xa0e1, //  4: mov    osr, x                     \n    0x7008, //  5: out    pins, 8         side 0     \n    0x0000, //  6: jmp    0                          \n    0x9aa0, //  7: pull   block           side 1 [2] \n    0x7108, //  8: out    pins, 8         side 0 [1] \n    0x0007, //  9: jmp    7                          \n            //     .wrap\n};\n\n#if !PICO_NO_HARDWARE\nstatic const struct pio_program tft_io_program = {\n    .instructions = tft_io_program_instructions,\n    .length = 10,\n    .origin = -1,\n};\n\nstatic inline pio_sm_config tft_io_program_get_default_config(uint offset) {\n    pio_sm_config c = pio_get_default_sm_config();\n    sm_config_set_wrap(&c, offset + tft_io_wrap_target, offset + tft_io_wrap);\n    sm_config_set_sideset(&c, 2, true, false);\n    return c;\n}\n#endif\n\n\n", "comment_ratio": 0.3673469387755102}
{"lang": "c", "code": "/* This file was generated by syncqt. */\n#ifndef QT_QTQUICKPARTICLES_VERSION_H\n#define QT_QTQUICKPARTICLES_VERSION_H\n\n#define QTQUICKPARTICLES_VERSION_STR \"5.12.3\"\n\n#define QTQUICKPARTICLES_VERSION 0x050C03\n\n#endif // QT_QTQUICKPARTICLES_VERSION_H\n\n", "comment_ratio": 0.1}
{"lang": "c", "code": "#ifndef LSCExportTypeModuleHeader_h\n#define LSCExportTypeModuleHeader_h\n\n#import \"LSCExportTypeModule.h\"\n#import \"LSCExportType.h\"\n#import \"LSCTypeDescription.h\"\n#import \"LSCInstance.h\"\n#import \"LSCTypeValue.h\"\n#import \"LSCInstanceValue.h\"\n\n#import \"LSCExportFilter.h\"\n#import \"LSCDefaultExportFilter.h\"\n#import \"LSCExportTypeRule.h\"\n\n\n#endif /* LSCExportTypeModuleHeader_h */\n\n", "comment_ratio": 0.28}
{"lang": "c", "code": "#import \"NSObject.h\"\n\n#import \"SCNRenderContext.h\"\n\n@class NSString, SCNRenderTargetRegistry;\n\n__attribute__((visibility(\"hidden\")))\n@interface SCNRenderContextImp : NSObject <SCNRenderContext>\n{\n    struct C3DColor4 _backgroundColor;\n    long long _currentFrameIndex;\n    struct __C3DEngineStats *__engineStats;\n    SCNRenderTargetRegistry *_renderTargetRegistry;\n    double contentScaleFactor;\n    long long sampleCount;\n}\n\n@property(readonly, nonatomic) SCNRenderTargetRegistry *renderTargetRegistry; // @synthesize renderTargetRegistry=_renderTargetRegistry;\n@property(nonatomic) long long sampleCount; // @synthesize sampleCount;\n@property(nonatomic) double contentScaleFactor; // @synthesize contentScaleFactor;\n- (struct __C3DMeshElement *)createVolatileMeshElementOfType:(BOOL)arg1 primitiveCount:(long long)arg2 bytesPerIndex:(long long)arg3;\n- (void)unmapVolatileMesh:(struct __C3DMesh *)arg1;\n- (BOOL)mapVolatileMesh:(struct __C3DMesh *)arg1 verticesCount:(long long)arg2;\n- (void)renderBackground:(struct __C3DEffectSlot *)arg1 engineContext:(struct __C3DEngineContext *)arg2;\n- (void)drawFullScreenQuadForPass:(struct __C3DFXPass *)arg1;\n-     // Error parsing type: v148@0:8^{__C3DMesh={__C3DEntity={__CFRuntimeBase=Q[4C]I}^v^{__CFString}^{__CFString}^{__CFDictionary}qq}[9^{__CFArray}]^{C3DSphere}^^{__CFArray}b1b1b1b4q}16^{__C3DMeshElement=}24^{__C3DFXProgram={__C3DEntity={__CFRuntimeBase=Q[4C]I}^v^{__CFString}^{__CFString}^{__CFDictionary}qq}ib1b1^{__C3DFXProgramDelegate}}32^{__C3DEngineContext=}40(C3DMatrix4x4=[16f][4])48r^{C3DColor4=(?=[4f]{?=ffff})}112^{__C3DRasterizerStates=}120^{__C3DBlendStates=}128^{__C3DImage=}136c144, name: renderMesh:meshElement:withProgram:engineContext:transform:color:rasterizerStates:blendState:texture:depthBias:\n- (void)drawRenderElement:(struct __C3DRendererElement *)arg1 withPass:(struct __C3DFXPass *)arg2;\n- (void)processRendererElement:(struct __C3DRendererElement *)arg1 engineIterationContext:(CDStruct_256c7a3c *)arg2;\n- (void)stopProcessingRendererElements;\n- (void)processRendererElement:(struct __C3DRendererElement *)arg1;\n- (void)startProcessingRendererElementsWithEngineIterationContext:(CDStruct_256c7a3c *)arg1;\n- (id)newRenderTargetWithDescription:(CDStruct_2e3d5ba3 *)arg1 size: /* Error: Ran out of types for this method. */;\n- (void)popDebugGroup;\n- (void)pushDebugGroup:(id)arg1;\n- (id)textureForEffectSlot:(struct __C3DEffectSlot *)arg1;\n@property(nonatomic) BOOL showsAuthoringEnvironment;\n@property(readonly, nonatomic) id <SCNResourceManager> resourceManager;\n- (struct __C3DEngineStats *)stats;\n@property(readonly, nonatomic) long long currentFrameIndex;\n- (void)setBackgroundColor:(struct C3DColor4)arg1;\n- (void)endRenderPass;\n- (BOOL)beginRenderPass:(struct __C3DFXPass *)arg1 isFinalTechnique:(BOOL)arg2;\n- (void)endFrameWaitingUntilCompleted:(BOOL)arg1;\n- (void)beginFrame:(id)arg1;\n@property(readonly, nonatomic) int profile;\n@property(readonly, nonatomic) unsigned int features;\n- (void)dealloc;\n- (id)init;\n\n// Remaining properties\n@property(readonly, copy) NSString *debugDescription;\n@property(readonly, copy) NSString *description;\n@property(readonly) unsigned long long hash;\n@property(readonly) Class superclass;\n\n@end\n\n\n", "comment_ratio": 0.15625}
{"lang": "c", "code": "#ifndef AMSI_VERBOSITY_H_\n#ifdef AMSI_VERBOSE_1\n#define AMSI_V1(out) out\n#else\n#define AMSI_V1(out) while(false);\n#endif\n#ifdef AMSI_VERBOSE_2\n#define AMSI_V2(out) out\n#else\n  // need this to compile, but compiler should optimize away\n#define AMSI_V2(out) while(false);\n#endif\n#ifdef AMSI_VERBOSE_3\n#define AMSI_V3(out) out\n#else\n  // need this to compile, but compiler should optimize away\n#define AMSI_V3(out) while(false);\n#endif\n#endif\n\n", "comment_ratio": 0.1}
{"lang": "c", "code": "#pragma once\n\n#include \"MSACore.h\"\n#include \"MSAObjCPointer.h\"\n#include \"MSAPhysicsParams.h\"\n\n\nnamespace MSA {\n\t\n\tnamespace Physics {\n\t\t\n\t\ttemplate <typename T>\n\t\tclass WorldT;\n\t\t\n\t\ttemplate <typename T>\n\t\tclass ParticleT : public ObjCPointer {\n\t\t\t\n\t\tpublic:\n\t\t\tfriend class WorldT<T>;\n\t\t\t\n\t\t\tParticleT();\n\t\t\tParticleT(T pos, float m = 1.0f, float d = 1.0f);\n\t\t\tParticleT(ParticleT &p);\n\t\t\t\n\t\t\tvirtual void\tinit(T pos, float m = 1.0f, float d = 1.0f);\n\t\t\t\n\t\t\tParticleT*\t\tsetMass(float t = 1);\n\t\t\tfloat\t\t\tgetMass();\n\t\t\tfloat\t\t\tgetInvMass();\n\t\t\t\n\t\t\tParticleT*\t\tsetDrag(float t = 1);\n\t\t\tfloat\t\t\tgetDrag();\n\t\t\t\n\t\t\tParticleT*\t\tsetBounce(float t = 1);\n\t\t\tfloat\t\t\tgetBounce();\n\t\t\t\n\t\t\tParticleT*\t\tsetRadius(float t = 15);\n\t\t\tfloat\t\t\tgetRadius();\n\t\t\t\n\t\t\t// collision methods\n\t\t\tParticleT*\t\tenableCollision();\n\t\t\tParticleT*\t\tdisableCollision();\n\t\t\tbool\t\t\thasCollision();\n\t\t\t\n\t\t\tbool\t\t\tisFixed();\n\t\t\tbool\t\t\tisFree();\n\t\t\tParticleT*\t\tmakeFixed();\n\t\t\tParticleT*\t\tmakeFree();\n\t\t\t\n\t\t\t// quick way of enabling (collision and update) and disabling\n\t\t\tParticleT*\t\tenable();\n\t\t\tParticleT*\t\tdisable();\n\t\t\t\n\t\t\t// move the particle\n\t\t\t// if preserveVelocity == true, the particle will move to new position and keep it's old velocity\n\t\t\t// if preserveVelocity == false, the particle will move to new position but gain the velocity of the displacement\n\t\t\tParticleT* moveTo(T targetPos, bool preserveVelocity = true);\n\t\t\tParticleT* moveBy(T offset, bool preserveVelocity = true);\n\t\t\t\n//\t\t\tfloat\t\t\tgetX();\n//\t\t\tfloat\t\t\tgetY();\n//\t\t\tfloat\t\t\tgetZ();\n\t\t\tconst T&\t\tgetPosition();\n\t\t\t\n\t\t\tParticleT*\t\tsetVelocity(T vel);\n\t\t\tParticleT*\t\taddVelocity(T vel);\n\t\t\tT\t\t\t\tgetVelocity();\n\t\t\t\n\t\t\t// override these functions if you create your own particle type with custom behaviour and/or drawing\n\t\t\tvirtual void\tupdate() {}\t\t// called every frame in world::update();\n\t\t\tvirtual void\tdraw() {}\t\t// called every frame in world::draw();\n\t\t\tvirtual void\tcollidedWithParticle(ParticleT *other, T collisionForce) {}\t// called when this particle collides with another particle (called for both particles)\n\t\t\tvirtual void\tcollidedWithEdgeOfWorld(T collisionForce) {}\n\t\t\t\n\t\t\tvoid\t\t\tkill();\n\t\t\tbool\t\t\tisDead();\n\t\t\t\n\t\t\t// custom void* which you can use to store any kind of custom data\n\t\t\tvoid\t\t\t*data;\n\t\t\t\n\t\t\tParamsT<T>\t\t*getParams();\n\n\t\t\t// only particles sharing bits in the collision plane collide with each other\n\t\t\tunsigned int\tcollisionPlane;\n\n\t\tprotected:\n\t\t\tParamsT<T>\t\t*_params;\n\t\t\tWorldT<T>\t\t*_world;\n\t\t\t\n\t\t\t\n\t\t\tT\t\t\t\t_pos;\n\t\t\tT\t\t\t\t_oldPos;\n\t\t\tfloat\t\t\t_mass, _invMass;\n\t\t\tfloat\t\t\t_drag;\n\t\t\tfloat\t\t\t_bounce;\n\t\t\tfloat\t\t\t_radius;\n\t\t\tfloat\t\t\t_age;\n\t\t\tbool\t\t\t_isDead;\n\t\t\tbool\t\t\t_isFixed;\n\t\t\tbool\t\t\t_collisionEnabled;\n\t\t\t\n\t\t\tvoid\t\t\tdoVerlet();\n\t\t\tvoid\t\t\tcheckWorldEdges();\n\t\t\t\n\t\t\tvirtual void debugDraw();\n\t\t};\n\t\t\n\t\t\n\t\t\n\t\ttemplate <typename T>\n\t\tinline ParticleT<T>* ParticleT<T>::setMass(float t) {\n\t\t\tif(t==0) t=0.00001f;\n\t\t\t_mass = t;\n\t\t\t_invMass = 1.0f/t;\n\t\t\treturn this;\n\t\t}\n\t\t\n\t\ttemplate <typename T>\n\t\tinline float ParticleT<T>::getMass() {\n\t\t\treturn _mass;\n\t\t}\n\t\t\n\t\ttemplate <typename T>\n\t\tinline float ParticleT<T>::getInvMass() {\n\t\t\treturn _invMass;\n\t\t}\n\t\t\n\t\t\n\t\ttemplate <typename T>\n\t\tinline ParticleT<T>* ParticleT<T>::setDrag(float t) {\n\t\t\t_drag = t;\n\t\t\treturn this;\n\t\t}\n\t\t\n\t\ttemplate <typename T>\n\t\tinline float ParticleT<T>::getDrag() {\n\t\t\treturn _drag;\n\t\t}\n\t\t\n\t\ttemplate <typename T>\n\t\tinline ParticleT<T>* ParticleT<T>::setBounce(float t) {\n\t\t\t_bounce = t;\n\t\t\treturn this;\n\t\t}\n\t\t\n\t\ttemplate <typename T>\n\t\tinline float ParticleT<T>::getBounce() {\n\t\t\treturn _bounce;\n\t\t}\n\t\t\n\t\t\n\t\ttemplate <typename T>\n\t\tinline ParticleT<T>* ParticleT<T>::setRadius(float t) {\n\t\t\t_radius = t;\n\t\t\treturn this;\n\t\t}\n\t\t\n\t\ttemplate <typename T>\n\t\tinline float ParticleT<T>::getRadius() {\n\t\t\treturn _radius;\n\t\t}\n\t\t\n\t\ttemplate <typename T>\n\t\tinline bool ParticleT<T>::isFixed() {\n\t\t\treturn (_isFixed == true);\n\t\t}\n\t\t\n\t\ttemplate <typename T>\n\t\tinline bool ParticleT<T>::isFree() {\n\t\t\treturn (_isFixed == false);\n\t\t}\n\t\t\n\t\ttemplate <typename T>\n\t\tinline ParticleT<T>* ParticleT<T>::makeFixed() {\n\t\t\t_isFixed = true;\n\t\t\treturn this;\n\t\t}\n\t\t\n\t\ttemplate <typename T>\n\t\tinline ParticleT<T>* ParticleT<T>::makeFree() {\n\t\t\t_oldPos = _pos;\n\t\t\t_isFixed = false;\n\t\t\treturn this;\n\t\t}\n\t\t\n\t\ttemplate <typename T>\n\t\tinline ParticleT<T>* ParticleT<T>::moveTo(T targetPos, bool preserveVelocity) {\n\t\t\tT diff = targetPos - _pos;\n\t\t\tmoveBy(diff, preserveVelocity);\n\t\t\treturn this;\n\t\t}\n\t\t\n\t\ttemplate <typename T>\n\t\tinline ParticleT<T>* ParticleT<T>::moveBy(T offset, bool preserveVelocity) {\n\t\t\t_pos += offset;\n\t\t\tif(preserveVelocity) _oldPos += offset;\n\t\t\treturn this;\n\t\t}\n\t\t\n//\t\ttemplate <typename T>\n//\t\tinline float ParticleT<T>::getX() {\n//\t\t\treturn _pos.x;\n//\t\t}\n//\t\t\n//\t\ttemplate <typename T>\n//\t\tinline float ParticleT<T>::getY() {\n//\t\t\treturn _pos.y;\n//\t\t}\n//\t\t\n//\t\ttemplate <typename T>\n//\t\tinline float ParticleT<T>::getZ() {\n//\t\t\treturn _pos.z;\n//\t\t}\n//\t\t\n\t\ttemplate <typename T>\n\t\tinline const T& ParticleT<T>::getPosition() {\n\t\t\treturn _pos;\n\t\t}\n\t\t\n\t\ttemplate <typename T>\n\t\tinline ParticleT<T>* ParticleT<T>::setVelocity(T vel) {\n\t\t\t_oldPos = _pos - vel;\n\t\t\treturn this;\n\t\t}\n\t\t\n\t\ttemplate <typename T>\n\t\tinline ParticleT<T>* ParticleT<T>::addVelocity(T vel) {\n\t\t\t_oldPos -= vel;\n\t\t\treturn this;\n\t\t}\n\t\t\n\t\ttemplate <typename T>\n\t\tinline T ParticleT<T>::getVelocity() {\n\t\t\treturn _pos - _oldPos;\n\t\t}\n\t\t\n\t\ttemplate <typename T>\n\t\tinline void ParticleT<T>::kill() {\n\t\t\t_isDead = true;\n\t\t}\n\t\t\n\t\t\n\t\ttemplate <typename T>\n\t\tinline bool ParticleT<T>::isDead() {\n\t\t\treturn _isDead;\n\t\t}\n\t\t\n\t\ttemplate <typename T>\n\t\tParticleT<T>::ParticleT() {\n\t\t\tinit(T());\n\t\t}\n\t\t\n\t\t\n\t\ttemplate <typename T>\n\t\tParticleT<T>::ParticleT(T pos, float m, float d) {\n\t\t\tinit(pos, m, d);\n\t\t}\n\t\t\n\t\ttemplate <typename T>\n\t\tParticleT<T>::ParticleT(ParticleT<T> &p) {\n\t\t\tinit(p.getPosition(), p._mass, p._drag);\n\t\t\t_isFixed = p._isFixed;\n\t\t\tsetBounce(p._bounce);\n\t\t\tsetRadius(p._radius);\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\ttemplate <typename T>\n\t\tvoid ParticleT<T>::init(T pos, float m, float d) {\n\t\t\t_params = NULL;\n\t\t\t_world = NULL;\n\t\t\t\n\t\t\t_pos = _oldPos = pos;\n\t\t\tsetMass(m);\n\t\t\tsetDrag(d);\n\t\t\tsetBounce();\n\t\t\tsetRadius();\n\t\t\tenableCollision();\n\t\t\tmakeFree();\n\t\t\t_isDead = false;\n\t\t\t_age = 0;\n\t\t\tverbose = true;\n\t\t\tdata = NULL;\n\t\t\t\n\t\t\tcollisionPlane = -1;\n\t\t\t\n\t\t\tsetClassName(\"ParticleT\");\n\t\t}\n\t\t\n\t\ttemplate <typename T>\n\t\tParticleT<T>* ParticleT<T>::enableCollision(){\n\t\t\t_collisionEnabled = true;\n\t\t\treturn this;\n\t\t}\n\t\t\n\t\ttemplate <typename T>\n\t\tParticleT<T>* ParticleT<T>::disableCollision() {\n\t\t\t_collisionEnabled = false;\n\t\t\treturn this;\n\t\t}\n\t\t\n\t\ttemplate <typename T>\n\t\tbool ParticleT<T>::hasCollision() {\n\t\t\treturn _collisionEnabled;\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\ttemplate <typename T>\n\t\tParticleT<T>* ParticleT<T>::enable(){\n\t\t\tenableCollision();\n\t\t\tmakeFree();\n\t\t\treturn this;\n\t\t}\n\t\t\n\t\ttemplate <typename T>\n\t\tParticleT<T>* ParticleT<T>::disable() {\n\t\t\tdisableCollision();\n\t\t\tmakeFixed();\n\t\t\treturn this;\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t\ttemplate <typename T>\n\t\tvoid ParticleT<T>::doVerlet() {\n\t\t\tif (!_isFixed) {\n\t\t\t\tif(_params->doGravity) {\n\t\t\t\t\tT gravityForce = _params->gravity;\n\t\t\t\t\taddVelocity(gravityForce);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tT curPos = _pos;\n\t\t\t\tT vel = _pos - _oldPos;\n\t\t\t\t_pos += vel * _params->drag * _drag;// + _params->timeStep2;\n\t\t\t\t//_pos += (_pos - _oldPos);// + _params->timeStep2;\t// TODO\n\t\t\t\t_oldPos = curPos;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\ttemplate <typename T>\n\t\tvoid ParticleT<T>::checkWorldEdges() {\n\t\t\t//\tprintf(\"%.3f, %.3f, %.3f\\n\", _params->worldMin.x, _params->worldMax.y, _params->worldMax.z);\n\n\t\t\t// not keen on this solution, but best so far\n\t\t\t//\t\t\tT r;\n\t\t\t\n\t\t\tbool collided = false;\n\t\t\tT oldVel = getVelocity();\n\t\t\tfor(int i=0; i<T::DIM; i++) {\n\t\t\t\t//\t\t\t\tr[i] = _radius;\n\t\t\t\t\n\t\t\t\tfloat vel = _pos[i] - _oldPos[i];\n\t\t\t\tif(_pos[i] < _params->worldMin[i] + _radius) {\n\t\t\t\t\t_pos[i] = _params->worldMin[i] + _radius;\n\t\t\t\t\t_oldPos[i] = _pos[i] + vel * _bounce;\n\t\t\t\t\tcollided = true;\n\t\t\t\t} else if(_pos[i] > _params->worldMax[i] - _radius) {\n\t\t\t\t\t_pos[i] = _params->worldMax[i] - _radius;\n\t\t\t\t\t_oldPos[i] = _pos[i] + vel * _bounce;\n\t\t\t\t\tcollided = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(collided) collidedWithEdgeOfWorld(getVelocity() - oldVel);\n\n\t\t\t\n\t\t\t//\t\t\tif(_pos.x < _params->worldMin.x + _radius) {\n\t\t\t//\t\t\t\tfloat vel = _pos.x - _oldPos.x;\n\t\t\t//\t\t\t\t_pos.x = _params->worldMin.x + _radius;\n\t\t\t//\t\t\t\t_oldPos.x = _pos.x + vel * _bounce;\n\t\t\t//\t\t\t} else if(_pos.x > _params->worldMax.x - _radius) {\n\t\t\t//\t\t\t\tfloat vel = _pos.x - _oldPos.x;\n\t\t\t//\t\t\t\t_pos.x = _params->worldMax.x - _radius;\n\t\t\t//\t\t\t\t_oldPos.x = _pos.x + vel * _bounce;\n\t\t\t//\t\t\t}\n\t\t\t//\t\t\t\n\t\t\t//\t\t\tif( _pos.y < _params->worldMin.y + _radius) {\n\t\t\t//\t\t\t\tfloat vel = _pos.y - _oldPos.y;\n\t\t\t//\t\t\t\t_pos.y = _params->worldMin.y + _radius;\n\t\t\t//\t\t\t\t_oldPos.y = _pos.y + vel * _bounce;\n\t\t\t//\t\t\t} else if(_pos.y > _params->worldMax.y - _radius) {\n\t\t\t//\t\t\t\tfloat vel = _pos.y - _oldPos.y;\n\t\t\t//\t\t\t\t_pos.y = _params->worldMax.y - _radius;\n\t\t\t//\t\t\t\t_oldPos.y = _pos.y + vel * _bounce;\n\t\t\t//\t\t\t}\n\t\t\t//\t\t\t\n\t\t\t//\t\t\tif(_pos.z < _params->worldMin.z + _radius) {\n\t\t\t//\t\t\t\tfloat vel = _pos.z - _oldPos.z;\n\t\t\t//\t\t\t\t_pos.z = _params->worldMin.z + _radius;\n\t\t\t//\t\t\t\t_oldPos.z = _pos.z + vel * _bounce;\n\t\t\t//\t\t\t} else if(_pos.z > _params->worldMax.z - _radius) {\n\t\t\t//\t\t\t\tfloat vel = _pos.z - _oldPos.z;\n\t\t\t//\t\t\t\t_pos.z = _params->worldMax.z - _radius;\n\t\t\t//\t\t\t\t_oldPos.z = _pos.z + vel * _bounce;\n\t\t\t//\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\ttemplate <typename T>\n\t\tParamsT<T> *ParticleT<T>::getParams() {\n\t\t\treturn _params;\n\t\t}\n\t\t\n\t\t\n\t\ttemplate <typename T>\n\t\tvoid ParticleT<T>::debugDraw() {\n\t\t\t//\t\t\tglPushMatrix();\n\t\t\t//\t\t\tglTranslatef(_pos.x, _pos.y, _pos.z);\n\t\t\t//#ifndef TARGET_OS_IPHONE\n\t\t\t//\t\t\tglutSolidSphere(_radius, 12, 12);\n\t\t\t//#else\n\t\t\t//\t\t\tofCircle(0, 0, _radius);\n\t\t\t//#endif\n\t\t\t//\t\t\tglPopMatrix();\n\t\t}\n\t\t\n\t\t\n\t}\n}\n\n", "comment_ratio": 0.15789473684210525}
{"lang": "c", "code": "//\n//  LVCombineTaskHandler.h\n//  LVBaseKit\n//\n//  Created by Hong Lv on 2021/11/6.\n//\n\n#import <Foundation/Foundation.h>\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface LVCombineTaskHandler : NSObject\n\n@end\n\n\n\ntypedef void(^configureBlock)(const dispatch_group_t group, const dispatch_queue_t queue);\ntypedef void(^taskBlock) (const dispatch_group_t group, const dispatch_queue_t queue);\ntypedef void(^normalTaskBlock)(const dispatch_queue_t queue); ///queue \uff1a\u5f53\u524d\u4efb\u52a1\u961f\u5217\n\n/**\n @brief \u5229\u7528GCD_group\u5b8c\u6210\u5e76\u53d1\u4efb\u52a1\n */\n@interface LVGCDCombinTaskHandler : LVCombineTaskHandler\n\n@property (nonatomic, readonly, strong) dispatch_group_t group; ///< group\n\n/**\n @brief \u5f80Group\u6dfb\u52a0\u4efb\u52a1\n \n @param configure \u53ef\u4ee5\u4f7f\u7528 dispatch_group_enter \u6807\u5fd7\u4e00\u4e2a\u5f02\u6b65\u4efb\u52a1\uff0c\u5f53\u524dGroup\u4e2d\u672a\u5b8c\u6210\u7684\u4efb\u52a1\u6570+1\n @param task \u4efb\u52a1\n */\n- (void)addTaskConfigure:(configureBlock)configure task:(taskBlock)task;\n\n/**\n @brief \u5f53Group\u4efb\u52a1\u90fd\u5b8c\u6210\u65f6\u56de\u8c03\u51fd\u6570\n \n @note \u6267\u884c\u56de\u8c03\u7ebf\u7a0b\u4e3aGCD\u5206\u914d\u7684\u5f02\u6b65\u7ebf\u7a0b\n @param isMain \u662f\u4e3a\u4e3b\u7ebf\u7a0b\n */\n- (void)bindCompletionOnMainThread:(BOOL)isMain completion:(taskBlock)completion;\n\n/**\n @brief \u963b\u585e\u5f53\u524d\u7ebf\u7a0b\u7b49\u5f85Group\u4efb\u52a1\u90fd\u5b8c\u6210\n \n @note \u7981\u6b62\u5728UI\u7ebf\u7a0b\u4f7f\u7528\n */\n- (void)waitUnFinishTask:(dispatch_time_t)time;\n\n@end\n\n/**\n @brief \u5229\u7528GCD_Barrier\u5b9e\u73b0\u8bfb\u5199\u4efb\u52a1\n \n @note \u5141\u8bb8\u591a\u6761\u7ebf\u7a0b\u8bfb\u53d6\u64cd\u4f5c\n @note \u4e0d\u5141\u8bb8\u591a\u7ebf\u7a0b\u540c\u65f6\u6267\u884c\u8bfb\u3001\u5199\u64cd\u4f5c\n @note \u4e0d\u5141\u8bb8\u591a\u7ebf\u7a0b\u591a\u4e2a\u5199\u64cd\u4f5c\n */\n@interface LVBarrierReadWriteHander : LVCombineTaskHandler\n\n/**\n @brief \u5229\u7528 dispatch_barrier_async \u5f00\u8f9f\u65b0\u7ebf\u7a0b\u5b8c\u6210\u5199\u64cd\u4f5c\n */\n- (void)addWriteTask:(normalTaskBlock)task;\n\n/**\n @brief \u5229\u7528 dispatch_async \u5f02\u6b65\u5e76\u53d1\u4efb\u52a1\n */\n- (void)addReadTask:(normalTaskBlock)task;\n\n@end\n\nNS_ASSUME_NONNULL_END\n\n", "comment_ratio": 0.10526315789473684}
{"lang": "c", "code": "#include \"py/mpconfig.h\"\n\n#if PYBRICKS_PY_IODEVICES && PYBRICKS_PY_EV3DEVICES\n\n#include <pbio/iodev.h>\n\n#include \"py/mphal.h\"\n#include \"py/objstr.h\"\n#include \"py/runtime.h\"\n\n#include <pybricks/common.h>\n#include <pybricks/parameters.h>\n\n#include <pybricks/util_mp/pb_kwarg_helper.h>\n#include <pybricks/util_mp/pb_obj_helper.h>\n#include <pybricks/util_pb/pb_device.h>\n#include <pybricks/util_pb/pb_error.h>\n#include <pybricks/util_pb/pb_serial.h>\n\n#define UART_MAX_LEN (32 * 1024)\n\n// pybricks.iodevices.UARTDevice class object\ntypedef struct _iodevices_UARTDevice_obj_t {\n    mp_obj_base_t base;\n    pb_serial_t *serial;\n    mp_int_t timeout;\n} iodevices_UARTDevice_obj_t;\n\n// pybricks.iodevices.UARTDevice.__init__\nSTATIC mp_obj_t iodevices_UARTDevice_make_new(const mp_obj_type_t *otype, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    PB_PARSE_ARGS_CLASS(n_args, n_kw, args,\n        PB_ARG_REQUIRED(port),\n        PB_ARG_REQUIRED(baudrate),\n        PB_ARG_DEFAULT_NONE(timeout));\n    iodevices_UARTDevice_obj_t *self = m_new_obj(iodevices_UARTDevice_obj_t);\n    self->base.type = (mp_obj_type_t *)otype;\n\n    // Get port number\n    pbio_port_id_t port = pb_type_enum_get_value(port_in, &pb_enum_type_Port);\n\n    // Init UART port\n    pb_device_get_device(port, PBIO_IODEV_TYPE_ID_CUSTOM_UART);\n\n    // Initialize serial\n    self->timeout = timeout_in == mp_const_none ? -1 : pb_obj_get_int(timeout_in);\n    pb_assert(pb_serial_get(&self->serial, port, pb_obj_get_int(baudrate_in)));\n    pb_assert(pb_serial_clear(self->serial));\n\n    return MP_OBJ_FROM_PTR(self);\n}\n\n// pybricks.iodevices.UARTDevice.write\nSTATIC mp_obj_t iodevices_UARTDevice_write(size_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args) {\n\n    PB_PARSE_ARGS_METHOD(n_args, pos_args, kw_args,\n        iodevices_UARTDevice_obj_t, self,\n        PB_ARG_REQUIRED(data));\n\n    // Assert that data argument are bytes\n    if (!(mp_obj_is_str_or_bytes(data_in) || mp_obj_is_type(data_in, &mp_type_bytearray))) {\n        pb_assert(PBIO_ERROR_INVALID_ARG);\n    }\n\n    // Get data and length\n    GET_STR_DATA_LEN(data_in, data, data_len);\n\n    // Write data to serial\n    pb_assert(pb_serial_write(self->serial, data, data_len));\n\n    return mp_const_none;\n}\nSTATIC MP_DEFINE_CONST_FUN_OBJ_KW(iodevices_UARTDevice_write_obj, 1, iodevices_UARTDevice_write);\n\n// pybricks.iodevices.UARTDevice.waiting\nSTATIC mp_obj_t iodevices_UARTDevice_waiting(mp_obj_t self_in) {\n    iodevices_UARTDevice_obj_t *self = MP_OBJ_TO_PTR(self_in);\n    size_t waiting;\n    pb_assert(pb_serial_in_waiting(self->serial, &waiting));\n    return mp_obj_new_int(waiting);\n}\nSTATIC MP_DEFINE_CONST_FUN_OBJ_1(iodevices_UARTDevice_waiting_obj, iodevices_UARTDevice_waiting);\n\n// pybricks.iodevices.UARTDevice._read_internal\nSTATIC mp_obj_t iodevices_UARTDevice_read_internal(iodevices_UARTDevice_obj_t *self, size_t len) {\n\n    if (len > UART_MAX_LEN) {\n        pb_assert(PBIO_ERROR_INVALID_ARG);\n    }\n\n    // If we don't need to read anything, return empty bytearray\n    if (len < 1) {\n        uint8_t none = 0;\n        return mp_obj_new_bytes(&none, 0);\n    }\n\n    // Read data into buffer\n    uint8_t *buf = m_malloc(len);\n    if (buf == NULL) {\n        pb_assert(PBIO_ERROR_FAILED);\n    }\n\n    // Initial status\n    mp_uint_t time_start = mp_hal_ticks_ms();\n    size_t remaining = len;\n\n    // Read up to the timeout\n    while (true) {\n\n        // Read and keep track of how much was read\n        size_t read_now;\n        pb_assert(pb_serial_read(self->serial, &buf[len - remaining], len, &read_now));\n\n        // Decrement remaining count\n        remaining -= read_now;\n\n        // If there is nothing remaining, we are done\n        if (remaining == 0) {\n            break;\n        }\n\n        // If we have timed out, let the user know\n        if (self->timeout >= 0 && mp_hal_ticks_ms() - time_start > (mp_uint_t)self->timeout) {\n            pb_assert(PBIO_ERROR_TIMEDOUT);\n        }\n\n        // Wait before looking again\n        mp_hal_delay_ms(10);\n    }\n\n    // Convert to bytes\n    mp_obj_t ret = mp_obj_new_bytes(buf, len);\n\n    // Free internal buffer and return bytes\n    m_free(buf, len);\n    return ret;\n}\n\n// pybricks.iodevices.UARTDevice.read\nSTATIC mp_obj_t iodevices_UARTDevice_read(size_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args) {\n\n    PB_PARSE_ARGS_METHOD(n_args, pos_args, kw_args,\n        iodevices_UARTDevice_obj_t, self,\n        PB_ARG_DEFAULT_INT(length, 1));\n\n    size_t length = mp_obj_get_int(length_in);\n    return iodevices_UARTDevice_read_internal(self, length);\n}\nSTATIC MP_DEFINE_CONST_FUN_OBJ_KW(iodevices_UARTDevice_read_obj, 1, iodevices_UARTDevice_read);\n\n// pybricks.iodevices.UARTDevice.read_all\nSTATIC mp_obj_t iodevices_UARTDevice_read_all(mp_obj_t self_in) {\n\n    iodevices_UARTDevice_obj_t *self = MP_OBJ_TO_PTR(self_in);\n\n    size_t len;\n    pb_assert(pb_serial_in_waiting(self->serial, &len));\n\n    return iodevices_UARTDevice_read_internal(self, len);\n}\nSTATIC MP_DEFINE_CONST_FUN_OBJ_1(iodevices_UARTDevice_read_all_obj, iodevices_UARTDevice_read_all);\n\n// pybricks.iodevices.UARTDevice.clear\nSTATIC mp_obj_t iodevices_UARTDevice_clear(mp_obj_t self_in) {\n    iodevices_UARTDevice_obj_t *self = MP_OBJ_TO_PTR(self_in);\n    pb_assert(pb_serial_clear(self->serial));\n    return mp_const_none;\n}\nSTATIC MP_DEFINE_CONST_FUN_OBJ_1(iodevices_UARTDevice_clear_obj, iodevices_UARTDevice_clear);\n\n// dir(pybricks.iodevices.UARTDevice)\nSTATIC const mp_rom_map_elem_t iodevices_UARTDevice_locals_dict_table[] = {\n    { MP_ROM_QSTR(MP_QSTR_read),  MP_ROM_PTR(&iodevices_UARTDevice_read_obj) },\n    { MP_ROM_QSTR(MP_QSTR_read_all),  MP_ROM_PTR(&iodevices_UARTDevice_read_all_obj) },\n    { MP_ROM_QSTR(MP_QSTR_write),  MP_ROM_PTR(&iodevices_UARTDevice_write_obj) },\n    { MP_ROM_QSTR(MP_QSTR_waiting),MP_ROM_PTR(&iodevices_UARTDevice_waiting_obj) },\n    { MP_ROM_QSTR(MP_QSTR_clear),MP_ROM_PTR(&iodevices_UARTDevice_clear_obj) },\n};\nSTATIC MP_DEFINE_CONST_DICT(iodevices_UARTDevice_locals_dict, iodevices_UARTDevice_locals_dict_table);\n\n// type(pybricks.iodevices.UARTDevice)\nconst mp_obj_type_t pb_type_iodevices_UARTDevice = {\n    { &mp_type_type },\n    .name = MP_QSTR_UARTDevice,\n    .make_new = iodevices_UARTDevice_make_new,\n    .locals_dict = (mp_obj_dict_t *)&iodevices_UARTDevice_locals_dict,\n};\n\n#endif // PYBRICKS_PY_IODEVICES && PYBRICKS_PY_EV3DEVICES\n\n", "comment_ratio": 0.15625}
{"lang": "c", "code": "#pragma once\n#include <aws/elasticbeanstalk/ElasticBeanstalk_EXPORTS.h>\n#include <aws/core/utils/memory/stl/AWSString.h>\n\nnamespace Aws\n{\nnamespace ElasticBeanstalk\n{\nnamespace Model\n{\n  enum class ActionStatus\n  {\n    NOT_SET,\n    Scheduled,\n    Pending,\n    Running,\n    Unknown\n  };\n\nnamespace ActionStatusMapper\n{\nAWS_ELASTICBEANSTALK_API ActionStatus GetActionStatusForName(const Aws::String& name);\n\nAWS_ELASTICBEANSTALK_API Aws::String GetNameForActionStatus(ActionStatus value);\n} // namespace ActionStatusMapper\n} // namespace Model\n} // namespace ElasticBeanstalk\n} // namespace Aws\n\n", "comment_ratio": 0.11764705882352941}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n\n@interface SLTLog : NSObject\n\n+ (void)start;\n\n+ (void)log:(NSString *)event;\n\n@end\n\n", "comment_ratio": 0.3888888888888889}
{"lang": "c", "code": "#pragma once\n\n#include <QSortFilterProxyModel>\n\nnamespace WalletGui {\n\nclass TransactionsBlockModel : public QSortFilterProxyModel {\n  Q_OBJECT\n  Q_DISABLE_COPY(TransactionsBlockModel)\n\npublic:\n  TransactionsBlockModel(QAbstractItemModel* _blockChainModel, QObject* _parent);\n  ~TransactionsBlockModel();\n\n  QVariant data(const QModelIndex &_index, int _role = Qt::DisplayRole) const override;\n  void setBlockIndex(const QModelIndex &_index);\n\nprotected:\n  bool filterAcceptsRow(int _sourceRow, const QModelIndex &_sourceParent) const override;\n  bool filterAcceptsColumn(int _sourceColumn, const QModelIndex &_sourceParent) const override;\n  bool lessThan(const QModelIndex &_left, const QModelIndex &_right) const override;\n\nprivate:\n  QPersistentModelIndex m_blockIndex;\n};\n\n}\n\n", "comment_ratio": 0.35555555555555557}
{"lang": "c", "code": "#ifndef C0P_PARAM_OBJECTS_SURFER__US_1O0__SURFTIMECONST_8O0__REORIENTATIONTIME_4O0_GROUP_HOMOGENEOUS_MEMBER_AGENT_ACTIVE_PASSIVE_CHOICE_H\n#define C0P_PARAM_OBJECTS_SURFER__US_1O0__SURFTIMECONST_8O0__REORIENTATIONTIME_4O0_GROUP_HOMOGENEOUS_MEMBER_AGENT_ACTIVE_PASSIVE_CHOICE_H\n#pragma once\n\n// THIS FILE SHOULD NOT BE EDITED DIRECTLY BY THE USERS.\n// THIS FILE WILL BE AUTOMATICALLY EDITED WHEN THE\n// CHOOSE COMMAND IS USED\n\n// choose your object\n#include \"core/env/objects/object/passive/spheroid/core.h\"\n#include \"param/env/objects/surfer__us_1o0__surftimeconst_8o0__reorientationtime_4o0/group/homogeneous/_member/agent/_active/_passive/spheroid/parameters.h\"\nnamespace c0p {\n    using SurferUs1O0Surftimeconst8O0Reorientationtime4O0GroupHomogeneousMemberAgentActivePassiveStep = PassiveSpheroidStep<SurferUs1O0Surftimeconst8O0Reorientationtime4O0GroupHomogeneousMemberAgentActivePassiveSpheroidStepParameters>;\n}\n\n#endif\n\n", "comment_ratio": 0.23529411764705882}
{"lang": "c", "code": "#import <libobjc.A.dylib/NSSecureCoding.h>\n\n@class NSString, NSArray, NSURL;\n\n@interface MSEmailModel : NSObject <NSSecureCoding> {\n\n\tint _type;\n\tNSString* _subject;\n\tNSString* _sender;\n\tNSArray* _to;\n\tNSArray* _cc;\n\tNSArray* _bcc;\n\tNSString* _body;\n\tNSURL* _reference;\n\n}\n\n@property (nonatomic,copy) NSString * subject;               //@synthesize subject=_subject - In the implementation block\n@property (nonatomic,copy) NSString * sender;                //@synthesize sender=_sender - In the implementation block\n@property (nonatomic,copy) NSArray * to;                     //@synthesize to=_to - In the implementation block\n@property (nonatomic,copy) NSArray * cc;                     //@synthesize cc=_cc - In the implementation block\n@property (nonatomic,copy) NSArray * bcc;                    //@synthesize bcc=_bcc - In the implementation block\n@property (nonatomic,retain) NSString * body;                //@synthesize body=_body - In the implementation block\n@property (nonatomic,retain) NSURL * reference;              //@synthesize reference=_reference - In the implementation block\n@property (assign,nonatomic) int type;                       //@synthesize type=_type - In the implementation block\n+(BOOL)supportsSecureCoding;\n-(int)type;\n-(void)setType:(int)arg1 ;\n-(void)encodeWithCoder:(id)arg1 ;\n-(id)initWithCoder:(id)arg1 ;\n-(NSArray *)to;\n-(NSString *)sender;\n-(void)setSender:(NSString *)arg1 ;\n-(NSString *)subject;\n-(void)setSubject:(NSString *)arg1 ;\n-(void)setBody:(NSString *)arg1 ;\n-(NSString *)body;\n-(NSURL *)reference;\n-(void)setTo:(NSArray *)arg1 ;\n-(void)setReference:(NSURL *)arg1 ;\n-(NSArray *)cc;\n-(NSArray *)bcc;\n-(void)setCc:(NSArray *)arg1 ;\n-(void)setBcc:(NSArray *)arg1 ;\n@end\n\n\n", "comment_ratio": 0.14545454545454545}
{"lang": "c", "code": "#import <CoconutKit/CoconutKit.h>\n\nNS_ASSUME_NONNULL_BEGIN\n\n/**\n * A view controller which only supports portrait orientation\n */\n@interface PortraitOnlyViewController : HLSViewController\n@end\n\nNS_ASSUME_NONNULL_END\n\n", "comment_ratio": 0.2777777777777778}
{"lang": "c", "code": "#import <GrowlPlugins/GrowlDisplayWindowController.h>\n\n@class GrowlNotification;\n\n@interface GrowlBubblesWindowController : GrowlDisplayWindowController {\n\tunsigned\tuid;\n}\n\n\n@end\n\n", "comment_ratio": 0.4}
{"lang": "c", "code": "#ifndef LULLABY_MODULES_DEBUG_DEBUG_RENDER_H_\n#define LULLABY_MODULES_DEBUG_DEBUG_RENDER_H_\n\n#include <vector>\n\n#include \"lullaby/systems/render/shader.h\"\n#include \"lullaby/systems/render/texture.h\"\n#include \"lullaby/util/color.h\"\n#include \"lullaby/util/math.h\"\n\n// DebugRender provides basic geometry drawing functionality for\n// debugging purposes.\n\nnamespace lull {\nnamespace debug {\n\nclass DebugRenderDrawInterface;\n\n// Initializes the debug render system to allow debug drawing.\nvoid Initialize(DebugRenderDrawInterface* interface);\n\n// Returns true if debug rendering has already been initialized and has not been\n// shutdown.\nbool IsInitialized();\n\n// Resets DebugRender interface to nullptr.\nvoid Shutdown();\n\n// Adds line between two given points to the queue.\nvoid DrawLine(const char* tag_name, const mathfu::vec3& start_point,\n              const mathfu::vec3& end_point, Color4ub color);\n\n// Adds line connecting given points in sequence to the queue.\n// Calls DrawLine for the number of given points.\nvoid DrawLineStrip(const char* tag_name,\n                   const std::vector<mathfu::vec3>& points, Color4ub color);\n\n// Adds an RGB transform frame using the given matrix.\nvoid DrawTransformAxes(const char* tag_name,\n                       const mathfu::mat4& world_from_object_matrix);\n\n// Adds billboard text and its position to the render queue.\nvoid DrawText3D(const char* tag_name, const mathfu::vec3& pos, Color4ub color,\n                const char* text);\n\n// Adds 2D text to render queue. Will be drawn in fixed screen space.\nvoid DrawText2D(const char* tag_name, Color4ub color, const char* text);\n\n// Adds a 3D box to the debug render queue.\nvoid DrawBox3D(const char* tag_name,\n               const mathfu::mat4& world_from_object_matrix, const Aabb& box,\n               Color4ub color);\n\n// Adds a 2D screen-space quad to the debug render queue.\n// Origin is at screen center and 1.0 is approximately screen height.\nvoid DrawQuad2D(const char* tag_name, Color4ub color, float x, float y, float w,\n                float h, const TexturePtr& texture);\n\n// Adds a 2D screen-space quad to the debug render queue, using pixel units.\n// * Origin is at the top-left and position is in pixel units.\n// * UVs default to the [0, 1] range.\nvoid DrawQuad2DAbsolute(\n    const char* tag_name, const mathfu::vec4& color,\n    const mathfu::vec2& pixel_pos0, const mathfu::vec2& uv0,\n    const mathfu::vec2& pixel_pos1, const mathfu::vec2& uv1,\n    const TexturePtr& texture);\nvoid DrawQuad2DAbsolute(\n    const char* tag_name, const mathfu::vec4& color,\n    const mathfu::vec2& pixel_pos0,\n    const mathfu::vec2& pixel_pos1,\n    const TexturePtr& texture);\nvoid DrawQuad2DAbsolute(\n    const char* tag_name, Color4ub color,\n    const mathfu::vec2& pixel_pos0, const mathfu::vec2& uv0,\n    const mathfu::vec2& pixel_pos1, const mathfu::vec2& uv1,\n    const TexturePtr& texture);\nvoid DrawQuad2DAbsolute(\n    const char* tag_name, Color4ub color,\n    const mathfu::vec2& pixel_pos0,\n    const mathfu::vec2& pixel_pos1,\n    const TexturePtr& texture);\n\n// Calls drawing for all enabled elements in element buffer. Must be called in\n// between Begin() and End() after main render_system->Render().\nvoid Submit();\n\n}  // namespace debug\n}  // namespace lull\n\n#endif  // LULLABY_MODULES_DEBUG_DEBUG_RENDER_H_\n\n", "comment_ratio": 0.22429906542056074}
{"lang": "c", "code": "class MSTrigger : public Named {\npublic:\n    /** @brief Constructor\n     *\n     * @param[in] id The id of the trigger\n     */\n    MSTrigger(const std::string& id);\n\n    /// @brief Destructor\n    virtual ~MSTrigger();\n\n    /// @brief properly deletes all trigger instances\n    static void cleanup();\n\nprivate:\n    /// @brief Invalidated copy constructor.\n    MSTrigger(const MSTrigger&);\n\n    /// @brief Invalidated assignment operator.\n    MSTrigger& operator=(const MSTrigger&);\n\n    static std::set<MSTrigger*> myInstances;\n\n};\n\n\n#endif\n\n/****************************************************************************/\n\n\n", "comment_ratio": 0.3333333333333333}
{"lang": "c", "code": "#include \"pch.h\"\r\n\r\n#ifdef ALLOC_PRAGMA\r\n    #pragma alloc_text(PAGE, PcmciaInitDeviceDispatchTable)\r\n#endif\r\n\r\n//\r\n// Dispatch table array for FDOs/PDOs\r\n//\r\nPDRIVER_DISPATCH DeviceObjectDispatch[sizeof(DEVICE_OBJECT_TYPE)][IRP_MJ_MAXIMUM_FUNCTION + 1];\r\n\r\nVOID\r\nPcmciaInitDeviceDispatchTable(\r\n    IN PDRIVER_OBJECT DriverObject\r\n    )\r\n/*++\r\n\r\nRoutine Description:\r\n    Initializes the IRP dispatch tables for Pdo's & Fdo's\r\n\r\nArguments:\r\n    None\r\n\r\nReturn value:\r\n    None\r\n\r\n--*/\r\n{\r\n    ULONG i;\r\n\r\n    PAGED_CODE();\r\n\r\n    //\r\n    // Init the controller (FDO) dispatch table\r\n    //\r\n    DeviceObjectDispatch[FDO][IRP_MJ_CREATE] =         PcmciaOpenCloseDispatch;\r\n    DeviceObjectDispatch[FDO][IRP_MJ_CLOSE]  =         PcmciaOpenCloseDispatch;\r\n    DeviceObjectDispatch[FDO][IRP_MJ_CLEANUP]=         PcmciaCleanupDispatch;\r\n    DeviceObjectDispatch[FDO][IRP_MJ_DEVICE_CONTROL] = PcmciaDeviceControl;\r\n    DeviceObjectDispatch[FDO][IRP_MJ_SYSTEM_CONTROL] = PcmciaFdoSystemControl;\r\n    DeviceObjectDispatch[FDO][IRP_MJ_PNP] =            PcmciaFdoPnpDispatch;\r\n    DeviceObjectDispatch[FDO][IRP_MJ_POWER] =          PcmciaFdoPowerDispatch;\r\n\r\n    //\r\n    // Init the PDO dispatch table\r\n    //\r\n    DeviceObjectDispatch[PDO][IRP_MJ_DEVICE_CONTROL] = PcmciaPdoDeviceControl;\r\n    DeviceObjectDispatch[PDO][IRP_MJ_SYSTEM_CONTROL] = PcmciaPdoSystemControl;\r\n    DeviceObjectDispatch[PDO][IRP_MJ_PNP] =            PcmciaPdoPnpDispatch;\r\n    DeviceObjectDispatch[PDO][IRP_MJ_POWER] =          PcmciaPdoPowerDispatch;\r\n\r\n    //\r\n    // Set the global dispatch table\r\n    DriverObject->MajorFunction[IRP_MJ_CREATE] =         PcmciaDispatch;\r\n    DriverObject->MajorFunction[IRP_MJ_CLOSE] =          PcmciaDispatch;\r\n    DriverObject->MajorFunction[IRP_MJ_CLEANUP] =        PcmciaDispatch;\r\n    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = PcmciaDispatch;\r\n    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = PcmciaDispatch;\r\n    DriverObject->MajorFunction[IRP_MJ_SHUTDOWN] =       PcmciaDispatch;\r\n    DriverObject->MajorFunction[IRP_MJ_PNP] =            PcmciaDispatch;\r\n    DriverObject->MajorFunction[IRP_MJ_POWER] =          PcmciaDispatch;\r\n}\r\n\r\nNTSTATUS\r\nPcmciaDispatch(\r\n    IN PDEVICE_OBJECT DeviceObject,\r\n    IN PIRP Irp\r\n    )\r\n\r\n/*++\r\n\r\nRoutine Description:\r\n\r\n    Dispatch routine for all IRPs handled by this driver. This dispatch would then\r\n    call the appropriate real dispatch routine which corresponds to the device object\r\n    type (physical or functional).\r\n\r\nArguments:\r\n\r\n    DeviceObject -  Pointer to the device object this dispatch is intended for\r\n    Irp          -  Pointer to the IRP to be handled\r\n\r\nReturn value:\r\n    Returns the status from the 'real' dispatch routine which handles this IRP\r\n\r\n--*/\r\n\r\n{\r\n    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);\r\n    NTSTATUS status;\r\n    DEVICE_OBJECT_TYPE devtype = IS_PDO(DeviceObject) ? PDO : FDO;\r\n    UCHAR MajorFunction = irpStack->MajorFunction;\r\n\r\n    if ((MajorFunction > IRP_MJ_MAXIMUM_FUNCTION) ||\r\n        (DeviceObjectDispatch[devtype][MajorFunction] == NULL)) {\r\n\r\n        DebugPrint((PCMCIA_DEBUG_INFO, \"PCMCIA: Dispatch skipping unimplemented Irp MJ function %x\\n\", MajorFunction));\r\n        status = Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;\r\n        IoCompleteRequest(Irp, IO_NO_INCREMENT);\r\n\r\n    } else if (((devtype == PDO) && IsDeviceDeleted((PPDO_EXTENSION)DeviceObject->DeviceExtension)) ||\r\n                  ((devtype == FDO) && IsDeviceDeleted((PFDO_EXTENSION)DeviceObject->DeviceExtension))) {\r\n        //\r\n        // This do was supposed to have been already deleted\r\n        // so we don't support any IRPs on it\r\n        //\r\n        DebugPrint((PCMCIA_DEBUG_INFO, \"PCMCIA: Dispatch skipping Irp on deleted DO %08x MJ function %x\\n\", DeviceObject, MajorFunction));\r\n\r\n        if (MajorFunction == IRP_MJ_POWER) {\r\n            PoStartNextPowerIrp(Irp);\r\n        }\r\n        status = Irp->IoStatus.Status = STATUS_DELETE_PENDING;\r\n        IoCompleteRequest(Irp, IO_NO_INCREMENT);\r\n\r\n    } else if (((KeGetCurrentIrql() == DISPATCH_LEVEL) && (MajorFunction != IRP_MJ_POWER)) ||\r\n                  (KeGetCurrentIrql() > DISPATCH_LEVEL)) {\r\n        //\r\n        // This is too high an IRQL to handle\r\n        //\r\n\r\n        if (MajorFunction == IRP_MJ_POWER) {\r\n            PoStartNextPowerIrp(Irp);\r\n        }\r\n        status = Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;\r\n        IoCompleteRequest(Irp, IO_NO_INCREMENT);\r\n\r\n    } else {\r\n\r\n        //\r\n        // Dispatch the irp\r\n        //\r\n        status = ((*DeviceObjectDispatch[devtype][MajorFunction])(DeviceObject, Irp));\r\n\r\n    }\r\n    return status;\r\n}\r\n\r\n\n", "comment_ratio": 0.12804878048780488}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n#import \"CollectionCell.h\"\n#import \"SupplementaryView.h\"\n#import \"Celda.h\"\n\n@interface CollectionWonderViewController : UICollectionViewController <UICollectionViewDataSource, UICollectionViewDelegate>\n\n@property (strong, nonatomic) NSMutableArray *sevenWonderImages;\n@property (strong, nonatomic) NSMutableArray *descriptions;\n@property (strong, nonatomic) NSMutableArray *coordenadas;\n\n@end\n\n", "comment_ratio": 0.3333333333333333}
{"lang": "c", "code": "//\n//  NSMutableArray+Queue.h\n//  PrettyTunnel\n//\n//  Created by zhang fan on 14-8-7.\n//\n//\n\n#import <Foundation/Foundation.h>\n\n@interface NSMutableArray (Queue)\n\n- (id) head;\n- (id) dequeue;\n- (void) enqueue:(id)obj;\n\n@end\n\n", "comment_ratio": 0.3888888888888889}
{"lang": "c", "code": "#ifndef TRANSFORM_FILTER_H\n#define TRANSFORM_FILTER_H\n\n/// PROJECT\n#include <csapex/model/node.h>\n\n// clang-format off\n#include <csapex/utility/suppress_warnings_start.h>\n#include <tf/tf.h>\n#include <csapex/utility/suppress_warnings_end.h>\n// clang-format on\n\nnamespace csapex\n{\nclass TransformFilter : public csapex::Node\n{\npublic:\n    TransformFilter();\n\n    void setup(csapex::NodeModifier& node_modifier) override;\n    void setupParameters(Parameterizable& parameters) override;\n    void process() override;\n\n    std::vector<std::vector<double>> median_matrix_;\n\nprivate:\n    Input* input_transform_;\n    Output* output_transform_;\n    Output* output_text_;  // debug output for text\n\n    unsigned int filter_size_;\n    unsigned int filter_index_;\n\n    std::vector<double> out_vector_latch_;\n\n    void tfToXYZrpy(tf::Transform& in, double& x, double& y, double& z, double& roll, double& pitch, double& yaw);\n    void runFilter(tf::Transform& in_new, tf::Transform& out);\n\n    double mean(std::vector<double> in);\n};\n\n}  // namespace csapex\n#endif  // TRANSFORM_FILTER_H\n\n", "comment_ratio": 0.13636363636363635}
{"lang": "c", "code": "#pragma once\n#include \"AL/al.h\"\n#include \"AL/alc.h\"\n#include \"AL/alext.h\"\n#include \"logger/Logger.h\"\n\nnamespace Nova\n{\n\nstatic const int NUM_SOUND_SOURCES = 32;\n\n#define NOVA_CHECK_OPENAL_ERRORS\n#ifdef NOVA_CHECK_OPENAL_ERRORS\n#    define CHECK_OPENAL_ERRORS()                                                                  \\\n        {                                                                                          \\\n            checkForErrors();                                                                      \\\n        };\n#endif\n#ifndef NOVA_CHECK_OPENAL_ERRORS\n#    define CHECK_OPENAL_ERRORS()\n#endif\n\nstatic inline void checkForErrors()\n{\n    ALenum errorID = alGetError();\n    if (errorID == AL_NO_ERROR)\n    {\n        return;\n    }\n    else\n    {\n        if (errorID == AL_INVALID_NAME)\n        {\n            LOG_ERROR(\"OpenAL:Invalid name\");\n            return;\n        }\n        else if (errorID == AL_INVALID_ENUM)\n        {\n            LOG_ERROR(\"OpenAL:Invalid enum\");\n            return;\n        }\n        else if (errorID == AL_INVALID_VALUE)\n        {\n            LOG_ERROR(\"OpenAL:Invalid value\");\n            return;\n        }\n        else if (errorID == AL_INVALID_OPERATION)\n        {\n            LOG_ERROR(\"OpenAL:Invalid operation\");\n            return;\n        }\n        else if (errorID == AL_OUT_OF_MEMORY)\n        {\n            LOG_ERROR(\"OpenAL:Out of memory!\");\n            return;\n        }\n        else\n        {\n            LOG_ERROR(\"OpenAL:Unkown error\");\n            return;\n        }\n    }\n}\n} // namespace Nova\n", "comment_ratio": 0.23255813953488372}
{"lang": "c", "code": "@class NSDictionary;\n\n@interface _DECPredictionCacheResult : NSObject {\n\n\tunsigned long long _hits;\n\tunsigned long long _misses;\n\tNSDictionary* _predictions;\n\n}\n\n@property (nonatomic,readonly) unsigned long long hits;                 //@synthesize hits=_hits - In the implementation block\n@property (nonatomic,readonly) unsigned long long misses;               //@synthesize misses=_misses - In the implementation block\n@property (nonatomic,readonly) NSDictionary * predictions;              //@synthesize predictions=_predictions - In the implementation block\n-(id)initWithPredictions:(id)arg1 hits:(unsigned long long)arg2 misses:(unsigned long long)arg3 ;\n-(unsigned long long)hits;\n-(unsigned long long)misses;\n-(id)description;\n-(NSDictionary *)predictions;\n@end\n\n\n", "comment_ratio": 0.1}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n#import \"HttpdnsModel.h\"\n\n@interface HttpdnsIPv6Manager : NSObject\n\n+ (instancetype)sharedInstance;\n\n/**\n \u5f00\u542f/\u5173\u95edIPv6\u89e3\u6790\u7ed3\u679c\uff08\u57df\u540d\u89e3\u6790\u8fd4\u56deIPv6\u5730\u5740\uff09\n */\n- (void)setIPv6ResultEnable:(BOOL)enable;\n\n/**\n \u8fd4\u56de\u652f\u6301IPv6\u89e3\u6790\u7ed3\u679c\u7684\u8bf7\u6c42\u62a5\u6587\n */\n- (NSString *)assembleIPv6ResultURL:(NSString *)originURL;\n\n/**\n \u5224\u65ad\u662f\u5426\u652f\u6301\u8fd4\u56deIPv6\u89e3\u6790\u7ed3\u679c\n */\n- (BOOL)isAbleToResolveIPv6Result;\n\n@end\n\n", "comment_ratio": 0.21875}
{"lang": "c", "code": "//\n// Created by Sparks on 2021/8/24.\n//\n\n#ifndef CPLUSPLUS_ADD_H\n#define CPLUSPLUS_ADD_H\n\nint add(int , int);\n\n#endif //CPLUSPLUS_ADD_H\n\n", "comment_ratio": 0.36363636363636365}
{"lang": "c", "code": "#ifndef YAJL_HELPER_H\n#define YAJL_HELPER_H\n#include <yajl/yajl_parse.h>\n#include <yajl/yajl_gen.h>\n\n#include <stdio.h>\n\n#include \"json_value.h\"\n\nenum yajl_helper_option {\n  yajl_helper_option_use_number_strings = 1\n} ;\n\nstruct json_value_string {\n  size_t len;\n  unsigned char *s; // holds\n  unsigned char _internal[128]; // will hold stringified int / float\n};\n\n/* experimental:\n// to use less memory, json_value_string_unconvertible can be used in lieu of struct json_value_string in json_value_to_string() and json_value_to_string_dup(),\n// provided that convert_if_not_str IS ALWAYS ZERO\nstruct json_value_string_unconvertible {\n  size_t len;\n  unsigned char *s; // holds}\n;\n*/\n// json_value_to_string(): get stringified json value. if convert_if_not_str = true, will also convert numbers. otherwise, returns 0 if value is not string type\nsize_t json_value_to_string(struct json_value *value, struct json_value_string *jvs, char convert_if_not_str);\n\n// json_value_to_string_dup(): same as json_value_to_string, but replace the target with a dupe (must be free()d), or NULL if not string type and convert_if_not_str not used\nsize_t json_value_to_string_dup(struct json_value *value, char **target, char convert_if_not_str);\n\n// json_value_dbl(): return double value; set *err if value is not numeric or can't be converted to dbl\ndouble json_value_dbl(struct json_value *value, int *err);\n\nlong long json_value_long(struct json_value *value, int *err);\n\nchar json_value_truthy(struct json_value *value);\n\n#ifndef STRUCT_LIST\n#define STRUCT_LIST\nstruct struct_list {\n  struct struct_list *next;\n};\n#endif\n\nvoid *linkedlist_reverse(void *p);\n\n#ifndef LINKEDLIST_REVERSE\n#define LINKEDLIST_REVERSE(struct_name,pp,next_name) do {   \\\n    struct struct_name *current = *pp;                      \\\n    struct struct_name *prev = NULL;                        \\\n    struct struct_name *next;                               \\\n    while (current != NULL) {                               \\\n      next = current->next_name;                            \\\n      current->next_name = prev;                            \\\n      prev = current;                                       \\\n      current = next;                                       \\\n    }                                                       \\\n    *pp = prev;                                             \\\n  } while(0)\n#endif\n\nstruct yajl_helper_parse_state {\n  unsigned int level;\n  unsigned int max_level;\n\n  unsigned int level_offset; // for nested parsing. when > 0, yajl_helper_got_path() will skip the specified number of levels. use yajl_helper_level_offset() to set\n\n  char *stack;\n  char **map_keys;\n  unsigned int *item_ind;\n\n  void *data; // user-defined\n\n  int (*start_map)(struct yajl_helper_parse_state *);\n  int (*end_map)(struct yajl_helper_parse_state *);\n  int (*map_key)(struct yajl_helper_parse_state *, const unsigned char *, size_t);\n  int (*start_array)(struct yajl_helper_parse_state *);\n  int (*end_array)(struct yajl_helper_parse_state *);\n  int (*value)(struct yajl_helper_parse_state *, struct json_value *);\n};\n\nvoid yajl_helper_set_data(struct yajl_helper_parse_state *st, void *data);\nvoid *yajl_helper_data(struct yajl_helper_parse_state *st);\n\nunsigned int yajl_helper_level(struct yajl_helper_parse_state *st);\n\n// yajl_helper_level_offset(): return error\nint yajl_helper_level_offset(struct yajl_helper_parse_state *st, unsigned int offset);\n\nunsigned int yajl_helper_array_index_plus_1(struct yajl_helper_parse_state *, unsigned int offset);\nunsigned int yajl_helper_element_index_plus_1(struct yajl_helper_parse_state *st, unsigned int offset);\n\n/* json_str_dup_if_len: return a dupe of the string value, or null if none */\nunsigned char *json_str_dup_if_len(struct json_value *value);\n\n// json_str_dup_if_len_buff(): copy value into buff, if sufficient bufflen, else\n// malloc() a new string and return that. returns buff, if buff was written to, else new malloc'd mem\nunsigned char *json_str_dup_if_len_buff(struct json_value *value, unsigned char *buff, size_t bufflen);\n\nchar yajl_helper_got_path(struct yajl_helper_parse_state *st, unsigned int level, const char *path);\nchar yajl_helper_path_is(struct yajl_helper_parse_state *st, const char *path);\n\nconst char *yajl_helper_get_map_key(struct yajl_helper_parse_state *st, unsigned int offset);\n\nvoid yajl_helper_parse_state_init(\n                                  struct yajl_helper_parse_state *st,\n                                  unsigned int max_level,\n                                  int (*start_map)(struct yajl_helper_parse_state *),\n                                  int (*end_map)(struct yajl_helper_parse_state *),\n                                  int (*map_key)(struct yajl_helper_parse_state *,\n                                                 const unsigned char *, size_t),\n                                  int (*start_array)(struct yajl_helper_parse_state *),\n                                  int (*end_array)(struct yajl_helper_parse_state *),\n                                  int (*value)(struct yajl_helper_parse_state *,\n                                               struct json_value *),\n                                  void *data\n                                  );\n\nvoid yajl_helper_callbacks_init(yajl_callbacks *callbacks, char nums_as_strings);\n\nvoid yajl_helper_parse_state_free(struct yajl_helper_parse_state *st);\n\n\nsize_t json_value_default_string(struct json_value *value, const unsigned char **target,\n                                 size_t *len);\n\n// ---- string_list\n#ifndef STRING_LIST\n#define STRING_LIST\nstruct string_list {\n  struct string_list *next;\n  char *value;\n};\n#endif\n\n// add_string_to_array(): return 1 if added non-null value\nchar add_string_to_array(struct string_list **head, struct json_value *value);\n\nvoid string_list_free(struct string_list *e);\n\n/// ---- int_list\nstruct int_list {\n  struct int_list *next;\n  long long i;\n};\n\nvoid add_int_to_array(struct int_list **head, struct json_value *value);\nvoid int_list_free(struct int_list *e);\n\n#endif // ifdef YAJL_HELPER_H\n\n", "comment_ratio": 0.11038961038961038}
{"lang": "c", "code": "//\n//  FYFCollectionViewCell.h\n//  FYFTableCollectionMiddleWare\n//\n//  Created by kingstar on 2021/8/18.\n//\n\n#import <UIKit/UIKit.h>\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface FYFCollectionViewCell : UICollectionViewCell<CollectionItemProtocol>\n\n@end\n\nNS_ASSUME_NONNULL_END\n\n", "comment_ratio": 0.35294117647058826}
{"lang": "c", "code": "#import \"NSObject.h\"\n\n@class MMIAsyncTask;\n\n@protocol MMKEventLoop <NSObject>\n- (void)post:(MMIAsyncTask *)arg1;\n@end\n\n\n", "comment_ratio": 0.3333333333333333}
{"lang": "c", "code": "/* Project Euler\n** 22\n** Numbers of Names\n*/\n\n#include <stdio.h>\n#include <string.h>\n#define MAX_NAME 20\n#define NUM_NAMES 5163\n\nunsigned long long euler;\nchar names[NUM_NAMES][MAX_NAME];\nchar finalnames[NUM_NAMES][MAX_NAME];\n\nvoid alphabetSort(const char a[][MAX_NAME], char b[][MAX_NAME])\n{\n    char temp[MAX_NAME];\n    int i,j,cmp;\n    unsigned long long iterations = 0;\n\n    // copy a to b\n    for (i = 0; i < NUM_NAMES; i++){\n        strcpy(b[i], a[i]);\n    }\n\n    // in-place sort the b array\n    for(i = 0; i < NUM_NAMES; i++){\n        for(j = 0; j < NUM_NAMES-1; j++){\n\n        \tcmp = strcmp(b[j], b[j+1]);\n\n            if(cmp > 0){\n                strcpy(temp, b[j+1]);\n                strcpy(b[j+1], b[j]);\n                strcpy(b[j], temp);\n            }\n            // iterations++;\n            // printf(\"iterations = %llu\\n\", iterations); // bubble sort is bad...\n        }\n    }\n}\n\nvoid addNames(void)\n{\n\t// go through each string\n\t// add char ascii values together\n\t// multiple by position in list 1- 5163\n\n\tint i, j;\n\tint namescore = 0;\n\n\tfor(i = 0; i < NUM_NAMES; i++) {\n\t\tnamescore = 0;\n\t\tfor(j = 0; j < MAX_NAME; j++) {\n\t\t\tif(finalnames[i][j] == '\\n') { break; }\n\t\t\telse {\n\t\t\t\tnamescore += finalnames[i][j]-64;\n\t\t\t\tprintf(\"namescore for name %d = %d\\n\", i+1, namescore);\n\t\t\t}\n\t\t}\n\t\tprintf(\"Final namescore for name %d = %d\\n\", i+1, (namescore * (i+1)));\n\t\teuler += (namescore * (i+1));\n\t\tprintf(\"euler = %llu\\n\", euler);\n\t}\n}\n\nint main (int argc, char** argv)\n{\n\tint i = 0; // name counter\n\n\tFILE *fin = fopen (\"p022_names.txt\", \"r\");\n\n\t// read in names and store in names array, currently stores \\n character\n\tif (fin != NULL) {\n\t\twhile( (fgets(names[i],MAX_NAME,fin) != NULL) && (i < NUM_NAMES) ) {\n\t\t\tprintf(\"%s\\n\",names[i++]);\n\t\t}\n\tfclose (fin);\n\t}\n\n\talphabetSort(names, finalnames);\n\taddNames();\n\n\tprintf(\"final euler = %llu\\n\", euler);\n\n}\n\n", "comment_ratio": 0.10344827586206896}
{"lang": "c", "code": "#include \"../../defs.h\"\n\n// --------------------------------------------------------\n\n/*\n *\tPLL Test (self-switching)\n *\t- Enables SPI master\n *\t- Uses SPI master to internally access the housekeeping SPI\n *      - Switches PLL bypass\n *\t- Changes PLL divider\n *\n * \tTesbench mostly copied from sysctrl\n */\nvoid main()\n{\n    int i;\n\n    reg_mprj_datal = 0;\n\n    // Configure upper 16 bits of user GPIO for generating testbench\n    // checkpoints.\n\n    reg_mprj_io_31 = GPIO_MODE_MGMT_STD_OUTPUT;\n    reg_mprj_io_30 = GPIO_MODE_MGMT_STD_OUTPUT;\n    reg_mprj_io_29 = GPIO_MODE_MGMT_STD_OUTPUT;\n    reg_mprj_io_28 = GPIO_MODE_MGMT_STD_OUTPUT;\n    reg_mprj_io_27 = GPIO_MODE_MGMT_STD_OUTPUT;\n    reg_mprj_io_26 = GPIO_MODE_MGMT_STD_OUTPUT;\n    reg_mprj_io_25 = GPIO_MODE_MGMT_STD_OUTPUT;\n    reg_mprj_io_24 = GPIO_MODE_MGMT_STD_OUTPUT;\n    reg_mprj_io_23 = GPIO_MODE_MGMT_STD_OUTPUT;\n    reg_mprj_io_22 = GPIO_MODE_MGMT_STD_OUTPUT;\n    reg_mprj_io_21 = GPIO_MODE_MGMT_STD_OUTPUT;\n    reg_mprj_io_20 = GPIO_MODE_MGMT_STD_OUTPUT;\n    reg_mprj_io_19 = GPIO_MODE_MGMT_STD_OUTPUT;\n    reg_mprj_io_18 = GPIO_MODE_MGMT_STD_OUTPUT;\n    reg_mprj_io_17 = GPIO_MODE_MGMT_STD_OUTPUT;\n    reg_mprj_io_16 = GPIO_MODE_MGMT_STD_OUTPUT;\n\n    /* Apply configuration */\n    reg_mprj_xfer = 1;\n    while (reg_mprj_xfer == 1);\n\n    // Start test\n    reg_mprj_datal = 0xA0400000;\n\n    // Enable SPI master\n    // SPI master configuration bits:\n    // bits 7-0:\tClock prescaler value (default 2)\n    // bit  8:\t\tMSB/LSB first (0 = MSB first, 1 = LSB first)\n    // bit  9:\t\tCSB sense (0 = inverted, 1 = noninverted)\n    // bit 10:\t\tSCK sense (0 = noninverted, 1 = inverted)\n    // bit 11:\t\tmode (0 = read/write opposite edges, 1 = same edges)\n    // bit 12:\t\tstream (1 = CSB ends transmission)\n    // bit 13:\t\tenable (1 = enabled)\n    // bit 14:\t\tIRQ enable (1 = enabled)\n    // bit 15:\t\tConnect to housekeeping SPI (1 = connected)\n\n    reg_spimaster_config = 0xa002;\t// Enable, prescaler = 2,\n\t\t\t\t\t// connect to housekeeping SPI\n\n    // Apply stream read (0x40 + 0x03) and read back one byte \n\n    reg_spimaster_config = 0xb002;\t// Apply stream mode\n    reg_spimaster_data = 0x80;\t\t// Write 0x80 (write mode)\n    reg_spimaster_data = 0x08;\t\t// Write 0x18 (start address)\n    reg_spimaster_data = 0x01;\t\t// Write 0x01 to PLL enable, no DCO mode\n    reg_spimaster_config = 0xa102;\t// Release CSB (ends stream mode)\n\n    reg_spimaster_config = 0xb002;\t// Apply stream mode\n    reg_spimaster_data = 0x80;\t\t// Write 0x80 (write mode)\n    reg_spimaster_data = 0x11;\t\t// Write 0x11 (start address)\n    reg_spimaster_data = 0x03;\t\t// Write 0x03 to PLL output divider\n    reg_spimaster_config = 0xa102;\t// Release CSB (ends stream mode)\n\n    reg_spimaster_config = 0xb002;\t// Apply stream mode\n    reg_spimaster_data = 0x80;\t\t// Write 0x80 (write mode)\n    reg_spimaster_data = 0x09;\t\t// Write 0x09 (start address)\n    reg_spimaster_data = 0x00;\t\t// Write 0x00 to clock from PLL (no bypass)\n    reg_spimaster_config = 0xa102;\t// Release CSB (ends stream mode)\n\n    // Write checkpoint\n    reg_mprj_datal = 0xA0410000;\n\n    reg_spimaster_config = 0xb002;\t// Apply stream mode\n    reg_spimaster_data = 0x80;\t\t// Write 0x80 (write mode)\n    reg_spimaster_data = 0x12;\t\t// Write 0x12 (start address)\n    reg_spimaster_data = 0x03;\t\t// Write 0x03 to feedback divider (was 0x04)\n    reg_spimaster_config = 0xa102;\t// Release CSB (ends stream mode)\n\n    // Write checkpoint\n    reg_mprj_datal = 0xA0420000;\n\n    reg_spimaster_config = 0xb002;\t// Apply stream mode\n    reg_spimaster_data = 0x80;\t\t// Write 0x80 (write mode)\n    reg_spimaster_data = 0x11;\t\t// Write 0x11 (start address)\n    reg_spimaster_data = 0x04;\t\t// Write 0x04 to PLL output divider\n    reg_spimaster_config = 0xa102;\t// Release CSB (ends stream mode)\n\n    reg_spimaster_config = 0x2102;\t// Release housekeeping SPI\n\n    // End test\n    reg_mprj_datal = 0xA0900000;\n}\n\n\n", "comment_ratio": 0.3902439024390244}
{"lang": "c", "code": "\ufeff#pragma once\n\n// Name: SeaOfThieves, Version: 2.0.23\n\n\n/*!!DEFINE!!*/\n\n/*!!HELPER_DEF!!*/\n\n/*!!HELPER_INC!!*/\n\n#ifdef _MSC_VER\n\t#pragma pack(push, 0x01)\n#endif\n\nnamespace CG\n{\n//---------------------------------------------------------------------------\n// Parameters\n//---------------------------------------------------------------------------\n\n// Function BP_VanityChestInteraction.BP_VanityChestInteraction_C.UserConstructionScript\nstruct ABP_VanityChestInteraction_C_UserConstructionScript_Params\n{\n};\n\n}\n\n#ifdef _MSC_VER\n\t#pragma pack(pop)\n#endif\n\n", "comment_ratio": 0.15625}
{"lang": "c", "code": "//  compute_primes.h\n\n// This is the class-based solution\n\n\n#include <set>\n\n\nclass  compute_primes\n{\npublic:\n    compute_primes();\n    std::set<int> operator()(int N);\n\n    // I will not bother to implement the following\n    // functions b/c I see no use for them.\n    // Because this class has no state there's no point in\n    // say, copying an instance.\n    compute_primes(const compute_primes& cpc)           = delete; // copy ctor\n    compute_primes operator=(const compute_primes& cpc) = delete; // copy assignment operator\n    compute_primes( compute_primes&& cpc)               = delete; // move ctor\n    compute_primes operator=( compute_primes&& cpc)     = delete; // move assignment operator\nprivate:\n    void compute_non_primes(int factor, int limit );\n    int sequence();\n    int get_next_prime();\n    std::set<int> series;\n    std::set<int> non_prime;\n    int last_factor;\n    int last_sequence;\n};\n\n\n", "comment_ratio": 0.30303030303030304}
{"lang": "c", "code": "#ifndef BX_IODEV_CMOS_H\n#define BX_IODEV_CMOS_H\n\n#if BX_USE_CMOS_SMF\n#  define BX_CMOS_SMF  static\n#  define BX_CMOS_THIS theCmosDevice->\n#else\n#  define BX_CMOS_SMF\n#  define BX_CMOS_THIS this->\n#endif\n\n\nclass bx_cmos_c : public bx_cmos_stub_c {\npublic:\n  bx_cmos_c();\n  virtual ~bx_cmos_c();\n\n  virtual void init(void);\n  virtual void checksum_cmos(void);\n  virtual void reset(unsigned type);\n  virtual void save_image(void);\n  virtual void register_state(void);\n  virtual void after_restore_state(void);\n\n  virtual Bit32u get_reg(unsigned reg) {\n    return s.reg[reg];\n  }\n  virtual void set_reg(unsigned reg, Bit32u val) {\n    s.reg[reg] = val;\n  }\n  virtual time_t get_timeval() {\n    return s.timeval;\n  }\n\n  struct {\n    int     periodic_timer_index;\n    Bit32u  periodic_interval_usec;\n    int     one_second_timer_index;\n    int     uip_timer_index;\n    time_t  timeval;\n    Bit8u   cmos_mem_address;\n    bx_bool timeval_change;\n    bx_bool rtc_mode_12hour;\n    bx_bool rtc_mode_binary;\n\n    Bit8u   reg[128];\n  } s;  // state information\n\nprivate:\n  static Bit32u read_handler(void *this_ptr, Bit32u address, unsigned io_len);\n  static void   write_handler(void *this_ptr, Bit32u address, Bit32u value, unsigned io_len);\n#if !BX_USE_CMOS_SMF\n  Bit32u read(Bit32u address, unsigned io_len);\n  void   write(Bit32u address, Bit32u value, unsigned len);\n#endif\n\npublic:\n  static void periodic_timer_handler(void *);\n  static void one_second_timer_handler(void *);\n  static void uip_timer_handler(void *);\n  BX_CMOS_SMF void periodic_timer(void);\n  BX_CMOS_SMF void one_second_timer(void);\n  BX_CMOS_SMF void uip_timer(void);\nprivate:\n  BX_CMOS_SMF void update_clock(void);\n  BX_CMOS_SMF void update_timeval(void);\n  BX_CMOS_SMF void CRA_change(void);\n};\n\n#endif\n\n", "comment_ratio": 0.26804123711340205}
{"lang": "c", "code": "#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include \"Practical.h\"\r\n#include <unistd.h>\r\n#include\t<time.h>\r\n\r\nstatic const int MAXPENDING = 5; // Maximum outstanding connection requests\r\n\r\nint main(int argc, char *argv[]) {\r\n\ttime_t\tticks;  //variable to hold date and time data\r\n\tchar sendbuffer[BUFSIZE]; // Buffer for sending data to the client \r\n\r\n\tif (argc != 2) // Test for correct number of arguments\r\n\t\tDieWithUserMessage(\"Parameter(s)\", \"<Server Port>\");\r\n\r\n\tin_port_t servPort = atoi(argv[1]); // First arg:  local port\r\n\r\n\t\t// Create socket for incoming connections\r\n\tint servSock; // Socket descriptor for server\r\n\tif ((servSock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0)\r\n\t\tDieWithSystemMessage(\"socket() failed\");\r\n\r\n\t// Construct local address structure\r\n\tstruct sockaddr_in servAddr;                  // Local address\r\n\tmemset(&servAddr, 0, sizeof(servAddr));       // Zero out structure\r\n\tservAddr.sin_family = AF_INET;                // IPv4 address family\r\n\tservAddr.sin_addr.s_addr = htonl(INADDR_ANY); // Any incoming interface\r\n\tservAddr.sin_port = htons(servPort);          // Local port\r\n\r\n\t// Bind to the local address\r\n\tif (bind(servSock, (struct sockaddr*) &servAddr, sizeof(servAddr)) < 0)\r\n\t\tDieWithSystemMessage(\"bind() failed\");\r\n\r\n\t// Mark the socket so it will listen for incoming connections\r\n\tif (listen(servSock, MAXPENDING) < 0)\r\n\t\tDieWithSystemMessage(\"listen() failed\");\r\n\r\n\tfor (;;) { // Infinite for loop; runs forever\r\n    \r\n    // Wait for a client to connect\r\n    int clntSock = accept(servSock, (struct sockaddr *) NULL, NULL);\r\n    if (clntSock < 0)\r\n      DieWithSystemMessage(\"accept() failed\");\r\n\r\n    // clntSock is connected to a client!\r\n    snprintf(sendbuffer, sizeof(sendbuffer), \"%.24s\\r\\n\", ctime(&ticks)); //Create data and time string in outgoing buffer\r\n    ssize_t numBytesSent = send(clntSock, sendbuffer, strlen(sendbuffer), 0); //Send date and time string to the client \r\n    if (numBytesSent < 0)\r\n      DieWithSystemMessage(\"send() failed\");\r\n\r\n\tclose(clntSock); // Close client socket\r\n\r\n  }  //end infinite for loop \r\n  // NOT REACHED\r\n}\n", "comment_ratio": 0.38333333333333336}
{"lang": "c", "code": "#import <UIKit/UIView.h>\n\n@class T1StatusBodyTextView, TFNAsymmetricalCornerView, TFNComposableViewLayoutState, TFNTwitterAccount, TFSTwitterScribeContext, UIImageView, UILabel, UITapGestureRecognizer;\n@protocol T1StatusBodyTextViewDelegate, T1StatusViewModel;\n\n@interface T1StatusNewsCameraAttachmentOverlayView : UIView\n{\n    TFNComposableViewLayoutState *_layoutState;\n    unsigned long long _statusOptions;\n    unsigned long long _statusDisplayTextOptions;\n    TFSTwitterScribeContext *_scribeContext;\n    TFNAsymmetricalCornerView *_locationBackgroundView;\n    UILabel *_locationLabel;\n    UIImageView *_locationBadgeImageView;\n    TFNAsymmetricalCornerView *_statusTextBackgroundView;\n    T1StatusBodyTextView *_statusBodyTextView;\n    id <T1StatusViewModel> _viewModel;\n    TFNTwitterAccount *_account;\n    UITapGestureRecognizer *_locationTapRecognizer;\n}\n\n+ (double)chyronViewHeightForViewModel:(id)arg1 options:(unsigned long long)arg2 displayTextOptions:(unsigned long long)arg3 width:(double)arg4 layoutMetrics:(id)arg5;\n@property(readonly, nonatomic) UITapGestureRecognizer *locationTapRecognizer; // @synthesize locationTapRecognizer=_locationTapRecognizer;\n@property(readonly, nonatomic) TFNTwitterAccount *account; // @synthesize account=_account;\n@property(readonly, nonatomic) id <T1StatusViewModel> viewModel; // @synthesize viewModel=_viewModel;\n@property(readonly, nonatomic) T1StatusBodyTextView *statusBodyTextView; // @synthesize statusBodyTextView=_statusBodyTextView;\n@property(readonly, nonatomic) TFNAsymmetricalCornerView *statusTextBackgroundView; // @synthesize statusTextBackgroundView=_statusTextBackgroundView;\n@property(readonly, nonatomic) UIImageView *locationBadgeImageView; // @synthesize locationBadgeImageView=_locationBadgeImageView;\n@property(readonly, nonatomic) UILabel *locationLabel; // @synthesize locationLabel=_locationLabel;\n@property(readonly, nonatomic) TFNAsymmetricalCornerView *locationBackgroundView; // @synthesize locationBackgroundView=_locationBackgroundView;\n@property(copy, nonatomic) TFSTwitterScribeContext *scribeContext; // @synthesize scribeContext=_scribeContext;\n@property(readonly, nonatomic) unsigned long long statusDisplayTextOptions; // @synthesize statusDisplayTextOptions=_statusDisplayTextOptions;\n@property(readonly, nonatomic) unsigned long long statusOptions; // @synthesize statusOptions=_statusOptions;\n@property(retain, nonatomic) TFNComposableViewLayoutState *layoutState; // @synthesize layoutState=_layoutState;\n- (void).cxx_destruct;\n- (void)_t1_locationTapped:(id)arg1;\n- (void)setViewModel:(id)arg1 options:(unsigned long long)arg2 displayTextOptions:(unsigned long long)arg3 account:(id)arg4;\n@property(nonatomic) __weak id <T1StatusBodyTextViewDelegate> statusBodyTextViewDelegate;\n- (void)layoutSubviews;\n- (id)hitTest:(struct CGPoint)arg1 withEvent:(id)arg2;\n- (id)initWithCoder:(id)arg1;\n- (id)initWithFrame:(struct CGRect)arg1;\n\n@end\n\n\n", "comment_ratio": 0.3269230769230769}
{"lang": "c", "code": "#pragma once\n\n#include <memory>\n\nnamespace INF4215_TP3\n{\n    namespace Utility\n    {\n        class DisjointSet\n        {\n        private:\n            std::unique_ptr<size_t[]> m_aGroups;\n            std::unique_ptr<size_t[]> m_aRanks;\n            size_t m_nSetCount;\n\n        public:\n            // Create an empty union find data structure with N isolated sets\n            DisjointSet(size_t nSize)\n                : m_aGroups(new size_t[nSize]),\n                m_aRanks(new size_t[nSize]),\n                m_nSetCount(nSize)\n            {\n                for(size_t i = 0; i < nSize; ++i)\n                {\n                    m_aGroups[i] = i;\n                    m_aRanks[i] = 1;\n                }\n            }\n\n            // Return the id of component corresponding to object p.\n            size_t find(size_t p)\n            {\n                size_t root = p;\n\n                // Find the root\n                while (root != m_aGroups[root])\n                {\n                    root = m_aGroups[root];\n                }\n\n                // Flatten hierarchy\n                while (p != root)\n                {\n                    size_t newp = m_aGroups[p];\n                    m_aGroups[p] = root;\n                    p = newp;\n                }\n\n                return root;\n            }\n\n            // Replace sets containing x and y with their union.\n            void merge(int x, int y)\n            {\n                const size_t i = find(x);\n                const size_t j = find(y);\n                if (i == j) return;\n\n                // make smaller root point to larger one\n                if (m_aRanks[i] < m_aRanks[j])\n                {\n                    m_aGroups[i] = j;\n                    m_aRanks[j] += m_aRanks[i];\n                }\n                else\n                {\n                    m_aGroups[j] = i;\n                    m_aRanks[i] += m_aRanks[j];\n                }\n\n                // We have merged two sets. There are now less sets\n                --m_nSetCount;\n            }\n            // Are objects x and y in the same set?\n            bool connected(int x, int y)\n            {\n                return find(x) == find(y);\n            }\n            // Return the number of disjoint sets.\n            size_t count()\n            {\n                return m_nSetCount;\n            }\n        };\n    }\n}\n\n", "comment_ratio": 0.10344827586206896}
{"lang": "c", "code": "/* <add id=\"microwire_interface_t\">\n   <insert-until text=\"// END INTERFACE microwire\"/>\n   </add> */\n\n#define MICROWIRE_INTERFACE \"microwire\"\n\ntypedef struct {\n        void (*set_cs)(conf_object_t *obj, int cs);\n        void (*set_sk)(conf_object_t *obj, int sk);\n        void (*set_di)(conf_object_t *obj, int di);\n        int  (*get_do)(conf_object_t *obj);\n} microwire_interface_t;\n\n// END INTERFACE microwire\n\n", "comment_ratio": 0.13333333333333333}
{"lang": "c", "code": "#ifndef TXREF_ENCODEOPRETURNDATA_H\n#define TXREF_ENCODEOPRETURNDATA_H\n\n#include <string>\n\n// The data returned by OP_RETURN needs to be UTF-8, hex-encoded. Assuming UTF-8 for now.\nstd::string encodeOpReturnData(const std::string &data);\n\n#endif //TXREF_ENCODEOPRETURNDATA_H\n\n", "comment_ratio": 0.2}
{"lang": "c", "code": "#pragma once\n\n#include <jude/jude_core.h>\n#include <string>\n#include <functional>\n#include <optional>\n\n#ifdef __GNUC__\n#define CHECK_FORMAT(formatParamIndex,argsBeginParamIndex) __attribute__ ((format (printf, formatParamIndex,argsBeginParamIndex)))\n#else\n#define CHECK_FORMAT(formatParamIndex,argsBeginParamIndex)\n#endif\n\nnamespace jude \n{\n   class InputStreamInterface\n   {\n      size_t m_totalBytesRead{ 0 }; // total bytes read\n      size_t m_lastBytesRead{ (size_t)-1 };  // bytes read in last call to Read()\n      jude_istream_t m_istream;\n\n      static size_t ReadCallback(void* user_data, uint8_t* data, size_t length);\n\n   public:\n      InputStreamInterface(const jude_decode_transport_t* transport = jude_decode_transport_json);\n\n      // Use this to allow input stream to be buffered using the given buffer\n      void SetInputBuffer(char* buffer, size_t bufferLen);\n      void SetInputBuffer(std::vector<char>& buffer) { SetInputBuffer(buffer.data(), buffer.capacity()); }\n      void ClearBuffer();\n      \n      // Use this to set the type of decoding transport that you want - e.g. JSON, protobuf, etc\n      void SetInputDecoding(const jude_decode_transport_t* transport);\n\n      // The low level stream is used by the C level api\n      jude_istream_t* GetLowLevelInputStream() { return &m_istream; }\n\n      size_t GetTotalBytesRead() const { return m_totalBytesRead; }\n      size_t GetLastBytesRead() const { return m_lastBytesRead; }\n      virtual size_t Read(uint8_t* data, size_t length);\n\n      bool HasInputError() const { return m_istream.has_error; }\n      void SetInputErrorMsg(const char* error) { jude_istream_error(&m_istream, error); }\n      const char * GetInputErrorMsg() const { return jude_istream_get_error(&m_istream); }\n\n      bool IsEof() const\n      {\n         return HasInputError() || GetLastBytesRead() == 0;\n      }\n\n      // Convenience functions\n      size_t Read(char *buffer, size_t maxBytesToRead) { return Read(reinterpret_cast<uint8_t*>(buffer), maxBytesToRead); }\n      size_t Read(char& datum) { return Read(&datum, 1); }\n      size_t Read(uint8_t &datum) { return Read(reinterpret_cast<char&>(datum)); }\n      size_t Read(int8_t &datum) { return Read(reinterpret_cast<char&>(datum)); }\n      size_t Read(std::vector<uint8_t>& destination); // destination must have some capacity\n      size_t ReadLineN(size_t maxBytesToRead, std::string& line, char delimiter = 0);\n      size_t ReadLine(std::string& line, char delimiter = 0); // up to line ending\n      size_t ReadWord(std::string& line, char delimiter)\n      {\n         return ReadLine(line, delimiter);\n      }\n\n      InputStreamInterface& operator >> (std::string& data)\n      {\n         // NOTE: Reading a string will read until the next space or newline\n         // If you want to read an entire line use the ReadLine function\n         ReadWord(data, ' ');\n         return *this;\n      }\n\n      template<typename T>\n      InputStreamInterface& operator >> (T& data)\n      { \n         Read(data);\n         return *this;\n      }\n\n      operator bool() const\n      {\n         return !HasInputError();\n      }\n\n   protected:\n      // To implement:\n      // Read up to 'length' bytes from the stream and store them in the memory pointed to by data\n      // Return the number of bytes successfully read, 0 on EOF / error\n      virtual size_t ReadImpl(uint8_t* data, size_t length) = 0;\n   };\n\n   class RomInputStream : public InputStreamInterface\n   {\n      const uint8_t* m_data;\n      size_t m_bytesLeft;\n      char m_buffer[128]; // without a buffer we can't log descriptive errors so put a small one here always\n\n   protected:\n      virtual size_t ReadImpl(uint8_t* data, size_t length) override;\n\n   public:\n      explicit RomInputStream(const char* data); // uses strlen\n      RomInputStream(const char* data, size_t length); // truncate at 'length' bytes\n      RomInputStream(const uint8_t* data, size_t length); // truncate at 'length' bytes\n      explicit RomInputStream(const std::string& data) : RomInputStream(data.c_str(), data.length()) {}\n\n      void SetConstData(const uint8_t *data, size_t length);\n      void SetConstData(const char *data) { SetConstData(reinterpret_cast<const uint8_t*>(data), strlen(data)); }\n      void SetConstData(const char *data, size_t length) { SetConstData((uint8_t*)data, length); }\n      void SetConstData(const std::string& s) { SetConstData(s.c_str(), s.length()); }\n      size_t GetBytesLeft() const { return m_bytesLeft; }\n\n\n   };\n\n   class OutputStreamInterface\n   {\n      static constexpr size_t DefaultWriteChunkSize = 1024;\n      jude_ostream_t m_ostream;\n\n      static size_t WriteCallback(void* user_data, const uint8_t* data, size_t length);\n\n   public:\n      OutputStreamInterface(const jude_encode_transport_t* transport = jude_encode_transport_json);\n\n      // Use this to allow output stream to be buffered using the given buffer\n      void SetOutputBuffer(char* buffer, size_t bufferLen);\n      void SetOutputBuffer(std::vector<char>& buffer) { SetOutputBuffer(buffer.data(), buffer.capacity()); }\n\n      // Use this to set the type of encoding that you want - e.g. JSON, protobuf, etc\n      void SetOutputEncoding(const jude_encode_transport_t* transport);\n\n      // The low level stream is used by the C level api\n      jude_ostream_t* GetLowLevelOutputStream() { return &m_ostream; }\n\n      size_t GetTotalBytesWritten() const { return m_ostream.bytes_written; }\n      \n      size_t Write(const uint8_t * data, size_t length);\n      size_t Print(const char* text);\n      size_t Printf(size_t max, const char* format, ...) CHECK_FORMAT(3,4);\n\n      virtual bool Flush(); // flush any buffered output to underlying stream - you can override this if you need to perform special operations\n\n      bool HasOutputError() const { return m_ostream.has_error; }\n      void SetOutputErrorMsg(const char* error) { jude_ostream_error(&m_ostream, error); }\n      const char* GetOutputErrorMsg() const { return jude_ostream_get_error(&m_ostream); }\n\n      // Convenience functions\n      size_t Write(uint8_t datum) { return Write(&datum, 1); }\n      size_t Write(char datum) { return Write(static_cast<uint8_t>(datum)); }\n      size_t Write(const char *data) { return Write(reinterpret_cast<const uint8_t*>(data), strlen(data)); }\n      size_t Write(const char *data, size_t length) { return Write(reinterpret_cast<const uint8_t*>(data), length); }\n      size_t Write(const std::string &data) { return Write(reinterpret_cast<const uint8_t*>(data.c_str()), data.length()); }\n      size_t Write(const std::vector<uint8_t> &data) { return Write(data.data(), data.size()); }\n      \n      template <class ... Args>\n      size_t WriteFormat(size_t maxBytesToWrite, const char *format, Args ... args)\n      {\n         return Printf(maxBytesToWrite, format, args...);\n      }\n\n      size_t Pipe(InputStreamInterface &inputStream,\n                         size_t chunkSizeBytes = DefaultWriteChunkSize, \n                         std::optional<size_t> expectedInputSize = std::nullopt,\n                         std::function<void(size_t)> progressCallback = nullptr);\n      \n      template<typename T> \n      OutputStreamInterface& operator << (T data)\n      { \n         Write(data);\n         return *this;\n      }\n\n      operator bool() const\n      {\n         return !HasOutputError();\n      }\n\n   protected:\n      // To implement:\n      // Write 'length' bytes from the memory pointed to by data\n      // Return the number of bytes successfully written, -1 on error\n      virtual size_t WriteImpl(const uint8_t * data, size_t length) = 0;\n\n   public:\n      ///////////////////////////////////////////////////////////////////////////////\n      // Protobuf backwards compatibility\n      struct OutputStreamResult\n      {\n         OutputStreamInterface& stream;\n         operator bool() const { return !stream.HasOutputError(); }\n         auto GetError() { return stream.GetOutputErrorMsg(); }\n         OutputStreamResult(OutputStreamInterface& _this) : stream(_this) {}\n      };\n      auto GetWriteResult() { return OutputStreamResult(*this); }\n      ///////////////////////////////////////////////////////////////////////////////\n\n   };\n\n   class SizingStream : public OutputStreamInterface\n   {\n   public:\n      virtual size_t WriteImpl(const uint8_t*, size_t length) override { return length; }\n   };\n\n   class StringOutputStream : public OutputStreamInterface\n   {\n      std::string  m_output;\n      size_t       m_maxCapacity;  // max we send in one go\n\n   public:\n      StringOutputStream(size_t maxCapacity = 0xFFFF, size_t initialBufferSize = 0);\n      virtual size_t WriteImpl(const uint8_t* data, size_t length) override;\n      const std::string& GetString() { return m_output; }\n      void Clear() { m_output = \"\"; }\n   };\n\n   class FixedBufferOutputStream : public OutputStreamInterface\n   {\n      uint8_t  *m_output;\n      size_t    m_size;\n      const size_t    m_maxCapacity;  // max we send in one go\n\n   public:\n      FixedBufferOutputStream(char    *buffer, size_t maxCapacity);\n      FixedBufferOutputStream(uint8_t *buffer, size_t maxCapacity);\n\n   protected:\n      virtual size_t WriteImpl(const uint8_t* data, size_t length) override;\n   };\n\n   class StringInputStream : public RomInputStream\n   {\n      std::string m_input;\n\n   public:\n      StringInputStream(std::string&& input)\n         : RomInputStream(input.data(), input.length())\n         , m_input(std::move(input))\n      {}\n   };\n\n   class StreamInterface : public InputStreamInterface, public OutputStreamInterface\n   {};\n\n   using EmbeddedJSONWriter = std::function< void(jude::OutputStreamInterface&) >;\n}\n\n", "comment_ratio": 0.11152416356877323}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n\n@class MBViewController;\n\n@interface MBAppDelegate : UIResponder <UIApplicationDelegate>\n\n@property (strong, nonatomic) UIWindow *window;\n\n@property (strong, nonatomic) MBViewController *viewController;\n\n@end\n\n", "comment_ratio": 0.35}
{"lang": "c", "code": "#ifdef BUILD_MODULE_MATH\n\n// ZJS includes\n#include \"zjs_util.h\"\n\nu32_t random_generator()\n{\n    // pseudorandom number generator using Xorshift\n    // https://en.wikipedia.org/wiki/Xorshift\n    // https://de.wikipedia.org/wiki/Xorshift\n    static uint32_t x = 123456789;\n    static uint32_t y = 362436069;\n    static uint32_t z = 521288629;\n    static uint32_t w = 88675123;\n    uint32_t t;\n    t = x ^ (x << 11);\n    x = y; y = z; z = w;\n    return w = w ^ (w >> 19) ^ (t ^ (t >> 8));\n}\n\nstatic ZJS_DECL_FUNC(math_random)\n{\n    u32_t next = random_generator();\n    // normalize to 0 - 1.0\n    double normalized = (double)next / UINT32_MAX;\n    return jerry_create_number(normalized);\n}\n\nvoid zjs_math_init(void)\n{\n    ZVAL math = zjs_create_object();\n    zjs_obj_add_function(math, \"random\", math_random);\n\n    // initialize the Math object\n    ZVAL global_obj = jerry_get_global_object();\n    zjs_set_property(global_obj, \"MathStubs\", math);\n}\n\nvoid zjs_math_cleanup()\n{\n}\n\n#endif  // BUILD_MODULE_MATH\n\n", "comment_ratio": 0.17777777777777778}
{"lang": "c", "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/stat.h>\n#include <time.h>\n#include <pthread.h>\n\n#include \"server.h\"\n#include \"config.h\"\n#include \"cmd.h\"\n#include \"sync.h\"\n#include \"error.h\"\n#include \"extra.h\"\n\n// server\nstatic int sd;\nstatic int run;\n\n// client session\nint *sdlist[PSSCLI_SERVER_SOCK_MAX]; // maps socket descriptors to socket descriptor pointer values\nstatic int cursor;\n\n// sync\nstatic pthread_rwlock_t pt_rw;\nstatic pthread_t pt_cmd[PSSCLI_SERVER_SOCK_MAX];\nstatic pthread_t pt_reply;\nextern pthread_mutex_t pt_lock_queue;\nextern pthread_cond_t pt_cond_reply;\nextern pthread_cond_t pt_cond_write;\n\nstatic int running();\n\nint psscli_server_status() {\n\tif (!run) {\n\t\treturn PSSCLI_SERVER_STATUS_IDLE;\n\t}\n\treturn PSSCLI_SERVER_STATUS_RUNNING;\n}\n\n// handle socket input command\n// returns null if invalid input\npsscli_cmd *parse_raw(psscli_cmd *cmd) {\n\tchar b[1024];\n\n\tswitch (cmd->code) {\n\t\tcase PSSCLI_CMD_BASEADDR:\n\t\t\treturn cmd;\n\t\t\tbreak;\n\t\tcase PSSCLI_CMD_GETPUBLICKEY:\n\t\t\treturn cmd;\n\t\t\tbreak;\n//\t\tcase PSSCLI_CMD_SETPEERPUBLICKEY:\n//\t\t\t// keylen+key 132 bytes + topiclen+topic 10 bytes + addrlen 2 bytes = 144 bytes\n//\t\t\tl = recv(s2, &b, 144, MSG_DONTWAIT);\n//\n//\t\t\t// all fields have length prefixes. Get each one\n//\t\t\tsl[0] = (short*)&b;\n//\t\t\tif (!is_le()) {\n//\t\t\t\tint16_rev(sl[0]);\n//\t\t\t}\n//\t\t\tsl[1] = (short*)&b[2+(*sl[0])];\n//\t\t\tif (!is_le()) {\n//\t\t\t\tint16_rev(sl[1]);\n//\t\t\t}\n//\t\t\tsl[2] = (short*)&b[4+(*sl[0])+(*sl[1])];\n//\t\t\tif (!is_le()) {\n//\t\t\t\tint16_rev(sl[2]);\n//\t\t\t}\n//\n//\t\t\t// check that we have enough data for required fields\n//\t\t\tif (l < 144 || *sl[0] != 130 || *sl[1] != 8) {\n//\t\t\t\tmemset(&b, (char)PSSCLI_EINVAL, 1);\n//\t\t\t\terrno = EPROTO;\n//\t\t\t\tsend(s2, &b, 1, 0);\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\t\t\t\n//\t\t\t// allocate three vars for this command\n//\t\t\tif (psscli_cmd_alloc(cmd, 3) == NULL) {\n//\t\t\t\tmemset(&b, (char)PSSCLI_EMEM, 1);\n//\t\t\t\terrno = ENOMEM;\n//\t\t\t\tsend(s2, &b, 1, 0);\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// allocate and set publickey\n//\t\t\t*cmd->values = malloc(sizeof(char)*(*sl[0])+3);\n//\t\t\tstrcpy(*cmd->values, \"0x\");\n//\t\t\tmemcpy(*cmd->values+2, &b[2], *sl[0]);\n//\t\t\tmemset(*cmd->values+2+(*sl[0]), 0, 1);\n//\n//\t\t\t// allocate and set topic\n//\t\t\t*(cmd->values+1) = malloc(sizeof(char)*(*sl[1])+3);\n//\t\t\tstrcpy(*(cmd->values+1), \"0x\");\n//\t\t\tmemcpy(*(cmd->values+1)+2, &b[4+(*sl[0])], *sl[1]);\n//\t\t\tmemset(*(cmd->values+1)+2+(*sl[1]), 0, 1);\n//\n//\t\t\t// if optional address is present, allocate, retrieve and set it\n//\t\t\tif (*sl[2] > 0) {\n//\t\t\t\tl = recv(s2, &b, *sl[2], MSG_DONTWAIT);\n//\t\t\t\t*(cmd->values+2) = malloc(sizeof(char)*(*sl[2])+3);\n//\t\t\t\tstrcpy(*(cmd->values+2), \"0x\");\n//\t\t\t\tmemcpy(*(cmd->values+2)+2, &b, *sl[2]);\n//\t\t\t\tmemset(*(cmd->values+2)+2+(*sl[2]), 0, 1);\n//\t\t\t}\n//\n//\t\t\t// tell the outgoing queue handler about the new pending command\n//\t\t\tb[0] = (unsigned char)PSSCLI_CMD_SETPEERPUBLICKEY;\n//\t\t\tl = write(psscli_ws.notify[1], &b, 1);\n//\n//\t\t\t// tell the client all is well\n//\t\t\tsend(s2, &n, 1, 0);\n//\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfree(*(cmd->values));\n\t\t\tpsscli_cmd_free(cmd);\t\n\t\t\treturn NULL;\n\t}\n}\n// thread handling a single socket connection. Adds received commands to the commands queue\nstatic void *process_input(void *arg) {\n\tint r;\n\tint c;\n\tint i;\n\tint lsd;\n\tchar b[PSSCLI_SERVER_SOCK_BUFFERSIZE];\n\tpsscli_cmd *cmd;\n\n\tpthread_rwlock_wrlock(&pt_rw);\n\tlsd = *((int*)arg);\n\tpthread_rwlock_unlock(&pt_rw);\n\t\n\twhile (running()) {\n\t\tif ((c = recv(lsd, &b, PSSCLI_SERVER_SOCK_BUFFERSIZE, 0)) <= 0) {\n\t\t\tfprintf(stderr, \"input error on %d (%d)\\n\", lsd, errno);\n\t\t\tshutdown(lsd, SHUT_RDWR);\n\t\t\tclose(lsd);\n\t\t\tbreak;\n\t\t}\n\n\t\tfprintf(stderr, \"server got: \");\n\t\tfor (i = 0; i < c; i++) {\n\t\t\tfprintf(stderr, \"%02x\", b[i]);\n\t\t}\n\t\tfprintf(stderr, \"\\n\");\n\n\t\tpsscli_cmd_alloc(&cmd, 0);\n\n\t\t// lock global vars for copy\n\t\tpthread_mutex_lock(&pt_lock_state);\n\t\tcmd->id = cursor;\n\t\tcmd->sdptr = (int*)arg;\n\t\tcmd->status = PSSCLI_STATUS_LOCAL;\n\t\tpthread_mutex_unlock(&pt_lock_state);\n\n\t\t// \n\t\tcmd->code = (unsigned char)*b;\n\t\tcmd->sd = lsd;\n\t\tmemcpy(cmd->src, b+1, c-1);\n\t\n\t\tcmd = parse_raw(cmd);\n\t\tif (cmd == NULL) {\n\t\t\tfprintf(stderr, \"parse error on data from %d (%d)\\n\", lsd);\n\t\t\tpsscli_cmd_free(cmd);\n\t\t\tshutdown(lsd, SHUT_RDWR);\n\t\t\tclose(lsd);\n\t\t\tbreak;\n\t\t}\n\n\t\tpthread_mutex_lock(&pt_lock_queue);\n\t\tif (psscli_cmd_queue_add(PSSCLI_QUEUE_OUT, cmd) == -1) {\n\t\t\tpthread_mutex_unlock(&pt_lock_queue);\n\t\t\tfprintf(stderr, \"cmd queue add fail, id %d\\n\", cmd->id);\n\t\t\tpsscli_cmd_free(cmd);\n\t\t\tshutdown(lsd, SHUT_RDWR);\n\t\t\tclose(lsd);\n\t\t\tbreak;\n\t\t} \n\t\tpthread_mutex_unlock(&pt_lock_queue);\n\t\tpthread_cond_signal(&pt_cond_write);\n\t}\n\n\tpthread_rwlock_wrlock(&pt_rw);\n\tsdlist[lsd] = NULL;\n\tpthread_rwlock_unlock(&pt_rw);\n\tfprintf(stderr, \"exit input process on %d\\n\", lsd);\n\tpthread_exit(NULL);\n\treturn NULL;\n}\n\n// when triggered polls the response queue and relays ready replies to the respective socket\nPRIVATE void *process_reply(void *arg) {\n\tint r;\n\tint c;\n\tint lsd;\n\tpsscli_cmd *cmd;\n\tpsscli_cmd *p;\n\n\t//pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);\n\n\tfprintf(stderr, \"starting process reply thread\\n\");\n\twhile (running()) {\n\t\tpthread_mutex_lock(&pt_lock_queue);\n\t\tpthread_cond_wait(&pt_cond_reply, &pt_lock_queue);\n\t\tfprintf(stderr, \"reply wakeup\\n\");\n\t\tif (!running()) {\n\t\t\tpthread_mutex_unlock(&pt_lock_queue);\n\t\t\tfprintf(stderr, \"reply process thread exiting\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tp = psscli_cmd_queue_next(PSSCLI_QUEUE_IN);\n\t\tif (p == NULL) {\n\t\t\tpthread_mutex_unlock(&pt_lock_queue);\n\t\t\tcontinue;\n\t\t}\n\t\tpsscli_cmd_alloc(&cmd, 1);\n\t\tpsscli_cmd_copy(cmd, p);\n\t\tpsscli_cmd_free(p); // this frees the command copy in the in queue\n\t\tpthread_mutex_unlock(&pt_lock_queue);\n\n\t\tpthread_rwlock_rdlock(&pt_rw);\n\t\tif (sdlist[cmd->sd] != cmd->sdptr) {\n\t\t\tpsscli_cmd_free(cmd);\n\t\t\tpthread_rwlock_unlock(&pt_rw);\n\t\t\tfprintf(stderr, \"stale sd %d (%p) in reply id %d\\n\", cmd->sd, cmd->sdptr, cmd->id);\n\t\t\tbreak;\n\t\t}\n\t\tpthread_rwlock_unlock(&pt_rw);\n\n\t\tfprintf(stderr, \"got response id %d: %s\\n\", cmd->id, *(cmd->values));\n\n\t\tif ((c = send(cmd->sd, *(cmd->values), sizeof(*(cmd->values)), 0)) <= 0) {\n\t\t\tfprintf(stderr, \"failed reply socket send on %d (%d)\\n\", cmd->sd, errno);\n\t\t}\n\t\tpsscli_cmd_free(cmd); // this frees the local copy of the cmd\n\t}\n\n\tpthread_exit(NULL);\n\treturn NULL;\n}\n\nint psscli_server_start() {\n\tint l;\n\tunsigned int sd2;\n\tstruct sockaddr_un sl, sr;\n\n\tstruct stat fstat;\n\n\trun = 0;\n\n\tif(!stat(conf.sock, &fstat)) {\n\t\tunlink(conf.sock);\n\t}\n\tif ((sd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {\n\t\tsprintf(psscli_error_string, \"socket create (%d): %s\", errno, conf.sock);\n\t\treturn PSSCLI_ESOCK;\n\t}\n\n\tsl.sun_family = AF_UNIX;\n\tstrcpy(sl.sun_path, conf.sock);\n\tl = strlen(sl.sun_path) + sizeof(sl.sun_family);\n\tif ((bind(sd, (struct sockaddr*)&sl, l)) == -1) {\n\t\tsprintf(psscli_error_string, \"socket bind on %s: %d\", conf.sock, errno);\n\t\treturn PSSCLI_ESOCK;\n\t}\n\n\tlisten(sd, 5);\n\n\trun = 1; // we have single thread still\n\n\tpthread_create(&pt_reply, NULL, process_reply, NULL);\n\n\tl = sizeof(struct sockaddr_un);\n\twhile (sd2 = accept(sd, (struct sockaddr*)&sr, &l)) {\n\t\tint r;\n\n\t\tif (!psscli_running()) {\n\t\t\tbreak;\n\t\t} else if (sd2 == -1) {\n\t\t\tfprintf(stderr, \"socket %d invalid errno %d, exiting\\n\", sd, errno);\n\t\t\tbreak;\n\t\t}\n\n\t\t// copy the socket reference for reply\n\t\tpthread_rwlock_wrlock(&pt_rw);\n\t\tsdlist[sd2] = &sd2;\n\t\tpthread_rwlock_unlock(&pt_rw);\n\n\t\tfprintf(stderr, \"sock connect %d\\n\", sd2);\n\n#ifdef TESTING\n\t\tint p;\n\t\tif (send(sd2, &sdlist[sd2], sizeof(int*), 0) == -1) {\n\t\t\tr = PSSCLI_ESYNC;\n\t\t\tsprintf(psscli_error_string, \"failed to send sd ptr in test mode\");\n\t\t}\n\t\tif (send(sd2, &sd2, sizeof(int), 0) == -1) {\n\t\t\tr = PSSCLI_ESYNC;\n\t\t\tsprintf(psscli_error_string, \"failed to send sd number in test mode\");\n\t\t}\n#endif\n\n\t\tif (pthread_create(&pt_cmd[r], NULL, process_input, (void*)sdlist[sd2])) { \n\t\t\tr = PSSCLI_ESYNC;\n\t\t\tfprintf(stderr, \"failed to start input processing thread (%d)\\n\", errno);\n\t\t\tif (send(sd2, (unsigned char*)&r, 1, 0) == -1) {\n\t\t\t\tsprintf(psscli_error_string, \"socket write fail (input processing) on %d (%d)\\n\", sd2, errno);\n\t\t\t}\n\t\t}\n\t\tpthread_mutex_lock(&pt_lock_state);\n\t\tr = cursor++;\n\t\tpthread_mutex_unlock(&pt_lock_state);\n\t}\n\n\tfprintf(stderr, \"server shutting down\\n\");\n\tpthread_cond_signal(&pt_cond_reply);\n\n\tpthread_join(pt_reply, NULL);\n\n\treturn PSSCLI_EOK;\n}\n\nstatic int running() {\n\tint r;\n\n\tpthread_mutex_lock(&pt_lock_state);\n\tr = run;\n\tpthread_mutex_unlock(&pt_lock_state);\n\n\treturn r;\n}\n\nvoid psscli_server_stop() {\n\tpthread_mutex_lock(&pt_lock_state);\n\trun = 0;\n\tif (shutdown(sd, SHUT_RDWR)) {\n\t\tfprintf(stderr, \"failed socket shutdown: %d\\n\", errno);\n\t}\n\tclose(sd);\n\tpthread_mutex_unlock(&pt_lock_state);\n\n\treturn;\n}\n\n", "comment_ratio": 0.22126436781609196}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface CDUserInfoManager : NSObject\n\n@property (nonatomic, strong) CDUserInfoModel *userInfo;\n@property (nonatomic, assign) BOOL isLogin;//\u662f\u5426\u767b\u5f55\u72b6\u6001\n\n+ (instancetype)sharedInstance;\n\n\n@end\n\nNS_ASSUME_NONNULL_END\n\n", "comment_ratio": 0.3333333333333333}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n\n@class ONEMoreSubtotalLayout;\n\n@protocol ONEMoreSubtotalLayoutDelegate <NSObject>\n\n@required\n/**\n *  \u6bcf\u4e2aitem\u7684\u9ad8\u5ea6\n *\n *  @param subtotallowLayout \u5e03\u5c40\u53c2\u6570\n *  @param width             item\u7684\u5bbd\u5ea6\n *  @param indexPath         item\u7684\u7d22\u5f15\n *\n *  @return Item\u7684\u9ad8\u5ea6\n */\n- (CGFloat)subtotallowLayout:(ONEMoreSubtotalLayout *)subtotallowLayout heightForWidth:(CGFloat)width atIndexPath:(NSIndexPath *)indexPath;\n@end\n\n@interface ONEMoreSubtotalLayout : UICollectionViewFlowLayout\n@property (nonatomic, weak) id<ONEMoreSubtotalLayoutDelegate> delegate;\n@end\n\n", "comment_ratio": 0.22580645161290322}
{"lang": "c", "code": "#ifndef _O3D_RIGIDBODYCOLLIDER_H\n#define _O3D_RIGIDBODYCOLLIDER_H\n\n#include \"o3d/core/memorydbg.h\"\n#include \"abccollider.h\"\n#include \"rigidbody.h\"\n\nnamespace o3d {\n\nclass CollisionManager;\n\n/**\n * @brief Track the collision between the pair of rigid body\n * @author Frederic SCHERMA (frederic.scherma@dreamoverflow.org)\n * @date 2006-06-01\n */\nclass O3D_API RigidBodyCollider : public ABCCollider\n{\npublic:\n\n\t//! default constructor\n    RigidBodyCollider(RigidBody& body0, RigidBody& body1);\n\n\t//! destructor\n\tvirtual ~RigidBodyCollider();\n\n    //! perform a collision detection\n    virtual void performCollisionDetection(CollisionManager& collisionManager);\n\n\tvirtual PhysicEntity& getCollideE0();\n\tvirtual PhysicEntity& getCollideE1();\n\n    inline RigidBody& getRigidBody0() { return *m_body0; }\n    inline RigidBody& getRigidBody1() { return *m_body1; }\n\n    // @todo integration of OPCODE\n//    AABBTreeCollider& getTreeCollider();\n//    BVTCache& getCollisionCache();\n\n//    Bool getLastCollisionStatus();\n//    UInt32 getNumCollidingPairs();\n\n//    static void collisionCallback(udword triangleindex, VertexPointers& triangle, udword userdata);\n\nprotected:\n\n    RigidBody* m_body0;   //!< first rigid body\n    RigidBody* m_body1;   //!< second rigid body\n\n    PhysicEntity *m_collideE0;\n    PhysicEntity *m_collideE1;\n};\n\n} // namespace o3d\n\n#endif // _O3D_RIGIDBODYCOLLIDER_H\n\n", "comment_ratio": 0.19696969696969696}
{"lang": "c", "code": "#import <PhotosUICore/PhotosUICore-Structs.h>\n#import <libobjc.A.dylib/PXCMMInvitationParticipant.h>\n#import <libobjc.A.dylib/NSCopying.h>\n\n@class NSString, NSSet, PXRecipientTransport, CNContact;\n\n@interface PXRecipient : NSObject <PXCMMInvitationParticipant, NSCopying> {\n\n\tNSString* _firstName;\n\tNSString* _lastName;\n\tNSSet* _allEmails;\n\tNSSet* _allPhones;\n\tNSSet* _unformattedAllPhones;\n\tNSString* _phoneNumberString;\n\tNSString* _emailAddressString;\n\tPXRecipientTransport* _suggestedTransport;\n\tNSString* _localizedName;\n\tCNContact* _contact;\n\n}\n\n@property (readonly) unsigned long long hash; \n@property (readonly) Class superclass; \n@property (copy,readonly) NSString * description; \n@property (copy,readonly) NSString * debugDescription; \n@property (nonatomic,readonly) NSString * emailAddressString; \n@property (nonatomic,readonly) NSString * phoneNumberString; \n@property (nonatomic,readonly) NSString * localizedName; \n@property (nonatomic,readonly) NSString * firstName; \n@property (nonatomic,retain) PXRecipientTransport * suggestedTransport;              //@synthesize suggestedTransport=_suggestedTransport - In the implementation block\n@property (nonatomic,copy,readonly) NSString * firstName;                            //@synthesize firstName=_firstName - In the implementation block\n@property (nonatomic,copy,readonly) NSString * lastName;                             //@synthesize lastName=_lastName - In the implementation block\n@property (nonatomic,readonly) NSSet * allEmails;                                    //@synthesize allEmails=_allEmails - In the implementation block\n@property (nonatomic,readonly) NSSet * allPhones;                                    //@synthesize allPhones=_allPhones - In the implementation block\n@property (nonatomic,readonly) NSSet * unformattedAllPhones;                         //@synthesize unformattedAllPhones=_unformattedAllPhones - In the implementation block\n@property (nonatomic,copy,readonly) NSString * phoneNumberString;                    //@synthesize phoneNumberString=_phoneNumberString - In the implementation block\n@property (nonatomic,copy,readonly) NSString * emailAddressString;                   //@synthesize emailAddressString=_emailAddressString - In the implementation block\n@property (nonatomic,copy,readonly) NSString * localizedName;                        //@synthesize localizedName=_localizedName - In the implementation block\n@property (nonatomic,readonly) CNContact * contact;                                  //@synthesize contact=_contact - In the implementation block\n+(id)new;\n+(id)_contactForAddress:(id)arg1 recipientKind:(long long)arg2 ;\n-(BOOL)isEqual:(id)arg1 ;\n-(unsigned long long)hash;\n-(id)copyWithZone:(NSZone*)arg1 ;\n-(NSString *)description;\n-(id)init;\n-(NSString *)localizedName;\n-(NSString *)firstName;\n-(NSString *)lastName;\n-(CNContact *)contact;\n-(NSSet *)allPhones;\n-(NSSet *)allEmails;\n-(id)initWithAddress:(id)arg1 nameComponents:(id)arg2 recipientKind:(long long)arg3 ;\n-(id)initWithContact:(id)arg1 address:(id)arg2 nameComponents:(id)arg3 recipientKind:(long long)arg4 ;\n-(NSSet *)unformattedAllPhones;\n-(NSString *)phoneNumberString;\n-(NSString *)emailAddressString;\n-(PXRecipientTransport *)suggestedTransport;\n-(void)setSuggestedTransport:(PXRecipientTransport *)arg1 ;\n@end\n\n\n", "comment_ratio": 0.14285714285714285}
{"lang": "c", "code": "#import <CoreLocation/CoreLocation.h>\n#import <Foundation/Foundation.h>\n#import <QuartzCore/QuartzCore.h>\n\n#import \"DataLayer.h\"\n#import \"MLConstants.h\"\n#import \"MLXMPPManager.h\"\n#import \"MLNotificationManager.h\"\n#import \"MLResizingTextView.h\"\n\n\n@interface chatViewController : UIViewController <UITableViewDelegate, UITableViewDataSource, UITextViewDelegate, UINavigationControllerDelegate, UIImagePickerControllerDelegate, UIDocumentPickerDelegate, CLLocationManagerDelegate>\n{\n    UIView* containerView;\n\tBOOL _firstmsg;\n}\n\n@property (nonatomic, retain) CLLocationManager *locationManager;\n\n@property (nonatomic, weak) IBOutlet UITableView *messageTable;\n@property (nonatomic, weak) IBOutlet MLResizingTextView *chatInput;\n@property (nonatomic, weak) IBOutlet UILabel *placeHolderText;\n@property (nonatomic, weak) IBOutlet UIButton *sendButton;\n@property (nonatomic, weak) IBOutlet UIButton *plusButton;\n\n@property (nonatomic, weak) IBOutlet UIView *inputContainerView;\n@property (nonatomic, weak) IBOutlet UIView *navBarContainerView;\n@property (nonatomic, weak) IBOutlet NSLayoutConstraint *tableviewBottom;\n@property (weak, nonatomic) IBOutlet UILabel *navBarContactJid;\n@property (weak, nonatomic) IBOutlet UILabel *navBarLastInteraction;\n@property (nonatomic, weak) IBOutlet UIImageView* navBarIcon;\n@property (weak, nonatomic) IBOutlet UIButton *navBarContactDetailsButton;\n@property (weak, nonatomic) IBOutlet UIBarButtonItem *navBarEncryptToggleButton;\n\n@property (nonatomic, weak) IBOutlet UIImageView *backgroundImage;\n@property (nonatomic, weak) IBOutlet UIView *transparentLayer;\n\n\n@property (nonatomic, strong) NSString *day;\n@property (nonatomic, strong) MLContact *contact;\n\n/**\n full own username with domain e.g. user@example.org\n */\n@property (nonatomic, strong) NSString *jid;\n\n-(IBAction)sendMessageText:(id)sender;\n// attach image\n-(IBAction)attach:(id)sender;\n//attach file\n-(IBAction)attachfile:(id)sender;\n\n-(IBAction)dismissKeyboard:(id)sender;\n\n-(void) setupWithContact:(MLContact *) contact;\n\n-(void)locationManager:(CLLocationManager *)manager didUpdateLocations:(NSArray<CLLocation *> *)locations;\n-(void)locationManager:(CLLocationManager *)manager didFailWithError:(NSError *)error;\n\n/**\n Receives the new message notice and will update if it is this user. \n */\n-(void) handleNewMessage:(NSNotification *)notification;\n-(void) addMessageto:(NSString*)to withMessage:(NSString*) message andId:(NSString *) messageId withCompletion:(void (^)(BOOL success))completion;\n\n-(void) retry:(id) sender;\n\n-(void) reloadTable; \n\n@end\n\n", "comment_ratio": 0.11392405063291139}
{"lang": "c", "code": "/**\n  ******************************************************************************\n  * @author  Lanceli\n  * @version V1.0.1\n  * @date    09-May-2020\n  * @brief   Project entrance.\n  *          Create the major task.\n  ******************************************************************************\n  * @attention\n  * This project is for learning only. If it is for commercial use, please contact the author.\n  *\n  * website:developerlab.cn\n  *\n  * Copyright (c) 2020 Lanceli All rights reserved.\n  ******************************************************************************\n  */\n\n/* Define to prevent recursive inclusion -------------------------------------*/\n#ifndef __MAIN_H\n#define __MAIN_H\n\n/* Includes ------------------------------------------------------------------*/\n#include \"FreeRTOS.h\"\n#include \"timers.h\"\n#include \"semphr.h\"\n\n#include \"delay.h\"\n#include \"BSPConfig.h\"\n\n#include \"main_task.h\"\n#include \"test_task.h\"\n\n#include \"stm32f4xx.h\"\n#include \"stm32f4xx_led_bsp.h\"\n#include \"stm32f4xx_heap_bsp.h\"\n#include \"stm32f4xx_uart_bsp.h\"\n#include \"stm32f4xx_fsmc_bsp.h\"\n\n/* Exported types ------------------------------------------------------------*/\n/* Exported constants --------------------------------------------------------*/\n#define BITBAND(addr, bitnum) ((addr & 0xF0000000) + 0x2000000 + ((addr & 0xFFFFF) << 5) + (bitnum << 2))\n#define MEM_ADDR(addr) *((volatile unsigned long *)(addr))\n#define BIT_ADDR(addr, bitnum) MEM_ADDR(BITBAND(addr, bitnum))\n\n#define GPIOA_ODR_Addr (GPIOA_BASE + 20) //0x40020014\n#define GPIOB_ODR_Addr (GPIOB_BASE + 20) //0x40020414\n#define GPIOC_ODR_Addr (GPIOC_BASE + 20) //0x40020814\n#define GPIOD_ODR_Addr (GPIOD_BASE + 20) //0x40020C14\n#define GPIOE_ODR_Addr (GPIOE_BASE + 20) //0x40021014\n#define GPIOF_ODR_Addr (GPIOF_BASE + 20) //0x40021414\n#define GPIOG_ODR_Addr (GPIOG_BASE + 20) //0x40021814\n#define GPIOH_ODR_Addr (GPIOH_BASE + 20) //0x40021C14\n#define GPIOI_ODR_Addr (GPIOI_BASE + 20) //0x40022014\n\n#define GPIOA_IDR_Addr (GPIOA_BASE + 16) //0x40020010\n#define GPIOB_IDR_Addr (GPIOB_BASE + 16) //0x40020410\n#define GPIOC_IDR_Addr (GPIOC_BASE + 16) //0x40020810\n#define GPIOD_IDR_Addr (GPIOD_BASE + 16) //0x40020C10\n#define GPIOE_IDR_Addr (GPIOE_BASE + 16) //0x40021010\n#define GPIOF_IDR_Addr (GPIOF_BASE + 16) //0x40021410\n#define GPIOG_IDR_Addr (GPIOG_BASE + 16) //0x40021810\n#define GPIOH_IDR_Addr (GPIOH_BASE + 16) //0x40021C10\n#define GPIOI_IDR_Addr (GPIOI_BASE + 16) //0x40022010\n\n#define PAout(n) BIT_ADDR(GPIOA_ODR_Addr, n)\n#define PAin(n) BIT_ADDR(GPIOA_IDR_Addr, n)\n\n#define PBout(n) BIT_ADDR(GPIOB_ODR_Addr, n)\n#define PBin(n) BIT_ADDR(GPIOB_IDR_Addr, n)\n\n#define PCout(n) BIT_ADDR(GPIOC_ODR_Addr, n)\n#define PCin(n) BIT_ADDR(GPIOC_IDR_Addr, n)\n\n#define PDout(n) BIT_ADDR(GPIOD_ODR_Addr, n)\n#define PDin(n) BIT_ADDR(GPIOD_IDR_Addr, n)\n\n#define PEout(n) BIT_ADDR(GPIOE_ODR_Addr, n)\n#define PEin(n) BIT_ADDR(GPIOE_IDR_Addr, n)\n\n#define PFout(n) BIT_ADDR(GPIOF_ODR_Addr, n)\n#define PFin(n) BIT_ADDR(GPIOF_IDR_Addr, n)\n\n#define PGout(n) BIT_ADDR(GPIOG_ODR_Addr, n)\n#define PGin(n) BIT_ADDR(GPIOG_IDR_Addr, n)\n\n#define PHout(n) BIT_ADDR(GPIOH_ODR_Addr, n)\n#define PHin(n) BIT_ADDR(GPIOH_IDR_Addr, n)\n\n#define PIout(n) BIT_ADDR(GPIOI_ODR_Addr, n)\n#define PIin(n) BIT_ADDR(GPIOI_IDR_Addr, n)\n\n/*Redefining RTOS delay function*/\n#define Delay(nCount) vTaskDelay(nCount)\n\n/*Hardware interupt priority*/\n#define USART1_IRQnPriority 7\n#define DMA2_Stream5_IRQnPriority 8\n\n/*Debug Message*/\n#define ASSERT(void) assert_failed((uint8_t *)__FILE__, __LINE__)\n\n/* Exported macro ------------------------------------------------------------*/\n/* Exported functions ------------------------------------------------------- */\n\n#endif /* __MAIN_H */\n\n", "comment_ratio": 0.16981132075471697}
{"lang": "c", "code": "#ifndef PDSP_CONTROL_SEQUENCER_H_INCLUDED\r\n#define PDSP_CONTROL_SEQUENCER_H_INCLUDED\r\n\r\n#include \"../pdspCore.h\"\r\n\r\nnamespace pdsp{\r\n/*!\r\n    @cond HIDDEN_SYMBOLS\r\n*/ \r\nclass MessageBuffer;\r\n        \r\nclass SequencerBridge : public Unit{\r\n        friend Patchable& linkBufferToSequencer (MessageBuffer& output, SequencerBridge& input);\r\n        friend MessageBuffer;\r\n\r\npublic:\r\n        virtual void link(MessageBuffer &messageBuffer) = 0;\r\n        virtual void unLink() = 0;\r\n        \r\n        //TODO: add operator for linking MessageSources to sequencer\r\nprotected:\r\n        virtual void resetMessageBufferSelector() {};\r\n        MessageBuffer* messageBuffer;\r\n        \r\n};\r\n        \r\nPatchable& linkBufferToSequencer (MessageBuffer& output, SequencerBridge& input);\r\nPatchable& operator>> (MessageBuffer& output, SequencerBridge& input);\r\n        \r\n/*!\r\n    @endcond\r\n*/         \r\n        \r\n} // pdsp namespace end\r\n\r\n\r\n\r\n#endif  // PDSP_CONTROL_SEQUENCER_H_INCLUDED\r\n\n", "comment_ratio": 0.13636363636363635}
{"lang": "c", "code": "//\n//  PNMessageHistoryRequest+Protected.h\n//  pubnub\n//\n//  This header file used by library internal\n//  components which require to access to some\n//  methods and properties which shouldn't be\n//  visible to other application components\n//\n//  Created by Sergey Mamontov.\n//\n//\n\n\n#import \"PNMessageHistoryRequest.h\"\n\n\n#pragma mark Protected interface implementation\n\n@interface PNMessageHistoryRequest (Protected)\n\n\n#pragma mark - Properties\n\n// Stores reference on channel for which history should\n// be pulled out\n@property (nonatomic, readonly, strong) PNChannel *channel;\n\n// Stores reference on history time frame start/end dates (time tokens)\n@property (nonatomic, readonly, strong) PNDate *startDate;\n@property (nonatomic, readonly, strong) PNDate *endDate;\n\n// Stores reference on maximum number of messages which\n// should be returned from backend\n@property (nonatomic, readonly, assign) NSUInteger limit;\n\n// Stores reference on whether messages should revert\n// their order in response or not\n@property (nonatomic, readonly, assign, getter = shouldRevertMessages) BOOL revertMessages;\n\n/**\n Stores whether response should include messages times stamp or not.\n */\n@property (nonatomic, readonly, assign, getter = shouldIncludeTimeToken) BOOL includeTimeToken;\n\n/**\n Storing configuration dependant parameters\n */\n@property (nonatomic, copy) NSString *subscriptionKey;\n\n#pragma mark -\n\n\n@end\n\n", "comment_ratio": 0.34545454545454546}
{"lang": "c", "code": "#import \"NSObject.h\"\n\n#import \"WCTTableCoding.h\"\n\n@class NSString;\n\n@interface WCDeviceAirKissReccord : NSObject <WCTTableCoding>\n{\n    unsigned int IntRes1;\n    unsigned int IntRes2;\n    NSString *m_key;\n    NSString *m_data;\n    NSString *StrRes1;\n    NSString *StrRes2;\n}\n\n+ (const struct WCTProperty *)StrRes2;\n+ (const struct WCTProperty *)StrRes1;\n+ (const struct WCTProperty *)IntRes2;\n+ (const struct WCTProperty *)IntRes1;\n+ (const struct WCTProperty *)m_data;\n+ (const struct WCTProperty *)m_key;\n+ (const struct WCTAnyProperty *)AnyProperty;\n+ (const list_2812bee2 *)AllProperties;\n+ (const struct WCTBinding *)objectRelationalMappingForWCDB;\n@property(retain, nonatomic) NSString *StrRes2; // @synthesize StrRes2;\n@property(retain, nonatomic) NSString *StrRes1; // @synthesize StrRes1;\n@property(nonatomic) unsigned int IntRes2; // @synthesize IntRes2;\n@property(nonatomic) unsigned int IntRes1; // @synthesize IntRes1;\n@property(retain, nonatomic) NSString *m_data; // @synthesize m_data;\n@property(retain, nonatomic) NSString *m_key; // @synthesize m_key;\n- (void).cxx_destruct;\n- (void)dealloc;\n\n// Remaining properties\n@property(nonatomic) _Bool isAutoIncrement;\n@property(nonatomic) long long lastInsertedRowID;\n\n@end\n\n\n", "comment_ratio": 0.2553191489361702}
{"lang": "c", "code": "#pragma once\n#include \"mvTypeBases.h\"\n#include <string>\n#include \"mvMarvel.h\"\n\n//-----------------------------------------------------------------------------\n// Widget Index\n//\n//     * mvSliderFloat\n//     * mvSliderFloat2\n//     * mvSliderFloat3\n//     * mvSliderFloat4\n//     * mvSliderInt\n//     * mvSliderInt2\n//     * mvSliderInt3\n//     * mvSliderInt4\n//\n//-----------------------------------------------------------------------------\n\nnamespace Marvel {\n\n    //-----------------------------------------------------------------------------\n    // mvSliderFloat\n    //-----------------------------------------------------------------------------\n    class mvSliderFloat : public mvFloatPtrBase\n    {\n        \n        MV_APPITEM_TYPE(mvAppItemType::SliderFloat, mvSliderFloat, \"add_slider_float\")\n\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderFloat, mvThemeCol_SliderFloat_Text            ,  0L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderFloat, mvThemeCol_SliderFloat_Bg              ,  7L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderFloat, mvThemeCol_SliderFloat_BgHovered       ,  8L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderFloat, mvThemeCol_SliderFloat_BgActive        ,  9L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderFloat, mvThemeCol_SliderFloat_Grab            , 19L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderFloat, mvThemeCol_SliderFloat_GrabActive      , 20L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderFloat, mvThemeCol_SliderFloat_Border          ,  5L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderFloat, mvThemeCol_SliderFloat_BorderShadow    ,  6L);\n\n        MV_START_COLOR_CONSTANTS\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderFloat_Text),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderFloat_Bg),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderFloat_BgHovered),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderFloat_BgActive),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderFloat_Grab),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderFloat_GrabActive),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderFloat_Border),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderFloat_BorderShadow),\n        MV_END_COLOR_CONSTANTS\n\n    public:\n\n        mvSliderFloat(const std::string& name, float default_value, const std::string& dataSource);\n        \n        void setEnabled(bool value) override;\n        void draw() override;\n\n#ifndef MV_CPP\n        void setExtraConfigDict(PyObject* dict) override;\n        void getExtraConfigDict(PyObject* dict) override;\n#endif // !MV_CPP\n        \n    private:\n\n        float               m_min = 0.0f;\n        float               m_max = 100.0f;\n        std::string         m_format = \"%.3f\";\n        bool                m_vertical = false;\n        ImGuiInputTextFlags m_flags = ImGuiSliderFlags_None;\n        ImGuiInputTextFlags m_stor_flags = ImGuiSliderFlags_None;\n        \n    };\n\n    //-----------------------------------------------------------------------------\n    // mvSliderFloat2\n    //-----------------------------------------------------------------------------\n    class mvSliderFloat2 : public mvFloat2PtrBase\n    {\n        \n        MV_APPITEM_TYPE(mvAppItemType::SliderFloat2, mvSliderFloat2, \"add_slider_float2\")\n\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderFloat2, mvThemeCol_SliderFloat2_Text          ,  0L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderFloat2, mvThemeCol_SliderFloat2_Bg            ,  7L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderFloat2, mvThemeCol_SliderFloat2_BgHovered     ,  8L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderFloat2, mvThemeCol_SliderFloat2_BgActive      ,  9L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderFloat2, mvThemeCol_SliderFloat2_Grab          , 19L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderFloat2, mvThemeCol_SliderFloat2_GrabActive    , 20L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderFloat2, mvThemeCol_SliderFloat2_Border        ,  5L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderFloat2, mvThemeCol_SliderFloat2_BorderShadow  ,  6L);\n\n        MV_START_COLOR_CONSTANTS\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderFloat2_Text),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderFloat2_Bg),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderFloat2_BgHovered),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderFloat2_BgActive),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderFloat2_Grab),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderFloat2_GrabActive),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderFloat2_Border),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderFloat2_BorderShadow),\n        MV_END_COLOR_CONSTANTS\n\n    public:\n\n        mvSliderFloat2(const std::string& name, float* default_value, const std::string& dataSource);\n        \n        void setEnabled(bool value) override;\n\n        void draw() override;\n\n#ifndef MV_CPP\n        void setExtraConfigDict(PyObject* dict) override;\n        void getExtraConfigDict(PyObject* dict) override;\n#endif // !MV_CPP\n        \n    private:\n\n        float               m_min = 0.0f;\n        float               m_max = 100.0f;\n        std::string         m_format = \"%.3f\";\n        ImGuiInputTextFlags m_flags = ImGuiSliderFlags_None;\n        ImGuiInputTextFlags m_stor_flags = ImGuiSliderFlags_None;\n        \n    };\n\n    //-----------------------------------------------------------------------------\n    // mvSliderFloat3\n    //-----------------------------------------------------------------------------\n    class mvSliderFloat3 : public mvFloat3PtrBase\n    {\n        \n        MV_APPITEM_TYPE(mvAppItemType::SliderFloat3, mvSliderFloat3, \"add_slider_float3\")\n\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderFloat3, mvThemeCol_SliderFloat3_Text          ,  0L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderFloat3, mvThemeCol_SliderFloat3_Bg            ,  7L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderFloat3, mvThemeCol_SliderFloat3_BgHovered     ,  8L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderFloat3, mvThemeCol_SliderFloat3_BgActive      ,  9L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderFloat3, mvThemeCol_SliderFloat3_Grab          , 19L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderFloat3, mvThemeCol_SliderFloat3_GrabActive    , 20L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderFloat3, mvThemeCol_SliderFloat3_Border        ,  5L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderFloat3, mvThemeCol_SliderFloat3_BorderShadow  ,  6L);\n\n        MV_START_COLOR_CONSTANTS\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderFloat3_Text),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderFloat3_Bg),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderFloat3_BgHovered),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderFloat3_BgActive),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderFloat3_Grab),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderFloat3_GrabActive),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderFloat3_Border),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderFloat3_BorderShadow),\n        MV_END_COLOR_CONSTANTS\n\n    public:\n\n        mvSliderFloat3(const std::string& name, float* default_value, const std::string& dataSource);\n        \n        void setEnabled(bool value) override;\n        void draw() override;\n\n#ifndef MV_CPP\n        void setExtraConfigDict(PyObject* dict) override;\n        void getExtraConfigDict(PyObject* dict) override;\n#endif // !MV_CPP\n        \n    private:\n\n        float               m_min = 0.0f;\n        float               m_max = 100.0f;\n        std::string         m_format = \"%.3f\";\n        ImGuiInputTextFlags m_flags = ImGuiSliderFlags_None;\n        ImGuiInputTextFlags m_stor_flags = ImGuiSliderFlags_None;\n        \n    };\n    \n    //-----------------------------------------------------------------------------\n    // mvSliderFloat4\n    //-----------------------------------------------------------------------------\n    class mvSliderFloat4 : public mvFloat4PtrBase\n    {\n          \n        MV_APPITEM_TYPE(mvAppItemType::SliderFloat4, mvSliderFloat4, \"add_slider_float4\")\n\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderFloat4, mvThemeCol_SliderFloat4_Text          ,  0L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderFloat4, mvThemeCol_SliderFloat4_Bg            ,  7L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderFloat4, mvThemeCol_SliderFloat4_BgHovered     ,  8L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderFloat4, mvThemeCol_SliderFloat4_BgActive      ,  9L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderFloat4, mvThemeCol_SliderFloat4_Grab          , 19L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderFloat4, mvThemeCol_SliderFloat4_GrabActive    , 20L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderFloat4, mvThemeCol_SliderFloat4_Border        ,  5L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderFloat4, mvThemeCol_SliderFloat4_BorderShadow  ,  6L);\n\n        MV_START_COLOR_CONSTANTS\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderFloat4_Text),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderFloat4_Bg),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderFloat4_BgHovered),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderFloat4_BgActive),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderFloat4_Grab),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderFloat4_GrabActive),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderFloat4_Border),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderFloat4_BorderShadow),\n        MV_END_COLOR_CONSTANTS\n\n    public:\n\n        mvSliderFloat4(const std::string& name, float* default_value, const std::string& dataSource);\n        \n        void setEnabled(bool value) override;\n        void draw() override;\n\n#ifndef MV_CPP\n        void setExtraConfigDict(PyObject* dict) override;\n        void getExtraConfigDict(PyObject* dict) override;\n#endif // !MV_CPP\n        \n    private:\n\n        float               m_min = 0.0f;\n        float               m_max = 100.0f;\n        std::string         m_format = \"%.3f\";\n        ImGuiInputTextFlags m_flags = ImGuiSliderFlags_None;\n        ImGuiInputTextFlags m_stor_flags = ImGuiSliderFlags_None;\n        \n    };\n     \n    //-----------------------------------------------------------------------------\n    // mvSliderInt\n    //-----------------------------------------------------------------------------\n    class mvSliderInt : public mvIntPtrBase\n    {\n            \n        MV_APPITEM_TYPE(mvAppItemType::SliderInt, mvSliderInt, \"add_slider_int\")\n\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderInt, mvThemeCol_SliderInt_Text            ,  0L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderInt, mvThemeCol_SliderInt_Bg              ,  7L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderInt, mvThemeCol_SliderInt_BgHovered       ,  8L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderInt, mvThemeCol_SliderInt_BgActive        ,  9L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderInt, mvThemeCol_SliderInt_Grab            , 19L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderInt, mvThemeCol_SliderInt_GrabActive      , 20L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderInt, mvThemeCol_SliderInt_Border          ,  5L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderInt, mvThemeCol_SliderInt_BorderShadow    ,  6L);\n\n        MV_START_COLOR_CONSTANTS\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderInt_Text),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderInt_Bg),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderInt_BgHovered),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderInt_BgActive),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderInt_Grab),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderInt_GrabActive),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderInt_Border),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderInt_BorderShadow),\n        MV_END_COLOR_CONSTANTS\n\n    public:\n\n        mvSliderInt(const std::string& name, int default_value, const std::string& dataSource);\n            \n        void setEnabled(bool value) override;   \n        void draw() override;\n\n#ifndef MV_CPP\n        void setExtraConfigDict(PyObject* dict) override;\n        void getExtraConfigDict(PyObject* dict) override;\n#endif // !MV_CPP\n            \n    private:\n\n        int                 m_min = 0;\n        int                 m_max = 100;\n        std::string         m_format = \"%d\";\n        bool                m_vertical = false;\n        ImGuiInputTextFlags m_flags = ImGuiSliderFlags_None;\n        ImGuiInputTextFlags m_stor_flags = ImGuiSliderFlags_None;\n        \n    };\n        \n    //-----------------------------------------------------------------------------\n    // mvSliderInt2\n    //-----------------------------------------------------------------------------\n    class mvSliderInt2 : public mvInt2PtrBase\n    {\n        \n        MV_APPITEM_TYPE(mvAppItemType::SliderInt2, mvSliderInt2, \"add_slider_int2\")\n\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderInt2, mvThemeCol_SliderInt2_Text          ,  0L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderInt2, mvThemeCol_SliderInt2_Bg            ,  7L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderInt2, mvThemeCol_SliderInt2_BgHovered     ,  8L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderInt2, mvThemeCol_SliderInt2_BgActive      ,  9L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderInt2, mvThemeCol_SliderInt2_Grab          , 19L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderInt2, mvThemeCol_SliderInt2_GrabActive    , 20L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderInt2, mvThemeCol_SliderInt2_Border        ,  5L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderInt2, mvThemeCol_SliderInt2_BorderShadow  ,  6L);\n\n        MV_START_COLOR_CONSTANTS\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderInt2_Text),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderInt2_Bg),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderInt2_BgHovered),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderInt2_BgActive),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderInt2_Grab),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderInt2_GrabActive),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderInt2_Border),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderInt2_BorderShadow),\n        MV_END_COLOR_CONSTANTS\n\n    public:\n\n        mvSliderInt2(const std::string& name, int* default_value, const std::string& dataSource);\n        \n        void setEnabled(bool value) override;\n        void draw() override;\n\n#ifndef MV_CPP\n        void setExtraConfigDict(PyObject* dict) override;\n        void getExtraConfigDict(PyObject* dict) override;\n#endif // !MV_CPP\n        \n    private:\n\n        int                 m_min = 0;\n        int                 m_max = 100;\n        std::string         m_format = \"%d\";\n        ImGuiInputTextFlags m_flags = ImGuiSliderFlags_None;\n        ImGuiInputTextFlags m_stor_flags = ImGuiSliderFlags_None;\n        \n    };\n    \n    //-----------------------------------------------------------------------------\n    // mvSliderInt3\n    //-----------------------------------------------------------------------------\n    class mvSliderInt3 : public mvInt3PtrBase\n    {\n        \n        MV_APPITEM_TYPE(mvAppItemType::SliderInt3, mvSliderInt3, \"add_slider_int3\")\n\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderInt3, mvThemeCol_SliderInt3_Text          ,  0L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderInt3, mvThemeCol_SliderInt3_Bg            ,  7L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderInt3, mvThemeCol_SliderInt3_BgHovered     ,  8L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderInt3, mvThemeCol_SliderInt3_BgActive      ,  9L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderInt3, mvThemeCol_SliderInt3_Grab          , 19L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderInt3, mvThemeCol_SliderInt3_GrabActive    , 20L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderInt3, mvThemeCol_SliderInt3_Border        ,  5L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderInt3, mvThemeCol_SliderInt3_BorderShadow  ,  6L);\n\n        MV_START_COLOR_CONSTANTS\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderInt3_Text),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderInt3_Bg),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderInt3_BgHovered),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderInt3_BgActive),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderInt3_Grab),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderInt3_GrabActive),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderInt3_Border),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderInt3_BorderShadow),\n        MV_END_COLOR_CONSTANTS\n\n    public:\n\n        mvSliderInt3(const std::string& name, int* default_value, const std::string& dataSource);\n        \n        void setEnabled(bool value) override;\n        void draw() override;\n\n#ifndef MV_CPP\n        void setExtraConfigDict(PyObject* dict) override;\n        void getExtraConfigDict(PyObject* dict) override;\n#endif // !MV_CPP\n        \n    private:\n\n        int                 m_min = 0;\n        int                 m_max = 100;\n        std::string         m_format = \"%d\";\n        ImGuiInputTextFlags m_flags = ImGuiSliderFlags_None;\n        ImGuiInputTextFlags m_stor_flags = ImGuiSliderFlags_None;\n        \n    };\n        \n    //-----------------------------------------------------------------------------\n    // mvSliderInt4\n    //-----------------------------------------------------------------------------\n    class mvSliderInt4 : public mvInt4PtrBase\n    {\n        \n        MV_APPITEM_TYPE(mvAppItemType::SliderInt4, mvSliderInt4, \"add_slider_int4\")\n\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderInt4, mvThemeCol_SliderInt4_Text          ,  0L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderInt4, mvThemeCol_SliderInt4_Bg            ,  7L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderInt4, mvThemeCol_SliderInt4_BgHovered     ,  8L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderInt4, mvThemeCol_SliderInt4_BgActive      ,  9L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderInt4, mvThemeCol_SliderInt4_Grab          , 19L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderInt4, mvThemeCol_SliderInt4_GrabActive    , 20L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderInt4, mvThemeCol_SliderInt4_Border        ,  5L);\n        MV_CREATE_THEME_CONSTANT(mvAppItemType::SliderInt4, mvThemeCol_SliderInt4_BorderShadow  ,  6L);\n\n        MV_START_COLOR_CONSTANTS\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderInt4_Text),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderInt4_Bg),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderInt4_BgHovered),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderInt4_BgActive),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderInt4_Grab),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderInt4_GrabActive),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderInt4_Border),\n            MV_CREATE_CONSTANT_PAIR(mvThemeCol_SliderInt4_BorderShadow),\n        MV_END_COLOR_CONSTANTS\n\n    public:\n\n        mvSliderInt4(const std::string& name, int* default_value, const std::string& dataSource);\n        \n        void setEnabled(bool value) override;\n        void draw() override;\n\n#ifndef MV_CPP\n        void setExtraConfigDict(PyObject* dict) override;\n        void getExtraConfigDict(PyObject* dict) override;\n#endif // !MV_CPP\n        \n    private:\n\n        int                 m_min = 0;\n        int                 m_max = 100;\n        std::string         m_format = \"%d\";\n        ImGuiInputTextFlags m_flags = ImGuiSliderFlags_None;\n        ImGuiInputTextFlags m_stor_flags = ImGuiSliderFlags_None;\n        \n    };\n\n}\n\n", "comment_ratio": 0.1056338028169014}
{"lang": "c", "code": "// fdrawcmd.sys 1.0.1.11\n//\n// Low-level floppy filter, by Simon Owen\n//\n// http://simonowen.com/fdrawcmd/\n\n#ifndef FDRAWCMD_H\n#define FDRAWCMD_H\n\n#ifndef CTL_CODE\n#include <winioctl.h>\n#endif\n\n#define FDRAWCMD_VERSION                0x0100010b      // Compile-time version, for structures and definitions below\n                                                        // Must be checked with run-time driver for compatibility\n\n#define FD_CTL_CODE(i,m)                CTL_CODE(FILE_DEVICE_UNKNOWN, i, m, FILE_READ_DATA|FILE_WRITE_DATA)\n\n                                                                                // If you're not using C/C++, use the IOCTL values below\n#define IOCTL_FDRAWCMD_GET_VERSION      FD_CTL_CODE(0x888, METHOD_BUFFERED)     // 0x0022e220\n\n#define IOCTL_FDCMD_READ_TRACK          FD_CTL_CODE(0x802, METHOD_OUT_DIRECT)   // 0x0022e00a\n#define IOCTL_FDCMD_SPECIFY             FD_CTL_CODE(0x803, METHOD_BUFFERED)     // 0x0022e00c\n#define IOCTL_FDCMD_SENSE_DRIVE_STATUS  FD_CTL_CODE(0x804, METHOD_BUFFERED)     // 0x0022e010\n#define IOCTL_FDCMD_WRITE_DATA          FD_CTL_CODE(0x805, METHOD_IN_DIRECT)    // 0x0022e015\n#define IOCTL_FDCMD_READ_DATA           FD_CTL_CODE(0x806, METHOD_OUT_DIRECT)   // 0x0022e01a\n#define IOCTL_FDCMD_RECALIBRATE         FD_CTL_CODE(0x807, METHOD_BUFFERED)     // 0x0022e01c\n#define IOCTL_FDCMD_SENSE_INT_STATUS    FD_CTL_CODE(0x808, METHOD_BUFFERED)     // 0x0022e020   // added in 1.0.0.22\n#define IOCTL_FDCMD_WRITE_DELETED_DATA  FD_CTL_CODE(0x809, METHOD_IN_DIRECT)    // 0x0022e025\n#define IOCTL_FDCMD_READ_ID             FD_CTL_CODE(0x80a, METHOD_BUFFERED)     // 0x0022e028\n#define IOCTL_FDCMD_READ_DELETED_DATA   FD_CTL_CODE(0x80c, METHOD_OUT_DIRECT)   // 0x0022e032\n#define IOCTL_FDCMD_FORMAT_TRACK        FD_CTL_CODE(0x80d, METHOD_BUFFERED)     // 0x0022e034\n#define IOCTL_FDCMD_DUMPREG             FD_CTL_CODE(0x80e, METHOD_BUFFERED)     // 0x0022e038\n#define IOCTL_FDCMD_SEEK                FD_CTL_CODE(0x80f, METHOD_BUFFERED)     // 0x0022e03c\n#define IOCTL_FDCMD_VERSION             FD_CTL_CODE(0x810, METHOD_BUFFERED)     // 0x0022e040\n#define IOCTL_FDCMD_SCAN_EQUAL          FD_CTL_CODE(0x811, METHOD_IN_DIRECT)    // 0x0022e045   (not implemented yet)\n#define IOCTL_FDCMD_PERPENDICULAR_MODE  FD_CTL_CODE(0x812, METHOD_BUFFERED)     // 0x0022e048\n#define IOCTL_FDCMD_CONFIGURE           FD_CTL_CODE(0x813, METHOD_BUFFERED)     // 0x0022e04c\n#define IOCTL_FDCMD_LOCK                FD_CTL_CODE(0x814, METHOD_BUFFERED)     // 0x0022e050\n#define IOCTL_FDCMD_VERIFY              FD_CTL_CODE(0x816, METHOD_BUFFERED)     // 0x0022e058\n#define IOCTL_FDCMD_POWERDOWN_MODE      FD_CTL_CODE(0x817, METHOD_BUFFERED)     // 0x0022e05c   (not implemented yet)\n#define IOCTL_FDCMD_PART_ID             FD_CTL_CODE(0x818, METHOD_BUFFERED)     // 0x0022e060\n#define IOCTL_FDCMD_SCAN_LOW_OR_EQUAL   FD_CTL_CODE(0x819, METHOD_IN_DIRECT)    // 0x0022e065   (not implemented yet)\n#define IOCTL_FDCMD_SCAN_HIGH_OR_EQUAL  FD_CTL_CODE(0x81d, METHOD_IN_DIRECT)    // 0x0022e075   (not implemented yet)\n#define IOCTL_FDCMD_SAVE                FD_CTL_CODE(0x82e, METHOD_BUFFERED)     // 0x0022e0b8   (not implemented yet)\n#define IOCTL_FDCMD_OPTION              FD_CTL_CODE(0x833, METHOD_BUFFERED)     // 0x0022e0cc   (not implemented yet)\n#define IOCTL_FDCMD_RESTORE             FD_CTL_CODE(0x84e, METHOD_BUFFERED)     // 0x0022e138   (not implemented yet)\n#define IOCTL_FDCMD_DRIVE_SPEC_CMD      FD_CTL_CODE(0x88e, METHOD_BUFFERED)     // 0x0022e238   (not implemented yet)\n#define IOCTL_FDCMD_RELATIVE_SEEK       FD_CTL_CODE(0x88f, METHOD_BUFFERED)     // 0x0022e23c\n#define IOCTL_FDCMD_FORMAT_AND_WRITE    FD_CTL_CODE(0x8ef, METHOD_BUFFERED)     // 0x0022e3bc   // added in 1.0.1.10\n\n#define IOCTL_FD_SCAN_TRACK             FD_CTL_CODE(0x900, METHOD_BUFFERED)     // 0x0022e400\n#define IOCTL_FD_GET_RESULT             FD_CTL_CODE(0x901, METHOD_BUFFERED)     // 0x0022e404\n#define IOCTL_FD_RESET                  FD_CTL_CODE(0x902, METHOD_BUFFERED)     // 0x0022e408\n#define IOCTL_FD_SET_MOTOR_TIMEOUT      FD_CTL_CODE(0x903, METHOD_BUFFERED)     // 0x0022e40c\n#define IOCTL_FD_SET_DATA_RATE          FD_CTL_CODE(0x904, METHOD_BUFFERED)     // 0x0022e410\n#define IOCTL_FD_GET_FDC_INFO           FD_CTL_CODE(0x905, METHOD_BUFFERED)     // 0x0022e414\n#define IOCTL_FD_GET_REMAIN_COUNT       FD_CTL_CODE(0x906, METHOD_BUFFERED)     // 0x0022e418   // added in 1.0.0.22\n#define IOCTL_FD_SET_DISK_CHECK         FD_CTL_CODE(0x908, METHOD_BUFFERED)     // 0x0022e420\n#define IOCTL_FD_SET_SHORT_WRITE        FD_CTL_CODE(0x909, METHOD_BUFFERED)     // 0x0022e424   // added in 1.0.0.22\n#define IOCTL_FD_SET_SECTOR_OFFSET      FD_CTL_CODE(0x90a, METHOD_BUFFERED)     // 0x0022e428   // added in 1.0.0.22\n#define IOCTL_FD_SET_HEAD_SETTLE_TIME   FD_CTL_CODE(0x90b, METHOD_BUFFERED)     // 0x0022e42c   // added in 1.0.0.22\n#define IOCTL_FD_LOCK_FDC               FD_CTL_CODE(0x910, METHOD_BUFFERED)     // 0x0022e440   // obsolete from 1.0.1.0\n#define IOCTL_FD_UNLOCK_FDC             FD_CTL_CODE(0x911, METHOD_BUFFERED)     // 0x0022e444   // obsolete from 1.0.1.0\n#define IOCTL_FD_MOTOR_ON               FD_CTL_CODE(0x912, METHOD_BUFFERED)     // 0x0022e448\n#define IOCTL_FD_MOTOR_OFF              FD_CTL_CODE(0x913, METHOD_BUFFERED)     // 0x0022e44c\n#define IOCTL_FD_WAIT_INDEX             FD_CTL_CODE(0x914, METHOD_BUFFERED)     // 0x0022e450   // added in 1.0.0.22\n#define IOCTL_FD_TIMED_SCAN_TRACK       FD_CTL_CODE(0x915, METHOD_BUFFERED)     // 0x0022e454   // added in 1.0.0.22\n#define IOCTL_FD_RAW_READ_TRACK         FD_CTL_CODE(0x916, METHOD_OUT_DIRECT)   // 0x0022e45a   // added in 1.0.1.4\n#define IOCTL_FD_CHECK_DISK             FD_CTL_CODE(0x917, METHOD_BUFFERED)     // 0x0022e45c   // added in 1.0.1.10\n#define IOCTL_FD_GET_TRACK_TIME         FD_CTL_CODE(0x918, METHOD_BUFFERED)     // 0x0022e460   // added in 1.0.1.10\n\n///////////////////////////////////////////////////////////////////////////////\n\n// Command flags: multi-track, MFM, sector skip, relative seek direction, verify enable count\n#define FD_OPTION_MT        0x80\n#define FD_OPTION_MFM       0x40\n#define FD_OPTION_SK        0x20\n#define FD_OPTION_DIR       0x40\n#define FD_OPTION_EC        0x01\n#define FD_OPTION_FM        0x00\n#define FD_ENCODING_MASK    FD_OPTION_MFM\n\n// Controller data rates, for use with IOCTL_FD_SET_DATA_RATE\n#define FD_RATE_MASK        3\n#define FD_RATE_500K        0\n#define FD_RATE_300K        1\n#define FD_RATE_250K        2\n#define FD_RATE_1M          3\n\n// FD_FDC_INFO controller types\n#define FDC_TYPE_UNKNOWN    0\n#define FDC_TYPE_UNKNOWN2   1\n#define FDC_TYPE_NORMAL     2\n#define FDC_TYPE_ENHANCED   3\n#define FDC_TYPE_82077      4\n#define FDC_TYPE_82077AA    5\n#define FDC_TYPE_82078_44   6\n#define FDC_TYPE_82078_64   7\n#define FDC_TYPE_NATIONAL   8\n\n// Bits representing supported data rates, for the FD_FDC_INFO structure below\n#define FDC_SPEED_250K      0x01\n#define FDC_SPEED_300K      0x02\n#define FDC_SPEED_500K      0x04\n#define FDC_SPEED_1M        0x08\n#define FDC_SPEED_2M        0x10\n\n\n#pragma pack(push,1)\n#pragma warning(push)\n#pragma warning(disable:4200)           // allow zero-sized arrays\n\n\ntypedef struct tagFD_ID_HEADER\n{\n    BYTE cyl, head, sector, size;\n}\nFD_ID_HEADER, *PFD_ID_HEADER;\n\ntypedef struct tagFD_SEEK_PARAMS\n{\n    BYTE cyl;\n    BYTE head;\n}\nFD_SEEK_PARAMS, *PFD_SEEK_PARAMS;\n\ntypedef struct tagFD_RELATIVE_SEEK_PARAMS\n{\n    BYTE flags;                         // DIR\n    BYTE head;\n    BYTE offset;\n}\nFD_RELATIVE_SEEK_PARAMS, *PFD_RELATIVE_SEEK_PARAMS;\n\ntypedef struct tagFD_READ_WRITE_PARAMS\n{\n    BYTE flags;                         // MT MFM SK\n    BYTE phead;\n    BYTE cyl, head, sector, size;\n    BYTE eot, gap, datalen;\n}\nFD_READ_WRITE_PARAMS, *PFD_READ_WRITE_PARAMS;\n\ntypedef struct tagFD_CMD_RESULT\n{\n    BYTE st0, st1, st2;\n    BYTE cyl, head, sector, size;\n}\nFD_CMD_RESULT, *PFD_CMD_RESULT;\n\ntypedef struct tagFD_FORMAT_PARAMS\n{\n    BYTE flags;                         // MFM\n    BYTE phead;\n    BYTE size, sectors, gap, fill;\n\n    FD_ID_HEADER Header[];\n}\nFD_FORMAT_PARAMS, *PFD_FORMAT_PARAMS;\n\ntypedef struct tagFD_READ_ID_PARAMS\n{\n    BYTE flags;                         // MFM\n    BYTE head;\n}\nFD_READ_ID_PARAMS, *PFD_READ_ID_PARAMS;\n\ntypedef struct tagFD_CONFIGURE_PARAMS\n{\n    BYTE eis_efifo_poll_fifothr;        // b6 = enable implied seek, b5 = enable fifo, b4 = poll disable, b3-b0 = fifo threshold\n    BYTE pretrk;                        // precompensation start track\n}\nFD_CONFIGURE_PARAMS, *PFD_CONFIGURE_PARAMS;\n\ntypedef struct tagFD_SPECIFY_PARAMS\n{\n    BYTE srt_hut;                       // b7-b4 = step rate, b3-b0 = head unload time\n    BYTE hlt_nd;                        // b7-b1 = head load time, b0 = non-DMA flag (unsupported)\n}\nFD_SPECIFY_PARAMS, *PFD_SPECIFY_PARAMS;\n\ntypedef struct tagFD_SENSE_PARAMS\n{\n    BYTE head;\n}\nFD_SENSE_PARAMS, *PFD_SENSE_PARAMS;\n\ntypedef struct tagFD_DRIVE_STATUS\n{\n    BYTE st3;\n}\nFD_DRIVE_STATUS, *PFD_DRIVE_STATUS;\n\ntypedef struct tagFD_INTERRUPT_STATUS\n{\n    BYTE st0;                           // status register 0\n    BYTE pcn;                           // present cylinder number\n}\nFD_INTERRUPT_STATUS, *PFD_INTERRUPT_STATUS;\n\ntypedef struct tagFD_PERPENDICULAR_PARAMS\n{\n    BYTE ow_ds_gap_wgate;               // b7 = OW, b6 = 0, b5-b2 = drive select, b1 = gap2, b0 = write gate pre-erase loads\n}\nFD_PERPENDICULAR_PARAMS, *PFD_PERPENDICULAR_PARAMS;\n\ntypedef struct tagFD_LOCK_PARAMS\n{\n    BYTE lock;                          // b7 = lock\n}\nFD_LOCK_PARAMS, *PFD_LOCK_PARAMS;\n\ntypedef struct tagFD_LOCK_RESULT\n{\n    BYTE lock;                          // b4 = lock\n}\nFD_LOCK_RESULT, *PFD_LOCK_RESULT;\n\ntypedef struct tagFD_DUMPREG_RESULT\n{\n    BYTE pcn0, pcn1, pcn2, pcn3;        // present cylinder numbers\n    BYTE srt_hut;                       // b7-4 = step rate, b3-0 = head unload time\n    BYTE hlt_nd;                        // b7-1 = head load time, b0 = non-dma mode\n    BYTE sceot;                         // sector count / end of track\n    BYTE lock_d0123_gap_wgate;          // b7 = setting lock, b5-2 = drive selects, b1 = gap 2 (perpendicular), b0 = write gate\n    BYTE eis_efifo_poll_fifothr;        // b6 = implied seeks, b5 = fifo enable, b4 = poll disable, b3-0 = fifo threshold\n    BYTE pretrk;                        // pre-comp start track\n}\nFD_DUMPREG_RESULT, *PFD_DUMPREG_RESULT;\n\ntypedef struct tagFD_SECTOR_OFFSET_PARAMS\n{\n    BYTE sectors;                       // number of sectors to skip after index\n}\nFD_SECTOR_OFFSET_PARAMS, *PFD_SECTOR_OFFSET_PARAMS;\n\ntypedef struct tagFD_SHORT_WRITE_PARAMS\n{\n    DWORD length;                       // length to write before interrupting\n    DWORD finetune;                     // finetune delay in microseconds\n}\nFD_SHORT_WRITE_PARAMS, *PFD_SHORT_WRITE_PARAMS;\n\ntypedef struct tagFD_SCAN_PARAMS\n{\n    BYTE flags;                         // MFM\n    BYTE head;\n}\nFD_SCAN_PARAMS, *PFD_SCAN_PARAMS;\n\ntypedef struct tagFD_SCAN_RESULT\n{\n    BYTE count;                         // count of returned headers\n    FD_ID_HEADER Header[];              // array of 'count' id fields\n}\nFD_SCAN_RESULT, *PFD_SCAN_RESULT;\n\n\ntypedef struct tagFD_TIMED_ID_HEADER\n{\n    DWORD reltime;                      // time relative to index (in microseconds)\n    BYTE cyl, head, sector, size;\n}\nFD_TIMED_ID_HEADER, *PFD_TIMED_ID_HEADER;\n\ntypedef struct tagFD_TIMED_SCAN_RESULT\n{\n    BYTE count;                         // count of returned headers\n    BYTE firstseen;                     // offset of first sector detected\n    DWORD tracktime;                    // total time for track (in microseconds)\n    FD_TIMED_ID_HEADER Header[];        // array of 'count' id fields\n}\nFD_TIMED_SCAN_RESULT, *PFD_TIMED_SCAN_RESULT;\n\ntypedef struct tagFD_FDC_INFO\n{\n    BYTE ControllerType;                // FDC_TYPE_*\n    BYTE SpeedsAvailable;               // FDC_SPEED_* values ORed together\n\n    BYTE BusType;\n    DWORD BusNumber;\n    DWORD ControllerNumber;\n    DWORD PeripheralNumber;\n}\nFD_FDC_INFO, *PFD_FDC_INFO;\n\ntypedef struct tagFD_RAW_READ_PARAMS\n{\n    BYTE flags;                         // MFM\n    BYTE head, size;\n}\nFD_RAW_READ_PARAMS, *PFD_RAW_READ_PARAMS;\n\n\n#pragma warning(pop)\n#pragma pack(pop)\n\n#endif  // FDRAWCMD_H\n\n", "comment_ratio": 0.33}
{"lang": "c", "code": "#pragma once\n\n#include <memory>\n#include <SFML/System.hpp>\n#include \"Graphics/AnimatedSprite.h\"\n#include \"Resources/AssetId.h\"\n\nnamespace OBJECTS\n{\n    /// A cloud of dust that appears after a tree has been chopped down and\n    /// before it has turned into wooden logs.  The cloud is animated and\n    /// only lasts for a short time during this transition.\n    class DustCloud\n    {\n    public:\n        // CONSTRUCTION.\n        explicit DustCloud(const RESOURCES::AssetId texture_id);\n\n        // STATUS QUERYING.\n        bool HasDisappeared() const;\n\n        // UPDATING.\n        void Update(const sf::Time& elapsed_time);\n\n        // PUBLIC MEMBER VARIABLES FOR EASY ACCESS.\n        /// The graphical sprite for the dust cloud.\n        GRAPHICS::AnimatedSprite Sprite;\n        /// The total time the cloud has been in existence.\n        /// Increased during each update call.\n        float TotalElapsedTimeInSeconds;\n    };\n}\n\n", "comment_ratio": 0.30303030303030304}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface BUDAdmob_PangleTool : NSObject\n+ (void)setPangleExtData;\n@end\n\nNS_ASSUME_NONNULL_END\n\n", "comment_ratio": 0.3888888888888889}
{"lang": "c", "code": "#pragma once\n\n#define MBUF_SIZE               8192\n#define MBUF_DEFAULT_HEADROOM   128\n\nstruct mbuf {\n\tuint32_t     raddr;\n\tstruct mbuf* next;\n\tchar*        head;\n\tunsigned int len;\n\tchar         buf[MBUF_SIZE];\n\tunion {\n\t\tstruct {\n\t\t\tuint32_t sndnxt;\n\t\t\tuint8_t  flg;\n\t\t\tuint16_t datalen;\n\t\t} tcp;\n\t}            params;\n\tstruct tcp*  tcphdr;\n\tvoid*        protodata;\n};\n\nchar *mbufpull(struct mbuf *m, unsigned int len);\n\nchar *mbufpush(struct mbuf *m, unsigned int len);\nchar *mbufput(struct mbuf *m, unsigned int len);\nchar *mbuftrim(struct mbuf *m, unsigned int len);\n\n// The above functions manipulate the size and position of the buffer:\n//            <- push            <- trim\n//             -> pull            -> put\n// [-headroom-][------buffer------][-tailroom-]\n// |----------------MBUF_SIZE-----------------|\n//\n// These marcos automatically typecast and determine the size of header structs.\n// In most situations you should use these instead of the raw ops above.\n#define mbufpullhdr(mbuf, hdr) (typeof(hdr)*)mbufpull(mbuf, sizeof(hdr))\n#define mbufpushhdr(mbuf, hdr) (typeof(hdr)*)mbufpush(mbuf, sizeof(hdr))\n#define mbufputhdr(mbuf, hdr) (typeof(hdr)*)mbufput(mbuf, sizeof(hdr))\n#define mbuftrimhdr(mbuf, hdr) (typeof(hdr)*)mbuftrim(mbuf, sizeof(hdr))\n\nstruct mbuf *mbufalloc(unsigned int headroom);\nvoid mbuffree(struct mbuf *m);\nstruct mbuf *mbuf_copy(struct mbuf *m);\n\nstruct mbufq {\n\tstruct mbuf *head;  // the first element in the queue\n\tstruct mbuf *tail;  // the last element in the queue\n};\n\nvoid mbufq_pushtail(struct mbufq *q, struct mbuf *m);\nvoid mbufq_pushhead(struct mbufq *q, struct mbuf *m);\nstruct mbuf *mbufq_pophead(struct mbufq *q);\nint mbufq_empty(struct mbufq *q);\nvoid mbufq_init(struct mbufq *q);\n\n\n", "comment_ratio": 0.17543859649122806}
{"lang": "c", "code": "#import \"CDStructures.h\"\n\n@protocol IDEPreBuildSavingDelegate <NSObject>\n- (void)performBlockAfterPreBuildSave:(void (^)(void))arg1;\n@end\n\n\n", "comment_ratio": 0.38461538461538464}
{"lang": "c", "code": "#import \"NSObject-Protocol.h\"\n\n@class MessageData;\n\n@protocol VoiceDownloadTaskDelegate <NSObject>\n- (void)onVoiceDowloadFinished:(MessageData *)arg1 isSuccess:(BOOL)arg2 isNeedSave:(BOOL)arg3 offset:(unsigned long long)arg4 taskId:(unsigned long long)arg5;\n\n@optional\n- (void)onVoiceUploadCanceledWhenDownloading:(MessageData *)arg1 taskId:(unsigned long long)arg2;\n- (void)onFailedToParseXMLWhenDownloading:(MessageData *)arg1 taskId:(unsigned long long)arg2;\n@end\n\n\n", "comment_ratio": 0.2631578947368421}
{"lang": "c", "code": "/**\n * TextMagic API\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 2\n * \n *\n * NOTE: This class is auto generated by the swagger code generator 2.4.8.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\n\n/*\n * SendPhoneVerificationCodeInputObject.h\n *\n * \n */\n\n#ifndef COM_TEXTMAGIC_CLIENT_MODEL_SendPhoneVerificationCodeInputObject_H_\n#define COM_TEXTMAGIC_CLIENT_MODEL_SendPhoneVerificationCodeInputObject_H_\n\n\n#include \"../ModelBase.h\"\n\n#include <cpprest/details/basic_types.h>\n\nnamespace com {\nnamespace textmagic {\nnamespace client {\nnamespace model {\n\n/// <summary>\n/// \n/// </summary>\nclass  SendPhoneVerificationCodeInputObject\n    : public ModelBase\n{\npublic:\n    SendPhoneVerificationCodeInputObject();\n    virtual ~SendPhoneVerificationCodeInputObject();\n\n    /////////////////////////////////////////////\n    /// ModelBase overrides\n\n    void validate() override;\n\n    web::json::value toJson() const override;\n    void fromJson(web::json::value& json) override;\n\n    void toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& namePrefix) const override;\n    void fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& namePrefix) override;\n\n    /////////////////////////////////////////////\n    /// SendPhoneVerificationCodeInputObject members\n\n    /// <summary>\n    /// Use the phone number in international E.164 format. If you need to pass phone numbers in the local format, please use them with the **country** parameter to specify the origin country of the phone number. \n    /// </summary>\n    utility::string_t getPhone() const;\n        void setPhone(utility::string_t value);\n    /// <summary>\n    /// Alphanumeric string with up to 18 characters you can use to personalize the verification text message body, to help users identify your company or application name. For example: \u201cYour TextMagic PIN is \u2026\u201d \n    /// </summary>\n    utility::string_t getBrand() const;\n        void setBrand(utility::string_t value);\n    /// <summary>\n    /// The length of the verification code. The value can be 4 or 6 characters. \n    /// </summary>\n    int32_t getCodeLength() const;\n        void setCodeLength(int32_t value);\n    /// <summary>\n    /// By default, the SMS or text-to-speech (TTS) voice message is generated in the locale that matches the number. For example, the text message or TTS message for a 33\\\\* number is sent in French. Use this parameter to explicitly control the language, accent, and gender used for the verification request.Can be one of the following: &#x60;de-de&#x60;, &#x60;en-au&#x60;, &#x60;en-gb&#x60;, &#x60;en-us&#x60;, &#x60;en-in&#x60;, &#x60;es-es&#x60;, &#x60;es-mx&#x60;, &#x60;es-us&#x60;, &#x60;fr-ca&#x60;, &#x60;fr-fr&#x60;, &#x60;is-is&#x60;, &#x60;it-it&#x60;, &#x60;ja-jp&#x60;, &#x60;ko-kr&#x60;, &#x60;nl-nl&#x60;, &#x60;pl-pl&#x60;, &#x60;pt-pt&#x60;, &#x60;pt-br&#x60;, &#x60;ro-ro&#x60;, &#x60;ru-ru&#x60;, &#x60;sv-se&#x60;, &#x60;tr-tr&#x60;, &#x60;zh-cn&#x60; or &#x60;zh-tw&#x60;. \n    /// </summary>\n    utility::string_t getLanguage() const;\n    bool languageIsSet() const;\n    void unsetLanguage();\n    void setLanguage(utility::string_t value);\n    /// <summary>\n    /// One of the available [sender settings](https://my.textmagic.com/online/reply-options/) on your TextMagic account. If specified sender setting type is not allowed for some destinations, a fallback default sender will be used to ensure the message delivery. More info about known restrictions can be found [here](https://support.textmagic.com/article/how-to-understand-sender-setting-restrictions/). \n    /// </summary>\n    utility::string_t getSenderId() const;\n    bool senderIdIsSet() const;\n    void unsetSenderId();\n    void setSenderId(utility::string_t value);\n    /// <summary>\n    /// 2-letter ISO country code for local phone number.\n    /// </summary>\n    utility::string_t getCountry() const;\n    bool countryIsSet() const;\n    void unsetCountry();\n    void setCountry(utility::string_t value);\n\nprotected:\n    utility::string_t m_Phone;\n        utility::string_t m_Brand;\n        int32_t m_CodeLength;\n        utility::string_t m_Language;\n    bool m_LanguageIsSet;\n    utility::string_t m_SenderId;\n    bool m_SenderIdIsSet;\n    utility::string_t m_Country;\n    bool m_CountryIsSet;\n};\n\n}\n}\n}\n}\n\n#endif /* COM_TEXTMAGIC_CLIENT_MODEL_SendPhoneVerificationCodeInputObject_H_ */\n\n", "comment_ratio": 0.24324324324324326}
{"lang": "c", "code": "#import \"NSObject.h\"\n\n#import \"NSSecureCoding.h\"\n\n@class NSDictionary, NSString, NSURL;\n\n@interface IASBootTimeInstallableItem : NSObject <NSSecureCoding>\n{\n    NSString *_interfaceType;\n    NSDictionary *_evaluatorMetaInfo;\n    NSURL *_productURL;\n    NSString *_clientIdentifier;\n}\n\n+ (BOOL)supportsSecureCoding;\n@property(copy) NSString *clientIdentifier; // @synthesize clientIdentifier=_clientIdentifier;\n@property(copy) NSURL *productURL; // @synthesize productURL=_productURL;\n@property(copy) NSDictionary *evaluatorMetaInfo; // @synthesize evaluatorMetaInfo=_evaluatorMetaInfo;\n@property(copy) NSString *interfaceType; // @synthesize interfaceType=_interfaceType;\n- (void).cxx_destruct;\n- (unsigned long long)hash;\n- (BOOL)isEqual:(id)arg1;\n- (BOOL)isEqualToInstallableItem:(id)arg1;\n- (void)encodeWithCoder:(id)arg1;\n- (id)initWithCoder:(id)arg1;\n- (id)initWithProductAtURL:(id)arg1 error:(id *)arg2;\n- (id)init;\n\n@end\n\n\n", "comment_ratio": 0.24324324324324326}
{"lang": "c", "code": "#pragma once\n#include <aws/inspector/Inspector_EXPORTS.h>\n#include <aws/core/utils/memory/stl/AWSString.h>\n\nnamespace Aws\n{\nnamespace Inspector\n{\nnamespace Model\n{\n  enum class StopAction\n  {\n    NOT_SET,\n    START_EVALUATION,\n    SKIP_EVALUATION\n  };\n\nnamespace StopActionMapper\n{\nAWS_INSPECTOR_API StopAction GetStopActionForName(const Aws::String& name);\n\nAWS_INSPECTOR_API Aws::String GetNameForStopAction(StopAction value);\n} // namespace StopActionMapper\n} // namespace Model\n} // namespace Inspector\n} // namespace Aws\n\n", "comment_ratio": 0.11904761904761904}
{"lang": "c", "code": "#ifndef GPU_COMMAND_BUFFER_SERVICE_GLES2_CMD_VALIDATION_H_\n#define GPU_COMMAND_BUFFER_SERVICE_GLES2_CMD_VALIDATION_H_\n\n#include \"gpu/command_buffer/common/gles2_cmd_format.h\"\n#include \"gpu/command_buffer/service/value_validator.h\"\n\nnamespace gpu {\nnamespace gles2 {\n\nstruct Validators {\n  Validators();\n\n  void UpdateValuesES3();\n  void UpdateETCCompressedTextureFormats();\n\n#include \"gpu/command_buffer/service/gles2_cmd_validation_autogen.h\"\n};\n\n}  // namespace gles2\n}  // namespace gpu\n\n#endif  // GPU_COMMAND_BUFFER_SERVICE_GLES2_CMD_VALIDATION_H_\n\n\n", "comment_ratio": 0.23333333333333334}
{"lang": "c", "code": "\n#include \"xparameters.h\"\n#include \"xil_io.h\"\n#include \"xstatus.h\"\n#include \"xscugic.h\"\n#include \"xil_exception.h\"\n#include \"opendla.h\"\n\n\n/************************** Constant Definitions *****************************/\n/* The following constant maps to the name of the hardware instances that\n * were created in the Vivado system design. */\n#define NVDLA_BASE_ADDRESS             0xA0030000\n#define PS_DDR0_BASE_ADDRESS           0x00000000\n#define PS_DDR1_BASE_ADDRESS           0x800000000\n#define base_addr                      0x40000000\n\n\nint nv_small_run(void)\n{\n    unsigned int memory_value;\n\t    \n    /*\n    printf(\"***********************\\n\");\n    printf(\"Begin NVDLA NV_SMALL Register Setting\\n\");\n    printf(\"***********************\\n\");\n    */\n    //mem_load(base_addr + 0x0, \"CONV_SDP_0_input.dat\");\n    //mem_load(base_addr + 0x40000, \"CONV_SDP_0_weight.dat\");\n    reg_write(NVDLA_CDMA_S_POINTER_0, 0x0);\n    reg_write(NVDLA_SDP_S_POINTER_0, 0x0);\n    reg_write(NVDLA_CSC_S_POINTER_0, 0x0);\n    reg_write(NVDLA_CMAC_B_S_POINTER_0, 0x0);\n    reg_write(NVDLA_CACC_S_POINTER_0, 0x0);\n    reg_write(NVDLA_CMAC_A_S_POINTER_0, 0x0);\n    reg_write(NVDLA_SDP_S_LUT_LO_SLOPE_SCALE_0, 0x0);\n    reg_write(NVDLA_SDP_S_LUT_LO_SLOPE_SHIFT_0, 0x0);\n    reg_write(NVDLA_SDP_S_LUT_ACCESS_DATA_0, 0x0);\n    reg_write(NVDLA_SDP_S_LUT_LE_START_0, 0x0);\n    reg_write(NVDLA_SDP_S_LUT_LE_SLOPE_SCALE_0, 0x0);\n    reg_write(NVDLA_SDP_S_LUT_INFO_0, 0x0);\n    reg_write(NVDLA_SDP_S_LUT_LE_SLOPE_SHIFT_0, 0x0);\n    reg_write(NVDLA_SDP_S_LUT_LO_END_0, 0x0);\n    reg_write(NVDLA_SDP_S_LUT_LO_START_0, 0x0);\n    reg_write(NVDLA_SDP_S_LUT_ACCESS_CFG_0, 0x0);\n    reg_write(NVDLA_SDP_S_LUT_CFG_0, 0x0);\n    reg_write(NVDLA_SDP_S_LUT_LE_END_0, 0x0);\n    reg_write(NVDLA_CDMA_D_RESERVED_X_CFG_0, 0x0);\n    reg_write(NVDLA_CDMA_D_BANK_0, 0x70007);\n    reg_write(NVDLA_CSC_D_DILATION_EXT_0, 0x0);\n    reg_write(NVDLA_CDMA_D_ZERO_PADDING_0, 0x0);\n    reg_write(NVDLA_CSC_D_ATOMICS_0, 0x23L);\n    reg_write(NVDLA_CSC_D_RELEASE_0, 0x7);\n    reg_write(NVDLA_SDP_D_DP_EW_MUL_CVT_TRUNCATE_VALUE_0, 0x0);\n    reg_write(NVDLA_SDP_D_PERF_ENABLE_0, 0x0);\n    reg_write(NVDLA_SDP_D_DST_LINE_STRIDE_0, 0x30L);\n    reg_write(NVDLA_SDP_D_DP_BS_ALU_CFG_0, 0x0);\n    reg_write(NVDLA_CSC_D_DATAIN_SIZE_EXT_0_0, 0x70007L);\n    reg_write(NVDLA_CACC_D_DATAOUT_SIZE_1_0, 0x1f);\n    reg_write(NVDLA_CDMA_D_RESERVED_Y_CFG_0, 0x0);\n    reg_write(NVDLA_CSC_D_CONV_STRIDE_EXT_0, 0x0);\n    reg_write(NVDLA_SDP_D_DATA_CUBE_HEIGHT_0, 0x5L);\n    reg_write(NVDLA_SDP_D_DST_SURFACE_STRIDE_0, 0x120L);\n    reg_write(NVDLA_CDMA_D_DAIN_ADDR_LOW_0_0, base_addr + 0x0);\n    reg_write(NVDLA_SDP_D_DP_EW_ALU_SRC_VALUE_0, 0x0);\n    reg_write(NVDLA_SDP_D_DP_BS_ALU_SRC_VALUE_0, 0x0);\n    reg_write(NVDLA_SDP_D_DP_BS_MUL_SRC_VALUE_0, 0x0);\n    reg_write(NVDLA_SDP_D_DP_EW_MUL_CFG_0, 0x2);\n    reg_write(NVDLA_CSC_D_DATAOUT_SIZE_0_0, 0x50005L);\n    reg_write(NVDLA_CDMA_D_WGS_ADDR_HIGH_0, 0x0);\n    reg_write(NVDLA_CACC_D_CYA_0, 0x0);\n    reg_write(NVDLA_CDMA_D_BATCH_STRIDE_0, 0x0);\n    reg_write(NVDLA_CDMA_D_CVT_SCALE_0, 0x0);\n    reg_write(NVDLA_SDP_D_DP_EW_TRUNCATE_VALUE_0, 0x0);\n    reg_write(NVDLA_CDMA_D_CONV_STRIDE_0, 0x0);\n    reg_write(NVDLA_CDMA_D_DAIN_ADDR_HIGH_0_0, 0x0);\n    reg_write(NVDLA_SDP_D_DP_EW_CFG_0, 0x53);\n    reg_write(NVDLA_CACC_D_CLIP_CFG_0, 0x0);\n    reg_write(NVDLA_SDP_D_DP_BS_CFG_0, 0x73);\n    reg_write(NVDLA_CSC_D_WEIGHT_SIZE_EXT_0_0, 0x20002);\n    reg_write(NVDLA_CDMA_D_WEIGHT_SIZE_0_0, 0x11fL);\n    reg_write(NVDLA_CSC_D_PRA_CFG_0, 0x0);\n    reg_write(NVDLA_CDMA_D_WMB_BYTES_0, 0x0);\n    reg_write(NVDLA_SDP_D_DP_EW_ALU_CFG_0, 0x2);\n    reg_write(NVDLA_CDMA_D_MEAN_GLOBAL_0_0, 0x0);\n    reg_write(NVDLA_SDP_D_DP_BN_MUL_SRC_VALUE_0, 0x0);\n    reg_write(NVDLA_CACC_D_BATCH_NUMBER_0, 0x0);\n    reg_write(NVDLA_CSC_D_BANK_0, 0x70007);\n    reg_write(NVDLA_CDMA_D_MEAN_FORMAT_0, 0x0);\n    reg_write(NVDLA_CSC_D_ENTRY_PER_SLICE_0, 0x1f);\n    reg_write(NVDLA_CSC_D_WMB_BYTES_0, 0x0);\n    reg_write(NVDLA_SDP_D_DST_BASE_ADDR_HIGH_0, 0x0);\n    reg_write(NVDLA_CACC_D_DATAOUT_MAP_0, 0x10001);\n    reg_write(NVDLA_CDMA_D_DAIN_ADDR_LOW_1_0, base_addr + 0x80000000);\n    reg_write(NVDLA_CDMA_D_DATAIN_SIZE_0_0, 0x70007L);\n    reg_write(NVDLA_SDP_D_CVT_SHIFT_0, 0x0);\n    reg_write(NVDLA_CSC_D_CYA_0, 0x0);\n    reg_write(NVDLA_CDMA_D_ENTRY_PER_SLICE_0, 0x1f);\n    reg_write(NVDLA_CACC_D_DATAOUT_ADDR_0, 0x0);\n    reg_write(NVDLA_CACC_D_SURF_STRIDE_0, 0x200L);\n    reg_write(NVDLA_SDP_D_DP_BN_CFG_0, 0x53);\n    reg_write(NVDLA_SDP_D_DST_BATCH_STRIDE_0, 0x0);\n    reg_write(NVDLA_CDMA_D_SURF_STRIDE_0, 0x200L);\n    reg_write(NVDLA_SDP_D_DP_EW_MUL_CVT_SCALE_VALUE_0, 0x0);\n    reg_write(NVDLA_CSC_D_MISC_CFG_0, 0x0);\n    reg_write(NVDLA_CSC_D_DATAOUT_SIZE_1_0, 0x1f);\n    reg_write(NVDLA_CDMA_D_LINE_UV_STRIDE_0, 0x0);\n    reg_write(NVDLA_CDMA_D_CVT_OFFSET_0, 0x0);\n    reg_write(NVDLA_CDMA_D_WMB_ADDR_LOW_0, base_addr + 0x80000000);\n    reg_write(NVDLA_CSC_D_WEIGHT_SIZE_EXT_1_0, 0x1f001fL);\n    reg_write(NVDLA_CSC_D_BATCH_NUMBER_0, 0x0);\n    reg_write(NVDLA_CDMA_D_WEIGHT_ADDR_HIGH_0, 0x0);\n    reg_write(NVDLA_CDMA_D_WEIGHT_RAM_TYPE_0, 0x1);\n    reg_write(NVDLA_CDMA_D_DAIN_ADDR_HIGH_1_0, 0x0);\n    reg_write(NVDLA_CDMA_D_LINE_STRIDE_0, 0x40L);\n    reg_write(NVDLA_SDP_D_DST_DMA_CFG_0, 0x1);\n    reg_write(NVDLA_CDMA_D_MEAN_GLOBAL_1_0, 0x0);\n    reg_write(NVDLA_SDP_D_DP_EW_ALU_CVT_OFFSET_VALUE_0, 0x0);\n    reg_write(NVDLA_CDMA_D_WEIGHT_ADDR_LOW_0, base_addr + 0x40000);\n    reg_write(NVDLA_SDP_D_DP_EW_ALU_CVT_SCALE_VALUE_0, 0x0);\n    reg_write(NVDLA_CDMA_D_DATAIN_FORMAT_0, 0xc00);\n    reg_write(NVDLA_CDMA_D_WEIGHT_SIZE_1_0, 0x1f);\n    reg_write(NVDLA_CSC_D_WEIGHT_FORMAT_0, 0x0);\n    reg_write(NVDLA_CDMA_D_DATAIN_SIZE_1_0, 0x1fL);\n    reg_write(NVDLA_CDMA_D_WGS_ADDR_LOW_0, base_addr + 0x80000000);\n    reg_write(NVDLA_CDMA_D_DAIN_RAM_TYPE_0, 0x1);\n    reg_write(NVDLA_SDP_D_DP_BN_MUL_CFG_0, 0x0);\n    reg_write(NVDLA_CDMA_D_CYA_0, 0x0);\n    reg_write(NVDLA_CACC_D_MISC_CFG_0, 0x0);\n    reg_write(NVDLA_CSC_D_WEIGHT_BYTES_0, 0x2400);\n    reg_write(NVDLA_CDMA_D_PERF_ENABLE_0, 0x0);\n    reg_write(NVDLA_CDMA_D_NAN_FLUSH_TO_ZERO_0, 0x0);\n    reg_write(NVDLA_CDMA_D_DAIN_MAP_0, 0x10001);\n    reg_write(NVDLA_CSC_D_DATAIN_SIZE_EXT_1_0, 0x1fL);\n    reg_write(NVDLA_SDP_D_DP_BS_MUL_CFG_0, 0x0);\n    reg_write(NVDLA_CDMA_D_WMB_ADDR_HIGH_0, 0x0);\n    reg_write(NVDLA_CDMA_D_PIXEL_OFFSET_0, 0x0);\n    reg_write(NVDLA_SDP_D_DP_EW_MUL_CVT_OFFSET_VALUE_0, 0x0);\n    reg_write(NVDLA_SDP_D_DST_BASE_ADDR_LOW_0, base_addr + 0x80000);\n    reg_write(NVDLA_SDP_D_DP_EW_ALU_CVT_TRUNCATE_VALUE_0, 0x0);\n    reg_write(NVDLA_SDP_D_DP_BN_ALU_CFG_0, 0x0);\n    reg_write(NVDLA_CDMA_D_FETCH_GRAIN_0, 0x0);\n    reg_write(NVDLA_SDP_D_CVT_OFFSET_0, 0x0);\n    reg_write(NVDLA_SDP_D_DATA_CUBE_WIDTH_0, 0x5L);\n    reg_write(NVDLA_CACC_D_LINE_STRIDE_0, 0x40L);\n    reg_write(NVDLA_SDP_D_DP_EW_MUL_SRC_VALUE_0, 0x0);\n    reg_write(NVDLA_CDMA_D_WEIGHT_BYTES_0, 0x2400);\n    reg_write(NVDLA_CMAC_B_D_MISC_CFG_0, 0x0);\n    reg_write(NVDLA_CACC_D_DATAOUT_SIZE_0_0, 0x50005L);\n    reg_write(NVDLA_CMAC_A_D_MISC_CFG_0, 0x0);\n    reg_write(NVDLA_SDP_D_DATA_CUBE_CHANNEL_0, 0x1f);\n    reg_write(NVDLA_SDP_D_DATA_FORMAT_0, 0x0);\n    reg_write(NVDLA_CDMA_S_ARBITER_0, 0x3000f);\n    reg_write(NVDLA_SDP_D_FEATURE_MODE_CFG_0, 0x1);\n    reg_write(NVDLA_CDMA_D_CVT_CFG_0, 0x0);\n    reg_write(NVDLA_CDMA_D_WEIGHT_FORMAT_0, 0x0);\n    reg_write(NVDLA_CDMA_D_ZERO_PADDING_VALUE_0, 0x0);\n    reg_write(NVDLA_SDP_D_DP_BN_ALU_SRC_VALUE_0, 0x0);\n    reg_write(NVDLA_SDP_D_CVT_SCALE_0, 0x1);\n    reg_write(NVDLA_CDMA_D_BATCH_NUMBER_0, 0x0);\n    reg_write(NVDLA_CDMA_D_MISC_CFG_0, 0x0);\n    reg_write(NVDLA_CSC_D_ZERO_PADDING_VALUE_0, 0x0);\n    reg_write(NVDLA_CSC_D_DATAIN_FORMAT_0, 0x0);\n    reg_write(NVDLA_CDMA_D_DATAIN_SIZE_EXT_0_0, 0x70007L);\n    // for test\n    //poll_reg_equal(NVDLA_CDMA_D_DATAIN_SIZE_EXT_0_0, 0x70007L);\n    //poll_field_not_equal(NVDLA_CDMA_D_DATAIN_SIZE_EXT_0_0, 0x0ffff, 0x70007L);\n    //printf(\"NVDLA_CDMA_D_DATAIN_SIZE_EXT_0_0 (0x%08x@0x%02x):\\n\", memory_value, NVDLA_BASE_ADDRESS + NVDLA_SDP_RDMA_D_BS_BATCH_STRIDE_0);\n    reg_write(NVDLA_CSC_D_ZERO_PADDING_0, 0x0);\n    reg_write(NVDLA_CSC_D_POST_Y_EXTENSION_0, 0x0);\n    poll_reg_equal(NVDLA_CDMA_S_CBUF_FLUSH_STATUS_0, 0x1);\n    reg_write(NVDLA_CDMA_D_OP_ENABLE_0, 0x1);\n    reg_write(NVDLA_CACC_D_OP_ENABLE_0, 0x1);\n    //sync_notify(NVDLA_CACC, CONV_SDP_0_NVDLA_CACC_D_OP_ENABLE_0);\n    //sync_wait(NVDLA_CMAC_A, CONV_SDP_0_NVDLA_CACC_D_OP_ENABLE_0);\n    reg_write(NVDLA_CMAC_A_D_OP_ENABLE_0, 0x1);\n    //sync_notify(NVDLA_CMAC_A, CONV_SDP_0_NVDLA_CMAC_A_D_OP_ENABLE_0);\n    //sync_wait(NVDLA_CMAC_B, CONV_SDP_0_NVDLA_CACC_D_OP_ENABLE_0);\n    reg_write(NVDLA_CMAC_B_D_OP_ENABLE_0, 0x1);\n    //sync_notify(NVDLA_CMAC_B, CONV_SDP_0_NVDLA_CMAC_B_D_OP_ENABLE_0);\n    //sync_wait(NVDLA_CSC, CONV_SDP_0_NVDLA_CMAC_A_D_OP_ENABLE_0);\n    //sync_wait(NVDLA_CSC, CONV_SDP_0_NVDLA_CMAC_B_D_OP_ENABLE_0);\n    reg_write(NVDLA_CSC_D_OP_ENABLE_0, 0x1);\n    reg_write(NVDLA_SDP_D_OP_ENABLE_0, 0x1);\n    //intr_notify(SDP_0, 0x1);\n    //intr_notify(CACC_0, 0x2);\n    //intr_notify(CDMA_DAT_0, 0x3);\n    //intr_notify(CDMA_WT_0, 0x4);\n    //check_file(0x1, base_addr + 0x80000, 0x480, \"CONV_SDP_0_output.dat\");\n    //check_nothing(0x2);\n    //check_nothing(0x4);\n    //check_nothing(0x3);\n\n\n\n\n\n\n\n\n    printf(\"***********************\\n\");\n    printf(\"Finish NVDLA NV_SMALL Register Setting\\n\");\n    printf(\"***********************\\n\");\n\n\n/*\t    \n\t    //get value\n    \tmemory_value= memory_get(NVDLA_BASE_ADDRESS, NVDLA_SDP_RDMA_D_BS_BATCH_STRIDE_0);\n    \tprintf(\"NVDLA_SDP_RDMA_D_BS_BATCH_STRIDE_0 (0x%08x@0x%02x):\\n\", memory_value, NVDLA_BASE_ADDRESS + NVDLA_SDP_RDMA_D_BS_BATCH_STRIDE_0);\n*/\n\n\n\n\n}\n\n", "comment_ratio": 0.10185185185185185}
{"lang": "c", "code": "#import <libobjc.A.dylib/NSSecureCoding.h>\n\n@class NSDictionary, NSString, PKTransitCommutePlan, NSDate, NSArray, NSSet, PKEnteredValueActionItem;\n\n@interface PKPaymentPassAction : NSObject <NSSecureCoding> {\n\n\tNSDictionary* _rawDictionary;\n\tNSDictionary* _localizations;\n\tBOOL _hasRemoteContent;\n\tBOOL _featured;\n\tNSString* _identifier;\n\tunsigned long long _type;\n\tNSString* _title;\n\tNSString* _actionDescription;\n\tNSString* _confirmationTitle;\n\tNSString* _relevantPropertyIdentifier;\n\tNSString* _associatedEnteredValueIdentifier;\n\tNSString* _associatedPlanIdentifier;\n\tPKTransitCommutePlan* _associatedPlan;\n\tNSDate* _availableFrom;\n\tNSDate* _availableUntil;\n\tNSString* _unavailableBeforeReason;\n\tNSString* _unavailableAfterReason;\n\tNSString* _serviceProviderIdentifier;\n\tNSString* _serviceProviderCountryCode;\n\tNSArray* _serviceProviderSupportedNetworks;\n\tNSSet* _serviceProviderSupportedCountries;\n\tunsigned long long _serviceProviderCapabilities;\n\tPKEnteredValueActionItem* _enteredValueItem;\n\tNSString* _headerText;\n\tNSString* _footerText;\n\tNSArray* _selectedActionItems;\n\n}\n\n@property (nonatomic,copy) NSString * associatedPlanIdentifier;                              //@synthesize associatedPlanIdentifier=_associatedPlanIdentifier - In the implementation block\n@property (nonatomic,copy) PKTransitCommutePlan * associatedPlan;                            //@synthesize associatedPlan=_associatedPlan - In the implementation block\n@property (nonatomic,copy) NSString * associatedEnteredValueIdentifier;                      //@synthesize associatedEnteredValueIdentifier=_associatedEnteredValueIdentifier - In the implementation block\n@property (nonatomic,copy,readonly) NSString * identifier;                                   //@synthesize identifier=_identifier - In the implementation block\n@property (nonatomic,readonly) unsigned long long type;                                      //@synthesize type=_type - In the implementation block\n@property (nonatomic,readonly) BOOL hasRemoteContent;                                        //@synthesize hasRemoteContent=_hasRemoteContent - In the implementation block\n@property (nonatomic,copy,readonly) NSString * title;                                        //@synthesize title=_title - In the implementation block\n@property (nonatomic,copy,readonly) NSString * actionDescription;                            //@synthesize actionDescription=_actionDescription - In the implementation block\n@property (nonatomic,copy,readonly) NSString * confirmationTitle;                            //@synthesize confirmationTitle=_confirmationTitle - In the implementation block\n@property (nonatomic,readonly) BOOL featured;                                                //@synthesize featured=_featured - In the implementation block\n@property (nonatomic,copy,readonly) NSString * relevantPropertyIdentifier;                   //@synthesize relevantPropertyIdentifier=_relevantPropertyIdentifier - In the implementation block\n@property (nonatomic,copy,readonly) NSDate * availableFrom;                                  //@synthesize availableFrom=_availableFrom - In the implementation block\n@property (nonatomic,copy,readonly) NSDate * availableUntil;                                 //@synthesize availableUntil=_availableUntil - In the implementation block\n@property (nonatomic,readonly) BOOL isActionAvailable; \n@property (nonatomic,copy,readonly) NSString * unavailableBeforeReason;                      //@synthesize unavailableBeforeReason=_unavailableBeforeReason - In the implementation block\n@property (nonatomic,copy,readonly) NSString * unavailableAfterReason;                       //@synthesize unavailableAfterReason=_unavailableAfterReason - In the implementation block\n@property (nonatomic,copy,readonly) NSString * serviceProviderIdentifier;                    //@synthesize serviceProviderIdentifier=_serviceProviderIdentifier - In the implementation block\n@property (nonatomic,copy,readonly) NSString * serviceProviderCountryCode;                   //@synthesize serviceProviderCountryCode=_serviceProviderCountryCode - In the implementation block\n@property (nonatomic,copy,readonly) NSArray * serviceProviderSupportedNetworks;              //@synthesize serviceProviderSupportedNetworks=_serviceProviderSupportedNetworks - In the implementation block\n@property (nonatomic,copy,readonly) NSSet * serviceProviderSupportedCountries;               //@synthesize serviceProviderSupportedCountries=_serviceProviderSupportedCountries - In the implementation block\n@property (nonatomic,readonly) unsigned long long serviceProviderCapabilities;               //@synthesize serviceProviderCapabilities=_serviceProviderCapabilities - In the implementation block\n@property (nonatomic,readonly) PKEnteredValueActionItem * enteredValueItem;                  //@synthesize enteredValueItem=_enteredValueItem - In the implementation block\n@property (nonatomic,copy,readonly) NSString * headerText;                                   //@synthesize headerText=_headerText - In the implementation block\n@property (nonatomic,copy,readonly) NSString * footerText;                                   //@synthesize footerText=_footerText - In the implementation block\n@property (nonatomic,copy,readonly) NSArray * selectedActionItems;                           //@synthesize selectedActionItems=_selectedActionItems - In the implementation block\n+(BOOL)supportsSecureCoding;\n-(id)description;\n-(unsigned long long)type;\n-(void)encodeWithCoder:(id)arg1 ;\n-(id)initWithCoder:(id)arg1 ;\n-(id)initWithDictionary:(id)arg1 ;\n-(NSString *)identifier;\n-(NSString *)title;\n-(NSString *)headerText;\n-(NSString *)serviceProviderIdentifier;\n-(NSString *)serviceProviderCountryCode;\n-(NSArray *)serviceProviderSupportedNetworks;\n-(unsigned long long)serviceProviderCapabilities;\n-(NSSet *)serviceProviderSupportedCountries;\n-(id)initWithDictionary:(id)arg1 bundle:(id)arg2 ;\n-(NSDate *)availableFrom;\n-(NSDate *)availableUntil;\n-(NSString *)unavailableBeforeReason;\n-(NSString *)unavailableAfterReason;\n-(void)_processLocalizableStrings:(/*^block*/id)arg1 ;\n-(id)_localizableKeys;\n-(id)actionUpdatedWithDictionary:(id)arg1 ;\n-(BOOL)isActionAvailable;\n-(BOOL)hasRemoteContent;\n-(NSString *)actionDescription;\n-(NSString *)confirmationTitle;\n-(BOOL)featured;\n-(NSString *)relevantPropertyIdentifier;\n-(NSString *)associatedEnteredValueIdentifier;\n-(void)setAssociatedEnteredValueIdentifier:(NSString *)arg1 ;\n-(NSString *)associatedPlanIdentifier;\n-(void)setAssociatedPlanIdentifier:(NSString *)arg1 ;\n-(PKTransitCommutePlan *)associatedPlan;\n-(void)setAssociatedPlan:(PKTransitCommutePlan *)arg1 ;\n-(PKEnteredValueActionItem *)enteredValueItem;\n-(NSString *)footerText;\n-(NSArray *)selectedActionItems;\n@end\n\n\n", "comment_ratio": 0.2222222222222222}
{"lang": "c", "code": "#include \"gfx/legato/common/legato_color.h\"\r\n\r\nstatic leColor values[LE_COLOR_LAST] =\r\n{\r\n    0x000000,  // LE_COLOR_BLACK\r\n    0xFFFFFF,  // LE_COLOR_WHITE\r\n    0xFF0000,  // LE_COLOR_RED\r\n    0x00FF00,  // LE_COLOR_LIME\r\n    0x0000FF,  // LE_COLOR_BLUE\r\n    0xFFFF00,  // LE_COLOR_YELLOW\r\n    0x00FFFF,  // LE_COLOR_CYAN\r\n    0xFF00FF,  // LE_COLOR_MAGENTA\r\n    0xC0C0C0,  // LE_COLOR_SILVER\r\n    0x404040,  // LE_COLOR_DARKGRAY\r\n    0x808080,  // LE_COLOR_GRAY\r\n    0xD4D0C8,  // LE_COLOR_LIGHTGRAY\r\n    0x800000,  // LE_COLOR_MAROON\r\n    0x808000,  // LE_COLOR_OLIVE\r\n    0x008000,  // LE_COLOR_GREEN\r\n    0x800080,  // LE_COLOR_PURPLE\r\n    0x008080,  // LE_COLOR_TEAL\r\n    0x000080   // LE_COLOR_NAVY\r\n};\r\n\r\nleColor leColorValue(leColorMode mode, leColorName name)\r\n{\r\n    if(name < 0 || name >= LE_COLOR_LAST)\r\n        return 0;\r\n\r\n    return leColorConvert(LE_COLOR_MODE_RGB_888, mode, values[name]);\r\n}\r\n\n", "comment_ratio": 0.3448275862068966}
{"lang": "c", "code": "--- base/process/kill.h.orig\t2020-11-13 06:36:34 UTC\n+++ base/process/kill.h\n@@ -113,11 +113,11 @@ BASE_EXPORT TerminationStatus GetTerminationStatus(Pro\n BASE_EXPORT TerminationStatus GetKnownDeadTerminationStatus(\n     ProcessHandle handle, int* exit_code);\n \n-#if defined(OS_LINUX) || defined(OS_CHROMEOS)\n+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_BSD)\n // Spawns a thread to wait asynchronously for the child |process| to exit\n // and then reaps it.\n BASE_EXPORT void EnsureProcessGetsReaped(Process process);\n-#endif  // defined(OS_LINUX) || defined(OS_CHROMEOS)\n+#endif  // defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_BSD)\n #endif  // defined(OS_POSIX)\n \n // Registers |process| to be asynchronously monitored for termination, forcibly\n\n", "comment_ratio": 0.35294117647058826}
{"lang": "c", "code": "#ifndef __ELASTOS_DROID_OPENGL_GLES_CEGLDIFPLAYIMPL_H__\n#define __ELASTOS_DROID_OPENGL_GLES_CEGLDIFPLAYIMPL_H__\n\n#include \"_Elastos_Droid_Opengl_Gles_CEGLDisplayImpl.h\"\n#include \"Elastos.Droid.Opengl.h\"\n\n#include <elastos/core/Object.h>\n\nusing Elastos::Core::Object;\n\nnamespace Elastos {\nnamespace Droid {\nnamespace Opengl {\nnamespace Gles {\n\nCarClass(CEGLDisplayImpl)\n    , public Object\n    , public Elastosx::Microedition::Khronos::Egl::IEGLDisplay\n{\npublic:\n    CAR_INTERFACE_DECL()\n\n    CAR_OBJECT_DECL()\n\n    CARAPI constructor(\n        /* [in] */ Int64 dpy);\n\n    CARAPI Equals(\n            /* [in] */ IInterface *object,\n            /* [out] */ Boolean *equals);\n\n    CARAPI GetHashCode(\n            /* [out] */ Int32 *hashCode);\n\n    CARAPI_(Int64) GetEGLDisplay();\n\nprivate:\n    Int64 mEGLDisplay;\n    friend class CEGLImpl;\n};\n\n} // namespace Gles\n} // namespace Opengl\n} // namespace Droid\n} // namespace Elastos\n#endif\n\n", "comment_ratio": 0.30158730158730157}
{"lang": "c", "code": "#import \"NSObject.h\"\n\n#import \"CalReminderMigrator.h\"\n\n@class NSString;\n\n@interface CalTruthFilesReminderMigrator : NSObject <CalReminderMigrator>\n{\n    id <CalReminderKitProvider> _reminderKitProvider;\n    id <CalReminderMigrationDefaultsProvider> _defaultsProvider;\n}\n\n+ (id)_subdirectoriesInDirectory:(id)arg1 withContext:(id)arg2 error:(id *)arg3;\n+ (id)_icsFilesForCalendarDirectory:(id)arg1 withContext:(id)arg2 error:(id *)arg3;\n+ (id)_eventsDirectoryForCalendarDirectory:(id)arg1;\n+ (id)_calendarDirectoryForHomeDirectory:(id)arg1;\n+ (id)_plistForDirectory:(id)arg1;\n+ (void)_updatePlist:(id)arg1 withContext:(id)arg2 updateBlock:(CDUnknownBlockType)arg3;\n+ (void)_savePlistDictionary:(id)arg1 toURL:(id)arg2 withContext:(id)arg3;\n+ (id)_plistDictionaryForPlistURL:(id)arg1 withContext:(id)arg2;\n+ (id)_plistDictionaryForDirectory:(id)arg1 withContext:(id)arg2;\n+ (long long)_accountTypeForExtension:(id)arg1;\n+ (void)_deleteItems:(id)arg1 withContext:(id)arg2;\n+ (void)_deleteItemsAfterSuccessfulMigrationWithContext:(id)arg1;\n+ (void)_disableRemindersEntityTypeInCalendarPlist:(id)arg1 withContext:(id)arg2;\n+ (void)_disableRemindersDataClassInAccountPlist:(id)arg1 withContext:(id)arg2;\n+ (void)_updatePlistsAfterSuccessfulMigrationWithContext:(id)arg1;\n+ (void)_removeRemindersDataAfterSuccessfulMigrationWithContext:(id)arg1;\n+ (void)_attemptImportOfICSFiles:(id)arg1 withContext:(id)arg2 listChangeItem:(id)arg3;\n+ (void)_importDirectoryAsReminderList:(id)arg1 withPlistDictionary:(id)arg2 context:(id)arg3 accountChangeItem:(id)arg4;\n+ (void)_visitDirectoryForImportAsReminderList:(id)arg1 withPlistDictionary:(id)arg2 context:(id)arg3 accountChangeItem:(id)arg4 shouldMigrateData:(BOOL)arg5;\n+ (BOOL)_shouldImportDirectoryAsReminderList:(id)arg1 withContext:(id)arg2 plistDictionary:(id *)arg3;\n+ (void)_attemptReminderListMigrationForDirectory:(id)arg1 withContext:(id)arg2 accountChangeItem:(id)arg3 shouldMigrateData:(BOOL)arg4;\n+ (BOOL)_attemptLocalReminderListMigrationForDirectory:(id)arg1 withContext:(id)arg2;\n+ (void)_migrateReminderListsInAccountDirectory:(id)arg1 withContext:(id)arg2 accountChangeItem:(id)arg3 shouldMigrateData:(BOOL)arg4;\n+ (id)_attemptAccountMigrationForDirectory:(id)arg1 withContext:(id)arg2 shouldMigrateData:(char *)arg3;\n+ (BOOL)_shouldMigrateDirectoryAsAccount:(id)arg1 withContext:(id)arg2 reportErrors:(BOOL)arg3 accountType:(long long *)arg4 identifier:(id *)arg5;\n+ (BOOL)_attemptMigrationForAccountInDirectory:(id)arg1 withContext:(id)arg2;\n+ (BOOL)_fileURLIsReminderICS:(id)arg1;\n+ (BOOL)_cleanupAccountDirectory:(id)arg1 withContext:(id)arg2;\n+ (BOOL)_cleanupCalendarDirectory:(id)arg1 withContext:(id)arg2;\n+ (BOOL)_cleanupTopLevelDirectory:(id)arg1 withContext:(id)arg2;\n@property(readonly, nonatomic) id <CalReminderMigrationDefaultsProvider> defaultsProvider; // @synthesize defaultsProvider=_defaultsProvider;\n@property(readonly, nonatomic) id <CalReminderKitProvider> reminderKitProvider; // @synthesize reminderKitProvider=_reminderKitProvider;\n- (void).cxx_destruct;\n- (id)_calendarDirectoryForHomeDirectory:(id)arg1;\n- (BOOL)_performPostMigrationTasksInCalendarDirectory:(id)arg1 withContext:(id)arg2;\n- (BOOL)_performMigrationInCalendarDirectory:(id)arg1 withContext:(id)arg2 shouldDeleteMigratedData:(char *)arg3;\n- (void)_performPreMigrationTasksInCalendarDirectory:(id)arg1 withContext:(id)arg2;\n- (BOOL)_attemptMigrateRemindersDataWithCalendarDirectory:(id)arg1;\n- (BOOL)attemptMigrationWithHomeDirectory:(id)arg1;\n- (id)initWithReminderKitProvider:(id)arg1 defaultsProvider:(id)arg2;\n\n// Remaining properties\n@property(readonly, copy) NSString *debugDescription;\n@property(readonly, copy) NSString *description;\n@property(readonly) unsigned long long hash;\n@property(readonly) Class superclass;\n\n@end\n\n\n", "comment_ratio": 0.11764705882352941}
{"lang": "c", "code": "#ifndef __pqTimeKeeper_h\n#define __pqTimeKeeper_h\n\n#include <QPair>\n#include \"pqProxy.h\"\n\nclass pqPipelineSource;\nclass pqView;\nclass vtkObject;\nclass vtkSMProxy;\n\n/// pqTimeKeeper is pqProxy for \"TimeKeeper\" proxy. A timekeeper is\n/// created by default per connection. pqServer keeps a pointer to the \n/// connection's time keeper. A time keeper keeps track of the\n/// global time and timesteps available currently.\nclass PQCORE_EXPORT pqTimeKeeper : public pqProxy \n{\n  Q_OBJECT\npublic:\n  pqTimeKeeper(const QString& group, const QString& name,\n    vtkSMProxy* timekeeper, pqServer* server, QObject* parent=0);\n  virtual ~pqTimeKeeper();\n\n  /// Returns the number of timestep values\n  /// known to this time keeper.\n  int getNumberOfTimeStepValues() const;\n\n  /// Returns the timestep value at the given index.\n  /// index < getNumberOfTimeStepValues().\n  double getTimeStepValue(int index) const;\n\n  /// Returns the maximum index in the timestep values\n  /// for the given time for which timestep value[index] <= time.\n  int getTimeStepValueIndex(double time) const;\n\n  /// Returns the time range. \n  /// Return (0,0) is getNumberOfTimeStepValues() == 0.\n  QPair<double, double> getTimeRange() const;\n\n  /// Returns the current time.\n  double getTime() const;\n\n  /// Update the current time.\n  void setTime(double time);\n\nsignals:\n  /// Fired when the keeper updates the times.\n  void timeStepsChanged();\n\n  /// Fired when the current time changes.\n  void timeChanged();\n\n\nprotected slots:\n  void propertyModified(vtkObject*, unsigned long, void*, void* callData);\n  \n  /// Called when a source is added.\n  void sourceAdded(pqPipelineSource*);\n\n  /// Called when a source is removed.\n  void sourceRemoved(pqPipelineSource*);\n\n  /// Called when a view is added.\n  void viewAdded(pqView*);\n\n  /// Called when a view is removed.\n  void viewRemoved(pqView*);\n\nprotected:\n  void updateTimeKeeperProxy();\n\n  void cleanupTimes(pqPipelineSource*);\nprivate:\n  pqTimeKeeper(const pqTimeKeeper&); // Not implemented.\n  void operator=(const pqTimeKeeper&); // Not implemented.\n\n  void propertyModified(pqPipelineSource*);\n\n  class pqInternals;\n  pqInternals* Internals;\n};\n\n#endif\n\n\n", "comment_ratio": 0.1896551724137931}
{"lang": "c", "code": "#ifndef WAVE_H_INCLUDED\n#define WAVE_H_INCLUDED\n\n// ----------------------------------------------------------------------------\n// Include standar libraries\n// ----------------------------------------------------------------------------\n#include <math.h>\n\n// ----------------------------------------------------------------------------\n// Include the hydrax prerequisites\n// ----------------------------------------------------------------------------\n#include \"../../HydraxPrerequisites.h\"\n\n// ----------------------------------------------------------------------------\n// Include the noise module\n// ----------------------------------------------------------------------------\n#include \"../HydraxNoise.h\"\n\n// ----------------------------------------------------------------------------\n// Include the perlin noise\n// ----------------------------------------------------------------------------\n#include \"../Perlin/HydraxPerlin.h\"\n\nnamespace Hydrax{ namespace Noise\n{\n\n/** @class Wave Wave.h Noise/Wave/Wave.h\n * @brief A wave defined by the direction, amplitude, period, and optionally phase.\n */\nclass HydraxDllExport Wave\n{\npublic:\n    /** Default constructor\n     * @param dir Direction of the wave.\n     * @param A Amplitude of the wave (m).\n     * @param T Period of the wave (s).\n     * @param p Phase of the wave (rad).\n     */\n    Wave(Ogre::Vector2 dir, float A, float T, float p=0.f);\n\n    /** Destructor\n     */\n    ~Wave();\n\n    /** Call it each frame\n        @param timeSinceLastFrame Time since last frame(delta)\n     */\n    void update(const Ogre::Real &timeSinceLastFrame);\n\n    /** Get the especified x/y noise value\n        @param x X Coord\n        @param y Y Coord\n        @return Noise value\n        @remarks range [~-0.2, ~0.2]\n     */\n    float getValue(const float &x, const float &y);\n\n    /** Returns direction of the wave.\n     * @return Direction.\n     */\n    inline Ogre::Vector2 getDirection() const{return mDir;}\n    /** Returns amplitude of the wave.\n     * @return Amplitude.\n     */\n    inline float getAmplitude() const{return mA;}\n    /** Returns period of the wave.\n     * @return Period.\n     */\n    inline float getPeriod() const{return mT;}\n    /** Returns phase of the wave.\n     * @return Phase.\n     */\n    inline float getPhase() const{return mP;}\n    /** Returns phase speed of the wave.\n     * @return Phase speed.\n     */\n    inline float getSpeed() const{return mC;}\n    /** Returns longitude of the wave.\n     * @return Wave longitude.\n     */\n    inline float getLongitude() const{return mL;}\n\nprotected:\n\n\nprivate:\n    /// Elapsed time\n    double mTime;\n\n    /// Direction (must be normalised)\n    Ogre::Vector2 mDir;\n    /// Amplitude\n    float mA;\n    /// Period\n    float mT;\n    /// Phase\n    float mP;\n    /// Speed (calculated)\n    float mC;\n    /// Longitude (calculated)\n    float mL;\n    /// Angular frec.\n    float mF;\n    /// Dispersion factor\n    float mK;\n};\n\n}}  // Namespace\n\n#endif // WAVE_H_INCLUDED\n\n", "comment_ratio": 0.1865671641791045}
{"lang": "c", "code": "//\n//  networking.c\n//  elise\n//\n//  contains all networking function definitions of libelise\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <curl/curl.h>\n#include \"networking.h\"\n\n\n// returns ELISE_OK on success all other values indicate failure\nerrno_t uri_builder(struct Uri *uri, char* buffer) {\n    // (void *) casts here to ignore compiler warnings\n    // the result will be NULL if it's not set by the user so this is still\n    // a proper and necessary check\n    if ((void*)uri->region == NULL) { // user forgot to specify region\n        fprintf(stderr, \"Error: Region is either not supported or isn't specified in URI struct.\\n\");\n        return NULL_REGION;\n    }\n    if ((void*)uri->api == NULL) {\n        fprintf(stderr, \"Error: API is either not supported or isn't specified in URI struct.\\n\");\n        return NULL_API;\n    }\n    // no checks needed for version in uri, because we set it even if the user\n    // doesn't specify it.\n\n    char* region = parse_region(uri->region);\n    if (region == NULL) {\n        // probably should change this so that the error handling makes more sense\n        // look at comments above parse_region()\n        return NULL_REGION;\n    }\n    // hostname is the same for every region as of this commit\n    const char* hostname = \".api.riotgames.com\";\n    char* api = parse_api(uri->api);\n    if (api == NULL) return NULL_API;\n    char* version = parse_version(uri->version);\n\n    // note that snprinf takes the size of address and not the size of the buffer\n    // passed to this function\n    // this way we know that it will never be more than 512 characters\n    // if it needs to be, we change it here.\n    char address[512] = \"https://\";\n\n    errno = 0;\n    // Eventually check to make sure all bytes from each string where written\n    // Right now it just assumes if it wrote more than 0 then it wrote all of the bytes\n    if (snprintf(buffer, sizeof(address), \"%s%s%s%s%s\", address, region, hostname, api, version) > 0) {\n        return ELISE_OK;\n    }\n    fprintf(stderr, \"Error: %s\\n\", strerror(errno));\n    return -1;\n}\n\n// instead of returning a string, return an errno_t instead and pass a buffer\n// by reference to modify it and return it while still being able to produce\n// decent error checking\nchar* parse_region(Region region) {\n    // switch through the region enum and return the regional endpoint\n    switch (region) {\n        case 0:  return \"br1\";\n        case 1:  return \"eun1\";\n        case 2:  return \"euw1\";\n        case 3:  return \"jp1\";\n        case 4:  return \"kr\";\n        case 5:  return \"la1\";\n        case 6:  return \"la2\";\n        case 7:  return \"na1\";\n        case 8:  return \"oc1\";\n        case 9:  return \"tr1\";\n        case 10: return \"ru\";\n        case 11: return \"pbe1\";\n        default: fprintf(stderr, \"Error: Region specified is not supported.\\n\");\n        return NULL;\n    }\n}\n\nchar* parse_api(Api api) {\n    switch (api) {\n        case 0: return \"/lol/champion-mastery/\";\n        case 1: return \"/lol/platform/\";\n        case 2: return \"/lol/league/\";\n        case 3: return \"/lol/static-data/\";\n        case 4: return \"/lol/status/\";\n        case 5: return \"/lol/match/\";\n        case 6: return \"/lol/specator/\";\n        case 7: return \"/lol/summoner/\";\n        case 8: return \"/lol/tournament-stub/\";\n        case 9: return \"/lol/tournament/\";\n        default: fprintf(stderr, \"Error: API specified is not supported.\\n\");\n        return NULL;\n    }\n}\n\nchar* parse_version(size_t version){\n    // only supporting one revision higher in case I don't update this\n    // immediately.\n    switch (version) {\n        case 3: return \"v3\";\n        case 4: return \"v4\";\n        default: return \"v3\";\n    }\n}\n\n// returns ELISE_OK on success\n// returns CURL_ERROR if curl checks fail.\n// returns NULL_X or STRING_X if it runs into user input issues\nerrno_t riot_get_request(char* uri_string, char* buffer, const char* api_key) {\n    if (uri_string == NULL) return NULL_STRING;\n    // API_KEY erorr checking\n    if (API_KEY == NULL) {\n        fprintf(stderr, \"Error: API_KEY not set.\\n\");\n        return NULL_STRING;\n    }if (strlen(API_KEY) > 42) {\n        // current api key is RGAPI-[+36 characters].\n        // This is for dev keys, I'm not sure about production level keys.\n        fprintf(stderr, \"Error: API Key is longer than 42 characters.\\n\");\n        return STRING_TOO_LARGE;\n    }if (strlen(API_KEY) < 42) {\n        fprintf(stderr, \"Error: API Key is shorter than 42 characters.\\n\");\n        return STRING_TOO_SMALL;\n    }\n\n    // literal + 1;\n    const char query[10] = \"?api_key=\";\n    char end[512];\n\n    int check = snprintf(end, sizeof(end), \"%s%s%s\", uri_string, query, api_key);\n    if (check != strlen(end)) {\n        fprintf(stderr, \"Error: Not all bytes were able to be written to string end.\\n\");\n        return -1;\n    }\n\n    // start curl magics\n    // probably should fold all of this into a function for the next x_get_request() functions.\n    CURL *curl;\n    CURLcode res;\n    char result[512];\n\n    curl = curl_easy_init();\n    if(curl) {\n        // eventually write errors out to the stderr, for consistency\n        // see CURLcode res below\n        if(curl_easy_setopt(curl, CURLOPT_URL, end) != CURLE_OK) {\n            curl_easy_cleanup(curl);\n            return CURL_ERROR;\n        }\n        if(curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L) != CURLE_OK) {\n            curl_easy_cleanup(curl);\n            return CURL_ERROR;\n        }\n        // specify a callback function to be called when the response is received\n        if(curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback) != CURLE_OK) {\n            // always try to free resources on failure\n            curl_easy_cleanup(curl);\n            return CURL_ERROR;\n        }\n        // perform the get request and store the result in res\n        res = curl_easy_perform(curl);\n        // proper curl error checking\n        if(res != CURLE_OK) {\n            fprintf(stderr, \"curl_easy_perform() failed: %s\\n\", curl_easy_strerror(res));\n        }\n\n        // attempt to write our json response out to our buffer\n        // ideally we want to return from here\n        if(snprintf(buffer, sizeof(json), \"%s\", json) > 0) {\n            curl_easy_cleanup(curl);\n            return ELISE_OK;\n        }\n        // if our write fails, we clean up and return -1;\n        curl_easy_cleanup(curl);\n        return CURL_ERROR;\n    }\n    // if for some reason curl is inaccesable we will land here.\n    fprintf(stderr, \"Error: Undefined curl behavior, please submit an issue on the libelise github.\\n\");\n    return CURL_ERROR;\n    // end curl magics\n}\n\n// curl's integrated callback for passing response data to a function\n// returns size of the response data on success, any other value indicates failure\nstatic size_t write_callback(char* ptr, size_t size, size_t nmemb, void* userdata) {\n    if(ptr == NULL) {\n        fprintf(stderr, \"Error: Curl response data is null in write_callback().\\n\");\n        // curl has an error message if we return from this function without the bytes written\n        return 0;\n    }\n    // null or invalid\n    //printf(\"hello\\n\");\n    size_t real_size = size * nmemb;\n    //char data[512];\n    // we add one to real_size, otherwise we lose the json ending bracket\n    if (snprintf(json, real_size+1, \"%s\", ptr) != 0) {\n        // checks need to be done here ^\n        // printf(\"%lu\\n\", real_size);\n        // printf(\"%s\\n\", json);\n        // this function must return real_size or curl will think the function\n        // failed to write any data\n        return real_size;\n    } return CALLBACK_ERROR;\n}\n\n", "comment_ratio": 0.2926829268292683}
{"lang": "c", "code": "/* This file was generated by syncqt. */\n#ifndef QT_QTSENSORS_VERSION_H\n#define QT_QTSENSORS_VERSION_H\n\n#define QTSENSORS_VERSION_STR \"5.11.0\"\n\n#define QTSENSORS_VERSION 0x050B00\n\n#endif // QT_QTSENSORS_VERSION_H\n\n", "comment_ratio": 0.1}
{"lang": "c", "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <strings.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdint.h>\n#include \"serial.h\"\n#include \"xbee.h\"\n\n/* ------------------------------------------------------------ *\n * global variables                                             *\n * ------------------------------------------------------------ */\nint verbose  = 0;              // 0 = off, 1 = on\nchar progver[] = \"1.0\";        // program version\nchar *port   = \"/dev/ttySC1\";  // serial port device\nint speed    = 115200;         // XBee modified speed\n//int speed    = 9600;         // XBee default speed\nint timeout  = 3;              // 3 seconds timeout\nint factoryreset = 0;          // reset config to factory settings\nint defaultcoord = 0;          // default coordinator config\nint defaultdevice = 0;         // default enddevice config\nextern const char *coord_conf[];\nextern const char *device_conf[];\n\n/* ------------------------------------------------------------ *\n * print_usage() prints the programs commandline instructions.  *\n * ------------------------------------------------------------ */\nvoid usage() {\n   static char const usage[] = \"Usage: ./xbee-config [-s speed] [-r] [-c]  [-e] [-i config_file] [-v]\\n\\\nCommand line parameters have the following format:\\n\\\n   -c   use default coordinator config in xbee.c\\n\\\n   -e   use default enddevice config in xbee.c\\n\\\n   -i   load config from file. Example: -i ./xbee-config.txt\\n\\\n   -r   reset configuration to factory default\\n\\\n   -s   set serial ine speed. Default = 115200. Example -s 9600\\n\\\n   -h   display this message\\n\\\n   -v   enable debug output\\n\\\n\\n\\\nUsage examples:\\n\\\n./xbee-config -c -v\\n\";\n   printf(\"xee-config v%s\\n\\n\", progver);\n   printf(usage);\n}\n\n/* ----------------------------------------------------------- *\n * parseargs() checks the commandline arguments with C getopt  *\n * ----------------------------------------------------------- */\nvoid parseargs(int argc, char* argv[]) {\n   int arg;\n   opterr = 0;\n\n   if(argc == 1 || (argc == 2 && strcmp(argv[1], \"-v\") == 0)) {\n       printf(\"Error: No arguments. Need either -c, -e, -r or -i file.\\n\");\n       printf(\"See ./xbee-config -h for further usage.\\n\");\n       exit (-1);\n   }\n\n   while ((arg = (int) getopt (argc, argv, \"cei:s:rhv\")) != -1) {\n      switch (arg) {\n         // arg -v verbose, type: flag, optional\n         case 'v':\n            verbose = 1; break;\n\n         // arg -c \n         case 'c':\n            defaultcoord = 1;          // default coordinator config\n            break;\n\n         // arg -e\n         case 'e':\n            defaultdevice = 1;         // default enddevice config\n            break;\n\n         // arg -i config_file type: string\n         case 'i':\n            if(verbose == 1) printf(\"Debug: arg -i, value %s\\n\", optarg);\n            printf(\"Error: Not implemented.\\n\");\n            exit(-1);\n            break;\n\n         // arg -s speed type: int \n         case 's':\n            if(verbose == 1) printf(\"Debug: arg -s, value %s\\n\", optarg);\n            speed = (int) strtol(optarg, (char **)NULL, 10);\n            if(speed != 9600 && speed != 19200 && speed != 38400 \n               && speed != 57600 && speed != 115200) {\n               printf(\"Error: Invalid speed, must be 9600/19200/38400/57600/115200.\\n\");\n               exit(-1);\n            }\n            break;\n\n         // arg -r factory reset\n         case 'r':\n            factoryreset = 1;          // reset config to factory settings\n            break;\n\n         // arg -h usage, type: flag, optional\n         case 'h':\n            usage(); exit(0);\n            break;\n\n         case '?':\n            if(isprint (optopt))\n               printf (\"Error: Unknown option `-%c'.\\n\", optopt);\n            else {\n               printf (\"Error: Unknown option character `\\\\x%x'.\\n\", optopt);\n               usage();\n               exit(-1);\n            }\n            break;\n         default:\n            usage();\n            break;\n      }\n   }\n}\n\n/* ------------------------------------------------------------ *\n * main() function to execute the program                       *\n * ------------------------------------------------------------ */\nint main(int argc, char *argv[]) {\n\n   /* ---------------------------------------------------------- *\n    * process the cmdline parameters                             *\n    * ---------------------------------------------------------- */\n   parseargs(argc, argv);\n\n   if(defaultcoord == 1 && defaultdevice == 1)\n      printf(\"Error: either -c, or -e option needs to be selected.\\n\");\n\n   /* ---------------------------------------------------------- *\n    * Open the port with the speed in -s, or the program default *\n    * ---------------------------------------------------------- */\n   printf(\"XBee open with %s %dB\\n\", port, speed);\n   int fd = xbee_enable(port, speed);\n   if(fd != -1) printf(\"XBee connected %s %dB\\n\", port, speed);\n   else printf(\"Error: XBee not connected\\n\");\n\n   /* ---------------------------------------------------------- *\n    * Reset the config to factory settings. This may disconnect  *\n    * if tjhe serial speed was different from the default 9600.  *\n    * ---------------------------------------------------------- */\n   if(factoryreset == 1) {\n      printf(\"Reset XBee config to factory settings\\n\");\n      xbee_factoryreset(fd);\n   }\n\n   /* ---------------------------------------------------------- *\n    * Write the default coordinator settings                     *\n    * ---------------------------------------------------------- */\n   if(defaultcoord == 1) {\n      printf(\"Write XBee default coordinator config\\n\");\n      xbee_setconfig(fd, coord_conf, 7);\n   }\n\n   /* ---------------------------------------------------------- *\n    * Write the default end device settings                      *\n    * ---------------------------------------------------------- */\n   if(defaultdevice == 1) {\n      printf(\"Write XBee default enddevice config\\n\");\n      xbee_setconfig(fd, device_conf, 7);\n   }\n\n   closeserial(fd);\n   return 0;\n}\n\n", "comment_ratio": 0.10497237569060773}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n\ntypedef void (^KVOBlock)(NSDictionary *change, void *context);\n\n@interface NSObject (SPKVO)\n\n- (void)addObserver:(NSObject *)observer\n         forKeyPath:(NSString *)keyPath\n            options:(NSKeyValueObservingOptions)options\n            context:(void *)context\n          withBlock:(KVOBlock)block;\n\n- (void)removeBlockObserver:(NSObject *)observer\n                forKeyPath:(NSString *)keyPath;\n\n- (void)addObserverForKeyPath:(NSString *)keyPath\n                     options:(NSKeyValueObservingOptions)options\n                     context:(void *)context\n                   withBlock:(KVOBlock)block;\n\n- (void)removeBlockObserverForKeyPath:(NSString *)keyPath;\n\n@end\n\n", "comment_ratio": 0.21875}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n#import <CoreBluetooth/CoreBluetooth.h>\n#import \"Babysister.h\"\n#import \"BabyToy.h\"\n#import \"BabySpeaker.h\"\n#import \"BabyRhythm.h\"\n\n\n\n@interface BabyBluetooth : NSObject\n\n#pragma mark -babybluetooth\u7684\u59d4\u6258\n/* \n    \u9ed8\u8ba4\u9891\u9053\u7684\u59d4\u6258\n */\n//\u8bbe\u5907\u72b6\u6001\u6539\u53d8\u7684block\n-(void)setBlockOnCentralManagerDidUpdateState:(void (^)(CBCentralManager *central))block;\n//\u627e\u5230Peripherals\u7684block\n-(void)setBlockOnDiscoverToPeripherals:(void (^)(CBCentralManager *central,CBPeripheral *peripheral,NSDictionary *advertisementData, NSNumber *RSSI))block;\n//\u8fde\u63a5Peripherals\u6210\u529f\u7684block\n-(void)setBlockOnConnected:(void (^)(CBCentralManager *central,CBPeripheral *peripheral))block;\n//\u8fde\u63a5Peripherals\u5931\u8d25\u7684block\n-(void)setBlockOnFailToConnect:(void (^)(CBCentralManager *central,CBPeripheral *peripheral,NSError *error))block;\n//\u65ad\u5f00Peripherals\u7684\u8fde\u63a5\u7684block\n-(void)setBlockOnDisconnect:(void (^)(CBCentralManager *central,CBPeripheral *peripheral,NSError *error))block;\n//\u8bbe\u7f6e\u67e5\u627e\u670d\u52a1\u7684block\n-(void)setBlockOnDiscoverServices:(void (^)(CBPeripheral *peripheral,NSError *error))block;\n//\u8bbe\u7f6e\u67e5\u627e\u5230Characteristics\u7684block\n-(void)setBlockOnDiscoverCharacteristics:(void (^)(CBPeripheral *peripheral,CBService *service,NSError *error))block;\n//\u8bbe\u7f6e\u83b7\u53d6\u5230\u6700\u65b0Characteristics\u503c\u7684block\n-(void)setBlockOnReadValueForCharacteristic:(void (^)(CBPeripheral *peripheral,CBCharacteristic *characteristic,NSError *error))block;\n//\u8bbe\u7f6e\u67e5\u627e\u5230Descriptors\u540d\u79f0\u7684block\n-(void)setBlockOnDiscoverDescriptorsForCharacteristic:(void (^)(CBPeripheral *peripheral,CBCharacteristic *characteristic,NSError *error))block;\n//\u8bbe\u7f6e\u8bfb\u53d6\u5230Descriptors\u503c\u7684block\n-(void)setBlockOnReadValueForDescriptors:(void (^)(CBPeripheral *peripheral,CBDescriptor *descriptorNSError,NSError *error))block;\n\n/*\n channel\u7684\u59d4\u6258\n */\n//\u8bbe\u5907\u72b6\u6001\u6539\u53d8\u7684block\n-(void)setBlockOnCentralManagerDidUpdateStateAtChannel:(NSString *)channel\n                                                 block:(void (^)(CBCentralManager *central))block;\n//\u627e\u5230Peripherals\u7684block\n-(void)setBlockOnDiscoverToPeripheralsAtChannel:(NSString *)channel\n                                          block:(void (^)(CBCentralManager *central,CBPeripheral *peripheral,NSDictionary *advertisementData, NSNumber *RSSI))block;\n\n//\u8fde\u63a5Peripherals\u6210\u529f\u7684block\n-(void)setBlockOnConnectedAtChannel:(NSString *)channel\n                              block:(void (^)(CBCentralManager *central,CBPeripheral *peripheral))block;\n\n//\u8fde\u63a5Peripherals\u5931\u8d25\u7684block\n-(void)setBlockOnFailToConnectAtChannel:(NSString *)channel\n                                  block:(void (^)(CBCentralManager *central,CBPeripheral *peripheral,NSError *error))block;\n\n//\u65ad\u5f00Peripherals\u7684\u8fde\u63a5\u7684block\n-(void)setBlockOnDisconnectAtChannel:(NSString *)channel\n                               block:(void (^)(CBCentralManager *central,CBPeripheral *peripheral,NSError *error))block;\n\n//\u8bbe\u7f6e\u67e5\u627e\u670d\u52a1\u7684block\n-(void)setBlockOnDiscoverServicesAtChannel:(NSString *)channel\n                                     block:(void (^)(CBPeripheral *peripheral,NSError *error))block;\n\n//\u8bbe\u7f6e\u67e5\u627e\u5230Characteristics\u7684block\n-(void)setBlockOnDiscoverCharacteristicsAtChannel:(NSString *)channel\n                                            block:(void (^)(CBPeripheral *peripheral,CBService *service,NSError *error))block;\n//\u8bbe\u7f6e\u83b7\u53d6\u5230\u6700\u65b0Characteristics\u503c\u7684block\n-(void)setBlockOnReadValueForCharacteristicAtChannel:(NSString *)channel\n                                               block:(void (^)(CBPeripheral *peripheral,CBCharacteristic *characteristic,NSError *error))block;\n//\u8bbe\u7f6e\u67e5\u627e\u5230Characteristics\u63cf\u8ff0\u7684block\n-(void)setBlockOnDiscoverDescriptorsForCharacteristicAtChannel:(NSString *)channel\n                                                         block:(void (^)(CBPeripheral *peripheral,CBCharacteristic *service,NSError *error))block;\n//\u8bbe\u7f6e\u8bfb\u53d6\u5230Characteristics\u63cf\u8ff0\u7684\u503c\u7684block\n-(void)setBlockOnReadValueForDescriptorsAtChannel:(NSString *)channel\n                                            block:(void (^)(CBPeripheral *peripheral,CBDescriptor *descriptorNSError,NSError *error))block;\n\n\n#pragma mark -babybluetooth filter\u59d4\u6258\n//\u8bbe\u7f6e\u67e5\u627ePeripherals\u7684\u89c4\u5219\n-(void)setFilterOnDiscoverPeripherals:(BOOL (^)(NSString *peripheralName))filter;\n//\u8bbe\u7f6e\u8fde\u63a5Peripherals\u7684\u89c4\u5219\n-(void)setFilterOnConnetToPeripherals:(BOOL (^)(NSString *peripheralName))filter;\n\n\n//\u8bbe\u7f6e\u67e5\u627ePeripherals\u7684\u89c4\u5219\n-(void)setFilterOnDiscoverPeripheralsAtChannel:(NSString *)channel\n                                      filter:(BOOL (^)(NSString *peripheralName))filter;\n\n//\u8bbe\u7f6e\u8fde\u63a5Peripherals\u7684\u89c4\u5219\n-(void)setFilterOnConnetToPeripheralsAtChannel:(NSString *)channel\n                                     filter:(BOOL (^)(NSString *peripheralName))filter;\n\n\n#pragma mark -babybluetooth Special\n//babyBluettooth cancelScan\u65b9\u6cd5\u8c03\u7528\u540e\u7684\u56de\u8c03\n-(void)setBlockOnCancelScanBlock:(void(^)(CBCentralManager *centralManager))block;\n//babyBluettooth cancelAllPeripheralsConnectionBlock \u65b9\u6cd5\u6267\u884c\u540e\u5e76\u4e14\u5168\u90e8\u8bbe\u5907\u65ad\u5f00\u540e\u7684\u56de\u8c03\n-(void)setBlockOnCancelAllPeripheralsConnectionBlock:(void(^)(CBCentralManager *centralManager))block;\n\n//babyBluettooth cancelScan\u65b9\u6cd5\u8c03\u7528\u540e\u7684\u56de\u8c03\n-(void)setBlockOnCancelScanBlockAtChannel:(NSString *)channel\n                                         block:(void(^)(CBCentralManager *centralManager))block;\n//babyBluettooth cancelAllPeripheralsConnectionBlock \u65b9\u6cd5\u6267\u884c\u540e\u5e76\u4e14\u5168\u90e8\u8bbe\u5907\u65ad\u5f00\u540e\u7684\u56de\u8c03\n-(void)setBlockOnCancelAllPeripheralsConnectionBlockAtChannel:(NSString *)channel\n                                                             block:(void(^)(CBCentralManager *centralManager))block;\n\n//\u8bbe\u7f6e\u84dd\u7259\u8fd0\u884c\u65f6\u7684\u53c2\u6570\n-(void)setBabyOptionsWithScanForPeripheralsWithOptions:(NSDictionary *) scanForPeripheralsWithOptions\n                          connectPeripheralWithOptions:(NSDictionary *) connectPeripheralWithOptions\n                        scanForPeripheralsWithServices:(NSArray *)scanForPeripheralsWithServices\n                                  discoverWithServices:(NSArray *)discoverWithServices\n                           discoverWithCharacteristics:(NSArray *)discoverWithCharacteristics;\n//\u8bbe\u7f6e\u84dd\u7259\u8fd0\u884c\u65f6\u7684\u53c2\u6570\n-(void)setBabyOptionsAtChannel:(NSString *)channel\n scanForPeripheralsWithOptions:(NSDictionary *) scanForPeripheralsWithOptions\n  connectPeripheralWithOptions:(NSDictionary *) connectPeripheralWithOptions\nscanForPeripheralsWithServices:(NSArray *)scanForPeripheralsWithServices\n          discoverWithServices:(NSArray *)discoverWithServices\n   discoverWithCharacteristics:(NSArray *)discoverWithCharacteristics;\n\n\n#pragma mark -\u94fe\u5f0f\u51fd\u6570\n//\u67e5\u627ePeripherals\n-(BabyBluetooth *(^)()) scanForPeripherals;\n//\u8fde\u63a5Peripherals\n-(BabyBluetooth *(^)()) connectToPeripherals;\n//\u53d1\u73b0Services\n-(BabyBluetooth *(^)()) discoverServices;\n//\u83b7\u53d6Characteristics\n-(BabyBluetooth *(^)()) discoverCharacteristics;\n//\u66f4\u65b0Characteristics\u7684\u503c\n-(BabyBluetooth *(^)()) readValueForCharacteristic;\n//\u83b7\u53d6Characteristics\u7684\u540d\u79f0\n-(BabyBluetooth *(^)()) discoverDescriptorsForCharacteristic;\n//\u83b7\u53d6Descriptors\u7684\u503c\n-(BabyBluetooth *(^)()) readValueForDescriptors;\n//\u5f00\u59cb\u6267\u884c\n-(BabyBluetooth *(^)()) begin;\n//sec\u79d2\u540e\u505c\u6b62\n-(BabyBluetooth *(^)(int sec)) stop;\n//\u6301\u6709\u5bf9\u8c61\n-(BabyBluetooth *(^)(id obj)) having;\n//\u5207\u6362\u59d4\u6258\u7684\u9891\u9053\n-(BabyBluetooth *(^)(NSString *channel)) channel;\n//\u8c13\u8bcd\uff0c\u8fd4\u56deself\n-(BabyBluetooth *) and;\n-(BabyBluetooth *) then;\n-(BabyBluetooth *) with;\n\n#pragma mark -\u5de5\u5177\u65b9\u6cd5\n//\u65ad\u5f00\u8fde\u63a5\n-(void)cancelPeripheralConnection:(CBPeripheral *)peripheral;\n//\u65ad\u5f00\u6240\u6709\u8fde\u63a5\n-(void)cancelAllPeripheralsConnection;\n//\u505c\u6b62\u626b\u63cf\n-(void)cancelScan;\n//\u66f4\u65b0Characteristics\u7684\u503c\n-(BabyBluetooth *(^)(CBPeripheral *peripheral,CBCharacteristic *characteristic)) characteristicDetails;\n//\u8bbe\u7f6echaracteristic\u7684notify\n-(void)notify:(CBPeripheral *)peripheral\ncharacteristic:(CBCharacteristic *)characteristic\n         block:(void(^)(CBPeripheral *peripheral, CBCharacteristic *characteristics, NSError *error))block;\n//\u53d6\u6d88characteristic\u7684notify\n-(void)cancelNotify:(CBPeripheral *)peripheral\n     characteristic:(CBCharacteristic *)characteristic;\n\n//\u83b7\u53d6\u5f53\u524d\u8fde\u63a5\u7684peripherals\n-(NSArray *)findConnectedPeripherals;\n\n//\u83b7\u53d6\u5f53\u524d\u8fde\u63a5\u7684peripheral\n-(CBPeripheral *)findConnectedPeripheral:(NSString *)peripheralName;\n\n//\u83b7\u53d6\u5f53\u524dcorebluetooth\u7684centralManager\u5bf9\u8c61\n-(CBCentralManager *)centralManager;\n\n/**\n * \u5355\u4f8b\u6784\u9020\u65b9\u6cd5\n * @return BabyBluetooth\u5171\u4eab\u5b9e\u4f8b\n */\n+(instancetype)shareBabyBluetooth;\n\n@end\n\n\n\n", "comment_ratio": 0.27692307692307694}
{"lang": "c", "code": "#pragma once\n\n#include \"Projectile.h\"\n\n#include <memory>\n\n//Spawns and fires Projectiles at a specified rate\nclass ProjectileShooter\n{\npublic:\n\tProjectileShooter(std::shared_ptr<const Projectile> projectileType, const bool& shouldDelay = true);\n\tProjectileShooter(const ProjectileShooter& source);\n\n\tvoid Shoot(const Vector2& position, const Vector2& direction);\n\nprivate:\n\tstd::shared_ptr<const Projectile> _projectilePrototype = nullptr; //The Projectile instance that will be copied and fired\n\n\tdouble _delay = 0.15; //How often the Shooter is allowed to fire (seconds)\n\tTimer _delayTimer;\n\n\tconst bool _shouldDelay = true; //Whether or not the delay timer should be ignored\n};\n", "comment_ratio": 0.3548387096774194}
{"lang": "c", "code": "#ifndef LongSequenceOrEvent_h\n#define LongSequenceOrEvent_h\n\n#include \"bindings/core/v8/Dictionary.h\"\n#include \"bindings/core/v8/ExceptionState.h\"\n#include \"bindings/core/v8/NativeValueTraits.h\"\n#include \"bindings/core/v8/V8BindingForCore.h\"\n#include \"core/CoreExport.h\"\n#include \"platform/heap/Handle.h\"\n\nnamespace blink {\n\nclass Event;\n\nclass CORE_EXPORT LongSequenceOrEvent final {\n  DISALLOW_NEW_EXCEPT_PLACEMENT_NEW();\n public:\n  LongSequenceOrEvent();\n  bool IsNull() const { return type_ == SpecificType::kNone; }\n\n  bool IsEvent() const { return type_ == SpecificType::kEvent; }\n  Event* GetAsEvent() const;\n  void SetEvent(Event*);\n  static LongSequenceOrEvent FromEvent(Event*);\n\n  bool IsLongSequence() const { return type_ == SpecificType::kLongSequence; }\n  const Vector<int32_t>& GetAsLongSequence() const;\n  void SetLongSequence(const Vector<int32_t>&);\n  static LongSequenceOrEvent FromLongSequence(const Vector<int32_t>&);\n\n  LongSequenceOrEvent(const LongSequenceOrEvent&);\n  ~LongSequenceOrEvent();\n  LongSequenceOrEvent& operator=(const LongSequenceOrEvent&);\n  DECLARE_TRACE();\n\n private:\n  enum class SpecificType {\n    kNone,\n    kEvent,\n    kLongSequence,\n  };\n  SpecificType type_;\n\n  Member<Event> event_;\n  Vector<int32_t> long_sequence_;\n\n  friend CORE_EXPORT v8::Local<v8::Value> ToV8(const LongSequenceOrEvent&, v8::Local<v8::Object>, v8::Isolate*);\n};\n\nclass V8LongSequenceOrEvent final {\n public:\n  CORE_EXPORT static void ToImpl(v8::Isolate*, v8::Local<v8::Value>, LongSequenceOrEvent&, UnionTypeConversionMode, ExceptionState&);\n};\n\nCORE_EXPORT v8::Local<v8::Value> ToV8(const LongSequenceOrEvent&, v8::Local<v8::Object>, v8::Isolate*);\n\ntemplate <class CallbackInfo>\ninline void V8SetReturnValue(const CallbackInfo& callbackInfo, LongSequenceOrEvent& impl) {\n  V8SetReturnValue(callbackInfo, ToV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));\n}\n\ntemplate <class CallbackInfo>\ninline void V8SetReturnValue(const CallbackInfo& callbackInfo, LongSequenceOrEvent& impl, v8::Local<v8::Object> creationContext) {\n  V8SetReturnValue(callbackInfo, ToV8(impl, creationContext, callbackInfo.GetIsolate()));\n}\n\ntemplate <>\nstruct NativeValueTraits<LongSequenceOrEvent> : public NativeValueTraitsBase<LongSequenceOrEvent> {\n  CORE_EXPORT static LongSequenceOrEvent NativeValue(v8::Isolate*, v8::Local<v8::Value>, ExceptionState&);\n};\n\ntemplate <>\nstruct V8TypeOf<LongSequenceOrEvent> {\n  typedef V8LongSequenceOrEvent Type;\n};\n\n}  // namespace blink\n\n// We need to set canInitializeWithMemset=true because HeapVector supports\n// items that can initialize with memset or have a vtable. It is safe to\n// set canInitializeWithMemset=true for a union type object in practice.\n// See https://codereview.chromium.org/1118993002/#msg5 for more details.\nWTF_ALLOW_MOVE_AND_INIT_WITH_MEM_FUNCTIONS(blink::LongSequenceOrEvent);\n\n#endif  // LongSequenceOrEvent_h\n\n", "comment_ratio": 0.14432989690721648}
{"lang": "c", "code": "#ifndef SRC_SPAWN_SYNC_H_\n#define SRC_SPAWN_SYNC_H_\n\n#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS\n\n#include \"node_buffer.h\"\n#include \"uv.h\"\n#include \"v8.h\"\n\nnamespace node {\n\n\n\nclass SyncProcessOutputBuffer;\nclass SyncProcessStdioPipe;\nclass SyncProcessRunner;\n\n\nclass SyncProcessOutputBuffer {\n  static const unsigned int kBufferSize = 65536;\n\n public:\n  inline SyncProcessOutputBuffer() = default;\n\n  inline void OnAlloc(size_t suggested_size, uv_buf_t* buf) const;\n  inline void OnRead(const uv_buf_t* buf, size_t nread);\n\n  inline size_t Copy(char* dest) const;\n\n  inline unsigned int available() const;\n  inline unsigned int used() const;\n\n  inline SyncProcessOutputBuffer* next() const;\n  inline void set_next(SyncProcessOutputBuffer* next);\n\n private:\n  // Use unsigned int because that's what `uv_buf_init` takes.\n  mutable char data_[kBufferSize];\n  unsigned int used_ = 0;\n\n  SyncProcessOutputBuffer* next_ = nullptr;\n};\n\n\nclass SyncProcessStdioPipe {\n  enum Lifecycle {\n    kUninitialized = 0,\n    kInitialized,\n    kStarted,\n    kClosing,\n    kClosed\n  };\n\n public:\n  SyncProcessStdioPipe(SyncProcessRunner* process_handler,\n                       bool readable,\n                       bool writable,\n                       uv_buf_t input_buffer);\n  ~SyncProcessStdioPipe();\n\n  int Initialize(uv_loop_t* loop);\n  int Start();\n  void Close();\n\n  v8::Local<v8::Object> GetOutputAsBuffer(Environment* env) const;\n\n  inline bool readable() const;\n  inline bool writable() const;\n  inline uv_stdio_flags uv_flags() const;\n\n  inline uv_pipe_t* uv_pipe() const;\n  inline uv_stream_t* uv_stream() const;\n  inline uv_handle_t* uv_handle() const;\n\n private:\n  inline size_t OutputLength() const;\n  inline void CopyOutput(char* dest) const;\n\n  inline void OnAlloc(size_t suggested_size, uv_buf_t* buf);\n  inline void OnRead(const uv_buf_t* buf, ssize_t nread);\n  inline void OnWriteDone(int result);\n  inline void OnShutdownDone(int result);\n  inline void OnClose();\n\n  inline void SetError(int error);\n\n  static void AllocCallback(uv_handle_t* handle,\n                            size_t suggested_size,\n                            uv_buf_t* buf);\n  static void ReadCallback(uv_stream_t* stream,\n                           ssize_t nread,\n                           const uv_buf_t* buf);\n  static void WriteCallback(uv_write_t* req, int result);\n  static void ShutdownCallback(uv_shutdown_t* req, int result);\n  static void CloseCallback(uv_handle_t* handle);\n\n  SyncProcessRunner* process_handler_;\n\n  bool readable_;\n  bool writable_;\n  uv_buf_t input_buffer_;\n\n  SyncProcessOutputBuffer* first_output_buffer_;\n  SyncProcessOutputBuffer* last_output_buffer_;\n\n  mutable uv_pipe_t uv_pipe_;\n  uv_write_t write_req_;\n  uv_shutdown_t shutdown_req_;\n\n  Lifecycle lifecycle_;\n};\n\n\nclass SyncProcessRunner {\n  enum Lifecycle {\n    kUninitialized = 0,\n    kInitialized,\n    kHandlesClosed\n  };\n\n public:\n  static void Initialize(v8::Local<v8::Object> target,\n                         v8::Local<v8::Value> unused,\n                         v8::Local<v8::Context> context,\n                         void* priv);\n  static void Spawn(const v8::FunctionCallbackInfo<v8::Value>& args);\n\n private:\n  friend class SyncProcessStdioPipe;\n\n  explicit SyncProcessRunner(Environment* env_);\n  ~SyncProcessRunner();\n\n  inline Environment* env() const;\n\n  v8::MaybeLocal<v8::Object> Run(v8::Local<v8::Value> options);\n  v8::Maybe<bool> TryInitializeAndRunLoop(v8::Local<v8::Value> options);\n  void CloseHandlesAndDeleteLoop();\n\n  void CloseStdioPipes();\n  void CloseKillTimer();\n\n  void Kill();\n  void IncrementBufferSizeAndCheckOverflow(ssize_t length);\n\n  void OnExit(int64_t exit_status, int term_signal);\n  void OnKillTimerTimeout();\n\n  int GetError();\n  void SetError(int error);\n  void SetPipeError(int pipe_error);\n\n  v8::Local<v8::Object> BuildResultObject();\n  v8::Local<v8::Array> BuildOutputArray();\n\n  v8::Maybe<int> ParseOptions(v8::Local<v8::Value> js_value);\n  int ParseStdioOptions(v8::Local<v8::Value> js_value);\n  int ParseStdioOption(int child_fd, v8::Local<v8::Object> js_stdio_option);\n\n  inline int AddStdioIgnore(uint32_t child_fd);\n  inline int AddStdioPipe(uint32_t child_fd,\n                          bool readable,\n                          bool writable,\n                          uv_buf_t input_buffer);\n  inline int AddStdioInheritFD(uint32_t child_fd, int inherit_fd);\n\n  static bool IsSet(v8::Local<v8::Value> value);\n  v8::Maybe<int> CopyJsString(v8::Local<v8::Value> js_value,\n                              const char** target);\n  v8::Maybe<int> CopyJsStringArray(v8::Local<v8::Value> js_value,\n                                   char** target);\n\n  static void ExitCallback(uv_process_t* handle,\n                           int64_t exit_status,\n                           int term_signal);\n  static void KillTimerCallback(uv_timer_t* handle);\n  static void KillTimerCloseCallback(uv_handle_t* handle);\n\n  double max_buffer_;\n  uint64_t timeout_;\n  int kill_signal_;\n\n  uv_loop_t* uv_loop_;\n\n  uint32_t stdio_count_;\n  uv_stdio_container_t* uv_stdio_containers_;\n  std::vector<std::unique_ptr<SyncProcessStdioPipe>> stdio_pipes_;\n  bool stdio_pipes_initialized_;\n\n  uv_process_options_t uv_process_options_;\n  const char* file_buffer_;\n  char* args_buffer_;\n  char* env_buffer_;\n  const char* cwd_buffer_;\n\n  uv_process_t uv_process_;\n  bool killed_;\n\n  size_t buffered_output_size_;\n  int64_t exit_status_;\n  int term_signal_;\n\n  uv_timer_t uv_timer_;\n  bool kill_timer_initialized_;\n\n  // Errors that happen in one of the pipe handlers are stored in the\n  // `pipe_error` field. They are treated as \"low-priority\", only to be\n  // reported if no more serious errors happened.\n  int error_;\n  int pipe_error_;\n\n  Lifecycle lifecycle_;\n\n  Environment* env_;\n};\n\n}  // namespace node\n\n#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS\n\n#endif  // SRC_SPAWN_SYNC_H_\n\n", "comment_ratio": 0.1111111111111111}
{"lang": "c", "code": "#ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_WTF_ALLOCATOR_H_\n#define THIRD_PARTY_BLINK_RENDERER_PLATFORM_WTF_ALLOCATOR_H_\n\n#include \"third_party/blink/renderer/platform/wtf/allocator/partitions.h\"\n#include \"third_party/blink/renderer/platform/wtf/assertions.h\"\n#include \"third_party/blink/renderer/platform/wtf/type_traits.h\"\n\nnamespace WTF {\n\nnamespace internal {\n// A dummy class used in following macros.\nclass __thisIsHereToForceASemicolonAfterThisMacro;\n}\n\n// Classes that contain references to garbage-collected objects but aren't\n// themselves garbaged allocated, have some extra macros available which\n// allows their use to be restricted to cases where the garbage collector\n// is able to discover their references. These macros will be useful for\n// non-garbage-collected objects to avoid unintended allocations.\n//\n// STACK_ALLOCATED(): Use if the object is only stack allocated.\n// Garbage-collected objects should be in Members but you do not need the\n// trace method as they are on the stack.  (Down the line these might turn\n// in to raw pointers, but for now Members indicate that we have thought\n// about them and explicitly taken care of them.)\n//\n// DISALLOW_NEW(): Cannot be allocated with new operators but can be a\n// part of object, a value object in collections or stack allocated. If it has\n// Members you need a trace method and the containing object needs to call that\n// trace method.\n//\n#define DISALLOW_NEW()                                                        \\\n public:                                                                      \\\n  using IsDisallowNewMarker = int;                                            \\\n  void* operator new(size_t, NotNullTag, void* location) { return location; } \\\n  void* operator new(size_t, void* location) { return location; }             \\\n                                                                              \\\n private:                                                                     \\\n  void* operator new(size_t) = delete;                                        \\\n                                                                              \\\n public:                                                                      \\\n  friend class ::WTF::internal::__thisIsHereToForceASemicolonAfterThisMacro\n\n#define STATIC_ONLY(Type)                                 \\\n  Type() = delete;                                        \\\n  Type(const Type&) = delete;                             \\\n  Type& operator=(const Type&) = delete;                  \\\n  void* operator new(size_t) = delete;                    \\\n  void* operator new(size_t, NotNullTag, void*) = delete; \\\n  void* operator new(size_t, void*) = delete\n\n#define IS_GARBAGE_COLLECTED_TYPE()         \\\n public:                                    \\\n  using IsGarbageCollectedTypeMarker = int; \\\n                                            \\\n private:                                   \\\n  friend class ::WTF::internal::__thisIsHereToForceASemicolonAfterThisMacro\n\n#if defined(__clang__)\n#define ANNOTATE_STACK_ALLOCATED \\\n  __attribute__((annotate(\"blink_stack_allocated\")))\n#else\n#define ANNOTATE_STACK_ALLOCATED\n#endif\n\n#define STACK_ALLOCATED()                                       \\\n public:                                                        \\\n  using IsStackAllocatedTypeMarker[[maybe_unused]] = int;       \\\n                                                                \\\n private:                                                       \\\n  ANNOTATE_STACK_ALLOCATED void* operator new(size_t) = delete; \\\n  void* operator new(size_t, NotNullTag, void*) = delete;       \\\n  void* operator new(size_t, void*) = delete\n\n// Provides customizable overrides of fastMalloc/fastFree and operator\n// new/delete\n//\n// Provided functionality:\n//    Macro: USING_FAST_MALLOC\n//\n// Example usage:\n//    class Widget {\n//        USING_FAST_MALLOC(Widget)\n//    ...\n//    };\n//\n//    struct Data {\n//        USING_FAST_MALLOC(Data)\n//    public:\n//    ...\n//    };\n//\n\n#define USING_FAST_MALLOC_INTERNAL(type, typeName)                    \\\n public:                                                              \\\n  void* operator new(size_t, void* p) { return p; }                   \\\n  void* operator new[](size_t, void* p) { return p; }                 \\\n                                                                      \\\n  void* operator new(size_t size) {                                   \\\n    return ::WTF::Partitions::FastMalloc(size, typeName);             \\\n  }                                                                   \\\n                                                                      \\\n  void operator delete(void* p) { ::WTF::Partitions::FastFree(p); }   \\\n                                                                      \\\n  void* operator new[](size_t size) {                                 \\\n    return ::WTF::Partitions::FastMalloc(size, typeName);             \\\n  }                                                                   \\\n                                                                      \\\n  void operator delete[](void* p) { ::WTF::Partitions::FastFree(p); } \\\n  void* operator new(size_t, NotNullTag, void* location) {            \\\n    DCHECK(location);                                                 \\\n    return location;                                                  \\\n  }                                                                   \\\n                                                                      \\\n private:                                                             \\\n  friend class ::WTF::internal::__thisIsHereToForceASemicolonAfterThisMacro\n\n// In official builds, do not include type info string literals to avoid\n// bloating the binary.\n#if defined(OFFICIAL_BUILD)\n#define WTF_HEAP_PROFILER_TYPE_NAME(T) nullptr\n#else\n#define WTF_HEAP_PROFILER_TYPE_NAME(T) ::WTF::GetStringWithTypeName<T>()\n#endif\n\n// Both of these macros enable fast malloc and provide type info to the heap\n// profiler. The regular macro does not provide type info in official builds,\n// to avoid bloating the binary with type name strings. The |WITH_TYPE_NAME|\n// variant provides type info unconditionally, so it should be used sparingly.\n// Furthermore, the |WITH_TYPE_NAME| variant does not work if |type| is a\n// template argument; |USING_FAST_MALLOC| does.\n#define USING_FAST_MALLOC(type) \\\n  USING_FAST_MALLOC_INTERNAL(type, WTF_HEAP_PROFILER_TYPE_NAME(type))\n#define USING_FAST_MALLOC_WITH_TYPE_NAME(type) \\\n  USING_FAST_MALLOC_INTERNAL(type, #type)\n\n}  // namespace WTF\n\n// This version of placement new omits a 0 check.\nenum NotNullTag { NotNull };\ninline void* operator new(size_t, NotNullTag, void* location) {\n  DCHECK(location);\n  return location;\n}\n\n#endif /* WTF_Allocator_h */\n\n", "comment_ratio": 0.32450331125827814}
{"lang": "c", "code": "// apic_version = 0.6.1\n#import \"PTModel.h\"\nNS_ASSUME_NONNULL_BEGIN\n@interface PTGetFeedsPageRecommendationUsersReqMessage : PTModel\n@end\nNS_ASSUME_NONNULL_END\n\n", "comment_ratio": 0.14285714285714285}
{"lang": "c", "code": "#ifndef PATCHCACHE_H\r\n#define PATCHCACHE_H\r\n\r\n//need this #include for MSIHANDLE\r\n#include \"msiquery.h\"\r\n\r\nUINT PatchCacheEntryPoint( MSIHANDLE hdbInput, LPTSTR szFTK, LPTSTR szSrcPath, int iFileSeqNum, LPTSTR szTempFolder, LPTSTR szTempFName );\r\n\r\n//new globals used in existing patchwiz code for new algorithm...\r\nextern BOOL  g_bPatchCacheEnabled;\r\n\r\nextern TCHAR g_szPatchCacheDir[MAX_PATH];\r\n\r\nextern TCHAR g_szSourceLFN[MAX_PATH];\r\nextern TCHAR g_szDestLFN[MAX_PATH];\r\n\r\n//existing API's used in existing MSI PatchWiz.dll code and in the new patch caching code...\r\nvoid  GetFileVersion ( LPTSTR szFile, DWORD* pdwHi, DWORD* pdwLow );\r\nUINT  UiGenerateOnePatchFile ( MSIHANDLE hdbInput, LPTSTR szFTK, LPTSTR szSrcPath, int iFileSeqNum, LPTSTR szTempFolder, LPTSTR szTempFName );\r\n\r\n\r\n#endif\n", "comment_ratio": 0.13636363636363635}
{"lang": "c", "code": "#pragma pack(1)\n#include <libxtf/xtf_reader.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Possible types of data when multiple channels are involved.\n#define NUM_DATA_TYPES 7\nchar *ChannelTypes[NUM_DATA_TYPES] = {\n   \"SUBBOTTOM\",\n   \"PORT\",\n   \"STBD\",\n   \"BATHY\",\n   \"ELAC\",\n   \"SERIAL\",\n   \"UNRECOGNIZED\"\n};\n\n// For now, assume that the input file will contain 6 or fewer\n// channels of data.  This means that the file header will always\n// be 1024 bytes.  In the event that a file has more than 6 channels,\n// this program will need to be changed.\n#define FILEHEADERSIZE (sizeof(XTFFILEHEADER))\n\n//int infl=0;\n//unsigned int amt;\n//unsigned char *buffer = NULL;\n//XTFFILEHEADER *XTFFileHeader = NULL;\n//int NumSonarChans, NumBathyChans;\n//int StartPing = 0;\n//char *ptr;\n\nvoid ReadXTFFile(int infl, XTFFILEHEADER* XTFFileHeader, unsigned char* buffer) {\n/***************************************************************************************/\n// Given a handle to on open .XTF file, read through the file and\n// print out some data about it.\n\n   //\n   // Read the XTF file header\n   //\n\n   if (ReadXTFHeader(infl, XTFFileHeader, buffer) == FALSE) return;\n\n\n   ProcessXTFHeader(infl, XTFFileHeader, buffer);\n\n\n   //\n   // Read the XTF file one packet at a time\n   //\n\n   unsigned int amt;\n   char *ptr;\n   int NumSonar=0, NumHidden=0, NumBathy=0, NumAnnotation=0, NumAttitude=0, NumSerial=0;\n   while ((amt = ReadXTFFormatFileData(infl, buffer)) != 0xFFFF) {\n      //\n      // Buffer now holds a single record which can be processed \n      // here.  The return value from ReadXTFFormatFileData()\n      // holds byte length of the data record (i.e., sidescan ping)\n      //\n\n      XTFPINGHEADER *PingHeader = (XTFPINGHEADER *) buffer;\n\n      switch (PingHeader->HeaderType) {\n         case XTF_HEADER_SONAR    : ptr = \"SONAR \"; // sidescan ping\n            NumSonar++;\n            ProcessSidescanPing((XTFPINGHEADER *) PingHeader, XTFFileHeader);\n            break;\n\n         case XTF_HEADER_HIDDEN_SONAR  : ptr = \"HIDDEN\"; // sidescan ping\n            NumHidden++;\n            ProcessSidescanPing((XTFPINGHEADER *) PingHeader, XTFFileHeader);\n            break;\n\n         case XTF_HEADER_BATHY    : ptr = \"BATHY \"; // multibeam ping\n            NumBathy++;\n            ProcessMultibeamPing((XTFBATHHEADER *) PingHeader);\n            break;\n\n         case XTF_HEADER_ATTITUDE : ptr = \"TSS   \"; // TSS or MRU update\n            NumAttitude++;\n            ProcessAttitudeUpdate((XTFATTITUDEDATA *) PingHeader);\n            continue;\n            break;\n\n         case XTF_HEADER_NOTES    : ptr = \"NOTES \"; // just some user-entered annotation\n            NumAnnotation++;\n            ProcessNotes((XTFNOTESHEADER *) PingHeader);\n            continue;\n            break;\n\n         case XTF_HEADER_ELAC     : ptr = \"ELAC  \"; // just some user-entered annotation\n            NumBathy++;\n            break;\n\n         case XTF_HEADER_RAW_SERIAL : ptr = \"SERIAL\";\n            NumSerial++;\n            ProcessRawSerial((XTFRAWSERIALHEADER *) PingHeader);\n            continue;\n            break;\n\n         default : ptr = \"OTHER\"; \n            printf(\"%s  \\r\", ptr);\n            continue;\n            break;\n      }\n\n\n      printf(\"%s %02u/%02u/%02u %02u:%02u:%02u Y=%.6lf X=%.6lf pitch=%.1f roll=%.1f\\r\",\n         ptr,\n         PingHeader->Month,\n         PingHeader->Day,\n         PingHeader->Year,\n         PingHeader->Hour,\n         PingHeader->Minute,\n         PingHeader->Second,\n         PingHeader->SensorYcoordinate,\n         PingHeader->SensorXcoordinate,\n         PingHeader->SensorPitch,\n         PingHeader->SensorRoll);\n\n      //if (kbhit()) if (getchar() == 27) {\n      if (getchar() == 27) {\n         printf(\"\\nUser pressed ESC\\n\");\n         break; // press ESC to quit.\n      }\n   }\n\n   if (amt == 0xFFFF) {\n      printf(\"\\nStopped - read -1 bytes\\n\");\n   }\n   else {\n      printf(\"\\nDon't know why loop stopped.\\n\");\n   }\n\n   printf(\"\\n\\nPacket count: %u sonar, %u hidden, %u bathy, %u annotation, %u attitude, %d raw serial\\n\",\n      NumSonar, NumHidden, NumBathy, NumAnnotation, NumAttitude, NumSerial); \n\n   printf(\"\\nDone!\\n\");\n}\n\nBOOL ReadXTFHeader(int infl, XTFFILEHEADER *XTFFileHeader, unsigned char* buffer) {\n/****************************************************************************/\n// Read the header out of the XTF file and get ready to read the data that\n// follows in the file.  Returns TRUE if all wend OK.\n\n\n   //\n   // Read file header\n   //\n   if (read(infl, XTFFileHeader, FILEHEADERSIZE) != FILEHEADERSIZE) {\n      printf(\"Error reading file header!\\n\");\n      return FALSE;\n   }\n\n   if (XTFFileHeader->FileFormat != FMT_XTF) {\n      printf(\"Bad header ID (%d) -- this file is not an XTF format file!\\n\", XTFFileHeader->FileFormat);\n      return FALSE;\n   }\n\n   printf(\"This file contains %ld sonar pings and %ld bathymetry pings\\n\\n\",\n      XTFFmtLastPingNumberInFile(infl, XTF_HEADER_SONAR, buffer),\n      XTFFmtLastPingNumberInFile(infl, XTF_HEADER_BATHY, buffer) + \n      XTFFmtLastPingNumberInFile(infl, XTF_HEADER_ELAC, buffer));\n\n   // align back to start of data.  0xFF matches any kind of packet.\n   int StartPing = 0;\n   GoToIsisFmtPing(infl, StartPing, 0xFF, buffer);\n                                                                     \n   return TRUE;\n\n}\n\nvoid ProcessXTFHeader(int infl, XTFFILEHEADER *XTFFileHeader, unsigned char* buffer) {\n/*****************************************************************************/\n\n   int chan;\n\n   printf(\"\\nXTF File header information:\\n\");\n\n   int NumSonarChans = XTFFileHeader->NumberOfSonarChannels;\n   int NumBathyChans = XTFFileHeader->NumberOfBathymetryChannels;\n\n   // How many 1024-byte blocks do we need to read in order\n   // get all of the channel info structures?  For now,\n   // don't bother looking into the structures.  Just get\n   // past them so we can start reading the data in the file.\n   {\n      unsigned int Cnt = (NumSonarChans+NumBathyChans);\n      if (Cnt > 6) {\n         Cnt -= 6;\n         Cnt *= sizeof(CHANINFO);\n         Cnt += 1023; // bring to next even 1024-byte increment.\n         Cnt /= 1024; // use integer math to truncate fraction.\n         read(infl, buffer+1024, Cnt*1024);\n      }\n   }\n\n   printf(\"Recording program version: %s\\n\",XTFFileHeader->RecordingProgramVersion);\n\n   printf(\"Number of Sonar channels: %d\\n\", NumSonarChans);\n\n   for (chan=0; chan<NumSonarChans; chan++) {\n      int chtype = XTFFileHeader->ChanInfo[chan].TypeOfChannel;\n      if (chtype >= NUM_DATA_TYPES) chtype = NUM_DATA_TYPES-1;\n\n      printf(\"   Sonar channel %d is %s, %d byte(s) per sample\\n\", \n         chan, \n         ChannelTypes[chtype],\n         XTFFileHeader->ChanInfo[chan].BytesPerSample);\n   }                                                   \n\n   printf(\"Number of Bathymetry channels: %d\\n\", NumBathyChans);\n   for (chan=0; chan<NumBathyChans; chan++) {\n      printf(\"   Bathy channel %d is %s, mounted %.1f degrees\\n\", \n         chan, \n         ChannelTypes[XTFFileHeader->ChanInfo[chan+NumSonarChans].TypeOfChannel],\n         XTFFileHeader->ChanInfo[chan+NumSonarChans].OffsetRoll);\n   }\n\n   printf(\"\\n\");\n}\n\nunsigned int ReadXTFFormatFileData(int infl, unsigned char *buffer) {\n/*****************************************************************************/\n// This function will read data from an XTF file and return buffer with\n// a ping of sonar data in it.  This function is NOT limited to pings with a byte\n// count of less than 64K.\n// Returns the number of bytes in *buffer*.  These bytes will be a \n// Sonar data packet.  The calling program can use this data (which will\n// be side scan and/or subbottom data) for anything.\n//JF:\n// Max buffer should be 268K (268435456) and the now we can read records of that size too.\n  // return will be number of bytes to shift the buffer or OxFFFF if done.\n  // unrecognized records will be read but return (shift) will be 0 \n   XTFPINGHEADER *PacketHeader;\n   unsigned char *SrcPtr = buffer;\n   long AmountNeeded;\n   long RecordLength;\n   long AmountRead,len;\n\n      // Read in 64 bytes just to get going\n   if ((AmountRead = read(infl, SrcPtr, 64)) != 64) {\n      //printf(\"\\nCan't read 64 bytes\\n\");\n      return 0xFFFF;\n   }\n   printf(\"Amount Read %d\",AmountRead);\n   PacketHeader = (XTFPINGHEADER *) SrcPtr;\n   RecordLength = PacketHeader->NumBytesThisRecord;\n   if (RecordLength> 268435456) {\n     printf(\"Oh No! Record Length too large for buffer\"); \n     return 0xFFFF;\n   }\n   SrcPtr += AmountRead;  \n   AmountNeeded = RecordLength - AmountRead;\n   while (AmountNeeded > 64000) {\n     len=read(infl, SrcPtr, (WORD)64000);\n     if (len != 64000) return 0;\n     AmountRead+=len;\n     SrcPtr+= len;  \n     AmountNeeded = RecordLength - AmountRead;\n   }\n   if (AmountNeeded>0){\n     len=read(infl, SrcPtr, (WORD)AmountNeeded);\n     if (len != 64000) return 0;\n     AmountRead+=len;\n     SrcPtr+= len;  \n     AmountNeeded = RecordLength - AmountRead;\n   }    \n   switch (PacketHeader->HeaderType) {\n   case XTF_HEADER_SONAR        :\n   case XTF_HEADER_BATHY        :\n   case XTF_HEADER_ATTITUDE     :\n   case XTF_HEADER_NOTES        :\n   case XTF_HEADER_ELAC         :\n   case XTF_HEADER_RAW_SERIAL   :\n   case XTF_HEADER_EMBED_HEAD   :\n   case XTF_HEADER_HIDDEN_SONAR :\n   case XTF_HEADER_ECHOSTRENGTH :\n     break;  \n   default : // Unrecognized header type.  Skip past it.\n     return (WORD)0;\n     break;\n   }\n   return (WORD)AmountRead;\n}\n\nlong FindIsisFmtHeader(unsigned char *buf, long cnt, unsigned char RecordType, int Dir) {\n/************************************************************************************************/\n// Somewhere in buf is (probably) an ping header of type RecordType.\n// Find it, and return the offset to it.  If Dir!=0, find backwards (from end)\n// Returns offset to the start of the record, or -1 if not found.\n\n   long i;\n   \n   long start, end, inc;\n\n   if (Dir == 0) {\n      start = 0;\n      end = cnt-20+1;\n      inc = 1;\n   }\n   else {\n      start = cnt-20-1;\n      end = -1;\n      inc = -1;\n   }\n\n      //\n      // Sanity check to see if this is actually\n      // the start of a data packet.\n      //\n   for (i=start; i != end; i+=inc) {\n      if (\n         *((WORD *)&buf[i]) == 0xFACE && // magic number\n         (RecordType == 0xFF || buf[i+2] == RecordType) &&\n\n         buf[i+6] == 0    &&\n         buf[i+7] == 0    &&\n\n         buf[i+16] < 13   && // month\n         buf[i+17] < 33   && // day\n         buf[i+18] < 24   && // hour\n         buf[i+19] < 60   && // minute\n         buf[i+20] < 60) {   // sec\n\n         return i;\n      }\n   }\n   return -1L;\n}\n\n\nBOOL AlignIsisFmtFile(int infl, unsigned char RecordType, unsigned char *TempBuffer) {\n/************************************************************************************************/\n// Align an Isis-format file to the beginning of a ping with type RecordType\n// Returns TRUE if successful, FALSE if failure.\n\n   long Skip;\n   int tries;\n\n   for (tries=0; tries < 10; tries++) {\n      int amt = read(infl, TempBuffer, 16384);\n      if (amt <= 0) break;\n\n      Skip = FindIsisFmtHeader(TempBuffer, amt, RecordType, 0);\n      if (Skip != -1) {\n         lseek(infl, Skip-amt, 1);\n         return TRUE;\n      }\n   }\n   // printf(\"\\nNever found alignment!\\n\");\n   return FALSE;\n}\n   \nlong GetPingNumberFromIsisFmtFile(int fl, unsigned char RecordType, unsigned char *TempBuffer) {\n/************************************************************************************************/\n// Given the current file alignment, find the next ping of type RecordType\n// and return the ping number of that ping.\n// Returns Ping Number if successful, -1 if failure.\n\n   XTFPINGHEADER PingHeader;\n\n   if (AlignIsisFmtFile(fl, RecordType, TempBuffer)) {\n      if (read(fl, &PingHeader, sizeof(XTFPINGHEADER)) != sizeof(XTFPINGHEADER)) {\n         return -1L;\n      }\n      return PingHeader.PingNumber;\n   }\n   return -1L;\n}\n\nBOOL GoToIsisFmtPing(int infl, long DestPingNumber, unsigned char RecordType, unsigned char *TempBuffer) {\n/************************************************************************************************/\n// Given a ping number, this function will position a file to the indicated point in \n// a Isis format file (.XTF).  Alignment will be done on sonar pings if \n// RecordType==XTF_HEADER_SONAR or Bathy pings if RecordType==XTF_HEADER_BATHY.\n// If RecordType == 0xFF, aligns to any packet type.\n// Returns TRUE if successful, FALSE otherwise.\n//\n/* This function used a modified binary search to skip around the file\n   and look for packet headers.  This modified binary search looks like\n   this pseudo-code:\n\n   ptr = strt of file\n   offset = size of file / 2\n\n   do \n      check = ping number at (ptr+offset)\n      if (check > SonarPingNumber) offset /= 2;\n      else ptr += offset;\n   until found\n\n*/\n   unsigned long BytesInFile, Offset;\n   unsigned long ptr = 0L;\n   long check;\n\n   BytesInFile = lseek(infl, 0L, 2);\n   if (BytesInFile <= FILEHEADERSIZE) return FALSE;\n\n   BytesInFile -= FILEHEADERSIZE;\n\n   Offset = (BytesInFile/2);\n\n   do {\n      lseek(infl, ptr + Offset + FILEHEADERSIZE, 0);\n      check = GetPingNumberFromIsisFmtFile(infl, RecordType, TempBuffer);\n      if (check == DestPingNumber) break;\n      if (check > DestPingNumber || check == -1L) {\n         Offset /= 2L;\n         if (Offset < 256L) break;\n      }\n      else {\n         ptr += Offset;\n      }\n   } while (1);\n\n   lseek(infl, ptr+Offset+FILEHEADERSIZE, 0);\n   AlignIsisFmtFile(infl, RecordType, TempBuffer);\n   return TRUE;\n}\n\nlong XTFFmtLastPingNumberInFile(int fl, unsigned char RecordType, unsigned char *TempBuffer) {\n/************************************************************************************************/\n// Align an Isis-format file to the beginning of a ping with type RecordType\n// Returns Ping Number if successful, -1 otherwise.\n\n   long Skip;\n   int amt;\n   int tries;\n   XTFPINGHEADER *PingHeaderPtr;\n\n      // Try to read from the file backwards 10 times to\n      // see if we encounter a ping with this record type.\n\n   for (tries=0; tries < 10; tries++) {\n\n      lseek(fl, -(16384L * (tries+1)), 2);\n\n      amt = read(fl, TempBuffer, 16384);\n      if (amt <= 0) break;\n\n         // Find backwards\n      Skip = FindIsisFmtHeader(TempBuffer, amt, RecordType, 1);\n      if (Skip != -1) {\n         lseek(fl, Skip-amt, 1);\n         read(fl, TempBuffer, 256);\n         PingHeaderPtr = (XTFPINGHEADER *) TempBuffer;\n         return PingHeaderPtr->PingNumber;\n      }\n   }\n\n   return 0;\n}\n   \nvoid ProcessSidescanPing(XTFPINGHEADER *PingHeader, XTFFILEHEADER *XTFFileHeader) {\n/****************************************************************************/\n// Put whatever processing here to be performed on SIDESCAN data.\n// PingHeader points to the 256-byte ping header structure.  That structure\n// identifies how many channels of sidescan follow.  The structure is followed\n// by the sidescan data itself.\n//\n// For example: assume there are two channels of sidescan, stored 1024\n// 8-bit samples per channel.  The data pointed to by PingHeader looks like:\n// \n// 256 bytes   - XTFPINGHEADER structure holds data about this ping\n// 64 bytes    - XTFPINGCHANHEADER structure holds data about channel 1 (port)\n// 1024 bytes  - channel 1 imagery\n// 64 bytes    - XTFPINGCHANHEADER structure holds data about channel 2 (stbd)\n// 1024 bytes  - channel 2 imagery\n//\n   WORD chan;\n   int tmp;\n   unsigned char *Ptr = (unsigned char *)PingHeader;\n\n   // For backwards-compatibility.  The samples per channel used to\n   // be stored in the file header.  \n\n\n   // skip past the ping header\n   Ptr += sizeof(XTFPINGHEADER);\n\n   for (chan=0; chan<PingHeader->NumChansToFollow; chan++) {\n\n      XTFPINGCHANHEADER *ChanHeader;\n      unsigned char *Imagery;\n      WORD ChannelNumber;\n      WORD BytesPerSample;\n      DWORD SamplesPerChan;\n      DWORD BytesThisChannel;\n      \n      // point to the channel header\n      //\n      ChanHeader = (XTFPINGCHANHEADER *) Ptr;\n\n      // See which channel this is (0=port, 1=stbd, etc...)\n      //\n      ChannelNumber = ChanHeader->ChannelNumber;\n\n      // Compute the number of bytes of imagery for this channel\n      //\n      BytesPerSample   = XTFFileHeader->ChanInfo[ChannelNumber].BytesPerSample;\n\n      // If the NumSamples value in the channel header is zero, then this\n      // must be an old-style XTF File where the samples per channel was\n      // stored in this file header.\n      SamplesPerChan = XTFFileHeader->ChanInfo[ChannelNumber].Reserved; // for backwards compatibility only!\n      tmp = ChanHeader->NumSamples;\n      if (tmp != 0) SamplesPerChan = tmp;\n\n      BytesThisChannel = BytesPerSample * SamplesPerChan;\n\n      // skip past the channel header\n      //\n      Ptr += sizeof(XTFPINGCHANHEADER);\n\n      // Point to the imagery.  If BytesPerSample is 2, then\n      // Imagery should be a pointer to a signed 16-bit value.\n      // If BytesPerSample is 1, then Imagery should point to \n      // a unsigned 8-bit value.\n      Imagery = Ptr;\n\n      // Do whatever processing on the sidescan imagery here.\n\n      // skip past the imagery;\n      Ptr += BytesThisChannel;\n   }\n\n}\n\nvoid ProcessMultibeamPing(XTFBATHHEADER *PingHeader) {\n/****************************************************************************/\n// Put multibeam processing here.\n// PingHeader points to a 256-byte bathyheader structure.  That structure\n// is followed by the bathy data itself.  When Isis saves bathy data,\n// only one packet is saved at a time.  If there are two SEABAT heads,\n// the data from each one will be stored with in different records and\n// with their own XTFBATHHEADER structures.\n\n   unsigned char *Ptr = (unsigned char *)PingHeader;\n   unsigned char *BathyPacket;\n   static DWORD LastTimeTag = 0L, BathyTimeTag;\n   static DWORD AvgN=0, AvgD=0;\n\n   // skip past the ping header\n   Ptr += sizeof(XTFBATHHEADER);\n\n   BathyPacket = Ptr;\n\n   // BathyPacket now points to the raw data sent up by the\n   // SEABAT (or Odom ECHOSCAN).  To determine what kind of\n   // raw data, we must look at the data directly.\n   //\n   // See the Reson or Odom documentation for details on their\n   // binary data format.\n\n   // BathyPacket points to single binary data packet.  The length\n   // of that packet can be determined by the Seabat or Echoscan.\n   // Currently, there are only three packets recognized:\n   // 1. Seabat R-Theta (140 bytes)\n   // 2. Seabat RI-Theta (210 bytes)\n   // 3. Echoscan R-Theta (80 bytes)\n\n   // Do whatever Bathymetry processing here.  BathyPacket\n   // points to the binary multibeam data.  The relative time\n   // for this ping (in milliseconds) is given by\n   //\n   BathyTimeTag = PingHeader->AttitudeTimeTag;\n\n   if (LastTimeTag) {\n      if (BathyTimeTag < LastTimeTag) {\n         // printf(\"\\n*****BATHY TIME WENT BACKWARDS by %ld milliseconds!\\n\",LastTimeTag-BathyTimeTag);\n      }\n      else {\n         AvgN += (BathyTimeTag - LastTimeTag);\n         AvgD ++;\n\n         // printf(\"Bathy time diff: %ld (avg=%ld)\\n\", BathyTimeTag - LastTimeTag, AvgN/ AvgD);\n      }\n   }\n   LastTimeTag = BathyTimeTag;\n   //\n   // Use this time tag to correlate the Attitude (TSS or MRU) data\n   // with this multibeam data.\n\n}\n\nvoid ProcessAttitudeUpdate(XTFATTITUDEDATA *AttitudeData) {\n/****************************************************************************/\n// AttitudeData points to a single 64-byte structure that holds a \n// TSS or MRU update.\n\n   DWORD AttitudeTimeTag = AttitudeData->TimeTag;\n   float Pitch           = AttitudeData->Pitch;\n   float Roll            = AttitudeData->Roll;\n   float Heave           = AttitudeData->Heave;\n   float Yaw             = AttitudeData->Yaw;\n   static DWORD LastTimeTag;\n   static DWORD AvgN=0, AvgD=0;\n\n\n   //\n   // Use AttitudeTimeTag to correlate this attitude update with\n   // the multibeam data.  Consider putting the data received by\n   // this function in a circular buffer.  Then, use BathyTimeTag\n   // as a value to perform interpolation on the attitude data to\n   // closely approximate the attitude at BathyTimeTag.\n   //\n\n   if (LastTimeTag) {\n      if (AttitudeTimeTag < LastTimeTag) {\n         // printf(\"\\n******* ATTITUDE TIME JITTERED by %ld milliseconds\\n\", LastTimeTag - AttitudeTimeTag);\n      }\n      else {\n         AvgN += (AttitudeTimeTag - LastTimeTag);\n         AvgD++;\n         // printf(\"Attitude Time dif: %ld (avg=%ld)\\n\", AttitudeTimeTag - LastTimeTag, AvgN/AvgD);\n      }\n\n   }\n   LastTimeTag = AttitudeTimeTag;\n}\n\nvoid ProcessNotes(XTFNOTESHEADER *NoteHeader) {\n/****************************************************************************/\n// Stored in the XTF file whenever the user type in notes during data \n// collection.\n//\n   printf(\"\\nNote: %s\\n\", NoteHeader->NotesText);\n}\n\nvoid ProcessRawSerial(XTFRAWSERIALHEADER *SerialHeader) {\n/****************************************************************************/\n// Raw ASCII serial data as received over a serial port.  Present in file\n// only when \"SAVERAW\" present on Isis' serial template for a specific port.\n\n   printf(\"\\nPort %d: %s\\n\",\n      SerialHeader->SerialPort,\n      SerialHeader->RawAsciiData);\n}\n\n#pragma pack()\n\n", "comment_ratio": 0.2589147286821705}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n#import <CoreData/CoreData.h>\n\n@class ContactStatus, ImageCollection;\n\n@interface User : NSManagedObject\n\n@property (nonatomic, retain) NSNumber * age;\n@property (nonatomic, retain) NSNumber * age_visible;\n@property (nonatomic, retain) NSNumber * image_collection_id;\n@property (nonatomic, retain) NSString * location;\n@property (nonatomic, retain) NSNumber * location_visible;\n@property (nonatomic, retain) NSString * name;\n@property (nonatomic, retain) NSNumber * name_visible;\n@property (nonatomic, retain) NSNumber * num_profile_pics;\n@property (nonatomic, retain) NSString * password_hash;\n@property (nonatomic, retain) NSString * seeking;\n@property (nonatomic, retain) NSNumber * seeking_visible;\n@property (nonatomic, retain) NSNumber * selected_image;\n@property (nonatomic, retain) NSString * sex;\n@property (nonatomic, retain) NSNumber * sex_visible;\n@property (nonatomic, retain) NSNumber * user_id;\n@property (nonatomic, retain) NSString * username;\n@property (nonatomic, retain) NSNumber * username_visible;\n@property (nonatomic, retain) NSNumber * dataCompletion;\n@property (nonatomic, retain) NSSet *contacts;\n@property (nonatomic, retain) ImageCollection *imageCollection;\n\n- (void)fillWithJSON:(id)JSON;\n- (void)fillWithMinJSON:(id)JSON;\n- (ContactStatus *)hasContact:(ContactStatus *)contactStatus;\n- (BOOL)isContact:(User *)user;\n- (BOOL)isContactWithID:(NSInteger)contactID;\n+ (NSArray *)propertyList;\n@end\n\n@interface User (CoreDataGeneratedAccessors)\n\n- (void)addContactsObject:(ContactStatus *)value;\n- (void)removeContactsObject:(ContactStatus *)value;\n- (void)addContacts:(NSSet *)values;\n- (void)removeContacts:(NSSet *)values;\n\n@end\n\n", "comment_ratio": 0.1320754716981132}
{"lang": "c", "code": "//\n//  TrtcVoiceRoom.h\n//  ACM\n//\n//  Created by \u9ece\u5251\u950b on 2021/4/19.\n//\n\n#import <React/RCTBridgeModule.h>\n#import <React/RCTEventEmitter.h>\n#import \"TRTCVoiceRoom.h\"\n#import \"TRTCVoiceRoomDelegate.h\"\n\n@interface TrtcVoiceRoomModule : RCTEventEmitter<RCTBridgeModule, TRTCVoiceRoomDelegate>\n\n@end\n\n", "comment_ratio": 0.375}
{"lang": "c", "code": "const size_t mat4_size = sizeof(mat4_t);\n\nfloat \nmat4_determinant( const mat4_t *  _m){\n\tfloat determinant = 0.f;\n\tconst mat4_t *  m = _m;\n\tmat3_t temp = { m->_22, m->_23, m->_24, \n\t\t\t\t\tm->_32, m->_33, m->_34, \n\t\t\t\t\tm->_42, m->_43, m->_44 };\n\tdeterminant += (m->_11 * mat3_determinant(&temp));\n\ttemp = (mat3_t) { m->_21, m->_23, m->_24, \n\t\t\t\t\t  m->_31, m->_33, m->_34, \n\t\t\t\t\t  m->_41, m->_43, m->_44 };\n\t//temp._11 = m->_21; \n\t//temp._21 = m->_31; \n\t//temp._31 = m->_41;\n\tdeterminant += (m->_12 * mat3_determinant(&temp));\n\ttemp = (mat3_t) { m->_21, m->_22, m->_24, \n\t\t\t\t\t    m->_31, m->_32, m->_34, \n\t\t\t\t\t    m->_41, m->_42, m->_44 };\n\t//temp._12 = m->_22; \n\t//temp._22 = m->_32; \n\t//temp._32 = m->_42;\n\tdeterminant += (m->_13 * mat3_determinant(&temp));\n\ttemp = (mat3_t) { m->_21, m->_22, m->_23, \n\t\t\t\t\t  m->_31, m->_32, m->_33, \n\t\t\t\t\t  m->_41, m->_42, m->_43 };\n\t//temp._13 = m->_23;\n\t//temp._23 = m->_33;\n\t//temp._33 = m->_43;\n\tdeterminant += (m->_14 * mat3_determinant(&temp));\n\treturn determinant;\n}\n\nbool \nmat4_equals( const mat4_t *  m, const mat4_t *  m2){\n\treturn (m == m2) || \n\t\t   (m->_11 == m2->_11 &&\n\t\t\tm->_12 == m2->_12 &&\n\t\t\tm->_13 == m2->_13 &&\n\t\t\tm->_14 == m2->_14 &&\n\t\t\tm->_21 == m2->_21 &&\n\t\t\tm->_22 == m2->_22 &&\n\t\t\tm->_23 == m2->_23 &&\n\t\t\tm->_24 == m2->_24 &&\n\t\t\tm->_31 == m2->_31 &&\n\t\t\tm->_32 == m2->_32 &&\n\t\t\tm->_33 == m2->_33 &&\n\t\t\tm->_34 == m2->_34 &&\n\t\t\tm->_41 == m2->_41 &&\n\t\t\tm->_42 == m2->_42 &&\n\t\t\tm->_43 == m2->_43 &&\n\t\t\tm->_44 == m2->_44);\n}\n\nvoid \nmat4_transponse( mat4_t *  m){\n\tfloat temp = m->_21;\n\tm->_21 = m->_12;\n\tm->_12 = temp;\n\ttemp = m->_31;\n\tm->_31 = m->_13;\n\tm->_13 = temp;\n\ttemp = m->_32;\n\tm->_32 = m->_23;\n\tm->_23 = temp;\n\ttemp = m->_41;\n\tm->_41 = m->_14;\n\tm->_14 = temp;\n\ttemp = m->_42;\n\tm->_42 = m->_24;\n\tm->_24 = temp;\n\ttemp = m->_43;\n\tm->_43 = m->_34;\n\tm->_34 = temp;\n}\n\n\nmat4_t * \nmat4_transponse_new(const mat4_t *  m){\n\tmat4_t *newmat = mat4_copy_new(m);\n\tmat4_transponse(newmat);\n\treturn newmat;\n}\n\nvoid\nmat4_copy( mat4_t *  m, const mat4_t *  m2){\n\tm->_11 = m2->_11;\n\tm->_12 = m2->_12;\n\tm->_13 = m2->_13;\n\tm->_14 = m2->_14;\n\tm->_21 = m2->_21;\n\tm->_22 = m2->_22;\n\tm->_23 = m2->_23;\n\tm->_24 = m2->_24;\n\tm->_31 = m2->_31;\n\tm->_32 = m2->_32;\n\tm->_33 = m2->_33;\n\tm->_34 = m2->_34;\n\tm->_41 = m2->_41;\n\tm->_42 = m2->_42;\n\tm->_43 = m2->_43;\n\tm->_44 = m2->_44;\n}\n\nmat4_t * \nmat4_copy_new( const mat4_t *  m){\n\tmat4_t *newmat = malloc(mat4_size);\n\tmat4_copy(newmat, m);\n\treturn newmat;\n}\n\nvoid\nmat4_print( const mat4_t * m){\n\t#if 0\n\t\t//method cuts to stirng...must improve function for morze big numbers\n\t#endif\n\tprintf(\"\\n| %f %f %f %f |\\n| %f %f %f %f |\\n| %f %f %f %f |\\n| %f %f %f %f |\\n\", m->_11, m->_12, m->_13, m->_14\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t, m->_21, m->_22, m->_23, m->_24\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t, m->_31, m->_32, m->_33, m->_34\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t, m->_41, m->_42, m->_43, m->_44);\n}\n\nvoid \nmat4_add( mat4_t *  m, const mat4_t *  m2){\n\tm->_11 += m2->_11;\n\tm->_12 += m2->_12;\n\tm->_13 += m2->_13;\n\tm->_14 += m2->_14;\n\tm->_21 += m2->_21;\n\tm->_22 += m2->_22;\n\tm->_23 += m2->_23;\n\tm->_24 += m2->_24;\n\tm->_31 += m2->_31;\n\tm->_32 += m2->_32;\n\tm->_33 += m2->_33;\n\tm->_34 += m2->_34;\n\tm->_41 += m2->_41;\n\tm->_42 += m2->_42;\n\tm->_43 += m2->_43;\n\tm->_44 += m2->_44;\n}\n\nmat4_t * \nmat4_add_new( const mat4_t *  m, const mat4_t *  m2){\n\tmat4_t *newmat = malloc(mat4_size);\n\tnewmat->_11 = m->_11 + m2->_11;\n\tnewmat->_12 = m->_12 + m2->_12;\n\tnewmat->_13 = m->_13 + m2->_13;\n\tnewmat->_14 = m->_14 + m2->_14;\n\tnewmat->_21 = m->_21 + m2->_21;\n\tnewmat->_22 = m->_22 + m2->_22;\n\tnewmat->_23 = m->_23 + m2->_23;\n\tnewmat->_24 = m->_24 + m2->_24;\n\tnewmat->_31 = m->_31 + m2->_31;\n\tnewmat->_32 = m->_32 + m2->_32;\n\tnewmat->_33 = m->_33 + m2->_33;\n\tnewmat->_34 = m->_34 + m2->_34;\n\tnewmat->_41 = m->_41 + m2->_41;\n\tnewmat->_42 = m->_42 + m2->_42;\n\tnewmat->_43 = m->_43 + m2->_43;\n\tnewmat->_44 = m->_44 + m2->_44;\n\treturn newmat;\n}\n\nvoid \nmat4_sub( mat4_t *  m, const mat4_t *  m2){\n\tm->_11 -= m2->_11;\n\tm->_12 -= m2->_12;\n\tm->_13 -= m2->_13;\n\tm->_14 -= m2->_14;\n\tm->_21 -= m2->_21;\n\tm->_22 -= m2->_22;\n\tm->_23 -= m2->_23;\n\tm->_24 -= m2->_24;\n\tm->_31 -= m2->_31;\n\tm->_32 -= m2->_32;\n\tm->_33 -= m2->_33;\n\tm->_34 -= m2->_34;\n\tm->_41 -= m2->_41;\n\tm->_42 -= m2->_42;\n\tm->_43 -= m2->_43;\n\tm->_44 -= m2->_44;\n}\n\nmat4_t * \nmat4_sub_new( const mat4_t *  m, const mat4_t *  m2){\n\tmat4_t *newmat = malloc(mat4_size);\n\tnewmat->_11 = m->_11 - m2->_11;\n\tnewmat->_12 = m->_12 - m2->_12;\n\tnewmat->_13 = m->_13 - m2->_13;\n\tnewmat->_14 = m->_14 - m2->_14;\n\tnewmat->_21 = m->_21 - m2->_21;\n\tnewmat->_22 = m->_22 - m2->_22;\n\tnewmat->_23 = m->_23 - m2->_23;\n\tnewmat->_24 = m->_24 - m2->_24;\n\tnewmat->_31 = m->_31 - m2->_31;\n\tnewmat->_32 = m->_32 - m2->_32;\n\tnewmat->_33 = m->_33 - m2->_33;\n\tnewmat->_34 = m->_34 - m2->_34;\n\tnewmat->_41 = m->_41 - m2->_41;\n\tnewmat->_42 = m->_42 - m2->_42;\n\tnewmat->_43 = m->_43 - m2->_43;\n\tnewmat->_44 = m->_44 - m2->_44;\n\treturn newmat;\n}\n\nvoid \nmat4_mul( mat4_t *  m, const mat4_t *  m2){\n\tmat4_t temp = {\n\t\t(m->_11 * m2->_11) + (m->_12 * m2->_21) + (m->_13 * m2->_31) + (m->_14 * m2->_41),\n\t\t(m->_11 * m2->_12) + (m->_12 * m2->_22) + (m->_13 * m2->_32) + (m->_14 * m2->_42),\n\t\t(m->_11 * m2->_13) + (m->_12 * m2->_23) + (m->_13 * m2->_33) + (m->_14 * m2->_43),\n\t\t(m->_11 * m2->_14) + (m->_12 * m2->_24) + (m->_13 * m2->_34) + (m->_14 * m2->_44),\n\t\t(m->_21 * m2->_11) + (m->_22 * m2->_21) + (m->_23 * m2->_31) + (m->_24 * m2->_41),\n\t\t(m->_21 * m2->_12) + (m->_22 * m2->_22) + (m->_23 * m2->_32) + (m->_24 * m2->_42),\n\t\t(m->_21 * m2->_13) + (m->_22 * m2->_23) + (m->_23 * m2->_33) + (m->_24 * m2->_43),\n\t\t(m->_21 * m2->_14) + (m->_22 * m2->_24) + (m->_23 * m2->_34) + (m->_24 * m2->_44),\n\t\t(m->_31 * m2->_11) + (m->_32 * m2->_21) + (m->_33 * m2->_31) + (m->_34 * m2->_41),\n\t\t(m->_31 * m2->_12) + (m->_32 * m2->_22) + (m->_33 * m2->_32) + (m->_34 * m2->_42),\n\t\t(m->_31 * m2->_13) + (m->_32 * m2->_23) + (m->_33 * m2->_33) + (m->_34 * m2->_43),\n\t\t(m->_31 * m2->_14) + (m->_32 * m2->_24) + (m->_33 * m2->_34) + (m->_34 * m2->_44),\n\t\t(m->_41 * m2->_11) + (m->_42 * m2->_21) + (m->_43 * m2->_31) + (m->_44 * m2->_41),\n\t\t(m->_41 * m2->_12) + (m->_42 * m2->_22) + (m->_43 * m2->_32) + (m->_44 * m2->_42),\n\t\t(m->_41 * m2->_13) + (m->_42 * m2->_23) + (m->_43 * m2->_33) + (m->_44 * m2->_43),\n\t\t(m->_41 * m2->_14) + (m->_42 * m2->_24) + (m->_43 * m2->_34) + (m->_44 * m2->_44)\n\t};\n\tmat4_copy(m, &temp);\n}\n\nvoid \nmat4_mul_dest( mat4_t * _dest, const mat4_t *   _m, const mat4_t * _m2){\n\tmat4_t * dest = _dest;\n\tconst mat4_t *m = _m, *m2 = _m2;\n\tdest->_11 = (m->_11 * m2->_11) + (m->_12 * m2->_21) + (m->_13 * m2->_31) + (m->_14 * m2->_41);\n\tdest->_12 = (m->_11 * m2->_12) + (m->_12 * m2->_22) + (m->_13 * m2->_32) + (m->_14 * m2->_42);\n\tdest->_13 = (m->_11 * m2->_13) + (m->_12 * m2->_23) + (m->_13 * m2->_33) + (m->_14 * m2->_43);\n\tdest->_14 = (m->_11 * m2->_14) + (m->_12 * m2->_24) + (m->_13 * m2->_34) + (m->_14 * m2->_44);\n\tdest->_21 = (m->_21 * m2->_11) + (m->_22 * m2->_21) + (m->_23 * m2->_31) + (m->_24 * m2->_41);\n\tdest->_22 = (m->_21 * m2->_12) + (m->_22 * m2->_22) + (m->_23 * m2->_32) + (m->_24 * m2->_42);\n\tdest->_23 = (m->_21 * m2->_13) + (m->_22 * m2->_23) + (m->_23 * m2->_33) + (m->_24 * m2->_43);\n\tdest->_24 = (m->_21 * m2->_14) + (m->_22 * m2->_24) + (m->_23 * m2->_34) + (m->_24 * m2->_44);\n\tdest->_31 = (m->_31 * m2->_11) + (m->_32 * m2->_21) + (m->_33 * m2->_31) + (m->_34 * m2->_41);\n\tdest->_32 = (m->_31 * m2->_12) + (m->_32 * m2->_22) + (m->_33 * m2->_32) + (m->_34 * m2->_42);\n\tdest->_33 = (m->_31 * m2->_13) + (m->_32 * m2->_23) + (m->_33 * m2->_33) + (m->_34 * m2->_43);\n\tdest->_34 = (m->_31 * m2->_14) + (m->_32 * m2->_24) + (m->_33 * m2->_34) + (m->_34 * m2->_44);\n\tdest->_41 = (m->_41 * m2->_11) + (m->_42 * m2->_21) + (m->_43 * m2->_31) + (m->_44 * m2->_41);\n\tdest->_42 = (m->_41 * m2->_12) + (m->_42 * m2->_22) + (m->_43 * m2->_32) + (m->_44 * m2->_42);\n\tdest->_43 = (m->_41 * m2->_13) + (m->_42 * m2->_23) + (m->_43 * m2->_33) + (m->_44 * m2->_43);\n\tdest->_44 = (m->_41 * m2->_14) + (m->_42 * m2->_24) + (m->_43 * m2->_34) + (m->_44 * m2->_44);\n}\n\nmat4_t * \nmat4_mul_new( const mat4_t *   m, const mat4_t *   m2){\n\tmat4_t *newmat = malloc(mat4_size);\n\tnewmat->_11 = (m->_11 * m2->_11) + (m->_12 * m2->_21) + (m->_13 * m2->_31) + (m->_14 * m2->_41);\n\tnewmat->_12 = (m->_11 * m2->_12) + (m->_12 * m2->_22) + (m->_13 * m2->_32) + (m->_14 * m2->_42);\n\tnewmat->_13 = (m->_11 * m2->_13) + (m->_12 * m2->_23) + (m->_13 * m2->_33) + (m->_14 * m2->_43);\n\tnewmat->_14 = (m->_11 * m2->_14) + (m->_12 * m2->_24) + (m->_13 * m2->_34) + (m->_14 * m2->_44);\n\tnewmat->_21 = (m->_21 * m2->_11) + (m->_22 * m2->_21) + (m->_23 * m2->_31) + (m->_24 * m2->_41);\n\tnewmat->_22 = (m->_21 * m2->_12) + (m->_22 * m2->_22) + (m->_23 * m2->_32) + (m->_24 * m2->_42);\n\tnewmat->_23 = (m->_21 * m2->_13) + (m->_22 * m2->_23) + (m->_23 * m2->_33) + (m->_24 * m2->_43);\n\tnewmat->_24 = (m->_21 * m2->_14) + (m->_22 * m2->_24) + (m->_23 * m2->_34) + (m->_24 * m2->_44);\n\tnewmat->_31 = (m->_31 * m2->_11) + (m->_32 * m2->_21) + (m->_33 * m2->_31) + (m->_34 * m2->_41);\n\tnewmat->_32 = (m->_31 * m2->_12) + (m->_32 * m2->_22) + (m->_33 * m2->_32) + (m->_34 * m2->_42);\n\tnewmat->_33 = (m->_31 * m2->_13) + (m->_32 * m2->_23) + (m->_33 * m2->_33) + (m->_34 * m2->_43);\n\tnewmat->_34 = (m->_31 * m2->_14) + (m->_32 * m2->_24) + (m->_33 * m2->_34) + (m->_34 * m2->_44);\n\tnewmat->_41 = (m->_41 * m2->_11) + (m->_42 * m2->_21) + (m->_43 * m2->_31) + (m->_44 * m2->_41);\n\tnewmat->_42 = (m->_41 * m2->_12) + (m->_42 * m2->_22) + (m->_43 * m2->_32) + (m->_44 * m2->_42);\n\tnewmat->_43 = (m->_41 * m2->_13) + (m->_42 * m2->_23) + (m->_43 * m2->_33) + (m->_44 * m2->_43);\n\tnewmat->_44 = (m->_41 * m2->_14) + (m->_42 * m2->_24) + (m->_43 * m2->_34) + (m->_44 * m2->_44);\n\treturn newmat;\n}\n\nvoid \nmat4_mul_skalar( mat4_t *   m, const float skalar){\n\tm->_11 *= skalar;\n\tm->_12 *= skalar;\n\tm->_13 *= skalar;\n\tm->_14 *= skalar;\n\tm->_21 *= skalar;\n\tm->_22 *= skalar;\n\tm->_23 *= skalar;\n\tm->_24 *= skalar;\n\tm->_31 *= skalar;\n\tm->_32 *= skalar;\n\tm->_33 *= skalar;\n\tm->_34 *= skalar;\n\tm->_41 *= skalar;\n\tm->_42 *= skalar;\n\tm->_43 *= skalar;\n\tm->_44 *= skalar;\n}\n\nmat4_t * \nmat4_mul_skalar_new( const mat4_t *   m, const float skalar) {\n\tmat4_t *newmat = malloc(mat4_size);\n\tmat4_copy(newmat, m);\n\tmat4_mul_skalar(newmat, skalar);\n\treturn newmat;\n}\n\nvoid \nmat4_inverse( mat4_t *   m){\n\tmat3_t temp = {0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f};\n\tmat4_t * cof_mat4 = malloc(mat4_size);\n\ttemp = (mat3_t) { m->_22, m->_23, m->_24, m->_32, m->_33, m->_34, m->_42, m->_43, m->_44};\n\tcof_mat4->_11 = mat3_determinant(&temp);\n\ttemp = (mat3_t) { m->_21, m->_23, m->_24, m->_31, m->_33, m->_34, m->_41, m->_43, m->_44};\n\tcof_mat4->_12 = -mat3_determinant(&temp);\n\ttemp = (mat3_t) { m->_21, m->_22, m->_24, m->_31, m->_32, m->_34, m->_41, m->_42, m->_44};\n\tcof_mat4->_13 = mat3_determinant(&temp);\n\ttemp = (mat3_t) { m->_21, m->_22, m->_23, m->_31, m->_32, m->_33, m->_41, m->_42, m->_43};\n\tcof_mat4->_14 = -mat3_determinant(&temp);\n\t\n\ttemp = (mat3_t) { m->_12, m->_13, m->_14, m->_32, m->_33, m->_34, m->_42, m->_43, m->_44};\n\tcof_mat4->_21 = -mat3_determinant(&temp);\n\ttemp = (mat3_t) { m->_11, m->_13, m->_14, m->_31, m->_33, m->_34, m->_41, m->_43, m->_44};\n\tcof_mat4->_22 = mat3_determinant(&temp);\n\ttemp = (mat3_t) { m->_11, m->_12, m->_14, m->_31, m->_32, m->_34, m->_41, m->_42, m->_44};\n\tcof_mat4->_23 = -mat3_determinant(&temp);\n\ttemp = (mat3_t) { m->_11, m->_12, m->_13, m->_31, m->_32, m->_33, m->_41, m->_42, m->_43};\n\tcof_mat4->_24 = mat3_determinant(&temp);\n\t\n\ttemp = (mat3_t) { m->_12, m->_13, m->_14, m->_22, m->_23, m->_24, m->_42, m->_43, m->_44};\n\tcof_mat4->_31 = mat3_determinant(&temp);\n\ttemp = (mat3_t) { m->_11, m->_13, m->_14, m->_21, m->_23, m->_24, m->_41, m->_43, m->_44};\n\tcof_mat4->_32 = -mat3_determinant(&temp);\n\ttemp = (mat3_t) { m->_11, m->_12, m->_14, m->_21, m->_22, m->_24, m->_41, m->_42, m->_44};\n\tcof_mat4->_33 = mat3_determinant(&temp);\n\ttemp = (mat3_t) { m->_11, m->_12, m->_13, m->_21, m->_22, m->_23, m->_41, m->_42, m->_43};\n\tcof_mat4->_34 = -mat3_determinant(&temp);\n\t\n\ttemp = (mat3_t) { m->_12, m->_13, m->_14, m->_22, m->_23, m->_24, m->_32, m->_33, m->_34};\n\tcof_mat4->_41 = -mat3_determinant(&temp);\n\ttemp = (mat3_t) { m->_11, m->_13, m->_14, m->_21, m->_23, m->_24, m->_31, m->_33, m->_34};\n\tcof_mat4->_42 = mat3_determinant(&temp);\n\ttemp = (mat3_t) { m->_11, m->_12, m->_14, m->_21, m->_22, m->_24, m->_31, m->_32, m->_34};\n\tcof_mat4->_43 = -mat3_determinant(&temp);\n\ttemp = (mat3_t) { m->_11, m->_12, m->_13, m->_21, m->_22, m->_23, m->_31, m->_32, m->_33};\n\tcof_mat4->_44 = mat3_determinant(&temp);\n\t\n\tmat4_transponse(cof_mat4);\n\tmat4_mul_skalar(cof_mat4 , 1.f/mat4_determinant(m));\n\tmat4_copy(m, cof_mat4);\n\tfree(cof_mat4);\n}\n\nvoid mat4_inverse_dest(mat4_t * _dest, const mat4_t * _m)\n{\n\tconst mat4_t * m = _m;\n\tmat4_t * dest = _dest;\n\tmat3_t temp = { m->_22, m->_23, m->_24, \n\t\t\t\t    m->_32, m->_33, m->_34, \n\t\t\t\t    m->_42, m->_43, m->_44};\n\t//temp._11 = m->_12; temp._12 = m->_23; temp._13 = m->_24; \n\t//temp._21 = m->_32; temp._22 = m->_33; temp._23 = m->_34; \n\t//temp._31 = m->_42; temp._32 = m->_43; temp._33 = m->_44;\n\tdest->_11 = ((temp._11*temp._22*temp._33) +\n\t\t\t\t(temp._12*temp._23*temp._31) + \n\t\t\t\t(temp._13*temp._21*temp._32) -\n\t\t\t\t(temp._13*temp._22*temp._31) -\n\t\t\t\t(temp._12*temp._21*temp._33) -\n\t\t\t\t(temp._11*temp._23*temp._32));//mat3_determinant(&temp);\n\t//temp = (mat3_t) { m->_21, m->_23, m->_24, \n\t//\t\t\t\t\tm->_31, m->_33, m->_34, \n\t//\t\t\t\t\tm->_41, m->_43, m->_44};\n\ttemp._11 = m->_21; temp._21 = m->_31; temp._31 = m->_41;\n\tdest->_12 = -((temp._11*temp._22*temp._33) +\n\t\t\t\t(temp._12*temp._23*temp._31) + \n\t\t\t\t(temp._13*temp._21*temp._32) -\n\t\t\t\t(temp._13*temp._22*temp._31) -\n\t\t\t\t(temp._12*temp._21*temp._33) -\n\t\t\t\t(temp._11*temp._23*temp._32));//mat3_determinant(&temp);\n\t//temp = (mat3_t) { m->_21, m->_22, m->_24, \n\t//\t\t\t\t    m->_31, m->_32, m->_34, \n\t//\t\t\t\t    m->_41, m->_42, m->_44};\n\ttemp._12 = m->_22; temp._22 = m->_32; temp._32 = m->_42;\n\tdest->_13 = ((temp._11*temp._22*temp._33) +\n\t\t\t\t(temp._12*temp._23*temp._31) + \n\t\t\t\t(temp._13*temp._21*temp._32) -\n\t\t\t\t(temp._13*temp._22*temp._31) -\n\t\t\t\t(temp._12*temp._21*temp._33) -\n\t\t\t\t(temp._11*temp._23*temp._32));//mat3_determinant(&temp);\n\ttemp = (mat3_t) { m->_21, m->_22, m->_23, \n\t\t\t\t\t    m->_31, m->_32, m->_33, \n\t\t\t\t\t    m->_41, m->_42, m->_43};\n\t//temp._13 = m->_23; temp._23 = m->_33; temp._33 = m->_43;\n\tdest->_14 = -((temp._11*temp._22*temp._33) +\n\t\t\t\t(temp._12*temp._23*temp._31) + \n\t\t\t\t(temp._13*temp._21*temp._32) -\n\t\t\t\t(temp._13*temp._22*temp._31) -\n\t\t\t\t(temp._12*temp._21*temp._33) -\n\t\t\t\t(temp._11*temp._23*temp._32));//mat3_determinant(&temp);\n\t//temp = (mat3_t) { m->_12, m->_13, m->_14, \n\t//\t\t\t\t    m->_32, m->_33, m->_34, \n\t//\t\t\t\t    m->_42, m->_43, m->_44};\n\ttemp._11 = m->_12; temp._12 = m->_13; temp._13 = m->_14; \n\ttemp._21 = m->_32; temp._22 = m->_33; temp._23 = m->_34; \n\ttemp._31 = m->_42; temp._32 = m->_43; temp._33 = m->_44;\n\tdest->_21 = -((temp._11*temp._22*temp._33) +\n\t\t\t\t(temp._12*temp._23*temp._31) + \n\t\t\t\t(temp._13*temp._21*temp._32) -\n\t\t\t\t(temp._13*temp._22*temp._31) -\n\t\t\t\t(temp._12*temp._21*temp._33) -\n\t\t\t\t(temp._11*temp._23*temp._32));//mat3_determinant(&temp);\n\t//temp = (mat3_t) { m->_11, m->_13, m->_14, \n\t//\t\t\t\t    m->_31, m->_33, m->_34, \n\t//\t\t\t\t    m->_41, m->_43, m->_44};\n\ttemp._11 = m->_11; temp._21 = m->_31; temp._31 = m->_41;\n\tdest->_22 = ((temp._11*temp._22*temp._33) +\n\t\t\t\t(temp._12*temp._23*temp._31) + \n\t\t\t\t(temp._13*temp._21*temp._32) -\n\t\t\t\t(temp._13*temp._22*temp._31) -\n\t\t\t\t(temp._12*temp._21*temp._33) -\n\t\t\t\t(temp._11*temp._23*temp._32));//mat3_determinant(&temp);\n\t//temp = (mat3_t) { m->_11, m->_12, m->_14, \n\t//\t\t\t\t    m->_31, m->_32, m->_34, \n\t//\t\t\t\t    m->_41, m->_42, m->_44};\n\ttemp._12 = m->_12; temp._22 = m->_32; temp._32 = m->_42;\n\tdest->_23 = -((temp._11*temp._22*temp._33) +\n\t\t\t\t(temp._12*temp._23*temp._31) + \n\t\t\t\t(temp._13*temp._21*temp._32) -\n\t\t\t\t(temp._13*temp._22*temp._31) -\n\t\t\t\t(temp._12*temp._21*temp._33) -\n\t\t\t\t(temp._11*temp._23*temp._32));//mat3_determinant(&temp);\n\t//temp = (mat3_t) { m->_11, m->_12, m->_13, \n\t//\t\t\t\t    m->_31, m->_32, m->_33, \n\t//\t\t\t\t    m->_41, m->_42, m->_43};\n\ttemp._13 = m->_13; temp._23 = m->_33; temp._33 = m->_43;\n\tdest->_24 = ((temp._11*temp._22*temp._33) +\n\t\t\t\t(temp._12*temp._23*temp._31) + \n\t\t\t\t(temp._13*temp._21*temp._32) -\n\t\t\t\t(temp._13*temp._22*temp._31) -\n\t\t\t\t(temp._12*temp._21*temp._33) -\n\t\t\t\t(temp._11*temp._23*temp._32));//mat3_determinant(&temp);\n\t\n\t//temp = (mat3_t) { m->_12, m->_13, m->_14, \n\t//\t\t\t\t    m->_22, m->_23, m->_24, \n\t//\t\t\t\t    m->_42, m->_43, m->_44};\n\ttemp._11 = m->_12; temp._12 = m->_13; temp._13 = m->_14; \n\ttemp._21 = m->_22; temp._22 = m->_23; temp._23 = m->_24; \n\ttemp._31 = m->_42; temp._32 = m->_43; temp._33 = m->_44;\n\tdest->_31 = ((temp._11*temp._22*temp._33) +\n\t\t\t\t(temp._12*temp._23*temp._31) + \n\t\t\t\t(temp._13*temp._21*temp._32) -\n\t\t\t\t(temp._13*temp._22*temp._31) -\n\t\t\t\t(temp._12*temp._21*temp._33) -\n\t\t\t\t(temp._11*temp._23*temp._32));//mat3_determinant(&temp);\n\t//temp = (mat3_t) { m->_11, m->_13, m->_14, \n\t//\t\t\t\t    m->_21, m->_23, m->_24, \n\t//\t\t\t\t    m->_41, m->_43, m->_44};\n\ttemp._11 = m->_11; temp._21 = m->_21; temp._31 = m->_41;\n\tdest->_32 = -((temp._11*temp._22*temp._33) +\n\t\t\t\t(temp._12*temp._23*temp._31) + \n\t\t\t\t(temp._13*temp._21*temp._32) -\n\t\t\t\t(temp._13*temp._22*temp._31) -\n\t\t\t\t(temp._12*temp._21*temp._33) -\n\t\t\t\t(temp._11*temp._23*temp._32));//mat3_determinant(&temp);\n\t//temp = (mat3_t) { m->_11, m->_12, m->_14, \n\t//\t\t\t\t    m->_21, m->_22, m->_24, \n\t//\t\t\t\t    m->_41, m->_42, m->_44};\n\ttemp._12 = m->_12; temp._22 = m->_22; temp._32 = m->_42;\n\tdest->_33 = ((temp._11*temp._22*temp._33) +\n\t\t\t\t(temp._12*temp._23*temp._31) + \n\t\t\t\t(temp._13*temp._21*temp._32) -\n\t\t\t\t(temp._13*temp._22*temp._31) -\n\t\t\t\t(temp._12*temp._21*temp._33) -\n\t\t\t\t(temp._11*temp._23*temp._32));//mat3_determinant(&temp);\n\t//temp = (mat3_t) { m->_11, m->_12, m->_13, \n\t//                  m->_21, m->_22, m->_23, \n\t//\t\t\t\t    m->_41, m->_42, m->_43};\n\ttemp._13 = m->_13; temp._23 = m->_23; temp._33 = m->_43;\n\tdest->_34 = -((temp._11*temp._22*temp._33) +\n\t\t\t\t(temp._12*temp._23*temp._31) + \n\t\t\t\t(temp._13*temp._21*temp._32) -\n\t\t\t\t(temp._13*temp._22*temp._31) -\n\t\t\t\t(temp._12*temp._21*temp._33) -\n\t\t\t\t(temp._11*temp._23*temp._32));//mat3_determinant(&temp);\n\t\n\t//temp = (mat3_t) { m->_12, m->_13, m->_14, \n\t//\t\t\t        m->_22, m->_23, m->_24, \n\t//\t\t\t\t    m->_32, m->_33, m->_34};\n\ttemp._11 = m->_12; temp._12 = m->_13; temp._13 = m->_14; \n\ttemp._21 = m->_22; temp._22 = m->_23; temp._23 = m->_24; \n\ttemp._31 = m->_32; temp._32 = m->_33; temp._33 = m->_34;\n\tdest->_41 = -((temp._11*temp._22*temp._33) +\n\t\t\t\t(temp._12*temp._23*temp._31) + \n\t\t\t\t(temp._13*temp._21*temp._32) -\n\t\t\t\t(temp._13*temp._22*temp._31) -\n\t\t\t\t(temp._12*temp._21*temp._33) -\n\t\t\t\t(temp._11*temp._23*temp._32));//mat3_determinant(&temp);\n\t//temp = (mat3_t) { m->_11, m->_13, m->_14, \n\t//\t\t\t\t    m->_21, m->_23, m->_24, \n\t//\t\t\t\t    m->_31, m->_33, m->_34};\n\ttemp._11 = m->_11; temp._21 = m->_21; temp._31 = m->_31;\n\tdest->_42 = ((temp._11*temp._22*temp._33) +\n\t\t\t\t(temp._12*temp._23*temp._31) + \n\t\t\t\t(temp._13*temp._21*temp._32) -\n\t\t\t\t(temp._13*temp._22*temp._31) -\n\t\t\t\t(temp._12*temp._21*temp._33) -\n\t\t\t\t(temp._11*temp._23*temp._32));//mat3_determinant(&temp);\n\t//temp = (mat3_t) { m->_11, m->_12, m->_14, \n\t//\t\t\t\t    m->_21, m->_22, m->_24, \n\t//\t\t\t\t    m->_31, m->_32, m->_34};\n\ttemp._12 = m->_12; temp._22 = m->_22; temp._32 = m->_32;\n\tdest->_43 = -((temp._11*temp._22*temp._33) +\n\t\t\t\t(temp._12*temp._23*temp._31) + \n\t\t\t\t(temp._13*temp._21*temp._32) -\n\t\t\t\t(temp._13*temp._22*temp._31) -\n\t\t\t\t(temp._12*temp._21*temp._33) -\n\t\t\t\t(temp._11*temp._23*temp._32));//mat3_determinant(&temp);\n\t//temp = (mat3_t) { m->_11, m->_12, m->_13, \n\t//\t\t\t\t    m->_21, m->_22, m->_23, \n\t//\t\t\t\t    m->_31, m->_32, m->_33};\n\ttemp._13 = m->_13; temp._23 = m->_23; temp._33 = m->_33;\n\tdest->_44 = ((temp._11*temp._22*temp._33) +\n\t\t\t\t(temp._12*temp._23*temp._31) + \n\t\t\t\t(temp._13*temp._21*temp._32) -\n\t\t\t\t(temp._13*temp._22*temp._31) -\n\t\t\t\t(temp._12*temp._21*temp._33) -\n\t\t\t\t(temp._11*temp._23*temp._32));//mat3_determinant(&temp);\n\t\n\tmat4_transponse(dest);\n\tmat4_mul_skalar(dest , 1.f/mat4_determinant(m));\n}\n\nmat4_t * \nmat4_inverse_new( const mat4_t *  m){\n\tmat3_t temp = {0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f};\n\tmat4_t * newmat = malloc(mat4_size);\n\ttemp = (mat3_t) { m->_22, m->_23, m->_24, m->_32, m->_33, m->_34, m->_42, m->_43, m->_44};\n\tnewmat->_11 = mat3_determinant(&temp);\n\ttemp = (mat3_t) { m->_21, m->_23, m->_24, m->_31, m->_33, m->_34, m->_41, m->_43, m->_44};\n\tnewmat->_12 = -mat3_determinant(&temp);\n\ttemp = (mat3_t) { m->_21, m->_22, m->_24, m->_31, m->_32, m->_34, m->_41, m->_42, m->_44};\n\tnewmat->_13 = mat3_determinant(&temp);\n\ttemp = (mat3_t) { m->_21, m->_22, m->_23, m->_31, m->_32, m->_33, m->_41, m->_42, m->_43};\n\tnewmat->_14 = -mat3_determinant(&temp);\n\t\n\ttemp = (mat3_t) { m->_12, m->_13, m->_14, m->_32, m->_33, m->_34, m->_42, m->_43, m->_44};\n\tnewmat->_21 = -mat3_determinant(&temp);\n\ttemp = (mat3_t) { m->_11, m->_13, m->_14, m->_31, m->_33, m->_34, m->_41, m->_43, m->_44};\n\tnewmat->_22 = mat3_determinant(&temp);\n\ttemp = (mat3_t) { m->_11, m->_12, m->_14, m->_31, m->_32, m->_34, m->_41, m->_42, m->_44};\n\tnewmat->_23 = -mat3_determinant(&temp);\n\ttemp = (mat3_t) { m->_11, m->_12, m->_13, m->_31, m->_32, m->_33, m->_41, m->_42, m->_43};\n\tnewmat->_24 = mat3_determinant(&temp);\n\t\n\ttemp = (mat3_t) { m->_12, m->_13, m->_14, m->_22, m->_23, m->_24, m->_42, m->_43, m->_44};\n\tnewmat->_31 = mat3_determinant(&temp);\n\ttemp = (mat3_t) { m->_11, m->_13, m->_14, m->_21, m->_23, m->_24, m->_41, m->_43, m->_44};\n\tnewmat->_32 = -mat3_determinant(&temp);\n\ttemp = (mat3_t) { m->_11, m->_12, m->_14, m->_21, m->_22, m->_24, m->_41, m->_42, m->_44};\n\tnewmat->_33 = mat3_determinant(&temp);\n\ttemp = (mat3_t) { m->_11, m->_12, m->_13, m->_21, m->_22, m->_23, m->_41, m->_42, m->_43};\n\tnewmat->_34 = -mat3_determinant(&temp);\n\t\n\ttemp = (mat3_t) { m->_12, m->_13, m->_14, m->_22, m->_23, m->_24, m->_32, m->_33, m->_34};\n\tnewmat->_41 = -mat3_determinant(&temp);\n\ttemp = (mat3_t) { m->_11, m->_13, m->_14, m->_21, m->_23, m->_24, m->_31, m->_33, m->_34};\n\tnewmat->_42 = mat3_determinant(&temp);\n\ttemp = (mat3_t) { m->_11, m->_12, m->_14, m->_21, m->_22, m->_24, m->_31, m->_32, m->_34};\n\tnewmat->_43 = -mat3_determinant(&temp);\n\ttemp = (mat3_t) { m->_11, m->_12, m->_13, m->_21, m->_22, m->_23, m->_31, m->_32, m->_33};\n\tnewmat->_44 = mat3_determinant(&temp);\n\t\n\tmat4_transponse(newmat);\n\tmat4_mul_skalar(newmat , 1.f/mat4_determinant(m));\n\t\n\treturn newmat;\n}\n\n", "comment_ratio": 0.1256544502617801}
{"lang": "c", "code": "#ifndef __MEAL_InverseRule_H\n#define __MEAL_InverseRule_H\n\n#include \"MEAL/UnaryRule.h\"\n\nnamespace MEAL {\n\n  //! Computes the inverse of a model and its partial derivatives\n  template<class T>\n  class InverseRule : public UnaryRule<T>\n  {\n\n  public:\n\n    typedef typename T::Result Result;\n\n    // ///////////////////////////////////////////////////////////////////\n    //\n    // Function implementation\n    //\n    // ///////////////////////////////////////////////////////////////////\n\n    //! Return the name of the class\n    std::string get_name () const;\n\n  protected:\n\n    // ///////////////////////////////////////////////////////////////////\n    //\n    // Optimized implementation\n    //\n    // ///////////////////////////////////////////////////////////////////\n\n    //! Return the Result and its gradient\n    void calculate (Result& result, std::vector<Result>* gradient);\n\n  };\n\n}\n\ntemplate<class T>\nstd::string MEAL::InverseRule<T>::get_name () const\n{\n  return \"InverseRule<\" + std::string(T::Name)+ \">\";\n}\n\n\ntemplate<class T>\nvoid MEAL::InverseRule<T>::calculate (Result& result,\n\t\t\t\t      std::vector<Result>* grad)\n{\n  if (!this->model)\n    throw Error (InvalidState, \"MEAL::InverseRule::calculate\",\n\t\t \"no model to evaluate\");\n\n  if (T::verbose)\n    std::cerr << \"MEAL::InverseRule::calculate\" << std::endl;\n\n  result = inv( this->model->evaluate (grad) );\n  \n  if (T::verbose)\n    std::cerr << \"MEAL::InverseRule::calculate result\\n\"\n      \"   \" << result << std::endl;\n\n  if (!grad)\n    return;\n\n  for (unsigned igrad=0; igrad<grad->size(); igrad++)\n    (*grad)[igrad] = - result * (*grad)[igrad] * result;\n\n  if (T::verbose) {\n    std::cerr << \"MEAL::InverseRule::calculate gradient\\n\";\n    for (unsigned i=0; i<grad->size(); i++)\n      std::cerr << \"   \"\n\t   << i << \":\" << this->get_infit(i) << \"=\" << (*grad)[i] << std::endl;\n  }\n\n}\n\n\n#endif\n\n", "comment_ratio": 0.14736842105263157}
{"lang": "c", "code": "// BenchmarksUtil.h\n// Scott Grauer-Gray (sgrauerg@gmail.com)\n// Functions used across hmpp codes\n\n#ifndef BENCHMARKS_UTIL_H\n#define BENCHMARKS_UTIL_H\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/time.h>\n#include <time.h>\n#include <unistd.h>\n\n// define a small float value\n#define SMALL_FLOAT_VAL 0.00000001f\n\ndouble rtclock() {\n  struct timezone Tzp;\n  struct timeval Tp;\n  int stat;\n  stat = gettimeofday(&Tp, &Tzp);\n  if (stat != 0)\n    printf(\"Error return from gettimeofday: %d\", stat);\n  return (Tp.tv_sec + Tp.tv_usec * 1.0e-6);\n}\n\nfloat absVal(float a) {\n  if (a < 0) {\n    return (a * -1);\n  } else {\n    return a;\n  }\n}\n\nfloat percentDiff(double val1, double val2) {\n  if ((absVal(val1) < 0.01) && (absVal(val2) < 0.01)) {\n    return 0.0f;\n  }\n\n  else {\n    return 100.0f *\n           (absVal(absVal(val1 - val2) / absVal(val1 + SMALL_FLOAT_VAL)));\n  }\n}\n\n#endif // BENCHMARKS_UTIL_H\n\n", "comment_ratio": 0.10638297872340426}
{"lang": "c", "code": "#include \"sisl-copyright.h\"\n\n/*\n *\n * $Id: sh1994.c,v 1.2 2001-03-19 15:59:07 afr Exp $\n *\n */\n\n\n#define SH1994\n\n#include \"sislP.h\"\n\f\n#if defined(SISLNEEDPROTOTYPES)\nvoid sh1994(SISLSurf *s1,double aepsge,int *jstat)\n#else\nvoid sh1994(s1,aepsge,jstat)\n     SISLSurf *s1;\n     double aepsge;\n     int  *jstat;\n#endif\n/*\n*********************************************************************\n*\n*********************************************************************\n*                                                                   \n* PURPOSE    : Check if a point-surface intersection in one dimention\n*              is a simple case,\n*              i.e. the intersection will result in one single point.\n*\n*\n*\n* INPUT      : s1     - Surface in the intersection problem.\n*              aepsge - Geometry resolution.\n*\n*\n*\n* OUTPUT     : jstat  - status messages  \n*                                         = 1      : simpel case.\n*                                         = 0      : not simpel case.\n*                                         < 0      : error.\n*\n*\n* METHOD     :\n*\n*\n* REFERENCES :\n*\n* CALLS      : \n*\n* WRITTEN BY : TDO SI, 89-08.\n* REWISED BY : Vibeke Skytt, SI, 91-02.\n*              UJK, SI,91-10 Bug in first direction when a row\n*                            ends with 2 or more equal numbers.\n*                            Also added a test to include\n*                            tmax < tmin (both HUGE)\n*********************************************************************\n*/\n{\n  register int ki,kj,kh;\n  int kk1, kk2, kn1, kn2;\n  int kbez;\n  \n  double tmaxt, tmaxs;\n  double tmint, tmins;\n  double tdiff;\n  double *scoef=SISL_NULL;\n  \n  /* Init to  simple case. */\n  *jstat = 1;\n  \n  tmaxt = tmaxs = - HUGE;\n  tmint = tmins =   HUGE;\n  \n  /* Get surface attributes. */\n  kk1  = s1->ik1;\n  kk2  = s1->ik2;\n  kn1  = s1->in1;\n  kn2  = s1->in2;\n  kbez = (kk1 == kn1) && (kk2 == kn2); \n  \n  \n  /* If the surface is linear in some direction it is simpel case. */\n  if ((kk1 == 2 && kn1 == 2) || (kk2 == 2 && kn2 == 2)) goto out;\n  \n  \n  /* Run through vertices in first parameter direction to find\n     intervall of first derivative. */\n  \n  /* UJK, 91-10 */\n  /* for (kj=0, scoef=s1->ecoef; kj<kn2; kj++,scoef++) */\n  for (kj=0, scoef=s1->ecoef; kj<kn2; kj++,scoef=s1->ecoef+kn1*kj)\n     for (tdiff=DZERO, ki=1; ki<kn1; ki+=kh, scoef+=kh)\n     {\n\tfor (kh=1; ki+kh<=kn1; kh++)\n\t{\n\t   if (tdiff*(*(scoef+kh) - *(scoef+kh-1)) < DZERO)\n\t      {\n\t\t scoef += (kh-1);\n\t\t ki += (kh-1);\n\t\t kh = 1;\n\t      }\n\t      tdiff = *(scoef + kh) - *scoef;\n\t      if (fabs(tdiff) >= aepsge) break;\n\t}\n\tif (ki+kh > kn1) break;\n\t\n\ttmint = min(tmint,tdiff);\n\ttmaxt = max(tmaxt,tdiff);\n     }\n  \n  /* Run through vertices in second parameter direction to find\n     intervall of first derivative. */\n  \n  for (ki=0; ki<kn1; ki++)\n     for (tdiff=DZERO, kj=1, scoef=s1->ecoef+ki; kj<kn2; kj+=kh, scoef+=kh*kn1)\n     {\n\tfor (kh=1; kj+kh<=kn2; kh++)\n\t{\n\t   if (tdiff*(*(scoef+kh*kn1) - *(scoef+(kh-1)*kn1)) < DZERO)\n\t      {\n\t\t scoef += (kh-1)*kn1;\n\t\t kj += (kh-1);\n\t\t kh = 1;\n\t      }\n\t      tdiff = *(scoef + kh*kn1) - *scoef;\n\t      if (fabs(tdiff) >= aepsge) break;\n\t}\n\tif (kj+kh > kn2) break;\n\t\n\ttmins = min(tmins,tdiff);\n\ttmaxs = max(tmaxs,tdiff);\n     }\n\n  /* UJK, 91-10, maybe parameters not set */\n  if (tmint > tmaxt || tmins > tmaxs)\n  {\n     *jstat = 1;\n     goto out;\n  }\n  \n  /* The first derivatives decide directions of possible intersection curves. */\n  if (kbez && (tmint*tmaxt >=DZERO || tmins*tmaxs >=DZERO))\n    *jstat = 1;\n  else if (tmint*tmaxt > DZERO || tmins*tmaxs > DZERO) \n    *jstat = 1;\n  else if (tmint == tmaxt  || tmins == tmaxs) \n    *jstat = 1;\n  else\n    /* Not a simple case. */\n    *jstat = 0;\n  \n  goto out;\n out: ;\n}\n\n\n", "comment_ratio": 0.164021164021164}
{"lang": "c", "code": "#ifndef CMutexH\r\n#define CMutexH\r\n//------------------------------------------------------------------------------\r\n#include \"system/CGlobals.h\"\r\n//------------------------------------------------------------------------------\r\n\r\n//------------------------------------------------------------------------------\r\nnamespace chai3d {\r\n//------------------------------------------------------------------------------\r\n\r\n//==============================================================================\r\n/*!\r\n    \\file       CMutex.h\r\n    \\ingroup    system\r\n\r\n    \\brief\r\n    Implements support for mutex objects.\r\n*/\r\n//==============================================================================\r\n\r\n//==============================================================================\r\n/*!\r\n    \\class      cMutex\r\n    \\ingroup    system\r\n\r\n    \\brief\r\n    This class implements a mutex.\r\n\r\n    \\details\r\n    A mutex object is a synchronization object whose state is set to \r\n    signaled when it is not owned by any thread, and non-signaled when\r\n    it is owned. Only one thread at a time can own a mutex object, whose \r\n    name comes from the fact that it is useful in coordinating mutually \r\n    exclusive access to a shared resource. For example, to prevent two \r\n    threads from writing to shared memory at the same time, each thread \r\n    waits for ownership of a mutex object before executing the code that \r\n    accesses the memory. After writing to the shared memory, the thread \r\n    releases the mutex object.\r\n*/\r\n//==============================================================================\r\nclass cMutex\r\n{\r\n    //--------------------------------------------------------------------------\r\n    // CONSTRUCTOR & DESTRUCTOR:\r\n    //--------------------------------------------------------------------------\r\n\r\npublic:\r\n\r\n    //! Constructor of cMutex.\r\n    cMutex();\r\n\r\n    //! Destructor of cMutex.\r\n    virtual ~cMutex();\r\n\r\n\r\n    //--------------------------------------------------------------------------\r\n    // PUBLIC METHODS:\r\n    //--------------------------------------------------------------------------\r\n\r\npublic:\r\n\r\n    //! This method acquires the mutex.\r\n    bool acquire();\r\n\r\n    //! This method acquires the mutex only if it is not owned by another thread.\r\n    bool tryAcquire();\r\n\r\n    //! This method releases the mutex.\r\n    void release();\r\n\r\n\r\n    //--------------------------------------------------------------------------\r\n    // PROTECTED METHODS:\r\n    //--------------------------------------------------------------------------\r\n\r\nprotected:\r\n\r\n#if defined(WIN32) | defined(WIN64)\r\n    //! Mutex handle.\r\n    CRITICAL_SECTION m_mutex;\r\n#endif\r\n\r\n#if defined(LINUX) || defined(MACOSX)\r\n    //! Mutex handle.\r\n    pthread_mutex_t m_mutex;\r\n#endif\r\n};\r\n\r\n//------------------------------------------------------------------------------\r\n} // namespace chai3d\r\n//------------------------------------------------------------------------------\r\n\r\n//------------------------------------------------------------------------------\r\n#endif\r\n//------------------------------------------------------------------------------\r\n\n", "comment_ratio": 0.2357142857142857}
{"lang": "c", "code": "#ifndef DALI_OPERATORS_READER_LOADER_COCO_LOADER_H_\n#define DALI_OPERATORS_READER_LOADER_COCO_LOADER_H_\n\n#include <algorithm>\n#include <memory>\n#include <string>\n#include <vector>\n#include <utility>\n\n#include \"dali/operators/reader/loader/file_label_loader.h\"\n#include \"dali/core/common.h\"\n#include \"dali/core/error_handling.h\"\n\nnamespace dali {\n\nusing ImageIdPairs = std::vector<std::pair<std::string, int>>;\nclass CocoLoader : public FileLabelLoader {\n public:\n  explicit inline CocoLoader(\n    const OpSpec& spec,\n    std::vector<int> &offsets,\n    std::vector<float> &boxes,\n    std::vector<int> &labels,\n    std::vector<int> &counts,\n    std::vector<std::vector<int> > &masks_meta,\n    std::vector<std::vector<float> > &masks_coords,\n    bool read_masks,\n    bool save_img_ids,\n    std::vector<int> &original_ids,\n    bool shuffle_after_epoch = false) :\n      FileLabelLoader(spec, std::vector<std::pair<string, int>>(), shuffle_after_epoch),\n      spec_(spec),\n      parse_meta_files_(spec.HasArgument(\"meta_files_path\")),\n      offsets_(offsets),\n      boxes_(boxes),\n      labels_(labels),\n      counts_(counts),\n      masks_meta_(masks_meta),\n      masks_coords_(masks_coords),\n      read_masks_(read_masks),\n      save_img_ids_(save_img_ids),\n      original_ids_(original_ids) {}\n\n protected:\n  void PrepareMetadataImpl() override {\n    if (parse_meta_files_) {\n      ParseMetafiles();\n    } else {\n       ParseJsonAnnotations();\n    }\n\n    DALI_ENFORCE(Size() > 0, \"No files found.\");\n    if (shuffle_) {\n      // seeded with hardcoded value to get\n      // the same sequence on every shard\n      std::mt19937 g(kDaliDataloaderSeed);\n      std::shuffle(image_label_pairs_.begin(), image_label_pairs_.end(), g);\n    }\n    Reset(true);\n  }\n\n  void ParseMetafiles();\n\n  void ParseJsonAnnotations();\n\n  void DumpMetaFiles(std::string path, const ImageIdPairs &image_id_pairs);\n\n private:\n  const OpSpec &spec_;\n  bool parse_meta_files_;\n\n  std::vector<int> &offsets_;\n  std::vector<float> &boxes_;\n  std::vector<int> &labels_;\n  std::vector<int> &counts_;\n\n  // mask_meta: (mask_idx, offset, size)\n  // mask_coords: (all polygons concatenated )\n  std::vector<std::vector<int> > &masks_meta_;\n  std::vector<std::vector<float> > &masks_coords_;\n\n  bool read_masks_;\n  bool save_img_ids_;\n  std::vector<int> &original_ids_;\n};\n\n}  // namespace dali\n\n#endif  // DALI_OPERATORS_READER_LOADER_COCO_LOADER_H_\n\n", "comment_ratio": 0.18269230769230768}
{"lang": "c", "code": "#pragma once\n\n#include <app-common/zap-generated/enums.h>\n#include <app/OperationalDeviceProxy.h>\n#include <app/app-platform/ContentApp.h>\n#include <app/util/attribute-storage.h>\n#include <controller/CHIPCluster.h>\n#include <platform/CHIPDeviceLayer.h>\n\nusing chip::app::Clusters::ApplicationBasic::CatalogVendorApp;\nusing chip::Controller::CommandResponseFailureCallback;\nusing chip::Controller::CommandResponseSuccessCallback;\n\nnamespace chip {\nnamespace AppPlatform {\n\nclass DLL_EXPORT ContentAppFactory\n{\npublic:\n    virtual ~ContentAppFactory() = default;\n\n    // Lookup CatalogVendor App for this client (vendor id/product id client)\n    // and then write it to destinationApp\n    // return error if not found\n    virtual CHIP_ERROR LookupCatalogVendorApp(uint16_t vendorId, uint16_t productId, CatalogVendorApp * destinationApp) = 0;\n\n    // Lookup ContentApp for this catalog id / app id and load it\n    virtual ContentApp * LoadContentApp(const CatalogVendorApp & vendorApp) = 0;\n\n    // Gets the catalog vendor ID used by this platform\n    virtual uint16_t GetPlatformCatalogVendorId() = 0;\n\n    // Converts application (any catalog) into the platform's catalog Vendor\n    // and then writes it to destinationApp\n    virtual CHIP_ERROR ConvertToPlatformCatalogVendorApp(const CatalogVendorApp & sourceApp, CatalogVendorApp * destinationApp) = 0;\n};\n\nclass DLL_EXPORT ContentAppPlatform\n{\npublic:\n    static ContentAppPlatform & GetInstance()\n    {\n        static ContentAppPlatform instance;\n        return instance;\n    }\n\n    void SetupAppPlatform();\n\n    inline void SetContentAppFactory(ContentAppFactory * factory) { mContentAppFactory = factory; };\n\n    // add apps to the platform.\n    // This will assign the app to an endpoint (if it is not already added) and make it accessible via Matter\n    // returns the global endpoint for this app, or 0 if an error occurred\n    //\n    // dataVersionStorage.size() needs to be at least as big as the number of\n    // server clusters in the EmberAfEndpointType passed in.\n    EndpointId AddContentApp(ContentApp * app, EmberAfEndpointType * ep, uint16_t deviceType,\n                             const Span<DataVersion> & dataVersionStorage);\n\n    // remove app from the platform.\n    // returns the endpoint id where the app was, or 0 if app was not loaded\n    EndpointId RemoveContentApp(ContentApp * app);\n\n    // load and unload by vendor id\n    // void UnloadContentAppByVendorId(uint16_t vendorId, uint16_t productId);\n\n    // Lookup ContentApp for this client (vendor id/product id client) and load it\n    ContentApp * LoadContentAppByClient(uint16_t vendorId, uint16_t productId);\n\n    // Lookup ContentApp described by this application and load it\n    ContentApp * LoadContentApp(const CatalogVendorApp & application);\n\n    // helpful method to get a Content App by endpoint in order to perform attribute or command ops\n    ContentApp * GetContentApp(EndpointId id);\n\n    // helpful method to get a Content App by application, does not load if not found\n    ContentApp * GetContentApp(const CatalogVendorApp & application);\n\n    // sets the current app for this platform\n    void SetCurrentApp(ContentApp * app);\n\n    // returns true if there is a current app for this platform\n    inline bool HasCurrentApp() { return mCurrentAppEndpointId != kNoCurrentEndpointId; }\n\n    // returns true if the vendor/app arguments are the current app\n    bool IsCurrentApp(ContentApp * app);\n\n    // returns the current app endpoint\n    inline EndpointId GetCurrentAppEndpointId() { return mCurrentAppEndpointId; };\n\n    // unset this as current app, if it is current app\n    void UnsetIfCurrentApp(ContentApp * app);\n\n    // loads content app identified by vid/pid of client and calls HandleGetSetupPin.\n    // Returns 0 if pin cannot be obtained.\n    uint32_t GetPincodeFromContentApp(uint16_t vendorId, uint16_t productId, CharSpan rotatingId);\n\n    /**\n     * @brief\n     *   Add a binding.\n     *\n     * @param[in] device             OperationalDeviceProxy for the target device.\n     * @param[in] deviceEndpointId   The endpoint on the device containing the binding cluster.\n     * @param[in] bindingNodeId      The NodeId for the binding that will be created.\n     * @param[in] bindingGroupId     The GroupId for the binding that will be created.\n     * @param[in] bindingEndpointId  The EndpointId for the binding that will be created.\n     * @param[in] bindingClusterId   The ClusterId for the binding that will be created.\n     * @param[in] onSuccessCallback        The function to be called on success of adding the binding.\n     * @param[in] onFailureCallback        The function to be called on failure of adding the binding.\n     *\n     * @return CHIP_ERROR         CHIP_NO_ERROR on success, or corresponding error\n     */\n    CHIP_ERROR CreateBindingWithCallback(OperationalDeviceProxy * device, chip::EndpointId deviceEndpointId,\n                                         chip::NodeId bindingNodeId, chip::GroupId bindingGroupId,\n                                         chip::EndpointId bindingEndpointId, chip::ClusterId bindingClusterId,\n                                         CommandResponseSuccessCallback<app::DataModel::NullObjectType> successCb,\n                                         CommandResponseFailureCallback failureCb);\n\nprotected:\n    // requires vendorApp to be in the catalog of the platform\n    ContentApp * LoadContentAppInternal(const CatalogVendorApp & vendorApp);\n    ContentApp * GetContentAppInternal(const CatalogVendorApp & vendorApp);\n\n    static const int kNoCurrentEndpointId = 0;\n    EndpointId mCurrentAppEndpointId      = kNoCurrentEndpointId;\n\n    ContentAppFactory * mContentAppFactory = nullptr;\n    EndpointId mCurrentEndpointId;\n    EndpointId mFirstDynamicEndpointId;\n    ContentApp * mContentApps[CHIP_DEVICE_CONFIG_DYNAMIC_ENDPOINT_COUNT];\n};\n\n} // namespace AppPlatform\n} // namespace chip\n\n", "comment_ratio": 0.20382165605095542}
{"lang": "c", "code": "#import \"TTTAttributedLabel.h\"\n\ntypedef NS_ENUM(NSInteger, kCountDirection){\n    kCountDirectionUp = 0,\n    kCountDirectionDown\n};\n\n#pragma mark - TTCounterLabelDelegate\n\n@protocol TTCounterLabelDelegate <NSObject>\n@optional\n- (void)countdownDidEnd;\n@end\n\n#pragma mark - TTCounterLabel\n\n@interface TTCounterLabel : TTTAttributedLabel\n\n@property (weak) id <TTCounterLabelDelegate> countdownDelegate;\n@property (nonatomic, assign) unsigned long long currentValue;\n@property (nonatomic, assign) unsigned long long startValue;\n@property (nonatomic, assign) NSInteger countDirection;\n@property (strong, nonatomic) UIFont *boldFont;\n@property (strong, nonatomic) UIFont *regularFont;\n@property (nonatomic, assign) BOOL isRunning;\n@property (nonatomic, assign) unsigned long long resetValue;\n\n#pragma mark - Public Methods\n\n- (void)start;\n- (void)stop;\n- (void)reset;\n- (void)updateApperance;\n\n@end\n\n", "comment_ratio": 0.1590909090909091}
{"lang": "c", "code": "\ufeff#pragma once\n/**\n* Copyright (c) 2014-2020 dustpg   mailto:dustpg@gmail.com\n*\n* Permission is hereby granted, free of charge, to any person\n* obtaining a copy of this software and associated documentation\n* files (the \"Software\"), to deal in the Software without\n* restriction, including without limitation the rights to use,\n* copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the\n* Software is furnished to do so, subject to the following\n* conditions:\n*\n* The above copyright notice and this permission notice shall be\n* included in all copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n* OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#include \"ui_control.h\"\n\n#ifndef LUI_NO_UIGRID\n\n// ui namespace\nnamespace LongUI {\n    // column control\n    class UIColumn : public UIControl {\n        // super class\n        using Super = UIControl;\n    protected:\n        // ctor\n        UIColumn(const MetaControl&) noexcept;\n    public:\n        // class meta\n        static const  MetaControl   s_meta;\n        // dtor\n        ~UIColumn() noexcept override;\n        // ctor\n        explicit UIColumn(UIControl* parent = nullptr) noexcept : UIColumn(UIColumn::s_meta) { this->final_ctor(parent); }\n    public:\n        // update\n        void Update(UpdateReason reason) noexcept override;\n        // do normal event\n        //auto DoEvent(UIControl* sender, const EventArg& e) noexcept->EventAccept override;\n    public:\n        // update fitting\n        void UpdateValue(float limited, float fitting) noexcept;\n    private:\n    };\n    // get meta info for UIColumn\n    LUI_DECLARE_METAINFO(UIColumn);\n}\n\n#endif\n", "comment_ratio": 0.19672131147540983}
{"lang": "c", "code": "// Interfaces\n\n#include \"sdk.h\"\n\nextern cl_enginefunc_t *g_pEngineFuncs;\nextern cl_clientfunc_t *g_pClientFuncs;\nextern engine_studio_api_t *g_pEngineStudio;\nextern r_studio_interface_t *g_pStudioAPI;\nextern CStudioModelRenderer *g_pStudioRenderer;\n", "comment_ratio": 0.1111111111111111}
{"lang": "c", "code": "#ifndef GARNET_BIN_MEDIAPLAYER_FFMPEG_FFMPEG_VIDEO_DECODER_H_\n#define GARNET_BIN_MEDIAPLAYER_FFMPEG_FFMPEG_VIDEO_DECODER_H_\n\n#include \"garnet/bin/mediaplayer/ffmpeg/ffmpeg_decoder_base.h\"\n#include \"garnet/bin/mediaplayer/ffmpeg/ffmpeg_video_frame_layout.h\"\n#include \"lib/media/timeline/timeline_rate.h\"\n\nnamespace media_player {\n\n// Decoder implementation employing and ffmpeg video decoder.\nclass FfmpegVideoDecoder : public FfmpegDecoderBase {\n public:\n  static std::shared_ptr<Decoder> Create(AvCodecContextPtr av_codec_context);\n\n  FfmpegVideoDecoder(AvCodecContextPtr av_codec_context);\n\n  ~FfmpegVideoDecoder() override;\n\n  // AsyncNode implementation.\n  void ConfigureConnectors() override;\n\n protected:\n  // FfmpegDecoderBase overrides.\n  void OnNewInputPacket(const PacketPtr& packet) override;\n\n  int BuildAVFrame(const AVCodecContext& av_codec_context,\n                   AVFrame* av_frame) override;\n\n  PacketPtr CreateOutputPacket(\n      const AVFrame& av_frame,\n      fbl::RefPtr<PayloadBuffer> payload_buffer) override;\n\n  const char* label() const override;\n\n private:\n  // Frame buffers must be aligned on 32-byte boundaries to enable SIMD\n  // operations.\n  static const int kFrameBufferAlign = 32;\n\n  // Indicates whether the decoder has a non-zero coded size.\n  bool has_size() const {\n    return coded_size_.width() != 0 && coded_size_.height() != 0;\n  }\n\n  FfmpegVideoFrameLayout frame_layout_;\n  std::unique_ptr<StreamType> revised_stream_type_;\n\n  // TODO(dalesat): For investigation only...remove these three fields.\n  bool first_frame_ = true;\n  AVColorSpace colorspace_;\n  VideoStreamType::Extent coded_size_;\n  \n  size_t configured_output_buffer_size_ = 0;\n};\n\n}  // namespace media_player\n\n#endif  // GARNET_BIN_MEDIAPLAYER_FFMPEG_FFMPEG_VIDEO_DECODER_H_\n\n", "comment_ratio": 0.19047619047619047}
{"lang": "c", "code": "#ifndef __PLATFORMLC08L32DEFINITIONSSHARED_H__\n#define __PLATFORMLC08L32DEFINITIONSSHARED_H__\n\n\n// Function prefix\n#undef PFX\n\n#ifdef _USE_CVI_GUI\n#define PFX(_name)                                      _name\n#else\n#define PFX(_name)                                      _name\n#endif // ifdef __USE_CVI_GUI\n\n#ifdef GCC\n#define PACKED    __attribute__((packed))\n#else\n#define PACKED\n#endif\n\n//*****************************************************************************\n//*************** Header Includes *********************************************\n//*****************************************************************************\n\n#include <stdint.h>\n#include \"PlatformM7DefinitionsShared.h\"\n\n//*****************************************************************************\n//*************** Constants and Macros ****************************************\n//*****************************************************************************\n\n// Peak detector function selection\n#define _USE_CUSTOM_PULSE\n#undef  _USE_MAG_CORRECTION\n#define _USE_BAYES_DETECTOR\n#define _USE_AUTO_LED_POWER\n#define _USE_XTALK_REJECTION\n#undef  _USE_TIME_PROFILING\n#define _USE_TEMP_SLOPE\n#undef _NO_64BIT_OPS\n\n// Device\n#define LC08L32_DEFAULT_PART_NAME                       \"DEFAULT NAME\"                  ///< Default device name.\n#define LC08L32_DEFAULT_PART_NUMBER                     \"UNKNOWN\"                       ///< Default device part number.\n#define LC08L32_DEFAULT_SOFT_PART_NUMBER                VERSION_FIRMWARE_PART_NUMBER    ///< Default software part number.\n#define LC08L32_DEFAULT_SERIAL_NUMBER                   \"LEDDAR12345678-PO\"             ///< Default device serial number.\n#define LC08L32_DEFAULT_GROUP_ID                        \"LEDDARTECH\"                    ///< Default group id.\n#define LC08L32_DEFAULT_ASIC_VERSION                    \"1234\"                          ///< Default asic version.\n#define LC08L32_DEFAULT_FPGA_VERSION                    \"32912782-3\"                    ///< Default FPGA version.\n#define LC08L32_DEFAULT_MFG_NAME                        \"LeddarTech\"                    ///< Default manufacturer name.\n#define LC08L32_DEFAULT_BUILD_DATE                      \"12 January 2016\"               ///< Default build data\n#define LC08L32_DEFAULT_BOOTLD_VERSION                  \"123dd4\"                        ///< Bootloard version\n#define LC08L32_DEFAULT_OPTIONS                         0x2C                            ///< Default device options.\n\n// Platform\n#define LC08L32_DISTANCE_SCALE_BITS                     16\n#define LC08L32_DISTANCE_SCALE                          (1<<LC08L32_DISTANCE_SCALE_BITS)                                 ///< Distance scale factor to a value expressed in fixed-point.\n#define LC08L32_ADC_SCALE_BITS                          10                                                               ///< ADC scale bits.\n#define LC08L32_ADC_SCALE                               (1 << LC08L32_ADC_SCALE_BITS )                                   ///< ADC scale\n#define LC08L32_RAW_AMPLITUDE_SCALE_BITS                6u                                                               ///< Raw amplitude is expressed on 10 bits and the fractional part is on 6 bits.\n#define LC08L32_RAW_AMPLITUDE_SCALE                     (1 << LC08L32_RAW_AMPLITUDE_SCALE_BITS)                          ///< Raw amplitude scale factor to be expressed in fixed-point.\n#define LC08L32_TEMP_SENSOR_SCALE_BITS                  8                                                                ///< Temperature scale factor\n#define LC08L32_TEMP_SENSOR_SCALE                       LC08L32_TEMP_SENSOR_SCALE_BITS                                   ///< Temperature scale factor bits.\n#define LC08L32_TEMP_SCALE_BITS                         LC08L32_DISTANCE_SCALE_BITS                                      ///< Temperature scale factor to a value expressed in fixed-point. Beware,\n#define LC08L32_TEMP_SCALE                              LC08L32_DISTANCE_SCALE\n#define LC08L32_MEASUREMENT_RATE_SCALE_BITS             16\n#define LC08L32_MEASUREMENT_RATE_SCALE                  (1 << LC08L32_MEASUREMENT_RATE_SCALE_BITS)                       ///< Measurement rate scale factor to a value expressed in fixed-point Hz. Must be same as distance scale for temperature compensation of distance function.\n#define LC08L32_DEFAULT_SCAN_TIME                       0x2710                                                            ///< Default duration of one scan in 100 Mhz clock cycles.\n#define LC08L32_REFRESH_RATE_SCALE                      64\n#define LCO8L32_FPGA_FREQUENCY                          100000000\n#define LC08L32_DEFAULT_SRC_LIGHT_FREQ                  (LCO8L32_FPGA_FREQUENCY/LC08L32_DEFAULT_SCAN_TIME)               ///< Infrared source light frequency in Hz.\n#define LC08L32_BASE_SAMPLE_DISTANCE                    1.49896229F                                                      ///< Distance between two base sample points in meters.\n#define LC08L32_BEAM_RANGE_GAP                          (49 * LC08L32_DISTANCE_SCALE / 10)                               ///< (4.9m) Distance between the beam range and the selected base sample distance.\n#define LC08L32_NB_VERTICAL_CHANNELS                    1                                                                ///< Number of Leddar channels along the vertical.\n#define LC08L32_NB_REF_CHANNELS                         1                                                                ///< Number of reference channels.\n#define LC08L32_NB_HONRIZONTAL_CHANNELS                 8                                                                ///< Number of Leddar channels along the horizontal.\n#define LC08L32_NB_CHANNELS                             (LC08L32_NB_VERTICAL_CHANNELS * LC08L32_NB_HONRIZONTAL_CHANNELS+LC08L32_NB_REF_CHANNELS) ///< Total number of channel.\n#define LC08L32_DEFAULT_BASE_SAMPLE_COUNT               18                                                               ///< Default base sample count value.\n#define LC08L32_NB_BASE_SAMPLE_MIN                      2                                                                ///< Minimum authorized base sample count value.\n#define LC08L32_NB_BASE_SAMPLE_MAX                      128                                                               ///< Maximum authorized base sample count value.\n#define LC08L32_DEFAULT_ACCUMULATION_EXPONENT           8                                                                ///< Default accumulation exponent value.\n#define LC08L32_ACCUMULATION_EXPONENT_MIN               0                                                                ///< Minimum authorized accumulation exponent value.\n#define LC08L32_ACCUMULATION_EXPONENT_MAX               10                                                               ///< Maximum authorized accumulation exponent value.\n#define LC08L32_DEFAULT_OVERSAMPLING_EXPONENT           3                                                                ///< Default oversampling exponent value.\n#define LC08L32_OVERSAMPLING_EXPONENT_MIN               0                                                                ///< Minimum authorized oversampling exponent value.\n#define LC08L32_OVERSAMPLING_EXPONENT_MAX               5                                                                ///< Maximum authorized oversampling exponent value.\n#define LC08L32_DEFAULT_SEGMENT_ENABLE                  0x00FF                                                           ///< Default segment enable flag.\n#define LC08L32_NB_SAMPLES_PER_CHANNEL_MAX              1024                                                             ///< Maximum number of samples per channel (limited by RAM size --> only half of distance for 32 oversampling).\n#define LC08L32_DEFAULT_START_SCAN_OFFSET               0x0                                                              ///< Default sampling offset\n#define LC08L32_DEFAULT_TRIGGER_PERIOD                  0xffff                                                           ///< Default period of the trigger by steps of 1/8 of sampling period.\n#define LC08L32_DEFAULT_TRIGGER_CFG                     0x8                                                              ///< Default trigger enable setting\n#define LC08L32_DEFAULT_TRACE_BUFFER_TYPE               0                                                                ///< Default trace buffer state.\n#ifdef _USE_CVI_GUI\n  #define LC08L32_MAX_ECHOES_PER_CHANNEL                  60\n#else\n  #define LC08L32_MAX_ECHOES_PER_CHANNEL                  6\n#endif\n#define LC08L32_MAX_ECHOES                              (LC08L32_NB_CHANNELS*LC08L32_MAX_ECHOES_PER_CHANNEL)\n#define LC08L32_DEFAULT_FIELD_OF_VIEW                   (45*LC08L32_DISTANCE_SCALE)\n#define LC08L32_DEFAULT_YAW                             0.0F\n#define LC08L32_DEFAULT_PITCH                           0.0F\n#define LC08L32_DEFAULT_ROLL                            0.0F\n#define LC08L32_DEFAULT_POSITION_X                      0.0F\n#define LC08L32_DEFAULT_POSITION_Y                      0.0F\n#define LC08L32_DEFAULT_POSITION_Z                      0.0F\n\n// Grabber and led power\n#define LC08L32_DEFAULT_LEDPOW_ENABLE                  1\n#define LC08L32_DEFAULT_TRANS_IMP_GAIN                 2         ///< Default transimpedance gain.\n#define LC08L32_TRANS_IMP_GAIN_MIN                     0         ///< Minimum authorized transimpedance gain.\n#define LC08L32_TRANS_IMP_GAIN_MAX                     7         ///< Maximum authorized transimpedance gain.\n#define LC08L32_DEFAULT_PWM_WIDTH_1                    0x5\n#define LC08L32_DEFAULT_PWM_WIDTH_2                    0x5\n#define LC08L32_DEFAULT_PWM_WIDTH_3                    0x5\n#define LC08L32_DEFAULT_PWM_WIDTH_4                    0x5\n#define LC08L32_DEFAULT_PWM_WIDTH_5                    0x5\n#define LC08L32_DEFAULT_PWM_WIDTH_6                    0x5\n#define LC08L32_DEFAULT_PWM_WIDTH_7                    0x5\n#define LC08L32_DEFAULT_PWM_WIDTH_8                    0x5\n#define LC08L32_DEFAULT_PWM_WIDTH_9                    0x5\n#define LC08L32_DEFAULT_PWM_WIDTH_10                   0x6\n#define LC08L32_DEFAULT_PWM_WIDTH_11                   0x7\n#define LC08L32_DEFAULT_PWM_WIDTH_12                   0x9\n#define LC08L32_DEFAULT_PWM_WIDTH_13                   0xb\n#define LC08L32_DEFAULT_PWM_WIDTH_14                   0xe\n#define LC08L32_DEFAULT_PWM_WIDTH_15                   0x14\n#define LC08L32_DEFAULT_PWM_WIDTH_16                   0x20\n#define LC08L32_DEFAULT_PWM_WIDTH                      { LC08L32_DEFAULT_PWM_WIDTH_1, LC08L32_DEFAULT_PWM_WIDTH_2,  LC08L32_DEFAULT_PWM_WIDTH_3,  LC08L32_DEFAULT_PWM_WIDTH_4,  \\\n                                                         LC08L32_DEFAULT_PWM_WIDTH_5, LC08L32_DEFAULT_PWM_WIDTH_6,  LC08L32_DEFAULT_PWM_WIDTH_7,  LC08L32_DEFAULT_PWM_WIDTH_8,  \\\n                                                         LC08L32_DEFAULT_PWM_WIDTH_9, LC08L32_DEFAULT_PWM_WIDTH_10, LC08L32_DEFAULT_PWM_WIDTH_11, LC08L32_DEFAULT_PWM_WIDTH_12,  \\\n                                                         LC08L32_DEFAULT_PWM_WIDTH_13,LC08L32_DEFAULT_PWM_WIDTH_14, LC08L32_DEFAULT_PWM_WIDTH_15, LC08L32_DEFAULT_PWM_WIDTH_16 }               ///< Default pwm width.                                                                           ///< Default number of clock cycles for each PWM pulse.\n#define LC08L32_PWM_WIDTH_MIN                          0                                        ///< Minimum authorized transimpedance gain.\n#define LC08L32_PWM_WIDTH_MAX                          0xFF\n#define LC08L32_DEFAULT_PWM_PERIOD                     0x32                                     ///< Default time of one PWM cycle.\n#define LC08L32_PWM_PERIOD_MIN                         0                                        ///< Default time of one PWM cycle.\n#define LC08L32_PWM_PERIOD_MAX                         0xFF                                     ///< Default time of one PWM cycle.\n#define LC08L32_NB_PWM_PULSES                          16                                       ///< Number of pwm pulse.\n#define LC08L32_PWM_ENABLE_MIN                         0                                        ///< PWM enable min.\n#define LC08L32_PWM_ENABLE_MAX                         16\n\n#define LC08L32_DEFAULT_NB_USER_LED_POWER              5\n#define LC08L32_DEFAULT_CURRENT_USER_LED_POWER         (LC08L32_DEFAULT_NB_USER_LED_POWER-1)       ///< Current User led power level [in index]\n#define LC08L32_NB_USER_LED_POWER_MAX                  16                                          ///< Maximum authorized user led power.\n#define LC08L32_NB_USER_FIELD_MAX                      22                                          ///< Maximum authorized field led power.\n#define LC08L32_NB_PWM_PULSES                          16\n#define LC08L32_DEFAULT_TIME_BASE_DELAY                0xc\n#define LC08L32_DEFAULT_RANDOM_CTRL                    0\n#define LC08L32_DEFAULT_ADC                            0\n#define LC08L32_DEFAULT_REF_PULSE_RATE                 1\n#define LC08L32_REF_SEG_MASK                           0x100\n#define LC08L32_DEFAULT_REF_SEGMENT_ENABLE             LC08L32_REF_SEG_MASK                     ///< Enable or not the reference pulse by default\n\n// Demerge\n#define LC08L32_DEFAULT_DEM_ENABLE                     0         ///< Default demerge enable state.\n#define LC08L32_DEM_REF_PULSE_MAX_PTS                  400\n#define LC08L32_DEM_LUT_MAX_PTS                        200\n#define LC08L32_OBJECT_DEMERGING_MAX                   2\n\n// Peak detector\n// Bits field used in pulse struct (valid field)\n#define LC08L32_PULSE_INVALID               0     // Reset \"valid\" field in Pulse struct\n#define LC08L32_PULSE_VALID                 0\n#define LC08L32_PULSE_MULTOBJ               1\n#define LC08L32_PULSE_OVSHOOT               2\n#define LC08L32_PULSE_SATURAT               3\n#define LC08L32_PULSE_LOWAMP                4\n#define LC08L32_PULSE_MULTOBJ2              5\n#define LC08L32_PULSE_XTALK                 6\n#define LC08L32_PULSE_WPB                   7\n#define LC08L32_PULSE_REF                   8\n\n// Peak detector\n#define LC08L32_DEFAULT_FILTER_SUM_BITS                13                                                             ///< Number of bits added by the trace filter\n#define LC08L32_FILTER_SUM_BITS_MIN                    1\n#define LC08L32_FILTER_SUM_BITS_MAX                    16\n#define LC08L32_DEFAULT_FILTER_SUM                     (1 <<LC08L32_DEFAULT_FILTER_SUM_BITS )                        ///< The sum of all element in the filter matrix.\n#define LC08L32_DEFAULT_FILTERED_SCALE                 (LC08L32_RAW_AMPLITUDE_SCALE * LC08L32_DEFAULT_FILTER_SUM)   ///< Filter scale factor to be expressed in fixed-point.\n#define LC08L32_DEFAULT_FILTERED_SCALE_BITS            (LC08L32_DEFAULT_FILTER_SUM_BITS+LC08L32_RAW_AMPLITUDE_SCALE_BITS)\n#define LC08L32_DEFAULT_RAW_AMPLITUDE_MAX              (1020*LC08L32_RAW_AMPLITUDE_SCALE)\n#define LC08L32_DEFAULT_REAL_DISTANCE_OFFSET           ((int32_t)(2.6*LC08L32_DISTANCE_SCALE))                       ///< Difference in distance between the signal peak and the real distance: 2.6 m\n#define LC08L32_REAL_DISTANCE_OFFSET_MIN               ((int32_t)(0*LC08L32_DISTANCE_SCALE))\n#define LC08L32_REAL_DISTANCE_OFFSET_MAX               ((int32_t)(10*LC08L32_DISTANCE_SCALE))\n#define LC08L32_NB_COEFF_FILTER_MAX                    68                                                             ///< Maximum authorized number of coefficients in a Gaussian filter. BEWARE: must be an even value and a multiple of 4.\n#define LC08L32_BAYES_STD_LUT_SIZE_MAX                 5\n#define LC08L32_MAG_CORRECTION_LUT_SIZE_MAX            50\n#define LC08L32_XTALK_NB_TYPE_MAX                      10\n#define LC08L32_SATURATION_DIS_LUT_SIZE_MAX            16\n#define LC08L32_SATURATION_AMP_LUT_SIZE_MAX            16\n#define LC08L32_ACCUMULATION_DEM_EXPONENT_MIN           6\n#define LC08L32_OVERSAMPLING_DEM_EXPONENT_MIN           3\n#define LC08L32_REF_PULSE_FACTOR_SCALE_BITS             6\n\n// Crosstalk removal\n#define LC08L32_DIFF_EQ_MAX                            8\n#define LC08L32_TEMPLATE_MAX                           8\n#define LC08L32_DIFF_EQ_COEFF_MAX                      21\n#define LC08L32_TEMPLATE_COUNT_MAX                     200\n\n// Static noise removal\n#define LC08L32_DEFAULT_STNOIRMV_ENABLE                1                                                               ///< Static noise removal for standard segment\n#define LC08L32_DEFAULT_STNOIRMV_ENABLE_REFPULSE       1                                                               ///< Static noise removal for reference segment\n#define LC08L32_OVERSAMPLING_EXPONENT_CALIB            3                                                               ///< Maximum oversampling exponent authorized during a learning.\n#define LC08L32_OVERSAMPLING_CALIB                     (1 << LC08L32_OVERSAMPLING_EXPONENT_CALIB)                      ///< Maximum oversampling authorized during a learning.\n#define LC08L32_NB_BASE_SAMPLE_MIN_CALIB               1                                                               ///< Minimum authorized number base sample.\n#define LC08L32_NB_BASE_SAMPLE_MAX_CALIB               15                                                              ///< Maximum authorized number base sample.\n\n// Mathematics\n#define LC08L32_DELAY_SCALE_BITS                       16\n\n// Refresh Rate\n#define LC08L32_REFRESH_RATE_NUM_SCALE                 (1<<16)\n#define LC08L32_REFRESH_RATE_DEN_SCALE                 (1<<10)\n\n#endif  /* __PLATFORMLC08L32DEFINITIONSSHARED_H__ */\n\n// End of PlatformLC08l32DefinitionShared.h\n\n", "comment_ratio": 0.3940677966101695}
{"lang": "c", "code": "@class NSString;\n\n@protocol PLCloudPersistentHistoryMigratorContext\n- (void)updateTransferCountsWithInsertedPhotoCount:(unsigned long long)arg1 insertedVideoCount:(unsigned long long)arg2;\n- (void)saveTokenObject:(id)arg1;\n- (void)resetSyncDueToMigrationMarker;\n- (NSString *)readLocalVersion;\n- (void)setLocalVersion:(NSString *)arg1;\n- (void)setMigratedLocalVersion:(NSString *)arg1;\n- (void)setMigrationMarker:(id)arg1;\n- (id)readMigrationMarker;\n@end\n\n\n", "comment_ratio": 0.25}
{"lang": "c", "code": "#import \"AFWStockBaseModel.h\"\n\n@class NSString;\n\n@interface AFWStockNewsListFlagTypePairModel : AFWStockBaseModel\n{\n    NSString *_flag;\n    NSString *_type;\n}\n\n@property(retain, nonatomic) NSString *type; // @synthesize type=_type;\n@property(retain, nonatomic) NSString *flag; // @synthesize flag=_flag;\n- (void).cxx_destruct;\n- (id)initWithRpcResult:(id)arg1;\n\n@end\n\n\n", "comment_ratio": 0.2916666666666667}
{"lang": "c", "code": "#ifndef WireFrames_h\n#define WireFrames_h\n\n#import \"BUNewsWireFrame.h\"\n#import \"BUScheduleWireFrame.h\"\n#import \"BUNavigationWireFrame.h\"\n#import \"BUSettingsWireFrame.h\"\n#import \"BUGreetingsWireFrame.h\"\n#import \"BUReferenceWireFrame.h\"\n\n#endif /* WireFrames_h */\n\n", "comment_ratio": 0.35}
{"lang": "c", "code": "#include <debug.h>\n#include <string.h>\n#include <platform/iomap.h>\n#include <platform/reg_physical.h>\n#include <platform/tcc_ckc.h>\n#include <platform/CM4_earlycam.h>\n#include <bitmap.h>\n#include <dev/camera/camera.h>\n#include <dev/camera/sensor_if.h>\n#ifdef EARLY_CAM_MODULE_TW9921\n#include <dev/camera/tw9921.h>\n#endif\n#ifdef EARLY_CAM_MODULE_TW9990\n#include <dev/camera/tw9990.h>\n#endif\n#include <splash/splashimg.h>\n\n#include <clock.h>\n#include <platform/timer.h>\n#include <kernel/thread.h>\n\n#define SYNC_BASE_SIZE\t0x1000\n#define SYNC_BASE_ADDR\t(HwCORTEXM4_DATA_MEM_BASE + HwCORTEXM4_DATA_MEM_SIZE - SYNC_BASE_SIZE)\n\nstatic int DEBUG_EARLY_CAM = 0;\n\n#include <tcc_lcd.h>\nextern pmap_info_t gPmap[PMAP_MAX];\n\nvoid tcc_cif_vioc_register_dump(void) {\n\tstruct reg_test {\n\t\t\tunsigned int * reg;\n\t\t\tunsigned int cnt;\n\t};\n\tstruct reg_test regList[] = {\n//\t\t\t\t\t{ (unsigned int *)HwVIOC_RDMA16,\t\t12 },\n\t\t\t\t\t{ (unsigned int *)HwVIOC_VIN00, \t\t16 },\n\t\t\t\t\t{ (unsigned int *)HwVIOC_SC0,\t\t\t 8 },\n\t\t\t\t\t{ (unsigned int *)HwVIOC_WMIX5, \t\t28 },\n\t\t\t\t\t{ (unsigned int *)HwVIOC_WDMA05,\t\t18 },\n\t\t\t\t\t{ (unsigned int *)HwVIOC_RDMA05,\t\t12 },\n\t\t\t\t\t{ (unsigned int *)HwVIOC_WMIX1, \t\t28 },\n\t\t\t\t\t{ (unsigned int *)HwVIOC_WMIX0, \t\t28 },\n   };\n\tunsigned int * addr;\n\tunsigned int reg, idxLoop, nReg, idxReg;\n\n\tdprintf(INFO,\"\\n\\n\");\n\tfor(idxLoop=0; idxLoop<sizeof(regList)/sizeof(regList[0]); idxLoop++) {\n\t\t\taddr\t= regList[idxLoop].reg;\n\t\t\tnReg\t= regList[idxLoop].cnt;\n\t\t\tfor(idxReg=0; idxReg<nReg; idxReg++) {\n\t\t\t\t\tif((idxReg%4) == 0)\n\t\t\t\t\t\t\tdprintf(INFO,\"\\n%08x: \", (unsigned int)(addr + idxReg));\n\n//\t\t\t\t\tREGREAD((unsigned int)(addr + idxReg), reg);\n\t\t\t\t\treg = *((volatile unsigned int *) (addr + idxReg));\n\t\t\t\t\tdprintf(INFO,\"%08x \", reg);\n\t\t\t}\n\t\t\tdprintf(INFO,\"\\n\");\n\t}\n\tdprintf(INFO,\"\\n\\n\");\n}\n\nvoid tcc_cif_delay(int ms) {\n\tvolatile unsigned int msec = ms / 10; //10msec unit\n\t\n\tif(!msec)\tmdelay(1);\n\telse\t\tmdelay(msec);\n}\n\nvoid tcc_mbox_flush_buffers(void) {\n\tvolatile MAILBOX\t* pMbox;\n\t\n\t// flush mbox0\n\tpMbox = (volatile MAILBOX *)HwCORTEXM4_MAILBOX0_BASE;\n\tmemset((void *)&pMbox->uMBOX_TX0, 0, sizeof(unsigned int) * 8);\n\t\n\t// flush mbox0\n\tpMbox = (volatile MAILBOX *)HwCORTEXM4_MAILBOX1_BASE;\n\tmemset((void *)&pMbox->uMBOX_TX0, 0, sizeof(unsigned int) * 8);\n}\n\nint tcc_mbox_receive_msg(cm_ctrl_msg_t * msg) {\n\tvolatile MAILBOX\t* pMbox\t= (volatile MAILBOX *)HwCORTEXM4_MAILBOX0_BASE;\n\tunsigned int\t\tscount\t= 0;\n\t\n\t// Data received\n\t// Wait until data received...\n\t// If \"SEMP\" is low, the message has been arrived and than \"SCOUNT\"\n\t// indicates the total number of received messages in word unit.\n//\tscount = (unsigned int)pMbox->uMBOX_STATUS.bREG.SCOUNT;\n\tscount = (unsigned int)((pMbox->uMBOX_CTL_017.nREG >> 20) & 0xF);\n//\tprintf(\"[LK] %s - STATUS[0x%08x]: 0x%08x, SCOUNT: %d\\n\", __func__, (unsigned int)&pMbox->uMBOX_STATUS, (unsigned int)pMbox->uMBOX_STATUS.nREG, scount);\n//\tprintf(\"[LK] %s - STATUS[0x%08x]: 0x%08x, SCOUNT: %d\\n\", __func__, (unsigned int)&pMbox->uMBOX_CTL_017, (unsigned int)pMbox->uMBOX_CTL_017.nREG, scount);\n\tif(scount != 8) {\n\t\treturn -1;\n\t}\n\t\n\t// Read Data from FIFO\n\t// The sequence of read operation can be replaced to burst read to the receive fifo data region\n\t// After reading done, the empty status of the counter-part goes to \"HIGH\" means empty\n\tmemcpy((void *)msg, (const void *)&pMbox->uMBOX_RX0, sizeof(cm_ctrl_msg_t));\n\t\n\treturn 0;\n}\n\nunsigned int tcc_mbox_wait_receive_msg(cm_ctrl_msg_t * msg_to_check) {\n\tunsigned int\tack_to_check\t= msg_to_check->cmd | MAILBOX_MSG_ACK;\n\tcm_ctrl_msg_t\tmsg_to_receive;\n\tvolatile int\ttimeout = 100000;\n\tint\t\tret;\n\t\n\tdo {\n\t\tret = tcc_mbox_receive_msg(&msg_to_receive);\n\t\tif(!ret) {\n\t\t\tif(DEBUG_EARLY_CAM) {\n\t\t\t\tprintf(\"[LK] Rx: 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x\\n\",\t\\\n\t\t\t\t\tmsg_to_receive.preamble,\t\\\n\t\t\t\t\tmsg_to_receive.data[5],\t\t\\\n\t\t\t\t\tmsg_to_receive.data[4],\t\t\\\n\t\t\t\t\tmsg_to_receive.data[3], \t\\\n\t\t\t\t\tmsg_to_receive.data[2],\t\t\\\n\t\t\t\t\tmsg_to_receive.data[1],\t\t\\\n\t\t\t\t\tmsg_to_receive.data[0],\t\t\\\n\t\t\t\t\tmsg_to_receive.cmd);\n\t\t\t}\n\t\t\tif(msg_to_receive.cmd == ack_to_check)\n\t\t\t\treturn 0;\n\t\t}\n\t\tmdelay(1);\n\t} while(0 < --timeout);\n\treturn -1;\n}\n\nint tcc_mbox_send_msg(/*const */cm_ctrl_msg_t * msg) {\n\tvolatile MAILBOX\t* pMbox\t = (volatile MAILBOX *)HwCORTEXM4_MAILBOX0_BASE;\n\tvolatile int\t\ttimeout =  100000;\n\n\t// set preamble\n\tmsg->preamble\t= MAILBOX_MSG_PREAMBLE;\n\t\n\t// Flush transmit FIFO or Wait until empty of transmit FIFO\n\t// Can be skipped by case\n\t\n\t// Set \"OEN\" to Low\n\t// To protect the invalid event which can be generated during writing data\n\tpMbox->uMBOX_CTL_016.bREG.OEN = 0;\n\t\n\t// Write Data to FIFO\n\t// The sequence of writing operation can be replaced to burst writing to the transmit fifo data region\n\tif(DEBUG_EARLY_CAM) {\n\t\tprintf(\"[LK] Tx: 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x\\n\",      \\\n\t\t\tmsg->preamble,\t\t\\\n\t\t\tmsg->data[5],\t\t\\\n\t\t\tmsg->data[4],\t\t\\\n\t\t\tmsg->data[3],\t\t\\\n\t\t\tmsg->data[2],\t\t\\\n\t\t\tmsg->data[1],\t\t\\\n\t\t\tmsg->data[0],\t\t\\\n\t\t\tmsg->cmd);\n\t}\n\tmemcpy((void *)&pMbox->uMBOX_TX0, (const void *)msg, sizeof(cm_ctrl_msg_t));\n\t\n\t// Set \"OEN\" to HIGH\n\t// After this, the event(interrupt) for \"SendMessage\" will occur to counter-part\n\tpMbox->uMBOX_CTL_016.bREG.OEN = 1;\n\t\n\t// Check \"MEMPTY\" being true\n#if 1\n\twhile(((pMbox->uMBOX_CTL_017.nREG & 0x1) == 0) && timeout > 0) {\n\t\tmdelay(1);\n//\t\tif(DEBUG_EARLY_CAM) printf( \"[LK] - pMbox->uMBOX_STATUS.bREG.MEMP == 0\\n\");\n\t\ttimeout--;\n\t}\n\n\tif(timeout <= 0) {\n\t\tdprintf(INFO, \"!@#---- %s - fail(timeout) \\n\", __func__);\n\t\treturn -1;\n\t}\n#else\n\twhile(((pMbox->uMBOX_CTL_017.nREG & 0x1) == 0))\n\t\tdprintf(SPEW, \"[CM] pMbox->uMBOX_STATUS.bREG.MEMP == 0\\n\");\n#endif\n\n\treturn 0;\n}\n\nvoid CM_MailBox_Configure(void) {\n\tvolatile PMAILBOX pMbox_M\t= (volatile PMAILBOX)HwCORTEXM4_MAILBOX0_BASE;\n\tvolatile PMAILBOX pMbox_S\t= (volatile PMAILBOX)HwCORTEXM4_MAILBOX1_BASE;\n\tvolatile PCM_TSD_CFG pTSDCfg\t= (volatile PCM_TSD_CFG)HwCORTEXM4_TSD_CFG_BASE;\n\t\n\ttcc_mbox_flush_buffers();\n\t/* Interrupt isn't used in Cortex-M4 */\n//\tBITSET(pMbox_M->uMBOX_CTL_016.nREG, Hw6|Hw5|Hw4|Hw1|Hw0);\n//\tBITSET(pMbox_S->uMBOX_CTL_016.nREG, Hw6|Hw5|Hw4|Hw1|Hw0);\n\tBITSET(pMbox_M->uMBOX_CTL_016.nREG, Hw6|Hw5);\n\tBITSET(pMbox_S->uMBOX_CTL_016.nREG, Hw6|Hw5);\n\tBITSET(pTSDCfg->IRQ_MASK_POL.nREG, Hw16|Hw22);\n}\n\nvoid CM_UnloadBinary(void) {\n\tvolatile unsigned int * pCodeMem = (volatile unsigned int *)HwCORTEXM4_CODE_MEM_BASE;\n\tvolatile PCM_TSD_CFG    pTSDCfg  = (volatile PCM_TSD_CFG   )HwCORTEXM4_TSD_CFG_BASE;\n\t\n\t// turn off\n\tBITSET(pTSDCfg->CM_RESET.nREG, Hw2|Hw1);\n\t\n\t// clear all code memory\n\tmemset((void *)pCodeMem, 0, HwCORTEXM4_CODE_MEM_SIZE);\t// CODE_MEM_SIZE == 64KB on CM4\n}\n\nvoid CM_LoadBinary(unsigned char * fw_data, unsigned int fw_size) {\n\tvolatile unsigned int * pCodeMem = (volatile unsigned int *)HwCORTEXM4_CODE_MEM_BASE;\n\tvolatile PCM_TSD_CFG    pTSDCfg  = (volatile PCM_TSD_CFG   )HwCORTEXM4_TSD_CFG_BASE;\n\t\n\t// unload and clear all code memory\n\tCM_UnloadBinary();\n\t\n\t//dprintf(INFO, \"!@#---- %s - DST: 0x%08x, SRC: 0x%08x, SIZE: %d\\n\", __func__,\t\\\n\t\t(unsigned)pCodeMem, (unsigned)fw_data, (unsigned)fw_size);\n\tif((fw_data != NULL) && (0 < fw_size)) {\n\t\t// clear all memory\n\t\tmemset((void *)pCodeMem, 0, (HwCORTEXM4_CODE_MEM_SIZE + HwCORTEXM4_DATA_MEM_SIZE) - SYNC_BASE_SIZE);\n\t\t// copy image to run\n\t\tmemcpy((void *)pCodeMem, (void *)fw_data, fw_size);\n\t} else {\n\t\tdprintf(INFO,\"Using previous loading the firmware\\n\");\n\t}\n\t\n\t// turn on\n\tBITCLR(pTSDCfg->CM_RESET.nREG, Hw2|Hw1);\n}\n\nextern struct tcc_cif_parameters * parameters_data;\n\nvoid tcc_sync_parameters(void) {\n\tstruct lcd_panel *panel_info;\n\tpanel_info = tccfb_get_panel();\n\n\t// calculate pmap address\n\tparameters_data->Lcdc_address0  = gPmap[PMAP_EARLYCAM_PREVIEW].pbase;\n\tparameters_data->PGL_addr       = gPmap[PMAP_EARLYCAM_PGL].pbase;\n\tparameters_data->Viqe_area      = gPmap[PMAP_EARLYCAM_VIQE].pbase;\n\n\t// set width, height size\n\tparameters_data->viocmg_info.early_cam_preview_width    = panel_info->xres;\n\tparameters_data->viocmg_info.early_cam_preview_height   = panel_info->yres;\n\n\tparameters_data->viocmg_info.early_cam_parking_line_width   = panel_info->xres;\n\tparameters_data->viocmg_info.early_cam_parking_line_height  = panel_info->yres;\n\n\tdprintf(INFO, \"parameters_data->size : %d \\n\", sizeof(struct tcc_cif_parameters));\n\tdprintf(INFO, \"earlycam PGL base addr : 0x%x 0x%x \\n\", \\\n\t\t\t\tparameters_data->PGL_addr,  gPmap[PMAP_EARLYCAM_PGL].pbase);\n\tdprintf(INFO, \"earlycam PREVIEW base addr : 0x%x 0x%x \\n\", \\\n\t\t\t\tparameters_data->Lcdc_address0, gPmap[PMAP_EARLYCAM_PREVIEW].pbase);\n\tdprintf(INFO, \"earlycam VIQE base addr : 0x%x 0x%x \\n\", \\\n\t\t\t\tparameters_data->Viqe_area, gPmap[PMAP_EARLYCAM_VIQE].pbase);\n\tdprintf(INFO, \"early view width : %d, early view height : %d \\n\", \\\n\t            parameters_data->viocmg_info.early_cam_preview_width, parameters_data->viocmg_info.early_cam_preview_height);\n\n\tmemset((void *)SYNC_BASE_ADDR, 0, SYNC_BASE_SIZE);\n\tmemcpy((void *)SYNC_BASE_ADDR, parameters_data, sizeof(struct tcc_cif_parameters));\n}\n\nvoid parking_guide_clear(void) {\n\tunsigned int parking_guide = parameters_data->PGL_addr;\n\tmemset((void *)parking_guide, 0xff, (parameters_data->viocmg_info.early_cam_parking_line_width * parameters_data->viocmg_info.early_cam_parking_line_height * 4));\n}\n\nint set_parking_guide_loading_status(int onOff) {\n\tcm_ctrl_msg_t\tmsg;\n\n\tif(onOff) {\n\t\t// wati until receiving stop msg\n\t\tmsg.cmd \t= MAILBOX_MSG_EARLYCAMERA_PGL;\n\n\t\ttcc_mbox_send_msg(&msg);\n//\t\ttcc_mbox_wait_receive_msg(&msg);\n\t}\n\n\treturn 0;\n}\n\nunsigned int load_parking_guide(void) {\n\tulong splah_width, splah_height;\n\tunsigned int ret;\n\tstruct fbcon_config pgl_cfg;\n\n\tpgl_cfg.base = parameters_data->PGL_addr;\n\n\tprintf(\"early_cam change parking line %d\\r\\n\", parameters_data->viocmg_info.feature_early_view_use_parking_line);\n\n\tif(parameters_data->viocmg_info.feature_early_view_use_parking_line) {\n\t\tret = splash_image_load(CONFIG_TCC_PARKING_GUIDE_LINE_NAME, &pgl_cfg);\n\t\tif(ret != -1) {\n\t\t\tif(pgl_cfg.width <= parameters_data->viocmg_info.early_cam_parking_line_width || pgl_cfg.height <= parameters_data->viocmg_info.early_cam_parking_line_height) {\n\t\t\t\tparameters_data->viocmg_info.early_cam_parking_line_width = pgl_cfg.width;\n\t\t\t\tparameters_data->viocmg_info.early_cam_parking_line_height = pgl_cfg.height;\n\n\t\t\t\tif(pgl_cfg.width < parameters_data->viocmg_info.early_cam_preview_width) {\n\t\t\t\t\tparameters_data->viocmg_info.early_cam_parking_line_x = (parameters_data->viocmg_info.early_cam_preview_width - pgl_cfg.width) >> 1;\n\t\t\t\t}\n\t\t\t\tif(pgl_cfg.height < parameters_data->viocmg_info.early_cam_preview_height) {\n\t\t\t\t\tparameters_data->viocmg_info.early_cam_parking_line_y = (parameters_data->viocmg_info.early_cam_preview_height - splah_height) >> 1;\n\t\t\t\t}\n\n\t\t\t\t((struct tcc_cif_parameters *)SYNC_BASE_ADDR)->viocmg_info.early_cam_parking_line_width = pgl_cfg.width;\n\t\t\t\t((struct tcc_cif_parameters *)SYNC_BASE_ADDR)->viocmg_info.early_cam_parking_line_height = pgl_cfg.height;\n\t\t\t\t((struct tcc_cif_parameters *)SYNC_BASE_ADDR)->viocmg_info.early_cam_parking_line_x = parameters_data->viocmg_info.early_cam_parking_line_x;\n\t\t\t\t((struct tcc_cif_parameters *)SYNC_BASE_ADDR)->viocmg_info.early_cam_parking_line_y = parameters_data->viocmg_info.early_cam_parking_line_y;\n\n\t\t\t\tset_parking_guide_loading_status(1);\n\n\t\t\t\tif(DEBUG_EARLY_CAM) printf(\"early_cam change parking line size to %dx%d\\r\\n\",\n\t\t\t\t\t\t\t\t\t\t\tparameters_data->viocmg_info.early_cam_parking_line_width,\n\t\t\t\t\t\t\t\t\t\t\tparameters_data->viocmg_info.early_cam_parking_line_height);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t((struct tcc_cif_parameters *)SYNC_BASE_ADDR)->viocmg_info.feature_early_view_use_parking_line = 0;\n\t\t\t\tparameters_data->viocmg_info.feature_early_view_use_parking_line = 0;\n\t\t\t\tprintf(\"PGL is larger than lcd panel!! PGL is disabled...\\n\");\n\t\t\t}\n\t\t}\n\t}\n}\n\nint startEarlyCamera(void) {\n\tcm_ctrl_msg_t\tmsg;\n\n\t// decoder start\n\tsensor_if_open();\n\ttcc_cif_delay(10);\n\t\n\t// enable cm clk\n\ttcc_set_clkctrl(FBUS_CMBUS, ENABLE, 100000000);\n\n\t// syncronize parameters\n\ttcc_sync_parameters();\n\t\n\t// set mbox\n\tCM_MailBox_Configure();\n\t\n\t// load EarlyCamera image\n\tCM_LoadBinary(CM4_earlycam, sizeof(CM4_earlycam));\n#if 0\t\n\t// wati until receiving ready msg\n\tmsg.cmd\t\t= MAILBOX_MSG_EARLYCAMERA_READY;\n\ttcc_mbox_wait_receive_msg(&msg);\n#endif\t\n\treturn 0;\n}\n\nint stopEarlyCamera(void) {\n\tcm_ctrl_msg_t\tmsg;\n\t\n\t// wati until receiving stop msg\n\tmsg.cmd\t\t= MAILBOX_MSG_EARLYCAMERA_STOP;\n\ttcc_mbox_send_msg(&msg);\n\ttcc_mbox_wait_receive_msg(&msg);\n\t\n\t// unload EarlyCamera image\n\tCM_UnloadBinary();\n\t\n\t// disable cm clk\n//\ttcc_set_clkctrl(FBUS_CMBUS, DISABLE, 1000000);\n//\ttcc_cif_delay(10);\n\t\n\t// decoder start\n\tsensor_if_close();\n\t\n\treturn 0;\n}\n\nstatic int cm4_clk = 0;\n\nlong tcc_cm4_ctrl_ioctl(unsigned int cmd, unsigned long arg) {\n#if defined(DAUDIO_KK_3HW_GPIO)\n\tswitch (cmd) {\n\tcase IOCTL_CM4_CTRL_OFF:\n\t\tif(cm4_clk)\n\t\t{\n\t\t\tstopEarlyCamera();\n\t\t}\n\t\tbreak;\n\t\t\t\n\tcase IOCTL_CM4_CTRL_ON:\n\t\t//dprintf(INFO, \"EarlyCamera - Start\\n\");\t\n\n\t\tstartEarlyCamera(); \n\t\t\t\n\t\tcm4_clk = 1;\n\t\tbreak;\n\t}\n#endif\n\treturn 0;\n}\n\n\n", "comment_ratio": 0.12771084337349398}
{"lang": "c", "code": "#ifndef __PERF_TESTS_H_\r\n#define __PERF_TESTS_H_\r\n\r\nextern \"C\"\r\n{\r\n#include \"tcl.h\"\r\n}\r\n\r\n#include <time.h>\r\n#include <stdint.h>\r\n#include <iostream>\r\n\r\nstatic __inline__ unsigned long long rdtsc(void)\r\n{\r\n    unsigned hi, lo;\r\n    __asm__ __volatile__ (\"rdtsc\" : \"=a\"(lo), \"=d\"(hi));\r\n    return ( (unsigned long long)lo)|( ((unsigned long long)hi)<<32 );\r\n}\r\n\r\n// non-optimized\r\nunsigned long long p_aes_encrypt_ecb_128_noop(size_t payloadLen, size_t nIterations);\r\nunsigned long long p_aes_decrypt_ecb_128_noop(size_t payloadLen, size_t nIterations);\r\n\r\n// pure c with optimization\r\nunsigned long long p_aes_encrypt_ecb_128_pure_c(size_t payloadLen, size_t nIterations);\r\nunsigned long long p_aes_decrypt_ecb_128_pure_c(size_t payloadLen, size_t nIterations);\r\n\r\n// aesni without pipeline\r\nunsigned long long p_aes_encrypt_ecb_128_aesni_iterative(size_t payloadLen, size_t nIterations);\r\nunsigned long long p_aes_decrypt_ecb_128_aesni_iterative(size_t payloadLen, size_t nIterations);\r\n\r\n// pipelined aesni\r\nunsigned long long p_aes_encrypt_ecb_128_aesni_pipelined(size_t payloadLen, size_t nIterations);\r\nunsigned long long p_aes_decrypt_ecb_128_aesni_pipelined(size_t payloadLen, size_t nIterations);\r\n\r\n#endif\r\n\n", "comment_ratio": 0.10810810810810811}
{"lang": "c", "code": "/// @file system/text/encoder_exception_fallback.h\n#ifndef __EncoderExceptionFallback_h__\n#define __EncoderExceptionFallback_h__\n\n#include \"system/text/encoder_exception_fallback_buffer.h\"\n#include \"system/text/encoder_fallback.h\"\n\n#include \"fwd.h\"\n\nnamespace System { namespace Text {\n\n/// Provides exception-throwing fallback strategy.\n/// Objects of this class should only be allocated using System::MakeObject() function.\n/// Never create instance of this type on stack or using operator new, as it will result in runtime errors and/or assertion faults.\n/// Always wrap this class into System::SmartPtr pointer and use this pointer to pass it to functions as argument.\nclass ASPOSECPP_SHARED_CLASS EncoderExceptionFallback : public EncoderFallback\n{\npublic:\n    /// Constructor.\n    EncoderExceptionFallback() {}\n\n    /// Gets maximal count of characters the instance can return.\n    /// @return Always returns 0.\n    virtual int get_MaxCharCount() ASPOSE_CONST override { return 0; }\n    /// Creates fallback buffer.\n    /// @return Newly created fallback buffer object.\n    virtual EncoderFallbackBufferPtr CreateFallbackBuffer() override {\n        return MakeObject<EncoderExceptionFallbackBuffer>();\n    }\n};\n\n}}\n\n#endif\n\n", "comment_ratio": 0.2857142857142857}
{"lang": "c", "code": "#ifndef AC_GEBLOCK3D_H\n#define AC_GEBLOCK3D_H\n\n#include \"geent3d.h\"\n#pragma pack (push, 8)\nclass AcGePoint3d;\nclass AcGeVector3d;\n\nclass \nGE_DLLEXPIMPORT\nAcGeBoundBlock3d : public AcGeEntity3d\n{\npublic:\n                    \n\tAcGeBoundBlock3d ();\n\tAcGeBoundBlock3d (const AcGePoint3d& base, const AcGeVector3d& dir1,\n\t\t\t\t\t  const AcGeVector3d& dir2, const AcGeVector3d& dir3);\n\tAcGeBoundBlock3d (const AcGeBoundBlock3d& block);\n    \n\t// Access methods.\n    //    \n    void              getMinMaxPoints  (AcGePoint3d& point1,\n\t\t\t\t\t\t\t\t        AcGePoint3d& point2) const;\n    void              get              (AcGePoint3d& base,\n\t\t\t\t\t\t\t\t        AcGeVector3d& dir1,\n\t\t\t\t\t\t\t\t        AcGeVector3d& dir2,\n\t\t\t\t\t\t\t\t        AcGeVector3d& dir3) const;\n\t// Set methods.\n    //    \n    AcGeBoundBlock3d& set              (const AcGePoint3d& point1,\n\t\t\t\t\t\t\t\t        const AcGePoint3d& point2);\n    AcGeBoundBlock3d& set              (const AcGePoint3d& base,\n\t\t\t\t\t\t\t\t        const AcGeVector3d& dir1,\n\t\t\t\t\t\t\t\t        const AcGeVector3d& dir2,\n\t\t\t\t\t\t\t\t        const AcGeVector3d& dir3);\n    // Expand to contain point.\n    //\n    AcGeBoundBlock3d& extend           (const AcGePoint3d& point);\n   \n\t// Expand by a specified distance.\n    //\n    AcGeBoundBlock3d& swell            (double distance);\n\n    // Containment and intersection tests\n    //\n    Adesk::Boolean    contains         (const AcGePoint3d& point) const;\n    Adesk::Boolean    isDisjoint       (const AcGeBoundBlock3d& block) const;\n\n    // Assignment opearator\n    //\n    AcGeBoundBlock3d& operator =       (const AcGeBoundBlock3d& block);\n\n    Adesk::Boolean     isBox    () const;\n    AcGeBoundBlock3d&  setToBox (Adesk::Boolean);\n};\n\n\n#pragma pack (pop)\n#endif\n\n", "comment_ratio": 0.35526315789473684}
{"lang": "c", "code": "#ifndef CRYPTO_PBKDF2_SHA256_H\n#define CRYPTO_PBKDF2_SHA256_H\n\n#include \"util/blob.h\"\n#include <string>\n#include <memory>\n\nnamespace Crypto {\n\ntypedef U32 PBKD_Iters;\nstatic const PBKD_Iters PBKD_ITERS_DEFAULT = 100000;\n\nstd::unique_ptr<Util::Blob> PBKDF2_SHA256(U64 keySize, const Util::Blob &password,\n  const Util::Blob &salt, U64 iterations);\n\n// TODO: Futures\n\n} // namespace Crypto\n\n#endif // CRYPTO_PBKDF2_SHA256_H\n\n\n", "comment_ratio": 0.13636363636363635}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n#import \"SCIDeltaCalculator.h\"\n\n@protocol SCINiceScaleProtocol;\n\n@interface SCINumericDeltaCalculatorBase : NSObject <SCIDeltaCalculatorProtocol>\n\n-(id<SCINiceScaleProtocol>) getScaleWithMin:(double)min Max:(double)max MinorsPerMajor:(int)minorsPerMajor MaxTicks:(uint)maxTicks;\n\n@end\n\n", "comment_ratio": 0.3684210526315789}
{"lang": "c", "code": "varying vec2 vTextureCoord;\nuniform float uTexSize;\nuniform float uTexStep;\n\n// initial condition\n// arguments in [-1,1]\nfloat func(float x, float y) {\n    float pi = 3.141592654;\n\n    vec2 xy = vec2(x,y);\n    \n    /*CUSTOM*/\n    return 0.;\n    /*CUSTOM*/\n}\n\nvoid main(void)\n{\n    vec2 xy = 2.0 * vTextureCoord - vec2(1., 1.);\n    \n    float h = 0.5 * uTexStep; // 0.5 because we multiply the texture size by 2.0\n    \n    gl_FragColor = vec4(\n                        func(xy.x - h, xy.y - h),\n                        func(xy.x + h, xy.y - h),\n                        func(xy.x - h, xy.y + h),\n                        func(xy.x + h, xy.y + h)\n                        );\n}\n\n", "comment_ratio": 0.1}
{"lang": "c", "code": "#pragma once\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include \"surena/game.h\"\n\n/*\n\nTODO interesting evals to try:\n\n1. classic distance to win:\n    count the required number of virtual/real connections for a win for that player\n    possibly only count unblockable (unobstructed distances)?\n    look at D*\n\n2. largest directional spread:\n    .. of a players graphs (horizontal for horizontal player, vice-versa for vertical)\n    i.e. maximum of all graph widths\n    for each graph that contains multiple nodes this is (point most to the right X) minus (point most to the left X)\n    (and Y with high and low for vertical player)\n    - need to do this using virtual connections too\n\n3. minimum open connection space:\n    e.g. for the vertical player\n    for each column, once starting from the top and once starting from the bottom\n    e.g. for starting from the top, start counting at 0\n        step one node lower and check its type\n            free: count up 1 and step lower\n            color of the player that wants to win in this direction: stop and return count\n            color of the player trying to block a connection in this direction: stop and return count.max\n        for all the columns, get the top count and bottom count, (min of top counts) + (min of bot counts) = eval score\n\n*/\n\nenum TWIXT_PP_PLAYER : player_id {\n    TWIXT_PP_PLAYER_NONE = 0,\n    TWIXT_PP_PLAYER_WHITE,\n    TWIXT_PP_PLAYER_BLACK,\n    TWIXT_PP_PLAYER_INVALID,\n};\n\nenum TWIXT_PP_DIR : uint8_t {\n    TWIXT_PP_DIR_RT = 1 << 3,\n    TWIXT_PP_DIR_RB = 1 << 2,\n    TWIXT_PP_DIR_BR = 1 << 1,\n    TWIXT_PP_DIR_BL = 1 << 0,\n};\n\nstatic const move_code TWIXT_PP_MOVE_SWAP = 1<<17;\n\ntypedef struct twixt_pp_node_s {\n    TWIXT_PP_PLAYER player : 2;\n    uint16_t graph_id : 14; // 14 bits are enough for boards up to 128x128\n    // order for these: 0b0000XYZW\n    // X right top, Y right bottom, Z bottom right, W bottom left\n    uint8_t connections : 4; // stores the right and downward facing connections that exist\n    uint8_t collisions; // stores the right and downward facing connection paths that are blocked by collisions for both players, 0bWWWWBBBB\n} twixt_pp_node;\n\ntypedef struct twixt_pp_graph_s {\n    uint16_t graph_id : 14; // joined graphs point to the true graph which connects this node\n    bool connect_low : 1; // left / up\n    bool connect_high : 1; // right / down\n} twixt_pp_graph;\n\ntypedef struct twixt_pp_options_s {\n    // this NOT only defines the playable area, so it includes the 1 wide borders on each side, max 128, min 3\n    uint8_t wx;\n    uint8_t wy;\n    bool pie_swap; // this is a move, mirroring on the diagonal from top left top bottom right\n} twixt_pp_options;\n\ntypedef struct twixt_pp_internal_methods_s {\n\n    error_code (*get_node)(game* self, uint8_t x, uint8_t y, TWIXT_PP_PLAYER* p);\n    error_code (*set_node)(game* self, uint8_t x, uint8_t y, TWIXT_PP_PLAYER p, bool* wins); // wins may be NULL, then it is ignored\n    error_code (*get_node_connections)(game* self, uint8_t x, uint8_t y, uint8_t* conn); // right and downward facing existing connections\n    error_code (*get_node_collisions)(game* self, uint8_t x, uint8_t y, uint8_t* collisions);\n\n    // connection is only placed if collision free\n    // call such that x1 y1 is left / top of x2 y2\n    // supplying wins is NOT optional\n    error_code (*set_connection)(game* self, uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2, bool* wins);\n\n    error_code (*can_swap)(game* self, bool* swap_available);\n\n} twixt_pp_internal_methods;\n\nextern const game_methods twixt_pp_gbe;\n\n#ifdef __cplusplus\n}\n#endif\n\n", "comment_ratio": 0.15625}
{"lang": "c", "code": "#ifndef H_COMPUTE_GPUHW\n#define H_COMPUTE_GPUHW\n\n#include \"compressonator.h\"\n#include \"common_def.h\"  // Updated at run time\n#include \"compute_base.h\"\n#include \"common_kerneldef.h\"\n#include \"query_timer.h\"\n#include \"textureio.h\"\n#include \"crc32.h\"\n#include \"cmp_math_common.h\"\n\n#include \"glad.h\"\n#include <GLFW/glfw3.h>\n#include <optional>\n#include <string>\n\n#define MAX_PLATFORMS 4\n\nusing namespace CMP_Compute_Base;\n\nclass CGpuHW : public ComputeBase {\n  public:\n    CGpuHW(void* kerneloptions);\n    CGpuHW(ComputeOptions CLOptions);\n    ~CGpuHW();\n\n    CMP_ERROR   Compress(KernelOptions* Options, MipSet& SrcTexture, MipSet& destTexture, CMP_Feedback_Proc pFeedback);\n    GLuint      processtexture();\n    void        SetComputeOptions(ComputeOptions* CLOptions);\n    float       GetProcessElapsedTimeMS();\n    float       GetMTxPerSec();\n    int         GetBlockSize();\n    const char* GetDeviceName();\n    const char* GetVersion();\n    int         GetMaxUCores();\n    void        CleanUp();\n\n    // shader ops\n    void checkShaderStatus(GLuint shader) const;\n    void checkProgramStatus() const;\n    void shader_destroy();\n\n  private:\n    static void errorCallback(int error, const char* description);\n\n    MipSet* m_source;\n    MipSet* m_destination;\n\n    bool m_genGPUMipMaps;\n\n    // Window shaders;\n    GLuint w_vertex;\n    GLuint w_fragment;\n    GLuint w_geometry;\n    GLuint w_program;\n\n    // Texture shaders;\n    GLuint m_vertex;\n    GLuint m_fragment;\n    GLuint m_geometry;\n    GLuint m_program;\n\n    GLuint m_vao_ref;\n    GLuint m_vbo_ref;\n    GLuint w_vao_ref;\n    GLuint w_vbo_ref;\n\n    GLuint m_glformat;\n\n    GLFWwindow* m_gltfwindow;\n    int         tupleIndex;\n    bool        shouldGenerate;\n\n    size_t m_destination_size;\n    unsigned int m_width_in_blocks;\n    unsigned int m_height_in_blocks;\n\n    bool       m_initDeviceOk;\n    bool       m_programRun;\n    CMP_FORMAT m_codecFormat;\n\n    // Performance Info\n    bool  m_getPerfStats;\n    int   m_num_blocks;\n    float m_CmpMTxPerSec;\n    float m_computeShaderElapsedMS;\n\n    // Device Info\n    std::string m_deviceName;\n    std::string m_version;\n\n    // Internal\n    std::string    m_source_file;\n    KernelOptions* m_kernel_options;\n\n    // Options that users can override or add\n    bool m_force_rebuild;\n\n    Source_Info m_SourceInfo;\n    bool        m_svmSupport;\n    void*       m_svmData;\n\n    // OpenCL file (Binary or Source)\n    char m_compile_options[256];\n\n    union {\n        char*          buffer;\n        unsigned char* ubuffer;\n    } p_program;\n\n    size_t m_program_size;\n    bool   m_isBinary;\n    float  time_device = 0;\n\n    // Need to fill these\n    BYTE*       p_destination[MAX_MIPLEVEL_SUPPORTED];\n    CMP_BYTE*   m_psource;\n    void        Init();\n    bool        GetPlatformID();\n    bool        GetDeviceInfo();\n    bool        CreateContext();\n    bool        RunKernel();\n\n};\n\n#endif\n\n", "comment_ratio": 0.2119205298013245}
{"lang": "c", "code": "#ifndef IOSS_DECOMPOSITON_H\n#define IOSS_DECOMPOSITON_H\n\n#include \"vtk_ioss_mangle.h\"\n\n#include <Ioss_CodeTypes.h>\n#include <Ioss_Map.h>\n#include <Ioss_ParallelUtils.h>\n#include <Ioss_PropertyManager.h>\n#include <algorithm>\n#include <assert.h>\n#include <map>\n#include <string>\n#include <vector>\n\n#if !defined(NO_PARMETIS_SUPPORT)\n#include <parmetis.h>\n#endif\n\n#if !defined(NO_ZOLTAN_SUPPORT)\n#undef MPICPP\n#include <zoltan_cpp.h>\n#endif\n\nnamespace Ioss {\n  const std::vector<std::string> &valid_decomp_methods();\n\n  class BlockDecompositionData\n  {\n  public:\n    BlockDecompositionData() = default;\n\n    const std::string &name() const { return name_; }\n    int                zone() const { return zone_; }\n    int                section() const { return section_; }\n    int64_t            id() const { return id_; }\n    size_t             file_count() const { return fileCount; }\n    size_t             ioss_count() const { return iossCount; }\n    size_t             global_count() const { return globalCount; }\n\n    std::string name_{};\n    int         zone_{0};\n    int         section_{0};\n\n    size_t  fileSectionOffset{0}; // In partial read, where start\n    int64_t id_{0};\n    size_t  fileCount{0};\n    size_t  iossCount{0};\n    size_t  globalCount{0};\n\n    size_t      zoneNodeOffset{0};\n    std::string topologyType{\"unknown\"};\n    int         nodesPerEntity{0};\n    int         attributeCount{0};\n\n    // maps from file-block data to ioss-block data\n    // The local_map.size() elements starting at localIossOffset are local.\n    // ioss[localIossOffset+i] = file[local_map[i]];\n    size_t           localIossOffset{0};\n    std::vector<int> localMap;\n\n    // Maps from file-block data to export list.\n    // export[i] = file[export_map[i]\n    std::vector<int> exportMap;\n    std::vector<int> exportCount;\n    std::vector<int> exportIndex;\n\n    // Maps from import data to ioss-block data.\n    // ioss[import_map[i] = local_map[i];\n    std::vector<int> importMap;\n    std::vector<int> importCount;\n    std::vector<int> importIndex;\n  };\n\n  class SetDecompositionData\n  {\n  public:\n    SetDecompositionData()                             = default;\n    SetDecompositionData(const SetDecompositionData &) = delete;\n    SetDecompositionData(SetDecompositionData &&)      = default;\n\n    ~SetDecompositionData()\n    {\n      if (setComm_ != MPI_COMM_NULL) {\n        MPI_Comm_free(&setComm_);\n      }\n    }\n\n    const std::string &name() const { return name_; }\n    const std::string &ss_name() const { return ss_name_.empty() ? name_ : ss_name_; }\n    int64_t            id() const { return id_; }\n    int                zone() const { return zone_; }\n    int                section() const { return section_; }\n    size_t             file_count() const { return fileCount; }\n    size_t             ioss_count() const { return entitylist_map.size(); }\n    size_t             df_count() const { return distributionFactorCount; }\n\n    // contains global entity-list positions for all entities in this set on this processor.\n    std::vector<size_t> entitylist_map;\n    std::vector<bool>   hasEntities; // T/F if this set exists on processor p\n\n    std::string name_{};\n    std::string ss_name_{};\n    int64_t     id_{0};\n    int         zone_{0}; // Zone of the element block that this set is on\n    int         section_{0};\n    size_t      fileCount{0}; // Number of nodes in nodelist for file decomposition\n    int         root_{0};     // Lowest number processor that has nodes for this nodest\n    std::string topologyType{};\n    size_t      parentBlockIndex{0};\n\n    int distributionFactorValsPerEntity{-1}; // number of df / element or node. -1 if nonconstant.\n    size_t distributionFactorCount{0};\n    double distributionFactorValue{\n        0.0}; // If distributionFactorConstant == true, the constant value\n    MPI_Comm setComm_{MPI_COMM_NULL};\n    bool     distributionFactorConstant{false}; // T if all distribution factors the same value.\n  };\n\n  template <typename INT> class Decomposition\n  {\n  public:\n    Decomposition(const Ioss::PropertyManager &props, MPI_Comm comm);\n\n    size_t global_node_count() const { return m_globalNodeCount; }\n    size_t global_elem_count() const { return m_globalElementCount; }\n    size_t ioss_node_count() const { return nodeGTL.size(); }\n    size_t ioss_elem_count() const { return localElementMap.size() + importElementMap.size(); }\n    size_t file_node_count() const { return m_nodeCount; }\n    size_t file_elem_count() const { return m_elementCount; }\n    size_t file_node_offset() const { return m_nodeOffset; }\n    size_t file_elem_offset() const { return m_elementOffset; }\n\n    bool needs_centroids() const\n    {\n      return (m_method == \"RCB\" || m_method == \"RIB\" || m_method == \"HSFC\" ||\n              m_method == \"GEOM_KWAY\" || m_method == \"KWAY_GEOM\" || m_method == \"METIS_SFC\");\n    }\n\n    void generate_entity_distributions(size_t globalNodeCount, size_t globalElementCount);\n\n    // T/F if node with global index node owned by this processors ioss-decomp.\n    bool i_own_node(size_t global_index) const\n    {\n      // global_index is 1-based index into global list of nodes [1..global_node_count]\n      return std::binary_search(nodeGTL.begin(), nodeGTL.end(), global_index);\n    }\n\n    // T/F if element with global index elem owned by this processors ioss-decomp.\n    bool i_own_elem(size_t global_index) const\n    {\n      // global_index is 1-based index into global list of elements [1..global_element_count]\n      return elemGTL.count(global_index) != 0;\n    }\n\n    size_t node_global_to_local(size_t global_index) const\n    {\n      // global_index is 1-based index into global list of nodes [1..global_node_count]\n      // return value is 1-based index into local list of nodes on this\n      // processor (ioss-decomposition)\n      // Note that for 'int', equivalence and equality are the same, so\n      // lower_bound is OK here (EffectiveSTL, Item 19)\n      typename std::vector<INT>::const_iterator I =\n          lower_bound(nodeGTL.begin(), nodeGTL.end(), global_index);\n      assert(I != nodeGTL.end());\n      return std::distance(nodeGTL.begin(), I) + 1; // Convert to 1-based index.\n    }\n\n    size_t elem_global_to_local(size_t global_index) const\n    {\n      // global_index is 1-based index into global list of elements [1..global_node_count]\n      // return value is 1-based index into local list of elements on this\n      // processor (ioss-decomposition)\n      typename std::map<INT, INT>::const_iterator I = elemGTL.find(global_index);\n      assert(I != elemGTL.end());\n      return I->second;\n    }\n\n    void show_progress(const std::string &message) const\n    {\n      if (m_showProgress) {\n        Ioss::ParallelUtils pu(m_comm);\n        pu.progress(message);\n      }\n    }\n\n    // Zero out some large arrays usually not needed after decomposition\n    void release_memory();\n    void decompose_model(\n#if !defined(NO_ZOLTAN_SUPPORT)\n        Zoltan &zz,\n#endif\n        std::vector<BlockDecompositionData> &element_blocks);\n\n    void simple_decompose();\n\n    void simple_node_decompose();\n\n    void calculate_element_centroids(const std::vector<double> &x, const std::vector<double> &y,\n                                     const std::vector<double> &z);\n\n#if !defined(NO_ZOLTAN_SUPPORT)\n    void zoltan_decompose(Zoltan &zz);\n\n    void get_local_element_list(const ZOLTAN_ID_PTR &export_global_ids, size_t export_count);\n#endif\n\n#if !defined(NO_PARMETIS_SUPPORT)\n    void metis_decompose(idx_t *pointer, idx_t *adjacency,\n                         std::vector<BlockDecompositionData> &el_blocks);\n\n    void internal_metis_decompose(std::vector<BlockDecompositionData> &el_blocks,\n                                  idx_t *element_dist, idx_t *pointer, idx_t *adjacency,\n                                  idx_t *elem_partition);\n#endif\n\n    void get_node_entity_proc_data(INT *entity_proc, const Ioss::MapContainer &node_map,\n                                   bool do_map) const\n    {\n      show_progress(__func__);\n      size_t j = 0;\n      if (do_map) {\n        for (size_t i = 0; i < m_nodeCommMap.size(); i += 2) {\n          INT local_id     = m_nodeCommMap[i];\n          entity_proc[j++] = node_map[local_id];\n          entity_proc[j++] = m_nodeCommMap[i + 1];\n        }\n      }\n      else {\n        for (size_t i = 0; i < m_nodeCommMap.size(); i += 2) {\n          entity_proc[j++] = m_nodeCommMap[i + 0];\n          entity_proc[j++] = m_nodeCommMap[i + 1];\n        }\n      }\n    }\n\n    void get_element_block_communication(std::vector<BlockDecompositionData> &el_blocks);\n    void build_global_to_local_elem_map();\n    void get_local_node_list();\n    void get_shared_node_list();\n\n    // The following function is used if reading all element data on a\n    // processor instead of just an element blocks worth...\n    template <typename T>\n    void communicate_element_data(T *file_data, T *ioss_data, size_t comp_count) const\n    {\n      show_progress(__func__);\n      // Transfer the file-decomposition based data in 'file_data' to\n      // the ioss-decomposition based data in 'ioss_data'\n      std::vector<T> export_data(exportElementMap.size() * comp_count);\n      std::vector<T> import_data(importElementMap.size() * comp_count);\n\n      if (comp_count == 1) {\n        for (size_t i = 0; i < exportElementMap.size(); i++) {\n          size_t index   = exportElementMap[i] - m_elementOffset;\n          export_data[i] = file_data[index];\n        }\n\n        // Transfer all local data from file_data to ioss_data...\n        for (size_t i = 0; i < localElementMap.size(); i++) {\n          size_t index                             = localElementMap[i];\n          ioss_data[m_importPreLocalElemIndex + i] = file_data[index];\n        }\n\n        // Get my imported data and send my exported data...\n        Ioss::MY_Alltoallv(export_data, exportElementCount, exportElementIndex, import_data,\n                           importElementCount, importElementIndex, m_comm);\n        show_progress(\"\\tCommunication 1a finished\");\n\n        // Copy the imported data into ioss_data...\n        // Some comes before the local data...\n        for (size_t i = 0; i < m_importPreLocalElemIndex; i++) {\n          ioss_data[i] = import_data[i];\n        }\n\n        // Some comes after the local data...\n        size_t offset = m_importPreLocalElemIndex + localElementMap.size();\n        for (size_t i = 0; i < importElementMap.size() - m_importPreLocalElemIndex; i++) {\n          ioss_data[offset + i] = import_data[m_importPreLocalElemIndex + i];\n        }\n      }\n      else {\n        for (size_t i = 0; i < exportElementMap.size(); i++) {\n          size_t index = exportElementMap[i] - m_elementOffset;\n          for (size_t j = 0; j < comp_count; j++) {\n            export_data[comp_count * i + j] = file_data[comp_count * index + j];\n          }\n        }\n\n        // Transfer all local data from file_data to ioss_data...\n        for (size_t i = 0; i < localElementMap.size(); i++) {\n          size_t index = localElementMap[i];\n          for (size_t j = 0; j < comp_count; j++) {\n            ioss_data[comp_count * (m_importPreLocalElemIndex + i) + j] =\n                file_data[comp_count * index + j];\n          }\n        }\n\n        std::vector<INT> export_count(exportElementCount.begin(), exportElementCount.end());\n        std::vector<INT> export_disp(exportElementIndex.begin(), exportElementIndex.end());\n        std::vector<INT> import_count(importElementCount.begin(), importElementCount.end());\n        std::vector<INT> import_disp(importElementIndex.begin(), importElementIndex.end());\n\n        for (int i = 0; i < m_processorCount; i++) {\n          export_count[i] *= comp_count;\n          export_disp[i] *= comp_count;\n          import_count[i] *= comp_count;\n          import_disp[i] *= comp_count;\n        }\n\n        // Get my imported data and send my exported data...\n        Ioss::MY_Alltoallv(export_data, export_count, export_disp, import_data, import_count,\n                           import_disp, m_comm);\n        show_progress(\"\\tCommunication 1b finished\");\n\n        // Copy the imported data into ioss_data...\n        // Some comes before the local data...\n        for (size_t i = 0; i < m_importPreLocalElemIndex; i++) {\n          for (size_t j = 0; j < comp_count; j++) {\n            ioss_data[comp_count * i + j] = import_data[comp_count * i + j];\n          }\n        }\n\n        // Some comes after the local data...\n        size_t offset = m_importPreLocalElemIndex + localElementMap.size();\n        for (size_t i = 0; i < importElementMap.size() - m_importPreLocalElemIndex; i++) {\n          for (size_t j = 0; j < comp_count; j++) {\n            ioss_data[comp_count * (offset + i) + j] =\n                import_data[comp_count * (m_importPreLocalElemIndex + i) + j];\n          }\n        }\n      }\n    }\n\n    template <typename T>\n    void communicate_set_data(T *file_data, T *ioss_data, const SetDecompositionData &set,\n                              size_t comp_count) const\n    {\n      show_progress(__func__);\n      std::vector<T> recv_data;\n\n      size_t size = set.file_count() * comp_count;\n      if (size == 0)\n        return;\n\n      if (set.setComm_ != MPI_COMM_NULL) {\n        recv_data.resize(size);\n        if (m_processor == set.root_) {\n          std::copy(file_data, file_data + size, recv_data.begin());\n        }\n        // NOTE: This broadcast uses a split communicator, so possibly\n        // not all processors participating.\n        MPI_Bcast(recv_data.data(), size, Ioss::mpi_type(T(0)), 0, set.setComm_);\n      }\n      if (comp_count == 1) {\n        if (set.root_ == m_processor) {\n          for (size_t i = 0; i < set.ioss_count(); i++) {\n            size_t index = set.entitylist_map[i];\n            ioss_data[i] = file_data[index];\n          }\n        }\n        else {\n          // Receiving data from root...\n          for (size_t i = 0; i < set.ioss_count(); i++) {\n            size_t index = set.entitylist_map[i];\n            ioss_data[i] = recv_data[index];\n          }\n        }\n      }\n      else {\n        if (set.root_ == m_processor) {\n          for (size_t i = 0; i < set.ioss_count(); i++) {\n            size_t index = set.entitylist_map[i];\n            for (size_t j = 0; j < comp_count; j++) {\n              ioss_data[comp_count * i + j] = file_data[comp_count * index + j];\n            }\n          }\n        }\n        else {\n          // Receiving data from root...\n          for (size_t i = 0; i < set.ioss_count(); i++) {\n            size_t index = set.entitylist_map[i];\n            for (size_t j = 0; j < comp_count; j++) {\n              ioss_data[comp_count * i + j] = recv_data[comp_count * index + j];\n            }\n          }\n        }\n      }\n    }\n\n    template <typename T, typename U>\n    void communicate_block_data(T *file_data, U *ioss_data, const BlockDecompositionData &block,\n                                size_t comp_count) const\n    {\n      show_progress(__func__);\n      std::vector<U> exports;\n      exports.reserve(comp_count * block.exportMap.size());\n      std::vector<U> imports(comp_count * block.importMap.size());\n\n      if (comp_count == 1) {\n        for (int i : block.exportMap) {\n          exports.push_back(file_data[i]);\n        }\n\n        // Get my imported data and send my exported data...\n        Ioss::MY_Alltoallv(exports, block.exportCount, block.exportIndex, imports,\n                           block.importCount, block.importIndex, m_comm);\n\n        // Map local and imported data to ioss_data.\n        for (size_t i = 0; i < block.localMap.size(); i++) {\n          ioss_data[i + block.localIossOffset] = file_data[block.localMap[i]];\n        }\n\n        for (size_t i = 0; i < block.importMap.size(); i++) {\n          ioss_data[block.importMap[i]] = imports[i];\n        }\n      }\n      else {\n        for (int i : block.exportMap) {\n          for (size_t j = 0; j < comp_count; j++) {\n            exports.push_back(file_data[i * comp_count + j]);\n          }\n        }\n\n        std::vector<int> export_count(block.exportCount.begin(), block.exportCount.end());\n        std::vector<int> export_disp(block.exportIndex.begin(), block.exportIndex.end());\n        std::vector<int> import_count(block.importCount.begin(), block.importCount.end());\n        std::vector<int> import_disp(block.importIndex.begin(), block.importIndex.end());\n\n        for (int i = 0; i < m_processorCount; i++) {\n          export_count[i] *= comp_count;\n          export_disp[i] *= comp_count;\n          import_count[i] *= comp_count;\n          import_disp[i] *= comp_count;\n        }\n\n        // Get my imported data and send my exported data...\n        Ioss::MY_Alltoallv(exports, export_count, export_disp, imports, import_count, import_disp,\n                           m_comm);\n        show_progress(\"\\tCommunication 1 finished\");\n\n        // Map local and imported data to ioss_data.\n        for (size_t i = 0; i < block.localMap.size(); i++) {\n          for (size_t j = 0; j < comp_count; j++) {\n            ioss_data[(i + block.localIossOffset) * comp_count + j] =\n                file_data[block.localMap[i] * comp_count + j];\n          }\n        }\n\n        for (size_t i = 0; i < block.importMap.size(); i++) {\n          for (size_t j = 0; j < comp_count; j++) {\n            ioss_data[block.importMap[i] * comp_count + j] = imports[i * comp_count + j];\n          }\n        }\n      }\n    }\n\n    template <typename T>\n    void communicate_node_data(T *file_data, T *ioss_data, size_t comp_count) const\n    {\n      show_progress(__func__);\n      // Transfer the file-decomposition based data in 'file_data' to\n      // the ioss-decomposition based data in 'ioss_data'\n      std::vector<T> export_data(exportNodeMap.size() * comp_count);\n      std::vector<T> import_data(importNodeMap.size() * comp_count);\n\n      if (comp_count == 1) {\n        for (size_t i = 0; i < exportNodeMap.size(); i++) {\n          size_t index = exportNodeMap[i] - m_nodeOffset;\n          assert(index < m_nodeCount);\n          export_data[i] = file_data[index];\n        }\n\n        // Transfer all local data from file_data to ioss_data...\n        for (size_t i = 0; i < localNodeMap.size(); i++) {\n          size_t index = localNodeMap[i] - m_nodeOffset;\n          assert(index < m_nodeCount);\n          ioss_data[m_importPreLocalNodeIndex + i] = file_data[index];\n        }\n\n        // Get my imported data and send my exported data...\n        Ioss::MY_Alltoallv(export_data, exportNodeCount, exportNodeIndex, import_data,\n                           importNodeCount, importNodeIndex, m_comm);\n        show_progress(\"\\tCommunication 1a finished\");\n\n        // Copy the imported data into ioss_data...\n        for (size_t i = 0; i < importNodeMap.size(); i++) {\n          size_t index = importNodeMap[i];\n          assert(index < ioss_node_count());\n          ioss_data[index] = import_data[i];\n        }\n      }\n      else { // Comp_count > 1\n        for (size_t i = 0; i < exportNodeMap.size(); i++) {\n          size_t index = exportNodeMap[i] - m_nodeOffset;\n          assert(index < m_nodeCount);\n          for (size_t j = 0; j < comp_count; j++) {\n            export_data[comp_count * i + j] = file_data[comp_count * index + j];\n          }\n        }\n\n        // Transfer all local data from file_data to ioss_data...\n        for (size_t i = 0; i < localNodeMap.size(); i++) {\n          size_t index = localNodeMap[i] - m_nodeOffset;\n          assert(index < m_nodeCount);\n          for (size_t j = 0; j < comp_count; j++) {\n            ioss_data[comp_count * (m_importPreLocalNodeIndex + i) + j] =\n                file_data[comp_count * index + j];\n          }\n        }\n\n        std::vector<INT> export_count(exportNodeCount.begin(), exportNodeCount.end());\n        std::vector<INT> export_disp(exportNodeIndex.begin(), exportNodeIndex.end());\n        std::vector<INT> import_count(importNodeCount.begin(), importNodeCount.end());\n        std::vector<INT> import_disp(importNodeIndex.begin(), importNodeIndex.end());\n\n        for (int i = 0; i < m_processorCount; i++) {\n          export_count[i] *= comp_count;\n          export_disp[i] *= comp_count;\n          import_count[i] *= comp_count;\n          import_disp[i] *= comp_count;\n        }\n\n        // Get my imported data and send my exported data...\n        Ioss::MY_Alltoallv(export_data, export_count, export_disp, import_data, import_count,\n                           import_disp, m_comm);\n        show_progress(\"\\tCommunication 1b finished\");\n\n        // Copy the imported data into ioss_data...\n        for (size_t i = 0; i < importNodeMap.size(); i++) {\n          size_t index = importNodeMap[i];\n          assert(index < ioss_node_count());\n          for (size_t j = 0; j < comp_count; j++) {\n            ioss_data[comp_count * index + j] = import_data[comp_count * i + j];\n          }\n        }\n      }\n    }\n\n    MPI_Comm    m_comm;\n    int         m_processor{};\n    int         m_processorCount{};\n    std::string m_method;\n\n    // Values for the file decomposition\n    int    m_spatialDimension{3};\n    size_t m_globalElementCount{0};\n    size_t m_elementCount{0};\n    size_t m_elementOffset{0};\n    size_t m_importPreLocalElemIndex{0};\n\n    size_t m_globalNodeCount{0};\n    size_t m_nodeCount{0};\n    size_t m_nodeOffset{0};\n    size_t m_importPreLocalNodeIndex{0};\n\n    bool m_retainFreeNodes{true};\n    bool m_showProgress{false};\n    bool m_showHWM{false};\n\n    std::vector<double> m_centroids;\n    std::vector<INT>    m_pointer;   // Index into adjacency, processor list for each element...\n    std::vector<INT>    m_adjacency; // Size is sum of element connectivity sizes\n\n    std::vector<INT> m_nodeCommMap; // node/processor pair of the\n    // nodes I communicate with.  Stored node#,proc,node#,proc, ...\n\n    // The global element at index 'I' (0-based) is on block B in the\n    // file decomposition.\n    // if m_fileBlockIndex[B] <= I && m_fileBlockIndex[B+1] < I\n    std::vector<size_t> m_fileBlockIndex;\n\n  private:\n    // This processor \"manages\" the elements on the exodus mesh file from\n    // element_offset to element_offset+count (0-based). This is\n    // 'file' data\n    //\n    // This processor also appears to the Ioss clients to own other\n    // element and node data based on the decomposition.  This is the\n    // 'ioss' data.\n    //\n    // The indices in 'local_element_map' are the elements that are\n    // common to both the 'file' data and the 'ioss' data.\n    // local_element_map[i] contains the location in 'file' data for\n    // the 'ioss' data at location 'i+import_pre_local_elem_index'\n    //\n    // local_element_map[i]+m_elementOffset is the 0-based global index\n    //\n    // The indices in 'import_element_map' map the data received via\n    // mpi communication from other processors into 'ioss' data.\n    // if 'ind=import_element_map[i]', then ioss[ind] = comm_recv[i]\n    // Note that this is the reverse direction of the\n    // local_element_map mapping.\n    //\n    // The indices in 'export_element_map' are used to pull from\n    // 'file' data into the comm_send vector.  if 'ind =\n    // export_element_map[i]', then 'comm_send[i] = file[ind]' for i =\n    // 0..#exported_elements\n    //\n    // local_element_map.size() + import_element_map.size() == #\n    // ioss elements on this processor.\n    //\n    // local_element_map.size() + export_element_map.size() == #\n    // file elements on this processor.\n    //\n    // export_element_map and import_element_map are sorted.\n    // The primary key is processor order followed by global id.\n    // The processor association is via 'export_proc_disp' and\n    // 'import_proc_disp' Both are of size '#processors+1' and\n    // the elements for processor p range from [X_proc_disp[p] to\n    // X_proc_disp[p+1])\n\n    std::vector<INT> localElementMap;\n\n    std::vector<INT> importElementMap;\n    std::vector<INT> importElementCount;\n    std::vector<INT> importElementIndex;\n\n    std::vector<INT> exportElementMap;\n    std::vector<INT> exportElementCount;\n    std::vector<INT> exportElementIndex;\n\n    std::vector<INT> nodeIndex;\n\n    std::vector<INT> exportNodeMap;\n    std::vector<INT> exportNodeCount;\n    std::vector<INT> exportNodeIndex;\n\n    std::vector<INT>\n                     importNodeMap; // Where to put each imported nodes data in the list of all data...\n    std::vector<INT> importNodeCount;\n    std::vector<INT> importNodeIndex;\n\n    std::vector<INT> localNodeMap;\n\n    std::vector<INT> m_elementDist;\n    std::vector<INT> m_nodeDist;\n\n    // Note that nodeGTL is a sorted vector.\n    std::vector<INT>   nodeGTL; // Convert from global index to local index (1-based)\n    std::map<INT, INT> elemGTL; // Convert from global index to local index (1-based)\n  };\n} // namespace Ioss\n#endif\n\n", "comment_ratio": 0.16519174041297935}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n\n@interface UIImage (Trim)\n\n- (UIEdgeInsets)transparencyInsetsRequiringFullOpacity:(BOOL)fullyOpaque;\n- (UIImage *)imageByTrimmingTransparentPixels;\n- (UIImage *)imageByTrimmingTransparentPixelsRequiringFullOpacity:(BOOL)fullyOpaque;\n\n- (UIImage *)imageByTrimmingTransparentPixelsRequiringFullOpacity:(BOOL)fullyOpaque withXPadding:(CGFloat)xPadding;\n\n@end\n\n", "comment_ratio": 0.38095238095238093}
{"lang": "c", "code": "#import \"YJBaseNavController.h\"\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface AuthViewController : YJBaseViewController\n@property (weak, nonatomic) IBOutlet UILabel *nameLabel;\n@property (weak, nonatomic) IBOutlet UITextField *nameTextField;\n@property (weak, nonatomic) IBOutlet UILabel *firstLabel;\n@property (weak, nonatomic) IBOutlet UIImageView *pc1;\n@property (weak, nonatomic) IBOutlet UILabel *secondLabel;\n@property (weak, nonatomic) IBOutlet UIImageView *pc2;\n@property (weak, nonatomic) IBOutlet UILabel *thirdLabel;\n@property (weak, nonatomic) IBOutlet UIImageView *pc3;\n@property (weak, nonatomic) IBOutlet UIButton *commitBtn;\n\n@end\n\nNS_ASSUME_NONNULL_END\n\n", "comment_ratio": 0.25925925925925924}
{"lang": "c", "code": "#include <xc.h>\n#include \"color.h\"\n#include \"i2c.h\"\n\n/************************************\n * Function to perform the initialization of the color click\n * Inputs: None\n * Outputs: None\n * Functions called within:\n * The I2C_2_Master_Init function is called to initialize the I2C communication before\n * the color_writetoaddr() function is called which sends values to appropriate registers to \n * initialize the color click using I2C communication.\n************************************/\nvoid color_click_init(void)\n{   \n    //setup colour sensor via i2c interface\n    I2C_2_Master_Init();      //Initialise i2c Master\n\n     //set device PON\n\tcolor_writetoaddr(0x00, 0x01);\n    __delay_ms(3); //need to wait 3ms for everthing to start up\n    \n    //turn on device ADC\n\tcolor_writetoaddr(0x00, 0x03);\n\n    //set integration time\n\tcolor_writetoaddr(0x01, 0xD5);\n}\n\n/************************************\n * Function to write values to associated addresses on the color_click\n * Inputs: Register address, value to be stored\n * Outputs: None\n * Functions called within: The I2C functions to start communication, declare write mode, \n * declare address to be written to, and write the value to the address are called in that order.\n************************************/\nvoid color_writetoaddr(char address, char value){\n    I2C_2_Master_Start();         //Start condition\n    I2C_2_Master_Write(0x52 | 0x00);     //7 bit device address + Write mode\n    I2C_2_Master_Write(0x80 | address);    //command + register address\n    I2C_2_Master_Write(value);    \n    I2C_2_Master_Stop();          //Stop condition\n}\n\n/************************************\n * Function to read sensor values representing color intensity from the color click\n * Inputs: RGB_val structure and pointer rgb\n * Outputs: None\n * Functions called within: I2C functions are called to set up the auto-incremented reading of \n * the sensor high and low byte registers which are stored in addresses 0x14-0x1B. The\n * read values are stored in the structure RGB_val.\n************************************/\nvoid color_read_RGB(struct RGB_val *rgb)\n{\n\tunsigned int tmp=0;\n\tI2C_2_Master_Start();         //Start condition\n\tI2C_2_Master_Write(0x52 | 0x00);     //7 bit address + Write mode\n\tI2C_2_Master_Write(0xA0 | 0x14);    //command (auto-increment protocol transaction) + start at Clear low register\n\tI2C_2_Master_RepStart();\t\t\t// start a repeated transmission\n\tI2C_2_Master_Write(0x52 | 0x01);     //7 bit address + Read (1) mode\n    tmp=I2C_2_Master_Read(1);\t\t\t//read the Clear LSB\n\ttmp=tmp | (I2C_2_Master_Read(1)<<8); //read the Clear MSB \n    rgb->C = tmp; // Write Clear value to structure\n\ttmp=I2C_2_Master_Read(1);\t\t\t//read the Red LSB\n\ttmp=tmp | (I2C_2_Master_Read(1)<<8); //read the Red MSB \n    rgb->R = tmp; // Write Red value to structure\n    tmp=I2C_2_Master_Read(1);\t\t\t//read the Green LSB\n\ttmp=tmp | (I2C_2_Master_Read(1)<<8); //read the Green MSB \n    rgb->G = tmp; // Write Green value to structure\n    tmp=I2C_2_Master_Read(1);\t\t\t//read the Blue LSB\n\ttmp=tmp | (I2C_2_Master_Read(0)<<8); //read the Blue MSB (don't acknowledge as this is the last read)\n   \trgb->B = tmp; // Write Blue value to structure\n    I2C_2_Master_Stop();          //Stop condition\n}\n\n/************************************\n * Function to convert the values read from the color_click sensors to RGB values ranging (0-255). \n * red, green, and blue calibration measurements for Black RGB(0,0,0) and white RGB(255,255,255) are interpolated \n * in between to obtain the 'normalized' RGB values for each color. \n * Inputs: RGB_val structure and pointer rgb\n * Outputs: None\n * Functions called within: None\n************************************/\nvoid calibrate_RGB(struct RGB_val *rgb)\n{\n    rgb->R = 0 + ((rgb->R - rgb->B_R) * (255 - 0) / (rgb->W_R - rgb->B_R)); // Linear interpolation to calibrate R value to conventional 0,255 RGB scale\n    rgb->G = 0 + ((rgb->G - rgb->B_G) * (255 - 0) / (rgb->W_G - rgb->B_G)); // Linear interpolation to calibrate G value to conventional 0,255 RGB scale\n    rgb->B = 0 + ((rgb->B - rgb->B_B) * (255 - 0) / (rgb->W_B - rgb->B_B)); // Linear interpolation to calibrate B value to conventional 0,255 RGB scale\n}\n\n\n/************************************\n * Function to convert the normalized RGB values to Hue. \n * Associates a hue value from 0 to 360 to each color.\n * Hue value is calculated using predefined equations\n * Inputs: RGB_val structure and pointer rgb\n * Outputs: None\n * Functions called within: None\n************************************/\nvoid RGB_to_Hue(struct RGB_val *rgb)\n{// Different hue equations depending on if R,G or B max\n    \n    if(rgb->R >= rgb->G && rgb->R >= rgb->B){ // If R largest return R\n        rgb->max = rgb->R;\n    }else if(rgb->G >= rgb->R && rgb->G >= rgb->B){ // If G largest return G \n        rgb->max = rgb->G;\n    }else{ // Else return B\n       rgb->max = rgb->B;\n    }\n    \n    if(rgb->R <= rgb->G && rgb->R <= rgb->B){ // If R smallest return R\n        rgb->min = rgb->R;\n    }else if(rgb->G <= rgb->R && rgb->G <= rgb->B){ // If G smallest return G \n        rgb->min = rgb->G;\n    }else{ // Else return B\n        rgb->min = rgb->B;\n    }\n    \n    if(rgb->max == rgb->R){ // For R max\n        rgb->hue = ((rgb->G - rgb->B) / (rgb->max-rgb->min)) * 60;\n    }else if(rgb->max == rgb->G){ // For G max\n        rgb->hue = (2 + ((rgb->B - rgb->R) / (rgb->max-rgb->min))) * 60;\n    }else{ // For B max\n        rgb->hue = (4 + ((rgb->R - rgb->G) / (rgb->max-rgb->min))) * 60;\n    }\n    \n    if(rgb->hue < 0){ // Conversion for hue if negative number\n        rgb->hue = 360 + rgb->hue; // Add another cycle to make it positive\n    }\n}\n\n", "comment_ratio": 0.3282442748091603}
{"lang": "c", "code": "#include \"Private.h\"\n#include \"VadHelpers.h\"\n\n#pragma alloc_text(PAGE, MiPromoteNode)\n#pragma alloc_text(PAGE, MiRebalanceNode)\n#pragma alloc_text(PAGE, MiRemoveNode)\n#pragma alloc_text(PAGE, MiFindNodeOrParent)\n\nVOID\nMiPromoteNode(\n    IN PMMADDRESS_NODE C\n    )\n\n/*++\n\n    Routine Description:\n\n        This routine performs the fundamental adjustment required for balancing\n        the binary tree during insert and delete operations.  Simply put, the\n        designated node is promoted in such a way that it rises one level in\n        the tree and its parent drops one level in the tree, becoming now the\n        child of the designated node.  Generally the path length to the subtree\n        \"opposite\" the original parent.  Balancing occurs as the caller chooses\n        which nodes to promote according to the balanced tree algorithms from\n        Knuth.\n\n        This is not the same as a splay operation, typically a splay \"promotes\"\n        a designated node twice.\n\n        Note that the pointer to the root node of the tree is assumed to be\n        contained in a MMADDRESS_NODE structure itself, to allow the\n        algorithms below to change the root of the tree without checking\n        for special cases.  Note also that this is an internal routine,\n        and the caller guarantees that it never requests to promote the\n        root itself.\n\n        This routine only updates the tree links; the caller must update\n        the balance factors as appropriate.\n\n    Arguments:\n\n        C - pointer to the child node to be promoted in the tree.\n\n    Return Value:\n\n        None.\n\n--*/\n\n{\n    PMMADDRESS_NODE P;\n    PMMADDRESS_NODE G;\n\n    //\n    // Capture the current parent and grandparent (may be the root).\n    //\n\n    P = SANITIZE_PARENT_NODE( C->u1.Parent );\n    G = SANITIZE_PARENT_NODE( P->u1.Parent );\n\n    //\n    // Break down the promotion into two cases based upon whether C\n    // is a left or right child.\n    //\n\n    if (P->LeftChild == C) {\n\n        //\n        // This promotion looks like this:\n        //\n        //          G           G\n        //          |           |\n        //          P           C\n        //         / \\   =>    / \\\n                                                //        C   z       x   P\n        //       / \\             / \\\n                                                //      x   y           y   z\n        //\n\n        P->LeftChild = C->RightChild;\n\n        if (P->LeftChild != NULL) {\n\n            P->LeftChild->u1.Parent = MI_MAKE_PARENT( P, P->LeftChild->u1.Balance );\n        }\n\n        C->RightChild = P;\n\n        //\n        // Fall through to update parent and G <-> C relationship in\n        // common code.\n        //\n\n    }\n    else {\n\n        //\n        // This promotion looks like this:\n        //\n        //        G               G\n        //        |               |\n        //        P               C\n        //       / \\     =>      / \\\n                                                //      x   C           P   z\n        //         / \\         / \\\n                                                //        y   z       x   y\n        //\n\n        P->RightChild = C->LeftChild;\n\n        if (P->RightChild != NULL) {\n            P->RightChild->u1.Parent = MI_MAKE_PARENT( P, P->RightChild->u1.Balance );\n        }\n\n        C->LeftChild = P;\n    }\n\n    //\n    // Update parent of P, for either case above.\n    //\n\n    P->u1.Parent = MI_MAKE_PARENT( C, P->u1.Balance );\n\n    //\n    // Finally update G <-> C links for either case above.\n    //\n\n    if (G->LeftChild == P) {\n        G->LeftChild = C;\n    }\n    else {\n        G->RightChild = C;\n    }\n    C->u1.Parent = MI_MAKE_PARENT( G, C->u1.Balance );\n}\n\nULONG\nMiRebalanceNode(\n    IN PMMADDRESS_NODE S\n    )\n\n/*++\n\n    Routine Description:\n\n        This routine performs a rebalance around the input node S, for which the\n        Balance factor has just effectively become +2 or -2.  When called, the\n        Balance factor still has a value of +1 or -1, but the respective longer\n        side has just become one longer as the result of an insert or delete\n        operation.\n\n        This routine effectively implements steps A7.iii (test for Case 1 or\n        Case 2) and steps A8 and A9 of Knuth's balanced insertion algorithm,\n        plus it handles Case 3 identified in the delete section, which can\n        only happen on deletes.\n\n        The trick is, to convince yourself that while traveling from the\n        insertion point at the bottom of the tree up, that there are only\n        these two cases, and that when traveling up from the deletion point,\n        that there are just these three cases.  Knuth says it is obvious!\n\n    Arguments:\n\n        S - pointer to the node which has just become unbalanced.\n\n    Return Value:\n\n        TRUE if Case 3 was detected (causes delete algorithm to terminate).\n\n    Environment:\n\n        Kernel mode.  The PFN lock is held for some of the tables.\n\n--*/\n\n{\n    PMMADDRESS_NODE R, P;\n    SCHAR a;\n\n    //\n    // Capture which side is unbalanced.\n    //\n\n    a = (SCHAR)S->u1.Balance;\n\n    if (a == +1) {\n        R = S->RightChild;\n    }\n    else {\n        R = S->LeftChild;\n    }\n\n    //\n    // If the balance of R and S are the same (Case 1 in Knuth) then a single\n    // promotion of R will do the single rotation.  (Step A8, A10)\n    //\n    // Here is a diagram of the Case 1 transformation, for a == +1 (a mirror\n    // image transformation occurs when a == -1), and where the subtree\n    // heights are h and h+1 as shown (++ indicates the node out of balance):\n    //\n    //                  |                   |\n    //                  S++                 R\n    //                 / \\                 / \\\n                        //               (h)  R+     ==>      S  (h+1)\n    //                   / \\             / \\\n                        //                 (h) (h+1)       (h) (h)\n    //\n    // Note that on an insert we can hit this case by inserting an item in the\n    // right subtree of R.  The original height of the subtree before the insert\n    // was h+2, and it is still h+2 after the rebalance, so insert rebalancing\n    // may terminate.\n    //\n    // On a delete we can hit this case by deleting a node from the left subtree\n    // of S.  The height of the subtree before the delete was h+3, and after the\n    // rebalance it is h+2, so rebalancing must continue up the tree.\n    //\n\n    if ((SCHAR)R->u1.Balance == a) {\n\n        MiPromoteNode( R );\n        R->u1.Balance = 0;\n        S->u1.Balance = 0;\n\n        return FALSE;\n    }\n\n    //\n    // Otherwise, we have to promote the appropriate child of R twice (Case 2\n    // in Knuth).  (Step A9, A10)\n    //\n    // Here is a diagram of the Case 2 transformation, for a == +1 (a mirror\n    // image transformation occurs when a == -1), and where the subtree\n    // heights are h and h-1 as shown.  There are actually two minor subcases,\n    // differing only in the original balance of P (++ indicates the node out\n    // of balance).\n    //\n    //                  |                   |\n    //                  S++                 P\n    //                 / \\                 / \\\n                        //                /   \\               /   \\\n                        //               /     \\             /     \\\n                        //             (h)      R-   ==>    S-      R\n    //                     / \\         / \\     / \\\n                        //                    P+ (h)     (h)(h-1)(h) (h)\n    //                   / \\\n                        //               (h-1) (h)\n    //\n    //\n    //                  |                   |\n    //                  S++                 P\n    //                 / \\                 / \\\n                        //                /   \\               /   \\\n                        //               /     \\             /     \\\n                        //             (h)      R-   ==>    S       R+\n    //                     / \\         / \\     / \\\n                        //                    P- (h)     (h) (h)(h-1)(h)\n    //                   / \\\n                        //                 (h) (h-1)\n    //\n    // Note that on an insert we can hit this case by inserting an item in the\n    // left subtree of R.  The original height of the subtree before the insert\n    // was h+2, and it is still h+2 after the rebalance, so insert rebalancing\n    // may terminate.\n    //\n    // On a delete we can hit this case by deleting a node from the left subtree\n    // of S.  The height of the subtree before the delete was h+3, and after the\n    // rebalance it is h+2, so rebalancing must continue up the tree.\n    //\n\n    if ((SCHAR)R->u1.Balance == -a) {\n\n        //\n        // Pick up the appropriate child P for the double rotation (Link(-a,R)).\n        //\n\n        if (a == 1) {\n            P = R->LeftChild;\n        }\n        else {\n            P = R->RightChild;\n        }\n\n        //\n        // Promote him twice to implement the double rotation.\n        //\n\n        MiPromoteNode( P );\n        MiPromoteNode( P );\n\n        //\n        // Now adjust the balance factors.\n        //\n\n        S->u1.Balance = 0;\n        R->u1.Balance = 0;\n        if ((SCHAR)P->u1.Balance == a) {\n            COUNT_BALANCE_MAX( (SCHAR)-a );\n            S->u1.Balance = (ULONG_PTR)-a;\n        }\n        else if ((SCHAR)P->u1.Balance == -a) {\n            COUNT_BALANCE_MAX( (SCHAR)a );\n            R->u1.Balance = (ULONG_PTR)a;\n        }\n\n        P->u1.Balance = 0;\n        return FALSE;\n    }\n\n    //\n    // Otherwise this is Case 3 which can only happen on Delete (identical\n    // to Case 1 except R->u1.Balance == 0).  We do a single rotation, adjust\n    // the balance factors appropriately, and return TRUE.  Note that the\n    // balance of S stays the same.\n    //\n    // Here is a diagram of the Case 3 transformation, for a == +1 (a mirror\n    // image transformation occurs when a == -1), and where the subtree\n    // heights are h and h+1 as shown (++ indicates the node out of balance):\n    //\n    //                  |                   |\n    //                  S++                 R-\n    //                 / \\                 / \\\n                        //               (h)  R      ==>      S+ (h+1)\n    //                   / \\             / \\\n                        //                (h+1)(h+1)       (h) (h+1)\n    //\n    // This case can not occur on an insert, because it is impossible for\n    // a single insert to balance R, yet somehow grow the right subtree of\n    // S at the same time.  As we move up the tree adjusting balance factors\n    // after an insert, we terminate the algorithm if a node becomes balanced,\n    // because that means the subtree length did not change!\n    //\n    // On a delete we can hit this case by deleting a node from the left\n    // subtree of S.  The height of the subtree before the delete was h+3,\n    // and after the rebalance it is still h+3, so rebalancing may terminate\n    // in the delete path.\n    //\n\n    MiPromoteNode( R );\n    COUNT_BALANCE_MAX( (SCHAR)-a );\n    R->u1.Balance = -a;\n    return TRUE;\n}\n\n\n/*\nVOID\nMiInsertNode (\nIN PMMADDRESS_NODE NodeToInsert,\nIN PMM_AVL_TABLE Table\n)\n\n/ *++\n\nRoutine Description:\n\nThis function inserts a new element in a table.\n\nArguments:\n\nNodeToInsert - The initialized address node to insert.\n\nTable - Pointer to the table in which to insert the new node.\n\nReturn Value:\n\nNone.\n\nEnvironment:\n\nKernel mode.  The PFN lock is held for some of the tables.\n\n--* /\n\n{\n    //\n    // Holds a pointer to the node in the table or what would be the\n    // parent of the node.\n    //\n\n    PMMADDRESS_NODE NodeOrParent;\n    TABLE_SEARCH_RESULT SearchResult;\n\n    SearchResult = MiFindNodeOrParent( Table,\n                                       (ULONG_PTR)((PMMVAD_SHORT)NodeToInsert)->StartingVpn,\n                                       &NodeOrParent );\n\n\n    //\n    // The node wasn't in the (possibly empty) tree.\n    //\n    // We just check that the table isn't getting too big.\n    //\n\n    NodeToInsert->LeftChild = NULL;\n    NodeToInsert->RightChild = NULL;\n\n    Table->NumberGenericTableElements += 1;\n\n    //\n    // Insert the new node in the tree.\n    //\n\n    if (SearchResult == TableEmptyTree) {\n\n        Table->BalancedRoot.RightChild = NodeToInsert;\n        NodeToInsert->u1.Parent = &Table->BalancedRoot;\n        Table->DepthOfTree = 1;\n\n    }\n    else {\n\n        PMMADDRESS_NODE R = NodeToInsert;\n        PMMADDRESS_NODE S = NodeOrParent;\n\n        if (SearchResult == TableInsertAsLeft) {\n            NodeOrParent->LeftChild = NodeToInsert;\n        }\n        else {\n            NodeOrParent->RightChild = NodeToInsert;\n        }\n\n        NodeToInsert->u1.Parent = NodeOrParent;\n\n        //\n        // The above completes the standard binary tree insertion, which\n        // happens to correspond to steps A1-A5 of Knuth's \"balanced tree\n        // search and insertion\" algorithm.  Now comes the time to adjust\n        // balance factors and possibly do a single or double rotation as\n        // in steps A6-A10.\n        //\n        // Set the Balance factor in the root to a convenient value\n        // to simplify loop control.\n        //\n\n        COUNT_BALANCE_MAX( (SCHAR)-1 );\n        Table->BalancedRoot.u1.Balance = (ULONG_PTR)-1;\n\n        //\n        // Now loop to adjust balance factors and see if any balance operations\n        // must be performed, using NodeOrParent to ascend the tree.\n        //\n\n        for (;;) {\n\n            SCHAR a;\n\n            //\n            // Calculate the next adjustment.\n            //\n\n            a = 1;\n            if (MiIsLeftChild( R )) {\n                a = -1;\n            }\n\n            //\n            // If this node was balanced, show that it is no longer and\n            // keep looping.  This is essentially A6 of Knuth's algorithm,\n            // where he updates all of the intermediate nodes on the\n            // insertion path which previously had balance factors of 0.\n            // We are looping up the tree via Parent pointers rather than\n            // down the tree as in Knuth.\n            //\n\n            if (S->u1.Balance == 0) {\n\n                COUNT_BALANCE_MAX( (SCHAR)a );\n                S->u1.Balance = a;\n                R = S;\n                S = SANITIZE_PARENT_NODE( S->u1.Parent );\n            }\n            else if ((SCHAR)S->u1.Balance != a) {\n\n\n                //\n                // If this node has the opposite balance, then the tree got\n                // more balanced (or we hit the root) and we are done.\n                //\n                // Step A7.ii\n                //\n\n                S->u1.Balance = 0;\n\n                //\n                // If S is actually the root, then this means the depth\n                // of the tree just increased by 1!  (This is essentially\n                // A7.i, but we just initialized the root balance to force\n                // it through here.)\n                //\n\n                if (Table->BalancedRoot.u1.Balance == 0) {\n                    Table->DepthOfTree += 1;\n                }\n\n                break;\n            }\n            else {\n\n                //\n                // The tree became unbalanced (path length differs\n                // by 2 below us) and we need to do one of the balancing\n                // operations, and then we are done.  The RebalanceNode routine\n                // does steps A7.iii, A8 and A9.\n                //\n\n                MiRebalanceNode( S );\n                break;\n            }\n        }\n    }\n\n    //\n    // Sanity check tree size and depth.\n    //\n\n\n    return;\n}*/\n\nVOID\nMiRemoveNode(\n    IN PMMADDRESS_NODE NodeToDelete,\n    IN PMM_AVL_TABLE Table\n    )\n\n/*++\n\n    Routine Description:\n\n        This routine deletes the specified node from the balanced tree, rebalancing\n        as necessary.  If the NodeToDelete has at least one NULL child pointers,\n        then it is chosen as the EasyDelete, otherwise a subtree predecessor or\n        successor is found as the EasyDelete.  In either case the EasyDelete is\n        deleted and the tree is rebalanced.  Finally if the NodeToDelete was\n        different than the EasyDelete, then the EasyDelete is linked back into the\n        tree in place of the NodeToDelete.\n\n    Arguments:\n\n    NodeToDelete - Pointer to the node which the caller wishes to delete.\n\n    Table - The generic table in which the delete is to occur.\n\n    Return Value:\n\n        None.\n\n    Environment:\n\n        Kernel mode.  The PFN lock is held for some of the tables.\n\n--*/\n\n{\n    PMMADDRESS_NODE Parent;\n    PMMADDRESS_NODE EasyDelete;\n    PMMADDRESS_NODE P;\n    SCHAR a;\n\n    //\n    // If the NodeToDelete has at least one NULL child pointer, then we can\n    // delete it directly.\n    //\n\n    if ((NodeToDelete->LeftChild == NULL) ||\n         (NodeToDelete->RightChild == NULL)) {\n\n        EasyDelete = NodeToDelete;\n    }\n\n    //\n    // Otherwise, we may as well pick the longest side to delete from (if one is\n    // is longer), as that reduces the probability that we will have to\n    // rebalance.\n    //\n\n    else if ((SCHAR)NodeToDelete->u1.Balance >= 0) {\n\n        //\n        // Pick up the subtree successor.\n        //\n\n        EasyDelete = NodeToDelete->RightChild;\n        while (EasyDelete->LeftChild != NULL) {\n            EasyDelete = EasyDelete->LeftChild;\n        }\n    }\n    else {\n\n        //\n        // Pick up the subtree predecessor.\n        //\n\n        EasyDelete = NodeToDelete->LeftChild;\n        while (EasyDelete->RightChild != NULL) {\n            EasyDelete = EasyDelete->RightChild;\n        }\n    }\n\n    //\n    // Rebalancing must know which side of the first parent the delete occurred\n    // on.  Assume it is the left side and otherwise correct below.\n    //\n\n    a = -1;\n\n    //\n    // Now we can do the simple deletion for the no left child case.\n    //\n\n    if (EasyDelete->LeftChild == NULL) {\n\n        Parent = SANITIZE_PARENT_NODE( EasyDelete->u1.Parent );\n\n        if (MiIsLeftChild( EasyDelete )) {\n            Parent->LeftChild = EasyDelete->RightChild;\n        }\n        else {\n            Parent->RightChild = EasyDelete->RightChild;\n            a = 1;\n        }\n\n        if (EasyDelete->RightChild != NULL) {\n            EasyDelete->RightChild->u1.Parent = MI_MAKE_PARENT( Parent, EasyDelete->RightChild->u1.Balance );\n        }\n\n        //\n        // Now we can do the simple deletion for the no right child case,\n        // plus we know there is a left child.\n        //\n\n    }\n    else {\n\n        Parent = SANITIZE_PARENT_NODE( EasyDelete->u1.Parent );\n\n        if (MiIsLeftChild( EasyDelete )) {\n            Parent->LeftChild = EasyDelete->LeftChild;\n        }\n        else {\n            Parent->RightChild = EasyDelete->LeftChild;\n            a = 1;\n        }\n\n        EasyDelete->LeftChild->u1.Parent = MI_MAKE_PARENT( Parent,\n                                                           EasyDelete->LeftChild->u1.Balance );\n    }\n\n    //\n    // For delete rebalancing, set the balance at the root to 0 to properly\n    // terminate the rebalance without special tests, and to be able to detect\n    // if the depth of the tree actually decreased.\n    //\n\n#if defined( _WIN81_ ) || defined ( _WIN10_ )\n    Table->BalancedRoot->u1.Balance = 0;\n#else\n    Table->BalancedRoot.u1.Balance = 0;\n#endif\n    P = SANITIZE_PARENT_NODE( EasyDelete->u1.Parent );\n\n    //\n    // Loop until the tree is balanced.\n    //\n\n    for (;;) {\n\n        //\n        // First handle the case where the tree became more balanced.  Zero\n        // the balance factor, calculate a for the next loop and move on to\n        // the parent.\n        //\n\n        if ((SCHAR)P->u1.Balance == a) {\n\n            P->u1.Balance = 0;\n\n            //\n            // If this node is curently balanced, we can show it is now unbalanced\n            // and terminate the scan since the subtree length has not changed.\n            // (This may be the root, since we set Balance to 0 above!)\n            //\n\n        }\n        else if (P->u1.Balance == 0)\n        {\n            COUNT_BALANCE_MAX( (SCHAR)-a );\n            P->u1.Balance = -a;\n\n            //\n            // If we shortened the depth all the way back to the root, then\n            // the tree really has one less level.\n            //\n\n#if !defined( _WIN81_ ) && !defined ( _WIN10_ )\n            if (Table->BalancedRoot.u1.Balance != 0) {\n                Table->DepthOfTree -= 1;\n            }\n#endif\n\n            break;\n\n            //\n            // Otherwise we made the short side 2 levels less than the long side,\n            // and rebalancing is required.  On return, some node has been promoted\n            // to above node P.  If Case 3 from Knuth was not encountered, then we\n            // want to effectively resume rebalancing from P's original parent which\n            // is effectively its grandparent now.\n            //\n\n        }\n        else\n        {\n\n            //\n            // We are done if Case 3 was hit, i.e., the depth of this subtree is\n            // now the same as before the delete.\n            //\n\n            if (MiRebalanceNode( P ))\n            {\n                break;\n            }\n\n            P = SANITIZE_PARENT_NODE( P->u1.Parent );\n        }\n\n        a = -1;\n        if (MiIsRightChild( P ))\n        {\n            a = 1;\n        }\n\n        P = SANITIZE_PARENT_NODE( P->u1.Parent );\n    }\n\n    //\n    // Finally, if we actually deleted a predecessor/successor of the\n    // NodeToDelete, we will link him back into the tree to replace\n    // NodeToDelete before returning.  Note that NodeToDelete did have\n    // both child links filled in, but that may no longer be the case\n    // at this point.\n    //\n\n    if (NodeToDelete != EasyDelete)\n    {\n\n        //\n        // Note carefully - VADs are of differing sizes therefore it is not safe\n        // to just overlay the EasyDelete node with the NodeToDelete like the\n        // rtl avl code does.\n        //\n        // Copy just the links, preserving the rest of the original EasyDelete\n        // VAD.\n        //\n\n        EasyDelete->u1.Parent = NodeToDelete->u1.Parent;\n        EasyDelete->LeftChild = NodeToDelete->LeftChild;\n        EasyDelete->RightChild = NodeToDelete->RightChild;\n\n        if (MiIsLeftChild( NodeToDelete ))\n        {\n            Parent = SANITIZE_PARENT_NODE( EasyDelete->u1.Parent );\n            Parent->LeftChild = EasyDelete;\n        }\n        else\n        {\n            Parent = SANITIZE_PARENT_NODE( EasyDelete->u1.Parent );\n            Parent->RightChild = EasyDelete;\n        }\n        if (EasyDelete->LeftChild != NULL)\n        {\n            EasyDelete->LeftChild->u1.Parent = MI_MAKE_PARENT( EasyDelete,\n                                                               EasyDelete->LeftChild->u1.Balance );\n        }\n        if (EasyDelete->RightChild != NULL)\n        {\n            EasyDelete->RightChild->u1.Parent = MI_MAKE_PARENT( EasyDelete,\n                                                                EasyDelete->RightChild->u1.Balance );\n        }\n    }\n\n    return;\n}\n\nTABLE_SEARCH_RESULT\nMiFindNodeOrParent(\n    IN PMM_AVL_TABLE Table,\n    IN ULONG_PTR StartingVpn,\n    OUT PMMADDRESS_NODE *NodeOrParent\n    )\n\n/*++\n\n    Routine Description:\n\n        This routine is used by all of the routines of the generic\n        table package to locate the a node in the tree.  It will\n        find and return (via the NodeOrParent parameter) the node\n        with the given key, or if that node is not in the tree it\n        will return (via the NodeOrParent parameter) a pointer to\n        the parent.\n\n    Arguments:\n\n        Table - The generic table to search for the key.\n\n        StartingVpn - The starting virtual page number.\n\n        NodeOrParent - Will be set to point to the node containing the\n        the key or what should be the parent of the node\n        if it were in the tree.  Note that this will *NOT*\n        be set if the search result is TableEmptyTree.\n\n    Return Value:\n\n        TABLE_SEARCH_RESULT - TableEmptyTree: The tree was empty.  NodeOrParent\n        is *not* altered.\n\n        TableFoundNode: A node with the key is in the tree.\n        NodeOrParent points to that node.\n\n        TableInsertAsLeft: Node with key was not found.\n        NodeOrParent points to what would\n        be parent.  The node would be the\n        left child.\n\n        TableInsertAsRight: Node with key was not found.\n        NodeOrParent points to what would\n        be parent.  The node would be\n        the right child.\n\n    Environment:\n\n        Kernel mode.  The PFN lock is held for some of the tables.\n\n--*/\n\n{\n    PMMADDRESS_NODE Child;\n    PMMADDRESS_NODE NodeToExamine;\n    PMMVAD_SHORT    VpnCompare;\n    ULONG_PTR       startVpn;\n    ULONG_PTR       endVpn;\n\n    if (Table->NumberGenericTableElements == 0) {\n        return TableEmptyTree;\n    }\n\n    NodeToExamine = (PMMADDRESS_NODE)GET_VAD_ROOT( Table );\n\n    for (;;) {\n\n        VpnCompare = (PMMVAD_SHORT)NodeToExamine;\n        startVpn = VpnCompare->StartingVpn;\n        endVpn = VpnCompare->EndingVpn;\n\n#if defined( _WIN81_ ) || defined( _WIN10_ )\n        startVpn |= (ULONG_PTR)VpnCompare->StartingVpnHigh << 32;\n        endVpn |= (ULONG_PTR)VpnCompare->EndingVpnHigh << 32;\n#endif  \n\n        //\n        // Compare the buffer with the key in the tree element.\n        //\n\n        if (StartingVpn < startVpn) {\n\n            Child = NodeToExamine->LeftChild;\n\n            if (Child != NULL) {\n                NodeToExamine = Child;\n            }\n            else {\n\n                //\n                // Node is not in the tree.  Set the output\n                // parameter to point to what would be its\n                // parent and return which child it would be.\n                //\n\n                *NodeOrParent = NodeToExamine;\n                return TableInsertAsLeft;\n            }\n        }\n        else if (StartingVpn <= endVpn) {\n\n            //\n            // This is the node.\n            //\n\n            *NodeOrParent = NodeToExamine;\n            return TableFoundNode;\n        }\n        else {\n\n            Child = NodeToExamine->RightChild;\n\n            if (Child != NULL) {\n                NodeToExamine = Child;\n            }\n            else {\n\n                //\n                // Node is not in the tree.  Set the output\n                // parameter to point to what would be its\n                // parent and return which child it would be.\n                //\n\n                *NodeOrParent = NodeToExamine;\n                return TableInsertAsRight;\n            }\n        }\n\n    };\n}\n", "comment_ratio": 0.31986899563318777}
{"lang": "c", "code": "#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <X11/X.h>\n#include <X11/Xlib.h>\n\n#include \"client.h\"\n#include \"display.h\"\n#include \"evilwm.h\"\n#include \"ewmh.h\"\n#include \"list.h\"\n#include \"screen.h\"\n#include \"util.h\"\n\n#define SPACE 3\n\n// Use the inverting graphics context to draw an outline for the client.\n// Drawing it a second time will erase it.  If INFOBANNER_MOVERESIZE is\n// defined, the information window is shown for the duration (but this can be\n// slow on old X servers).\n\nstatic void draw_outline(struct client *c) {\n#ifndef INFOBANNER_MOVERESIZE\n\tchar buf[27];\n\tint width_inc = c->width_inc, height_inc = c->height_inc;\n#endif\n\n\tXDrawRectangle(display.dpy, c->screen->root, c->screen->invert_gc,\n\t\tc->x - c->border, c->y - c->border,\n\t\tc->width + 2*c->border-1, c->height + 2*c->border-1);\n\n#ifndef INFOBANNER_MOVERESIZE\n\tsnprintf(buf, sizeof(buf), \"%dx%d+%d+%d\", (c->width-c->base_width)/width_inc,\n\t\t\t(c->height-c->base_height)/height_inc, c->x, c->y);\n\tXDrawString(display.dpy, c->screen->root, c->screen->invert_gc,\n\t\tc->x + c->width - XTextWidth(display.font, buf, strlen(buf)) - SPACE,\n\t\tc->y + c->height - SPACE,\n\t\tbuf, strlen(buf));\n#endif\n}\n\nstatic int absmin(int a, int b) {\n\tif (abs(a) < abs(b))\n\t\treturn a;\n\treturn b;\n}\n\n// Snap a client to the edges of other clients (if on same screen, and visible)\n// or to the screen border.\n\nstatic void snap_client(struct client *c, struct monitor *monitor) {\n\tint dx, dy;\n\tint dpy_width = monitor->width;\n\tint dpy_height = monitor->height;\n\n\t// Snap to other windows\n\n\tdx = dy = option.snap;\n\tfor (struct list *iter = clients_tab_order; iter; iter = iter->next) {\n\t\tstruct client *ci = iter->data;\n\t\tif (ci == c)\n\t\t\tcontinue;\n\t\tif (ci->screen != c->screen)\n\t\t\tcontinue;\n\t\tif (!is_fixed(ci) && ci->vdesk != c->screen->vdesk)\n\t\t\tcontinue;\n\t\tif (ci->is_dock && !c->screen->docks_visible)\n\t\t\tcontinue;\n\t\tif (ci->y - ci->border - c->border - c->height - c->y <= option.snap && c->y - c->border - ci->border - ci->height - ci->y <= option.snap) {\n\t\t\tdx = absmin(dx, ci->x + ci->width - c->x + c->border + ci->border);\n\t\t\tdx = absmin(dx, ci->x + ci->width - c->x - c->width);\n\t\t\tdx = absmin(dx, ci->x - c->x - c->width - c->border - ci->border);\n\t\t\tdx = absmin(dx, ci->x - c->x);\n\t\t}\n\t\tif (ci->x - ci->border - c->border - c->width - c->x <= option.snap && c->x - c->border - ci->border - ci->width - ci->x <= option.snap) {\n\t\t\tdy = absmin(dy, ci->y + ci->height - c->y + c->border + ci->border);\n\t\t\tdy = absmin(dy, ci->y + ci->height - c->y - c->height);\n\t\t\tdy = absmin(dy, ci->y - c->y - c->height - c->border - ci->border);\n\t\t\tdy = absmin(dy, ci->y - c->y);\n\t\t}\n\t}\n\tif (abs(dx) < option.snap)\n\t\tc->x += dx;\n\tif (abs(dy) < option.snap)\n\t\tc->y += dy;\n\n\t// Snap to screen border\n\n\tif (abs(c->x - c->border - monitor->x) < option.snap)\n\t\tc->x = monitor->x + c->border;\n\tif (abs(c->y - c->border - monitor->y) < option.snap)\n\t\tc->y = monitor->y + c->border;\n\tif (abs(c->x + c->width + c->border - monitor->x - dpy_width) < option.snap)\n\t\tc->x = monitor->x + dpy_width - c->width - c->border;\n\tif (abs(c->y + c->height + c->border - monitor->y - dpy_height) < option.snap)\n\t\tc->y = monitor->y + dpy_height - c->height - c->border;\n\n\tif (abs(c->x) == monitor->x + c->border && c->width == dpy_width)\n\t\tc->x = monitor->x;\n\tif (abs(c->y) == monitor->y + c->border && c->height == dpy_height)\n\t\tc->y = monitor->y;\n}\n\n// During a sweep (resize interaction), recalculate new dimensions for a window\n// based on mouse position relative to top-left corner.\n\nstatic void recalculate_sweep(struct client *c, int x1, int y1, int x2, int y2, _Bool force) {\n\tif (force || c->oldw == 0) {\n\t\tc->oldw = 0;\n\t\tc->width = abs(x1 - x2);\n\t\tc->width -= (c->width - c->base_width) % c->width_inc;\n\t\tif (c->min_width && c->width < c->min_width)\n\t\t\tc->width = c->min_width;\n\t\tif (c->max_width && c->width > c->max_width)\n\t\t\tc->width = c->max_width;\n\t\tc->x = (x1 <= x2) ? x1 : x1 - c->width;\n\t}\n\tif (force || c->oldh == 0)  {\n\t\tc->oldh = 0;\n\t\tc->height = abs(y1 - y2);\n\t\tc->height -= (c->height - c->base_height) % c->height_inc;\n\t\tif (c->min_height && c->height < c->min_height)\n\t\t\tc->height = c->min_height;\n\t\tif (c->max_height && c->height > c->max_height)\n\t\t\tc->height = c->max_height;\n\t\tc->y = (y1 <= y2) ? y1 : y1 - c->height;\n\t}\n}\n\n// Handle user resizing a window with the mouse.  Takes over processing X\n// motion events until the mouse button is released.\n//\n// Note that because of the way this draws an outline, other events are blocked\n// until the mouse is moved.  TODO: consider using a SHAPEd window for this,\n// where available.\n\nvoid client_resize_sweep(struct client *c, unsigned button) {\n\t// Ensure we can grab pointer events.\n\tif (!grab_pointer(c->screen->root, display.resize_curs))\n\t\treturn;\n\n\t// Sweeping always raises.\n\tclient_raise(c);\n\n\tint old_cx = c->x;\n\tint old_cy = c->y;\n\n#ifdef INFOBANNER_MOVERESIZE\n\tcreate_info_window(c);\n#endif\n\tXGrabServer(display.dpy);\n\tdraw_outline(c);  // draw\n\n\t// Warp pointer to the bottom-right of the client for resizing\n\tsetmouse(c->window, c->width, c->height);\n\n\tfor (;;) {\n\t\tXEvent ev;\n\t\tXMaskEvent(display.dpy, ButtonPressMask|ButtonReleaseMask|PointerMotionMask, &ev);\n\t\tswitch (ev.type) {\n\t\t\tcase MotionNotify:\n\t\t\t\tif (ev.xmotion.root != c->screen->root)\n\t\t\t\t\tbreak;\n\t\t\t\tdraw_outline(c);  // erase\n\t\t\t\tXUngrabServer(display.dpy);\n\t\t\t\trecalculate_sweep(c, old_cx, old_cy, ev.xmotion.x, ev.xmotion.y, ev.xmotion.state & altmask);\n#ifdef INFOBANNER_MOVERESIZE\n\t\t\t\tupdate_info_window(c);\n#endif\n\t\t\t\tXSync(display.dpy, False);\n\t\t\t\tXGrabServer(display.dpy);\n\t\t\t\tdraw_outline(c);  // draw\n\t\t\t\tbreak;\n\n\t\t\tcase ButtonRelease:\n\t\t\t\tif (ev.xbutton.button != button)\n\t\t\t\t\tcontinue;\n\t\t\t\tdraw_outline(c);  // erase\n\t\t\t\tXUngrabServer(display.dpy);\n#ifdef INFOBANNER_MOVERESIZE\n\t\t\t\tremove_info_window();\n#endif\n\t\t\t\tXUngrabPointer(display.dpy, CurrentTime);\n\t\t\t\tclient_moveresizeraise(c);\n\t\t\t\t// In case maximise state has changed:\n\t\t\t\tewmh_set_net_wm_state(c);\n\t\t\t\treturn;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\n// Handle user moving a window with the mouse.  Takes over processing X motion\n// events until the mouse button is released.\n//\n// If solid drag is disabled, an outline is drawn, which leads to the same\n// limitations as in the sweep() function.\n\nvoid client_move_drag(struct client *c, unsigned button) {\n\t// Ensure we can grab pointer events.\n\tif (!grab_pointer(c->screen->root, display.move_curs))\n\t\treturn;\n\n\t// Dragging always raises.\n\tclient_raise(c);\n\n\t// Initial pointer and window positions; new coordinates calculated\n\t// relative to these.\n\tint x1, y1;\n\tint old_cx = c->x;\n\tint old_cy = c->y;\n\tget_pointer_root_xy(c->screen->root, &x1, &y1);\n\n\tstruct monitor *monitor = client_monitor(c, NULL);\n\n#ifdef INFOBANNER_MOVERESIZE\n\tcreate_info_window(c);\n#endif\n\tif (option.no_solid_drag) {\n\t\tXGrabServer(display.dpy);\n\t\tdraw_outline(c);  // draw\n\t}\n\n\tfor (;;) {\n\t\tXEvent ev;\n\t\tXMaskEvent(display.dpy, ButtonPressMask|ButtonReleaseMask|PointerMotionMask, &ev);\n\t\tswitch (ev.type) {\n\t\t\tcase MotionNotify:\n\t\t\t\tif (ev.xmotion.root != c->screen->root)\n\t\t\t\t\tbreak;\n\t\t\t\tif (option.no_solid_drag) {\n\t\t\t\t\tdraw_outline(c);  // erase\n\t\t\t\t\tXUngrabServer(display.dpy);\n\t\t\t\t}\n\t\t\t\tc->x = old_cx + (ev.xmotion.x - x1);\n\t\t\t\tc->y = old_cy + (ev.xmotion.y - y1);\n\t\t\t\tif (option.snap && !(ev.xmotion.state & altmask))\n\t\t\t\t\tsnap_client(c, monitor);\n\n#ifdef INFOBANNER_MOVERESIZE\n\t\t\t\tupdate_info_window(c);\n#endif\n\t\t\t\tif (option.no_solid_drag) {\n\t\t\t\t\tXSync(display.dpy, False);\n\t\t\t\t\tXGrabServer(display.dpy);\n\t\t\t\t\tdraw_outline(c);  // draw\n\t\t\t\t} else {\n\t\t\t\t\tXMoveWindow(display.dpy, c->parent,\n\t\t\t\t\t\t\tc->x - c->border,\n\t\t\t\t\t\t\tc->y - c->border);\n\t\t\t\t\tsend_config(c);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase ButtonRelease:\n\t\t\t\tif (ev.xbutton.button != button)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (option.no_solid_drag) {\n\t\t\t\t\tdraw_outline(c);  // erase\n\t\t\t\t\tXUngrabServer(display.dpy);\n\t\t\t\t}\n#ifdef INFOBANNER_MOVERESIZE\n\t\t\t\tremove_info_window();\n#endif\n\t\t\t\tXUngrabPointer(display.dpy, CurrentTime);\n\t\t\t\tif (option.no_solid_drag) {\n\t\t\t\t\t// For solid drags, the client was\n\t\t\t\t\t// moved with the mouse.  For non-solid\n\t\t\t\t\t// drags, we need a final move/raise:\n\t\t\t\t\tclient_moveresizeraise(c);\n\t\t\t\t}\n\t\t\t\treturn;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\n// Predicate function for use with XCheckIfEvent.\n//\n// This is used to detect when a keyrelease is followed by a keypress with the\n// same keycode and timestamp, indicating autorepeat.\n\nstatic Bool predicate_keyrepeatpress(Display *dummy, XEvent *ev, XPointer arg) {\n\t(void)dummy;\n\tXEvent *release_event = (XEvent *)arg;\n\tif (ev->type != KeyPress)\n\t\treturn False;\n\tif (release_event->xkey.keycode != ev->xkey.keycode)\n\t\treturn False;\n\treturn release_event->xkey.time == ev->xkey.time;\n}\n\n// Show information window until the key used to activate (keycode) is\n// released.\n//\n// This routine used to disable autorepeat for the duration, but modern X\n// servers seem to only change the keyboard control after all keys have been\n// physically released, which is not so useful here.  Instead, we detect when a\n// key release is followed by a key press with the same code and timestamp,\n// which indicates autorepeat.\n\nvoid client_show_info(struct client *c, unsigned keycode) {\n\tif (XGrabKeyboard(display.dpy, c->screen->root, False, GrabModeAsync, GrabModeAsync, CurrentTime) != GrabSuccess)\n\t\treturn;\n\n#ifdef INFOBANNER\n\tcreate_info_window(c);\n#else\n\tXGrabServer(display.dpy);\n\tdraw_outline(c);\n#endif\n\n\tfor (;;) {\n\t\tXEvent ev;\n\t\tXMaskEvent(display.dpy, KeyReleaseMask, &ev);\n\t\tif (ev.xkey.keycode != keycode)\n\t\t\tcontinue;\n\t\tif (XCheckIfEvent(display.dpy, &ev, predicate_keyrepeatpress, (XPointer)&ev)) {\n\t\t\t// Autorepeat keypress detected - ignore!\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n#ifdef INFOBANNER\n\tremove_info_window();\n#else\n\tdraw_outline(c);\n\tXUngrabServer(display.dpy);\n#endif\n\n\tXUngrabKeyboard(display.dpy, CurrentTime);\n}\n\n// Move window to (potentially updated) client coordinates.\n\nvoid client_moveresize(struct client *c) {\n\tXMoveResizeWindow(display.dpy, c->parent, c->x - c->border, c->y - c->border,\n\t\t\tc->width, c->height);\n\tXMoveResizeWindow(display.dpy, c->window, 0, 0, c->width, c->height);\n\tsend_config(c);\n}\n\n// Same, but raise the client first.\n\nvoid client_moveresizeraise(struct client *c) {\n\tclient_raise(c);\n\tclient_moveresize(c);\n}\n\n// Maximise (or de-maximise) horizontally, vertically, or both.\n//\n// Updates EWMH properties, but also stores old dimensions in evilwm-specific\n// properties so that they persist across window manager restarts.\n\nvoid client_maximise(struct client *c, int action, int hv) {\n\tint monitor_x, monitor_y;\n\tint monitor_width, monitor_height;\n\n\t// Maximising to monitor or screen?\n\tif (hv & MAXIMISE_SCREEN) {\n\t\tmonitor_x = monitor_y = 0;\n\t\tmonitor_width = DisplayWidth(display.dpy, c->screen->screen);\n\t\tmonitor_height = DisplayHeight(display.dpy, c->screen->screen);\n\t} else {\n\t\tstruct monitor *monitor = client_monitor(c, NULL);\n\t\tmonitor_x = monitor->x;\n\t\tmonitor_y = monitor->y;\n\t\tmonitor_width = monitor->width;\n\t\tmonitor_height = monitor->height;\n\t}\n\n\tif (hv & MAXIMISE_HORZ) {\n\t\tif (c->oldw) {\n\t\t\tif (action == NET_WM_STATE_REMOVE || action == NET_WM_STATE_TOGGLE) {\n\t\t\t\tc->x = c->oldx;\n\t\t\t\tc->width = c->oldw;\n\t\t\t\tc->oldw = 0;\n\t\t\t\tXDeleteProperty(display.dpy, c->window, X_ATOM(_EVILWM_UNMAXIMISED_HORZ));\n\t\t\t}\n\t\t} else {\n\t\t\tif (action == NET_WM_STATE_ADD || action == NET_WM_STATE_TOGGLE) {\n\t\t\t\tunsigned long props[2];\n\t\t\t\tc->oldx = c->x;\n\t\t\t\tc->oldw = c->width;\n\t\t\t\tc->x = monitor_x;\n\t\t\t\tc->width = monitor_width;\n\t\t\t\tprops[0] = c->oldx;\n\t\t\t\tprops[1] = c->oldw;\n\t\t\t\tXChangeProperty(display.dpy, c->window, X_ATOM(_EVILWM_UNMAXIMISED_HORZ),\n\t\t\t\t\t\tXA_CARDINAL, 32, PropModeReplace,\n\t\t\t\t\t\t(unsigned char *)&props, 2);\n\t\t\t}\n\t\t}\n\t}\n\tif (hv & MAXIMISE_VERT) {\n\t\tif (c->oldh) {\n\t\t\tif (action == NET_WM_STATE_REMOVE || action == NET_WM_STATE_TOGGLE) {\n\t\t\t\tc->y = c->oldy;\n\t\t\t\tc->height = c->oldh;\n\t\t\t\tc->oldh = 0;\n\t\t\t\tXDeleteProperty(display.dpy, c->window, X_ATOM(_EVILWM_UNMAXIMISED_VERT));\n\t\t\t}\n\t\t} else {\n\t\t\tif (action == NET_WM_STATE_ADD || action == NET_WM_STATE_TOGGLE) {\n\t\t\t\tunsigned long props[2];\n\t\t\t\tc->oldy = c->y;\n\t\t\t\tc->oldh = c->height;\n\t\t\t\tc->y = monitor_y;\n\t\t\t\tc->height = monitor_height;\n\t\t\t\tprops[0] = c->oldy;\n\t\t\t\tprops[1] = c->oldh;\n\t\t\t\tXChangeProperty(display.dpy, c->window, X_ATOM(_EVILWM_UNMAXIMISED_VERT),\n\t\t\t\t\t\tXA_CARDINAL, 32, PropModeReplace,\n\t\t\t\t\t\t(unsigned char *)&props, 2);\n\t\t\t}\n\t\t}\n\t}\n\t_Bool change_border = 0;\n\tif (c->oldw && c->oldh) {\n\t\t// maximised - remove border\n\t\tif (c->border) {\n\t\t\tc->border = 0;\n\t\t\tchange_border = 1;\n\t\t}\n\t} else {\n\t\t// not maximised - add border\n\t\tif (!c->border && c->normal_border) {\n\t\t\tc->border = c->normal_border;\n\t\t\tchange_border = 1;\n\t\t}\n\t}\n\tif (change_border) {\n\t\tXSetWindowBorderWidth(display.dpy, c->parent, c->border);\n\t\tewmh_set_net_frame_extents(c->window, c->border);\n\t}\n\tewmh_set_net_wm_state(c);\n\tclient_moveresizeraise(c);\n\tdiscard_enter_events(c);\n}\n\n// Find and select the \"next\" client, relative to the currently selected one\n// (basically, handle Alt+Tab).  Order is most-recently-used (maintained in the\n// clients_tab_order list).\n\nvoid client_select_next(void) {\n\tstruct list *newl = list_find(clients_tab_order, current);\n\tstruct client *newc = current;\n\n\tdo {\n\t\tif (newl) {\n\t\t\tnewl = newl->next;\n\t\t\tif (!newl && !current)\n\t\t\t\treturn;\n\t\t}\n\t\tif (!newl)\n\t\t\tnewl = clients_tab_order;\n\t\tif (!newl)\n\t\t\treturn;\n\t\tnewc = newl->data;\n\t\tif (newc == current)\n\t\t\treturn;\n\t} while ((!is_fixed(newc) && (newc->vdesk != newc->screen->vdesk))\n\t\t || (newc->is_dock && !newc->screen->docks_visible));\n\n\tif (!newc)\n\t\treturn;\n\n\tclient_show(newc);  // XXX why would it be hidden?\n\tclient_raise(newc);\n\tselect_client(newc);\n\n\t// Optionally force the pointer to jump to the newly-selected window.\n\t// I think this was the default behaviour in much earlier versions of\n\t// evilwm (possibly to generate the enter event and handle selecting\n\t// the client as a result of that), but I don't like it now.\n\n#ifdef WARP_POINTER\n\tsetmouse(newc->window, newc->width + newc->border - 1,\n\t\t\tnewc->height + newc->border - 1);\n#endif\n\n\tdiscard_enter_events(newc);\n}\n\n", "comment_ratio": 0.142}
{"lang": "c", "code": "#include <stdio.h>\n#include <pthread.h>\n\n#include \"tlclasses.h\"\n\nTL_EXPOSE_VAR int x1234;\n\nTL_EXPOSE_VAR char test_char;\n\nvoid *thread_func(void *p)\n{\n\t++test_char;\n\t++*((int *)p); // example of where this is unhelpful\n        return NULL;\n}\n\nint main(int argc, char **argv)\n{\n\tx1234 = 2;\n\ttest_char = 'd';\n\tprintf(\"%d\\n\", x1234);\n\tpthread_t p;\n\tpthread_create(&p, NULL, thread_func, &x1234); // but the access may be\n                                                       // caught here\n\t++test_char;\n        pthread_join(p, NULL);\n\tprintf(\"hello world!\\n\");\n}\n\n", "comment_ratio": 0.10344827586206896}
{"lang": "c", "code": "#ifndef CHANGESETWRITER_H\n#define CHANGESETWRITER_H\n\n#include \"geodiff.h\"\n\n#include \"changeset.h\"\n\n#include <fstream>\n\n/**\n * Class for writing binary changeset files.\n * First use open() to create a new changeset file and then for each modified table:\n * - call beginTable() once\n * - then call writeEntry() for each change within that table\n *\n * See changeset-format.md for the documentation of the format.\n */\nclass ChangesetWriter\n{\n  public:\n\n    //! opens a file for writing changeset (will overwrite if it exists already)\n    bool open( const std::string &filename );\n\n    //! writes table information, all subsequent writes will be related to this table until next call to beginTable()\n    void beginTable( const ChangesetTable &table );\n\n    //! writes table change entry\n    void writeEntry( const ChangesetEntry &entry );\n\n  private:\n\n    void writeByte( char c );\n    void writeVarint( int n );\n    void writeNullTerminatedString( const std::string &str );\n\n    void writeRowValues( const std::vector<Value> &values );\n\n    std::ofstream mFile;\n\n    ChangesetTable mCurrentTable;  // currently processed table\n};\n\n#endif // CHANGESETWRITER_H\n\n", "comment_ratio": 0.1}
{"lang": "c", "code": "#import <objc/NSObject.h>\n\n@class LOTBezierData, NSArray, NSNumber, UIColor;\n\n@interface LOTKeyframe : NSObject\n{\n    _Bool _isHold;\n    NSNumber *_keyframeTime;\n    double _floatValue;\n    UIColor *_colorValue;\n    LOTBezierData *_pathData;\n    NSArray *_arrayValue;\n    struct CGPoint _inTangent;\n    struct CGPoint _outTangent;\n    struct CGPoint _spatialInTangent;\n    struct CGPoint _spatialOutTangent;\n    struct CGPoint _pointValue;\n    struct CGSize _sizeValue;\n}\n\n@property(readonly, nonatomic) NSArray *arrayValue; // @synthesize arrayValue=_arrayValue;\n@property(readonly, nonatomic) LOTBezierData *pathData; // @synthesize pathData=_pathData;\n@property(readonly, nonatomic) UIColor *colorValue; // @synthesize colorValue=_colorValue;\n@property(readonly, nonatomic) struct CGSize sizeValue; // @synthesize sizeValue=_sizeValue;\n@property(readonly, nonatomic) struct CGPoint pointValue; // @synthesize pointValue=_pointValue;\n@property(readonly, nonatomic) double floatValue; // @synthesize floatValue=_floatValue;\n@property(readonly, nonatomic) struct CGPoint spatialOutTangent; // @synthesize spatialOutTangent=_spatialOutTangent;\n@property(readonly, nonatomic) struct CGPoint spatialInTangent; // @synthesize spatialInTangent=_spatialInTangent;\n@property(readonly, nonatomic) struct CGPoint outTangent; // @synthesize outTangent=_outTangent;\n@property(readonly, nonatomic) struct CGPoint inTangent; // @synthesize inTangent=_inTangent;\n@property(readonly, nonatomic) _Bool isHold; // @synthesize isHold=_isHold;\n@property(readonly, nonatomic) NSNumber *keyframeTime; // @synthesize keyframeTime=_keyframeTime;\n- (void).cxx_destruct;\n- (id)_colorValueFromArray:(id)arg1;\n- (struct CGPoint)_pointFromValueDict:(id)arg1;\n- (struct CGPoint)_pointFromValueArray:(id)arg1;\n- (void)setupOutputWithData:(id)arg1;\n- (void)remapValueWithBlock:(CDUnknownBlockType)arg1;\n- (void)setData:(id)arg1;\n- (id)copyWithData:(id)arg1;\n- (id)initWithLOTKeyframe:(id)arg1;\n- (id)initWithValue:(id)arg1;\n- (id)initWithKeyframe:(id)arg1;\n\n@end\n\n\n", "comment_ratio": 0.32075471698113206}
{"lang": "c", "code": "#import <itunesstored/itunesstored-Structs.h>\n#import <itunesstored/NSCopying.h>\n\n@class NSNumber, NSString;\n\n@interface MediaSocialStatusPollRequest : NSObject <NSCopying> {\n\n\tNSNumber* _accountIdentifier;\n\tNSString* _activityIdentifier;\n\tdouble _pollingDuration;\n\tdouble _pollingInterval;\n\tlong long _postIdentifier;\n\tNSString* _sourceApplicationIdentifier;\n\tdouble _postCreateTime;\n\n}\n\n@property (nonatomic,copy) NSString * activityIdentifier;                       //@synthesize activityIdentifier=_activityIdentifier - In the implementation block\n@property (nonatomic,copy) NSNumber * accountIdentifier;                        //@synthesize accountIdentifier=_accountIdentifier - In the implementation block\n@property (assign,nonatomic) double pollingDuration;                            //@synthesize pollingDuration=_pollingDuration - In the implementation block\n@property (assign,nonatomic) double pollingInterval;                            //@synthesize pollingInterval=_pollingInterval - In the implementation block\n@property (assign,nonatomic) long long postIdentifier;                          //@synthesize postIdentifier=_postIdentifier - In the implementation block\n@property (nonatomic,copy) NSString * sourceApplicationIdentifier;              //@synthesize sourceApplicationIdentifier=_sourceApplicationIdentifier - In the implementation block\n@property (assign,nonatomic) double postCreateTime;                             //@synthesize postCreateTime=_postCreateTime - In the implementation block\n-(BOOL)isEqual:(id)arg1 ;\n-(unsigned long long)hash;\n-(id)copyWithZone:(NSZone*)arg1 ;\n-(void)setAccountIdentifier:(NSNumber *)arg1 ;\n-(NSNumber *)accountIdentifier;\n-(double)pollingInterval;\n-(void)setSourceApplicationIdentifier:(NSString *)arg1 ;\n-(NSString *)sourceApplicationIdentifier;\n-(NSString *)activityIdentifier;\n-(void)setActivityIdentifier:(NSString *)arg1 ;\n-(void)setPollingInterval:(double)arg1 ;\n-(void)setPollingDuration:(double)arg1 ;\n-(void)setPostIdentifier:(long long)arg1 ;\n-(void)setPostCreateTime:(double)arg1 ;\n-(double)pollingDuration;\n-(long long)postIdentifier;\n-(double)postCreateTime;\n@end\n\n\n", "comment_ratio": 0.1346153846153846}
{"lang": "c", "code": "#pragma once\r\n\r\n#include \"Enums11.h\"\r\n\r\nnamespace SlimDX\r\n{\r\n\tnamespace Direct3D11\r\n\t{\t\r\n\t\t/// <summary>\r\n\t\t/// Describes a buffer resource.\r\n\t\t/// </summary>\r\n\t\t/// <unmanaged>D3D11_BUFFER_DESC</unmanaged>\r\n\t\tpublic value class BufferDescription : System::IEquatable<BufferDescription>\r\n\t\t{\r\n\t\tprivate:\r\n\t\t\tint m_ByteWidth;\r\n\t\t\tResourceUsage m_Usage;\r\n\t\t\tBindFlags m_BindFlags;\r\n\t\t\tCpuAccessFlags m_CPUAccessFlags;\r\n\t\t\tResourceOptionFlags m_MiscFlags;\r\n\t\t\tint m_StructureByteStride;\r\n\r\n\t\tinternal:\r\n\t\t\tBufferDescription( const D3D11_BUFFER_DESC& native );\r\n\t\t\t\r\n\t\tpublic:\r\n\t\t\t/// <summary>\r\n\t\t\t/// Gets or sets the size, in bytes, of the buffer.\r\n\t\t\t/// </summary>\r\n\t\t\tproperty int SizeInBytes\r\n\t\t\t{\r\n\t\t\t\tint get();\r\n\t\t\t\tvoid set( int value );\r\n\t\t\t}\r\n\r\n\t\t\t/// <summary>\r\n\t\t\t/// Gets or sets the intended usage pattern of the buffer.\r\n\t\t\t/// </summary>\r\n\t\t\tproperty ResourceUsage Usage\r\n\t\t\t{\r\n\t\t\t\tResourceUsage get();\r\n\t\t\t\tvoid set( ResourceUsage value );\r\n\t\t\t}\r\n\r\n\t\t\t/// <summary>\r\n\t\t\t/// Gets or sets the flags specifying how the buffer is bound to the pipeline.\r\n\t\t\t/// </summary>\r\n\t\t\tproperty Direct3D11::BindFlags BindFlags\r\n\t\t\t{\r\n\t\t\t\tDirect3D11::BindFlags get();\r\n\t\t\t\tvoid set( Direct3D11::BindFlags value );\r\n\t\t\t}\r\n\r\n\t\t\t/// <summary>\r\n\t\t\t/// Gets or sets the flags specifying how the CPU will be allowed to access the buffer.\r\n\t\t\t/// </summary>\r\n\t\t\tproperty Direct3D11::CpuAccessFlags CpuAccessFlags\r\n\t\t\t{\r\n\t\t\t\tDirect3D11::CpuAccessFlags get();\r\n\t\t\t\tvoid set( Direct3D11::CpuAccessFlags value );\r\n\t\t\t}\r\n\r\n\t\t\t/// <summary>\r\n\t\t\t/// Gets or sets the flags specifying miscellaneous resource options.\r\n\t\t\t/// </summary>\r\n\t\t\tproperty ResourceOptionFlags OptionFlags\r\n\t\t\t{\r\n\t\t\t\tResourceOptionFlags get();\r\n\t\t\t\tvoid set( ResourceOptionFlags value );\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t/// <summary>\r\n\t\t\t/// Gets or sets the size (in bytes) of the structure used for elements of a structured buffer.\r\n\t\t\t/// </summary>\r\n\t\t\tproperty int StructureByteStride\r\n\t\t\t{\r\n\t\t\t\tint get();\r\n\t\t\t\tvoid set( int value );\r\n\t\t\t}\r\n\r\n\t\t\t/// <summary>\r\n\t\t\t/// Initializes a new instance of the <see cref=\"BufferDescription\"/> struct.\r\n\t\t\t/// </summary>\r\n\t\t\t/// <param name=\"sizeInBytes\">The size, in bytes, of the buffer.</param>\r\n\t\t\t/// <param name=\"usage\">The usage pattern for the buffer.</param>\r\n\t\t\t/// <param name=\"bindFlags\">Flags specifying how the buffer will be bound to the pipeline.</param>\r\n\t\t\t/// <param name=\"accessFlags\">Flags specifying how the buffer will be accessible from the CPU.</param>\r\n\t\t\t/// <param name=\"optionFlags\">Miscellaneous resource options.</param>\r\n\t\t\t/// <param name=\"structureByteStride\">The size (in bytes) of the structure for a structured buffer.</param>\r\n\t\t\tBufferDescription( int sizeInBytes, ResourceUsage usage, Direct3D11::BindFlags bindFlags, Direct3D11::CpuAccessFlags accessFlags, ResourceOptionFlags optionFlags, int structureByteStride );\r\n\t\t\r\n\t\t\t/// <summary>\r\n\t\t\t/// Tests for equality between two BufferDescriptions.\r\n\t\t\t/// </summary>\r\n\t\t\t/// <param name=\"left\">The first value to compare.</param>\r\n\t\t\t/// <param name=\"right\">The second value to compare.</param>\r\n\t\t\t/// <returns><c>true</c> if <paramref name=\"left\"/> has the same value as <paramref name=\"right\"/>; otherwise, <c>false</c>.</returns>\r\n\t\t\tstatic bool operator == ( BufferDescription left, BufferDescription right );\r\n\t\t\t\r\n\t\t\t/// <summary>\r\n\t\t\t/// Tests for inequality between two BufferDescriptions.\r\n\t\t\t/// </summary>\r\n\t\t\t/// <param name=\"left\">The first value to compare.</param>\r\n\t\t\t/// <param name=\"right\">The second value to compare.</param>\r\n\t\t\t/// <returns><c>true</c> if <paramref name=\"left\"/> has a different value than <paramref name=\"right\"/>; otherwise, <c>false</c>.</returns>\r\n\t\t\tstatic bool operator != ( BufferDescription left, BufferDescription right );\r\n\t\t\t\r\n\t\t\t/// <summary>\r\n\t\t\t/// Returns the hash code for this instance.\r\n\t\t\t/// </summary>\r\n\t\t\t/// <returns>A 32-bit signed integer hash code.</returns>\r\n\t\t\tvirtual int GetHashCode() override;\r\n\t\t\t\r\n\t\t\t/// <summary>\r\n\t\t\t/// Returns a value indicating whether this instance is equal to the specified object.\r\n\t\t\t/// </summary>\r\n\t\t\t/// <param name=\"obj\">An object to compare with this instance.</param>\r\n\t\t\t/// <returns><c>true</c> if <paramref name=\"obj\"/> has the same value as this instance; otherwise, <c>false</c>.</returns>\r\n\t\t\tvirtual bool Equals( System::Object^ obj ) override;\r\n\r\n\t\t\t/// <summary>\r\n\t\t\t/// Returns a value indicating whether this instance is equal to the specified object.\r\n\t\t\t/// </summary>\r\n\t\t\t/// <param name=\"other\">A <see cref=\"BufferDescription\"/> to compare with this instance.</param>\r\n\t\t\t/// <returns><c>true</c> if <paramref name=\"other\"/> has the same value as this instance; otherwise, <c>false</c>.</returns>\r\n\t\t\tvirtual bool Equals( BufferDescription other );\r\n\r\n\t\t\t/// <summary>\r\n\t\t\t/// Returns a value indicating whether the two BufferDescriptions are equivalent.\r\n\t\t\t/// </summary>\r\n\t\t\t/// <param name=\"value1\">The first value to compare.</param>\r\n\t\t\t/// <param name=\"value2\">The second value to compare.</param>\r\n\t\t\t/// <returns><c>true</c> if <paramref name=\"value1\"/> has the same value as <paramref name=\"value2\"/>; otherwise, <c>false</c>.</returns>\r\n\t\t\tstatic bool Equals( BufferDescription% value1, BufferDescription% value2 );\r\n\t\t};\r\n\t}\r\n};\n", "comment_ratio": 0.3987341772151899}
{"lang": "c", "code": "#if !defined(LZS_H)\n#define LZS_H\n\nint encode_file(char *in, char *out);\nint decode_file(char *in, char *out);\n\n#endif // !defined(LZS_H)\n\n", "comment_ratio": 0.125}
{"lang": "c", "code": "#import \"NSObject.h\"\n\n#import \"UIAlertViewDelegate.h\"\n\n@class NSMutableDictionary, NSString;\n\n@interface ReadInJoy0x68bMonitor : NSObject <UIAlertViewDelegate>\n{\n    NSMutableDictionary *_monitoredSeqDic;\n}\n\n+ (id)getInstance;\n- (void).cxx_destruct;\n- (void)alertView:(id)arg1 clickedButtonAtIndex:(long long)arg2;\n- (void)endMonitorAtRecvWithSeq:(int)arg1 recvArticleArray:(id)arg2;\n- (id)errorStrFromKdWithReqInfoDic:(id)arg1 recvArticleArray:(id)arg2;\n- (id)errorStrFromSaWithReqInfoDic:(id)arg1 recvArticleArray:(id)arg2;\n- (id)init;\n@property(retain, nonatomic) NSMutableDictionary *monitoredSeqDic; // @synthesize monitoredSeqDic=_monitoredSeqDic;\n- (id)recvDetialFromArticleArray:(id)arg1;\n- (id)reqAndRecvDetialFromKdIdArray:(id)arg1 recvArticleArray:(id)arg2;\n- (id)reqAndRecvDetialFromSaId:(unsigned long long)arg1 title:(id)arg2 recvArticleArray:(id)arg3;\n- (void)showAlertWithErrorStr:(id)arg1;\n- (void)startMonitorAtReqWithSeq:(int)arg1 reqInfoDic:(id)arg2;\n- (id)uinAndTimeStr;\n\n// Remaining properties\n@property(readonly, copy) NSString *debugDescription;\n@property(readonly, copy) NSString *description;\n@property(readonly) unsigned long long hash;\n@property(readonly) Class superclass;\n\n@end\n\n\n", "comment_ratio": 0.17073170731707318}
{"lang": "c", "code": "#import \"NSObject.h\"\n\n@interface KeychainAccountStorage : NSObject\n{\n}\n\n+ (id)configuredAccountIdentifiers;\n+ (void)_deleteFileAtPath:(id)arg1 ifNotOfExpectedType:(id)arg2;\n+ (BOOL)_accountsDirectoryCreated;\n+ (void)_setCachedKey:(id)arg1 forDSID:(id)arg2;\n+ (id)_cachedKeyForDSID:(id)arg1;\n+ (void)_removeInfoForDSID:(id)arg1;\n+ (id)_dsidForAccount:(struct AOSAccount *)arg1;\n+ (id)_dsidForAlias:(id)arg1;\n+ (id)_aliasPathsForDSID:(id)arg1;\n+ (void)_removeAliasesForDSID:(id)arg1;\n+ (BOOL)_updateAlias:(id)arg1 forDSID:(id)arg2;\n+ (BOOL)_updateAliases:(id)arg1 forDSID:(id)arg2;\n+ (id)_generateKeyFromData:(id)arg1;\n+ (id)_decryptedDataForDSID:(id)arg1 andKey:(id)arg2;\n+ (BOOL)_storeInfo:(id)arg1 forDSID:(id)arg2 withKey:(id)arg3;\n+ (id)_storedInfoForDSID:(id)arg1 withKey:(id)arg2;\n+ (void)_removeKeyForDSID:(id)arg1 andService:(id)arg2;\n+ (int)_updateItem:(struct __SecKeychainItem *)arg1 withNewServiceName:(id)arg2;\n+ (BOOL)_isValidKeychainItem:(struct __SecKeychainItem *)arg1;\n+ (id)_appStringFromSecTrustedApplication:(struct __SecTrustedApplication *)arg1;\n+ (BOOL)_storeKey:(id)arg1 forDSID:(id)arg2 service:(id)arg3 primaryAppleID:(id)arg4 andAccount:(struct AOSAccount *)arg5;\n+ (id)_storedKeyForDSID:(id)arg1 andAccount:(struct AOSAccount *)arg2;\n+ (void)removeInfoForAccount:(struct AOSAccount *)arg1;\n+ (BOOL)storeInfo:(id)arg1 forAccount:(struct AOSAccount *)arg2;\n+ (id)storedInfoForAccount:(struct AOSAccount *)arg1;\n+ (void)initialize;\n\n@end\n\n\n", "comment_ratio": 0.11904761904761904}
{"lang": "c", "code": "#ifndef RECONSTRUCTOR_H_\n#define RECONSTRUCTOR_H_\n\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <vnl/vnl_matrix.h>\n#include <vnl/vnl_vector.h>\n\nclass FltFile;\n\nconst int BUFF_MAX = 256;\n\n// Abstract base class for reconstruction task.\n// TODO: Disallow copy and assignment.\nclass Reconstructor {\n public:\n  Reconstructor(const char* config) :\n      fltFile(0), S0Image(0), b2Dslice(0),\n      minSig(0.001f), S0Scale(1), S0default(1), bUseS0(0),\n      bUseBMatrix(0), bFixedBValue(1), degree(6) {\n    strcpy(f_config, config);\n  }\n\n  virtual ~Reconstructor();\n\n  //void SetConfigFile(const char* input_config);\n  // Interface for performing reconstruction.\n  // Should be implemented by derived classes.\n  virtual void DoReconstruction() = 0;\n\n protected:\n  virtual void ComputeP(vnl_vector<float>& S, vnl_vector<float>& P) = 0;\n  bool ReadSignal(unsigned i, vnl_vector <float> &S);\n  void SignalAttenuation(unsigned i, vnl_vector <float> &S);\n  void ComputeADC(vnl_vector <float> &S);\n  void SaveProbabilityProfile(unsigned i, vnl_vector <float> &P);\n  void Reconstruct();\n  void Write();\n  void Prepare();\n  void LoadOutputDataFiles();\n  void LoadInputDataFiles();\n  void PrepareInputData();\n  void PrepareOutputData();\n  void LoadImagingParams();\n  void LoadCommonConstants();\n  void LoadFltFile(const char*);\n  void LoadS0File(const char*);\n  void WriteFltFile(const char*);\n  void AssembleSPHBasis();\n\n protected:\n  // diffusion time, measured in seconds; typical value: 0.020s.\n  float t;\n  // radius of the probability surface, measured in mm = 1000um; typical value: 0.015mm\n  float r;\n  // regularization factor for spherical harmonics coefficients\n  float lambda;\n  // configuration file\n  char f_config[512];\n  // int K, T;\n  // K*3 matrix containing gradient directions where K is the # of measurements\n  vnl_matrix<float> gradients;\n  // K*6 matrix containing b-matrices where K is the # of measurements\n  vnl_matrix<float> bmatrix;\n  // T*6 matrix containing tessellation vertices where T is the # of vertices\n  vnl_matrix<float> tessellation;\n  // b-values of diffusion gradients\n  vnl_vector<float> b;\n\n  FltFile* fltFile;\n  int nSamples, nVoxels;\n  int bUseBMatrix;\n\n  int degree;\n  int nCoeffs, nMoreCoeffs;\n  std::vector<float *> m_SPH_coeff;\n  //std::vector<float *> m_SPH_coeff_mag;\n  std::vector<float *> m_coeff_real;\n  std::vector<float *> m_coeff_imag;\n  std::vector<float *> m_weights;\n\n  std::vector<float *> m_S_coeff;\n  std::vector<float *> m_S_coeff_real;\n  std::vector<float *> m_S_coeff_imag;\n  std::vector<float *> m_qball_coeff_real;\n  std::vector<float *> m_qball_coeff_imag;\n\n private:\n  float minSig;\n  std::vector<float*> data, S0;\n\n  vnl_matrix<float> SPH_basis, inv_SPH_basis;\n  FltFile*  S0Image;\n  float S0default, S0Scale;\n  bool b2Dslice;\n  int bUseS0;\n  int bFixedBValue;\n};\n#endif  // RECONSTRUCTOR_H_\n\n", "comment_ratio": 0.15841584158415842}
{"lang": "c", "code": "#ifndef RNChartManagerBridge_h\n#define RNChartManagerBridge_h\n\n#define EXPORT_CHART_BASE_PROPERTIES \\\nRCT_EXPORT_VIEW_PROPERTY(data, NSDictionary) \\\nRCT_EXPORT_VIEW_PROPERTY(highlights, NSArray) \\\nRCT_EXPORT_VIEW_PROPERTY(legend, NSDictionary) \\\nRCT_EXPORT_VIEW_PROPERTY(chartBackgroundColor, NSInteger) \\\nRCT_EXPORT_VIEW_PROPERTY(chartDescription, NSDictionary) \\\nRCT_EXPORT_VIEW_PROPERTY(noDataText, NSString) \\\nRCT_EXPORT_VIEW_PROPERTY(noDataTextColor, NSInteger) \\\nRCT_EXPORT_VIEW_PROPERTY(noDataTextFontSize, CGFloat) \\\nRCT_EXPORT_VIEW_PROPERTY(touchEnabled, BOOL) \\\nRCT_EXPORT_VIEW_PROPERTY(dragDecelerationEnabled, BOOL) \\\nRCT_EXPORT_VIEW_PROPERTY(dragDecelerationFrictionCoef, NSNumber) \\\nRCT_EXPORT_VIEW_PROPERTY(animation, NSDictionary) \\\nRCT_EXPORT_VIEW_PROPERTY(xAxis, NSDictionary) \\\nRCT_EXPORT_VIEW_PROPERTY(marker, NSDictionary) \\\nRCT_EXPORT_VIEW_PROPERTY(onSelect, RCTBubblingEventBlock) \\\nRCT_EXPORT_VIEW_PROPERTY(onChange, RCTBubblingEventBlock)\n\n\n\n#endif /* RNChartManagerBridge_h */\n\n", "comment_ratio": 0.21212121212121213}
{"lang": "c", "code": "#import \"NSCollectionView.h\"\n\n@interface NSCollectionView (IMSharedUICompatibility)\n- (id)dequeueReusableSupplementaryViewOfKind:(id)arg1 withReuseIdentifier:(id)arg2 forIndexPath:(id)arg3;\n- (id)dequeueReusableCellWithReuseIdentifier:(id)arg1 forIndexPath:(id)arg2;\n@end\n\n\n", "comment_ratio": 0.35714285714285715}
{"lang": "c", "code": "#include <X11/XF86keysym.h>\n/* appearance */\nstatic const unsigned int borderpx = 0; /* border pixel of windows */\nstatic const unsigned int gappx = 5;    /* gaps between windows */\nstatic const unsigned int snap = 32;    /* snap pixel */\nstatic const unsigned int systraypinning =\n    0; /* 0: sloppy systray follows selected monitor, >0: pin systray to monitor\n          X */\nstatic const unsigned int systrayspacing = 2; /* systray spacing */\nstatic const int systraypinningfailfirst = 1; /* 1: if pinning fails, display\nsystray on the first monitor, False: display systray on the last monitor*/\nstatic const int showsystray = 1;             /* 0 means no systray */\nstatic const int smartgaps =\n    0; /* 1 means no outer gap when there is only one window */\nstatic const int showbar = 1;   /* 0 means no bar */\nstatic const int topbar = 1;    /* 0 means botom bar */\nstatic const int viewontag = 1; /* Switch view on tag switch */\nstatic const char *fonts[] = {\"Fira Code:size=10:antialias=true:autohint=true\"};\nstatic const char dmenufont[] =\n    \"Fira Code:size=10:antialias=true:autohint=true\";\n// static const char col_gray1[] = \"#222222\";\n// static const char col_gray2[] = \"#444444\";\n// static const char col_gray3[] = \"#bbbbbb\";\n// static const char col_gray4[] = \"#ffffff\";\n\n// gruvbox dark\nstatic const char col_gray1[] = \"#282828\";\nstatic const char col_gray2[] = \"#3c3836\";\nstatic const char col_gray3[] = \"#ebdbb2\";\nstatic const char col_gray4[] = \"#fdf1c7\";\nstatic const char col_cyan[] = \"#d79921\";\n\n// gruvbox light\n// static const char col_gray1[] = \"#fdf1c7\";\n// static const char col_gray2[] = \"#ebdbb2\";\n// static const char col_gray3[] = \"#3c3836\";\n// static const char col_gray4[] = \"#282828\";\n// static const char col_cyan[] = \"#fabd2f\";\n\nstatic const char col_border[] = \"#42A5F5\";\nstatic const unsigned int baralpha = 0xd0;\nstatic const unsigned int borderalpha = OPAQUE;\nstatic const char *colors[][3] = {\n    /*               fg         bg         border   */\n    [SchemeNorm] = {col_gray3, col_gray1, col_gray2},\n    [SchemeSel] = {col_gray4, col_cyan, col_border},\n    [SchemeHid] = {col_cyan, col_gray1, col_border},\n};\nstatic const unsigned int alphas[][3] = {\n    /*               fg      bg        border     */\n    [SchemeNorm] = {OPAQUE, baralpha, borderalpha},\n    [SchemeSel] = {OPAQUE, baralpha, borderalpha},\n};\n\n/* tagging */\nstatic const char *tags[] = {\"\\uf120\", \"\\uf7ae\", \"\\uf121\", \"\\uf04b\", \"\\ue62e\",\n                             \"\\uf251\", \"\\ue727\", \"\\uf537\", \"\\uf684\"};\n\nstatic const Rule rules[] = {\n    /* xprop(1):\n     *\tWM_CLASS(STRING) = instance, class\n     *\tWM_NAME(STRING)  = title\n     */\n    /* class      \t\tinstance    title       tags mask     isfloating\n     * monitor\n     */\n    {\"Gimp\", NULL, NULL, 0, 1, -1},\n};\n\n/* layout(s) */\nstatic const float mfact = 0.5; /* factor of master area size [0.05..0.95] */\nstatic const int nmaster = 1;   /* number of clients in master area */\nstatic const int resizehints =\n    1; /* 1 means respect size hints in tiled resizals */\n\n#include \"layouts.c\"\nstatic const Layout layouts[] = {\n    /* symbol     arrange function */\n    {\"[ ]\", tile}, /* first entry is default */\n    {\"><>\", NULL}, /* no layout function means floating behavior */\n    {\"[M]\", monocle},\n    {\"HHH\", grid},\n};\n\n/* key definitions */\n#define MODKEY Mod4Mask\n#define TAGKEYS(KEY, TAG)                                                      \\\n  {MODKEY, KEY, view, {.ui = 1 << TAG}},                                       \\\n      {MODKEY | ControlMask, KEY, toggleview, {.ui = 1 << TAG}},               \\\n      {MODKEY | ShiftMask, KEY, tag, {.ui = 1 << TAG}},                        \\\n      {MODKEY | ControlMask | ShiftMask, KEY, toggletag, {.ui = 1 << TAG}},\n\n/* helper for spawning shell commands in the pre dwm-5.0 fashion */\n#define SHCMD(cmd)                                                             \\\n  {                                                                            \\\n    .v = (const char *[]) { \"/bin/sh\", \"-c\", cmd, NULL }                       \\\n  }\n\n/* commands */\n\nstatic const char *dmenucmd[] = {\"rofi\", \"-show\", \"drun\", NULL};\n// static char dmenumon[2] = \"0\";\n//[> component of dmenucmd, manipulated in spawn() <]\n// static const char *dmenucmd[] = {\n//\"dmenu_run\", \"-m\",      dmenumon, \"-fn\",    dmenufont, \"-nb\",     col_gray1,\n//\"-nf\",       col_gray3, \"-sb\",    col_cyan, \"-sf\",     col_gray4, NULL};\n// static const char *dmenucmd[] = {\"i3-dmenu-desktop\", NULL};\nstatic const char *termcmd[] = {\"st\", NULL};\nstatic const char *browsercmd[] = {\"firefox\", NULL};\n// static const char *musiccmd[] = {\"yesplaymusic\", NULL};\n// static const char *volup[] = {\"~/scripts/dwm/volup.sh\", NULL};\n// static const char *voldown[] = {\"~/scripts/dwm/voldown.sh\", NULL};\nstatic const char *screenlock[] = {\"slock\", NULL};\n// static const char *screenshotcmd[] = {\n//\"/home/xingji/Desktop/scripts/screenshot.sh\", NULL};\nstatic const char *volup[] = {\"amixer\", \"-qM\",   \"set\", \"Master\",\n                              \"2%+\",    \"umute\", NULL};\nstatic const char *voldown[] = {\"amixer\", \"-qM\",   \"set\", \"Master\",\n                                \"2%-\",    \"umute\", NULL};\nstatic const char *mute[] = {\"amixer\", \"-qM\", \"set\", \"Master\", \"toggle\", NULL};\nstatic const char *lightup[] = {\"xbacklight\", \"-inc\", \"2\", NULL};\nstatic const char *lightdown[] = {\"xbacklight\", \"-dec\", \"2\", NULL};\nstatic const char *dolphin[] = {\"dolphin\", NULL};\n\nstatic Key keys[] = {\n    /* modifier     \t        key        \tfunction        argument */\n    {MODKEY, XK_d, spawn, {.v = dmenucmd}},\n    {MODKEY, XK_Return, spawn, {.v = termcmd}},\n    {MODKEY, XK_b, spawn, {.v = browsercmd}},\n    //{MODKEY | ShiftMask, XK_m, spawn, {.v = musiccmd}},\n    //{0, XK_Print, spawn, {.v = screenshotcmd}},\n    {MODKEY | ShiftMask, XK_Up, spawn, {.v = lightup}},\n    {MODKEY | ShiftMask, XK_Down, spawn, {.v = lightdown}},\n    {MODKEY | ShiftMask, XK_Right, spawn, {.v = volup}},\n    {MODKEY | ShiftMask, XK_Left, spawn, {.v = voldown}},\n    {MODKEY | ShiftMask, XK_m, spawn, {.v = mute}},\n    {MODKEY | ShiftMask, XK_d, spawn, {.v = dolphin}},\n    {MODKEY, XK_o, togglebar, {0}},\n    {MODKEY | ShiftMask, XK_u, rotatestack, {.i = +1}},\n    {MODKEY | ShiftMask, XK_e, rotatestack, {.i = -1}},\n    {MODKEY, XK_u, focusstack, {.i = +1}},\n    {MODKEY, XK_e, focusstack, {.i = -1}},\n    {MODKEY, XK_n, incnmaster, {.i = +1}},\n    {MODKEY, XK_i, incnmaster, {.i = -1}},\n    {MODKEY | ShiftMask, XK_n, setmfact, {.f = -0.05}},\n    {MODKEY | ShiftMask, XK_i, setmfact, {.f = +0.05}},\n    {MODKEY, XK_z, hidewin, {0}},\n    {MODKEY | ShiftMask, XK_z, restorewin, {0}},\n    {MODKEY | ShiftMask, XK_Return, zoom, {0}},\n    {MODKEY, XK_Tab, view, {0}},\n    {MODKEY, XK_a, spawn, {.v = screenlock}},\n    {MODKEY | ShiftMask, XK_q, killclient, {0}},\n    {MODKEY | ControlMask, XK_q, quit, {0}},\n    {MODKEY | ShiftMask, XK_r, quit, {1}},\n    {MODKEY, XK_t, setlayout, {.v = &layouts[0]}},\n    {MODKEY, XK_f, setlayout, {.v = &layouts[1]}},\n    {MODKEY, XK_m, setlayout, {.v = &layouts[2]}},\n    {MODKEY, XK_g, setlayout, {.v = &layouts[3]}},\n    {MODKEY, XK_space, setlayout, {0}},\n    {MODKEY | ShiftMask, XK_f, fullscreen, {0}},\n    {MODKEY | ShiftMask, XK_space, togglefloating, {0}},\n    {MODKEY, XK_0, view, {.ui = ~0}},\n    {MODKEY | ShiftMask, XK_0, tag, {.ui = ~0}},\n    {MODKEY, XK_comma, focusmon, {.i = -1}},\n    {MODKEY, XK_period, focusmon, {.i = +1}},\n    {MODKEY | ShiftMask, XK_comma, tagmon, {.i = -1}},\n    {MODKEY | ShiftMask, XK_period, tagmon, {.i = +1}},\n    TAGKEYS(XK_1, 0) TAGKEYS(XK_2, 1) TAGKEYS(XK_3, 2) TAGKEYS(XK_4, 3)\n        TAGKEYS(XK_5, 4) TAGKEYS(XK_6, 5) TAGKEYS(XK_7, 6) TAGKEYS(XK_8, 7)\n            TAGKEYS(XK_9, 8){MODKEY | ControlMask, XK_c, quit, {0}},\n};\n\n/* button definitions */\n/* click can be ClkTagBar, ClkLtSymbol, ClkStatusText, ClkWinTitle,\n * ClkClientWin, or ClkRootWin */\nstatic Button buttons[] = {\n    /* click               \tevent mask      button          function\n       argument*/\n    {ClkLtSymbol, 0, Button1, setlayout, {0}},\n    {ClkLtSymbol, 0, Button3, setlayout, {.v = &layouts[2]}},\n    {ClkWinTitle, 0, Button1, togglewin, {0}},\n    {ClkWinTitle, 0, Button2, zoom, {0}},\n    {ClkStatusText, 0, Button2, spawn, {.v = termcmd}},\n    {ClkClientWin, MODKEY, Button1, movemouse, {0}},\n    {ClkClientWin, MODKEY, Button2, togglefloating, {0}},\n    {ClkClientWin, MODKEY, Button3, resizemouse, {0}},\n    {ClkTagBar, 0, Button1, view, {0}},\n    {ClkTagBar, 0, Button3, toggleview, {0}},\n    {ClkTagBar, MODKEY, Button1, tag, {0}},\n    {ClkTagBar, MODKEY, Button3, toggletag, {0}},\n};\n\n", "comment_ratio": 0.125}
{"lang": "c", "code": "#import <VideoSubscriberAccount/VideoSubscriberAccount-Structs.h>\n#import <libobjc.A.dylib/NSCopying.h>\n#import <libobjc.A.dylib/NSSecureCoding.h>\n\n@class NSString, VSOptional, NSNumber, NSArray, NSURL;\n\n@interface VSIdentityProvider : NSObject <NSCopying, NSSecureCoding> {\n\n\tNSString* _displayName;\n\tBOOL _prohibitedByStore;\n\tBOOL _developer;\n\tBOOL _isSetTopBoxSupported;\n\tVSOptional* _uniqueID;\n\tVSOptional* _providerID;\n\tVSOptional* _providerInfo;\n\tNSString* _nameForSorting;\n\tNSNumber* _rankForSorting;\n\tNSArray* _supportedTemplates;\n\tNSArray* _supportedAuthenticationSchemes;\n\tNSURL* _authenticationURL;\n\tNSURL* _appStoreRoomURL;\n\tNSArray* _appAdamIDs;\n\tNSString* _providerArtworkTemplateURL;\n\tNSString* _providerAppArtworkTemplateURL;\n\tNSNumber* _appPlacementPosition;\n\tNSString* _userToken;\n\n}\n\n@property (nonatomic,retain) VSOptional * uniqueID;                                               //@synthesize uniqueID=_uniqueID - In the implementation block\n@property (nonatomic,retain) VSOptional * providerID;                                             //@synthesize providerID=_providerID - In the implementation block\n@property (nonatomic,retain) VSOptional * providerInfo;                                           //@synthesize providerInfo=_providerInfo - In the implementation block\n@property (nonatomic,copy) NSString * nameForSorting;                                             //@synthesize nameForSorting=_nameForSorting - In the implementation block\n@property (nonatomic,copy) NSNumber * rankForSorting;                                             //@synthesize rankForSorting=_rankForSorting - In the implementation block\n@property (nonatomic,readonly) VSOptional * displayName; \n@property (nonatomic,copy) NSArray * supportedTemplates;                                          //@synthesize supportedTemplates=_supportedTemplates - In the implementation block\n@property (nonatomic,copy) NSArray * supportedAuthenticationSchemes;                              //@synthesize supportedAuthenticationSchemes=_supportedAuthenticationSchemes - In the implementation block\n@property (assign,getter=isProhibitedByStore,nonatomic) BOOL prohibitedByStore;                   //@synthesize prohibitedByStore=_prohibitedByStore - In the implementation block\n@property (nonatomic,readonly) BOOL supportsTemplatesSufficientForSomeKnownPlatform; \n@property (nonatomic,readonly) BOOL supportsTemplatesSufficientForCurrentPlatform; \n@property (assign,getter=isDeveloper,nonatomic) BOOL developer;                                   //@synthesize developer=_developer - In the implementation block\n@property (nonatomic,copy) NSURL * authenticationURL;                                             //@synthesize authenticationURL=_authenticationURL - In the implementation block\n@property (nonatomic,copy) NSURL * appStoreRoomURL;                                               //@synthesize appStoreRoomURL=_appStoreRoomURL - In the implementation block\n@property (nonatomic,copy) NSArray * appAdamIDs;                                                  //@synthesize appAdamIDs=_appAdamIDs - In the implementation block\n@property (nonatomic,copy) NSString * providerArtworkTemplateURL;                                 //@synthesize providerArtworkTemplateURL=_providerArtworkTemplateURL - In the implementation block\n@property (assign,nonatomic) BOOL isSetTopBoxSupported;                                           //@synthesize isSetTopBoxSupported=_isSetTopBoxSupported - In the implementation block\n@property (nonatomic,copy) NSString * providerAppArtworkTemplateURL;                              //@synthesize providerAppArtworkTemplateURL=_providerAppArtworkTemplateURL - In the implementation block\n@property (nonatomic,copy) NSNumber * appPlacementPosition;                                       //@synthesize appPlacementPosition=_appPlacementPosition - In the implementation block\n@property (nonatomic,copy) NSString * userToken;                                                  //@synthesize userToken=_userToken - In the implementation block\n+(BOOL)supportsSecureCoding;\n-(void)setUniqueID:(VSOptional *)arg1 ;\n-(VSOptional *)uniqueID;\n-(VSOptional *)providerID;\n-(void)setProviderID:(VSOptional *)arg1 ;\n-(NSArray *)supportedTemplates;\n-(void)setDeveloper:(BOOL)arg1 ;\n-(NSURL *)appStoreRoomURL;\n-(void)setUserToken:(NSString *)arg1 ;\n-(NSString *)userToken;\n-(void)setRankForSorting:(NSNumber *)arg1 ;\n-(void)setAppAdamIDs:(NSArray *)arg1 ;\n-(BOOL)isDeveloper;\n-(NSURL *)authenticationURL;\n-(NSNumber *)rankForSorting;\n-(void)setProviderInfo:(VSOptional *)arg1 ;\n-(void)setNameForSorting:(NSString *)arg1 ;\n-(void)setAuthenticationURL:(NSURL *)arg1 ;\n-(void)setProviderArtworkTemplateURL:(NSString *)arg1 ;\n-(void)setProviderAppArtworkTemplateURL:(NSString *)arg1 ;\n-(void)setIsSetTopBoxSupported:(BOOL)arg1 ;\n-(void)setAppPlacementPosition:(NSNumber *)arg1 ;\n-(void)setAppStoreRoomURL:(NSURL *)arg1 ;\n-(void)setSupportedTemplates:(NSArray *)arg1 ;\n-(void)setProhibitedByStore:(BOOL)arg1 ;\n-(BOOL)isProhibitedByStore;\n-(BOOL)supportsTemplatesSufficientForCurrentPlatform;\n-(BOOL)supportsTemplatesSufficientForSomeKnownPlatform;\n-(NSNumber *)appPlacementPosition;\n-(BOOL)isFullySupportedForRequestsExpectingAuthenticationSchemes:(id)arg1 ;\n-(BOOL)supportsRequestsExpectingAuthenticationSchemes:(id)arg1 ;\n-(NSString *)providerArtworkTemplateURL;\n-(NSString *)providerAppArtworkTemplateURL;\n-(BOOL)isSetTopBoxSupported;\n-(NSString *)nameForSorting;\n-(NSArray *)supportedAuthenticationSchemes;\n-(void)setSupportedAuthenticationSchemes:(NSArray *)arg1 ;\n-(id)init;\n-(BOOL)isEqual:(id)arg1 ;\n-(void)encodeWithCoder:(id)arg1 ;\n-(id)initWithCoder:(id)arg1 ;\n-(unsigned long long)hash;\n-(id)description;\n-(id)copyWithZone:(NSZone*)arg1 ;\n-(VSOptional *)displayName;\n-(VSOptional *)providerInfo;\n-(NSArray *)appAdamIDs;\n@end\n\n\n", "comment_ratio": 0.1588785046728972}
{"lang": "c", "code": "#ifndef MODULES_REMOTE_BITRATE_ESTIMATOR_TEST_PACKET_SENDER_H_\n#define MODULES_REMOTE_BITRATE_ESTIMATOR_TEST_PACKET_SENDER_H_\n\n#include <list>\n#include <limits>\n#include <memory>\n#include <set>\n#include <string>\n\n#include \"modules/include/module.h\"\n#include \"modules/remote_bitrate_estimator/test/bwe.h\"\n#include \"modules/remote_bitrate_estimator/test/bwe_test_framework.h\"\n#include \"rtc_base/constructormagic.h\"\n\nnamespace webrtc {\nnamespace testing {\nnamespace bwe {\n\nclass MetricRecorder;\n\nclass PacketSender : public PacketProcessor {\n public:\n  PacketSender(PacketProcessorListener* listener, int flow_id)\n      : PacketProcessor(listener, flow_id, kSender),\n        running_(true),\n        // For Packet::send_time_us() to be comparable with timestamps from\n        // clock_, the clock of the PacketSender and the Source must be aligned.\n        // We assume that both start at time 0.\n        clock_(0),\n        metric_recorder_(nullptr) {}\n  virtual ~PacketSender() {}\n  // Call GiveFeedback() with the returned interval in milliseconds, provided\n  // there is a new estimate available.\n  // Note that changing the feedback interval affects the timing of when the\n  // output of the estimators is sampled and therefore the baseline files may\n  // have to be regenerated.\n  virtual int GetFeedbackIntervalMs() const = 0;\n  void SetSenderTimestamps(Packets* in_out);\n\n  virtual uint32_t TargetBitrateKbps() { return 0; }\n\n  virtual void Pause();\n  virtual void Resume(int64_t paused_time_ms);\n\n  void set_metric_recorder(MetricRecorder* metric_recorder);\n  virtual void RecordBitrate();\n\n protected:\n  bool running_;  // Initialized by default as true.\n  SimulatedClock clock_;\n\n private:\n  MetricRecorder* metric_recorder_;\n};\n\nclass VideoSender : public PacketSender, public BitrateObserver {\n public:\n  VideoSender(PacketProcessorListener* listener,\n              VideoSource* source,\n              BandwidthEstimatorType estimator);\n  virtual ~VideoSender();\n\n  int GetFeedbackIntervalMs() const override;\n  void RunFor(int64_t time_ms, Packets* in_out) override;\n\n  virtual VideoSource* source() const { return source_; }\n\n  uint32_t TargetBitrateKbps() override;\n\n  // Implements BitrateObserver.\n  void OnNetworkChanged(uint32_t target_bitrate_bps,\n                        uint8_t fraction_lost,\n                        int64_t rtt) override;\n  void Pause() override;\n  void Resume(int64_t paused_time_ms) override;\n\n protected:\n  void ProcessFeedbackAndGeneratePackets(int64_t time_ms,\n                                         std::list<FeedbackPacket*>* feedbacks,\n                                         Packets* generated);\n\n  VideoSource* source_;\n  std::unique_ptr<BweSender> bwe_;\n  int64_t start_of_run_ms_;\n  std::list<Module*> modules_;\n\n private:\n  uint32_t previous_sending_bitrate_;\n  RTC_DISALLOW_COPY_AND_ASSIGN(VideoSender);\n};\n\nclass PacedVideoSender : public VideoSender, public PacedSender::PacketSender {\n public:\n  PacedVideoSender(PacketProcessorListener* listener,\n                   VideoSource* source,\n                   BandwidthEstimatorType estimator);\n  virtual ~PacedVideoSender();\n\n  void RunFor(int64_t time_ms, Packets* in_out) override;\n\n  // Implements PacedSender::Callback.\n  bool TimeToSendPacket(uint32_t ssrc,\n                        uint16_t sequence_number,\n                        int64_t capture_time_ms,\n                        bool retransmission,\n                        const PacedPacketInfo& pacing_info) override;\n  size_t TimeToSendPadding(size_t bytes,\n                           const PacedPacketInfo& pacing_info) override;\n\n  // Implements BitrateObserver.\n  void OnNetworkChanged(uint32_t target_bitrate_bps,\n                        uint8_t fraction_lost,\n                        int64_t rtt) override;\n\n  void OnNetworkChanged(uint32_t bitrate_for_encoder_bps,\n                        uint32_t bitrate_for_pacer_bps,\n                        bool in_probe_rtt,\n                        int64_t rtt,\n                        uint64_t congestion_window) override;\n  size_t pacer_queue_size_in_bytes() override {\n    return pacer_queue_size_in_bytes_;\n  }\n  void OnBytesAcked(size_t bytes) override;\n\n private:\n  int64_t TimeUntilNextProcess(const std::list<Module*>& modules);\n  void CallProcess(const std::list<Module*>& modules);\n  void QueuePackets(Packets* batch, int64_t end_of_batch_time_us);\n\n  size_t pacer_queue_size_in_bytes_ = 0;\n  std::unique_ptr<Pacer> pacer_;\n  Packets queue_;\n  Packets pacer_queue_;\n\n  RTC_DISALLOW_IMPLICIT_CONSTRUCTORS(PacedVideoSender);\n};\n\nclass TcpSender : public PacketSender {\n public:\n  TcpSender(PacketProcessorListener* listener, int flow_id, int64_t offset_ms);\n  TcpSender(PacketProcessorListener* listener,\n            int flow_id,\n            int64_t offset_ms,\n            int send_limit_bytes);\n  virtual ~TcpSender() {}\n\n  void RunFor(int64_t time_ms, Packets* in_out) override;\n  int GetFeedbackIntervalMs() const override { return 10; }\n\n  uint32_t TargetBitrateKbps() override;\n\n private:\n  struct InFlight {\n   public:\n    explicit InFlight(const MediaPacket& packet)\n        : sequence_number(packet.header().sequenceNumber),\n          time_ms(packet.send_time_ms()) {}\n\n    InFlight(uint16_t seq_num, int64_t now_ms)\n        : sequence_number(seq_num), time_ms(now_ms) {}\n\n    bool operator<(const InFlight& rhs) const {\n      return sequence_number < rhs.sequence_number;\n    }\n\n    uint16_t sequence_number;  // Sequence number of a packet in flight, or a\n                               // packet which has just been acked.\n    int64_t time_ms;  // Time of when the packet left the sender, or when the\n                      // ack was received.\n  };\n\n  void SendPackets(Packets* in_out);\n  void UpdateCongestionControl(const FeedbackPacket* fb);\n  int TriggerTimeouts();\n  void HandleLoss();\n  Packets GeneratePackets(size_t num_packets);\n  void UpdateSendBitrateEstimate(size_t num_packets);\n\n  float cwnd_;\n  int ssthresh_;\n  std::set<InFlight> in_flight_;\n  bool ack_received_;\n  uint16_t last_acked_seq_num_;\n  uint16_t next_sequence_number_;\n  int64_t offset_ms_;\n  int64_t last_reduction_time_ms_;\n  int64_t last_rtt_ms_;\n  int total_sent_bytes_;\n  int send_limit_bytes_;  // Initialized by default as kNoLimit.\n  int64_t last_generated_packets_ms_;\n  size_t num_recent_sent_packets_;\n  uint32_t bitrate_kbps_;\n};\n}  // namespace bwe\n}  // namespace testing\n}  // namespace webrtc\n#endif  // MODULES_REMOTE_BITRATE_ESTIMATOR_TEST_PACKET_SENDER_H_\n\n", "comment_ratio": 0.10096153846153846}
{"lang": "c", "code": "#pragma once\n\n#include \"Modules/Module.h\"\n#include \"Utils/UID.h\"\n\n#include <string>\n\nclass Scene;\nclass GameObject;\n\nclass ModuleScene : public Module {\npublic:\n\t// ------- Core Functions ------ //\n\tbool Init() override;\n\tbool Start() override;\n\tUpdateStatus Update() override;\n\tUpdateStatus PostUpdate() override;\n\tbool CleanUp() override;\n\tvoid ReceiveEvent(TesseractEvent& e) override;\n\n\tvoid CreateEmptyScene(); // Crates a new scene with a default game camera and directional light.\n\n\tvoid BuildPrefab(UID prefabId, GameObject* parent);\n\n\tvoid LoadScene(const char* filePath);\n\tvoid SaveScene(const char* filePath);\n\n\tvoid DestroyGameObjectDeferred(GameObject* gameObject); //Event dependant destruction, Gameobjects are destroyed upon the receival of an event, so that info is not null\n\npublic:\n\tScene* scene = nullptr;\n\n\tUID startSceneId = 0; // First scene to be loaded when in GAME configuration\n\n\t//Temporary hardcoded solution\n\tbool godModeOn = false;\n\nprivate:\n\tbool shouldLoadScene = false;\n\tstd::string sceneToLoadPath = \"\";\n\n\tbool shouldSaveScene = false;\n\tstd::string sceneToSavePath = \"\";\n\n\tbool shouldBuildPrefab = false;\n\tUID buildingPrefabId = 0;\n\tUID buildingPrefabParentId = 0;\n};\n\n", "comment_ratio": 0.10204081632653061}
{"lang": "c", "code": "// RobotBuilder Version: 2.0\n//\n// This file was generated by RobotBuilder. It contains sections of\n// code that are automatically generated and assigned by robotbuilder.\n// These sections will be updated in the future when you export to\n// C++ from RobotBuilder. Do not put any code or make any change in\n// the blocks indicating autogenerated code or it will be lost on an\n// update. Deleting the comments indicating the section will prevent\n// it from being updated in the future.\n\n\n#pragma once\n\n#include \"frc/commands/Command.h\"\n#include \"frc/commands/Subsystem.h\"\n#include \"Robot.h\"\n\n/**\n *\n *\n * @author ExampleAuthor\n */\nclass AutonomousCommand: public frc::Command {\npublic:\n    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR\nAutonomousCommand();\n\n    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR\n\tfrc::Command* autonomousMode = nullptr;\n\tvoid Initialize() override;\n\tvoid Execute() override;\n\tbool IsFinished() override;\n\tvoid End() override;\n\tvoid Interrupted() override;\n\n\tint autoMode = 0;\n\tint autoStartNum = 0;\n\tint autoFinishNum = 0;\n\n\tdouble startX = 0;\n\tdouble startY = 0;\n\nprivate:\n\t// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLES\n\n\n    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLES\n};\n\n", "comment_ratio": 0.2653061224489796}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n\nNS_ASSUME_NONNULL_BEGIN\n\n/**\n    json data type\n */\ntypedef NS_ENUM(NSInteger, RC_JSON_Type){\n    \n    /// unknown\n    RC_JSON_Type_None = 0,\n    /// json array\n    RC_JSON_Type_Array = 1,\n    /// json dictionary\n    RC_JSON_Type_Dictionary = 2,\n};\n\n/**\n    json data object\n */\n@interface RC_JSON : NSObject\n\n- (instancetype)initWithData:(nonnull id)data NS_DESIGNATED_INITIALIZER;\n\n+ (instancetype)rc_JSONWithData:(nonnull id)data;\n\n/**\n    maybe is nil when failed to convert\n */\n@property (nonatomic, readonly) id data;\n@property (nonatomic, readonly) RC_JSON_Type type;\n\n/**\n    json array data\n */\n- (NSArray *)rc_JSONArray;\n\n/**\n    json dictionary data\n */\n- (NSDictionary *)rc_JSONDictionary;\n\n@end\n\nNS_ASSUME_NONNULL_END\n\n", "comment_ratio": 0.16981132075471697}
{"lang": "c", "code": "#ifndef YB_COMMON_CONSISTENT_READ_POINT_H\n#define YB_COMMON_CONSISTENT_READ_POINT_H\n\n#include <mutex>\n#include <unordered_map>\n\n#include \"yb/common/common.pb.h\"\n#include \"yb/common/entity_ids.h\"\n#include \"yb/common/read_hybrid_time.h\"\n\n#include \"yb/gutil/thread_annotations.h\"\n\n#include \"yb/util/locks.h\"\n\nnamespace yb {\n\nYB_STRONGLY_TYPED_BOOL(HadReadTime);\n\n// ConsistentReadPoint tracks a consistent read point to read across tablets.\nclass ConsistentReadPoint {\n public:\n  // A map of tablet id to local limits.\n  typedef std::unordered_map<TabletId, HybridTime> HybridTimeMap;\n\n  explicit ConsistentReadPoint(const scoped_refptr<ClockBase>& clock);\n\n  void MoveFrom(ConsistentReadPoint* rhs);\n\n  // Set the current time as the read point.\n  void SetCurrentReadTime() EXCLUDES(mutex_);\n\n  // Set the read point to the specified read time with local limits.\n  void SetReadTime(const ReadHybridTime& read_time, HybridTimeMap&& local_limits) EXCLUDES(mutex_);\n\n  ReadHybridTime GetReadTime() const;\n\n  // Get the read time of this read point for a tablet.\n  ReadHybridTime GetReadTime(const TabletId& tablet) const EXCLUDES(mutex_);\n\n  // Notify that a tablet requires restart. This method is thread-safe.\n  void RestartRequired(const TabletId& tablet, const ReadHybridTime& restart_time) EXCLUDES(mutex_);\n\n  void UpdateLocalLimit(const TabletId& tablet, HybridTime local_limit) EXCLUDES(mutex_);\n\n  // Does the current read require restart?\n  bool IsRestartRequired() const EXCLUDES(mutex_);\n\n  // Restart read.\n  void Restart() EXCLUDES(mutex_);\n\n  // Defer read hybrid time to global limit.\n  void Defer() EXCLUDES(mutex_);\n\n  // Update the clock used by this consistent read point with the propagated time.\n  void UpdateClock(HybridTime propagated_hybrid_time) EXCLUDES(mutex_);\n\n  // Return the current time to propagate.\n  HybridTime Now() const EXCLUDES(mutex_);\n\n  // Prepare the read time and local limits in a child transaction.\n  void PrepareChildTransactionData(ChildTransactionDataPB* data) const EXCLUDES(mutex_);\n\n  // Finish a child transaction and populate the restart read times in the result.\n  void FinishChildTransactionResult(\n      HadReadTime had_read_time, ChildTransactionResultPB* result) const EXCLUDES(mutex_);\n\n  // Apply restart read times from a child transaction result. This method is thread-safe.\n  void ApplyChildTransactionResult(const ChildTransactionResultPB& result) EXCLUDES(mutex_);\n\n  // Sets in transaction limit.\n  void SetInTxnLimit(HybridTime value) EXCLUDES(mutex_);\n\n private:\n  void UpdateLimitsMapUnlocked(\n      const TabletId& tablet, const HybridTime& local_limit, HybridTimeMap* map) REQUIRES(mutex_);\n  void RestartRequiredUnlocked(const TabletId& tablet, const ReadHybridTime& restart_time)\n      REQUIRES(mutex_);\n  bool IsRestartRequiredUnlocked() const REQUIRES(mutex_);\n\n  const scoped_refptr<ClockBase> clock_;\n\n  mutable simple_spinlock mutex_;\n  ReadHybridTime read_time_ GUARDED_BY(mutex_);\n  HybridTime restart_read_ht_ GUARDED_BY(mutex_);\n\n  // Local limits for separate tablets. Does not change during lifetime of a consistent read.\n  // Times such that anything happening at that hybrid time or later is definitely after the\n  // original request arrived and therefore does not have to be shown in results.\n  HybridTimeMap local_limits_ GUARDED_BY(mutex_);\n\n  // Restarts that happen during a consistent read. Used to initialise local_limits for restarted\n  // read.\n  HybridTimeMap restarts_ GUARDED_BY(mutex_);\n};\n\n} // namespace yb\n\n#endif // YB_COMMON_CONSISTENT_READ_POINT_H\n\n", "comment_ratio": 0.30357142857142855}
{"lang": "c", "code": "#ifndef DIST_SERIAL\n#define DIST_SERIAL\n\n/*#include \"dist_moduleV2/dist_common.h\"\n#include \"dist_moduleV2/dist_out.h\"\n#include \"dist_moduleV2/dist_coords.h\"*/\n\n#include \"dist_common.h\"\n#include \"dist_out.h\"\n#include \"dist_coords.h\"\n\nnamespace dist {\n\n\t// Scalary implementation that is used in part by the SIMD code too (for corner cases)\n\ttemplate <uint D, bool SELF>\n\tinline void dist_scalar_ij(dOut<D,SELF> &out, const Coords &c1, const Coords &c2, uint i, uint j){\n\t\n\t\tfloat dx = c2.x[j]-c1.x[i];\n\t\tfloat dy = c2.y[j]-c1.y[i];\n\t\tfloat dz = c2.z[j]-c1.z[i];\n\t\tint diff = c1.filinfo[i] - c2.filinfo[j];\n\t\tdiff = abs(diff);\n//\t\tdiff = 3;\n\n\t\tfloat dist_sq = dx*dx + dy*dy + dz*dz;\n\n\t\tfor(uint d=0; d<D; ++d){\n\t\t\tfloat d_l = out.dt[2*d];\n\t\t\tfloat d_h = out.dt[2*d+1];\n\t\t\tuint &counter(out.counter[d]);\n            if(dist_sq > d_l && dist_sq<d_h && diff > SysParams::Mechanics().sameFilBindSkip){\n//\t\t\tif(dist_sq > d_l && dist_sq<d_h){\n\t\t\t\t(out.dout[2*d])[counter] = c1.indices[i];\n\t\t\t\t(out.dout[2*d+1])[counter] = c2.indices[j];\n\t\t\t\t++counter;\n\t\t\t}\n\t\t}\t\n\t}\n\n\t// The main scalar outer double loop.\n\ttemplate <uint D, bool SELF>\n\tinline void find_distances(dOut<D,SELF> &out, Coords &c, tag_simd<simd_no,float> tag){\n\t\tuint N = c.size();\n\t\tfor(uint i=0; i<N; ++i){\n\t\t\tfor(uint j=(i+1); j<N; ++j){\n\t\t\t\tdist_scalar_ij(out, c, c, i, j);\t\t\t\n\t\t\t\t// float d_l = out.dt[0];\n\t\t\t\t// float d_h = out.dt[1];\n\t\t\t\t//\n\t\t\t\t// float dx = c.x[j]-c.x[i];\n\t\t\t\t// float dy = c.y[j]-c.y[i];\n\t\t\t\t// float dz = c.z[j]-c.z[i];\n\t\t\t\t//\n\t\t\t\t// float dist_sq = dx*dx + dy*dy + dz*dz;\n\t\t\t\t//\n\t\t\t\t// if(dist_sq > d_l && dist_sq<d_h){\n\t\t\t\t// \tcout << \"dist_scalar_ij: i=\" << i << \" j=\" << j << \" d=\" << dist_sq << endl;\n\t\t\t\t// }\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// The main scalar outer double loop.\n\ttemplate <uint D, bool SELF>\n\tinline void find_distances(dOut<D,SELF> &out, Coords &c1, Coords &c2, tag_simd<simd_no,float> tag){\n\t\tuint N1 = c1.size();\n\t\tuint N2 = c2.size();\n\t\tfor(uint i=0; i<N1; ++i){\n\t\t\tfor(uint j=0; j<N2; ++j){\n\t\t\t\tdist_scalar_ij(out, c1, c2, i, j);\n\t\t\t}\n\t\t}\n\t}\n\n} // end-of-namespace dist\n\n#endif // DIST_SERIAL\n\n", "comment_ratio": 0.2261904761904762}
{"lang": "c", "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n// internal structure\nstruct MSOURCE(_s)\n{\n    // internal sources\n    QSOURCE() *     sources;        // array of sources\n    unsigned int    num_sources;    // number of sources\n    int             id_counter;     // qsource id counter\n\n    // channelizer description\n    unsigned int    M;              // channelizer size\n    unsigned int    m;              // channelizer filter semi-length\n    float           As;             // channelizer filter stop-band suppression (dB)\n    firpfbch2_crcf  ch;             // analysis channelizer object\n\n    // buffers\n    float complex * buf_freq;       // [size: M   x 1]\n    float complex * buf_time;       // [size: M/2 x 1]\n    unsigned int    read_index;     // output buffer read index\n    unsigned int    num_blocks;     // output buffer read index\n\n    // global counters\n    unsigned long long num_samples; // total number of samples generated\n};\n\n//\n// internal methods\n//\n\n// find index of qsource object by id within list, return -1 if not found\nint MSOURCE(_find)(MSOURCE() _q, int _id);\n\n// find qsource object by id within list, return NULL if not found\nQSOURCE() MSOURCE(_get_source)(MSOURCE() _q, int _id);\n\n// add source to list\nint MSOURCE(_add_source)(MSOURCE() _q,\n                         QSOURCE() _s);\n\n// generate samples internally\nint MSOURCE(_generate)(MSOURCE() _q);\n\n// create msource object\nMSOURCE() MSOURCE(_create)(unsigned int _M,\n                           unsigned int _m,\n                           float        _As)\n{\n    // validate input\n    if (_M < 2)\n        return liquid_error_config(\"msource%s_create(), number of subcarriers must be at least 2\",EXTENSION);\n    if (_M % 2)\n        return liquid_error_config(\"msource%s_create(), number of subcarriers must be even\",EXTENSION);\n    if (_m==0)\n        return liquid_error_config(\"msource%s_create(), number of subcarriers must be even\",EXTENSION);\n\n    // allocate memory for main object\n    MSOURCE() q = (MSOURCE()) malloc( sizeof(struct MSOURCE(_s)) );\n\n    //\n    q->sources     = NULL;\n    q->num_sources = 0;\n    q->id_counter  = 0;\n    q->M           = _M;\n    q->m           = _m;\n    q->As          = _As;\n    q->num_samples = 0;\n\n    q->ch = firpfbch2_crcf_create_kaiser(LIQUID_SYNTHESIZER, q->M, q->m, q->As);\n\n    q->buf_freq = (float complex*) malloc(q->M   * sizeof(float complex)); \n    q->buf_time = (float complex*) malloc(q->M/2 * sizeof(float complex)); \n\n    q->read_index = q->M/2; // indicate buffer is empty\n    q->num_blocks = 0;\n\n    // reset and return main object\n    MSOURCE(_reset)(q);\n    return q;\n}\n\n// create msource object with default parameters\nMSOURCE() MSOURCE(_create_default)(void)\n{\n    return MSOURCE(_create)(1200, 4, 60);\n}\n\n// destroy msource object, freeing all internal memory\nint MSOURCE(_destroy)(MSOURCE() _q)\n{\n    // destroy internal objects\n    unsigned int i;\n    for (i=0; i<_q->num_sources; i++)\n        QSOURCE(_destroy)(_q->sources[i]);\n\n    // free list of sources\n    free(_q->sources);\n\n    // destroy channelizer\n    firpfbch2_crcf_destroy(_q->ch);\n\n    // free buffers\n    free(_q->buf_freq);\n    free(_q->buf_time);\n\n    // free main object\n    free(_q);\n    return LIQUID_OK;\n}\n\n// reset msource internal state\nint MSOURCE(_reset)(MSOURCE() _q)\n{\n    // reset all internal objects\n    _q->read_index = _q->M/2;\n    return LIQUID_OK;\n}\n\n// print\nint MSOURCE(_print)(MSOURCE() _q)\n{\n    printf(\"msource%s, M=%u, m=%u, As=%.1f dB, %llu samples:\\n\",\n            EXTENSION, _q->M, _q->m, _q->As, _q->num_samples);\n    unsigned int i;\n    for (i=0; i<_q->num_sources; i++)\n        QSOURCE(_print)(_q->sources[i]);\n    return LIQUID_OK;\n}\n\n// add user-defined source\nint MSOURCE(_add_user)(MSOURCE()          _q,\n                       float              _fc,\n                       float              _bw,\n                       float              _gain,\n                       void *             _userdata,\n                       MSOURCE(_callback) _callback)\n{\n    QSOURCE() s = QSOURCE(_create)(_q->M, _q->m, _q->As, _fc, _bw, _gain);\n    QSOURCE(_init_user)(s, _userdata, (void*)_callback);\n    return MSOURCE(_add_source)(_q, s);\n}\n\n// add tone source\nint MSOURCE(_add_tone)(MSOURCE() _q,\n                       float     _fc,\n                       float     _bw,\n                       float     _gain)\n{\n    QSOURCE() s = QSOURCE(_create)(_q->M, _q->m, _q->As, _fc, _bw, _gain);\n    QSOURCE(_init_tone)(s);\n    return MSOURCE(_add_source)(_q, s);\n}\n\n// add chirp source\nint MSOURCE(_add_chirp)(MSOURCE() _q,\n                        float     _fc,\n                        float     _bw,\n                        float     _gain,\n                        float     _duration,\n                        int       _negate,\n                        int       _single)\n{\n    QSOURCE() s = QSOURCE(_create)(_q->M, _q->m, _q->As, _fc, _bw, _gain);\n    QSOURCE(_init_chirp)(s, _duration, _negate, _single);\n    return MSOURCE(_add_source)(_q, s);\n}\n\n// add noise source\nint MSOURCE(_add_noise)(MSOURCE() _q,\n                        float     _fc,\n                        float     _bw,\n                        float     _gain)\n{\n    QSOURCE() s = QSOURCE(_create)(_q->M, _q->m, _q->As, _fc, _bw, _gain);\n    QSOURCE(_init_noise)(s);\n    return MSOURCE(_add_source)(_q, s);\n}\n\n// add linear modem source\nint MSOURCE(_add_modem)(MSOURCE()    _q,\n                        float        _fc,\n                        float        _bw,\n                        float        _gain,\n                        int          _ms,\n                        unsigned int _m,\n                        float        _beta)\n{\n    // create object with double the bandwidth to account for 2 samples/symbol\n    QSOURCE() s = QSOURCE(_create)(_q->M, _q->m, _q->As, _fc, 2*_bw, _gain);\n    QSOURCE(_init_modem)(s, _ms, _m, _beta);\n    return MSOURCE(_add_source)(_q, s);\n}\n\n// add frequency-shift keying modem source\nint MSOURCE(_add_fsk)(MSOURCE()    _q,\n                      float        _fc,\n                      float        _bw,\n                      float        _gain,\n                      unsigned int _m,\n                      unsigned int _k)\n{\n    // create object with double the bandwidth to account for 2 samples/symbol\n    QSOURCE() s = QSOURCE(_create)(_q->M, _q->m, _q->As, _fc, 2*_bw, _gain);\n    QSOURCE(_init_fsk)(s, _m, _k);\n    return MSOURCE(_add_source)(_q, s);\n}\n\n// add GMSK modem source\nint MSOURCE(_add_gmsk)(MSOURCE()    _q,\n                       float        _fc,\n                       float        _bw,\n                       float        _gain,\n                       unsigned int _m,\n                       float        _bt)\n{\n    // create object with double the bandwidth to account for 2 samples/symbol\n    QSOURCE() s = QSOURCE(_create)(_q->M, _q->m, _q->As, _fc, 2*_bw, _gain);\n    QSOURCE(_init_gmsk)(s, _m, _bt);\n    return MSOURCE(_add_source)(_q, s);\n}\n\n// remove signal\nint MSOURCE(_remove)(MSOURCE() _q,\n                     int       _id)\n{\n    // find source object matching id\n    unsigned int i;\n    int id_found = 0;\n    for (i=0; i<_q->num_sources; i++) {\n        if (QSOURCE(_get_id)(_q->sources[i]) == _id) {\n            id_found = 1;\n            break;\n        }\n    }\n\n    // check to see if id was found\n    if (!id_found)\n        return liquid_error(LIQUID_EIRANGE,\"msource%s_remove(), signal id (%d) not found\",EXTENSION,_id);\n\n    // delete source\n    QSOURCE(_destroy)(_q->sources[i]);\n\n    //\n    _q->num_sources--;\n\n    // shift sources down\n    for (; i<_q->num_sources; i++)\n        _q->sources[i] = _q->sources[i+1];\n\n    return LIQUID_OK;\n}\n\n// enable/disable signal\nint MSOURCE(_enable)(MSOURCE() _q,\n                     int       _id)\n{\n    QSOURCE() source = MSOURCE(_get_source)(_q, _id);\n    if (source == NULL)\n        return liquid_error(LIQUID_EIRANGE,\"msource%s_enable(), could not find source with id %u\",EXTENSION,_id);\n\n    // set source gain\n    return QSOURCE(_enable)(source);\n}\n\nint MSOURCE(_disable)(MSOURCE() _q,\n                      int       _id)\n{\n    QSOURCE() source = MSOURCE(_get_source)(_q, _id);\n    if (source == NULL)\n        return liquid_error(LIQUID_EIRANGE,\"msource%s_disable(), could not find source with id %u\",EXTENSION,_id);\n\n    // set source gain\n    return QSOURCE(_disable)(source);\n}\n\n// set signal gain\n//  _q      :   msource object\n//  _id     :   source id\n//  _gain_dB:   signal gain in dB\nint MSOURCE(_set_gain)(MSOURCE() _q,\n                       int       _id,\n                       float     _gain_dB)\n{\n    QSOURCE() source = MSOURCE(_get_source)(_q, _id);\n    if (source == NULL)\n        return liquid_error(LIQUID_EIRANGE,\"msource%s_set_gain(), could not find source with id %u\",EXTENSION,_id);\n\n    // set source gain\n    return QSOURCE(_set_gain)(source, _gain_dB);\n}\n\n// set signal gain\n//  _q      :   msource object\n//  _id     :   source id\n//  _gain_dB:   signal gain in dB\nint MSOURCE(_get_gain)(MSOURCE() _q,\n                       int       _id,\n                       float *   _gain_dB)\n{\n    QSOURCE() source = MSOURCE(_get_source)(_q, _id);\n    if (source == NULL)\n        return liquid_error(LIQUID_EIRANGE,\"msource%s_get_gain(), could not find source with id %u\",EXTENSION,_id);\n\n    // set source gain\n    *_gain_dB = QSOURCE(_get_gain)(source);\n    return LIQUID_OK;\n}\n\n// Get number of samples generated by the object so far\nunsigned long long int MSOURCE(_get_num_samples)(MSOURCE() _q)\n{\n    return _q->num_samples;\n}\n\n// set carrier offset to signal\n//  _q      :   msource object\n//  _id     :   source id\n//  _fc     :   carrier offset, fc in [-0.5,0.5]\nint MSOURCE(_set_frequency)(MSOURCE() _q,\n                            int       _id,\n                            float     _dphi)\n{\n    QSOURCE() source = MSOURCE(_get_source)(_q, _id);\n    if (source == NULL)\n        return liquid_error(LIQUID_EIRANGE,\"msource%s_set_frequency(), could not find source with id %u\",EXTENSION,_id);\n\n    // set source frequency\n    return QSOURCE(_set_frequency)(source, _dphi);\n}\n\n// set carrier offset to signal\n//  _q      :   msource object\n//  _id     :   source id\n//  _fc     :   carrier offset, fc in [-0.5,0.5]\nint MSOURCE(_get_frequency)(MSOURCE() _q,\n                            int       _id,\n                            float *   _dphi)\n{\n    QSOURCE() source = MSOURCE(_get_source)(_q, _id);\n    if (source == NULL)\n        return liquid_error(LIQUID_EIRANGE,\"msource%s_get_frequency(), could not find source with id %u\",EXTENSION,_id);\n\n    // set source frequency\n    *_dphi = QSOURCE(_get_frequency)(source);\n    return LIQUID_OK;\n}\n\n// write block of samples to output buffer\n//  _q      : synchronizer object\n//  _buf    : output buffer [size: _buf_len x 1]\n//  _buf_len: output buffer size\nint MSOURCE(_write_samples)(MSOURCE()    _q,\n                             TO *         _buf,\n                             unsigned int _buf_len)\n{\n    unsigned int i;\n    for (i=0; i<_buf_len; i++) {\n        // generate more samples if needed\n        if (_q->read_index >= _q->M/2) {\n            MSOURCE(_generate)(_q);\n        }\n\n        // write output sample and update counter\n        _buf[i] = _q->buf_time[_q->read_index++];\n    }\n    return LIQUID_OK;\n}\n\n//\n// internal msource methods\n//\n\n// find qsource object by id within list, return -1 if not found\nint MSOURCE(_find)(MSOURCE() _q, int _id)\n{\n    unsigned int i;\n    for (i=0; i<_q->num_sources; i++) {\n        if (QSOURCE(_get_id)(_q->sources[i]) == _id)\n            return (int)i;\n    }\n    return -1;\n}\n\n// get source by id\nQSOURCE() MSOURCE(_get_source)(MSOURCE() _q,\n                               int       _id)\n{\n    int index = MSOURCE(_find)(_q, _id);\n    if (index < 0)\n        return liquid_error_config(\"msource%s_get_source(), could not find source with id %u\",EXTENSION,_id);\n    return _q->sources[index];\n}\n\n// add source to list\nint MSOURCE(_add_source)(MSOURCE() _q,\n                         QSOURCE() _s)\n{\n    if (_s == NULL)\n        return -1;\n\n    // reallocate\n    if (_q->num_sources == 0) {\n        _q->sources = (QSOURCE()*) malloc(sizeof(QSOURCE()));\n    } else {\n        _q->sources = (QSOURCE()*) realloc(_q->sources,\n                                           (_q->num_sources+1)*sizeof(QSOURCE()));\n    }\n\n    // append new object to end of list\n    _q->sources[_q->num_sources] = _s;\n    _q->num_sources++;\n\n    // set id and increment internal counter\n    int id = _q->id_counter;\n    QSOURCE(_set_id)(_s, id);\n    _q->id_counter++;\n\n    // return id to user\n    return id;\n}\n\n// generate samples internally\nint MSOURCE(_generate)(MSOURCE() _q)\n{\n    // clear buffer\n    memset(_q->buf_freq, 0, _q->M*sizeof(float complex));\n\n    // add sources into main frequency buffer\n    unsigned int i;\n    for (i=0; i<_q->num_sources; i++)\n        QSOURCE(_generate_into)(_q->sources[i], _q->buf_freq);\n\n    // run synthesis channelizer\n    firpfbch2_crcf_execute(_q->ch, _q->buf_freq, _q->buf_time);\n\n    // update state\n    _q->read_index = 0;\n    _q->num_blocks++;\n    _q->num_samples += _q->M / 2;\n    return LIQUID_OK;\n}\n\n\n", "comment_ratio": 0.22033898305084745}
{"lang": "c", "code": "#import \"BugsnagCrashReport.h\"\n#import <Foundation/Foundation.h>\n\ntypedef NS_ENUM(NSUInteger, SeverityReasonType) {\n    UnhandledException,\n    Signal,\n    HandledError,\n    HandledException,\n    UserSpecifiedSeverity,\n    UserCallbackSetSeverity,\n    PromiseRejection,\n    LogMessage\n};\n\n@interface BugsnagHandledState : NSObject\n\n@property(nonatomic, readonly) BOOL unhandled;\n@property(nonatomic, readonly) SeverityReasonType severityReasonType;\n@property(nonatomic, readonly) BSGSeverity originalSeverity;\n@property(nonatomic) BSGSeverity currentSeverity;\n@property(nonatomic, readonly) SeverityReasonType calculateSeverityReasonType;\n@property(nonatomic, readonly) NSString *attrValue;\n@property(nonatomic, readonly) NSString *attrKey;\n\n+ (NSString *)stringFromSeverityReason:(SeverityReasonType)severityReason;\n+ (SeverityReasonType)severityReasonFromString:(NSString *)string;\n\n+ (instancetype)handledStateWithSeverityReason:\n    (SeverityReasonType)severityReason;\n\n+ (instancetype)handledStateWithSeverityReason:\n                    (SeverityReasonType)severityReason\n                                      severity:(BSGSeverity)severity\n                                     attrValue:(NSString *)attrValue;\n\n- (NSDictionary *)toJson;\n\n- (instancetype)initWithDictionary:(NSDictionary *)dict;\n\n@end\n\n", "comment_ratio": 0.14285714285714285}
{"lang": "c", "code": "#ifndef CHROME_BROWSER_NOTIFICATIONS_NOTIFICATION_DELEGATE_H_\n#define CHROME_BROWSER_NOTIFICATIONS_NOTIFICATION_DELEGATE_H_\n#pragma once\n\n#include <string>\n\n#include \"base/memory/ref_counted.h\"\n\n// Delegate for a notification. This class has two role, to implement\n// callback methods for notification, and provides an identify of\n// the associated notification.\nclass NotificationDelegate\n    : public base::RefCountedThreadSafe<NotificationDelegate> {\n public:\n  // To be called when the desktop notification is actually shown.\n  virtual void Display() = 0;\n\n  // To be called when the desktop notification cannot be shown due to an\n  // error.\n  virtual void Error() = 0;\n\n  // To be called when the desktop notification is closed.  If closed by a\n  // user explicitly (as opposed to timeout/script), |by_user| should be true.\n  virtual void Close(bool by_user) = 0;\n\n  // To be called when a desktop notification is clicked.\n  virtual void Click() = 0;\n\n  // Returns unique id of the notification.\n  virtual std::string id() const = 0;\n\n protected:\n  virtual ~NotificationDelegate() {}\n\n private:\n  friend class base::RefCountedThreadSafe<NotificationDelegate>;\n};\n\n#endif  // CHROME_BROWSER_NOTIFICATIONS_NOTIFICATION_DELEGATE_H_\n\n", "comment_ratio": 0.3181818181818182}
{"lang": "c", "code": "#include<stdio.h>\nint main()\n{\n    int n,k;\n    printf(\"enter size of the array: \");\n    scanf(\"%d\",&n);\n    printf(\"enter key: \");  // the element to be found\n    scanf(\"%d\",&k);\n    int arr[n];\n    printf(\"enter the elements in the array\\n\");\n    for(int i=0;i<n;i++)\n    {\n        scanf(\"%d\",&arr[i]);\n    }\n    int found = 0;\n    for(int i=0;i<n;i++)\n    {\n        if(arr[i]==k)\n        {\n            printf(\"element found at %d position\",i+1);\n            found = 1;   //if element is found in the array\n            break;\n        }\n    }\n    if(found == 0)\n    {\n        printf(\"Element not found in array\\n\");\n    }\n    \nreturn 0;\n}\n\n// Talking about its time complexity\n//Best Case - O(1)\n//Average Case - O(n/2)\n//Worst Case - O(n)\n\n", "comment_ratio": 0.16216216216216217}
{"lang": "c", "code": "#ifndef CONTENT_COMMON_ZYGOTE_ZYGOTE_COMMUNICATION_LINUX_H_\n#define CONTENT_COMMON_ZYGOTE_ZYGOTE_COMMUNICATION_LINUX_H_\n\n#include <memory>\n#include <set>\n#include <string>\n#include <vector>\n\n#include <sys/types.h>\n\n#include \"base/callback.h\"\n#include \"base/files/scoped_file.h\"\n#include \"base/process/kill.h\"\n#include \"base/process/launch.h\"\n#include \"base/process/process_handle.h\"\n#include \"base/synchronization/lock.h\"\n#include \"content/common/content_export.h\"\n\nnamespace base {\nclass Pickle;\n}  // namespace base\n\nnamespace content {\n\n// Handles interprocess communication with the Linux zygote process. The zygote\n// does not use standard Chrome IPC or mojo, see:\n// https://chromium.googlesource.com/chromium/src/+/main/docs/linux/sandbox_ipc.md\nclass CONTENT_EXPORT ZygoteCommunication {\n public:\n  enum class ZygoteType { kSandboxed, kUnsandboxed };\n  explicit ZygoteCommunication(ZygoteType type);\n  ~ZygoteCommunication();\n\n  void Init(\n      base::OnceCallback<pid_t(base::CommandLine*, base::ScopedFD*)> launcher);\n\n  // Tries to start a process of type indicated by process_type.\n  // Returns its pid on success, otherwise base::kNullProcessHandle;\n  pid_t ForkRequest(const std::vector<std::string>& command_line,\n                    const base::FileHandleMappingVector& mapping,\n                    const std::string& process_type);\n\n  void EnsureProcessTerminated(pid_t process);\n\n  // Should be called every time a Zygote child died.\n  void ZygoteChildDied(pid_t process);\n\n  // Get the termination status (and, optionally, the exit code) of\n  // the process. |exit_code| is set to the exit code of the child\n  // process. (|exit_code| may be NULL.)\n  // Unfortunately the Zygote can not accurately figure out if a process\n  // is already dead without waiting synchronously for it.\n  // |known_dead| should be set to true when we already know that the process\n  // is dead. When |known_dead| is false, processes could be seen as\n  // still running, even when they're not. When |known_dead| is true, the\n  // process will be SIGKILL-ed first (which should have no effect if it was\n  // really dead). This is to prevent a waiting waitpid() from blocking in\n  // a single-threaded Zygote. See https://crbug.com/157458.\n  base::TerminationStatus GetTerminationStatus(base::ProcessHandle handle,\n                                               bool known_dead,\n                                               int* exit_code);\n\n  // Returns the sandbox status of this zygote.\n  int GetSandboxStatus();\n\n private:\n  // Should be called every time a Zygote child is born.\n  void ZygoteChildBorn(pid_t process);\n\n  // Read the reply from the zygote.\n  ssize_t ReadReply(void* buf, size_t buf_len);\n\n  // Sends |data| to the zygote via |control_fd_|.  If |fds| is non-NULL, the\n  // included file descriptors will also be passed.  The caller is responsible\n  // for acquiring |control_lock_|.\n  bool SendMessage(const base::Pickle& data, const std::vector<int>* fds);\n\n  // Get the sandbox status from the zygote.\n  ssize_t ReadSandboxStatus();\n\n  // Indicates whether the Zygote starts unsandboxed or not.\n  const ZygoteType type_;\n\n  base::ScopedFD control_fd_;  // the socket to the zygote.\n  // A lock protecting all communication with the zygote. This lock must be\n  // acquired before sending a command and released after the result has been\n  // received.\n  base::Lock control_lock_;\n  // The pid of the zygote.\n  pid_t pid_;\n  // The list of running zygote children.\n  std::set<pid_t> list_of_running_zygote_children_;\n  // The lock to guard the list of running zygote children.\n  base::Lock child_tracking_lock_;\n  int sandbox_status_;\n  bool have_read_sandbox_status_word_;\n  // Set to true when the zygote is initialized successfully.\n  bool init_;\n};\n\n}  // namespace content\n\n#endif  // CONTENT_COMMON_ZYGOTE_ZYGOTE_COMMUNICATION_LINUX_H_\n\n", "comment_ratio": 0.3611111111111111}
{"lang": "c", "code": "#ifndef ACADOS_OCP_NLP_OCP_NLP_SQP_H_\n#define ACADOS_OCP_NLP_OCP_NLP_SQP_H_\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// acados\n#include \"acados/ocp_nlp/ocp_nlp_common.h\"\n#include \"acados/utils/types.h\"\n\n\n\n/************************************************\n * options\n ************************************************/\n\ntypedef struct\n{\n    ocp_nlp_opts *nlp_opts;\n    double tol_stat;     // exit tolerance on stationarity condition\n    double tol_eq;       // exit tolerance on equality constraints\n    double tol_ineq;     // exit tolerance on inequality constraints\n    double tol_comp;     // exit tolerance on complementarity condition\n    int max_iter;\n    int ext_qp_res;      // compute external QP residuals (i.e. at SQP level) at each SQP iteration (for debugging)\n    int qp_warm_start;   // qp_warm_start in all but the first sqp iterations\n    bool warm_start_first_qp; // to set qp_warm_start in first iteration\n    int rti_phase;       // only phase 0 at the moment \n    int print_level;     // verbosity\n    int initialize_t_slacks;  // 0-false or 1-true\n\n} ocp_nlp_sqp_opts;\n\n//\nacados_size_t ocp_nlp_sqp_opts_calculate_size(void *config, void *dims);\n//\nvoid *ocp_nlp_sqp_opts_assign(void *config, void *dims, void *raw_memory);\n//\nvoid ocp_nlp_sqp_opts_initialize_default(void *config, void *dims, void *opts);\n//\nvoid ocp_nlp_sqp_opts_update(void *config, void *dims, void *opts);\n//\nvoid ocp_nlp_sqp_opts_set(void *config_, void *opts_, const char *field, void* value);\n//\nvoid ocp_nlp_sqp_opts_set_at_stage(void *config_, void *opts_, size_t stage, const char *field, void* value);\n\n\n\n/************************************************\n * memory\n ************************************************/\n\ntypedef struct\n{\n    // nlp memory\n    ocp_nlp_memory *nlp_mem;\n\n    double time_qp_sol;\n    double time_qp_solver_call;\n    double time_qp_xcond;\n    double time_lin;\n    double time_reg;\n    double time_tot;\n    double time_glob;\n    double time_sim;\n    double time_sim_la;\n    double time_sim_ad;\n\n    // statistics\n    double *stat;\n    int stat_m;\n    int stat_n;\n\n    int status;\n    int sqp_iter;\n\n} ocp_nlp_sqp_memory;\n\n//\nacados_size_t ocp_nlp_sqp_memory_calculate_size(void *config, void *dims, void *opts_);\n//\nvoid *ocp_nlp_sqp_memory_assign(void *config, void *dims, void *opts_, void *raw_memory);\n\n\n\n/************************************************\n * workspace\n ************************************************/\n\ntypedef struct\n{\n    ocp_nlp_workspace *nlp_work;\n\n    // temp QP in & out (to be used as workspace in param sens)\n    ocp_qp_in *tmp_qp_in;\n    ocp_qp_out *tmp_qp_out;\n\n    // qp residuals\n    ocp_qp_res *qp_res;\n    ocp_qp_res_ws *qp_res_ws;\n\n} ocp_nlp_sqp_workspace;\n\n//\nacados_size_t ocp_nlp_sqp_workspace_calculate_size(void *config, void *dims, void *opts_);\n\n\n\n/************************************************\n * functions\n ************************************************/\n\n//\nint ocp_nlp_sqp(void *config, void *dims, void *nlp_in, void *nlp_out,\n                void *args, void *mem, void *work_);\n//\nvoid ocp_nlp_sqp_config_initialize_default(void *config_);\n//\nint ocp_nlp_sqp_precompute(void *config_, void *dims_, void *nlp_in_, void *nlp_out_,\n                void *opts_, void *mem_, void *work_);\n\n#ifdef __cplusplus\n} /* extern \"C\" */\n#endif\n\n#endif  // ACADOS_OCP_NLP_OCP_NLP_SQP_H_\n/// @}\n/// @}\n/// @}\n\n", "comment_ratio": 0.21511627906976744}
{"lang": "c", "code": "#if 0\n#elif defined(__x86_64__) && __x86_64__\n// Generated by Apple Swift version 5.1.3 effective-4.2 (swiftlang-1100.0.282.1 clang-1100.0.33.15)\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wgcc-compat\"\n\n#if !defined(__has_include)\n# define __has_include(x) 0\n#endif\n#if !defined(__has_attribute)\n# define __has_attribute(x) 0\n#endif\n#if !defined(__has_feature)\n# define __has_feature(x) 0\n#endif\n#if !defined(__has_warning)\n# define __has_warning(x) 0\n#endif\n\n#if __has_include(<swift/objc-prologue.h>)\n# include <swift/objc-prologue.h>\n#endif\n\n#pragma clang diagnostic ignored \"-Wauto-import\"\n#include <Foundation/Foundation.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <stdbool.h>\n\n#if !defined(SWIFT_TYPEDEFS)\n# define SWIFT_TYPEDEFS 1\n# if __has_include(<uchar.h>)\n#  include <uchar.h>\n# elif !defined(__cplusplus)\ntypedef uint_least16_t char16_t;\ntypedef uint_least32_t char32_t;\n# endif\ntypedef float swift_float2  __attribute__((__ext_vector_type__(2)));\ntypedef float swift_float3  __attribute__((__ext_vector_type__(3)));\ntypedef float swift_float4  __attribute__((__ext_vector_type__(4)));\ntypedef double swift_double2  __attribute__((__ext_vector_type__(2)));\ntypedef double swift_double3  __attribute__((__ext_vector_type__(3)));\ntypedef double swift_double4  __attribute__((__ext_vector_type__(4)));\ntypedef int swift_int2  __attribute__((__ext_vector_type__(2)));\ntypedef int swift_int3  __attribute__((__ext_vector_type__(3)));\ntypedef int swift_int4  __attribute__((__ext_vector_type__(4)));\ntypedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));\ntypedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));\ntypedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));\n#endif\n\n#if !defined(SWIFT_PASTE)\n# define SWIFT_PASTE_HELPER(x, y) x##y\n# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)\n#endif\n#if !defined(SWIFT_METATYPE)\n# define SWIFT_METATYPE(X) Class\n#endif\n#if !defined(SWIFT_CLASS_PROPERTY)\n# if __has_feature(objc_class_property)\n#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__\n# else\n#  define SWIFT_CLASS_PROPERTY(...)\n# endif\n#endif\n\n#if __has_attribute(objc_runtime_name)\n# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))\n#else\n# define SWIFT_RUNTIME_NAME(X)\n#endif\n#if __has_attribute(swift_name)\n# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))\n#else\n# define SWIFT_COMPILE_NAME(X)\n#endif\n#if __has_attribute(objc_method_family)\n# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))\n#else\n# define SWIFT_METHOD_FAMILY(X)\n#endif\n#if __has_attribute(noescape)\n# define SWIFT_NOESCAPE __attribute__((noescape))\n#else\n# define SWIFT_NOESCAPE\n#endif\n#if __has_attribute(warn_unused_result)\n# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))\n#else\n# define SWIFT_WARN_UNUSED_RESULT\n#endif\n#if __has_attribute(noreturn)\n# define SWIFT_NORETURN __attribute__((noreturn))\n#else\n# define SWIFT_NORETURN\n#endif\n#if !defined(SWIFT_CLASS_EXTRA)\n# define SWIFT_CLASS_EXTRA\n#endif\n#if !defined(SWIFT_PROTOCOL_EXTRA)\n# define SWIFT_PROTOCOL_EXTRA\n#endif\n#if !defined(SWIFT_ENUM_EXTRA)\n# define SWIFT_ENUM_EXTRA\n#endif\n#if !defined(SWIFT_CLASS)\n# if __has_attribute(objc_subclassing_restricted)\n#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA\n#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA\n# else\n#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA\n#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA\n# endif\n#endif\n#if !defined(SWIFT_RESILIENT_CLASS)\n# if __has_attribute(objc_class_stub)\n#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))\n#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)\n# else\n#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)\n#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)\n# endif\n#endif\n\n#if !defined(SWIFT_PROTOCOL)\n# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA\n# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA\n#endif\n\n#if !defined(SWIFT_EXTENSION)\n# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)\n#endif\n\n#if !defined(OBJC_DESIGNATED_INITIALIZER)\n# if __has_attribute(objc_designated_initializer)\n#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))\n# else\n#  define OBJC_DESIGNATED_INITIALIZER\n# endif\n#endif\n#if !defined(SWIFT_ENUM_ATTR)\n# if defined(__has_attribute) && __has_attribute(enum_extensibility)\n#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))\n# else\n#  define SWIFT_ENUM_ATTR(_extensibility)\n# endif\n#endif\n#if !defined(SWIFT_ENUM)\n# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type\n# if __has_feature(generalized_swift_name)\n#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type\n# else\n#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)\n# endif\n#endif\n#if !defined(SWIFT_UNAVAILABLE)\n# define SWIFT_UNAVAILABLE __attribute__((unavailable))\n#endif\n#if !defined(SWIFT_UNAVAILABLE_MSG)\n# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))\n#endif\n#if !defined(SWIFT_AVAILABILITY)\n# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))\n#endif\n#if !defined(SWIFT_WEAK_IMPORT)\n# define SWIFT_WEAK_IMPORT __attribute__((weak_import))\n#endif\n#if !defined(SWIFT_DEPRECATED)\n# define SWIFT_DEPRECATED __attribute__((deprecated))\n#endif\n#if !defined(SWIFT_DEPRECATED_MSG)\n# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))\n#endif\n#if __has_feature(attribute_diagnose_if_objc)\n# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, \"warning\")))\n#else\n# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)\n#endif\n#if !defined(IBSegueAction)\n# define IBSegueAction\n#endif\n#if __has_feature(modules)\n#if __has_warning(\"-Watimport-in-framework-header\")\n#pragma clang diagnostic ignored \"-Watimport-in-framework-header\"\n#endif\n@import AVFoundation;\n@import CoreGraphics;\n@import Dispatch;\n@import Foundation;\n@import ObjectiveC;\n@import UIKit;\n#endif\n\n#pragma clang diagnostic ignored \"-Wproperty-attribute-mismatch\"\n#pragma clang diagnostic ignored \"-Wduplicate-method-arg\"\n#if __has_warning(\"-Wpragma-clang-attribute\")\n# pragma clang diagnostic ignored \"-Wpragma-clang-attribute\"\n#endif\n#pragma clang diagnostic ignored \"-Wunknown-pragmas\"\n#pragma clang diagnostic ignored \"-Wnullability\"\n\n#if __has_attribute(external_source_symbol)\n# pragma push_macro(\"any\")\n# undef any\n# pragma clang attribute push(__attribute__((external_source_symbol(language=\"Swift\", defined_in=\"SwiftyCam\",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))\n# pragma pop_macro(\"any\")\n#endif\n\n@class CMMotionManager;\n\nSWIFT_CLASS(\"_TtC9SwiftyCam11Orientation\")\n@interface Orientation : NSObject\n@property (nonatomic, readonly, strong) CMMotionManager * _Nonnull coreMotionManager;\n- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;\n@end\n\n@class NSCoder;\n@class AVCaptureVideoPreviewLayer;\n@class AVCaptureSession;\n\nSWIFT_CLASS(\"_TtC9SwiftyCam11PreviewView\")\n@interface PreviewView : UIView\n- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;\n@property (nonatomic, readonly, strong) AVCaptureVideoPreviewLayer * _Nonnull videoPreviewLayer;\n@property (nonatomic, strong) AVCaptureSession * _Nullable session;\nSWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) Class _Nonnull layerClass;)\n+ (Class _Nonnull)layerClass SWIFT_WARN_UNUSED_RESULT;\n- (nonnull instancetype)initWithFrame:(CGRect)frame SWIFT_UNAVAILABLE;\n@end\n\n@protocol SwiftyCamButtonDelegate;\n\n/// UIButton Subclass for Capturing Photo and Video with SwiftyCamViewController\nSWIFT_CLASS(\"_TtC9SwiftyCam15SwiftyCamButton\")\n@interface SwiftyCamButton : UIButton\n/// Delegate variable\n@property (nonatomic, weak) id <SwiftyCamButtonDelegate> _Nullable delegate;\n@property (nonatomic) BOOL buttonEnabled;\n/// Initialization Declaration\n- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;\n/// Initialization Declaration\n- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;\n@end\n\n\n/// Delegate for SwiftyCamButton\nSWIFT_PROTOCOL(\"_TtP9SwiftyCam23SwiftyCamButtonDelegate_\")\n@protocol SwiftyCamButtonDelegate\n/// Called when UITapGestureRecognizer begins\n- (void)buttonWasTapped;\n/// Called When UILongPressGestureRecognizer enters UIGestureRecognizerState.began\n- (void)buttonDidBeginLongPress;\n/// Called When UILongPressGestureRecognizer enters UIGestureRecognizerState.end\n- (void)buttonDidEndLongPress;\n/// Called when the maximum duration is reached\n- (void)longPressDidReachMaximumDuration;\n/// Sets the maximum duration of the video recording\n- (double)setMaxiumVideoDuration SWIFT_WARN_UNUSED_RESULT;\n@end\n\n/// A function to specifty the Preview Layer\u2019s videoGravity. Indicates how the video is displayed within a player layer\u2019s bounds rect.\ntypedef SWIFT_ENUM(NSInteger, SwiftyCamVideoGravity, closed) {\n/// <ul>\n///   <li>\n///     Specifies that the video should be stretched to fill the layer\u2019s bounds\n///   </li>\n///   <li>\n///     Corrsponds to <code>AVLayerVideoGravityResize</code>\n///   </li>\n/// </ul>\n  SwiftyCamVideoGravityResize = 0,\n/// <ul>\n///   <li>\n///     Specifies that the player should preserve the video\u2019s aspect ratio and fit the video within the layer\u2019s bounds.\n///   </li>\n///   <li>\n///     Corresponds to <code>AVLayerVideoGravityResizeAspect</code>\n///   </li>\n/// </ul>\n  SwiftyCamVideoGravityResizeAspect = 1,\n/// <ul>\n///   <li>\n///     Specifies that the player should preserve the video\u2019s aspect ratio and fill the layer\u2019s bounds.\n///   </li>\n///   <li>\n///     Correponds to <code>AVLayerVideoGravityResizeAspectFill</code>\n///   </li>\n/// </ul>\n  SwiftyCamVideoGravityResizeAspectFill = 2,\n};\n\n@protocol SwiftyCamViewControllerDelegate;\nenum VideoQuality : NSInteger;\nenum CameraSelection : NSInteger;\n@class UIPinchGestureRecognizer;\n@class UIPanGestureRecognizer;\nenum SessionSetupResult : NSInteger;\n@class AVCaptureDeviceInput;\n@class AVCaptureMovieFileOutput;\n@class AVCaptureStillImageOutput;\n@class AVCaptureDevice;\n@class UIImage;\n@class NSBundle;\n\n/// A UIViewController Camera View Subclass\nSWIFT_CLASS(\"_TtC9SwiftyCam23SwiftyCamViewController\")\n@interface SwiftyCamViewController : UIViewController\n/// Public Camera Delegate for the Custom View Controller Subclass\n@property (nonatomic, weak) id <SwiftyCamViewControllerDelegate> _Nullable cameraDelegate;\n/// Maxiumum video duration if SwiftyCamButton is used\n@property (nonatomic) double maximumVideoDuration;\n/// Video capture quality\n@property (nonatomic) enum VideoQuality videoQuality;\n/// Disable audio\n@property (nonatomic) BOOL disableAudio;\n/// Sets whether flash is enabled for photo and video capture\n@property (nonatomic) BOOL flashEnabled;\n/// Sets whether Pinch to Zoom is enabled for the capture session\n@property (nonatomic) BOOL pinchToZoom;\n/// Sets the maximum zoom scale allowed during gestures gesture\n@property (nonatomic) CGFloat maxZoomScale;\n/// Sets whether Tap to Focus and Tap to Adjust Exposure is enabled for the capture session\n@property (nonatomic) BOOL tapToFocus;\n/// Sets whether the capture session should adjust to low light conditions automatically\n/// Only supported on iPhone 5 and 5C\n@property (nonatomic) BOOL lowLightBoost;\n/// Set whether SwiftyCam should allow background audio from other applications\n@property (nonatomic) BOOL allowBackgroundAudio;\n/// Sets whether a double tap to switch cameras is supported\n@property (nonatomic) BOOL doubleTapCameraSwitch;\n/// Sets whether swipe vertically to zoom is supported\n@property (nonatomic) BOOL swipeToZoom;\n/// Sets whether swipe vertically gestures should be inverted\n@property (nonatomic) BOOL swipeToZoomInverted;\n/// Set default launch camera\n@property (nonatomic) enum CameraSelection defaultCamera;\n/// Sets wether the taken photo or video should be oriented according to the device orientation\n@property (nonatomic) BOOL shouldUseDeviceOrientation;\n/// Sets whether or not View Controller supports auto rotation\n@property (nonatomic) BOOL allowAutoRotate;\n/// Specifies the <a href=\"https://developer.apple.com/reference/avfoundation/avcapturevideopreviewlayer/1386708-videogravity\">videoGravity</a> for the preview layer.\n@property (nonatomic) enum SwiftyCamVideoGravity videoGravity;\n/// Sets whether or not video recordings will record audio\n/// Setting to true will prompt user for access to microphone on View Controller launch.\n@property (nonatomic) BOOL audioEnabled;\n/// Sets whether or not app should display prompt to app settings if audio/video permission is denied\n/// If set to false, delegate function will be called to handle exception\n@property (nonatomic) BOOL shouldPrompToAppSettings;\n/// Video will be recorded to this folder\n@property (nonatomic, copy) NSString * _Nonnull outputFolder;\n/// Public access to Pinch Gesture\n@property (nonatomic, readonly, strong) UIPinchGestureRecognizer * _Null_unspecified pinchGesture;\n/// Public access to Pan Gesture\n@property (nonatomic, readonly, strong) UIPanGestureRecognizer * _Null_unspecified panGesture;\n/// Returns true if video is currently being recorded\n@property (nonatomic, readonly) BOOL isVideoRecording;\n/// Returns true if the capture session is currently running\n@property (nonatomic, readonly) BOOL isSessionRunning;\n/// Returns the CameraSelection corresponding to the currently utilized camera\n@property (nonatomic, readonly) enum CameraSelection currentCamera;\n/// Current Capture Session\n@property (nonatomic, readonly, strong) AVCaptureSession * _Nonnull session;\n/// Serial queue used for setting up session\n@property (nonatomic, readonly, strong) dispatch_queue_t _Nonnull sessionQueue;\n/// Variable for storing current zoom scale\n@property (nonatomic) CGFloat zoomScale;\n/// Variable for storing initial zoom scale before Pinch to Zoom begins\n@property (nonatomic) CGFloat beginZoomScale;\n/// Returns true if the torch (flash) is currently enabled\n@property (nonatomic) BOOL isCameraTorchOn;\n/// Variable to store result of capture session setup\n@property (nonatomic) enum SessionSetupResult setupResult;\n/// Video Input variable\n@property (nonatomic, strong) AVCaptureDeviceInput * _Null_unspecified videoDeviceInput;\n/// Movie File Output variable\n@property (nonatomic, strong) AVCaptureMovieFileOutput * _Nullable movieFileOutput;\n/// Photo File Output variable\n@property (nonatomic, strong) AVCaptureStillImageOutput * _Nullable photoFileOutput;\n/// Video Device variable\n@property (nonatomic, strong) AVCaptureDevice * _Nullable videoDevice;\n/// PreviewView for the capture session\n@property (nonatomic, strong) PreviewView * _Null_unspecified previewLayer;\n/// UIView for front facing flash\n@property (nonatomic, strong) UIView * _Nullable flashView;\n/// Pan Translation\n@property (nonatomic) CGFloat previousPanTranslation;\n/// Last changed orientation\n@property (nonatomic, strong) Orientation * _Nonnull orientation;\n/// Boolean to store when View Controller is notified session is running\n@property (nonatomic) BOOL sessionRunning;\n/// Disable view autorotation for forced portrait recorindg\n@property (nonatomic, readonly) BOOL shouldAutorotate;\n@property (nonatomic) AVVideoCodecType _Nullable videoCodecType;\n/// ViewDidLoad Implementation\n- (void)viewDidLoad;\n- (void)viewDidLayoutSubviews;\n/// ViewWillAppear(_ animated:) Implementation\n- (void)viewWillAppear:(BOOL)animated;\n/// ViewDidAppear(_ animated:) Implementation\n- (void)viewDidAppear:(BOOL)animated;\n/// ViewDidDisappear(_ animated:) Implementation\n- (void)viewDidDisappear:(BOOL)animated;\n/// Capture photo from current session\n/// UIImage will be returned with the SwiftyCamViewControllerDelegate function SwiftyCamDidTakePhoto(photo:)\n- (void)takePhoto;\n/// Begin recording video of current session\n/// SwiftyCamViewControllerDelegate function SwiftyCamDidBeginRecordingVideo() will be called\n- (void)startVideoRecording;\n/// Stop video recording video of current session\n/// SwiftyCamViewControllerDelegate function SwiftyCamDidFinishRecordingVideo() will be called\n/// When video has finished processing, the URL to the video location will be returned by SwiftyCamDidFinishProcessingVideoAt(url:)\n- (void)stopVideoRecording;\n/// Switch between front and rear camera\n/// SwiftyCamViewControllerDelegate function SwiftyCamDidSwitchCameras(camera:  will be return the current camera selection\n- (void)switchCamera;\n/// Returns a UIImage from Image Data.\n/// \\param imageData Image Data returned from capturing photo from the capture session.\n///\n///\n/// returns:\n/// UIImage from the image data, adjusted for proper orientation.\n- (UIImage * _Nonnull)processPhoto:(NSData * _Nonnull)imageData SWIFT_WARN_UNUSED_RESULT;\n- (void)capturePhotoAsyncronouslyWithCompletionHandler:(void (^ _Nonnull)(BOOL))completionHandler;\n/// Handle Denied App Privacy Settings\n- (void)promptToAppSettings;\n/// Returns an AVCapturePreset from VideoQuality Enumeration\n/// \\param quality ViewQuality enum\n///\n///\n/// returns:\n/// String representing a AVCapturePreset\n- (NSString * _Nonnull)videoInputPresetFromVideoQualityWithQuality:(enum VideoQuality)quality SWIFT_WARN_UNUSED_RESULT;\n/// Get Devices\n+ (AVCaptureDevice * _Nullable)deviceWithMediaType:(NSString * _Nonnull)mediaType preferringPosition:(enum AVCaptureDevicePosition)position SWIFT_WARN_UNUSED_RESULT;\n/// Enable or disable flash for photo\n- (void)changeFlashSettingsWithDevice:(AVCaptureDevice * _Nonnull)device mode:(enum AVCaptureFlashMode)mode;\n/// Enable flash\n- (void)enableFlash;\n/// Disable flash\n- (void)disableFlash;\n/// Toggles between enabling and disabling flash\n- (void)toggleFlash;\n/// Sets whether SwiftyCam should enable background audio from other applications or sources\n- (void)setBackgroundAudioPreference;\n- (nonnull instancetype)initWithNibName:(NSString * _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil OBJC_DESIGNATED_INITIALIZER;\n- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;\n@end\n\n/// Enumeration for Camera Selection\ntypedef SWIFT_ENUM(NSInteger, CameraSelection, closed) {\n/// Camera on the back of the device\n  CameraSelectionRear = 0,\n/// Camera on the front of the device\n  CameraSelectionFront = 1,\n};\n\n/// Enumeration for video quality of the capture session. Corresponds to a AVCaptureSessionPreset\ntypedef SWIFT_ENUM(NSInteger, VideoQuality, closed) {\n/// AVCaptureSessionPresetHigh\n  VideoQualityHigh = 0,\n/// AVCaptureSessionPresetMedium\n  VideoQualityMedium = 1,\n/// AVCaptureSessionPresetLow\n  VideoQualityLow = 2,\n/// AVCaptureSessionPreset352x288\n  VideoQualityResolution352x288 = 3,\n/// AVCaptureSessionPreset640x480\n  VideoQualityResolution640x480 = 4,\n/// AVCaptureSessionPreset1280x720\n  VideoQualityResolution1280x720 = 5,\n/// AVCaptureSessionPreset1920x1080\n  VideoQualityResolution1920x1080 = 6,\n/// AVCaptureSessionPreset3840x2160\n  VideoQualityResolution3840x2160 = 7,\n/// AVCaptureSessionPresetiFrame960x540\n  VideoQualityIframe960x540 = 8,\n/// AVCaptureSessionPresetiFrame1280x720\n  VideoQualityIframe1280x720 = 9,\n};\n\n/// Result from the AVCaptureSession Setup\n/// <ul>\n///   <li>\n///     success: success\n///   </li>\n///   <li>\n///     notAuthorized: User denied access to Camera of Microphone\n///   </li>\n///   <li>\n///     configurationFailed: Unknown error\n///   </li>\n/// </ul>\ntypedef SWIFT_ENUM(NSInteger, SessionSetupResult, closed) {\n  SessionSetupResultSuccess = 0,\n  SessionSetupResultNotAuthorized = 1,\n  SessionSetupResultConfigurationFailed = 2,\n};\n\n@class AVCaptureFileOutput;\n@class AVCaptureConnection;\n\n@interface SwiftyCamViewController (SWIFT_EXTENSION(SwiftyCam)) <AVCaptureFileOutputRecordingDelegate>\n/// Process newly captured video and write it to temporary directory\n- (void)captureOutput:(AVCaptureFileOutput * _Nonnull)output didFinishRecordingToOutputFileAtURL:(NSURL * _Nonnull)outputFileURL fromConnections:(NSArray<AVCaptureConnection *> * _Nonnull)connections error:(NSError * _Nullable)error;\n@end\n\n@class UIGestureRecognizer;\n\n@interface SwiftyCamViewController (SWIFT_EXTENSION(SwiftyCam)) <UIGestureRecognizerDelegate>\n/// Set beginZoomScale when pinch begins\n- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer * _Nonnull)gestureRecognizer SWIFT_WARN_UNUSED_RESULT;\n@end\n\n\n\n\n@interface SwiftyCamViewController (SWIFT_EXTENSION(SwiftyCam)) <SwiftyCamButtonDelegate>\n/// Sets the maximum duration of the SwiftyCamButton\n- (double)setMaxiumVideoDuration SWIFT_WARN_UNUSED_RESULT;\n/// Set UITapGesture to take photo\n- (void)buttonWasTapped;\n/// Set UILongPressGesture start to begin video\n- (void)buttonDidBeginLongPress;\n/// Set UILongPressGesture begin to begin end video\n- (void)buttonDidEndLongPress;\n/// Called if maximum duration is reached\n- (void)longPressDidReachMaximumDuration;\n@end\n\n\n/// Delegate for SwiftyCamViewController\nSWIFT_PROTOCOL(\"_TtP9SwiftyCam31SwiftyCamViewControllerDelegate_\")\n@protocol SwiftyCamViewControllerDelegate\n/// SwiftyCamViewControllerDelegate function called when when SwiftyCamViewController session did start running.\n/// Photos and video capture will be enabled.\n/// \\param swiftyCam Current SwiftyCamViewController\n///\n- (void)swiftyCamSessionDidStartRunning:(SwiftyCamViewController * _Nonnull)swiftyCam;\n/// SwiftyCamViewControllerDelegate function called when when SwiftyCamViewController session did stops running.\n/// Photos and video capture will be disabled.\n/// \\param swiftyCam Current SwiftyCamViewController\n///\n- (void)swiftyCamSessionDidStopRunning:(SwiftyCamViewController * _Nonnull)swiftyCam;\n/// SwiftyCamViewControllerDelegate function called when the takePhoto() function is called.\n/// \\param swiftyCam Current SwiftyCamViewController session\n///\n/// \\param photo UIImage captured from the current session\n///\n- (void)swiftyCam:(SwiftyCamViewController * _Nonnull)swiftyCam didTake:(UIImage * _Nonnull)photo;\n/// SwiftyCamViewControllerDelegate function called when SwiftyCamViewController begins recording video.\n/// \\param swiftyCam Current SwiftyCamViewController session\n///\n/// \\param camera Current camera orientation\n///\n- (void)swiftyCam:(SwiftyCamViewController * _Nonnull)swiftyCam didBeginRecordingVideo:(enum CameraSelection)camera;\n/// SwiftyCamViewControllerDelegate function called when SwiftyCamViewController finishes recording video.\n/// \\param swiftyCam Current SwiftyCamViewController session\n///\n/// \\param camera Current camera orientation\n///\n- (void)swiftyCam:(SwiftyCamViewController * _Nonnull)swiftyCam didFinishRecordingVideo:(enum CameraSelection)camera;\n/// SwiftyCamViewControllerDelegate function called when SwiftyCamViewController is done processing video.\n/// \\param swiftyCam Current SwiftyCamViewController session\n///\n/// \\param url URL location of video in temporary directory\n///\n- (void)swiftyCam:(SwiftyCamViewController * _Nonnull)swiftyCam didFinishProcessVideoAt:(NSURL * _Nonnull)url;\n/// SwiftyCamViewControllerDelegate function called when SwiftyCamViewController fails to record a video.\n/// \\param swiftyCam Current SwiftyCamViewController session\n///\n/// \\param error An error object that describes the problem\n///\n- (void)swiftyCam:(SwiftyCamViewController * _Nonnull)swiftyCam didFailToRecordVideo:(NSError * _Nonnull)error;\n/// SwiftyCamViewControllerDelegate function called when SwiftyCamViewController switches between front or rear camera.\n/// \\param swiftyCam Current SwiftyCamViewController session\n///\n/// \\param camera Current camera selection\n///\n- (void)swiftyCam:(SwiftyCamViewController * _Nonnull)swiftyCam didSwitchCameras:(enum CameraSelection)camera;\n/// SwiftyCamViewControllerDelegate function called when SwiftyCamViewController view is tapped and begins focusing at that point.\n/// \\param swiftyCam Current SwiftyCamViewController session\n///\n/// \\param point Location in view where camera focused\n///\n- (void)swiftyCam:(SwiftyCamViewController * _Nonnull)swiftyCam didFocusAtPoint:(CGPoint)point;\n/// SwiftyCamViewControllerDelegate function called when when SwiftyCamViewController view changes zoom level.\n/// \\param swiftyCam Current SwiftyCamViewController session\n///\n/// \\param zoom Current zoom level\n///\n- (void)swiftyCam:(SwiftyCamViewController * _Nonnull)swiftyCam didChangeZoomLevel:(CGFloat)zoom;\n/// SwiftyCamViewControllerDelegate function called when when SwiftyCamViewController fails to confiture the session.\n/// \\param swiftyCam Current SwiftyCamViewController\n///\n- (void)swiftyCamDidFailToConfigure:(SwiftyCamViewController * _Nonnull)swiftyCam;\n/// SwiftyCamViewControllerDelegate function called when when SwiftyCamViewController does not have access to camera or microphone.\n/// \\param swiftyCam Current SwiftyCamViewController\n///\n- (void)swiftyCamNotAuthorized:(SwiftyCamViewController * _Nonnull)swiftyCam;\n@end\n\n#if __has_attribute(external_source_symbol)\n# pragma clang attribute pop\n#endif\n#pragma clang diagnostic pop\n\n#elif defined(__i386__) && __i386__\n// Generated by Apple Swift version 5.1.3 effective-4.2 (swiftlang-1100.0.282.1 clang-1100.0.33.15)\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wgcc-compat\"\n\n#if !defined(__has_include)\n# define __has_include(x) 0\n#endif\n#if !defined(__has_attribute)\n# define __has_attribute(x) 0\n#endif\n#if !defined(__has_feature)\n# define __has_feature(x) 0\n#endif\n#if !defined(__has_warning)\n# define __has_warning(x) 0\n#endif\n\n#if __has_include(<swift/objc-prologue.h>)\n# include <swift/objc-prologue.h>\n#endif\n\n#pragma clang diagnostic ignored \"-Wauto-import\"\n#include <Foundation/Foundation.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <stdbool.h>\n\n#if !defined(SWIFT_TYPEDEFS)\n# define SWIFT_TYPEDEFS 1\n# if __has_include(<uchar.h>)\n#  include <uchar.h>\n# elif !defined(__cplusplus)\ntypedef uint_least16_t char16_t;\ntypedef uint_least32_t char32_t;\n# endif\ntypedef float swift_float2  __attribute__((__ext_vector_type__(2)));\ntypedef float swift_float3  __attribute__((__ext_vector_type__(3)));\ntypedef float swift_float4  __attribute__((__ext_vector_type__(4)));\ntypedef double swift_double2  __attribute__((__ext_vector_type__(2)));\ntypedef double swift_double3  __attribute__((__ext_vector_type__(3)));\ntypedef double swift_double4  __attribute__((__ext_vector_type__(4)));\ntypedef int swift_int2  __attribute__((__ext_vector_type__(2)));\ntypedef int swift_int3  __attribute__((__ext_vector_type__(3)));\ntypedef int swift_int4  __attribute__((__ext_vector_type__(4)));\ntypedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));\ntypedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));\ntypedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));\n#endif\n\n#if !defined(SWIFT_PASTE)\n# define SWIFT_PASTE_HELPER(x, y) x##y\n# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)\n#endif\n#if !defined(SWIFT_METATYPE)\n# define SWIFT_METATYPE(X) Class\n#endif\n#if !defined(SWIFT_CLASS_PROPERTY)\n# if __has_feature(objc_class_property)\n#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__\n# else\n#  define SWIFT_CLASS_PROPERTY(...)\n# endif\n#endif\n\n#if __has_attribute(objc_runtime_name)\n# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))\n#else\n# define SWIFT_RUNTIME_NAME(X)\n#endif\n#if __has_attribute(swift_name)\n# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))\n#else\n# define SWIFT_COMPILE_NAME(X)\n#endif\n#if __has_attribute(objc_method_family)\n# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))\n#else\n# define SWIFT_METHOD_FAMILY(X)\n#endif\n#if __has_attribute(noescape)\n# define SWIFT_NOESCAPE __attribute__((noescape))\n#else\n# define SWIFT_NOESCAPE\n#endif\n#if __has_attribute(warn_unused_result)\n# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))\n#else\n# define SWIFT_WARN_UNUSED_RESULT\n#endif\n#if __has_attribute(noreturn)\n# define SWIFT_NORETURN __attribute__((noreturn))\n#else\n# define SWIFT_NORETURN\n#endif\n#if !defined(SWIFT_CLASS_EXTRA)\n# define SWIFT_CLASS_EXTRA\n#endif\n#if !defined(SWIFT_PROTOCOL_EXTRA)\n# define SWIFT_PROTOCOL_EXTRA\n#endif\n#if !defined(SWIFT_ENUM_EXTRA)\n# define SWIFT_ENUM_EXTRA\n#endif\n#if !defined(SWIFT_CLASS)\n# if __has_attribute(objc_subclassing_restricted)\n#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA\n#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA\n# else\n#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA\n#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA\n# endif\n#endif\n#if !defined(SWIFT_RESILIENT_CLASS)\n# if __has_attribute(objc_class_stub)\n#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))\n#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)\n# else\n#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)\n#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)\n# endif\n#endif\n\n#if !defined(SWIFT_PROTOCOL)\n# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA\n# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA\n#endif\n\n#if !defined(SWIFT_EXTENSION)\n# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)\n#endif\n\n#if !defined(OBJC_DESIGNATED_INITIALIZER)\n# if __has_attribute(objc_designated_initializer)\n#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))\n# else\n#  define OBJC_DESIGNATED_INITIALIZER\n# endif\n#endif\n#if !defined(SWIFT_ENUM_ATTR)\n# if defined(__has_attribute) && __has_attribute(enum_extensibility)\n#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))\n# else\n#  define SWIFT_ENUM_ATTR(_extensibility)\n# endif\n#endif\n#if !defined(SWIFT_ENUM)\n# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type\n# if __has_feature(generalized_swift_name)\n#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type\n# else\n#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)\n# endif\n#endif\n#if !defined(SWIFT_UNAVAILABLE)\n# define SWIFT_UNAVAILABLE __attribute__((unavailable))\n#endif\n#if !defined(SWIFT_UNAVAILABLE_MSG)\n# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))\n#endif\n#if !defined(SWIFT_AVAILABILITY)\n# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))\n#endif\n#if !defined(SWIFT_WEAK_IMPORT)\n# define SWIFT_WEAK_IMPORT __attribute__((weak_import))\n#endif\n#if !defined(SWIFT_DEPRECATED)\n# define SWIFT_DEPRECATED __attribute__((deprecated))\n#endif\n#if !defined(SWIFT_DEPRECATED_MSG)\n# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))\n#endif\n#if __has_feature(attribute_diagnose_if_objc)\n# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, \"warning\")))\n#else\n# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)\n#endif\n#if !defined(IBSegueAction)\n# define IBSegueAction\n#endif\n#if __has_feature(modules)\n#if __has_warning(\"-Watimport-in-framework-header\")\n#pragma clang diagnostic ignored \"-Watimport-in-framework-header\"\n#endif\n@import AVFoundation;\n@import CoreGraphics;\n@import Dispatch;\n@import Foundation;\n@import ObjectiveC;\n@import UIKit;\n#endif\n\n#pragma clang diagnostic ignored \"-Wproperty-attribute-mismatch\"\n#pragma clang diagnostic ignored \"-Wduplicate-method-arg\"\n#if __has_warning(\"-Wpragma-clang-attribute\")\n# pragma clang diagnostic ignored \"-Wpragma-clang-attribute\"\n#endif\n#pragma clang diagnostic ignored \"-Wunknown-pragmas\"\n#pragma clang diagnostic ignored \"-Wnullability\"\n\n#if __has_attribute(external_source_symbol)\n# pragma push_macro(\"any\")\n# undef any\n# pragma clang attribute push(__attribute__((external_source_symbol(language=\"Swift\", defined_in=\"SwiftyCam\",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))\n# pragma pop_macro(\"any\")\n#endif\n\n@class CMMotionManager;\n\nSWIFT_CLASS(\"_TtC9SwiftyCam11Orientation\")\n@interface Orientation : NSObject\n@property (nonatomic, readonly, strong) CMMotionManager * _Nonnull coreMotionManager;\n- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;\n@end\n\n@class NSCoder;\n@class AVCaptureVideoPreviewLayer;\n@class AVCaptureSession;\n\nSWIFT_CLASS(\"_TtC9SwiftyCam11PreviewView\")\n@interface PreviewView : UIView\n- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;\n@property (nonatomic, readonly, strong) AVCaptureVideoPreviewLayer * _Nonnull videoPreviewLayer;\n@property (nonatomic, strong) AVCaptureSession * _Nullable session;\nSWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) Class _Nonnull layerClass;)\n+ (Class _Nonnull)layerClass SWIFT_WARN_UNUSED_RESULT;\n- (nonnull instancetype)initWithFrame:(CGRect)frame SWIFT_UNAVAILABLE;\n@end\n\n@protocol SwiftyCamButtonDelegate;\n\n/// UIButton Subclass for Capturing Photo and Video with SwiftyCamViewController\nSWIFT_CLASS(\"_TtC9SwiftyCam15SwiftyCamButton\")\n@interface SwiftyCamButton : UIButton\n/// Delegate variable\n@property (nonatomic, weak) id <SwiftyCamButtonDelegate> _Nullable delegate;\n@property (nonatomic) BOOL buttonEnabled;\n/// Initialization Declaration\n- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;\n/// Initialization Declaration\n- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;\n@end\n\n\n/// Delegate for SwiftyCamButton\nSWIFT_PROTOCOL(\"_TtP9SwiftyCam23SwiftyCamButtonDelegate_\")\n@protocol SwiftyCamButtonDelegate\n/// Called when UITapGestureRecognizer begins\n- (void)buttonWasTapped;\n/// Called When UILongPressGestureRecognizer enters UIGestureRecognizerState.began\n- (void)buttonDidBeginLongPress;\n/// Called When UILongPressGestureRecognizer enters UIGestureRecognizerState.end\n- (void)buttonDidEndLongPress;\n/// Called when the maximum duration is reached\n- (void)longPressDidReachMaximumDuration;\n/// Sets the maximum duration of the video recording\n- (double)setMaxiumVideoDuration SWIFT_WARN_UNUSED_RESULT;\n@end\n\n/// A function to specifty the Preview Layer\u2019s videoGravity. Indicates how the video is displayed within a player layer\u2019s bounds rect.\ntypedef SWIFT_ENUM(NSInteger, SwiftyCamVideoGravity, closed) {\n/// <ul>\n///   <li>\n///     Specifies that the video should be stretched to fill the layer\u2019s bounds\n///   </li>\n///   <li>\n///     Corrsponds to <code>AVLayerVideoGravityResize</code>\n///   </li>\n/// </ul>\n  SwiftyCamVideoGravityResize = 0,\n/// <ul>\n///   <li>\n///     Specifies that the player should preserve the video\u2019s aspect ratio and fit the video within the layer\u2019s bounds.\n///   </li>\n///   <li>\n///     Corresponds to <code>AVLayerVideoGravityResizeAspect</code>\n///   </li>\n/// </ul>\n  SwiftyCamVideoGravityResizeAspect = 1,\n/// <ul>\n///   <li>\n///     Specifies that the player should preserve the video\u2019s aspect ratio and fill the layer\u2019s bounds.\n///   </li>\n///   <li>\n///     Correponds to <code>AVLayerVideoGravityResizeAspectFill</code>\n///   </li>\n/// </ul>\n  SwiftyCamVideoGravityResizeAspectFill = 2,\n};\n\n@protocol SwiftyCamViewControllerDelegate;\nenum VideoQuality : NSInteger;\nenum CameraSelection : NSInteger;\n@class UIPinchGestureRecognizer;\n@class UIPanGestureRecognizer;\nenum SessionSetupResult : NSInteger;\n@class AVCaptureDeviceInput;\n@class AVCaptureMovieFileOutput;\n@class AVCaptureStillImageOutput;\n@class AVCaptureDevice;\n@class UIImage;\n@class NSBundle;\n\n/// A UIViewController Camera View Subclass\nSWIFT_CLASS(\"_TtC9SwiftyCam23SwiftyCamViewController\")\n@interface SwiftyCamViewController : UIViewController\n/// Public Camera Delegate for the Custom View Controller Subclass\n@property (nonatomic, weak) id <SwiftyCamViewControllerDelegate> _Nullable cameraDelegate;\n/// Maxiumum video duration if SwiftyCamButton is used\n@property (nonatomic) double maximumVideoDuration;\n/// Video capture quality\n@property (nonatomic) enum VideoQuality videoQuality;\n/// Disable audio\n@property (nonatomic) BOOL disableAudio;\n/// Sets whether flash is enabled for photo and video capture\n@property (nonatomic) BOOL flashEnabled;\n/// Sets whether Pinch to Zoom is enabled for the capture session\n@property (nonatomic) BOOL pinchToZoom;\n/// Sets the maximum zoom scale allowed during gestures gesture\n@property (nonatomic) CGFloat maxZoomScale;\n/// Sets whether Tap to Focus and Tap to Adjust Exposure is enabled for the capture session\n@property (nonatomic) BOOL tapToFocus;\n/// Sets whether the capture session should adjust to low light conditions automatically\n/// Only supported on iPhone 5 and 5C\n@property (nonatomic) BOOL lowLightBoost;\n/// Set whether SwiftyCam should allow background audio from other applications\n@property (nonatomic) BOOL allowBackgroundAudio;\n/// Sets whether a double tap to switch cameras is supported\n@property (nonatomic) BOOL doubleTapCameraSwitch;\n/// Sets whether swipe vertically to zoom is supported\n@property (nonatomic) BOOL swipeToZoom;\n/// Sets whether swipe vertically gestures should be inverted\n@property (nonatomic) BOOL swipeToZoomInverted;\n/// Set default launch camera\n@property (nonatomic) enum CameraSelection defaultCamera;\n/// Sets wether the taken photo or video should be oriented according to the device orientation\n@property (nonatomic) BOOL shouldUseDeviceOrientation;\n/// Sets whether or not View Controller supports auto rotation\n@property (nonatomic) BOOL allowAutoRotate;\n/// Specifies the <a href=\"https://developer.apple.com/reference/avfoundation/avcapturevideopreviewlayer/1386708-videogravity\">videoGravity</a> for the preview layer.\n@property (nonatomic) enum SwiftyCamVideoGravity videoGravity;\n/// Sets whether or not video recordings will record audio\n/// Setting to true will prompt user for access to microphone on View Controller launch.\n@property (nonatomic) BOOL audioEnabled;\n/// Sets whether or not app should display prompt to app settings if audio/video permission is denied\n/// If set to false, delegate function will be called to handle exception\n@property (nonatomic) BOOL shouldPrompToAppSettings;\n/// Video will be recorded to this folder\n@property (nonatomic, copy) NSString * _Nonnull outputFolder;\n/// Public access to Pinch Gesture\n@property (nonatomic, readonly, strong) UIPinchGestureRecognizer * _Null_unspecified pinchGesture;\n/// Public access to Pan Gesture\n@property (nonatomic, readonly, strong) UIPanGestureRecognizer * _Null_unspecified panGesture;\n/// Returns true if video is currently being recorded\n@property (nonatomic, readonly) BOOL isVideoRecording;\n/// Returns true if the capture session is currently running\n@property (nonatomic, readonly) BOOL isSessionRunning;\n/// Returns the CameraSelection corresponding to the currently utilized camera\n@property (nonatomic, readonly) enum CameraSelection currentCamera;\n/// Current Capture Session\n@property (nonatomic, readonly, strong) AVCaptureSession * _Nonnull session;\n/// Serial queue used for setting up session\n@property (nonatomic, readonly, strong) dispatch_queue_t _Nonnull sessionQueue;\n/// Variable for storing current zoom scale\n@property (nonatomic) CGFloat zoomScale;\n/// Variable for storing initial zoom scale before Pinch to Zoom begins\n@property (nonatomic) CGFloat beginZoomScale;\n/// Returns true if the torch (flash) is currently enabled\n@property (nonatomic) BOOL isCameraTorchOn;\n/// Variable to store result of capture session setup\n@property (nonatomic) enum SessionSetupResult setupResult;\n/// Video Input variable\n@property (nonatomic, strong) AVCaptureDeviceInput * _Null_unspecified videoDeviceInput;\n/// Movie File Output variable\n@property (nonatomic, strong) AVCaptureMovieFileOutput * _Nullable movieFileOutput;\n/// Photo File Output variable\n@property (nonatomic, strong) AVCaptureStillImageOutput * _Nullable photoFileOutput;\n/// Video Device variable\n@property (nonatomic, strong) AVCaptureDevice * _Nullable videoDevice;\n/// PreviewView for the capture session\n@property (nonatomic, strong) PreviewView * _Null_unspecified previewLayer;\n/// UIView for front facing flash\n@property (nonatomic, strong) UIView * _Nullable flashView;\n/// Pan Translation\n@property (nonatomic) CGFloat previousPanTranslation;\n/// Last changed orientation\n@property (nonatomic, strong) Orientation * _Nonnull orientation;\n/// Boolean to store when View Controller is notified session is running\n@property (nonatomic) BOOL sessionRunning;\n/// Disable view autorotation for forced portrait recorindg\n@property (nonatomic, readonly) BOOL shouldAutorotate;\n@property (nonatomic) AVVideoCodecType _Nullable videoCodecType;\n/// ViewDidLoad Implementation\n- (void)viewDidLoad;\n- (void)viewDidLayoutSubviews;\n/// ViewWillAppear(_ animated:) Implementation\n- (void)viewWillAppear:(BOOL)animated;\n/// ViewDidAppear(_ animated:) Implementation\n- (void)viewDidAppear:(BOOL)animated;\n/// ViewDidDisappear(_ animated:) Implementation\n- (void)viewDidDisappear:(BOOL)animated;\n/// Capture photo from current session\n/// UIImage will be returned with the SwiftyCamViewControllerDelegate function SwiftyCamDidTakePhoto(photo:)\n- (void)takePhoto;\n/// Begin recording video of current session\n/// SwiftyCamViewControllerDelegate function SwiftyCamDidBeginRecordingVideo() will be called\n- (void)startVideoRecording;\n/// Stop video recording video of current session\n/// SwiftyCamViewControllerDelegate function SwiftyCamDidFinishRecordingVideo() will be called\n/// When video has finished processing, the URL to the video location will be returned by SwiftyCamDidFinishProcessingVideoAt(url:)\n- (void)stopVideoRecording;\n/// Switch between front and rear camera\n/// SwiftyCamViewControllerDelegate function SwiftyCamDidSwitchCameras(camera:  will be return the current camera selection\n- (void)switchCamera;\n/// Returns a UIImage from Image Data.\n/// \\param imageData Image Data returned from capturing photo from the capture session.\n///\n///\n/// returns:\n/// UIImage from the image data, adjusted for proper orientation.\n- (UIImage * _Nonnull)processPhoto:(NSData * _Nonnull)imageData SWIFT_WARN_UNUSED_RESULT;\n- (void)capturePhotoAsyncronouslyWithCompletionHandler:(void (^ _Nonnull)(BOOL))completionHandler;\n/// Handle Denied App Privacy Settings\n- (void)promptToAppSettings;\n/// Returns an AVCapturePreset from VideoQuality Enumeration\n/// \\param quality ViewQuality enum\n///\n///\n/// returns:\n/// String representing a AVCapturePreset\n- (NSString * _Nonnull)videoInputPresetFromVideoQualityWithQuality:(enum VideoQuality)quality SWIFT_WARN_UNUSED_RESULT;\n/// Get Devices\n+ (AVCaptureDevice * _Nullable)deviceWithMediaType:(NSString * _Nonnull)mediaType preferringPosition:(enum AVCaptureDevicePosition)position SWIFT_WARN_UNUSED_RESULT;\n/// Enable or disable flash for photo\n- (void)changeFlashSettingsWithDevice:(AVCaptureDevice * _Nonnull)device mode:(enum AVCaptureFlashMode)mode;\n/// Enable flash\n- (void)enableFlash;\n/// Disable flash\n- (void)disableFlash;\n/// Toggles between enabling and disabling flash\n- (void)toggleFlash;\n/// Sets whether SwiftyCam should enable background audio from other applications or sources\n- (void)setBackgroundAudioPreference;\n- (nonnull instancetype)initWithNibName:(NSString * _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil OBJC_DESIGNATED_INITIALIZER;\n- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;\n@end\n\n/// Enumeration for Camera Selection\ntypedef SWIFT_ENUM(NSInteger, CameraSelection, closed) {\n/// Camera on the back of the device\n  CameraSelectionRear = 0,\n/// Camera on the front of the device\n  CameraSelectionFront = 1,\n};\n\n/// Enumeration for video quality of the capture session. Corresponds to a AVCaptureSessionPreset\ntypedef SWIFT_ENUM(NSInteger, VideoQuality, closed) {\n/// AVCaptureSessionPresetHigh\n  VideoQualityHigh = 0,\n/// AVCaptureSessionPresetMedium\n  VideoQualityMedium = 1,\n/// AVCaptureSessionPresetLow\n  VideoQualityLow = 2,\n/// AVCaptureSessionPreset352x288\n  VideoQualityResolution352x288 = 3,\n/// AVCaptureSessionPreset640x480\n  VideoQualityResolution640x480 = 4,\n/// AVCaptureSessionPreset1280x720\n  VideoQualityResolution1280x720 = 5,\n/// AVCaptureSessionPreset1920x1080\n  VideoQualityResolution1920x1080 = 6,\n/// AVCaptureSessionPreset3840x2160\n  VideoQualityResolution3840x2160 = 7,\n/// AVCaptureSessionPresetiFrame960x540\n  VideoQualityIframe960x540 = 8,\n/// AVCaptureSessionPresetiFrame1280x720\n  VideoQualityIframe1280x720 = 9,\n};\n\n/// Result from the AVCaptureSession Setup\n/// <ul>\n///   <li>\n///     success: success\n///   </li>\n///   <li>\n///     notAuthorized: User denied access to Camera of Microphone\n///   </li>\n///   <li>\n///     configurationFailed: Unknown error\n///   </li>\n/// </ul>\ntypedef SWIFT_ENUM(NSInteger, SessionSetupResult, closed) {\n  SessionSetupResultSuccess = 0,\n  SessionSetupResultNotAuthorized = 1,\n  SessionSetupResultConfigurationFailed = 2,\n};\n\n@class AVCaptureFileOutput;\n@class AVCaptureConnection;\n\n@interface SwiftyCamViewController (SWIFT_EXTENSION(SwiftyCam)) <AVCaptureFileOutputRecordingDelegate>\n/// Process newly captured video and write it to temporary directory\n- (void)captureOutput:(AVCaptureFileOutput * _Nonnull)output didFinishRecordingToOutputFileAtURL:(NSURL * _Nonnull)outputFileURL fromConnections:(NSArray<AVCaptureConnection *> * _Nonnull)connections error:(NSError * _Nullable)error;\n@end\n\n@class UIGestureRecognizer;\n\n@interface SwiftyCamViewController (SWIFT_EXTENSION(SwiftyCam)) <UIGestureRecognizerDelegate>\n/// Set beginZoomScale when pinch begins\n- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer * _Nonnull)gestureRecognizer SWIFT_WARN_UNUSED_RESULT;\n@end\n\n\n\n\n@interface SwiftyCamViewController (SWIFT_EXTENSION(SwiftyCam)) <SwiftyCamButtonDelegate>\n/// Sets the maximum duration of the SwiftyCamButton\n- (double)setMaxiumVideoDuration SWIFT_WARN_UNUSED_RESULT;\n/// Set UITapGesture to take photo\n- (void)buttonWasTapped;\n/// Set UILongPressGesture start to begin video\n- (void)buttonDidBeginLongPress;\n/// Set UILongPressGesture begin to begin end video\n- (void)buttonDidEndLongPress;\n/// Called if maximum duration is reached\n- (void)longPressDidReachMaximumDuration;\n@end\n\n\n/// Delegate for SwiftyCamViewController\nSWIFT_PROTOCOL(\"_TtP9SwiftyCam31SwiftyCamViewControllerDelegate_\")\n@protocol SwiftyCamViewControllerDelegate\n/// SwiftyCamViewControllerDelegate function called when when SwiftyCamViewController session did start running.\n/// Photos and video capture will be enabled.\n/// \\param swiftyCam Current SwiftyCamViewController\n///\n- (void)swiftyCamSessionDidStartRunning:(SwiftyCamViewController * _Nonnull)swiftyCam;\n/// SwiftyCamViewControllerDelegate function called when when SwiftyCamViewController session did stops running.\n/// Photos and video capture will be disabled.\n/// \\param swiftyCam Current SwiftyCamViewController\n///\n- (void)swiftyCamSessionDidStopRunning:(SwiftyCamViewController * _Nonnull)swiftyCam;\n/// SwiftyCamViewControllerDelegate function called when the takePhoto() function is called.\n/// \\param swiftyCam Current SwiftyCamViewController session\n///\n/// \\param photo UIImage captured from the current session\n///\n- (void)swiftyCam:(SwiftyCamViewController * _Nonnull)swiftyCam didTake:(UIImage * _Nonnull)photo;\n/// SwiftyCamViewControllerDelegate function called when SwiftyCamViewController begins recording video.\n/// \\param swiftyCam Current SwiftyCamViewController session\n///\n/// \\param camera Current camera orientation\n///\n- (void)swiftyCam:(SwiftyCamViewController * _Nonnull)swiftyCam didBeginRecordingVideo:(enum CameraSelection)camera;\n/// SwiftyCamViewControllerDelegate function called when SwiftyCamViewController finishes recording video.\n/// \\param swiftyCam Current SwiftyCamViewController session\n///\n/// \\param camera Current camera orientation\n///\n- (void)swiftyCam:(SwiftyCamViewController * _Nonnull)swiftyCam didFinishRecordingVideo:(enum CameraSelection)camera;\n/// SwiftyCamViewControllerDelegate function called when SwiftyCamViewController is done processing video.\n/// \\param swiftyCam Current SwiftyCamViewController session\n///\n/// \\param url URL location of video in temporary directory\n///\n- (void)swiftyCam:(SwiftyCamViewController * _Nonnull)swiftyCam didFinishProcessVideoAt:(NSURL * _Nonnull)url;\n/// SwiftyCamViewControllerDelegate function called when SwiftyCamViewController fails to record a video.\n/// \\param swiftyCam Current SwiftyCamViewController session\n///\n/// \\param error An error object that describes the problem\n///\n- (void)swiftyCam:(SwiftyCamViewController * _Nonnull)swiftyCam didFailToRecordVideo:(NSError * _Nonnull)error;\n/// SwiftyCamViewControllerDelegate function called when SwiftyCamViewController switches between front or rear camera.\n/// \\param swiftyCam Current SwiftyCamViewController session\n///\n/// \\param camera Current camera selection\n///\n- (void)swiftyCam:(SwiftyCamViewController * _Nonnull)swiftyCam didSwitchCameras:(enum CameraSelection)camera;\n/// SwiftyCamViewControllerDelegate function called when SwiftyCamViewController view is tapped and begins focusing at that point.\n/// \\param swiftyCam Current SwiftyCamViewController session\n///\n/// \\param point Location in view where camera focused\n///\n- (void)swiftyCam:(SwiftyCamViewController * _Nonnull)swiftyCam didFocusAtPoint:(CGPoint)point;\n/// SwiftyCamViewControllerDelegate function called when when SwiftyCamViewController view changes zoom level.\n/// \\param swiftyCam Current SwiftyCamViewController session\n///\n/// \\param zoom Current zoom level\n///\n- (void)swiftyCam:(SwiftyCamViewController * _Nonnull)swiftyCam didChangeZoomLevel:(CGFloat)zoom;\n/// SwiftyCamViewControllerDelegate function called when when SwiftyCamViewController fails to confiture the session.\n/// \\param swiftyCam Current SwiftyCamViewController\n///\n- (void)swiftyCamDidFailToConfigure:(SwiftyCamViewController * _Nonnull)swiftyCam;\n/// SwiftyCamViewControllerDelegate function called when when SwiftyCamViewController does not have access to camera or microphone.\n/// \\param swiftyCam Current SwiftyCamViewController\n///\n- (void)swiftyCamNotAuthorized:(SwiftyCamViewController * _Nonnull)swiftyCam;\n@end\n\n#if __has_attribute(external_source_symbol)\n# pragma clang attribute pop\n#endif\n#pragma clang diagnostic pop\n\n#endif\n\n", "comment_ratio": 0.3314097279472383}
{"lang": "c", "code": "#import <IDEKit/_TtC6IDEKit50IDESourceControlConflictResolutionWindowController.h>\n\n@interface _TtC6IDEKit50IDESourceControlConflictResolutionWindowController (IDEKit)\n+ (id)keyPathsForValuesAffectingFileSystemNavigableItem;\n+ (id)keyPathsForValuesAffectingFlatNavigableItem;\n- (id)reviewFilesNavigator:(id)arg1 documentLocationForNavigableItem:(id)arg2;\n- (id)issueNavigableItem;\n- (id)workspaceNavigableItem;\n- (id)flatNavigableItem;\n- (id)fileSystemNavigableItem;\n@end\n\n\n", "comment_ratio": 0.2631578947368421}
{"lang": "c", "code": "// stdafx.h : include file for standard system include files,\n// or project specific include files that are used frequently, but\n// are changed infrequently\n//\n\n#pragma once\n\n#include \"targetver.h\"\n\n#include <stdio.h>\n#include <tchar.h>\n#include <strsafe.h>\n#include <windows.h>\n#include <io.h>\n#include <fcntl.h>\n#include <Shlwapi.h>\n\n#include <queue>\n#include <vector>\n#include <array>\n\n// TODO: reference additional headers your program requires here\n\n", "comment_ratio": 0.21739130434782608}
{"lang": "c", "code": "#pragma once\n\n#include <memory>\n#include <string>\n\nnamespace milvus {\nnamespace storage {\n\nclass IOReader {\n public:\n    virtual bool\n    Open(const std::string& name) = 0;\n\n    virtual void\n    Read(void* ptr, int64_t size) = 0;\n\n    virtual void\n    Seekg(int64_t pos) = 0;\n\n    virtual int64_t\n    Length() = 0;\n\n    virtual void\n    Close() = 0;\n};\n\nusing IOReaderPtr = std::shared_ptr<IOReader>;\n\n}  // namespace storage\n}  // namespace milvus\n\n", "comment_ratio": 0.2857142857142857}
{"lang": "c", "code": "#import \"UIXCollectionViewController.h\"\n#import \"UIXPullUpControl.h\"\n\n@interface UIXLMCollectionViewController : UIXCollectionViewController<UIXPullUpControlDelegate>\n\n/**\n *  @Author wangxiaoxiang.cn@iCloud.com, 14-10-27 11:10:57\n *\n *  @brief  \u4e0a\u62c9\u89c6\u56fe\uff0c\u9700\u8981\u5b50\u7c7b\u521d\u59cb\u5316\u3002\u7236\u7c7b\u4e2d\u4e0d\u505a\u521d\u59cb\u5316\u3002\n */\n@property (nonatomic,strong) UIXPullUpControl* pullUpControl;\n\n\n/**\n *  @Author wangxiaoxiang.cn@iCloud.com, 14-10-27 11:10:25\n *\n *  @brief \u5f53\u5b50\u7c7b\u521d\u59cb\u5316\u201c\u4e0a\u62c9\u52a0\u8f7d\u201d\u5b8c\u6210\uff0c\u89e6\u53d1\u4e0a\u62c9\u52a0\u8f7d\u65f6\u4f1a\u8c03\u7528\u6b64\u65b9\u6cd5\u3002\u5982\u679c\u5b50\u7c7b\u9700\u8981Override\u6b64\u65b9\u6cd5\u3002\n */\n-(void)beginPullUpRefreshing;\n\n\n/**\n *  @Author wangxiaoxiang.cn@iCloud.com, 14-10-27 11:10:25\n *\n *  @brief \u5982\u679c\u5b50\u7c7b\u5b8c\u6210\u4e0a\u62c9\u52a0\u8f7d\u65f6\u9700\u8981\u8c03\u7528\u6b64\u65b9\u6cd5\u3002\n */\n-(void)endPullUpRefreshing;\n\n@end\n\n", "comment_ratio": 0.18421052631578946}
{"lang": "c", "code": "#import <CalendarPersistence/CalManagedChangeRequest.h>\n\n@class NSData, NSString;\n\n@interface CalManagedSharedCalendarInvitationResponseChangeRequest : CalManagedChangeRequest\n{\n}\n\n+ (id)insertSharedCalendarInvitationResponse:(int)arg1 toInvitation:(id)arg2 principalUID:(id)arg3 calendarHomePath:(id)arg4 inManagedObjectContext:(id)arg5;\n\n// Remaining properties\n@property(retain) NSString *calendarHomePath; // @dynamic calendarHomePath;\n@property(retain) NSData *invitation; // @dynamic invitation;\n@property(retain) NSString *principalUID; // @dynamic principalUID;\n@property int response; // @dynamic response;\n\n@end\n\n\n", "comment_ratio": 0.4}
{"lang": "c", "code": "#ifndef LLVM_OBJECTYAML_ELFYAML_H\n#define LLVM_OBJECTYAML_ELFYAML_H\n\n#include \"llvm/ObjectYAML/YAML.h\"\n#include \"llvm/Support/ELF.h\"\n\nnamespace llvm {\nnamespace ELFYAML {\n\n// These types are invariant across 32/64-bit ELF, so for simplicity just\n// directly give them their exact sizes. We don't need to worry about\n// endianness because these are just the types in the YAMLIO structures,\n// and are appropriately converted to the necessary endianness when\n// reading/generating binary object files.\n// The naming of these types is intended to be ELF_PREFIX, where PREFIX is\n// the common prefix of the respective constants. E.g. ELF_EM corresponds\n// to the `e_machine` constants, like `EM_X86_64`.\n// In the future, these would probably be better suited by C++11 enum\n// class's with appropriate fixed underlying type.\nLLVM_YAML_STRONG_TYPEDEF(uint16_t, ELF_ET)\nLLVM_YAML_STRONG_TYPEDEF(uint32_t, ELF_EM)\nLLVM_YAML_STRONG_TYPEDEF(uint8_t, ELF_ELFCLASS)\nLLVM_YAML_STRONG_TYPEDEF(uint8_t, ELF_ELFDATA)\nLLVM_YAML_STRONG_TYPEDEF(uint8_t, ELF_ELFOSABI)\n// Just use 64, since it can hold 32-bit values too.\nLLVM_YAML_STRONG_TYPEDEF(uint64_t, ELF_EF)\nLLVM_YAML_STRONG_TYPEDEF(uint32_t, ELF_SHT)\nLLVM_YAML_STRONG_TYPEDEF(uint32_t, ELF_REL)\nLLVM_YAML_STRONG_TYPEDEF(uint8_t, ELF_RSS)\n// Just use 64, since it can hold 32-bit values too.\nLLVM_YAML_STRONG_TYPEDEF(uint64_t, ELF_SHF)\nLLVM_YAML_STRONG_TYPEDEF(uint8_t, ELF_STT)\nLLVM_YAML_STRONG_TYPEDEF(uint8_t, ELF_STV)\nLLVM_YAML_STRONG_TYPEDEF(uint8_t, ELF_STO)\n\nLLVM_YAML_STRONG_TYPEDEF(uint8_t, MIPS_AFL_REG)\nLLVM_YAML_STRONG_TYPEDEF(uint8_t, MIPS_ABI_FP)\nLLVM_YAML_STRONG_TYPEDEF(uint32_t, MIPS_AFL_EXT)\nLLVM_YAML_STRONG_TYPEDEF(uint32_t, MIPS_AFL_ASE)\nLLVM_YAML_STRONG_TYPEDEF(uint32_t, MIPS_AFL_FLAGS1)\nLLVM_YAML_STRONG_TYPEDEF(uint32_t, MIPS_ISA)\n\n// For now, hardcode 64 bits everywhere that 32 or 64 would be needed\n// since 64-bit can hold 32-bit values too.\nstruct FileHeader {\n  ELF_ELFCLASS Class;\n  ELF_ELFDATA Data;\n  ELF_ELFOSABI OSABI;\n  ELF_ET Type;\n  ELF_EM Machine;\n  ELF_EF Flags;\n  llvm::yaml::Hex64 Entry;\n};\nstruct Symbol {\n  StringRef Name;\n  ELF_STT Type;\n  StringRef Section;\n  llvm::yaml::Hex64 Value;\n  llvm::yaml::Hex64 Size;\n  uint8_t Other;\n};\nstruct LocalGlobalWeakSymbols {\n  std::vector<Symbol> Local;\n  std::vector<Symbol> Global;\n  std::vector<Symbol> Weak;\n};\n\nstruct SectionOrType {\n  StringRef sectionNameOrType;\n};\n\nstruct Section {\n  enum class SectionKind {\n    Group,\n    RawContent,\n    Relocation,\n    NoBits,\n    MipsABIFlags\n  };\n  SectionKind Kind;\n  StringRef Name;\n  ELF_SHT Type;\n  ELF_SHF Flags;\n  llvm::yaml::Hex64 Address;\n  StringRef Link;\n  StringRef Info;\n  llvm::yaml::Hex64 AddressAlign;\n  Section(SectionKind Kind) : Kind(Kind) {}\n  virtual ~Section();\n};\nstruct RawContentSection : Section {\n  yaml::BinaryRef Content;\n  llvm::yaml::Hex64 Size;\n  RawContentSection() : Section(SectionKind::RawContent) {}\n  static bool classof(const Section *S) {\n    return S->Kind == SectionKind::RawContent;\n  }\n};\n\nstruct NoBitsSection : Section {\n  llvm::yaml::Hex64 Size;\n  NoBitsSection() : Section(SectionKind::NoBits) {}\n  static bool classof(const Section *S) {\n    return S->Kind == SectionKind::NoBits;\n  }\n};\n\nstruct Group : Section {\n  // Members of a group contain a flag and a list of section indices\n  // that are part of the group.\n  std::vector<SectionOrType> Members;\n  Group() : Section(SectionKind::Group) {}\n  static bool classof(const Section *S) {\n    return S->Kind == SectionKind::Group;\n  }\n};\n\nstruct Relocation {\n  llvm::yaml::Hex64 Offset;\n  int64_t Addend;\n  ELF_REL Type;\n  StringRef Symbol;\n};\nstruct RelocationSection : Section {\n  std::vector<Relocation> Relocations;\n  RelocationSection() : Section(SectionKind::Relocation) {}\n  static bool classof(const Section *S) {\n    return S->Kind == SectionKind::Relocation;\n  }\n};\n\n// Represents .MIPS.abiflags section\nstruct MipsABIFlags : Section {\n  llvm::yaml::Hex16 Version;\n  MIPS_ISA ISALevel;\n  llvm::yaml::Hex8 ISARevision;\n  MIPS_AFL_REG GPRSize;\n  MIPS_AFL_REG CPR1Size;\n  MIPS_AFL_REG CPR2Size;\n  MIPS_ABI_FP FpABI;\n  MIPS_AFL_EXT ISAExtension;\n  MIPS_AFL_ASE ASEs;\n  MIPS_AFL_FLAGS1 Flags1;\n  llvm::yaml::Hex32 Flags2;\n  MipsABIFlags() : Section(SectionKind::MipsABIFlags) {}\n  static bool classof(const Section *S) {\n    return S->Kind == SectionKind::MipsABIFlags;\n  }\n};\n\nstruct Object {\n  FileHeader Header;\n  std::vector<std::unique_ptr<Section>> Sections;\n  // Although in reality the symbols reside in a section, it is a lot\n  // cleaner and nicer if we read them from the YAML as a separate\n  // top-level key, which automatically ensures that invariants like there\n  // being a single SHT_SYMTAB section are upheld.\n  LocalGlobalWeakSymbols Symbols;\n};\n\n} // end namespace ELFYAML\n} // end namespace llvm\n\nLLVM_YAML_IS_SEQUENCE_VECTOR(std::unique_ptr<llvm::ELFYAML::Section>)\nLLVM_YAML_IS_SEQUENCE_VECTOR(llvm::ELFYAML::Symbol)\nLLVM_YAML_IS_SEQUENCE_VECTOR(llvm::ELFYAML::Relocation)\nLLVM_YAML_IS_SEQUENCE_VECTOR(llvm::ELFYAML::SectionOrType)\n\nnamespace llvm {\nnamespace yaml {\n\ntemplate <>\nstruct ScalarEnumerationTraits<ELFYAML::ELF_ET> {\n  static void enumeration(IO &IO, ELFYAML::ELF_ET &Value);\n};\n\ntemplate <>\nstruct ScalarEnumerationTraits<ELFYAML::ELF_EM> {\n  static void enumeration(IO &IO, ELFYAML::ELF_EM &Value);\n};\n\ntemplate <>\nstruct ScalarEnumerationTraits<ELFYAML::ELF_ELFCLASS> {\n  static void enumeration(IO &IO, ELFYAML::ELF_ELFCLASS &Value);\n};\n\ntemplate <>\nstruct ScalarEnumerationTraits<ELFYAML::ELF_ELFDATA> {\n  static void enumeration(IO &IO, ELFYAML::ELF_ELFDATA &Value);\n};\n\ntemplate <>\nstruct ScalarEnumerationTraits<ELFYAML::ELF_ELFOSABI> {\n  static void enumeration(IO &IO, ELFYAML::ELF_ELFOSABI &Value);\n};\n\ntemplate <>\nstruct ScalarBitSetTraits<ELFYAML::ELF_EF> {\n  static void bitset(IO &IO, ELFYAML::ELF_EF &Value);\n};\n\ntemplate <>\nstruct ScalarEnumerationTraits<ELFYAML::ELF_SHT> {\n  static void enumeration(IO &IO, ELFYAML::ELF_SHT &Value);\n};\n\ntemplate <>\nstruct ScalarBitSetTraits<ELFYAML::ELF_SHF> {\n  static void bitset(IO &IO, ELFYAML::ELF_SHF &Value);\n};\n\ntemplate <>\nstruct ScalarEnumerationTraits<ELFYAML::ELF_STT> {\n  static void enumeration(IO &IO, ELFYAML::ELF_STT &Value);\n};\n\ntemplate <>\nstruct ScalarEnumerationTraits<ELFYAML::ELF_STV> {\n  static void enumeration(IO &IO, ELFYAML::ELF_STV &Value);\n};\n\ntemplate <>\nstruct ScalarBitSetTraits<ELFYAML::ELF_STO> {\n  static void bitset(IO &IO, ELFYAML::ELF_STO &Value);\n};\n\ntemplate <>\nstruct ScalarEnumerationTraits<ELFYAML::ELF_REL> {\n  static void enumeration(IO &IO, ELFYAML::ELF_REL &Value);\n};\n\ntemplate <>\nstruct ScalarEnumerationTraits<ELFYAML::ELF_RSS> {\n  static void enumeration(IO &IO, ELFYAML::ELF_RSS &Value);\n};\n\ntemplate <>\nstruct ScalarEnumerationTraits<ELFYAML::MIPS_AFL_REG> {\n  static void enumeration(IO &IO, ELFYAML::MIPS_AFL_REG &Value);\n};\n\ntemplate <>\nstruct ScalarEnumerationTraits<ELFYAML::MIPS_ABI_FP> {\n  static void enumeration(IO &IO, ELFYAML::MIPS_ABI_FP &Value);\n};\n\ntemplate <>\nstruct ScalarEnumerationTraits<ELFYAML::MIPS_AFL_EXT> {\n  static void enumeration(IO &IO, ELFYAML::MIPS_AFL_EXT &Value);\n};\n\ntemplate <>\nstruct ScalarEnumerationTraits<ELFYAML::MIPS_ISA> {\n  static void enumeration(IO &IO, ELFYAML::MIPS_ISA &Value);\n};\n\ntemplate <>\nstruct ScalarBitSetTraits<ELFYAML::MIPS_AFL_ASE> {\n  static void bitset(IO &IO, ELFYAML::MIPS_AFL_ASE &Value);\n};\n\ntemplate <>\nstruct ScalarBitSetTraits<ELFYAML::MIPS_AFL_FLAGS1> {\n  static void bitset(IO &IO, ELFYAML::MIPS_AFL_FLAGS1 &Value);\n};\n\ntemplate <>\nstruct MappingTraits<ELFYAML::FileHeader> {\n  static void mapping(IO &IO, ELFYAML::FileHeader &FileHdr);\n};\n\ntemplate <>\nstruct MappingTraits<ELFYAML::Symbol> {\n  static void mapping(IO &IO, ELFYAML::Symbol &Symbol);\n};\n\ntemplate <>\nstruct MappingTraits<ELFYAML::LocalGlobalWeakSymbols> {\n  static void mapping(IO &IO, ELFYAML::LocalGlobalWeakSymbols &Symbols);\n};\n\ntemplate <> struct MappingTraits<ELFYAML::Relocation> {\n  static void mapping(IO &IO, ELFYAML::Relocation &Rel);\n};\n\ntemplate <>\nstruct MappingTraits<std::unique_ptr<ELFYAML::Section>> {\n  static void mapping(IO &IO, std::unique_ptr<ELFYAML::Section> &Section);\n  static StringRef validate(IO &io, std::unique_ptr<ELFYAML::Section> &Section);\n};\n\ntemplate <>\nstruct MappingTraits<ELFYAML::Object> {\n  static void mapping(IO &IO, ELFYAML::Object &Object);\n};\n\ntemplate <> struct MappingTraits<ELFYAML::SectionOrType> {\n  static void mapping(IO &IO, ELFYAML::SectionOrType &sectionOrType);\n};\n\n} // end namespace yaml\n} // end namespace llvm\n\n#endif\n\n", "comment_ratio": 0.121875}
{"lang": "c", "code": "#include <askap_analysisutilities.h>\n#include <cppunit/extensions/HelperMacros.h>\n\n#include <askap/AskapLogging.h>\n#include <askap/AskapError.h>\n\n#include <modelcomponents/ContinuumS3SEX.h>\n\n#include <iostream>\n#include <sstream>\n\nnamespace askap {\n\n  namespace analysisutilities {\n    \n\n    class ContinuumS3SEXTest : public CppUnit::TestFixture {\n\tCPPUNIT_TEST_SUITE(ContinuumS3SEXTest);\n\tCPPUNIT_TEST(testParameters);\n\tCPPUNIT_TEST(testFluxes);\n\tCPPUNIT_TEST_SUITE_END();\n\t\n    private:\n\t// members\n\tContinuumS3SEX itsComponent;\n\t\n    public:\n\n\tfloat getFlux(float nu){return i_1400+log10(pow((nu/nu0),alpha+beta*log(nu/nu0)));};\n\tstd::string component;\n\tint structure;\n\tstd::string right_ascension;\n\tstd::string declination;\n\tfloat position_angle;\n\tfloat major_axis;\n\tfloat minor_axis;\n\tfloat alpha;\n\tfloat beta;\n\tfloat nu0;\n\tfloat i_1400;\n\tfloat i_151;\n\tfloat i_610;\n\tfloat i_4860;\n\tfloat i_18000;\n\n\tvoid setUp(){\n\n\t// component    galaxy structure right_ascension declination position_angle major_axis minor_axis   i_151   i_610  i_1400  i_4860 i_18000\n\t//    const std::string ContinuumS3SEXInput=\"12205907  12205907         1      180.343780  -49.569685            0.0        0.0        0.0 -5.3230 -5.7474 0.0000 -6.3784 -6.7764\";\n\t  component=\"12205907\";\n\t  structure=1;\n\t  right_ascension=\"187.5\";\n\t  declination=\"-45.\";\n\t  position_angle=30.;\n\t  major_axis=10.;\n\t  minor_axis=5.;\n\t  alpha=0.5;\n\t  beta=0.1;\n\t  nu0=1400.;\n\t  i_1400=0.;\n\t  i_151=getFlux(151.);\n\t  i_610=getFlux(610.);\n\t  i_4860=getFlux(4860.);\n\t  i_18000=getFlux(18000.);\n\t\n\t  std::ostringstream ContinuumS3SEXInput;\n\t  ContinuumS3SEXInput << component << \" \" << \n\t    component << \" \" << \n\t    structure << \" \" << \n\t    right_ascension << \" \" << \n\t    declination << \" \" << \n\t    position_angle << \" \" << \n\t    major_axis << \" \" << \n\t    minor_axis << \" \" << \n\t    i_151 << \" \" << \n\t    i_610 << \" \" << \n\t    i_1400 << \" \" << \n\t    i_4860 << \" \" <<\n\t    i_18000;\n\t  itsComponent.setNuZero(1.4e9);\n\t  itsComponent.define(ContinuumS3SEXInput.str());\n\t  itsComponent.prepareForUse();\n\n\t}\n\n/*****************************************/\n\tvoid tearDown() {\n\t}\n\n/*****************************************/\n\tvoid testParameters() {\n\t  CPPUNIT_ASSERT(itsComponent.ra()==\"187.5\");\n\t  CPPUNIT_ASSERT(itsComponent.dec()==\"-45.\");\n\t  CPPUNIT_ASSERT(fabs(itsComponent.fluxZero()-pow(10,i_1400))<1.e-6);\n\t  CPPUNIT_ASSERT(fabs(itsComponent.alpha()-alpha)<1.e-6);\n\t  CPPUNIT_ASSERT(fabs(itsComponent.maj()-major_axis)<1.e-6);\n\t  CPPUNIT_ASSERT(fabs(itsComponent.min()-minor_axis)<1.e-6);\n\t  CPPUNIT_ASSERT(fabs(itsComponent.pa()-position_angle)<1.e-6);\n\t}\n\n\tvoid testFluxes(){\n\t  CPPUNIT_ASSERT(fabs(itsComponent.fluxZero()-pow(10,i_1400))<1.e-6);\n\t  CPPUNIT_ASSERT(fabs(itsComponent.flux(1400.e6)-pow(10.,i_1400))<1.e-6);\n\t  CPPUNIT_ASSERT(fabs(itsComponent.flux(1000.e6)-0.8547769)<1.e-6);\n\t  CPPUNIT_ASSERT(fabs(itsComponent.flux(2000.e6)-1.2105311)<1.e-6);\n\t}\n\n    };\n  }\n}\n\n", "comment_ratio": 0.22302158273381295}
{"lang": "c", "code": "#import \"NSObject.h\"\n\n@class NSMutableArray;\n\n@interface WBSCyclerTestRunner : NSObject\n{\n    BOOL _stopRequested;\n    NSMutableArray *_pendingRequestQueue;\n    NSMutableArray *_pendingRequestCompletionHandlerQueue;\n    BOOL _running;\n    id <WBSCyclerTestSuite> _testSuite;\n    id <WBSCyclerTestTarget> _target;\n}\n\n@property(readonly, nonatomic, getter=isRunning) BOOL running; // @synthesize running=_running;\n@property(readonly, nonatomic) id <WBSCyclerTestTarget> target; // @synthesize target=_target;\n@property(readonly, nonatomic) id <WBSCyclerTestSuite> testSuite; // @synthesize testSuite=_testSuite;\n- (void).cxx_destruct;\n- (id)_descriptionForErrorCode:(long long)arg1;\n- (id)_errorWithCode:(long long)arg1;\n- (void)_handleNextPendingRequestWithCompletionHandler:(CDUnknownBlockType)arg1;\n- (void)_performNextIterationWithCompletionHandler:(CDUnknownBlockType)arg1;\n- (void)_stop;\n- (void)handleRequest:(id)arg1 completionHandler:(CDUnknownBlockType)arg2;\n- (void)requestStop;\n- (void)runWithCompletionHandler:(CDUnknownBlockType)arg1;\n- (void)dealloc;\n- (id)initWithTestSuite:(id)arg1 target:(id)arg2;\n- (id)init;\n\n@end\n\n\n", "comment_ratio": 0.20512820512820512}
{"lang": "c", "code": "#ifndef InspectorPerformanceAgent_h\n#define InspectorPerformanceAgent_h\n\n#include \"core/CoreExport.h\"\n#include \"core/inspector/InspectorBaseAgent.h\"\n#include \"core/inspector/protocol/Performance.h\"\n#include \"platform/scheduler/base/task_time_observer.h\"\n\nnamespace blink {\n\nclass InspectedFrames;\n\nnamespace probe {\nclass CallFunction;\nclass ExecuteScript;\nclass RecalculateStyle;\nclass UpdateLayout;\n}  // namespace probe\n\nclass CORE_EXPORT InspectorPerformanceAgent final\n    : public InspectorBaseAgent<protocol::Performance::Metainfo>,\n      public scheduler::TaskTimeObserver {\n  WTF_MAKE_NONCOPYABLE(InspectorPerformanceAgent);\n\n public:\n  DECLARE_VIRTUAL_TRACE();\n\n  static InspectorPerformanceAgent* Create(InspectedFrames* inspected_frames) {\n    return new InspectorPerformanceAgent(inspected_frames);\n  }\n  ~InspectorPerformanceAgent() override;\n\n  void Restore() override;\n\n  // Performance protocol domain implementation.\n  protocol::Response enable() override;\n  protocol::Response disable() override;\n  protocol::Response getMetrics(\n      std::unique_ptr<protocol::Array<protocol::Performance::Metric>>*\n          out_result) override;\n\n  // PerformanceMetrics probes implementation.\n  void ConsoleTimeStamp(const String& title);\n  void Will(const probe::CallFunction&);\n  void Did(const probe::CallFunction&);\n  void Will(const probe::ExecuteScript&);\n  void Did(const probe::ExecuteScript&);\n  void Will(const probe::RecalculateStyle&);\n  void Did(const probe::RecalculateStyle&);\n  void Will(const probe::UpdateLayout&);\n  void Did(const probe::UpdateLayout&);\n\n  // scheduler::TaskTimeObserver\n  void WillProcessTask(double start_time) override;\n  void DidProcessTask(double start_time, double end_time) override;\n\n private:\n  InspectorPerformanceAgent(InspectedFrames*);\n\n  Member<InspectedFrames> inspected_frames_;\n  bool enabled_ = false;\n  double layout_duration_ = 0;\n  double recalc_style_duration_ = 0;\n  double script_duration_ = 0;\n  double script_start_time_ = 0;\n  double task_duration_ = 0;\n  double task_start_time_ = 0;\n  unsigned long long layout_count_ = 0;\n  unsigned long long recalc_style_count_ = 0;\n  int script_call_depth_ = 0;\n  int layout_depth_ = 0;\n};\n\n}  // namespace blink\n\n#endif  // !defined(InspectorPerformanceAgent_h)\n\n", "comment_ratio": 0.1111111111111111}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n#import <MapKit/MapKit.h>\n\ntypedef enum {None,Start,End} DatePickerState;\n\n@interface ReserveSpotController : UIViewController<MKMapViewDelegate>\n{\n    DatePickerState datePickerState;\n}\n@property NSDictionary * user;\n\n// Top Part\n@property (weak, nonatomic) IBOutlet UIImageView *ProfPic;\n@property (weak, nonatomic) IBOutlet UIImageView *parkingSpotView;\n@property (weak, nonatomic) IBOutlet UILabel *nameLabel;\n@property (weak, nonatomic) IBOutlet UILabel *ratingLabel;\n@property (weak, nonatomic) IBOutlet UILabel *numPrevParkers;\n\n// Middle Part\n@property (weak, nonatomic) IBOutlet UILabel *numHours;\n@property (weak, nonatomic) IBOutlet UILabel *price;\n@property (weak, nonatomic) IBOutlet UILabel *address;\n@property (weak, nonatomic) IBOutlet MKMapView *parkingMapView;\n\n\n// Bottom Part\n@property (weak, nonatomic) IBOutlet UILabel *totalWantedHours;\n@property (weak, nonatomic) IBOutlet UILabel *totalAmount;\n@property (weak, nonatomic) IBOutlet UIButton *startTime;\n@property (weak, nonatomic) IBOutlet UIButton *endTime;\n@property (weak, nonatomic) IBOutlet UIButton *reserveButton;\n\n- (id) initWithMapView: (MKMapView *) currentMapView andUser: (NSDictionary *) usr;\n- (IBAction)reserveButtonPressed:(id)sender;\n\n// ------ TOP SECTION ------//\n// User Name\n- (NSString *) getUserName ;\n- (void) setUserName:(NSString *) name;\n\n// Rating\n- (int) getRating ;\n- (void) setRating:(int) rating;\n\n// Number of parkers\n- (int) getNumParkers ;\n- (void) setNumParkers:(int) numParkers ;\n\n// Profile picture\n- (NSString *) getProfPic ;\n- (void) setProfilePic:(NSString *)profPic ;\n\n// Driveway picture\n- (NSString *) getDrivewayPic ;\n- (void) setDrivewayPic:(NSString *)parkingView;\n\n// ------ MIDDLE SECTION ------//\n\n// Hours Available\n- (NSString *) getHoursAvailable ;\n- (void) setHoursAvailable:(NSString *) hours;\n// Hourly Rate\n- (double) getHourlyRate;\n- (void) setHourlyRate:(double) rate ;\n// Address\n- (NSString *) getAddress;\n- (void) setTheAddress:(NSString *) addr;\n\n// ------ BOTTOM SECTION ------//\n\n// Wanted Hours\n- (float) getNumWantedHours;\n- (void) setNumWantedHours:(float) wntd;\n\n// Price\n- (double) getTotalPrice ;\n- (void) setTotalPrice:(double) pr;\n\n// Start Time\n- (NSDate *) getStartTime ;\n- (void) setTheStartTime:(NSDate *) date ;\n\n// End Time\n- (NSDate *) getEndTime ;\n- (void) setTheEndTime:(NSDate *) date;\n\n\n@end\n\n", "comment_ratio": 0.25773195876288657}
{"lang": "c", "code": "@protocol ACCBLEPairingXPCClientProtocol;\n@class NSXPCConnection, ACCBLEPairingServerRemote, NSString, NSArray;\n\n@interface _ACCBLEPairingProviderInfo : NSObject {\n\n\tNSXPCConnection* _connection;\n\tid<ACCBLEPairingXPCClientProtocol> _remoteObject;\n\tACCBLEPairingServerRemote* _serverRemote;\n\tNSString* _providerUID;\n\tNSArray* _supportedPairingTypes;\n\n}\n\n@property (nonatomic,retain) NSXPCConnection * connection;                                 //@synthesize connection=_connection - In the implementation block\n@property (nonatomic,retain) id<ACCBLEPairingXPCClientProtocol> remoteObject;              //@synthesize remoteObject=_remoteObject - In the implementation block\n@property (nonatomic,retain) ACCBLEPairingServerRemote * serverRemote;                     //@synthesize serverRemote=_serverRemote - In the implementation block\n@property (nonatomic,retain) NSString * providerUID;                                       //@synthesize providerUID=_providerUID - In the implementation block\n@property (nonatomic,retain) NSArray * supportedPairingTypes;                              //@synthesize supportedPairingTypes=_supportedPairingTypes - In the implementation block\n-(id)description;\n-(id)init;\n-(void)dealloc;\n-(void)setConnection:(NSXPCConnection *)arg1 ;\n-(NSXPCConnection *)connection;\n-(id<ACCBLEPairingXPCClientProtocol>)remoteObject;\n-(void)setRemoteObject:(id<ACCBLEPairingXPCClientProtocol>)arg1 ;\n-(ACCBLEPairingServerRemote *)serverRemote;\n-(void)setServerRemote:(ACCBLEPairingServerRemote *)arg1 ;\n-(NSString *)providerUID;\n-(void)setProviderUID:(NSString *)arg1 ;\n-(NSArray *)supportedPairingTypes;\n-(void)setSupportedPairingTypes:(NSArray *)arg1 ;\n@end\n\n\n", "comment_ratio": 0.11627906976744186}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n\nNS_ASSUME_NONNULL_BEGIN\n\ntypedef NS_ENUM(NSInteger, MKSPDeviceModelState) {\n    MKSPDeviceModelStateOffline,\n    MKSPDeviceModelStateOnline,\n};\n\n//\u5f53\u8bbe\u5907\u79bb\u7ebf\u7684\u65f6\u5019\u53d1\u51fa\u901a\u77e5\nextern NSString *const MKSPDeviceModelOfflineNotification;\n\n@protocol MKSPDeviceModelDelegate <NSObject>\n\n/// \u5f53\u524d\u8bbe\u5907\u79bb\u7ebf\n/// @param deviceID \u5f53\u524d\u8bbe\u5907\u7684deviceID\n- (void)sp_deviceOfflineWithDeviceID:(NSString *)deviceID;\n\n@end\n\n@interface MKSPDeviceModel : NSObject\n\n/// \u8bbe\u5907\u7c7b\u578b    00:MK107    02:MK107P\n@property (nonatomic, copy)NSString *deviceType;\n\n/**\n \u6570\u636e\u4ea4\u4e92\u53ef\u80fd\u5b58\u5728\u591a\u4e2a\u8bbe\u5907\u8ba2\u9605\u540c\u4e00\u4e2atopic\u7684\u60c5\u51b5\uff0c\u8fd9\u4e2a\u65f6\u5019\u53ea\u80fd\u901a\u8fc7deviceID\u533a\u5206\u8bbe\u5907\uff0c\u6240\u4ee5\u7edf\u4e00\u4e3atopic+deviceID\u6765\u533a\u5206\u901a\u4fe1\u6570\u636e\n */\n@property (nonatomic, copy)NSString *deviceID;\n\n/// MTQQ\u901a\u4fe1\u6240\u9700\u7684ID\uff0c\u5982\u679c\u5b58\u5728\u91cd\u590d\u7684\uff0c\u4f1a\u51fa\u73b0\u4ea4\u66ff\u4e0a\u7ebf\u7684\u60c5\u51b5\n@property (nonatomic, copy)NSString *clientID;\n\n/**\n \u8bbe\u5907\u5e7f\u64ad\u540d\u5b57\n */\n@property (nonatomic, copy)NSString *deviceName;\n\n/**\n \u8ba2\u9605\u4e3b\u9898\n */\n@property (nonatomic, copy)NSString *subscribedTopic;\n\n/**\n \u53d1\u5e03\u4e3b\u9898\n */\n@property (nonatomic, copy)NSString *publishedTopic;\n\n/**\n mac\u5730\u5740\n */\n@property (nonatomic, copy)NSString *macAddress;\n\n/**\n \u8bbe\u5907\u7684\u72b6\u6001\uff0c\u79bb\u7ebf\u3001\u5728\u7ebf\n */\n@property (nonatomic, assign)MKSPDeviceModelState onLineState;\n\n#pragma mark - \u4e1a\u52a1\u6d41\u7a0b\u76f8\u5173\n\n@property (nonatomic, weak)id <MKSPDeviceModelDelegate>delegate;\n\n/**\n \u5f53\u524dmodel\u7684\u8ba2\u9605\u4e3b\u9898\uff0c\u5f53\u7528\u6237\u8bbe\u7f6e\u4e86app\u7684\u8ba2\u9605\u4e3b\u9898\u65f6\uff0c\u8fd4\u56de\u8bbe\u7f6e\u7684\u8ba2\u9605\u4e3b\u9898\uff0c\u5426\u5219\u8fd4\u56de\u5f53\u524dmodel\u7684\u8ba2\u9605\u4e3b\u9898\n \n @return subscribedTopic\n */\n- (NSString *)currentSubscribedTopic;\n\n/**\n \u5f53\u524dmodel\u7684\u53d1\u5e03\u4e3b\u9898\uff0c\u5f53\u7528\u6237\u8bbe\u7f6e\u4e86app\u7684\u53d1\u5e03\u4e3b\u9898\u65f6\uff0c\u8fd4\u56de\u8bbe\u7f6e\u7684\u53d1\u5e03\u4e3b\u9898\uff0c\u5426\u5219\u8fd4\u56de\u5f53\u524dmodel\u7684\u53d1\u5e03\u4e3b\u9898\n \n @return publishedTopic\n */\n- (NSString *)currentPublishedTopic;\n\n/**\n \u8bbe\u5907\u5217\u8868\u9875\u9762\u7684\u72b6\u6001\u76d1\u63a7\n */\n- (void)startStateMonitoringTimer;\n\n/**\n \u63a5\u6536\u5230\u5f00\u5173\u72b6\u6001\u7684\u65f6\u5019\uff0c\u9700\u8981\u6e05\u9664\u79bb\u7ebf\u72b6\u6001\u8ba1\u6570\n */\n- (void)resetTimerCounter;\n\n/**\n \u53d6\u6d88\u5b9a\u65f6\u5668\n */\n- (void)cancel;\n\n@end\n\nNS_ASSUME_NONNULL_END\n\n", "comment_ratio": 0.11650485436893204}
{"lang": "c", "code": "#import <UXKit/NSObject-Protocol.h>\n\n@class NSString, UXView, UXViewController;\n\n@protocol UXViewControllerTransitionCoordinatorContext <NSObject>\n- (UXView *)containerView;\n- (UXViewController *)viewControllerForKey:(NSString *)arg1;\n- (long long)completionCurve;\n- (double)completionVelocity;\n- (double)percentComplete;\n- (double)transitionDuration;\n- (BOOL)isCancelled;\n- (BOOL)isInteractive;\n- (BOOL)initiallyInteractive;\n- (long long)presentationStyle;\n- (BOOL)isAnimated;\n@end\n\n\n", "comment_ratio": 0.2}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface HomeBannerCollectionViewCell : UICollectionViewCell\n\n@property(nonatomic,strong)NSMutableArray * ImgListArray;\n\n@property (nonatomic,copy) void(^SdClyImgBlockClick)(NSInteger ImgIndex);\n\n@end\n\nNS_ASSUME_NONNULL_END\n\n", "comment_ratio": 0.3181818181818182}
{"lang": "c", "code": "#pragma once\n\n#include \"dml_common.h\"\n#include \"dml_event_queue.h\"\n#include \"dml_execution_context.h\"\n#include \"dml_pooled_heap.h\"\n\nnamespace tensorflow {\nclass DmlExecutionContext;\n\n// Performs non-blocking readback from GPU resources. This class is thread-safe.\nclass DmlReadbackHeap : public DmlPooledHeap {\n public:\n  DmlReadbackHeap(ID3D12Device* device, DmlExecutionContext* execution_context,\n                  DmlEventQueue* event_queue);\n\n  // Copies data from the specified GPU resource into CPU memory pointed-to by\n  // the span. This is non-blocking; the copy is not complete until the returned\n  // event becomes signaled. Both the dst buffer and src resource must stay\n  // alive until the copy is complete.\n  StatusOr<DmlGpuEvent> ReadbackFromGpu(absl::Span<uint8_t> dst,\n                                        const D3D12BufferRegion& src);\n\n private:\n  std::mutex mutex_;\n  DmlExecutionContext* execution_context_;  // weak; owned by DmlDeviceState\n  DmlEventQueue* event_queue_;              // weak; owned by DmlDeviceState\n\n  // We maintain a completion event independent of the execution context,\n  // because the execution context's completion event only tells you when the\n  // copy to the readback heap has completed, whereas what the caller cares\n  // about is whether the copy to the `dst` buffer is complete.\n  DmlGpuEvent current_completion_event_;\n};\n\n}  // namespace tensorflow\n\n", "comment_ratio": 0.25}
{"lang": "c", "code": "#ifndef SLING_NLP_WIKI_NAME_TABLE_H_\n#define SLING_NLP_WIKI_NAME_TABLE_H_\n\n#include <string>\n#include <vector>\n\n#include \"sling/base/types.h\"\n#include \"sling/file/repository.h\"\n#include \"sling/string/text.h\"\n#include \"sling/util/unicode.h\"\n\nnamespace sling {\nnamespace nlp {\n\n// Name table for looking up entities based on name prefix.\nclass NameTable {\n public:\n  // Load name repository from file.\n  void Load(const string &filename);\n\n  // Look up entities with names matching a prefix. The matches are sorted\n  // by decreasing entity frequency.\n  void LookupPrefix(Text prefix, int limit, int boost,\n                    std::vector<Text> *matches) const;\n\n private:\n  // Entity name with offset and frequency.\n  struct EntityName {\n    uint32 offset;\n    uint32 count;\n  };\n\n  // Entity item in repository.\n  class EntityItem : public RepositoryObject {\n   public:\n    // Entity id.\n    Text id() const { return Text(id_ptr(), *idlen_ptr()); }\n\n    // Entity frequency.\n    uint32 count() const { return *count_ptr(); }\n\n   private:\n    // Entity frequency.\n    REPOSITORY_FIELD(uint32, count, 1, 0);\n\n    // Entity id.\n    REPOSITORY_FIELD(uint8, idlen, 1, AFTER(count));\n    REPOSITORY_FIELD(char, id, *idlen_ptr(), AFTER(idlen));\n  };\n\n  // Name item in repository.\n  class NameItem : public RepositoryObject {\n   public:\n    // Return name.\n    Text name() const { return Text(name_ptr(), *namelen_ptr()); }\n\n    // Return number of entities matching name.\n    int num_entities() const { return *entlen_ptr(); }\n\n    // Return array of entity names.\n    const EntityName *entities() const { return entities_ptr(); }\n\n   private:\n    // Name.\n    REPOSITORY_FIELD(uint8, namelen, 1, 0);\n    REPOSITORY_FIELD(char, name, *namelen_ptr(), AFTER(namelen));\n\n    // Entity list.\n    REPOSITORY_FIELD(uint32, entlen, 1, AFTER(name));\n    REPOSITORY_FIELD(EntityName, entities, num_entities(), AFTER(entlen));\n  };\n\n  // Name index in repository.\n  class NameIndex : public RepositoryIndex<uint32, NameItem> {\n   public:\n    // Initialize name index.\n    void Initialize(const Repository &repository) {\n      Init(repository, \"Index\", \"Names\", false);\n    }\n\n    // Return name from name index.\n    const NameItem *GetName(int index) const {\n      return GetObject(index);\n    }\n  };\n\n  // Get entity from entity table.\n  const EntityItem *GetEntity(uint32 offset) const {\n    return reinterpret_cast<const EntityItem *>(entity_table_ + offset);\n  }\n\n  // Repository with name table.\n  Repository repository_;\n\n  // Name index.\n  NameIndex name_index_;\n\n  // Entity table.\n  const char *entity_table_ = nullptr;\n\n  // Text normalization flags.\n  Normalization normalization_ = NORMALIZE_DEFAULT;\n};\n\n}  // namespace nlp\n}  // namespace sling\n\n#endif  // SLING_NLP_WIKI_NAME_TABLE_H_\n\n\n", "comment_ratio": 0.3225806451612903}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface MADBannerViewController : UIViewController\n\n@end\n\nNS_ASSUME_NONNULL_END\n\n", "comment_ratio": 0.3888888888888889}
{"lang": "c", "code": "#ifndef __ELASTOS_DROID_SERVER_CCONSUMERIR_SERVICE_H__\n#define __ELASTOS_DROID_SERVER_CCONSUMERIR_SERVICE_H__\n\n#include \"elastos/droid/ext/frameworkext.h\"\n#include \"_Elastos_Droid_Server_CConsumerIrService.h\"\n#include <elastos/core/Object.h>\n\nusing Elastos::Droid::Content::IContext;\nusing Elastos::Droid::Content::Pm::IPackageManager;\nusing Elastos::Droid::Hardware::IIConsumerIrService;\nusing Elastos::Droid::Os::IBinder;\nusing Elastos::Droid::Os::IPowerManager;\nusing Elastos::Droid::Os::IPowerManagerWakeLock;\n\nnamespace Elastos {\nnamespace Droid {\nnamespace Server {\n\nCarClass(CConsumerIrService)\n    , public Object\n    , public IIConsumerIrService\n    , public IBinder\n{\npublic:\n    CAR_INTERFACE_DECL()\n\n    CAR_OBJECT_DECL()\n\n    CConsumerIrService();\n\n    virtual ~CConsumerIrService();\n\n    CARAPI constructor(\n        /* [in] */ IContext* context);\n\n    //@Override\n    CARAPI HasIrEmitter(\n        /* [out] */ Boolean* result);\n\n    CARAPI ThrowIfNoIrEmitter();\n\n\n    //@Override\n    CARAPI Transmit(\n        /* [in] */ const String& packageName,\n        /* [in] */ Int32 carrierFrequency,\n        /* [in] */ ArrayOf<Int32>* pattern);\n\n    //@Override\n    CARAPI GetCarrierFrequencies(\n        /* [out, callee] */ ArrayOf<Int32>** result);\n\n    CARAPI ToString(\n        /* [out] */ String* str);\nprivate:\n\n    static Int64 HalOpen();\n\n    static Int32 HalTransmit(\n        /* [in] */ Int64 halObject,\n        /* [in] */ Int32 carrierFrequency,\n        /* [in] */ ArrayOf<Int32>* pattern);\n\n    static AutoPtr<ArrayOf<Int32> >  HalGetCarrierFrequencies(\n        /* [in] */ Int64 halObject);\n\nprivate:\n    static const String TAG;\n\n    static const Int32 MAX_XMIT_TIME; /* in microseconds */\n\n    AutoPtr<IContext> mContext;\n    AutoPtr<IPowerManagerWakeLock> mWakeLock;\n    Int64 mNativeHal;\n    Object mHalLock;\n};\n\n\n} // Server\n} // Droid\n} // Elastos\n\n#endif //__ELASTOS_DROID_SERVER_CALARMMANAGERSERVICE_H__\n\n", "comment_ratio": 0.22}
{"lang": "c", "code": "#ifndef SRC_DB_IO_READ_LEF_H_\n#define SRC_DB_IO_READ_LEF_H_\n\n#include \"db/core/cell.h\"\n#include \"db/tech/export_tech.h\"\n#include \"db/tech/layer.h\"\n#include \"db/tech/max_via_stack.h\"\n#include \"db/tech/ndr_rule.h\"\n#include \"db/tech/site.h\"\n#include \"db/tech/tech.h\"\n#include \"db/tech/via_master.h\"\n#include \"db/tech/via_rule.h\"\n#include \"parser/lef/lef/lefiDebug.hpp\"\n#include \"parser/lef/lef/lefiEncryptInt.hpp\"\n#include \"parser/lef/lef/lefiUtil.hpp\"\n#include \"parser/lef/lef/lefrReader.hpp\"\n#include \"parser/lef/lef/lefwWriter.hpp\"\n\nnamespace open_edi {\nnamespace db {\n\n// add tech features\nint readLef(int argc, const char** argv);\n\n// LAYER\nint readLayer(lefiLayer* io_layer);\nint readLayerRule(lefiLayer* io_layer, Layer* edi_layer);\n// int setMetalLayerRule(lefiLayer* io_layer, Layer *edi_layer);\n// int setCutLayerRule(lefiLayer* io_layer, Layer *edi_layer);\n// int setTrimLayerRule(lefiLayer* io_layer, Layer *edi_layer);\n\n// SITE\nint readSite(lefiSite* io_site);\n\n// MACRO\n\n// NDR\nint readNonDefaultRule(lefiNonDefault* io_ndr_rule);\n// VIA/VIARULE\nint readViaMaster(lefiVia* io_via, bool is_from_ndr = false);\nint readViaRule(lefiViaRule* io_via);\n// UNITS\nint readUnit(lefiUnits* io_units);\n// PROPERTY DEFINITION\nint readPropertyDefinition(lefiProp* io_prop);\n\n}  // namespace db\n}  // namespace open_edi\n\n#endif  // SRC_DB_IO_READ_LEF_H_\n\n", "comment_ratio": 0.22950819672131148}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n\n@interface UIView (Extension)\n\n@property (nonatomic, assign) CGFloat x;\n\n@property (nonatomic, assign) CGFloat y;\n\n@property (nonatomic, assign) CGFloat centerX;\n\n@property (nonatomic, assign) CGFloat centerY;\n\n@property (nonatomic, assign) CGFloat width;\n\n@property (nonatomic, assign) CGFloat height;\n\n@property (nonatomic, assign) CGSize size;\n\n@property (nonatomic, assign) CGPoint origin;\n\n@end\n\n", "comment_ratio": 0.28125}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n\n@interface ViewController : UIViewController\n\n@property (weak, nonatomic) IBOutlet UIImageView *backImageView;\n@property (weak, nonatomic) IBOutlet UISlider *sliderBar;\n\n@end\n\n\n", "comment_ratio": 0.3888888888888889}
{"lang": "c", "code": "#import <GPKGFeatureOverlay.h>\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface BaseMapOverlay : GPKGFeatureOverlay\n\n@property (nonatomic) BOOL darkTheme;\n\n@end\n\nNS_ASSUME_NONNULL_END\n\n", "comment_ratio": 0.35}
{"lang": "c", "code": "#pragma once\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define LIS3DH_DEFAULT_I2C_BUS 0\n#define LIS3DH_DEFAULT_SPI_BUS 0\n#define LIS3DH_DEFAULT_I2C_ADDR 0x18\n\n#define LIS3DH_CHIPID 0x33\n\n// NOTE: Reserved registers must not be written into or permanent\n// damage can result. Reading from them may return indeterminate\n// values. Registers containing reserved bitfields must be\n// written as 0, except for CTRL_REG0 - see datasheet for that one.\n\n/**\n * LIS3DH registers\n */\ntypedef enum {\n    // 0x00-0x06 reserved\n\n    LIS3DH_REG_STATUS_REG_AUX = 0x07,\n\n    LIS3DH_REG_OUT_ADC1_L = 0x08,\n    LIS3DH_REG_OUT_ADC1_H = 0x09,\n    LIS3DH_REG_OUT_ADC2_L = 0x0A,\n    LIS3DH_REG_OUT_ADC2_H = 0x0B,\n    LIS3DH_REG_OUT_ADC3_L = 0x0C,\n    LIS3DH_REG_OUT_ADC3_H = 0x0D,\n\n    // 0x0E reserved\n\n    LIS3DH_REG_WHO_AM_I = 0x0F,\n\n    // 0x10-0x1D reserved\n\n    LIS3DH_REG_CTRL_REG0 = 0x1E,\n    LIS3DH_REG_TEMP_CFG_REG = 0x1F,\n    LIS3DH_REG_CTRL_REG1 = 0x20,\n    LIS3DH_REG_CTRL_REG2 = 0x21,\n    LIS3DH_REG_CTRL_REG3 = 0x22,\n    LIS3DH_REG_CTRL_REG4 = 0x23,\n    LIS3DH_REG_CTRL_REG5 = 0x24,\n    LIS3DH_REG_CTRL_REG6 = 0x25,\n\n    LIS3DH_REG_REFERENCE = 0x26,\n\n    LIS3DH_REG_STATUS_REG = 0x27,\n\n    LIS3DH_REG_OUT_X_L = 0x28,\n    LIS3DH_REG_OUT_X_H = 0x29,\n    LIS3DH_REG_OUT_Y_L = 0x2A,\n    LIS3DH_REG_OUT_Y_H = 0x2B,\n    LIS3DH_REG_OUT_Z_L = 0x2C,\n    LIS3DH_REG_OUT_Z_H = 0x2D,\n\n    LIS3DH_REG_FIFO_CTRL_REG = 0x2E,\n    LIS3DH_REG_FIFO_SRC_REG = 0x2F,\n\n    LIS3DH_REG_INT1_CFG = 0x30,\n    LIS3DH_REG_INT1_SRC = 0x31,\n    LIS3DH_REG_INT1_THS = 0x32,\n    LIS3DH_REG_INT1_DURATION = 0x33,\n\n    LIS3DH_REG_INT2_CFG = 0x34,\n    LIS3DH_REG_INT2_SRC = 0x35,\n    LIS3DH_REG_INT2_THS = 0x36,\n    LIS3DH_REG_INT2_DURATION = 0x37,\n\n    LIS3DH_REG_CLICK_CFG = 0x38,\n    LIS3DH_REG_CLICK_SRC = 0x39,\n    LIS3DH_REG_CLICK_THS = 0x3A,\n\n    LIS3DH_REG_TIME_LIMIT = 0x3B,\n    LIS3DH_REG_TIME_LATENCY = 0x3C,\n    LIS3DH_REG_TIME_WINDOW = 0x3D,\n\n    LIS3DH_REG_ACT_THS = 0x3E,\n    LIS3DH_REG_ACT_DUR = 0x3F,\n} LIS3DH_REGS_T;\n\n/**\n * REG_STATUS_REG_AUX bits\n */\ntypedef enum {\n    LIS3DH_STATUS_REG_AUX_1DA = 0x01,\n    LIS3DH_STATUS_REG_AUX_2DA = 0x02,\n    LIS3DH_STATUS_REG_AUX_3DA = 0x04,\n    LIS3DH_STATUS_REG_AUX_321DA = 0x08,\n\n    LIS3DH_STATUS_REG_AUX_1OR = 0x10,\n    LIS3DH_STATUS_REG_AUX_2OR = 0x20,\n    LIS3DH_STATUS_REG_AUX_3OR = 0x40,\n    LIS3DH_STATUS_REG_AUX_321OR = 0x80,\n} LIS3DH_STATUS_REG_AUX_BITS_T;\n\n/**\n * REG_CTRL_REG0 bits\n */\ntypedef enum {\n    // 0x01-0x40 reserved\n\n    LIS3DH_CTRL_REG0_SDO_PU_DISC = 0x80,\n} LIS3DH_CTRL_REG0_BITS_T;\n\n/**\n * REG_TEMP_CFG_REG bits\n */\ntypedef enum {\n    // 0x01-0x20 reserved\n\n    LIS3DH_TEMP_CFG_REG_TEMP_EN = 0x40,\n    LIS3DH_TEMP_CFG_REG_ADC_EN = 0x80,\n} LIS3DH_TEMP_CFG_REG_BITS_T;\n\n/**\n * REG_CTRL_REG1 bits\n */\ntypedef enum {\n    LIS3DH_CTRL_REG1_XEN = 0x01,\n    LIS3DH_CTRL_REG1_YEN = 0x02,\n    LIS3DH_CTRL_REG1_ZEN = 0x04,\n    LIS3DH_CTRL_REG1_LPEN = 0x08,\n\n    LIS3DH_CTRL_REG1_ODR0 = 0x10,\n    LIS3DH_CTRL_REG1_ODR1 = 0x20,\n    LIS3DH_CTRL_REG1_ODR2 = 0x40,\n    LIS3DH_CTRL_REG1_ODR3 = 0x80,\n    _LIS3DH_CTRL_REG1_ODR_MASK = 0xF,\n    _LIS3DH_CTRL_REG1_ODR_SHIFT = 4,\n} LIS3DH_CTRL_REG1_BITS_T;\n\n/**\n * CTRL_REG1_ODR (Output Data Rate) values\n */\ntypedef enum {\n    LIS3DH_ODR_POWER_DOWN = 0x0, // 0b0000\n\n    // These are allowed in all modes (high resolution/normal/low power)\n    LIS3DH_ODR_1HZ = 0x1,   // 0b0001\n    LIS3DH_ODR_10HZ = 0x2,  // 0b0010\n    LIS3DH_ODR_25HZ = 0x3,  // 0b0011\n    LIS3DH_ODR_50HZ = 0x4,  // 0b0100\n    LIS3DH_ODR_100HZ = 0x5, // 0b0101\n    LIS3DH_ODR_200HZ = 0x6, // 0b0110\n    LIS3DH_ODR_400HZ = 0x7, // 0b0111\n\n    // The following two items have a dual meaning depending\n    // on whether the LPEN bit is set, but they use the same\n    // overlapping ODR values for the ODR bitfield. Since the\n    // bitfield is only 4 bits wide, we add a \"virtual\" 5th bit to\n    // indicate the LP versions. This is then screened out in the\n    // code and will set the LPEN bit according to what is selected\n    // here.\n\n    // CTRL_REG1_LPEN == 0 (high resolution/normal mode)\n    LIS3DH_ODR_1344HZ = 0x9, // 0b1001\n\n    // CTRL_REG1_LPEN == 1 (low power mode). Add 'virtual' bit 5\n    // value (0x10) for these LP modes, which we will detect and\n    // screen out in the driver. This simplifies the ODR API.\n    LIS3DH_ODR_5376HZ = (0x10 + 0x9), // 0b1001\n\n    // Low power-only mode, requires LPEN == 1, so add the virtual bit\n    LIS3DH_ODR_LP_1600HZ = (0x10 + 0x8), // 0b1000\n} LIS3DH_ODR_T;\n\n/**\n * REG_CTRL_REG2 bits\n */\ntypedef enum {\n    LIS3DH_CTRL_REG2_HP_IA1 = 0x01,\n    LIS3DH_CTRL_REG2_HP_IA2 = 0x02,\n    LIS3DH_CTRL_REG2_HPCLICK = 0x04,\n    LIS3DH_CTRL_REG2_FDS = 0x08,\n\n    LIS3DH_CTRL_REG2_HPCF0 = 0x10,\n    LIS3DH_CTRL_REG2_HPCF1 = 0x20,\n    _LIS3DH_CTRL_REG2_HPCF_MASK = 0x3, // 0b11\n    _LIS3DH_CTRL_REG2_HPCF_SHIFT = 4,\n\n    LIS3DH_CTRL_REG2_HPM0 = 0x40,\n    LIS3DH_CTRL_REG2_HPM1 = 0x80,\n    _LIS3DH_CTRL_REG2_HPM_MASK = 0x3, // 0b11\n    _LIS3DH_CTRL_REG2_HPM_SHIFT = 6,\n} LIS3DH_CTRL_REG2_BITS_T;\n\n/**\n * CTRL_REG2_HPM (High-pass filter mode) values\n */\ntypedef enum {\n    LIS3DH_HPM_NORMAL_RST_REF_READ = 0x0, // 0b00, Normal mode (reset by reading REFERENCE)\n    LIS3DH_HPM_REF_SIGNAL = 0x1,          // 0b01, Reference signal for filtering\n    LIS3DH_HPM_NORMAL = 0x2,              // 0b10, Normal mode\n    LIS3DH_HPM_AUTORST = 0x3,             // 0b11, Autoreset on interrupt event\n} LIS3DH_HPM_T;\n\n/**\n * REG_CTRL_REG3 bits\n */\ntypedef enum {\n    // 0x01 reserved\n\n    LIS3DH_CTRL_REG3_I1_OVERRUN = 0x02,\n    LIS3DH_CTRL_REG3_I1_WTM = 0x04,\n    LIS3DH_CTRL_REG3_I1_321DA = 0x08,\n    LIS3DH_CTRL_REG3_I1_ZYXDA = 0x10,\n    LIS3DH_CTRL_REG3_I1_IA2 = 0x20,\n    LIS3DH_CTRL_REG3_I1_IA1 = 0x40,\n    LIS3DH_CTRL_REG3_I1_CLICK = 0x80,\n} LIS3DH_CTRL_REG3_BITS_T;\n\n/**\n * REG_CTRL_REG4 bits\n */\ntypedef enum {\n    LIS3DH_CTRL_REG4_SIM = 0x01,\n\n    LIS3DH_CTRL_REG4_ST0 = 0x02,\n    LIS3DH_CTRL_REG4_ST1 = 0x04,\n    _LIS3DH_CTRL_REG4_ST_MASK = 0x3, // 0b11\n    _LIS3DH_CTRL_REG4_ST_SHIFT = 1,\n\n    LIS3DH_CTRL_REG4_HR = 0x08,\n\n    LIS3DH_CTRL_REG4_FS0 = 0x10,\n    LIS3DH_CTRL_REG4_FS1 = 0x20,\n    _LIS3DH_CTRL_REG4_FS_MASK = 0x3, // 0b11\n    _LIS3DH_CTRL_REG4_FS_SHIFT = 4,\n\n    LIS3DH_CTRL_REG4_BLE = 0x40,\n    LIS3DH_CTRL_REG4_BDU = 0x80,\n} LIS3DH_CTRL_REG4_BITS_T;\n\n/**\n * CTRL_REG4_ST (Self Test) values\n */\ntypedef enum {\n    LIS3DH_ST_NORMAL = 0x0, // 0b00\n    LIS3DH_ST_ST0 = 0x1,    // 0b01\n    LIS3DH_ST_ST1 = 0x2,    // 0b10\n} LIS3DH_ST_T;\n\n/**\n * CTRL_REG4_FS (Full Scale) values\n */\ntypedef enum {\n    LIS3DH_FS_2G = 0x0,  // 0b00\n    LIS3DH_FS_4G = 0x1,  // 0b01\n    LIS3DH_FS_8G = 0x2,  // 0b10\n    LIS3DH_FS_16G = 0x3, // 0b11\n} LIS3DH_FS_T;\n\n/**\n * REG_CTRL_REG5 bits\n */\ntypedef enum {\n    LIS3DH_CTRL_REG5_D4D_INT2 = 0x01,\n    LIS3DH_CTRL_REG5_LIR_INT2 = 0x02,\n    LIS3DH_CTRL_REG5_D4D_INT1 = 0x04,\n    LIS3DH_CTRL_REG5_LIR_INT1 = 0x08,\n\n    // 0x10-0x20 reserved\n\n    LIS3DH_CTRL_REG5_FIFO_EN = 0x40,\n    LIS3DH_CTRL_REG5_BOOT = 0x80,\n} LIS3DH_CTRL_REG5_BITS_T;\n\n/**\n * REG_CTRL_REG6 bits\n */\ntypedef enum {\n    // 0x01 reserved\n\n    LIS3DH_CTRL_REG6_INT_POLARITY = 0x02,\n\n    // 0x04 reserved\n\n    LIS3DH_CTRL_REG6_I2_ACT = 0x08,\n    LIS3DH_CTRL_REG6_I2_BOOT = 0x10,\n    LIS3DH_CTRL_REG6_I2_IA2 = 0x20,\n    LIS3DH_CTRL_REG6_I2_IA1 = 0x40,\n    LIS3DH_CTRL_REG6_I2_CLICK = 0x80,\n} LIS3DH_CTRL_REG6_BITS_T;\n\n/**\n * REG_STATUS_REG bits\n */\ntypedef enum {\n    LIS3DH_STATUS_REG_XDA = 0x01,\n    LIS3DH_STATUS_REG_YDA = 0x02,\n    LIS3DH_STATUS_REG_ZDA = 0x04,\n    LIS3DH_STATUS_REG_ZYXDA = 0x08,\n\n    LIS3DH_STATUS_REG_XOR = 0x10,\n    LIS3DH_STATUS_REG_YOR = 0x20,\n    LIS3DH_STATUS_REG_ZOR = 0x40,\n    LIS3DH_STATUS_REG_ZYXOR = 0x80,\n} LIS3DH_STATUS_REG_BITS_T;\n\n/**\n * REG_FIFO_CTRL_REG bits\n */\ntypedef enum {\n    LIS3DH_FIFO_CTRL_REG_FTH0 = 0x01,\n    LIS3DH_FIFO_CTRL_REG_FTH1 = 0x02,\n    LIS3DH_FIFO_CTRL_REG_FTH2 = 0x04,\n    LIS3DH_FIFO_CTRL_REG_FTH3 = 0x08,\n    LIS3DH_FIFO_CTRL_REG_FTH4 = 0x10,\n    _LIS3DH_FIFO_CTRL_REG_FTH_MASK = 0x1F, // 0b11111\n    _LIS3DH_FIFO_CTRL_REG_FTH_SHIFT = 0,\n\n    LIS3DH_FIFO_CTRL_REG_TR = 0x20,\n\n    LIS3DH_FIFO_CTRL_REG_FM0 = 0x40,\n    LIS3DH_FIFO_CTRL_REG_FM1 = 0x80,\n    _LIS3DH_FIFO_CTRL_REG_FM_MASK = 0x3, // 0b11\n    _LIS3DH_FIFO_CTRL_REG_FM_SHIFT = 6,\n} LIS3DH_FIFO_CTRL_REG_BITS_T;\n\n/**\n * FIFO_CTRL_REG_FM (FIFO Mode) values\n */\ntypedef enum {\n    LIS3DH_FM_BYPASS = 0x0,         // 0b00\n    LIS3DH_FM_FIFO = 0x1,           // 0b01\n    LIS3DH_FM_STREAM = 0x2,         // 0b10\n    LIS3DH_FM_STREAM_TO_FIFO = 0x3, // 0b11\n} LIS3DH_FM_T;\n\n/**\n * REG_FIFO_SRC_REG bits\n */\ntypedef enum {\n    LIS3DH_FIFO_SRC_REG_FSS0 = 0x01,\n    LIS3DH_FIFO_SRC_REG_FSS1 = 0x02,\n    LIS3DH_FIFO_SRC_REG_FSS2 = 0x04,\n    LIS3DH_FIFO_SRC_REG_FSS3 = 0x08,\n    LIS3DH_FIFO_SRC_REG_FSS4 = 0x10,\n    _LIS3DH_FIFO_SRC_REG_FSS_MASK = 0x1F, // 0b11111\n    _LIS3DH_FIFO_SRC_REG_FSS_SHIFT = 0,\n\n    LIS3DH_FIFO_SRC_REG_EMPTY = 0x20,\n    LIS3DH_FIFO_SRC_REG_OVRN_FIFO = 0x40,\n    LIS3DH_FIFO_SRC_REG_WTM = 0x80,\n} LIS3DH_FIFO_SRC_REG_BITS_T;\n\n/**\n * REG_INT1_CFG bits\n */\ntypedef enum {\n    LIS3DH_INT1_CFG_XLIE = 0x01,\n    LIS3DH_INT1_CFG_XHIE = 0x02,\n\n    LIS3DH_INT1_CFG_YLIE = 0x04,\n    LIS3DH_INT1_CFG_YHIE = 0x08,\n\n    LIS3DH_INT1_CFG_ZLIE = 0x10,\n    LIS3DH_INT1_CFG_ZHIE = 0x20,\n\n    LIS3DH_INT1_CFG_6D = 0x40,\n    LIS3DH_INT1_CFG_AOI = 0x80,\n} LIS3DH_INT1_CFG_BITS_T;\n\n/**\n * REG_INT1_SRC bits\n */\ntypedef enum {\n    LIS3DH_INT1_SRC_XL = 0x01,\n    LIS3DH_INT1_SRC_XH = 0x02,\n\n    LIS3DH_INT1_SRC_YL = 0x04,\n    LIS3DH_INT1_SRC_YH = 0x08,\n\n    LIS3DH_INT1_SRC_ZL = 0x10,\n    LIS3DH_INT1_SRC_ZH = 0x20,\n\n    LIS3DH_INT1_SRC_IA = 0x40,\n\n    // 0x80 reserved\n} LIS3DH_INT1_SRC_BITS_T;\n\n/**\n * REG_INT2_CFG bits\n */\ntypedef enum {\n    LIS3DH_INT2_CFG_XLIE = 0x01,\n    LIS3DH_INT2_CFG_XHIE = 0x02,\n\n    LIS3DH_INT2_CFG_YLIE = 0x04,\n    LIS3DH_INT2_CFG_YHIE = 0x08,\n\n    LIS3DH_INT2_CFG_ZLIE = 0x10,\n    LIS3DH_INT2_CFG_ZHIE = 0x20,\n\n    LIS3DH_INT2_CFG_6D = 0x40,\n    LIS3DH_INT2_CFG_AOI = 0x80,\n} LIS3DH_INT2_CFG_BITS_T;\n\n/**\n * REG_INT2_SRC bits\n */\ntypedef enum {\n    LIS3DH_INT2_SRC_XL = 0x01,\n    LIS3DH_INT2_SRC_XH = 0x02,\n\n    LIS3DH_INT2_SRC_YL = 0x04,\n    LIS3DH_INT2_SRC_YH = 0x08,\n\n    LIS3DH_INT2_SRC_ZL = 0x10,\n    LIS3DH_INT2_SRC_ZH = 0x20,\n\n    LIS3DH_INT2_SRC_IA = 0x40,\n\n    // 0x80 reserved\n} LIS3DH_INT2_SRC_BITS_T;\n\n/**\n * REG_CLICK_CFG bits\n */\ntypedef enum {\n    LIS3DH_CLICK_CFG_XS = 0x01,\n    LIS3DH_CLICK_CFG_XD = 0x02,\n\n    LIS3DH_CLICK_CFG_YS = 0x04,\n    LIS3DH_CLICK_CFG_YD = 0x08,\n\n    LIS3DH_CLICK_CFG_ZS = 0x10,\n    LIS3DH_CLICK_CFG_ZD = 0x20,\n\n    // 0x40-0x80 reserved\n} LIS3DH_CLICK_CFG_BITS_T;\n\n/**\n * REG_CLICK_SRC bits\n */\ntypedef enum {\n    LIS3DH_CLICK_SRC_X = 0x01,\n    LIS3DH_CLICK_SRC_Y = 0x02,\n    LIS3DH_CLICK_SRC_Z = 0x04,\n\n    LIS3DH_CLICK_SRC_SIGN = 0x08,\n\n    LIS3DH_CLICK_SRC_SCLICK = 0x10,\n    LIS3DH_CLICK_SRC_DCLICK = 0x20,\n\n    LIS3DH_CLICK_SRC_IA = 0x40,\n\n    // 0x80 reserved\n} LIS3DH_CLICK_SRC_BITS_T;\n\n/**\n * REG_CLICK_THS bits\n */\ntypedef enum {\n    LIS3DH_CLICK_THS_THS0 = 0x01,\n    LIS3DH_CLICK_THS_THS1 = 0x02,\n    LIS3DH_CLICK_THS_THS2 = 0x04,\n    LIS3DH_CLICK_THS_THS3 = 0x08,\n    LIS3DH_CLICK_THS_THS4 = 0x10,\n    LIS3DH_CLICK_THS_THS5 = 0x20,\n    LIS3DH_CLICK_THS_THS6 = 0x40,\n    _LIS3DH_CLICK_THS_THS_MASK = 0x7F, // 0b1111111\n    _LIS3DH_CLICK_THS_THS_SHIFT = 0,\n\n    LIS3DH_CLICK_THS_LIR_CLICK = 0x80,\n} LIS3DH_CLICK_THS_BITS_T;\n\n// Interrupt selection for installISR() and uninstallISR()\ntypedef enum { LIS3DH_INTERRUPT_INT1, LIS3DH_INTERRUPT_INT2 } LIS3DH_INTERRUPT_PINS_T;\n\n#ifdef __cplusplus\n}\n#endif\n\n", "comment_ratio": 0.12845849802371542}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n\n@interface DJFavoriteView : UIView\n\n@property (nonatomic, retain) UITableView *tableView;\n\n\n\n@end\n\n", "comment_ratio": 0.3888888888888889}
{"lang": "c", "code": "#ifndef _WINUMMODULEBLOCK_H_\n#define _WINUMMODULEBLOCK_H_\n\n#include \"winpe.h\"\n\n///\n/// @brief  DllHandle, Reason and Reserved can be equal to #WINMODBLOCK_INVALID_VALUE when something that is not the\n/// entry point of the module (e.g. DllMain) is called.\n///\n#define WINMODBLOCK_INVALID_VALUE               0xFFFFFFFF\n\n\n///\n/// @brief  Used to provided blocking options\n///\ntypedef enum _WIN_MOD_BLOCK_FLAG\n{\n    winModBlockFlagUnloadAfterExec = 0x00000001u,   ///< Force the module to unload by returning FALSE.\n    winModBlockFlagDoNotUnload = 0x00000002u,       ///< Do not unload the module.\n    winModBlockFlagKillOnError = 0x00000004u        ///< Kill the process by injecting a \\#PF on CR2 0 if something\n                                 ///  fails.\n} WIN_MOD_BLOCK_FLAG;\n\n\n///\n/// @brief This callbacks provided detection logic for Windows module loads.\n///\n/// This callback type can be called for the following reasons:\n///     1) At every execution of a suspicious DLL which should be blocked, being mandatory registered through\n/// #IntWinModBlockBlockModuleLoad.\n///     2) On certain DllMain reasons, as requested by the user, callbacks which are being registered by calls to\n/// #IntWinModBlockRegisterCallbackForReason.\n///\n/// For the case 1) - DllHandle, Reason and Reserved can be equal to WINMODBLOCK_INVALID_VALUE\n/// when something that is not the entry point of the module (e.g. DllMain) is called.\n/// It is good practice for the callback to verify for DllHandle, Reason and Reserved being equal to\n/// WINMODBLOCK_INVALID_VALUE, especially when the callback does something regarding those parameters\n/// (e.g. verify reason or do something with the Reserved parameter).\n///\ntypedef INTSTATUS\n(*PFUNC_IntWinModBlockCallback)(\n    _In_ WIN_PROCESS_MODULE *Module,\n    _In_ void *BlockObject,\n    _In_ QWORD DllHandle,\n    _In_ QWORD Reason,\n    _In_ QWORD Reserved,\n    _In_ QWORD RetAddress,\n    _Inout_ INTRO_ACTION *Action\n    );\n\n///\n/// @brief  This callback type will be called for the suspicious module headers when they are swapped in.\n///\n/// It is used for getting auxiliary information on the module (e.g. on double agent it is needed for deciding\n/// a good address for putting the verifier structures needed for init).\n///\ntypedef INTSTATUS\n(*PFUNC_IntWinModBlockHeadersCallback)(\n    _Inout_ WIN_PROCESS_MODULE *Module,\n    _In_ BYTE *Headers\n    );\n\n///\n/// @brief  This callback type will be invoked when IntWinModBlockRemoveBlockObject is called for cleanup purposes.\n///\n/// It is strongly recommended that at least the block object is kept inside the module to be nullified when\n/// this is called.\n///\ntypedef INTSTATUS\n(*PFUNC_IntWinModBlockCleanup)(\n    _Inout_ WIN_PROCESS_MODULE *Module,\n    _In_ const void *BlockObject\n    );\n\n\nINTSTATUS\nIntWinModBlockBlockModuleLoad(\n    _In_ WIN_PROCESS_MODULE *Module,\n    _In_ WIN_MOD_BLOCK_FLAG Flags,\n    _In_ PFUNC_IntWinModBlockCallback Callback,\n    _In_opt_ PFUNC_IntWinModBlockHeadersCallback HeadersCallback,\n    _In_opt_ PFUNC_IntWinModBlockCleanup CleanupCallback,\n    _Inout_ void **BlockObject\n    );\n\n\nINTSTATUS\nIntWinModBlockRegisterCallbackForReason(\n    _In_ void *BlockObject,\n    _In_ DWORD Reason,\n    _In_ PFUNC_IntWinModBlockCallback Callback\n    );\n\n\nINTSTATUS\nIntWinModBlockRemoveBlockObject(\n    _Inout_ void *BlockObject\n    );\n\n#endif\n\n", "comment_ratio": 0.39285714285714285}
{"lang": "c", "code": "#ifndef DALI_TEST_DALI_TEST_UTILS_H_\n#define DALI_TEST_DALI_TEST_UTILS_H_\n\n#include <string>\n#include \"dali/core/tensor_shape.h\"\n#include \"dali/pipeline/data/backend.h\"\n#include \"dali/pipeline/data/tensor.h\"\n#include \"dali/pipeline/workspace/device_workspace.h\"\n\n\ntemplate <typename Enum>\nstd::string EnumToString(Enum value) {\n  return std::to_string(static_cast<std::underlying_type_t<Enum>>(value));\n}\n\nnamespace dali {\nnamespace test {\n\nstd::string CurrentExecutableDir();\n\n/**\n * @brief Produces a batch of ND random data\n *        with random shapes between a minimum and a maximum shape\n *\n * @param data output data\n * @param N number of samples\n * @param min_sh minimum shape\n * @param max_sh maximum shape\n */\nvoid MakeRandomBatch(TensorList<CPUBackend> &data, int N,\n                     const TensorShape<> &min_sh = TensorShape<>{10, 10, 3},\n                     const TensorShape<> &max_sh = TensorShape<>{20, 20, 3});\n\n/**\n * @brief Compares one of the output of a pipeline for the i-th iteration,\n *        with the appropriate sample in the dataset, assuming wrap-around behavior.\n *\n * @param ws workspace\n * @param batch_size batch size\n * @param i index of the iteration in the pipeline\n * @param data dataset used to drive the pipeline, the output of the pipeline should\n *             match those samples explicitly, and should wrap-around when reaching\n *             the end.\n * @param output_idx Index of the output in the workspace\n */\nvoid CheckResults(const DeviceWorkspace& ws, int batch_size, int i,\n                  TensorList<CPUBackend> &data, int output_idx = 0);\n\n}  // namespace test\n}  // namespace dali\n\n#endif  // DALI_TEST_DALI_TEST_UTILS_H_\n\n", "comment_ratio": 0.23880597014925373}
{"lang": "c", "code": "#if !defined(AFX_RIDGEVIEW_DLG_H__DDF68495_BEC1_4E36_A726_29E97D93EDA3__INCLUDED_)\n#define AFX_RIDGEVIEW_DLG_H__DDF68495_BEC1_4E36_A726_29E97D93EDA3__INCLUDED_\n\n#if _MSC_VER > 1000\n#pragma once\n#endif // _MSC_VER > 1000\n// RidgeView_dlg.h : header file\n//\n\n#include \"ColorBox.h\"\n#include \"CutoffOnly_dlg.h\"\n\n\n/////////////////////////////////////////////////////////////////////////////\n// CRidgeView_dlg dialog\n\nclass CRidgeView_dlg : public CCutoffOnly_dlg\n{\n  CColorBox m_color_box;\n  bool local_topo;\n\n// Construction\npublic:\n  CRidgeView_dlg(bool, CWnd *pParent = NULL);   // standard constructor\n\n// Dialog Data\n  //{{AFX_DATA(CRidgeView_dlg)\n  enum { IDD = IDD_RIDGE_VIEW };\n  CButton\tm_sadl_butn;\n  CButton\tm_peak_butn;\n  BOOL\tm_runoff;\n  BOOL\tm_basin_sadl;\n  BOOL\tm_peak;\n  BOOL\tm_saddle;\n  BOOL\tm_ridge_rot;\n  int\tm_topology;\n  //}}AFX_DATA\n  COLORREF m_color;\n\n// Overrides\n  // ClassWizard generated virtual function overrides\n  //{{AFX_VIRTUAL(CRidgeView_dlg)\n  protected:\n  virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support\n  //}}AFX_VIRTUAL\n\n// Implementation\nprotected:\n\n  // Generated message map functions\n  //{{AFX_MSG(CRidgeView_dlg)\n  afx_msg void OnPeak();\n  afx_msg void OnSaddle();\n  afx_msg void OnColor();\n  virtual BOOL OnInitDialog();\n  //}}AFX_MSG\n  DECLARE_MESSAGE_MAP()\n};\n\n//{{AFX_INSERT_LOCATION}}\n// Microsoft Visual C++ will insert additional declarations immediately before the previous line.\n\n#endif // !defined(AFX_RIDGEVIEW_DLG_H__DDF68495_BEC1_4E36_A726_29E97D93EDA3__INCLUDED_)\n\n", "comment_ratio": 0.4}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n#import \"TFTableSectionModel.h\"\n#import \"TFUILibMacro.h\"\n\n@interface TFTableViewHeaderFooterView : UITableViewHeaderFooterView\n\n/// \u70b9\u51fb\u540e\u56de\u8c03\n@property (nonatomic, copy) void (^touchAction)(void);\n\n/**\n *  cell\u6570\u636e\n */\n@property (nonatomic, strong) id data;\n\n/**\n *  \u4eceXIB\u83b7\u53d6view\n */\n+ (id)loadViewFromXib;\n\n/**\n *  \u521d\u59cb\u5316\u89c6\u56fe\n */\n- (void)initViews;\n\n/**\n *  \u81ea\u52a8\u5e03\u5c40\u89c6\u56fe\n */\n- (void)autolayoutViews;\n\n/**\n *  \u7ed1\u5b9a\u6570\u636e\n */\n- (void)bindData;\n\n/**\n *  \u8fd4\u56deview\u9ad8\u5ea6\n *\n *  @return view\u9ad8\u5ea6\n */\n- (CGFloat)viewHeight;\n\n/**\n *  \u83b7\u53d6view\u9ad8\u5ea6\n *\n *  @return view\u9ad8\u5ea6\n */\n+ (CGFloat)viewHeight;\n\n/**\n *  \u83b7\u53d6reusableIdentifier\n *\n *  @return reusableIdentifier\n */\n+(NSString*)reusableIdentifier;\n\n@end\n\n", "comment_ratio": 0.12307692307692308}
{"lang": "c", "code": "void __kl02z_mcu_init()\n{\n    // TODO\n//    /* Chip errata */\n//    CHIP_Init();\n//\n//    // init clock\n//    CMU_ClockDivSet(cmuClock_HF, cmuClkDiv_2);       // Set HF clock divider to /2 to keep core frequency < 32MHz\n//    CMU_OscillatorEnable(cmuOsc_HFXO, true, true);   // Enable XTAL Osc and wait to stabilize\n//    CMU_ClockSelectSet(cmuClock_HF, cmuSelect_HFXO); // Select HF XTAL osc as system clock source. 48MHz XTAL, but we divided the system clock by 2, therefore our HF clock will be 24MHz\n}\n\n\n", "comment_ratio": 0.23684210526315788}
{"lang": "c", "code": "#ifndef CHROME_BROWSER_VR_SERVICE_VR_DEVICE_MANAGER_H_\n#define CHROME_BROWSER_VR_SERVICE_VR_DEVICE_MANAGER_H_\n\n#include <stdint.h>\n\n#include <map>\n#include <memory>\n#include <vector>\n\n#include \"base/callback.h\"\n#include \"base/macros.h\"\n#include \"base/memory/ref_counted.h\"\n#include \"base/threading/thread_checker.h\"\n#include \"base/timer/timer.h\"\n#include \"chrome/browser/vr/service/vr_service_impl.h\"\n#include \"device/vr/public/mojom/vr_service.mojom.h\"\n#include \"device/vr/vr_device.h\"\n#include \"mojo/public/cpp/bindings/binding_set.h\"\n\nnamespace device {\nclass VRDeviceProvider;\n}\n\nnamespace vr {\n\nclass BrowserXrDevice;\n\n// Singleton used to provide the platform's VR devices to VRServiceImpl\n// instances.\nclass VRDeviceManager {\n public:\n  virtual ~VRDeviceManager();\n\n  // Returns the VRDeviceManager singleton.\n  static VRDeviceManager* GetInstance();\n  static bool HasInstance();\n  static void RecordVrStartupHistograms();\n\n  // Adds a listener for device manager events. VRDeviceManager does not own\n  // this object.\n  // Automatically connects all currently available VR devices by querying\n  // the device providers and, for each returned device, calling\n  // VRServiceImpl::ConnectDevice.\n  void AddService(VRServiceImpl* service);\n  void RemoveService(VRServiceImpl* service);\n\n protected:\n  using ProviderList = std::vector<std::unique_ptr<device::VRDeviceProvider>>;\n\n  // Used by tests to supply providers.\n  explicit VRDeviceManager(ProviderList providers);\n\n  // Used by tests to check on device state.\n  device::VRDevice* GetDevice(unsigned int index);\n\n  size_t NumberOfConnectedServices();\n\n private:\n  void InitializeProviders();\n  void OnProviderInitialized();\n  bool AreAllProvidersInitialized();\n\n  void AddDevice(device::VRDevice* device);\n  void RemoveDevice(device::VRDevice* device);\n\n  ProviderList providers_;\n\n  // VRDevices are owned by their providers, each correspond to a\n  // BrowserXrDevice that is owned by VRDeviceManager.\n  using DeviceMap = std::map<unsigned int, std::unique_ptr<BrowserXrDevice>>;\n  DeviceMap devices_;\n\n  bool providers_initialized_ = false;\n  size_t num_initialized_providers_ = 0;\n\n  std::set<VRServiceImpl*> services_;\n\n  THREAD_CHECKER(thread_checker_);\n\n  DISALLOW_COPY_AND_ASSIGN(VRDeviceManager);\n};\n\n}  // namespace vr\n\n#endif  // CHROME_BROWSER_VR_SERVICE_VR_DEVICE_MANAGER_H_\n\n", "comment_ratio": 0.18888888888888888}
{"lang": "c", "code": "#ifndef __ELASTOS_DROID_SERVER_TELECOM_CALLSMANAGERLISTENERBASE_H__\n#define __ELASTOS_DROID_SERVER_TELECOM_CALLSMANAGERLISTENERBASE_H__\n\n#include \"_Elastos.Droid.Server.Telecom.h\"\n#include <elastos/droid/ext/frameworkext.h>\n#include <elastos/core/Object.h>\n\nusing Elastos::Droid::Telecom::IAudioState;\n\nnamespace Elastos {\nnamespace Droid {\nnamespace Server {\nnamespace Telecom {\n\n/**\n * Provides a default implementation for listeners of CallsManager.\n */\nclass CallsManagerListenerBase\n    : public Object\n    , public ICallsManagerListener\n{\npublic:\n    CAR_INTERFACE_DECL()\n\n    // @Override\n    CARAPI OnCallAdded(\n        /* [in] */ ICall* call);\n\n    // @Override\n    CARAPI OnCallRemoved(\n        /* [in] */ ICall* call);\n\n    // @Override\n    CARAPI OnCallStateChanged(\n        /* [in] */ ICall* call,\n        /* [in] */ Int32 oldState,\n        /* [in] */ Int32 newState);\n\n    // @Override\n    CARAPI OnCallExtrasUpdated(\n        /* [in] */ ICall* call);\n\n    // @Override\n    CARAPI OnConnectionServiceChanged(\n        /* [in] */ ICall* call,\n        /* [in] */ IConnectionServiceWrapper* oldService,\n        /* [in] */ IConnectionServiceWrapper* newService);\n\n    // @Override\n    CARAPI OnIncomingCallAnswered(\n        /* [in] */ ICall* call);\n\n    // @Override\n    CARAPI OnIncomingCallRejected(\n        /* [in] */ ICall* call,\n        /* [in] */ Boolean rejectWithMessage,\n        /* [in] */ const String& textMessage);\n\n    // @Override\n    CARAPI OnForegroundCallChanged(\n        /* [in] */ ICall* oldForegroundCall,\n        /* [in] */ ICall* newForegroundCall);\n\n    // @Override\n    CARAPI OnAudioStateChanged(\n        /* [in] */ IAudioState* oldAudioState,\n        /* [in] */ IAudioState* newAudioState);\n\n    // @Override\n    CARAPI OnRingbackRequested(\n        /* [in] */ ICall* call,\n        /* [in] */ Boolean ringback);\n\n    // @Override\n    CARAPI OnIsConferencedChanged(\n        /* [in] */ ICall* call);\n\n    // @Override\n    CARAPI OnIsVoipAudioModeChanged(\n        /* [in] */ ICall* call);\n\n    // @Override\n    CARAPI OnVideoStateChanged(\n        /* [in] */ ICall* call);\n\n    // @Override\n    CARAPI OnCallSubstateChanged(\n        /* [in] */ ICall* call);\n\n    // @Override\n    CARAPI OnCanAddCallChanged(\n        /* [in] */ Boolean canAddCall);\n\n    // @Override\n    CARAPI OnProcessIncomingCall(\n        /* [in] */ ICall* call);\n};\n\n} // namespace Telecom\n} // namespace Server\n} // namespace Droid\n} // namespace Elastos\n\n#endif // __ELASTOS_DROID_SERVER_TELECOM_CALLSMANAGERLISTENERBASE_H__\n\n", "comment_ratio": 0.2975206611570248}
{"lang": "c", "code": "#pragma once\n//\n//    FILE: Prandom.h\n//  AUTHOR: Rob dot Tillaart at gmail dot com\n// VERSION: 0.1.4\n// PURPOSE: Arduino library for random numbers with Python Random interface\n//          The underlying pseudo-random number generator is a\n//          Multiply-with-carry method invented by George Marsaglia.\n//     URL: https://github.com/RobTillaart/Prandom\n//          https://docs.python.org/3/library/random.html\n//          https://www.pcg-random.org/\n\n\n#include \"Arduino.h\"\n\n#define PRANDOM_LIB_VERSION                 (F(\"0.1.4\"))\n\n\nclass Prandom\n{\npublic:\n  Prandom();\n  Prandom(uint32_t s);\n\n  void seed();\n  void seed(uint32_t s, uint32_t t = 2);  // Marsaglia need 2 seeds, but 1 will work too\n\n\n  // integer methods\n  //\n  uint32_t getrandbits(uint8_t n);\n  uint32_t randrange(uint32_t stop);\n  uint32_t randrange(uint32_t start, uint32_t stop, uint32_t step = 1);\n  // randint is inclusive end value\n  uint32_t randint(uint32_t start, uint32_t stop) { return randrange(start, stop + 1); };\n\n\n  // real distributions\n  //\n  float random(const float top = 1.0);\n  float uniform(float lo, float hi);\n  float triangular(float lo = 0, float hi = 1.0, float mid = 0.5);\n  float normalvariate(float mu = 0, float sigma = 1.0);\n  float lognormvariate(float mu = 0, float sigma = 1.0);\n  float gauss(float mu = 0, float sigma = 1.0);\n  float expovariate(float lambda);\n  float gammavariate(float alpha, float beta);\n  float betavariate(float alpha, float beta);\n  float paretovariate(float alpha);\n  float weibullvariate(float alpha, float beta);\n\n \n  // Circular distributions\n  //\n  // mu is mean angle in radians\n  // kappa is concentration parameter, 0 -> uniform.\n  float vonmisesvariate(float mu, float kappa = 0);\n\n\nprivate:\n\n  uint32_t _rndTime();\n  uint32_t _rnd(uint32_t n);\n\n  // Marsaglia 'constants'\n  uint32_t _m_w = 1;\n  uint32_t _m_z = 2;\n  uint32_t __random();\n};\n\n\n// -- END OF FILE --\n\n\n", "comment_ratio": 0.2972972972972973}
{"lang": "c", "code": "#import \"DemoRequestModelReformer.h\"\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface DemoRequestModel : DemoRequestModelReformer\n\n@property (nonatomic, copy) NSString *key1;\n@property (nonatomic, copy) NSString *key2;\n/** ...... */\n@property (nonatomic, copy) NSString *keyn;\n\n@end\n\nNS_ASSUME_NONNULL_END\n\n", "comment_ratio": 0.30434782608695654}
{"lang": "c", "code": "#ifndef WEBKIT_BROWSER_BLOB_BLOB_URL_REQUEST_JOB_H_\n#define WEBKIT_BROWSER_BLOB_BLOB_URL_REQUEST_JOB_H_\n\n#include <map>\n\n#include \"base/memory/scoped_ptr.h\"\n#include \"base/memory/weak_ptr.h\"\n#include \"net/http/http_byte_range.h\"\n#include \"net/http/http_status_code.h\"\n#include \"net/url_request/url_request_job.h\"\n#include \"webkit/browser/webkit_storage_browser_export.h\"\n#include \"webkit/common/blob/blob_data.h\"\n\nnamespace base {\nclass MessageLoopProxy;\n}\n\nnamespace fileapi {\nclass FileSystemContext;\n}\n\nnamespace net {\nclass DrainableIOBuffer;\nclass IOBuffer;\n}\n\nnamespace webkit_blob {\n\nclass FileStreamReader;\n\n// A request job that handles reading blob URLs.\nclass WEBKIT_STORAGE_BROWSER_EXPORT BlobURLRequestJob\n    : public net::URLRequestJob {\n public:\n  BlobURLRequestJob(net::URLRequest* request,\n                    net::NetworkDelegate* network_delegate,\n                    BlobData* blob_data,\n                    fileapi::FileSystemContext* file_system_context,\n                    base::MessageLoopProxy* resolving_message_loop_proxy);\n\n  // net::URLRequestJob methods.\n  virtual void Start() OVERRIDE;\n  virtual void Kill() OVERRIDE;\n  virtual bool ReadRawData(net::IOBuffer* buf,\n                           int buf_size,\n                           int* bytes_read) OVERRIDE;\n  virtual bool GetMimeType(std::string* mime_type) const OVERRIDE;\n  virtual void GetResponseInfo(net::HttpResponseInfo* info) OVERRIDE;\n  virtual int GetResponseCode() const OVERRIDE;\n  virtual void SetExtraRequestHeaders(\n      const net::HttpRequestHeaders& headers) OVERRIDE;\n\n protected:\n  virtual ~BlobURLRequestJob();\n\n private:\n  typedef std::map<size_t, FileStreamReader*> IndexToReaderMap;\n\n  // For preparing for read: get the size, apply the range and perform seek.\n  void DidStart();\n  bool AddItemLength(size_t index, int64 item_length);\n  void CountSize();\n  void DidCountSize(int error);\n  void DidGetFileItemLength(size_t index, int64 result);\n  void Seek(int64 offset);\n\n  // For reading the blob.\n  bool ReadLoop(int* bytes_read);\n  bool ReadItem();\n  void AdvanceItem();\n  void AdvanceBytesRead(int result);\n  bool ReadBytesItem(const BlobData::Item& item, int bytes_to_read);\n  bool ReadFileItem(FileStreamReader* reader, int bytes_to_read);\n\n  void DidReadFile(int result);\n  void DeleteCurrentFileReader();\n\n  int ComputeBytesToRead() const;\n  int BytesReadCompleted();\n\n  // These methods convert the result of blob data reading into response headers\n  // and pass it to URLRequestJob's NotifyDone() or NotifyHeadersComplete().\n  void NotifySuccess();\n  void NotifyFailure(int);\n  void HeadersCompleted(net::HttpStatusCode status_code);\n\n  // Returns a FileStreamReader for a blob item at |index|.\n  // If the item at |index| is not of file this returns NULL.\n  FileStreamReader* GetFileStreamReader(size_t index);\n\n  // Creates a FileStreamReader for the item at |index| with additional_offset.\n  void CreateFileStreamReader(size_t index, int64 additional_offset);\n\n  scoped_refptr<BlobData> blob_data_;\n\n  // Variables for controlling read from |blob_data_|.\n  scoped_refptr<fileapi::FileSystemContext> file_system_context_;\n  scoped_refptr<base::MessageLoopProxy> file_thread_proxy_;\n  std::vector<int64> item_length_list_;\n  int64 total_size_;\n  int64 remaining_bytes_;\n  int pending_get_file_info_count_;\n  IndexToReaderMap index_to_reader_;\n  size_t current_item_index_;\n  int64 current_item_offset_;\n\n  // Holds the buffer for read data with the IOBuffer interface.\n  scoped_refptr<net::DrainableIOBuffer> read_buf_;\n\n  // Is set when NotifyFailure() is called and reset when DidStart is called.\n  bool error_;\n\n  bool byte_range_set_;\n  net::HttpByteRange byte_range_;\n\n  scoped_ptr<net::HttpResponseInfo> response_info_;\n\n  base::WeakPtrFactory<BlobURLRequestJob> weak_factory_;\n\n  DISALLOW_COPY_AND_ASSIGN(BlobURLRequestJob);\n};\n\n}  // namespace webkit_blob\n\n#endif  // WEBKIT_BROWSER_BLOB_BLOB_URL_REQUEST_JOB_H_\n\n", "comment_ratio": 0.13076923076923078}
{"lang": "c", "code": "#ifndef BASE_TASK_SCHEDULER_TASK_SCHEDULER_IMPL_H_\n#define BASE_TASK_SCHEDULER_TASK_SCHEDULER_IMPL_H_\n\n#include <memory>\n#include <vector>\n\n#include \"base/base_export.h\"\n#include \"base/callback.h\"\n#include \"base/logging.h\"\n#include \"base/macros.h\"\n#include \"base/memory/ptr_util.h\"\n#include \"base/memory/ref_counted.h\"\n#include \"base/strings/string_piece.h\"\n#include \"base/synchronization/atomic_flag.h\"\n#include \"base/task_scheduler/delayed_task_manager.h\"\n#include \"base/task_scheduler/scheduler_single_thread_task_runner_manager.h\"\n#include \"base/task_scheduler/scheduler_worker_pool_impl.h\"\n#include \"base/task_scheduler/single_thread_task_runner_thread_mode.h\"\n#include \"base/task_scheduler/task_scheduler.h\"\n#include \"base/task_scheduler/task_tracker.h\"\n#include \"base/task_scheduler/task_traits.h\"\n#include \"build/build_config.h\"\n\n#if defined(OS_POSIX) && !defined(OS_NACL_SFI)\n#include \"base/task_scheduler/task_tracker_posix.h\"\n#endif\n\n#if defined(OS_WIN)\n#include \"base/win/com_init_check_hook.h\"\n#endif\n\nnamespace base {\n\nclass HistogramBase;\nclass Thread;\n\nnamespace internal {\n\n// Default TaskScheduler implementation. This class is thread-safe.\nclass BASE_EXPORT TaskSchedulerImpl : public TaskScheduler {\n public:\n  using TaskTrackerImpl =\n#if defined(OS_POSIX) && !defined(OS_NACL_SFI)\n      TaskTrackerPosix;\n#else\n      TaskTracker;\n#endif\n\n  // Creates a TaskSchedulerImpl with a production TaskTracker.\n  //|histogram_label| is used to label histograms, it must not be empty.\n  explicit TaskSchedulerImpl(StringPiece histogram_label);\n\n  // For testing only. Creates a TaskSchedulerImpl with a custom TaskTracker.\n  TaskSchedulerImpl(StringPiece histogram_label,\n                    std::unique_ptr<TaskTrackerImpl> task_tracker);\n\n  ~TaskSchedulerImpl() override;\n\n  // TaskScheduler:\n  void Start(const TaskScheduler::InitParams& init_params,\n             SchedulerWorkerObserver* scheduler_worker_observer) override;\n  void PostDelayedTaskWithTraits(const Location& from_here,\n                                 const TaskTraits& traits,\n                                 OnceClosure task,\n                                 TimeDelta delay) override;\n  scoped_refptr<TaskRunner> CreateTaskRunnerWithTraits(\n      const TaskTraits& traits) override;\n  scoped_refptr<SequencedTaskRunner> CreateSequencedTaskRunnerWithTraits(\n      const TaskTraits& traits) override;\n  scoped_refptr<SingleThreadTaskRunner> CreateSingleThreadTaskRunnerWithTraits(\n      const TaskTraits& traits,\n      SingleThreadTaskRunnerThreadMode thread_mode) override;\n#if defined(OS_WIN)\n  scoped_refptr<SingleThreadTaskRunner> CreateCOMSTATaskRunnerWithTraits(\n      const TaskTraits& traits,\n      SingleThreadTaskRunnerThreadMode thread_mode) override;\n#endif  // defined(OS_WIN)\n  std::vector<const HistogramBase*> GetHistograms() const override;\n  int GetMaxConcurrentNonBlockedTasksWithTraitsDeprecated(\n      const TaskTraits& traits) const override;\n  void Shutdown() override;\n  void FlushForTesting() override;\n  void FlushAsyncForTesting(OnceClosure flush_callback) override;\n  void JoinForTesting() override;\n\n private:\n  // Returns the worker pool that runs Tasks with |traits|.\n  SchedulerWorkerPoolImpl* GetWorkerPoolForTraits(\n      const TaskTraits& traits) const;\n\n  // Returns |traits|, with priority set to TaskPriority::USER_BLOCKING if\n  // |all_tasks_user_blocking_| is set.\n  TaskTraits SetUserBlockingPriorityIfNeeded(const TaskTraits& traits) const;\n\n  const std::unique_ptr<TaskTrackerImpl> task_tracker_;\n  std::unique_ptr<Thread> service_thread_;\n  DelayedTaskManager delayed_task_manager_;\n  SchedulerSingleThreadTaskRunnerManager single_thread_task_runner_manager_;\n\n  // Indicates that all tasks are handled as if they had been posted with\n  // TaskPriority::USER_BLOCKING. Since this is set in Start(), it doesn't apply\n  // to tasks posted before Start() or to tasks posted to TaskRunners created\n  // before Start().\n  //\n  // TODO(fdoray): Remove after experiment. https://crbug.com/757022\n  AtomicFlag all_tasks_user_blocking_;\n\n  // There are 4 SchedulerWorkerPoolImpl in this array to match the 4\n  // SchedulerWorkerPoolParams in TaskScheduler::InitParams.\n  std::unique_ptr<SchedulerWorkerPoolImpl> worker_pools_[4];\n\n#if DCHECK_IS_ON()\n  // Set once JoinForTesting() has returned.\n  AtomicFlag join_for_testing_returned_;\n#endif\n\n#if defined(OS_WIN) && defined(COM_INIT_CHECK_HOOK_ENABLED)\n  // Provides COM initialization verification for supported builds.\n  base::win::ComInitCheckHook com_init_check_hook_;\n#endif\n\n  DISALLOW_COPY_AND_ASSIGN(TaskSchedulerImpl);\n};\n\n}  // namespace internal\n}  // namespace base\n\n#endif  // BASE_TASK_SCHEDULER_TASK_SCHEDULER_IMPL_H_\n\n", "comment_ratio": 0.18796992481203006}
{"lang": "c", "code": "#ifndef CMFT_CUBEMAPUTILS_H_HEADER_GUARD\n#define CMFT_CUBEMAPUTILS_H_HEADER_GUARD\n\n#include \"common/fpumath.h\"\n\nnamespace cmft\n{\n    #define CMFT_PI       3.14159265358979323846f\n    #define CMFT_RPI      0.31830988618379067153f\n    #define CMFT_2PI      6.28318530717958647692f\n    #define CMFT_DEGTORAD 0.01745329251994329576f\n    #define CMFT_RADTODEG 57.2957795130823208767f\n\n    ///\n    ///\n    ///              +----------+\n    ///              | +---->+x |\n    ///              | |        |\n    ///              | |  +y    |\n    ///              |+z      2 |\n    ///   +----------+----------+----------+----------+\n    ///   | +---->+z | +---->+x | +---->-z | +---->-x |\n    ///   | |        | |        | |        | |        |\n    ///   | |  -x    | |  +z    | |  +x    | |  -z    |\n    ///   |-y      1 |-y      4 |-y      0 |-y      5 |\n    ///   +----------+----------+----------+----------+\n    ///              | +---->+x |\n    ///              | |        |\n    ///              | |  -y    |\n    ///              |-z      3 |\n    ///              +----------+\n    ///\n    static const float s_faceUvVectors[6][3][3] =\n    {\n        { // +x face\n            {  0.0f,  0.0f, -1.0f }, // u -> -z\n            {  0.0f, -1.0f,  0.0f }, // v -> -y\n            {  1.0f,  0.0f,  0.0f }, // +x face\n        },\n        { // -x face\n            {  0.0f,  0.0f,  1.0f }, // u -> +z\n            {  0.0f, -1.0f,  0.0f }, // v -> -y\n            { -1.0f,  0.0f,  0.0f }, // -x face\n        },\n        { // +y face\n            {  1.0f,  0.0f,  0.0f }, // u -> +x\n            {  0.0f,  0.0f,  1.0f }, // v -> +z\n            {  0.0f,  1.0f,  0.0f }, // +y face\n        },\n        { // -y face\n            {  1.0f,  0.0f,  0.0f }, // u -> +x\n            {  0.0f,  0.0f, -1.0f }, // v -> -z\n            {  0.0f, -1.0f,  0.0f }, // -y face\n        },\n        { // +z face\n            {  1.0f,  0.0f,  0.0f }, // u -> +x\n            {  0.0f, -1.0f,  0.0f }, // v -> -y\n            {  0.0f,  0.0f,  1.0f }, // +z face\n        },\n        { // -z face\n            { -1.0f,  0.0f,  0.0f }, // u -> -x\n            {  0.0f, -1.0f,  0.0f }, // v -> -y\n            {  0.0f,  0.0f, -1.0f }, // -z face\n        }\n    };\n\n    enum\n    {\n        CMFT_FACE_POS_X = 0,\n        CMFT_FACE_NEG_X = 1,\n        CMFT_FACE_POS_Y = 2,\n        CMFT_FACE_NEG_Y = 3,\n        CMFT_FACE_POS_Z = 4,\n        CMFT_FACE_NEG_Z = 5,\n    };\n\n    enum\n    {\n        CMFT_EDGE_LEFT   = 0,\n        CMFT_EDGE_RIGHT  = 1,\n        CMFT_EDGE_TOP    = 2,\n        CMFT_EDGE_BOTTOM = 3,\n    };\n\n    ///\n    ///    --> U    _____\n    ///   |        |     |\n    ///   v        | +Y  |\n    ///   V   _____|_____|_____ _____\n    ///      |     |     |     |     |\n    ///      | -X  | +Z  | +X  | -Z  |\n    ///      |_____|_____|_____|_____|\n    ///            |     |\n    ///            | -Y  |\n    ///            |_____|\n    ///\n    /// Neighbour faces in order: left, right, top, bottom.\n    /// FaceEdge is the edge that belongs to the neighbour face.\n    static const struct CubeFaceNeighbour\n    {\n        uint8_t m_faceIdx;\n        uint8_t m_faceEdge;\n    } s_cubeFaceNeighbours[6][4] =\n    {\n        { //POS_X\n            { CMFT_FACE_POS_Z, CMFT_EDGE_RIGHT },\n            { CMFT_FACE_NEG_Z, CMFT_EDGE_LEFT  },\n            { CMFT_FACE_POS_Y, CMFT_EDGE_RIGHT },\n            { CMFT_FACE_NEG_Y, CMFT_EDGE_RIGHT },\n        },\n        { //NEG_X\n            { CMFT_FACE_NEG_Z, CMFT_EDGE_RIGHT },\n            { CMFT_FACE_POS_Z, CMFT_EDGE_LEFT  },\n            { CMFT_FACE_POS_Y, CMFT_EDGE_LEFT  },\n            { CMFT_FACE_NEG_Y, CMFT_EDGE_LEFT  },\n        },\n        { //POS_Y\n            { CMFT_FACE_NEG_X, CMFT_EDGE_TOP },\n            { CMFT_FACE_POS_X, CMFT_EDGE_TOP },\n            { CMFT_FACE_NEG_Z, CMFT_EDGE_TOP },\n            { CMFT_FACE_POS_Z, CMFT_EDGE_TOP },\n        },\n        { //NEG_Y\n            { CMFT_FACE_NEG_X, CMFT_EDGE_BOTTOM },\n            { CMFT_FACE_POS_X, CMFT_EDGE_BOTTOM },\n            { CMFT_FACE_POS_Z, CMFT_EDGE_BOTTOM },\n            { CMFT_FACE_NEG_Z, CMFT_EDGE_BOTTOM },\n        },\n        { //POS_Z\n            { CMFT_FACE_NEG_X, CMFT_EDGE_RIGHT  },\n            { CMFT_FACE_POS_X, CMFT_EDGE_LEFT   },\n            { CMFT_FACE_POS_Y, CMFT_EDGE_BOTTOM },\n            { CMFT_FACE_NEG_Y, CMFT_EDGE_TOP    },\n        },\n        { //NEG_Z\n            { CMFT_FACE_POS_X, CMFT_EDGE_RIGHT  },\n            { CMFT_FACE_NEG_X, CMFT_EDGE_LEFT   },\n            { CMFT_FACE_POS_Y, CMFT_EDGE_TOP    },\n            { CMFT_FACE_NEG_Y, CMFT_EDGE_BOTTOM },\n        }\n    };\n\n    /// _u and _v should be center adressing and in [-1.0+invSize..1.0-invSize] range.\n    static inline void texelCoordToVec(float* _out3f, float _u, float _v, uint8_t _faceId)\n    {\n        // out = u * s_faceUv[0] + v * s_faceUv[1] + s_faceUv[2].\n        _out3f[0] = s_faceUvVectors[_faceId][0][0] * _u + s_faceUvVectors[_faceId][1][0] * _v + s_faceUvVectors[_faceId][2][0];\n        _out3f[1] = s_faceUvVectors[_faceId][0][1] * _u + s_faceUvVectors[_faceId][1][1] * _v + s_faceUvVectors[_faceId][2][1];\n        _out3f[2] = s_faceUvVectors[_faceId][0][2] * _u + s_faceUvVectors[_faceId][1][2] * _v + s_faceUvVectors[_faceId][2][2];\n\n        // Normalize.\n        const float invLen = 1.0f/sqrtf(_out3f[0]*_out3f[0] + _out3f[1]*_out3f[1] + _out3f[2]*_out3f[2]);\n        _out3f[0] *= invLen;\n        _out3f[1] *= invLen;\n        _out3f[2] *= invLen;\n    }\n\n    /// Notice: _faceSize should not be equal to one!\n    static inline float warpFixupFactor(float _faceSize)\n    {\n        // Edge fixup.\n        // Based on Nvtt : http://code.google.com/p/nvidia-texture-tools/source/browse/trunk/src/nvtt/CubeSurface.cpp\n        if (_faceSize == 1.0f)\n        {\n            return 1.0f;\n        }\n\n        const float fs = _faceSize;\n        const float fsmo = fs - 1.0f;\n        return (fs*fs) / (fsmo*fsmo*fsmo);\n    }\n\n    /// _u and _v should be center adressing and in [-1.0+invSize..1.0-invSize] range.\n    static inline void texelCoordToVecWarp(float* _out3f, float _u, float _v, uint8_t _faceId, float _warpFixup)\n    {\n        _u = (_warpFixup * _u*_u*_u) + _u;\n        _v = (_warpFixup * _v*_v*_v) + _v;\n\n        texelCoordToVec(_out3f, _u, _v, _faceId);\n    }\n\n    /// _u and _v are in [0.0 .. 1.0] range.\n    static inline void vecToTexelCoord(float& _u, float& _v, uint8_t& _faceIdx, const float* _vec)\n    {\n        const float absVec[3] =\n        {\n            fabsf(_vec[0]),\n            fabsf(_vec[1]),\n            fabsf(_vec[2]),\n        };\n        const float max = fmaxf(fmaxf(absVec[0], absVec[1]), absVec[2]);\n\n        // Get face id (max component == face vector).\n        if (max == absVec[0])\n        {\n            _faceIdx = (_vec[0] >= 0.0f) ? uint8_t(CMFT_FACE_POS_X) : uint8_t(CMFT_FACE_NEG_X);\n        }\n        else if (max == absVec[1])\n        {\n            _faceIdx = (_vec[1] >= 0.0f) ? uint8_t(CMFT_FACE_POS_Y) : uint8_t(CMFT_FACE_NEG_Y);\n        }\n        else //if (max == absVec[2])\n        {\n            _faceIdx = (_vec[2] >= 0.0f) ? uint8_t(CMFT_FACE_POS_Z) : uint8_t(CMFT_FACE_NEG_Z);\n        }\n\n        // Divide by max component.\n        float faceVec[3];\n        vec3Mul(faceVec, _vec, 1.0f/max);\n\n        // Project other two components to face uv basis.\n        _u = (vec3Dot(s_faceUvVectors[_faceIdx][0], faceVec) + 1.0f) * 0.5f;\n        _v = (vec3Dot(s_faceUvVectors[_faceIdx][1], faceVec) + 1.0f) * 0.5f;\n    }\n\n    static inline void latLongFromVec(float& _u, float& _v, const float _vec[3])\n    {\n        const float phi = atan2f(_vec[0], _vec[2]);\n        const float theta = acosf(_vec[1]);\n\n        _u = (CMFT_PI + phi)*(0.5f/CMFT_PI);\n        _v = theta*CMFT_RPI;\n    }\n\n    static inline void vecFromLatLong(float _vec[3], float _u, float _v)\n    {\n        const float phi   = _u * CMFT_2PI;\n        const float theta = _v * CMFT_PI;\n\n        _vec[0] = -sinf(theta)*sinf(phi);\n        _vec[1] = cosf(theta);\n        _vec[2] = -sinf(theta)*cosf(phi);\n    }\n\n    // Assume normalized _vec.\n    // Output is on [0, 1] for each component\n    static inline void octantFromVec(float& _u, float& _v, const float _vec[3])\n    {\n        // Project the sphere onto the octahedron, and then onto the xy plane.\n        float dot = fabsf(_vec[0]) + fabsf(_vec[1]) + fabsf(_vec[2]);\n        float px = _vec[0] / dot;\n        float py = _vec[2] / dot;\n\n        // Reflect the folds of the lower hemisphere over the diagonals.\n        if (_vec[1] <= 0.0f)\n        {\n            _u = ((1.0f - fabsf(py)) * fsign(px));\n            _v = ((1.0f - fabsf(px)) * fsign(py));\n        }\n        else\n        {\n            _u = px;\n            _v = py;\n        }\n\n        _u = _u * 0.5f + 0.5f;\n        _v = _v * 0.5f + 0.5f;\n    }\n\n    static inline void vecFromOctant(float _vec[3], float _u, float _v)\n    {\n        _u = _u*2.0f - 1.0f;\n        _v = _v*2.0f - 1.0f;\n\n        _vec[1] = 1.0f - fabsf(_u) - fabsf(_v);\n\n        if (_vec[1] < 0.0f)\n        {\n            _vec[0] = (1.0f - fabsf(_v)) * fsign(_u);\n            _vec[2] = (1.0f - fabsf(_u)) * fsign(_v);\n        }\n        else\n        {\n            _vec[0] = _u;\n            _vec[2] = _v;\n        }\n\n        const float invLen = 1.0f/vec3Length(_vec);\n        _vec[0] *= invLen;\n        _vec[1] *= invLen;\n        _vec[2] *= invLen;\n    }\n\n    /// http://www.mpia-hd.mpg.de/~mathar/public/mathar20051002.pdf\n    /// http://www.rorydriscoll.com/2012/01/15/cubemap-texel-solid-angle/\n    static inline float areaElement(float _x, float _y)\n    {\n        return atan2f(_x*_y, sqrtf(_x*_x + _y*_y + 1.0f));\n    }\n\n    /// _u and _v should be center adressing and in [-1.0+invSize..1.0-invSize] range.\n    static inline float texelSolidAngle(float _u, float _v, float _invFaceSize)\n    {\n        // Specify texel area.\n        const float x0 = _u - _invFaceSize;\n        const float x1 = _u + _invFaceSize;\n        const float y0 = _v - _invFaceSize;\n        const float y1 = _v + _invFaceSize;\n\n        // Compute solid angle of texel area.\n        const float solidAngle = areaElement(x1, y1)\n                               - areaElement(x0, y1)\n                               - areaElement(x1, y0)\n                               + areaElement(x0, y0)\n                               ;\n\n        return solidAngle;\n    }\n\n} // namespace cmft\n\n#endif //CMFT_CUBEMAPUTILS_H_HEADER_GUARD\n\n/* vim: set sw=4 ts=4 expandtab: */\n\n", "comment_ratio": 0.271875}
{"lang": "c", "code": "#ifndef STELLA_VSLAM_PUBLISH_FRAME_PUBLISHER_H\n#define STELLA_VSLAM_PUBLISH_FRAME_PUBLISHER_H\n\n#include \"stella_vslam/config.h\"\n#include \"stella_vslam/tracking_module.h\"\n\n#include <mutex>\n#include <vector>\n#include <memory>\n\n#include <opencv2/core/mat.hpp>\n#include <opencv2/core/types.hpp>\n\nnamespace stella_vslam {\n\nclass tracking_module;\n\nnamespace data {\nclass map_database;\n} // namespace data\n\nnamespace publish {\n\nclass frame_publisher {\npublic:\n    /**\n     * Constructor\n     */\n    frame_publisher(const std::shared_ptr<config>& cfg, data::map_database* map_db,\n                    const unsigned int img_width = 1024);\n\n    /**\n     * Destructor\n     */\n    virtual ~frame_publisher();\n\n    /**\n     * Update tracking information\n     * NOTE: should be accessed from system thread\n     */\n    void update(const std::vector<std::shared_ptr<data::landmark>>& curr_lms,\n                bool mapping_is_enabled,\n                tracker_state_t tracking_state,\n                std::vector<cv::KeyPoint>& keypts,\n                const cv::Mat& img,\n                double elapsed_ms);\n\n    /**\n     * Get the current image with tracking information\n     * NOTE: should be accessed from viewer thread\n     */\n    cv::Mat draw_frame();\n\nprotected:\n    unsigned int draw_tracked_points(cv::Mat& img, const std::vector<cv::KeyPoint>& curr_keypts,\n                                     const std::vector<bool>& is_tracked, const bool mapping_is_enabled,\n                                     const float mag = 1.0) const;\n\n    // colors (BGR)\n    const cv::Scalar mapping_color_{0, 255, 255};\n    const cv::Scalar localization_color_{255, 255, 0};\n\n    //! config\n    std::shared_ptr<config> cfg_;\n    //! map database\n    data::map_database* map_db_;\n    //! maximum size of output images\n    const int img_width_;\n\n    // -------------------------------------------\n    //! mutex to access variables below\n    std::mutex mtx_;\n\n    //! raw img\n    cv::Mat img_;\n    //! tracking state\n    tracker_state_t tracking_state_;\n\n    //! current keypoints\n    std::vector<cv::KeyPoint> curr_keypts_;\n\n    //! elapsed time for tracking\n    double elapsed_ms_ = 0.0;\n\n    //! mapping module status\n    bool mapping_is_enabled_;\n\n    //! tracking flag for each current keypoint\n    std::vector<bool> is_tracked_;\n};\n\n} // namespace publish\n} // namespace stella_vslam\n\n#endif // STELLA_VSLAM_PUBLISH_FRAME_PUBLISHER_H\n\n", "comment_ratio": 0.16666666666666666}
{"lang": "c", "code": "@class UIViewController;\n\n@protocol BuddyTCSubControllerDelegate\n- (void)buddyTCSubController:(UIViewController *)arg1 didFinishWithAgree:(_Bool)arg2;\n@end\n\n\n", "comment_ratio": 0.38461538461538464}
{"lang": "c", "code": "#include <stdarg.h>\n#include <stdio.h>\n#include <time.h>\n#include <string.h>\n#include <stdbool.h>\n#include \"kmyth.h\"\n#include \"kmyth_log.h\"\n\nvoid kmyth_log(const char *src_file, const char *src_func, const int src_line, char *severity, int level, const char *message,\n  ...)\n{\n  //Create the args string\n  const size_t LOG_MAX = 1024;  //max message length, enforced by vsnprintf\n  char out[LOG_MAX];\n  va_list args;\n\n  va_start(args, message);\n  vsnprintf(out, LOG_MAX, message, args);\n  va_end(args);\n\n  //Setting appropriate log level by doing an 'if' once\n  FILE *stddest = stdout;\n  int syslog_level = LOG_INFO;\n\n  //If we have an ERROR or WARNING\n  if (!strncmp(severity, ERROR, strlen(ERROR)) && strlen(ERROR) == strlen(severity))\n  {\n    stddest = stderr;\n    syslog_level = LOG_ERR;\n  }\n  else if (!strncmp(severity, WARNING, strlen(WARNING)) && strlen(WARNING) == strlen(severity))\n  {\n    stddest = stderr;\n    syslog_level = LOG_WARNING;\n  }\n\n  //Log to messages for pre-existing log parsers\n  setlogmask(LOG_UPTO(LOG_INFO));\n  openlog(\"kmyth\", LOG_CONS | LOG_PID | LOG_NDELAY, KMYTH_SYSLOG_FACILITY);\n  syslog(syslog_level, out);\n  closelog();\n\n  //Populate the timestamp string\n  //12345678901234567890\n  //yyyy-mm-dd hh:mm:ss\n  char timestamp[20];\n  time_t ts = time(0);\n\n  strftime(timestamp, 20, \"%F %T\", localtime(&ts));\n\n  //Kmyth expects to log to KMYTH_LOG_FILE which is expected to be available only to root users and\n  //and processes. Kmyth expects, then, if logfile == NULL, then it is being used by a non-root \n  //user, and stdout does not need to contain the same information desirable in a log file. Error\n  //messages still contain this information for the sake of troubleshooting problems.\n  FILE *logfile = fopen(KMYTH_LOG_FILE, \"a\");\n\n  //This switch decides what to print and where.\n  switch (level)\n  {\n  case 0:\n    if (logfile == NULL && (fileno(stddest) == fileno(stdout))) //level 0, no log file, stdout\n    {\n      fprintf(stddest, \"kmyth - %s\\n\", out);\n    }\n    else                        //level 0, log file or stderr\n    {\n      fprintf(stddest, \"kmyth-%s %s %s - %s(%s:%d) %s\\n\", KMYTH_VERSION, severity, timestamp, src_file, src_func, src_line,\n        out);\n    }\n    if (logfile != NULL)        //level 0, no log file, stderr\n    {\n      fprintf(logfile, \"kmyth-%s %s %s - %s(%s:%d) %s\\n\", KMYTH_VERSION, severity, timestamp, src_file, src_func, src_line,\n        out);\n    }\n    break;\n  case 2:\n    if (logfile == NULL)        //level 2, no log file, no message to user\n    {\n      break;\n    }                           //else go to default\n  default:\n    if (logfile == NULL)        //level 1 (or other), no log file, stdout/stderr to user\n    {\n      fprintf(stddest, \"kmyth-%s %s %s - %s(%s:%d) %s\\n\", KMYTH_VERSION, severity, timestamp, src_file, src_func, src_line,\n        out);\n    }\n    else                        //level 1, is a log file, write to it!\n    {\n      fprintf(logfile, \"kmyth-%s %s %s - %s(%s:%d) %s\\n\", KMYTH_VERSION, severity, timestamp, src_file, src_func, src_line,\n        out);\n    }\n    break;\n  }\n  if (logfile != NULL)\n  {\n    fclose(logfile);\n  }\n}\n\n", "comment_ratio": 0.20202020202020202}
{"lang": "c", "code": "#ifndef AMT_GENERALSYSTEMDEFENSECAPABILITIES_H\n#define AMT_GENERALSYSTEMDEFENSECAPABILITIES_H 1\n#include \"CIM_Capabilities.h\"\nnamespace Intel\n{\nnamespace Manageability\n{\nnamespace Cim\n{\nnamespace Typed \n{\n\t// Describes the system capabilities of the System Defense feature. These capabilities are independent of all network interfaces.\n\tclass CIMFRAMEWORK_API AMT_GeneralSystemDefenseCapabilities  : public CIM_Capabilities\n\t{\n\tpublic:\n\n\t\t//Default constructor\n\t\tAMT_GeneralSystemDefenseCapabilities()\n\t\t\t: CIM_Capabilities(NULL, CLASS_NAME, CLASS_NS, CLASS_NS_PREFIX, CLASS_URI)\n\t\t{\n\t\t\tif(_classMetaData.size() == 0)\n\t\t\t{\n\t\t\t\tCIM_Capabilities::SetMetaData(_classMetaData);\n\t\t\t\tCimBase::SetMetaData(_classMetaData, _metadata, 3);\n\t\t\t}\n\t\t}\n\n\t\t//constructor which receives WSMan client\n\t\tAMT_GeneralSystemDefenseCapabilities(ICimWsmanClient *client)\n\t\t\t: CIM_Capabilities(client, CLASS_NAME, CLASS_NS, CLASS_NS_PREFIX, CLASS_URI)\n\t\t{\n\t\t\tif(_classMetaData.size() == 0)\n\t\t\t{\n\t\t\t\tCIM_Capabilities::SetMetaData(_classMetaData);\n\t\t\t\tCimBase::SetMetaData(_classMetaData, _metadata, 3);\n\t\t\t}\n\t\t}\n\n\t\t//Destructor\n\t\tvirtual ~AMT_GeneralSystemDefenseCapabilities(){}\n\n\t\t// The \"type\" information for the object. Gettors only.\n\t\tvirtual const string& ResourceURI() const { return CLASS_URI; }\n\t\tstatic const string& ClassResourceURI() { return CLASS_URI; }\n\t\tvirtual const string& XmlNamespace() const { return CLASS_NS; }\n\t\tvirtual const string& XmlPrefix() const { return CLASS_NS_PREFIX; }\n\t\tvirtual const string& ObjectType() const { return CLASS_NAME; }\n\t\tstatic const string& ClassObjectType() { return CLASS_NAME; }\n\n\t\t// Class representing AMT_GeneralSystemDefenseCapabilities keys\n\t\tclass CimKeys : public CIM_Capabilities::CimKeys\n\t\t{\n\t\tpublic:\n\t\t\t// Key, Required, Opaquely and uniquely identifies an instance of this class.\n\t\t\tconst string InstanceID() const\n\t\t\t{\n\t\t\t\treturn GetKey(\"InstanceID\");\n\t\t\t}\n\n\t\t\t// Key, Required, Opaquely and uniquely identifies an instance of this class.\n\t\t\tvoid InstanceID(const string &value)\n\t\t\t{\n\t\t\t\tSetOrAddKey(\"InstanceID\", value);\n\t\t\t}\n\n\t\t};\n\n\t\t// class fields declarations\n\n\t\t// Optional, Specifies the maximum number of supported policies allocated by the Intel(R) AMT device.\n\t\tconst unsigned int GlobalMaxSupportedPolicies() const;\n\n\t\t// Optional, Specifies the maximum number of supported policies allocated by the Intel(R) AMT device.\n\t\tvoid GlobalMaxSupportedPolicies(const unsigned int value); \n\n\t\t// Is true if the field GlobalMaxSupportedPolicies exists in the current object, otherwise is false.\n\t\tbool GlobalMaxSupportedPoliciesExists() const;\n\n\t\t// Remove GlobalMaxSupportedPolicies field.\n\t\tvoid RemoveGlobalMaxSupportedPolicies(); \n\n\t\t// Optional, Specifies the maximum number of supported filters allocated by the Intel(R) AMT device.\n\t\tconst unsigned int GlobalMaxSupportedFilters() const;\n\n\t\t// Optional, Specifies the maximum number of supported filters allocated by the Intel(R) AMT device.\n\t\tvoid GlobalMaxSupportedFilters(const unsigned int value); \n\n\t\t// Is true if the field GlobalMaxSupportedFilters exists in the current object, otherwise is false.\n\t\tbool GlobalMaxSupportedFiltersExists() const;\n\n\t\t// Remove GlobalMaxSupportedFilters field.\n\t\tvoid RemoveGlobalMaxSupportedFilters(); \n\n\t\t // Function used by the factory\n\t\tstatic CimBase *CreateFromCimObject(const CimObject &object);\n\n\t\tstatic vector<shared_ptr<AMT_GeneralSystemDefenseCapabilities> > Enumerate(ICimWsmanClient *client, const CimKeys &keys = CimKeys()) ;\n\n\t\t// Overloaded delete which supplies the internal resourceURI\n\t\tstatic void Delete(ICimWsmanClient *client, const CimKeys &keys = CimKeys()) ;\n\n\t\tusing CimBase::Delete;\n\n\tprotected:\n\t\t // Protected constructor to be used by derived classes\n\t\tAMT_GeneralSystemDefenseCapabilities(ICimWsmanClient *client, const string &class_name,\n\t\t\tconst string &class_ns, const string &prefix, const string &uri): CIM_Capabilities(client, class_name, class_ns, prefix, uri)\n\t\t{\n\t\t\tif(_classMetaData.size() == 0)\n\t\t\t{\n\t\t\t\tCIM_Capabilities::SetMetaData(_classMetaData);\n\t\t\t\tCimBase::SetMetaData(_classMetaData, _metadata, 3);\n\t\t\t}\n\t\t}\n\t\t // Protected constructor which receives CimObject\n\t\tAMT_GeneralSystemDefenseCapabilities(const CimObject &object)\n\t\t\t: CIM_Capabilities(object)\n\t\t{\n\t\t\tif(_classMetaData.size() == 0)\n\t\t\t{\n\t\t\t\tCIM_Capabilities::SetMetaData(_classMetaData);\n\t\t\t\tCimBase::SetMetaData(_classMetaData, _metadata, 3);\n\t\t\t}\n\t\t}\n\t\t// Called by derived classes\n\t\tvoid SetMetaData(vector<CimFieldAttribute>& childMetaData)\n\t\t{\n\t\t\tCIM_Capabilities::SetMetaData(childMetaData);\n\t\t\tCimBase::SetMetaData(childMetaData, _metadata, 3);\n\t\t}\n\t\tconst vector<CimFieldAttribute> &GetMetaData() const;\n\tprivate:\n\t\tstatic const CimFieldAttribute _metadata[];\n\t\tstatic const string CLASS_NAME;\n\t\tstatic const string CLASS_URI;\n\t\tstatic const string CLASS_NS;\n\t\tstatic const string CLASS_NS_PREFIX;\n\t\tstatic vector<CimFieldAttribute> _classMetaData;\n\t};\n\n} // close namespace Typed\n} // close namespace Cim\n} // close namespace Manageability\n} // close namespace Intel\n#endif // AMT_GENERALSYSTEMDEFENSECAPABILITIES_H\n\n", "comment_ratio": 0.24203821656050956}
{"lang": "c", "code": "#include \"GB.h\"\n\nGB_PUBLIC   // accessed by the MATLAB tests in GraphBLAS/Test only\nGrB_Info GB_Type_check      // check a GraphBLAS Type\n(\n    const GrB_Type type,    // GraphBLAS type to print and check\n    const char *name,       // name of the type from the caller; optional\n    int pr,                 // print level\n    FILE *f,                // file for output\n    GB_Context Context\n)\n{\n\n    //--------------------------------------------------------------------------\n    // check inputs\n    //--------------------------------------------------------------------------\n\n    GBPR0 (\"    GraphBLAS type: \") ;\n    if (name != NULL) GBPR0 (\"%s \", name) ;\n\n    if (type == NULL)\n    { \n        // GrB_error status not modified since this may be an optional argument\n        GBPR0 (\"NULL\\n\") ;\n        return (GrB_NULL_POINTER) ;\n    }\n\n    //--------------------------------------------------------------------------\n    // check object\n    //--------------------------------------------------------------------------\n\n    GB_CHECK_MAGIC (type, \"Type\") ;\n\n    switch (type->code)\n    {\n        case GB_BOOL_code   : GBPR0 (\"bool\"     ) ; break ;\n        case GB_INT8_code   : GBPR0 (\"int8_t\"   ) ; break ;\n        case GB_UINT8_code  : GBPR0 (\"uint8_t\"  ) ; break ;\n        case GB_INT16_code  : GBPR0 (\"int16_t\"  ) ; break ;\n        case GB_UINT16_code : GBPR0 (\"uint16_t\" ) ; break ;\n        case GB_INT32_code  : GBPR0 (\"int32_t\"  ) ; break ;\n        case GB_UINT32_code : GBPR0 (\"uint32_t\" ) ; break ;\n        case GB_INT64_code  : GBPR0 (\"int64_t\"  ) ; break ;\n        case GB_UINT64_code : GBPR0 (\"uint64_t\" ) ; break ;\n        case GB_FP32_code   : GBPR0 (\"float\"    ) ; break ;\n        case GB_FP64_code   : GBPR0 (\"double\"   ) ; break ;\n        case GB_FC32_code   : GBPR0 (\"float complex\" ) ; break ;\n        case GB_FC64_code   : GBPR0 (\"double complex\") ; break ;\n        case GB_UDT_code    : GBPR0 (\"user-defined: [%s]\", type->name) ; break ;\n        default             : GBPR0 (\"unknown type\\n\") ;\n            return (GB_ERROR (GrB_INVALID_OBJECT, (GB_LOG,\n                \"Type code %d is unknown: %s [%s]\",\n                type->code, GB_NAME, type->name))) ;\n    }\n\n    GBPR0 (\" size: %zu\\n\", type->size) ;\n\n    if (type->size == 0 || type->size != GB_code_size (type->code, type->size))\n    { \n        GBPR0 (\"    Type has an invalid size\\n\") ;\n        return (GB_ERROR (GrB_INVALID_OBJECT, (GB_LOG,\n            \"Type has an invalid size: %s [%s]\", GB_NAME, type->name))) ;\n    }\n\n    return (GrB_SUCCESS) ;\n}\n\n\n", "comment_ratio": 0.2804878048780488}
{"lang": "c", "code": "#pragma once\n\n#include <soulblight/SoulblightGravelords.h>\n#include <Weapon.h>\n\nnamespace Soulblight {\n\n    class WightKingOnSteed : public SoulblightBase {\n    public:\n\n        static Unit *Create(const ParameterList &parameters);\n\n        static int ComputePoints(const ParameterList& parameters);\n\n        static void Init();\n\n        WightKingOnSteed(CursedBloodline bloodline, CommandTrait trait, Artefact artefact, bool isGeneral);\n\n        ~WightKingOnSteed() override = default;\n\n    protected:\n\n        void onCharged() override;\n\n    private:\n\n        Weapon  m_lance{Weapon::Type::Melee, \"Tomb Lance\", 2, 3, 3, 3, -1, RAND_D3},\n                m_hoovesAndTeeth{Weapon::Type::Melee, \"Hooves and Teeth\", 1, 2, 4, 4, 0, 1};\n\n        static bool s_registered;\n\n    };\n\n//\n// Abilities                    Implemented\n// -------------------------------------------\n// Deathly Charge                   Yes\n// Lord of Bones                    Yes\n//\n\n} // namespace Soulblight\n\n", "comment_ratio": 0.16326530612244897}
{"lang": "c", "code": "#ifndef _XSAT_H_\n#define _XSAT_H_\n//MUST BE NEAGATIVE!!\n#define EPSILON 0\n#include <math.h>\n#include <limits.h>\n#include <stdint.h>\n#include <inttypes.h>\n\n\n/* uint64_t ulp_i(double x, double y) { */\n/*   int64_t xx = *((int64_t*)&x); */\n/*   xx = xx < 0 ? LLONG_MIN - xx : xx; */\n/*   int64_t yy = *((int64_t*)&y); */\n/*   yy = yy < 0 ? LLONG_MIN - yy : yy; */\n/*   uint64_t ret=xx>=yy?xx-yy:yy-xx; */\n/*   //return (double) (ret); */\n/*   return  (ret); */\n/*   //return ((double)ret)*((double)ret);; */\n/* } */\n\n/* uint64_t substract_u64(uint64_t a, uint64_t b){ */\n/*   return a > b ? a - b : b - a; */\n/* } */\n/* void CHECK(double x,double y){ */\n/*   if (ulp_i(-x,-y)!=ulp_i(x,y)) */\n/*     printf (\"****************************************************issue 1 \\n\"); */\n/*   if (x*y>=0 && ulp_i(x,y)!=substract_u64(ulp_i(0,x),ulp_i(0,y))) */\n/*     printf (\"****************************************************issue 2 \\n\"); */\n/*   if (x*y==0 &&  ulp_i(x,y)!=ulp_i(0,x)+ulp_i(0,y)) */\n/*     printf (\"****************************************************issue 3 \\n\"); */\n/*   if (x!=y &&  ulp_i(x,y)== 0) */\n/*     printf (\"****************************************************issue 4 \\n\"); */\n/*   if (x==y &&  ulp_i(x,y)!= 0) */\n/*     printf (\"****************************************************issue 5 \\n\"); */\n/*   if (ulp_i(x,y)!=ulp_i(y,x)) */\n/*     printf (\"****************************************************issue 6 \\n\"); */\n/*   if (ulp_i(x,y)!=ulp_i(x,x/2+y/2) + ulp_i(x/2+y/2,y)) */\n/*     printf (\"****************************************************issue 7 \\n\"); */\n/*   if ( (x<y) && ulp_i(x,y)!=ulp_i(x,nextafter(y,-INFINITY))+1) */\n    \n/*     printf (\"****************************************************issue 8 \\n\"); */\n\n/*   if ((x>y) && ulp_i(x,y)!=ulp_i(x,nextafter(y,-INFINITY))-1) */\n/*     printf (\"****************************************************issue 9 \\n\");   */\n\t     \n/*   return; */\n/* } */\n\ndouble DLE(double x,double y);\ndouble DLT(double x,double y);\ndouble DGT(double x,double y);\ndouble DGE(double x,double y);\ndouble DEQ(double x,double y);\ndouble DNE(double x,double y);\n\ndouble  BAND(double x,double y);\ndouble  BOR(double x,double y);\nfloat TR32(double x);\ndouble MAX(double a, double b);\n\ndouble ulp(double x, double y) {\n  int64_t xx = *((int64_t*)&x);\n  xx = xx < 0 ? LLONG_MIN - xx : xx;\n  int64_t yy = *((int64_t*)&y);\n  yy = yy < 0 ? LLONG_MIN - yy : yy;\n  uint64_t ret=xx>=yy?xx-yy:yy-xx;\n  //CHECK(x,y);\n  /* if ( ((double)ret)*((double)ret)==0){ */\n  /*   printf(\"*******x = %g, y = %g\\n\", x,y); */\n  /* } */\n  return (double) (ret);\n  //return ((double)ret)*((double)ret);;\n}\n\n\n\ndouble DLE(double x,double y){\n  //printf (\"x = %g, y = %g\\n\",x,y);\n\n    \n    return x<=y?0.0:ulp(x,y);\n  // return x<=y?0.0:(x-y)*(x-y);\n  //     return 0;\n}\ndouble DLT(double x,double y){\n  //  return DLE(x-y,EPSILON);\n  //  return DLE(x,y);\n  return x<y?0.0:ulp(x,y)+1;\n  //return x<y?0.0:ulp(x,nextafter(y,-INFINITY));\n  //    return 0;\n}\n\ndouble DGE(double x,double y)  {\n   return DLE(y,x);\n  //  return 0;\n}\ndouble  DGT(double x,double y)  {\n  return DLT(y,x);\n\n  //return 0;\n}\ndouble DEQ(double x, double y){\n  //  return fabs(x-y);\n  // return x>y?x-y:y-x;\n  //   return (x-y)*(x-y);\n  //double a = log2(1+fabs(x)) - log2(1+fabs(y));\n\n  \n  return ulp(x,y);\n  //  return (x-y)*(x-y);\n\n}\ndouble  DNE(double x,double y) {\n  //return 0;\n  return  (x==y)?1.0:0.0;      \n\t \n  //return BOR(DLT(x,y),DGT(x,y));\n  \n}\n\n\n\n\n//DIZ can be 2, 3 or undefined, or just defined, namely 1.\n\n\n//#if DIZ==2 \n//double  BAND(double x,double y){ return (x<=y)?y:x ;}\n//double  BOR(double x,double y){return x<=y?x:y;}\n\n//#elif DIZ==3\n//double  BAND(double x,double y){return (x==0.0 && y== 0.0)?0.0:1.0 ;}\n//double  BOR(double x,double y){return (x==0.0 || y==0.0)?0.0:1.0;}\n\n\n//#else\n//double  BAND(double x,double y){return x+y;}\n//#define BAND(x,y) (x+y)\n#define MIN(a, b) (((a) < (b)) ? (a) : (b)) \ndouble MAX(double a, double b) {\n  return (((a) > (b)) ? (a) : (b));\n}\ndouble  BAND(double x,double y){return x+y;}\ndouble  BOR(double x,double y){return x*y;}\n\n//#endif\nfloat TR32(double x){\n  return (float)x;\n}\n#endif\n\n", "comment_ratio": 0.21052631578947367}
{"lang": "c", "code": "/**********************************************************************************************************\n                                \u5929\u7a79\u98de\u63a7 \u2014\u2014 \u81f4\u529b\u4e8e\u6253\u9020\u4e2d\u56fd\u6700\u597d\u7684\u591a\u65cb\u7ffc\u5f00\u6e90\u98de\u63a7\n                                Github: github.com/loveuav/BlueSkyFlightControl\n                                \u6280\u672f\u8ba8\u8bba\uff1abbs.loveuav.com/forum-68-1.html\n * @\u6587\u4ef6     sensor_task.c\n * @\u8bf4\u660e     \u4f20\u611f\u5668\u6821\u51c6\u53ca\u6570\u636e\u9884\u5904\u7406\u76f8\u5173\u4efb\u52a1\n * @\u7248\u672c  \t V1.0\n * @\u4f5c\u8005     BlueSky\n * @\u7f51\u7ad9     bbs.loveuav.com\n * @\u65e5\u671f     2018.05 \n**********************************************************************************************************/\n#include \"TaskConfig.h\"\n\n#include \"gyroscope.h\"\n#include \"accelerometer.h\"\n#include \"magnetometer.h\"\n\nxTaskHandle imuDataPreTreatTask;\nxTaskHandle otherSensorTask;\n\n/**********************************************************************************************************\n*\u51fd \u6570 \u540d: vImuDataPreTreatTask\n*\u529f\u80fd\u8bf4\u660e: IMU\u4f20\u611f\u5668\u6570\u636e\u9884\u5904\u7406\u4efb\u52a1\uff0c\u4efb\u52a1\u4f18\u5148\u7ea7\u4ec5\u6b21\u4e8eIMU\u4f20\u611f\u5668\u8bfb\u53d6\n*\u5f62    \u53c2: \u65e0\n*\u8fd4 \u56de \u503c: \u65e0\n**********************************************************************************************************/\nportTASK_FUNCTION(vImuDataPreTreatTask, pvParameters) \n{\n\tVector3f_t* gyroRawData;\n\tVector3f_t* accRawData;\n\tfloat*      tempRawData;\n\tVector3f_t* accData  = pvPortMalloc(sizeof(Vector3f_t));\n\tVector3f_t* gyroData = pvPortMalloc(sizeof(Vector3f_t));\n\t\n\t//\u6302\u8d77\u8c03\u5ea6\u5668\n\tvTaskSuspendAll();\n\t\n    //\u9640\u87ba\u4eea\u6821\u51c6\u53c2\u6570\u521d\u59cb\u5316\n\tGyroCaliDataInit();\n    //\u52a0\u901f\u5ea6\u6821\u51c6\u53c2\u6570\u521d\u59cb\u5316\n    AccCaliDataInit();\n    \n\t//\u5524\u9192\u8c03\u5ea6\u5668\n\txTaskResumeAll();\n\n\tfor(;;)\n\t{\n\t\t//\u4ece\u6d88\u606f\u961f\u5217\u4e2d\u83b7\u53d6\u6570\u636e\n\t\txQueueReceive(messageQueue[GYRO_SENSOR_READ], &gyroRawData, (3 / portTICK_RATE_MS)); \n\t\txQueueReceive(messageQueue[ACC_SENSOR_READ], &accRawData, (3 / portTICK_RATE_MS)); \n\t\txQueueReceive(messageQueue[TEMP_SENSOR_READ], &tempRawData, (3 / portTICK_RATE_MS)); \n\t\t\n\t\t//\u9640\u87ba\u4eea\u6821\u51c6\n\t\tGyroCalibration(*gyroRawData);\t\n        //\u52a0\u901f\u5ea6\u6821\u51c6\n        AccCalibration(*accRawData);\n        \n\t\t//\u9640\u87ba\u4eea\u6570\u636e\u9884\u5904\u7406\n\t\tGyroDataPreTreat(*gyroRawData, gyroData);\n        //\u52a0\u901f\u5ea6\u6570\u636e\u9884\u5904\u7406\n        AccDataPreTreat(*accRawData, accData);\n        \n\t\t//IMU\u5b89\u88c5\u8bef\u5dee\u6821\u51c6\n        ImuLevelCalibration();\n        \n\t\t//\u5f80\u4e0b\u4e00\u7ea7\u6d88\u606f\u961f\u5217\u4e2d\u586b\u5145\u6570\u636e\n\t\txQueueSendToBack(messageQueue[ACC_DATA_PRETREAT], (void *)&accData, 0); \t\t\n\t\txQueueSendToBack(messageQueue[GYRO_DATA_PRETREAT], (void *)&gyroData, 0); \n\t\txQueueSendToBack(messageQueue[GYRO_FOR_CONTROL], (void *)&gyroData, 0); \t\t\t\n\t}\n}\n\n/**********************************************************************************************************\n*\u51fd \u6570 \u540d: vOtherSensorTask\n*\u529f\u80fd\u8bf4\u660e: \u5176\u5b83\u4f20\u611f\u5668\u6570\u636e\u9884\u5904\u7406\u4efb\u52a1\n*\u5f62    \u53c2: \u65e0\n*\u8fd4 \u56de \u503c: \u65e0\n**********************************************************************************************************/\nportTASK_FUNCTION(vOtherSensorTask, pvParameters) \n{\n\tportTickType xLastWakeTime;\n\tstatic uint16_t count = 0;\n\t\n\t//\u6302\u8d77\u8c03\u5ea6\u5668\n\tvTaskSuspendAll();\n    \n    //\u78c1\u529b\u8ba1\u6821\u51c6\u53c2\u6570\u521d\u59cb\u5316\n    MagCaliDataInit();\n    \n\t//\u5524\u9192\u8c03\u5ea6\u5668\n\txTaskResumeAll();\n\t\n\txLastWakeTime = xTaskGetTickCount();\n\tfor(;;)\n\t{\t\t\n        //100Hz\n        if(count % 2 == 0)\t\n\t\t{\n            //\u78c1\u529b\u8ba1\u6821\u51c6\n            MagCalibration();\n            \n            //\u78c1\u529b\u8ba1\u6570\u636e\u9884\u5904\u7406\n            MagDataPreTreat();\n\t\t}\n        \n\t\tcount++;\n        \n        //\u7761\u77205ms\n\t\tvTaskDelayUntil(&xLastWakeTime, (5 / portTICK_RATE_MS));\n\t}\n}\n\n/**********************************************************************************************************\n*\u51fd \u6570 \u540d: SensorTaskCreate\n*\u529f\u80fd\u8bf4\u660e: \u4f20\u611f\u5668\u6570\u636e\u9884\u5904\u7406\u76f8\u5173\u4efb\u52a1\u521b\u5efa\n*\u5f62    \u53c2: \u65e0\n*\u8fd4 \u56de \u503c: \u65e0\n**********************************************************************************************************/\nvoid SensorTaskCreate(void)\n{\n\txTaskCreate(vImuDataPreTreatTask, \"imuDataPreTreat\", IMU_DATA_PRETREAT_TASK_STACK, NULL, IMU_DATA_PRETREAT_TASK_PRIORITY, &imuDataPreTreatTask); \n\txTaskCreate(vOtherSensorTask, \"otherSensor\", OTHER_SENSOR_TASK_STACK, NULL, OTHER_SENSOR_TASK_PRIORITY, &otherSensorTask); \n}\n\n/**********************************************************************************************************\n*\u51fd \u6570 \u540d: GetImuDataPreTreatTaskStackUse\n*\u529f\u80fd\u8bf4\u660e: \u83b7\u53d6\u4efb\u52a1\u5806\u6808\u4f7f\u7528\u60c5\u51b5\n*\u5f62    \u53c2: \u65e0\n*\u8fd4 \u56de \u503c: \u65e0\n**********************************************************************************************************/\nint16_t\tGetImuDataPreTreatTaskStackUse(void)\n{\n\treturn uxTaskGetStackHighWaterMark(imuDataPreTreatTask);\n}\n\n/**********************************************************************************************************\n*\u51fd \u6570 \u540d: GetOtherSensorTaskStackUse\n*\u529f\u80fd\u8bf4\u660e: \u83b7\u53d6\u4efb\u52a1\u5806\u6808\u4f7f\u7528\u60c5\u51b5\n*\u5f62    \u53c2: \u65e0\n*\u8fd4 \u56de \u503c: \u65e0\n**********************************************************************************************************/\nint16_t\tGetOtherSensorTaskStackUse(void)\n{\n\treturn uxTaskGetStackHighWaterMark(otherSensorTask);\t\n}\n\n\n\n\n\n", "comment_ratio": 0.12}
{"lang": "c", "code": "#ifndef __GLOBAL__\n#define __GLOBAL__\n\n// Global Defines (used by many avr-libc libaries)\n//#define F_CPU=16000000L // if using a platformio board definition this would already be defined\n\n// Debugging\n#define DEBUG // enable debugging\n\n// UART\n#define BAUD 9600\n#define UART_RX_BUFFER_SIZE 20\n#define UART_RX_INTERUPT\n#define UART_INIT_STDOUT\n\n// Arduino Hardware\n#define LED_PIN PB5 // typically the builtin LED is connected to PB5\n\n#endif\n", "comment_ratio": 0.3684210526315789}
{"lang": "c", "code": "#ifndef ABULAFIA_PATTERNS_LEAF_STRING_LITERAL_H_\n#define ABULAFIA_PATTERNS_LEAF_STRING_LITERAL_H_\n\n#include \"abulafia/config.h\"\n\n#include \"abulafia/patterns/pattern.h\"\n\n#include <cassert>\n#include <memory>\n#include <string>\n\nnamespace ABULAFIA_NAMESPACE {\n\n// The string literal matches agaisnt a sequence of tokens without\n// emmiting anything.\ntemplate <typename CHAR_T>\nclass StringLiteral : public Pattern<StringLiteral<CHAR_T>> {\n  std::shared_ptr<std::basic_string<CHAR_T>> str_;\n\n public:\n  StringLiteral(std::basic_string<CHAR_T> str)\n      : str_(std::make_shared<std::basic_string<CHAR_T>>(std::move(str))) {\n    assert(str_->size() > 0);\n  }\n\n  auto begin() const { return str_->begin(); }\n  auto end() const { return str_->end(); }\n};\n\ntemplate <typename CHAR_T>\ninline auto lit(CHAR_T const* str) {\n  return StringLiteral<decay_t<CHAR_T>>(str);\n}\n\ntemplate <>\nstruct expr_traits<char const*> {\n  enum { is_pattern = false, converts_to_pattern = true };\n\n  static StringLiteral<char> make_pattern(char const* v) { return lit(v); }\n};\n\ntemplate <>\nstruct expr_traits<char32_t const*> {\n  enum { is_pattern = false, converts_to_pattern = true };\n\n  static StringLiteral<char32_t> make_pattern(char32_t const* v) {\n    return lit(v);\n  }\n};\n\n}  // namespace ABULAFIA_NAMESPACE\n\n#endif\n\n", "comment_ratio": 0.14754098360655737}
{"lang": "c", "code": "#ifndef NP_PVD_SCENEQUERYCOLLECTOR_H\n#define NP_PVD_SCENEQUERYCOLLECTOR_H\n\n#include \"CmPhysXCommon.h\"\n#include \"PsArray.h\"\n#include \"PxFiltering.h\"\n#include \"PxGeometryHelpers.h\"\n#include \"PxQueryReport.h\"\n#include \"PxBatchQueryDesc.h\"\n\n#if PX_SUPPORT_PVD\n\nnamespace physx\n{\nnamespace Scb\n{\nclass Scene;\n}\n\nnamespace Vd\n{\nstruct PvdReference\n{\n\tPX_FORCE_INLINE PvdReference()\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{}\n\tPX_FORCE_INLINE PvdReference(const char* arrayName, PxU32 baseIndex, PxU32 count) : mArrayName(arrayName), mBaseIndex(baseIndex), mCount(count)\t{}\n\n\tconst char*\t\tmArrayName;\n\tPxU32\t\t\tmBaseIndex;\n\tPxU32\t\t\tmCount;\n};\n\nstruct PvdRaycast\n{\n\tPxU32\t\t\tmType;\n\tPxFilterData\tmFilterData;\n\tPxU32\t\t\tmFilterFlags;\n\tPxVec3\t\t\tmOrigin;\n\tPxVec3\t\t\tmUnitDir;\n\tPxReal\t\t\tmDistance;\n\tPvdReference\tmHits;\n};\n\nstruct PvdOverlap\n{\n\tPxU32\t\t\tmType;\n\tPxFilterData\tmFilterData;\n\tPxU32\t\t\tmFilterFlags;\n\tPxTransform\t\tmPose;\n\tPvdReference\tmGeometries;\n\tPvdReference\tmHits;\n};\n\nstruct PvdSweep\n{\n\tPxU32\t\t\tmType;\n\tPxU32\t\t\tmFilterFlags;\n\tPxVec3\t\t\tmUnitDir;\n\tPxReal\t\t\tmDistance;\n\tPvdReference\tmGeometries;\n\tPvdReference\tmPoses;\n\tPvdReference\tmFilterData;\n\tPvdReference\tmHits;\n};\n\nstruct PvdSqHit\n{\n\tconst void*\t\tmShape;\n\tconst void*\t\tmActor;\n\tPxU32\t\t\tmFaceIndex;\n\tPxU32\t\t\tmFlags;\n\tPxVec3\t\t\tmImpact;\n\tPxVec3\t\t\tmNormal;\n\tPxF32\t\t\tmDistance;\n\tPxF32\t\t\tmU;\n\tPxF32\t\t\tmV;\n\n\tPvdSqHit()\n\t{\n\t\tsetDefaults(PxQueryHit());\n\t}\n\n\texplicit PvdSqHit(const PxOverlapHit& hit)\n\t{\n\t\tsetDefaults(hit);\n\t}\n\n\texplicit PvdSqHit(const PxRaycastHit& hit)\n\t{\n\t\tsetDefaults(hit);\n\n\t\tmImpact = hit.position;\n\t\tmNormal = hit.normal;\n\t\tmDistance = hit.distance;\n\t\tmFlags = hit.flags;\n\t\tmU = hit.u;\n\t\tmV = hit.v;\n\t}\n\n\texplicit PvdSqHit(const PxSweepHit& hit)\n\t{\n\t\tsetDefaults(hit);\n\n\t\tmImpact = hit.position;\n\t\tmNormal = hit.normal;\n\t\tmDistance = hit.distance;\n\t\tmFlags = hit.flags;\n\t}\n\n  private:\n\tvoid setDefaults(const PxQueryHit& hit)\n\t{\n\t\tmShape = hit.shape;\n\t\tmActor = hit.actor;\n\t\tmFaceIndex = hit.faceIndex;\n\t\tmFlags = 0;\n\t\tmImpact = mNormal = PxVec3(0.0f);\n\t\tmDistance = mU = mV = 0.0f;\n\t}\n};\n\ntemplate <class T>\nclass NamedArray : public Ps::Array<T>\n{\n\tpublic:\n\t\tNamedArray(const char* names[2]) { mNames[0] = names[0]; mNames[1] = names[1]; }\n\n\tconst char*\tmNames[2];\n};\n\nclass PvdSceneQueryCollector\n{\n\tPX_NOCOPY(PvdSceneQueryCollector)\npublic:\n\tPvdSceneQueryCollector(Scb::Scene& scene, bool isBatched);\n\t~PvdSceneQueryCollector()\t{}\n\n\tvoid clear()\n\t{\n\t\tPs::Mutex::ScopedLock lock(mMutex);\n\n\t\tmAccumulatedRaycastQueries.clear();\n\t\tmAccumulatedOverlapQueries.clear();\n\t\tmAccumulatedSweepQueries.clear();\n\t\tmPvdSqHits.clear();\n\t\tmPoses.clear();\n\t\tmFilterData.clear();\n\t}\n\n\tvoid clearGeometryArrays()\n\t{\n\t\tmGeometries0.clear();\n\t\tmGeometries1.clear();\n\t}\n\n\tvoid release();\n\n\tvoid raycast(const PxVec3& origin, const PxVec3& unitDir, PxReal distance, const PxRaycastHit* hit, PxU32 hitsNum, const PxQueryFilterData& filterData, bool multipleHits);\n\tvoid sweep(const PxGeometry& geometry, const PxTransform& pose, const PxVec3& unitDir, PxReal distance, const PxSweepHit* hit, PxU32 hitsNum, const PxQueryFilterData& filterData, bool multipleHits);\n\tvoid overlapMultiple(const PxGeometry& geometry, const PxTransform& pose, const PxOverlapHit* hit, PxU32 hitsNum, const PxQueryFilterData& filterData);\n\n\tvoid collectAllBatchedHits\t(const PxRaycastQueryResult* raycastResults, PxU32 nbRaycastResults, PxU32 batchedRayQstartIdx,\n\t\t\t\t\t\t\t\tconst PxOverlapQueryResult* overlapResults, PxU32 nbOverlapResults, PxU32 batchedOverlapQstartIdx,\n\t\t\t\t\t\t\t\tconst PxSweepQueryResult* sweepResults, PxU32 nbSweepResults, PxU32 batchedSweepQstartIdx);\n\n\tPX_FORCE_INLINE\tPs::Mutex&\t\t\t\t\t\t\tgetLock()\t\t\t\t\t\t\t\t\t\t\t\t{ return mMutex;\t\t\t\t\t\t\t\t}\n\n\ttemplate <class T>\n\tPX_FORCE_INLINE\tconst char*\t\t\t\t\t\t\tgetArrayName(const NamedArray<T>& namedArray)\tconst\t{ return namedArray.mNames[mIsBatched];\t\t\t}\n\n\tPX_FORCE_INLINE\tconst NamedArray<PxGeometryHolder>&\tgetGeometries(PxU32 index)\t\t\t\t\t\tconst\t{ return index ? mGeometries1 : mGeometries0;\t}\n\tPX_FORCE_INLINE\tNamedArray<PxGeometryHolder>&\t\tgetGeometries(PxU32 index)\t\t\t\t\t\t\t\t{ return index ? mGeometries1 : mGeometries0;\t}\n\n\tPX_FORCE_INLINE\tconst NamedArray<PxGeometryHolder>& getCurrentFrameGeometries()\t\t\t\t\t\tconst\t{ return getGeometries(mInUse);\t\t\t\t\t}\n\tPX_FORCE_INLINE\tconst NamedArray<PxGeometryHolder>& getPrevFrameGeometries()\t\t\t\t\t\tconst\t{ return getGeometries(mInUse ^ 1);\t\t\t\t}\n\n\tvoid prepareNextFrameGeometries()\n\t{\n\t\tmInUse ^= 1;\n\t\tgetGeometries(mInUse).clear();\n\t}\n\n\tNamedArray<PvdRaycast>\t\tmAccumulatedRaycastQueries;\n\tNamedArray<PvdSweep>\t\tmAccumulatedSweepQueries;\n\tNamedArray<PvdOverlap>\t\tmAccumulatedOverlapQueries;\n\tNamedArray<PvdSqHit>\t\tmPvdSqHits;\n\tNamedArray<PxTransform>\t\tmPoses;\n\tNamedArray<PxFilterData>\tmFilterData;\n\nprivate:\n\tScb::Scene&\t\t\t\t\tmScene;\n\tPs::Mutex\t\t\t\t\tmMutex;\n\tNamedArray<PxGeometryHolder>mGeometries0;\n\tNamedArray<PxGeometryHolder>mGeometries1;\n\tPxU32\t\t\t\t\t\tmInUse;\n\tconst bool\t\t\t\t\tmIsBatched;\n};\n}\n}\n\n#endif // PX_SUPPORT_PVD\n\n#endif // NP_PVD_SCENEQUERYCOLLECTOR_H\n\n", "comment_ratio": 0.12931034482758622}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n\n#define LSDataInSection(secName) __attribute((used, section(\"__DATA,\"#secName\" \")))\n\n@interface LSRegisterHelper : NSObject\n\n+ (NSArray<Class> *)allMonitorModules;\n+ (NSArray<Class> *)allProcessors;\n\n@end\n\n", "comment_ratio": 0.3684210526315789}
{"lang": "c", "code": "#ifndef pipe_sem_h\n#define pipe_sem_h\n\ntypedef struct {\n    int fd[2];\n    int value;\n} pipe_sem_t;\n\n// Initializes a semaphore and sets its initial value.\nvoid pipe_sem_init(pipe_sem_t *sem, int value);\n\n// Performs a wait operation on the semaphore.\nvoid pipe_sem_wait(pipe_sem_t *sem);\n\n// Performs a signal operation on the semaphore.\nvoid pipe_sem_signal(pipe_sem_t *sem);\n\n#endif\n\n", "comment_ratio": 0.15789473684210525}
{"lang": "c", "code": "// SKIP PARAM: --sets solver td3 --set ana.activated \"['base','threadid','threadflag','mallocWrapper','octApron']\"\nvoid change(int *p) {\n    (*p)++;\n}\n\nint g;\nint main() {\n    int c = rand();\n    g = 3; // Globals are not tracked by octApron for now\n    assert(g != 3); // FAIL\n    assert(g == 3);\n    int a = 5;\n    int *p = &a; // after this octApron should put a to top because pointers are not tracked\n    change(p);\n    assert(a - 6 == 0);\n    return 0;\n}\n", "comment_ratio": 0.23529411764705882}
{"lang": "c", "code": "// arrayqueue.h\n// queue, implemented with an array\n\n#ifndef ARRAYQUEUE_H\n#define ARRAYQUEUE_H\n\n#include \"xassert.h\"           // xassert\n\n// needed operations on T:\n//   T()                       // default ctor\n//   operator=(T&)             // assignment\n//   bool operator==(T&)       // comparison\n\ntemplate <class T>\nclass ArrayQueue {\nprivate:     // data\n  T *arr;                      // working storage\n  int arrSize;                 // allocated length of 'arr'\n  int head;                    // index of first element to dequeue\n  int tail;                    // index+1 of last element to dequeue\n\n  // NOTE: If head == tail then the queue is empty.  If head > tail,\n  // then the queue elements circularly wrap around the end of 'arr'.\n  // At all times, 0 <= head,tail < arrSize.\n\npublic:      // funcs\n  ArrayQueue(int initSize = 10);\n  ~ArrayQueue();\n\n  // test # of elements in queue\n  int length() const\n    { return head<=tail? tail-head : arrSize-(head-tail); }\n  bool isEmpty() const                  { return head==tail; }\n  bool isNotEmpty() const               { return !isEmpty(); }\n\n  // add/remove elements in FIFO order\n  void enqueue(T const &t);\n  T dequeue();\n\n  // remove all elements\n  void empty()                          { head = tail = 0; }\n\n  // access elements of the queue in dequeue order; that is,\n  // element 0 is the next element to be dequeued, and element\n  // length()-1 is the element most recently enqueued\n  //\n  // as this interface is O(1), it is the intended method\n  // of iterating over the elements in the queue\n  T const &eltC(int index) const;\n  T &elt(int index)                     { return const_cast<T&>(eltC(index)); }\n  T &operator[] (int index)             { return elt(index); }\n  T const &operator[] (int index) const { return eltC(index); }\n\n  // reverse the sequence of stored elements\n  void reverse();\n\n  // true if a specific element is among the queue elements\n  bool contains(T const &t) const;\n};\n\n\ntemplate <class T>\nArrayQueue<T>::ArrayQueue(int initSize)\n{\n  // initial size must be positive, since array growth is\n  // simply by doubling the size\n  xassert(initSize > 0);\n\n  arr = new T[initSize];\n  arrSize = initSize;\n  head = tail = 0;\n}\n\n\ntemplate <class T>\nArrayQueue<T>::~ArrayQueue()\n{\n  delete[] arr;\n}\n\n\ntemplate <class T>\nvoid ArrayQueue<T>::enqueue(T const &t)\n{\n  if (length() == arrSize-1) {\n    // must expand the queue\n\n    // make new array\n    int newArrSize = arrSize * 2;\n    T *newArr = new T[newArrSize];\n\n    // copy elements sequentially\n    int oldLength = length();\n    for (int i=0; i<oldLength; i++) {\n      newArr[i] = eltC(i);\n    }\n\n    // discard old array\n    delete[] arr;\n\n    // put new one in its place\n    arr = newArr;\n    arrSize = newArrSize;\n    head = 0;\n    tail = oldLength;\n  }\n  \n  // store the new element where 'tail' points\n  arr[tail] = t;\n  \n  // advance 'tail'\n  if (++tail == arrSize) {\n    tail = 0;\n  }\n}\n\n\ntemplate <class T>\nT ArrayQueue<T>::dequeue()\n{\n  if (isEmpty()) {\n    xfailure(\"attempt to dequeue an empty queue\");\n  }\n\n  // advance 'head' while yielding the element it currently points at;\n  // avoid making an intermediate copy (for performance)\n  if (head == arrSize-1) {\n    head = 0;\n    return arr[arrSize-1];\n  }\n  else {\n    return arr[head++];\n  }\n}\n\n  \ntemplate <class T>\nT const &ArrayQueue<T>::eltC(int index) const\n{                         \n  xassert(0 <= index && index < length());\n\n  if (head+index < arrSize) {\n    return arr[head+index];\n  }\n  else {\n    return arr[head+index - arrSize];\n  }\n}\n\n\ntemplate <class T>\nvoid ArrayQueue<T>::reverse()\n{\n  int i = 0, j = length()-1;\n  while (i < j) {\n    // swap i,j elements\n    T tmp = elt(i);\n    elt(i) = elt(j);\n    elt(j) = tmp;\n\n    i++;\n    j--;\n  }\n}\n\n\ntemplate <class T>\nbool ArrayQueue<T>::contains(T const &t) const\n{                                 \n  int len=length();\n  for (int i=0; i<len; i++) {\n    if (t == eltC(i)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n\n#endif // ARRAYQUEUE_H\n\n", "comment_ratio": 0.22099447513812154}
{"lang": "c", "code": "#define ChatTimeFont [UIFont systemFontOfSize:11]   //\u65f6\u95f4\u5b57\u4f53\n#define ChatContentFont [UIFont systemFontOfSize:14]//\u5185\u5bb9\u5b57\u4f53\n\n\n#import <Foundation/Foundation.h>\n#import <CoreGraphics/CoreGraphics.h>\n\n@class YLChat;\n@interface YLChatFrame : NSObject\n\n@property (nonatomic ,strong) YLChat *chat;\n\n/** timeLab */\n@property (nonatomic, assign, readonly) CGRect timeFrame;\n\n/** \u5934\u50cfframe */\n@property (nonatomic, assign, readonly) CGRect iconFrame;\n\n/** \u6635\u79f0frame*/\n@property (nonatomic, assign, readonly) CGRect nickFrame;\n\n/** \u5185\u5bb9\u7684frame */\n@property (nonatomic, assign, readonly) CGRect contentFrame;\n\n/** cell\u9ad8\u5ea6 */\n@property (nonatomic, assign, readonly) CGFloat cellH;\n\n@end\n\n", "comment_ratio": 0.225}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n#import \"TFSSDKError.h\"\n\n/**\n * This delegate defines the different methods the client application needs to implement in order to handle differents events like message received, chat view minimized etc.\n */\n@protocol TFSSDKDelegate <NSObject>\n\n@optional\n\n/** onMessageReceived Notifies application when new messages(agent or VA) are received in the Chat. This is an optional notification and can be used to inform the user that the agent has sent messages.\n * @param data message Data object. Data received.\n */\n-(void)onMessageReceived:(NSArray*)data;\n\n/** onMessageDownloadStarted Notifies application that a download message process has begun. This is an optional notification.\n */\n-(void)onMessageDownloadStarted;\n\n/** onMessageDownloadComplete Notifies application that a download message process has completed. This is an optional notification.\n * @param error If an error is generated while downloading a message, this will contain the error information \n */\n-(void)onMessageDownloadComplete:(NSError *)error;\n\n/** onChatViewDismissed Notifies application when the chat view has been hidden from the end user. This is an optional notification and can be used to display a custom minimized button that the user can click to go back into chat.\n */\n-(void)onChatViewDismissed;\n\n/** onChatViewPresented Notifies application when the chat view has been displayed back to the end user. This is an optional notification and should be handled if the application developer needs to perform any application specific functions when chat screen gets presented\n */\n-(void)onChatViewPresented;\n\n/** onNavigationRequest Notifies application when a custom URL specified in configuration object is received in the  chat and has been clicked by the end user. This is an optional notification.\n * @param url Url on which navigation is requested.\n */\n-(void)onNavigationRequest:(NSString *)url;\n\n/** onCustomCardAction Notifies the application that a custom card was invoked. The control is transfered to the delegate which is the client app in this case.\n * @param cardName Name of custom card invoked.\n * @param cardData Data of custom card.\n */\n-(void)onCustomCardActionTriggered:(NSString *)cardName cardData:(NSDictionary *)cardData onSuccess:(nonnull void (^)(NSDictionary* _Nullable))onSuccess onError:(nonnull void (^)(NSDictionary* _Nullable))onError;\n\n/** onSDKError Notifies application when any error occurs on SDK side.\n * @param error TFSSDKError object which holds error information\n */\n-(void)onSDKError:(nonnull TFSSDKError *)error;\n\n@end\n\n", "comment_ratio": 0.1206896551724138}
{"lang": "c", "code": "#include \"client.h\"\nstatic char sound_dir[] = \"resource\";   /* Directory for sound files */\n\nstatic Bool wave_open = False;   /* Is Wavemix open & ready to play sounds? */\n\nstatic HANDLE hMixSession; /* Handle for Wavemix DLL */\n\n#ifdef M59_MSS\n#define SOUND_MAX_VOICES 16\nstatic int iNumVoices;\n\t// user defined data associated with sample handles\n#define SOUND_USER_ADDRESS 0\t// memory address of sample\n#define SOUND_USER_X 1\t\t\t// x and y position of sound source\n#define SOUND_USER_Y 2\n#define SOUND_USER_RADIUS 3\t\t// maximum distance sound is audible\n#define SOUND_USER_MAXVOL 4\t\t// maximum volume of sound (when distance = 0)\nstatic HSAMPLE SampleHandle[SOUND_MAX_VOICES];\t// array of sample handles\n\nstatic \tHDIGDRIVER hDriver;\t\t\t\t\t// handle to the digital audio driver\n#endif\n\n/******************************************************************************/\n/*\n * SoundInitialize:  Called at startup; initialize sound and MIDI devices.\n */\nvoid SoundInitialize(void)\n{\n\n   if (config.soundLibrary == LIBRARY_NIL)\n   {\n      wave_open = FALSE;\n      return;\n   }\n\n#ifdef M59_MSS\n\n   {\n\tint i;\n\tfor( i = 0; i < SOUND_MAX_VOICES; i++ )\n\t\tSampleHandle[i] = NULL;\n\n        wave_open = FALSE;\n        debug((\"SoundInitialize: starting library\\n\"));\n\n\t// it's ok to do this more than once, and we do,\n\t//\tonce in MusicInitialize and once here\n\tAIL_startup();\n\n\t// prefer a 22K device, to match our WAV files\n\thDriver = WAVE_init_driver(22050, 8, 1);\n\t// next choice is a 44K device\n\tif( hDriver == NULL )\n\t\thDriver = WAVE_init_driver(44100, 8, 1);\n\t// finally try an 11K device\n\tif( hDriver == NULL )\n\t\thDriver = WAVE_init_driver(11025, 8, 1);\n\n\t// prefer a 22K device, to match WAV files\n\tif( hDriver == NULL )\n\t\thDriver = WAVE_init_driver(22050, 8, 1);\n\t// next choice is a 44K device\n\tif( hDriver == NULL )\n\t\thDriver = WAVE_init_driver(44100, 8, 1);\n\t// finally try an 11K device\n\tif( hDriver == NULL )\n\t\thDriver = WAVE_init_driver(11025, 8, 1);\n\tif( hDriver == NULL )\n\t{\n\t\tdebug(( \"MSS digital sound failed to initialize.\\n\" ));\n\t\twave_open = FALSE;\n\t\treturn;\n\t}\n\n\t// allocate sample handles\n\tfor( i=0; i < SOUND_MAX_VOICES; i++ )\n\t{\n\t\tSampleHandle[i] = AIL_allocate_sample_handle( hDriver );\n\n\t\t// clear user data (sample addresses, looper locations)\n\t\tAIL_set_sample_user_data( SampleHandle[i], SOUND_USER_ADDRESS, 0 );\n\t\tAIL_set_sample_user_data( SampleHandle[i], SOUND_USER_X, 0 );\n\t\tAIL_set_sample_user_data( SampleHandle[i], SOUND_USER_Y, 0 );\n\t\tAIL_set_sample_user_data( SampleHandle[i], SOUND_USER_RADIUS, 0 );\n\t\tAIL_set_sample_user_data( SampleHandle[i], SOUND_USER_MAXVOL, 0 );\n\n\t\tif( SampleHandle[i] == NULL )\n\t\t\tbreak;\n\t}\n\n\tiNumVoices = i;\n\tdebug(( \"MSS digital sound initialized successfully.\\n\" ));\n\tdebug(( \"%i simultaneous voices available.\\n\", iNumVoices ));\n\n\twave_open = True;\n   }\n\n#else\n\n   {\n   MCI_SYSINFO_PARMS mciSysinfoParms;\n   DWORD num_devices, retval;\n   Bool has_wave = False;\n\n   /* See if WAV player is present */\n   mciSysinfoParms.lpstrReturn = (LPSTR) &num_devices;\n   mciSysinfoParms.dwRetSize = sizeof(num_devices);\n   mciSysinfoParms.wDeviceType = MCI_DEVTYPE_WAVEFORM_AUDIO;\n   retval = mciSendCommand(0, MCI_SYSINFO, MCI_SYSINFO_QUANTITY,\n\t\t  (DWORD) &mciSysinfoParms);\n   if (retval == 0 && num_devices > 0)\n      has_wave = True;\n\n   /* Start Wave mixer */\n   if (has_wave)\n   {\n      if ((hMixSession = WaveMixInit()) == NULL)\n      {\n\t debug((\"WaveMixInit returned error\\n\"));\n\t wave_open = False;\n      }\n      else wave_open = True;\n\n      if (WaveMixOpenChannel(hMixSession, 0, WMIX_ALL))\n      {\n\t debug((\"WaveMixOpenChannel returned error\\n\"));\n\t wave_open = False;\n      }\n      if (WaveMixActivate(hMixSession, TRUE) != MMSYSERR_NOERROR)\n      {\n\t debug((\"WaveMixActivate returned error\\n\"));\n\t wave_open = False;\n      }\n   }\n   }\n#endif\n}\n#ifdef M59_MSS\n/******************************************************************************/\n/*\n * WAVE_init_driver: Initialize a digital output driver\n */\nstatic HDIGDRIVER WAVE_init_driver( DWORD rate, WORD bits, WORD chans )\n{\n\tchar buf[128];\n\n   HDIGDRIVER DIG = AIL_open_digital_driver(rate, bits, chans, 0);\n\n\tif (DIG == NULL)\n\t{\n\t\tdebug((AIL_last_error()));\n\t\treturn NULL;\n\t}\n\n\tstrcpy(buf,\"Device: \");\n\tAIL_digital_configuration(DIG,0,0,buf+strlen(buf));\n\tdebug((\"%s\\n\",buf));\n\n   return DIG;\n}\n#endif\n/******************************************************************************/\n/*\n * SoundClose: Close all sound and music devices.\n */\nvoid SoundClose(void)\n{\n   if (wave_open)\n   {\n#ifdef M59_MSS\n\n      int npFreeUps = 0, i, j;\n      void* apSampleAddresses[SOUND_MAX_VOICES];\n\n      void *pSampleAddress;\n\n      debug((\"SoundClose: ending samples\\n\"));\n\n      // end any samples playing to clean up their handles and memory\n\n      for (j = 0; j < SOUND_MAX_VOICES; j++)\n\t apSampleAddresses[j] = NULL;\n\n      for ( i = 0; i < iNumVoices; i++ )\n      {\n\t //debug((\"Releasing sound handle %i\\n\",i ));\n\n\t pSampleAddress = (void *)AIL_sample_user_data(SampleHandle[i], SOUND_USER_ADDRESS);\n\t AIL_release_sample_handle(SampleHandle[i]);\n\n\t if (pSampleAddress)\n\t {\n\t    for (j = 0; j < npFreeUps; j++)\n\t    {\n\t       if (apSampleAddresses[j] == pSampleAddress)\n\t       {\n\t\t  break;\n\t       }\n\t    }\n\t    if (j >= npFreeUps)\n\t       apSampleAddresses[npFreeUps++] = pSampleAddress;\n\t }\n      }\n\n      debug((\"SoundClose: pausing\\n\"));\n\n      Sleep(1500);\n\n      debug((\"SoundClose: freeing samples\\n\"));\n\n      for (j = 0; j < npFreeUps; j++)\n\t AIL_mem_free_lock(apSampleAddresses[j]);\n\n      debug((\"SoundClose: done\\n\"));\n\n      // Don't want to shutdown, since music may still be playing\n      // Done in MusicClose() instead\n      //AIL_shutdown();\n\n#else\n      WaveMixCloseChannel(hMixSession, 0, WMIX_ALL);\n      WaveMixCloseSession(hMixSession);\n#endif\n      wave_open = False;\n   }\n}\n/******************************************************************************/\n/*\n * PlayWaveFile:  Send given wave file to mixer to play.\n *   Sound is played at given volume, where 0 = silence and MAX_VOLUME = normal volume\n *\t Looping sounds update volume as player moves using row, col for sound source location\n *\t\tand radius and max_vol as attenuation parameters\n * Returns 0 on success; nonzero on error.\n */\nUINT PlayWaveFile(HWND hwnd, char *fname, int volume, BYTE flags, int src_row, int src_col, int radius, int max_vol)\n{\n   if (!wave_open)\n      return TRUE;\n\n#ifdef M59_MSS\n\n\tint i, iRandomPitch;\n\tvoid FAR *pSample;\n\tdebug((\"Reading sound file %s.\\n\",fname));\n\t// let Miles allocate the memory\n\tpSample=AIL_file_read( fname, NULL );\n\n\tif( pSample == NULL )\n\t{\n\t\tdebug(( \"Error reading sound file %s.\\n\", fname ));\n\t\treturn 1L;\n\t}\n\n\t// Quick configuration escape for especially annoying sound types.\n\tif ((flags & SF_LOOP) && (!config.play_loop_sounds))\n\t\treturn 0;\n\tif ((flags & SF_RANDOM_PLACE) && (!config.play_random_sounds))\n\t\treturn 0;\n\n\t// Find an HSAMPLE to play it\n\tfor( i=0; i < iNumVoices; i++ )\n\t{\n\t\tif( AIL_sample_user_data( SampleHandle[i], SOUND_USER_ADDRESS ) == 0 )\n\t\t\tbreak;\n\t}\n\n   // If no samples available, ignore request\n\tif( i == iNumVoices )\n\t{\n\t\tdebug((\"Too many sounds to play at once!\\n\"));\n\t\tAIL_mem_free_lock( pSample );\n\t\treturn 1L;\n\t}\n\n\tif (!AIL_set_named_sample_file(SampleHandle[i], fname, pSample,\n                                  AIL_file_size(fname), 0))\n\t{\n\t\tdebug((\"Error initializing sound sample.\\n\" ));\n\t\tAIL_mem_free_lock( pSample );\n\t\treturn 1L;\n\t}\n\n\t// Set initial volume and rate\n   float vol = (float) volume / MAX_VOLUME;\n   vol = vol * config.sound_volume / CONFIG_MAX_VOLUME;\n\tAIL_set_sample_volume_levels( SampleHandle[i], vol, vol );\n\n\t// If random pitch flag is set, diddle the pitch  by +/- 10%\n\tif( flags & SF_RANDOM_PITCH )\n\t{\n\t\tiRandomPitch = ( rand() % 21 - 10 + 100 ) * AIL_sample_playback_rate( SampleHandle[i] ) / 100;\n\t\tAIL_set_sample_playback_rate( SampleHandle[i],iRandomPitch);\n\t}\n\n\t// Set it to loop if flag is set\n\tif( flags & SF_LOOP )\n\t{\n\t\tAIL_set_sample_loop_count( SampleHandle[i], 0 );\t// 0 = infinite\n//\t\tdebug(( \"Looping sound on voice %i.\\n\",i ));\n\n\t\t// save x and y pos of sound source, and cutoff radius and max volume\n//\t\tdebug((\"Sound source at: (%i,%i)\\n\",src_col,src_row ));\n\t\tAIL_set_sample_user_data( SampleHandle[i], SOUND_USER_X, src_col );\n\t\tAIL_set_sample_user_data( SampleHandle[i], SOUND_USER_Y, src_row );\n\t\tAIL_set_sample_user_data( SampleHandle[i], SOUND_USER_RADIUS, radius );\n\t\tAIL_set_sample_user_data( SampleHandle[i], SOUND_USER_MAXVOL, max_vol );\n//\t\tdebug((\"Setting volume to %i.\\n\",volume));\n\t}\n\n\t// Finally, activate sample\n//\tdebug((\"Playing sound with voice %i, flags=%i.\\n\",i,flags));\n\tAIL_start_sample( SampleHandle[i] );\n\tAIL_set_sample_user_data( SampleHandle[i], SOUND_USER_ADDRESS, (S32) pSample );\n\n\t//\tregister callback to free memory allocated\n\tAIL_register_EOS_callback( SampleHandle[i], SoundDoneCallback );\n\n\treturn 0;\n#else\n   MIXPLAYPARAMS params;\n   LPMIXWAVE lpWave;\n   UINT retval;\n   \n   lpWave = WaveMixOpenWave(hMixSession, fname, hInst, WMIX_FILE, volume);\n   if (lpWave == NULL)\n   {\n      debug((\"Error opening wave file %s\\n\", fname));\n      return 1;\n   }\n   \n   /* Send sound to any available channel; play exactly once */\n   /* hwnd is sent a MM_WOM_DONE message when the sound has finished playing */\n   params.wSize = sizeof(MIXPLAYPARAMS);\n   params.hMixSession = hMixSession;\n   params.iChannel = 0;\n   params.lpMixWave = lpWave;\n   params.hWndNotify = hwnd;\n   params.dwFlags = WMIX_CLEARQUEUE | WMIX_HIPRIORITY | WMIX_USELRUCHANNEL;\n   params.wLoops = (flags & SF_LOOP) ? 0xFFFF : 0;\n   \n   if (retval = WaveMixPlay(&params)) \n      debug((\"WaveMixPlay failed, error = %d\\n\", retval));\n   \n   return retval;\n#endif\n}\n/******************************************************************************/\n/*\n * PlayWaveRsc:  Play wave file associated with given resource number.\n *   Sound is played at given volume, where 0 = silence and MAX_VOLUME = normal volume\n *\t Looping sounds update volume as player moves using row, col for sound source location\n *\t\tand radius and max_vol as attenuation parameters\n */\nvoid PlayWaveRsc(ID rsc, int volume, BYTE flags, int row, int col, int radius, int max_vol)\n{\n   char *filename, fname[MAX_PATH + FILENAME_MAX], game_path[MAX_PATH];\n   \n   if (!config.play_sound || !wave_open)\n      return;\n\n   if ((filename = LookupNameRsc(rsc)) == NULL)\n   {\n      debug((\"Couldn't find filename for wave resource %s\\n\", rsc));\n      return;\n   }\n\n   GetGamePath(game_path);\n   sprintf(fname, \"%s%s\\\\%.*s\", game_path, sound_dir, FILENAME_MAX, filename);\n   \n   PlayWaveFile(hMain, fname, volume, flags, row, col, radius, max_vol);\n}\n/******************************************************************************/\n/*\n * SoundDone:  A sound has finished playing; close appropriate device element.\n */\n#ifdef M59_MSS\nvoid SoundDone( HWND hwnd, WPARAM wParam, LPARAM lParam )\n{\n\tint i;\n\tHSAMPLE hSample;\n\tvoid *pSampleAddress;\n\thSample = (HSAMPLE) wParam;\n\n\tfor( i = 0; i < iNumVoices; i++ )\n\t{\n\t\tif( SampleHandle[i] == hSample )\n\t\t{\n\t\t\tif( AIL_sample_status( SampleHandle[i] ) == SMP_FREE )\n\t\t\t{\n//\t\t\t\tdebug((\"Sound handle %i already marked as free.\\n\", i));\n\t\t\t\treturn;\t //  SoundClose has already freed the memory, in this case\n\t\t\t}\n\t\t\telse if( AIL_sample_status( SampleHandle[i] ) != SMP_DONE )\n\t\t\t{\n\t\t\t\tdebug((\"Can't free memory, since sound %i still playing!\\n\", i));\n\t\t\t\tdebug((\"Re-posting message...\\n\"));\n\t\t\t\tPostMessage( hMain, MM_WOM_DONE, (WPARAM) hSample, 0 );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tpSampleAddress = (void *)AIL_sample_user_data( SampleHandle[i], SOUND_USER_ADDRESS );\n\n\t\t\tAIL_mem_free_lock( pSampleAddress );\n\t\t\tAIL_set_sample_user_data( SampleHandle[i], SOUND_USER_ADDRESS, 0 );\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif( i >= iNumVoices )\n\t\tdebug((\"Sound error: tried to free memory for nonexistent handle!\"));\n}\n#else\nvoid SoundDone(HWND hwnd, int iChannel, LPMIXWAVE lpMixWave)\n{\n   WaveMixFreeWave(hMixSession, lpMixWave);\n   // debug((\"Stopping sound, channel = %d\\n\", iChannel));\n}\n\n#endif\n/******************************************************************************/\n/*\n * SoundDoneCallback:  A sound has finished playing; send a windows message to invoke SoundDone.\n *\t\t\t\t\t\tWould love to call SoundDone directly, but can't call mem_free_lock from\n *\t\t\t\t\t\twithin the callback, so post a Windows message instead\n */                             /*  */\n#ifdef M59_MSS\nvoid AILCALLBACK SoundDoneCallback( HSAMPLE S )\n{\n\tPostMessage( hMain, MM_WOM_DONE, (WPARAM) S, 0 );\n}\n#endif\n/******************************************************************************/\n/*\n * UpdateLoopingSounds:  Adjust the volume of each looping sound\n *    to reflect a change in the player's position\n */\nvoid UpdateLoopingSounds( int px, int py)\n{\n#ifdef M59_MSS\n   int i;\n\n   for( i=0; i < iNumVoices; i++ )\n   {\n      if( AIL_sample_status( SampleHandle[i] ) != SMP_DONE )\n      {\n         if( AIL_sample_loop_count( SampleHandle[i] ) == 0 )\n         {\n            // looping sound volume falls off linearly w/ distance\n            int vol = 0;\n            int dx = px - (int)AIL_sample_user_data( SampleHandle[i], SOUND_USER_X );\n            int dy = py - (int)AIL_sample_user_data( SampleHandle[i], SOUND_USER_Y );\n            int cutoff = (int)AIL_sample_user_data( SampleHandle[i], SOUND_USER_RADIUS );\n            int maxvolume = (int)AIL_sample_user_data( SampleHandle[i], SOUND_USER_MAXVOL );\n            int distance = Distance(dx, dy);\n            if (distance < cutoff)\n            {\n               vol = maxvolume - (distance * maxvolume / cutoff);\n            }\n            // debug((\"Distance = %i\\n\",distance));\n            // debug((\"Setting volume to %i.\\n\",vol));\n            float volume = (float) vol / MAX_VOLUME;\n            volume = volume * config.sound_volume / CONFIG_MAX_VOLUME;\n            AIL_set_sample_volume_levels( SampleHandle[i], volume, volume );\n         }\n      }\n   }\n#endif\n}\n/******************************************************************************/\n/*\n * SoundAbort:  Turn off currently playing sounds\n */\nvoid SoundAbort(void)\n{\n   if (wave_open)\n   {\n#ifdef M59_MSS\n\tint i;\n//\tdebug((\"Shutting off all sounds.\\n\"));\n\t// end any samples playing to clean up their handles and memory\n\tfor( i = 0; i < iNumVoices; i++ )\n\t{\n\t\tif( SampleHandle[i] != NULL )\n\t\t\tif( AIL_sample_status( SampleHandle[i] ) != SMP_DONE )\n\t\t\t\tAIL_end_sample( SampleHandle[i] );\n\t}\n#else\n      /* Stop all playing sounds */\n      WaveMixFlushChannel(hMixSession, 0, WMIX_ALL | WMIX_NOREMIX);\n#endif\n   }\n}\n\n", "comment_ratio": 0.10276679841897234}
{"lang": "c", "code": "//@+leo-ver=4-thin\n//@+node:leonardoce.20090629082550.190:@thin quattro_parser.h\n//@@language c\n#ifndef __QUATTRO_PARSER_H\n#define __QUATTRO_PARSER_H\n\n#include <stdio.h>\n\n//@+others\n//@+node:leonardoce.20090629082550.230:ForthWord\n/****c* forth/ForthWord\n * NAME\n *   ForthWord\n * FUNCTION\n *   Rappresenta una parola di forth\n * SOURCE\n */\ntypedef struct ForthWord ForthWord;\nstruct ForthWord {\n  char *fileName;\n  char *stringValue;\n  int intValue;\n  double doubleValue;\n\n  int wordType;\n  int row, col;\n};\n\nenum ForthWordType {\n  UNKNOWN_WORD,\n  INT_WORD,\n  DOUBLE_WORD,\n  EXECUTE_WORD\n};\n\nForthWord *ForthWord_NewExecute(const char *fileName, const char *forthString, int row, int col);\nForthWord *ForthWord_NewInt(const char *fileName, int value, int row, int col);\nForthWord *ForthWord_NewDouble(const char *fileName, double value, int row, int col);\nvoid ForthWord_Delete(ForthWord *self);\nvoid ForthWord_Dump(ForthWord *self);\n/****/\n//@-node:leonardoce.20090629082550.230:ForthWord\n//@+node:leonardoce.20090629082550.231:ForthStream\n/****c* forth/ForthStream\n * NAME\n *   ForthStream\n * FUNCTION\n *   Stream di ingresso di parole Forth\n * SOURCE\n */\ntypedef struct ForthStream ForthStream;\nstruct ForthStream {\n  char *buffer;\n  int row, col;\n  int index;\n\n  int fileSize;\n  char *fileName;\n};\n\n\nForthStream *ForthStream_NewForFile( const char *fileName );\nForthStream *ForthStream_NewForBuffer( const char *fileName, const char *buffer );\nvoid ForthStream_ResetForBuffer(ForthStream *self, const char *fileName, const char *buffer);\nvoid ForthStream_Delete(ForthStream *self);\nForthWord *ForthStream_ParseWord( ForthStream *in );\nvoid ForthStream_SkipSpaces( ForthStream *in );\nint ForthStream_Eof( ForthStream *self );\nchar ForthStream_Getc( ForthStream *self );\nvoid ForthStream_Ungetc( ForthStream *self );\nint forthIsSpace( char c );\n/****/\n//@-node:leonardoce.20090629082550.231:ForthStream\n//@-others\n\n#endif\n//@-node:leonardoce.20090629082550.190:@thin quattro_parser.h\n//@-leo\n\n", "comment_ratio": 0.13924050632911392}
{"lang": "c", "code": "\n/*\ngcc -o v8crypto v8crypto.c -march=armv8-a -mfpu=crypto-neon-fp-armv8\ngcc -o v8crypto v8crypto.c -mfpu=crypto-neon-fp-armv8\n*/\n\n#include <stdio.h>\n#include <assert.h>\n#include <malloc.h>  // memalign\n#include <string.h>  // memset\n#include \"tests/malloc.h\"\n#include <math.h>    // isnormal\n\ntypedef  unsigned char           UChar;\ntypedef  unsigned short int      UShort;\ntypedef  unsigned int            UInt;\ntypedef  signed int              Int;\ntypedef  unsigned char           UChar;\ntypedef  unsigned long long int  ULong;\ntypedef  signed long long int    Long;\ntypedef  double                  Double;\ntypedef  float                   Float;\n\ntypedef  unsigned char           Bool;\n#define False ((Bool)0)\n#define True  ((Bool)1)\n\n\n#define ITERS 1\n\ntypedef\n  enum { TyHF=1234, TySF, TyDF, TyB, TyH, TyS, TyD, TyNONE }\n  LaneTy;\n\nunion _V128 {\n   UChar  u8[16];\n   UShort u16[8];\n   UInt   u32[4];\n   ULong  u64[2];\n   Float  f32[4];\n   Double f64[2];\n};\ntypedef  union _V128   V128;\n\nstatic inline UChar randUChar ( void )\n{\n   static UInt seed = 80021;\n   seed = 1103515245 * seed + 12345;\n   return (seed >> 17) & 0xFF;\n}\n\n//static ULong randULong ( LaneTy ty )\n//{\n//   Int i;\n//   ULong r = 0;\n//   for (i = 0; i < 8; i++) {\n//      r = (r << 8) | (ULong)(0xFF & randUChar());\n//   }\n//   return r;\n//}\n\n/* Generates a random V128.  Ensures that that it contains normalised\n   FP numbers when viewed as either F32x4 or F64x2, so that it is\n   reasonable to use in FP test cases. */\nstatic void randV128 ( /*OUT*/V128* v, LaneTy ty )\n{\n   static UInt nCalls = 0, nIters = 0;\n   Int i;\n   nCalls++;\n   while (1) {\n      nIters++;\n      for (i = 0; i < 16; i++) {\n         v->u8[i] = randUChar();\n      }\n      if (isnormal(v->f32[0]) && isnormal(v->f32[1]) && isnormal(v->f32[2])\n          && isnormal(v->f32[3]) && isnormal(v->f64[0]) && isnormal(v->f64[1]))\n        break;\n   }\n   if (0 == (nCalls & 0xFF))\n      printf(\"randV128: %u calls, %u iters\\n\", nCalls, nIters);\n}\n\nstatic void showV128 ( V128* v )\n{\n   Int i;\n   for (i = 15; i >= 0; i--)\n      printf(\"%02x\", (Int)v->u8[i]);\n}\n\n//static void showBlock ( const char* msg, V128* block, Int nBlock )\n//{\n//   Int i;\n//   printf(\"%s\\n\", msg);\n//   for (i = 0; i < nBlock; i++) {\n//      printf(\"  \");\n//      showV128(&block[i]);\n//      printf(\"\\n\");\n//   }\n//}\n\n\n/* ---------------------------------------------------------------- */\n/* -- Parameterisable test macros                                -- */\n/* ---------------------------------------------------------------- */\n\n#define DO50(_action) \\\n   do { \\\n      Int _qq; for (_qq = 0; _qq < 50; _qq++) { _action ; } \\\n   } while (0)\n\n\n/* Generate a test that involves two vector regs,\n   with no bias as towards which is input or output. \n   It's OK to use r8 as scratch.*/\n#define GEN_TWOVEC_TEST(TESTNAME,INSN,VECREG1NO,VECREG2NO) \\\n  __attribute__((noinline)) \\\n  static void test_##TESTNAME ( LaneTy ty ) { \\\n     Int i; \\\n     for (i = 0; i < ITERS; i++) { \\\n        V128 block[4+1]; \\\n        memset(block, 0x55, sizeof(block)); \\\n        randV128(&block[0], ty); \\\n        randV128(&block[1], ty); \\\n        randV128(&block[2], ty); \\\n        randV128(&block[3], ty); \\\n        __asm__ __volatile__( \\\n           \"mov r9, #0 ; vmsr fpscr, r9 ; \" \\\n           \"add r9, %0, #0  ; vld1.8 { q\"#VECREG1NO\" }, [r9] ; \" \\\n           \"add r9, %0, #16 ; vld1.8 { q\"#VECREG2NO\" }, [r9] ; \" \\\n           INSN \" ; \" \\\n           \"add r9, %0, #32 ; vst1.8 { q\"#VECREG1NO\" }, [r9] ; \" \\\n           \"add r9, %0, #48 ; vst1.8 { q\"#VECREG2NO\" }, [r9] ; \" \\\n           \"vmrs r9, fpscr ; str r9, [%0, #64] \" \\\n           : : \"r\"(&block[0]) \\\n             : \"cc\", \"memory\", \"q\"#VECREG1NO, \"q\"#VECREG2NO, \"r8\", \"r9\" \\\n        ); \\\n        printf(INSN   \"   \"); \\\n        UInt fpscr = 0xFFFFFFFF & block[4].u32[0]; \\\n        showV128(&block[0]); printf(\"  \"); \\\n        showV128(&block[1]); printf(\"  \"); \\\n        showV128(&block[2]); printf(\"  \"); \\\n        showV128(&block[3]); printf(\" fpscr=%08x\\n\", fpscr); \\\n     } \\\n  }\n\n\n/* Generate a test that involves three vector regs,\n   with no bias as towards which is input or output.  It's also OK\n   to use r8 scratch. */\n#define GEN_THREEVEC_TEST(TESTNAME,INSN,VECREG1NO,VECREG2NO,VECREG3NO)  \\\n  __attribute__((noinline)) \\\n  static void test_##TESTNAME ( LaneTy ty ) { \\\n     Int i; \\\n     for (i = 0; i < ITERS; i++) { \\\n        V128 block[6+1]; \\\n        memset(block, 0x55, sizeof(block)); \\\n        randV128(&block[0], ty); \\\n        randV128(&block[1], ty); \\\n        randV128(&block[2], ty); \\\n        randV128(&block[3], ty); \\\n        randV128(&block[4], ty); \\\n        randV128(&block[5], ty); \\\n        __asm__ __volatile__( \\\n           \"mov r9, #0 ; vmsr fpscr, r9 ; \" \\\n           \"add r9, %0, #0  ; vld1.8 { q\"#VECREG1NO\" }, [r9] ; \" \\\n           \"add r9, %0, #16 ; vld1.8 { q\"#VECREG2NO\" }, [r9] ; \" \\\n           \"add r9, %0, #32 ; vld1.8 { q\"#VECREG3NO\" }, [r9] ; \" \\\n           INSN \" ; \" \\\n           \"add r9, %0, #48 ; vst1.8 { q\"#VECREG1NO\" }, [r9] ; \" \\\n           \"add r9, %0, #64 ; vst1.8 { q\"#VECREG2NO\" }, [r9] ; \" \\\n           \"add r9, %0, #80 ; vst1.8 { q\"#VECREG3NO\" }, [r9] ; \" \\\n           \"vmrs r9, fpscr ; str r9, [%0, #96] \" \\\n           : : \"r\"(&block[0]) \\\n           : \"cc\", \"memory\", \"q\"#VECREG1NO, \"q\"#VECREG2NO, \"q\"#VECREG3NO, \\\n             \"r8\", \"r9\" \\\n        ); \\\n        printf(INSN   \"   \"); \\\n        UInt fpscr = 0xFFFFFFFF & block[6].u32[0]; \\\n        showV128(&block[0]); printf(\"  \"); \\\n        showV128(&block[1]); printf(\"  \"); \\\n        showV128(&block[2]); printf(\"  \"); \\\n        showV128(&block[3]); printf(\"  \"); \\\n        showV128(&block[4]); printf(\"  \"); \\\n        showV128(&block[5]); printf(\" fpscr=%08x\\n\", fpscr); \\\n     } \\\n  }\n\n// ======================== CRYPTO ========================\n\nGEN_TWOVEC_TEST(aesd_q_q,   \"aesd.8 q3, q4\",     3,  4)\nGEN_TWOVEC_TEST(aese_q_q,   \"aese.8 q12, q13\",  12, 13)\nGEN_TWOVEC_TEST(aesimc_q_q, \"aesimc.8 q15, q0\", 15,  0)\nGEN_TWOVEC_TEST(aesmc_q_q,  \"aesmc.8 q1, q9\",    1,  9)\n\nGEN_THREEVEC_TEST(sha1c_q_q_q,   \"sha1c.32 q11, q10, q2\",   11, 10, 2)\nGEN_TWOVEC_TEST(sha1h_q_q,       \"sha1h.32 q6, q7\",         6, 7)\nGEN_THREEVEC_TEST(sha1m_q_q_q,   \"sha1m.32 q2, q8, q13\",    2, 8, 13)\nGEN_THREEVEC_TEST(sha1p_q_q_q,   \"sha1p.32 q3, q9, q14\",    3, 9, 14)\nGEN_THREEVEC_TEST(sha1su0_q_q_q, \"sha1su0.32 q4, q10, q15\", 4, 10, 15)\nGEN_TWOVEC_TEST(sha1su1_q_q,     \"sha1su1.32 q11, q2\",      11, 2)\n\nGEN_THREEVEC_TEST(sha256h2_q_q_q,  \"sha256h2.32 q9, q8, q7\",     9, 8, 7)\nGEN_THREEVEC_TEST(sha256h_q_q_q,   \"sha256h.32 q10, q9, q8\",     10, 9, 8)\nGEN_TWOVEC_TEST(sha256su0_q_q,     \"sha256su0.32 q11, q10\",      11, 10)\nGEN_THREEVEC_TEST(sha256su1_q_q_q, \"sha256su1.32 q12, q11, q10\", 12, 11, 10)\n\n// This is a bit complex.  This really mentions three registers, so it\n// should really be a THREEVEC variant.  But the two source registers\n// are D registers.  So we say it is just a TWOVEC insn, producing a Q\n// and taking a single Q (q7); q7 is the d14-d15 register pair, which\n// is why the insn itself is mentions d14 and d15 whereas the\n// numbers that follow mention q7.  The result (q7) is 128 bits wide and\n// so is unaffected by these shenanigans.\nGEN_TWOVEC_TEST(pmull_q_d_d,  \"vmull.p64 q13, d14, d15\", 13, 7)\n\nint main ( void )\n{\n   // ======================== CRYPTO ========================\n\n   // aesd.8     q_q (aes single round decryption)\n   // aese.8     q_q (aes single round encryption)\n   // aesimc.8   q_q (aes inverse mix columns)\n   // aesmc.8    q_q (aes mix columns)\n   if (1) DO50( test_aesd_q_q(TyNONE) );\n   if (1) DO50( test_aese_q_q(TyNONE) );\n   if (1) DO50( test_aesimc_q_q(TyNONE) );\n   if (1) DO50( test_aesmc_q_q(TyNONE) );\n\n   // sha1c.32   q_q_q\n   // sha1h.32   q_q\n   // sha1m.32   q_q_q\n   // sha1p.32   q_q_q\n   // sha1su0.32 q_q_q\n   // sha1su1.32 q_q\n   if (1) DO50( test_sha1c_q_q_q(TyNONE) );\n   if (1) DO50( test_sha1h_q_q(TyNONE) );\n   if (1) DO50( test_sha1m_q_q_q(TyNONE) );\n   if (1) DO50( test_sha1p_q_q_q(TyNONE) );\n   if (1) DO50( test_sha1su0_q_q_q(TyNONE) );\n   if (1) DO50( test_sha1su1_q_q(TyNONE) );\n\n   // sha256h2.32  q_q_q\n   // sha256h.32   q_q_q\n   // sha256su0.32 q_q\n   // sha256su1.32 q_q_q\n   if (1) DO50( test_sha256h2_q_q_q(TyNONE) );\n   if (1) DO50( test_sha256h_q_q_q(TyNONE) );\n   if (1) DO50( test_sha256su0_q_q(TyNONE) );\n   if (1) DO50( test_sha256su1_q_q_q(TyNONE) );\n\n   // vmull.64  q_d_d\n   if (1) DO50( test_pmull_q_d_d(TyD) );\n\n   return 0;\n}\n\n", "comment_ratio": 0.1796875}
{"lang": "c", "code": "#ifndef LLVM_LIB_TARGET_NVPTX_NVPTXMCEXPR_H\n#define LLVM_LIB_TARGET_NVPTX_NVPTXMCEXPR_H\n\n#include \"llvm/ADT/APFloat.h\"\n#include \"llvm/MC/MCExpr.h\"\n\nnamespace llvm {\n\nclass NVPTXFloatMCExpr : public MCTargetExpr {\npublic:\n  enum VariantKind {\n    VK_NVPTX_None,\n    VK_NVPTX_SINGLE_PREC_FLOAT,   // FP constant in single-precision\n    VK_NVPTX_DOUBLE_PREC_FLOAT    // FP constant in double-precision\n  };\n\nprivate:\n  const VariantKind Kind;\n  const APFloat Flt;\n\n  explicit NVPTXFloatMCExpr(VariantKind Kind, APFloat Flt)\n      : Kind(Kind), Flt(Flt) {}\n\npublic:\n  /// @name Construction\n  /// @{\n\n  static const NVPTXFloatMCExpr *create(VariantKind Kind, APFloat Flt,\n                                        MCContext &Ctx);\n\n  static const NVPTXFloatMCExpr *createConstantFPSingle(APFloat Flt,\n                                                        MCContext &Ctx) {\n    return create(VK_NVPTX_SINGLE_PREC_FLOAT, Flt, Ctx);\n  }\n\n  static const NVPTXFloatMCExpr *createConstantFPDouble(APFloat Flt,\n                                                        MCContext &Ctx) {\n    return create(VK_NVPTX_DOUBLE_PREC_FLOAT, Flt, Ctx);\n  }\n\n  /// @}\n  /// @name Accessors\n  /// @{\n\n  /// getOpcode - Get the kind of this expression.\n  VariantKind getKind() const { return Kind; }\n\n  /// getSubExpr - Get the child of this expression.\n  APFloat getAPFloat() const { return Flt; }\n\n/// @}\n\n  void printImpl(raw_ostream &OS, const MCAsmInfo *MAI) const override;\n  bool evaluateAsRelocatableImpl(MCValue &Res,\n                                 const MCAsmLayout *Layout,\n                                 const MCFixup *Fixup) const override {\n    return false;\n  }\n  void visitUsedExpr(MCStreamer &Streamer) const override {};\n  MCFragment *findAssociatedFragment() const override { return nullptr; }\n\n  // There are no TLS NVPTXMCExprs at the moment.\n  void fixELFSymbolsInTLSFixups(MCAssembler &Asm) const override {}\n\n  static bool classof(const MCExpr *E) {\n    return E->getKind() == MCExpr::Target;\n  }\n};\n\n/// A wrapper for MCSymbolRefExpr that tells the assembly printer that the\n/// symbol should be enclosed by generic().\nclass NVPTXGenericMCSymbolRefExpr : public MCTargetExpr {\nprivate:\n  const MCSymbolRefExpr *SymExpr;\n\n  explicit NVPTXGenericMCSymbolRefExpr(const MCSymbolRefExpr *_SymExpr)\n      : SymExpr(_SymExpr) {}\n\npublic:\n  /// @name Construction\n  /// @{\n\n  static const NVPTXGenericMCSymbolRefExpr\n  *create(const MCSymbolRefExpr *SymExpr, MCContext &Ctx);\n\n  /// @}\n  /// @name Accessors\n  /// @{\n\n  /// getOpcode - Get the kind of this expression.\n  const MCSymbolRefExpr *getSymbolExpr() const { return SymExpr; }\n\n  /// @}\n\n  void printImpl(raw_ostream &OS, const MCAsmInfo *MAI) const override;\n  bool evaluateAsRelocatableImpl(MCValue &Res,\n                                 const MCAsmLayout *Layout,\n                                 const MCFixup *Fixup) const override {\n    return false;\n  }\n  void visitUsedExpr(MCStreamer &Streamer) const override {};\n  MCFragment *findAssociatedFragment() const override { return nullptr; }\n\n  // There are no TLS NVPTXMCExprs at the moment.\n  void fixELFSymbolsInTLSFixups(MCAssembler &Asm) const override {}\n\n  static bool classof(const MCExpr *E) {\n    return E->getKind() == MCExpr::Target;\n  }\n  };\n} // end namespace llvm\n\n#endif\n\n", "comment_ratio": 0.248}
{"lang": "c", "code": "#ifndef NUFR_KERNEL_BASE_MESSAGING_H\n#define NUFR_KERNEL_BASE_MESSAGING_H\n\n#include \"nufr-global.h\"\n\n//              'fields' bit assignments\n//              ------------------------\n//      31-22     21-12       11-4           3-2         1-0\n//     PREFIX      ID       SENDING TASK  [unused]     PRIORITY\n\n\n//!\n//! @struct   nufr_msg_t\n//!\ntypedef struct nufr_msg_t_\n{\n    struct nufr_msg_t_ *flink;\n    uint32_t            fields;\n    uint32_t            parameter;\n} nufr_msg_t;\n\n// See 'nufr-api.h' for helper macros for nufr_msg_t->fields value\n\n#endif  //NUFR_KERNEL_BASE_MESSAGING_H\n", "comment_ratio": 0.3050847457627119}
{"lang": "c", "code": "#import <RongIMLib/RongIMLib.h>\nextern NSString *const RCDGroupCreate;\nextern NSString *const RCDGroupMemberAdd;\nextern NSString *const RCDGroupMemberQuit;\nextern NSString *const RCDGroupMemberKicked;\nextern NSString *const RCDGroupRename;\nextern NSString *const RCDGroupBulletin;\nextern NSString *const RCDGroupOwnerTransfer;\nextern NSString *const RCDGroupDismiss;\nextern NSString *const RCDGroupMemberJoin;\nextern NSString *const RCDGroupMemberManagerSet;\nextern NSString *const RCDGroupMemberManagerRemove;\nextern NSString *const RCDGroupMemberProtectionOpen;\nextern NSString *const RCDGroupMemberProtectionClose;\n#define RCDGroupNotificationMessageIdentifier @\"ST:GrpNtf\"\n\n/*!\n \u7fa4\u7ec4\u901a\u77e5\u6d88\u606f\n */\n@interface RCDGroupNotificationMessage : RCMessageContent\n\n@property (nonatomic, copy) NSString *operation;\n\n@property (nonatomic, copy) NSString *operatorUserId;\n\n@property (nonatomic, strong) NSArray<NSString *> *targetUserIds;\n\n@property (nonatomic, copy) NSString *message;\n\n- (NSString *)getDigest:(NSString *)groupId;\n@end\n\n", "comment_ratio": 0.175}
{"lang": "c", "code": "#import \"ACRBaseCardElementRenderer.h\"\n\n@interface ACRInputRenderer : ACRBaseCardElementRenderer\n\n+ (ACRInputRenderer *)getInstance;\n\n@end\n\n", "comment_ratio": 0.4}
{"lang": "c", "code": "// vim: set tabstop=2 softtabstop=2 shiftwidth=2 autoindent shiftround expandtab:\n#include \"yapi.h\"\n#include <math.h>\n\n#ifndef DEG2RAD\n#define DEG2RAD 0.017453292519943295\n#endif\n#ifndef RAD2DEG\n#define RAD2DEG 57.295779513082\n#endif\n\nvoid ll2utm(\n  double *lat, double *lon,\n  double *north, double *east, short *zone,\n  long count,\n  double a, double e2)\n{\n  // This code is structured to mirror the code in the Yorick function, so that\n  // the two can be kept in sync in case of code changes / bug fixes.\n\n  long i;\n  double cmeridian;\n  double N, T, C, A, M;\n\n  // Scale factor along central meridian\n  double k0 = 0.9996;\n\n  // eccentricity prime squared\n  double ep2 = e2/(1-e2);\n\n  // higher powers of eccentricity squared\n  double e4 = e2*e2;\n  double e6 = e4*e2;\n\n  // constants used in M equation further below\n  double M0 = 1 - e2/4 - 3*e4/64 - 5*e6/256;\n  double M2 = 3*e2/8 + 3*e4/32 + 45*e6/1024;\n  double M4 = 15*e4/256 + 45*e6/1024;\n  double M6 = 35*e6/3072;\n\n  for(i = 0; i < count; i++) {\n    // Make sure the longitude is between -180. and 179.99999\n    lon[i] -= floor(.5+lon[i]/360.)*360.;\n\n    // Calculate zone if needed\n    if(!zone[i])\n      zone[i] = floor(lon[i]/6. + 31);\n\n    // Convert to radians\n    lon[i] *= DEG2RAD;\n    lat[i] *= DEG2RAD;\n\n    // Central meridian\n    cmeridian = (zone[i] * 6 - 183) * DEG2RAD;\n\n    // PP1395 eq 4-20 p25, p61\n    // N is radius of curvature of the ellipsoid in a plane perpendicular to the\n    // meridian and also perpendiuclar to a plane tangent to the surface\n    N = a/sqrt(1 - e2 * pow(sin(lat[i]), 2));\n\n    // PP1395 eq 8-13 p61\n    T = pow(tan(lat[i]), 2);\n\n    // PP1395 eq 8-14 p61\n    C = ep2 * pow(cos(lat[i]), 2);\n\n    // PP1395 eq 8-15 p61\n    A = cos(lat[i]) * (lon[i] - cmeridian);\n\n    // PP1395 eq 3-21 p17, p61\n    // M is the true distance along the central meridian from the equator to\n    // this latitude\n    M = (\n      M0 * lat[i] - M2 * sin(2*lat[i]) +\n      M4 * sin(4*lat[i]) - M6 * sin(6*lat[i])\n    ) * a;\n\n    // PP1395 eq 8-9 p61\n    east[i] = (\n      (5-18*T+T*T+72*C-58*ep2) * pow(A,5)/120 + A + (1-T+C) * pow(A,3)/6\n    ) * k0 * N + 500000.;\n\n    // PP1395 eq 8-10 p61\n    north[i] = (\n      ( (-(58+T)*T + 600*C - 330*ep2 + 61\n        ) * pow(A,6) / 720 + (5-T+9*C+4*C*C) * pow(A,4)/24 + A*A/2\n      ) * N * tan(lat[i]) + M\n    ) * k0;\n  }\n}\n\nvoid utm2ll(\n  double *north, double *east, short *zone,\n  double *lon, double *lat,\n  long count,\n  double a, double e2)\n{\n  long i;\n  double x, y, M, N1, T1, C1, R1, D, lon0, lat1, mu;\n\n  // Scale factor along central meridian\n  double k0 = 0.9996;\n\n  // PP1395 eq 8-12 p61, p64\n  // eccentricity prime squared\n  double ep2 = e2/(1-e2);\n\n  // PP1395 eq 3-24 ??, p63\n  double e1 = (1-sqrt(1-e2))/(1+sqrt(1-e2));\n\n  for(i = 0; i < count; i++) {\n    x = east[i] - 500000.;\n    y = north[i];\n\n    // PP1395 eq 8-20 p63\n    // M = M0 + y/k0\n    // Apparently M0 is 0 here...\n    M = y / k0;\n\n    lon0 = DEG2RAD * ((zone[i] - 1)*6 - 180 + 3);\n\n    // PP1395 eq 7-10 p??, p63\n    mu = M/(a*(1-e2/4-3*e2*e2/64 - 5*e2*e2*e2/256));\n\n    // PP1395 eq 3-26 p??, p63\n    // \"footprint latitude\" or latitude at central meridian which has same y\n    // coordinate as that of the point (lat,lon).\n    lat1 = mu + (3*e1/2-27*e1*e1*e1/32)*sin(2*mu) +\n      (21*e1*e1/16-55*e1*e1*e1*e1/32)*sin(4*mu) +\n      (151*e1*e1*e1/96)*sin(6*mu);\n\n    // PP1395 eq 8-23 p64\n    N1 = a/sqrt(1-e2*pow(sin(lat1), 2));\n    // PP1395 eq 8-22 p64\n    T1 = pow(tan(lat1), 2);\n    // PP1395 eq 8-21 p64\n    C1 = ep2*pow(cos(lat1), 2);\n    // PP1395 eq 8-24 p64\n    R1 = a*(1-e2)/pow(1-e2*pow(sin(lat1), 2), 1.5);\n    // PP1395 eq 8-25 p64\n    D = x/(N1*k0);\n\n    // PP1395 eq 8-17 p63\n    lat[i] = lat1 -\n      (N1*tan(lat1)/R1)*(D*D/2-\n      (5+3*T1+10*C1-4*C1*C1-9*ep2)*D*D*D*D/24 +\n      (61+90*T1+298*C1+45*T1*T1-252*ep2-\n      3*C1*C1)*D*D*D*D*D*D/720);\n\n    // PP1395 eq 8-18 p63\n    lon[i] = lon0 + (D-(1+2*T1+C1)*D*D*D/6+(5-2*C1+28*T1-\n      3*C1*C1+8*ep2+24*T1*T1)\n      *D*D*D*D*D/120)/cos(lat1);\n\n    lat[i] *= RAD2DEG;\n    lon[i] *= RAD2DEG;\n  }\n}\n\n", "comment_ratio": 0.25157232704402516}
{"lang": "c", "code": "#include <string.h>\n#include \"LPC18xx.h\"\n\n#define   USB_ENDPT_MSK  (0x0F)\n#include \"USB_LPC18xx.h\"\n#include \"SCU_LPC18xx.h\"\n\n#include \"Driver_USBD.h\"\n\n#include \"RTE_Device.h\"\n#include \"RTE_Components.h\"\n\n#if (RTE_USB_USB1 == 0)\n#error \"USB1 is not enabled in the RTE_Device.h!\"\n#endif\n\n/* USBD Driver ****************************************************************/\n\n#define ARM_USBD_DRV_VERSION ARM_DRIVER_VERSION_MAJOR_MINOR(2,2) /* USBD driver version */\n\n/* Driver Version */\nstatic const ARM_DRIVER_VERSION usbd_driver_version = { ARM_USBD_API_VERSION, ARM_USBD_DRV_VERSION };\n\n\n// Driver Capabilities\nstatic const ARM_USBD_CAPABILITIES usbd_driver_capabilities = {\n  0,  // vbus_detection\n  0,  // event_vbus_on\n  0,  // event_vbus_off\n};\n\n// Definitions\n#define USBD1_EP_MASK  ((RTE_USB_USB1_DEV_EP << 1) | 1)\n\n// Number of Endpoints\n#if    (USBD1_EP_MASK & 0x08)\n#define USBD_EP_NUM      3\n#elif  (USBD1_EP_MASK & 0x04)\n#define USBD_EP_NUM      2\n#elif  (USBD1_EP_MASK & 0x02)\n#define USBD_EP_NUM      1\n#else\n#define USBD_EP_NUM      0\n#endif\n\n\nstatic EPQH __align(2048) EPQHx[(USBD_EP_NUM + 1) * 2];\nstatic dTD  __align(32  ) dTDx[ (USBD_EP_NUM + 1) * 2];\n\n#define LPC_USBx            LPC_USB1\n#define ENDPTCTRL(EPNum)  *(volatile uint32_t *)((uint32_t)(&LPC_USBx->ENDPTCTRL0) + 4 * EPNum)\n#define EP_NUM(ep_addr)    (ep_addr & ARM_USB_ENDPOINT_NUMBER_MASK)\n#define EP_VAL(ep_addr)    (ep_addr & ARM_USB_ENDPOINT_DIRECTION_MASK) ? 16 : 0;\n#define EP_IDX(ep_addr)    (ep_addr & ARM_USB_ENDPOINT_DIRECTION_MASK) ? (EP_NUM(ep_addr) *2 + 1) : (EP_NUM(ep_addr) * 2)\n\n// Static Variables\nstatic ARM_USBD_SignalDeviceEvent_t   cbDeviceEvent;\nstatic ARM_USBD_SignalEndpointEvent_t cbEndpointEvent;\n\n         static uint8_t  setup_buf[8];\nvolatile static uint8_t  setup_flag = 0;\n\nstatic uint32_t usbd_flags = 0;\nstatic ARM_USBD_STATE usbd_state = {0, 0, 0};\n\n// External Variables\nextern volatile uint32_t USB1_role;\n\n// External Functions\nextern void USB1_PinsConfigure   (void);\nextern void USB1_PinsUnconfigure (void);\n\n// Local Functions\n\n/**\n  \\fn          void USBD_Reset (void)\n  \\brief       Called after usbd reset interrupt to reset configuration\n*/\nstatic void USBD_Reset (void) {\n  uint32_t i;\n\n  for (i = 1; i < USBD_EP_NUM + 1; i++) {\n    ENDPTCTRL(i) &= ~(USB_ENDPTCTRL_RXE | USB_ENDPTCTRL_TXE);\n  }\n\n  // Clear interrupts\n  LPC_USBx->ENDPTNAK       = 0xFFFFFFFF;\n  LPC_USBx->ENDPTNAKEN     = 0;\n  LPC_USBx->USBSTS_D       = 0xFFFFFFFF;\n  LPC_USBx->ENDPTSETUPSTAT = LPC_USBx->ENDPTSETUPSTAT;\n  LPC_USBx->ENDPTCOMPLETE  = LPC_USBx->ENDPTCOMPLETE;\n\n  while (LPC_USBx->ENDPTPRIME);\n\n  // Clear all Primed buffers\n  LPC_USBx->ENDPTFLUSH = 0xFFFFFFFF;\n  while (LPC_USBx->ENDPTFLUSH);\n\n  // Interrupt threshold control: no threshold\n  LPC_USBx->USBCMD_D &= ~(USB_USBCMD_D_ITC(0xFF));\n\n  // Clear endpoint queue heads and endpoint transfer descriptors\n  memset(EPQHx, 0, sizeof(EPQH)*((USBD_EP_NUM + 1) * 2));\n  memset(dTDx,  0, sizeof(dTD) *((USBD_EP_NUM + 1) * 2));\n\n  // Set start of endpoint list address\n  LPC_USBx->ENDPOINTLISTADDR = (uint32_t)EPQHx;\n\n  // Setup lockouts off\n  LPC_USBx->USBMODE_D |= USB_USBMODE_SLOM;\n}\n\n/**\n  \\fn          bool USBD_EndpointFlush (uint8_t ep_addr)\n  \\brief       Flush Endpoint\n*/\nstatic bool USBD_EndpointFlush (uint8_t ep_addr) {\n  uint32_t val, num;\n\n  num =  EP_NUM(ep_addr);\n  val =  EP_VAL(ep_addr);\n\n  // Flush endpoint\n  LPC_USBx->ENDPTFLUSH =        (1 << (num + val));\n  while (LPC_USBx->ENDPTFLUSH & (1 << (num + val)));\n\n  return true;\n}\n\n/**\n  \\fn          bool USBD_ReadSetup (void)\n  \\brief       Read Setup packet to buffer\n*/\nstatic bool USBD_ReadSetup (void) {\n\n  do {\n    // Setup trip wire\n    LPC_USBx->USBCMD_D |= USB_USBCMD_D_SUTW;\n\n    // Copy Setup packet to buffer\n    *((__packed uint32_t*) setup_buf)      = EPQHx[0].setup[0];\n    *((__packed uint32_t*)(setup_buf + 4)) = EPQHx[0].setup[1];\n  } while ((LPC_USBx->USBCMD_D & LPC_USBx->USBCMD_D) == 0);\n\n  // Clear Setup trip wire\n  LPC_USBx->USBCMD_D &= ~USB_USBCMD_D_SUTW;\n\n  // Clear Setup bit\n  LPC_USBx->ENDPTSETUPSTAT = 1;\n\n  return true;\n}\n\n/**\n\\fn          void USBD_EndpointPrime (uint8_t ep_addr, uint8_t *buf, uint32_t len)\n\\brief       Prime USB Endpoint\n\\param[in]   ep_addr specifies Endpoint Address\n              ep_addr.0..3: Address\n              ep_addr.7:    Direction\n\\param[out]  buf specifies buffer\n\\param[in]   len specifies buffer length\n*/\nstatic void USBD_EndpointPrime (uint8_t ep_addr, uint8_t *buf, uint32_t len) {\n  uint32_t val, num;\n\n  num =  EP_NUM(ep_addr);\n  val =  EP_VAL(ep_addr);\n\n  // Set buffer addresses\n  dTDx[EP_IDX(ep_addr)].buf[0]  =  (uint32_t)(buf         );\n  dTDx[EP_IDX(ep_addr)].buf[1]  =  (uint32_t)(buf + 0x1000);\n  dTDx[EP_IDX(ep_addr)].buf[2]  =  (uint32_t)(buf + 0x2000);\n  dTDx[EP_IDX(ep_addr)].buf[3]  =  (uint32_t)(buf + 0x3000);\n  dTDx[EP_IDX(ep_addr)].buf[4]  =  (uint32_t)(buf + 0x4000);\n\n  // Driver does not support linked endpoint descriptors\n  // Next link pointer is not valid\n  dTDx[EP_IDX(ep_addr)].next_dTD  = 1;\n\n  // Set number of transactions for isochronous endpoint\n  if (EPQHx[EP_IDX(ep_addr)].ep.type == ARM_USB_ENDPOINT_ISOCHRONOUS) {\n    if (EPQHx[EP_IDX(ep_addr)].ep.maxPacketSize <= len) {\n     // MultO = 1\n      dTDx[EP_IDX(ep_addr)].dTD_token = USB_bTD_TOKEN_MULTO(1);\n    }\n    else if ((EPQHx[EP_IDX(ep_addr)].ep.maxPacketSize * 2) <= len) {\n      // MultO = 2\n      dTDx[EP_IDX(ep_addr)].dTD_token = USB_bTD_TOKEN_MULTO(2);\n    }\n    else {\n      // MultO = 3\n      dTDx[EP_IDX(ep_addr)].dTD_token = USB_bTD_TOKEN_MULTO(3);\n    }\n  }\n  else {\n    dTDx[EP_IDX(ep_addr)].dTD_token = 0;\n  }\n\n  // Maximum transfer length is 16k\n  if (len > 0x4000) len = 0x4000;\n\n  // IN Endpoints\n  if (ep_addr & ARM_USB_ENDPOINT_DIRECTION_MASK) {\n    EPQHx[EP_IDX(ep_addr)].ep.bufferIndex += len;\n  }\n\n  // Configure endpoint transfer descriptor\n  dTDx[EP_IDX(ep_addr)].dTD_token  |= USB_bTD_TOKEN_TOTAL_BYTES(len) |  // Bytes to transfer\n                                      USB_bTD_TOKEN_IOC              |  // Interrupt on complete\n                                      USB_bTD_TOKEN_STATUS_ACTIVE;\n\n  // Save transfer descriptor address to endpoint queue head\n  EPQHx[EP_IDX(ep_addr)].next_dTD   = (uint32_t)(&dTDx[EP_IDX(ep_addr)]);\n\n  // Clear endpoint queue head status\n  EPQHx[EP_IDX(ep_addr)].dTD_token &= ~(USB_bTD_TOKEN_STATUS_ACTIVE       |\n                                        USB_bTD_TOKEN_STATUS_HALTED       |\n                                        USB_bTD_TOKEN_STATUS_BUFFER_ERROR |\n                                        USB_bTD_TOKEN_STATUS_TRAN_ERROR);\n\n  // Prime endpoint\n  LPC_USBx->ENDPTPRIME = (1 << (val + num));\n}\n\n\n// USB Device Driver Functions\n\n/**\n  \\fn          ARM_DRIVER_VERSION USBD_GetVersion (void)\n  \\brief       Get driver version.\n  \\return      \\ref ARM_DRIVER_VERSION\n*/\nstatic ARM_DRIVER_VERSION USBD_GetVersion (void) { return usbd_driver_version; }\n\n/**\n  \\fn          ARM_USBD_CAPABILITIES USBD_GetCapabilities (void)\n  \\brief       Get driver capabilities.\n  \\return      \\ref ARM_USBD_CAPABILITIES\n*/\nstatic ARM_USBD_CAPABILITIES USBD_GetCapabilities (void) { return usbd_driver_capabilities; }\n\n/**\n  \\fn          int32_t USBD_Initialize (ARM_USBD_SignalDeviceEvent_t   cb_device_event,\n                                        ARM_USBD_SignalEndpointEvent_t cb_endpoint_event)\n  \\brief       Initialize USB Device Interface.\n  \\param[in]   cb_device_event    Pointer to \\ref ARM_USBD_SignalDeviceEvent\n  \\param[in]   cb_endpoint_event  Pointer to \\ref ARM_USBD_SignalEndpointEvent\n  \\return      \\ref execution_status\n*/\nstatic int32_t USBD_Initialize (ARM_USBD_SignalDeviceEvent_t   cb_device_event,\n                                ARM_USBD_SignalEndpointEvent_t cb_endpoint_event) {\n\n  if (usbd_flags & USB_POWERED) {\n    // Device is powered - could not be re-initialized\n    return ARM_DRIVER_ERROR;\n  }\n\n  if (usbd_flags & USB_INITIALIZED){\n    // Driver is already initialized\n    return ARM_DRIVER_OK;\n  }\n\n  // Initialize USBD Run-time Resources\n  cbDeviceEvent   = cb_device_event;\n  cbEndpointEvent = cb_endpoint_event;\n\n  USB1_role = ARM_USB_ROLE_DEVICE;\n\n  // Set pin functions\n  USB1_PinsConfigure ();\n\n  usbd_flags = USB_INITIALIZED;\n\n  return ARM_DRIVER_OK;\n}\n\n/**\n  \\fn          int32_t USBD_Uninitialize (void)\n  \\brief       De-initialize USB Device Interface.\n  \\return      \\ref execution_status\n*/\nstatic int32_t USBD_Uninitialize (void) {\n\n  if (usbd_flags & USB_POWERED) {\n    // Device is powered - could not be uninitialized\n    return ARM_DRIVER_ERROR;\n  }\n\n  if ((usbd_flags & USB_INITIALIZED) == 0){\n    // Driver not initialized\n    return ARM_DRIVER_OK;\n  }\n\n  usbd_flags = 0;\n\n  USB1_role = ARM_USB_ROLE_NONE;\n\n  // Reset pin functions\n  USB1_PinsUnconfigure ();\n\n  return ARM_DRIVER_OK;\n}\n\n/**\n  \\fn          int32_t USBD_PowerControl (ARM_POWER_STATE state)\n  \\brief       Control USB Device Interface Power.\n  \\param[in]   state  Power state\n  \\return      \\ref execution_status\n*/\nstatic int32_t USBD_PowerControl (ARM_POWER_STATE state) {\n\n  if ((usbd_flags & USB_INITIALIZED) == 0){\n    // Driver is not initialized\n    return ARM_DRIVER_ERROR;\n  }\n\n  switch (state) {\n    case ARM_POWER_OFF:\n      if ((usbd_flags & USB_POWERED) == 0)\n        return ARM_DRIVER_OK;\n\n      // Disable interrupts\n      NVIC_DisableIRQ(USB1_IRQn);\n\n      // Disable USB1 base clock\n      LPC_CCU1->CLK_USB1_CFG &= ~1;\n      while (LPC_CCU1->CLK_USB1_STAT & 1);\n\n      // Disable USB1 register interface clock\n      LPC_CCU1->CLK_M3_USB1_CFG &= ~1;\n      while (LPC_CCU1->CLK_M3_USB1_STAT & 1);\n\n      usbd_flags = USB_INITIALIZED;\n      break;\n\n    case ARM_POWER_LOW:\n      return ARM_DRIVER_ERROR_UNSUPPORTED;\n\n    case ARM_POWER_FULL:\n      if (usbd_flags & USB_POWERED)\n        return ARM_DRIVER_OK;\n\n      // BASE_USB1_CLK\n      LPC_CGU->BASE_USB1_CLK   = (0x01 << 11) |   // Auto-block Enable\n                                 (0x0C << 24) ;   // Clock source: IDIVA\n      // Enable USB1 register interface clock\n      LPC_CCU1->CLK_M3_USB1_CFG |= 1;\n      while ((LPC_CCU1->CLK_M3_USB1_STAT & 1) == 0);\n\n      // Enable USB1 base clock\n      LPC_CCU1->CLK_USB1_CFG |= 1;\n      while ((LPC_CCU1->CLK_USB1_STAT & 1) == 0);\n\n      // USB reset\n      LPC_USBx->USBCMD_D = USB_USBCMD_D_RST;\n      while (LPC_USBx->USBCMD_D & (USB_USBCMD_D_RS | USB_USBCMD_D_RST));\n\n      // Force device mode and set Setup lockouts off\n      LPC_USBx->USBMODE_D  = USB_USBMODE_CM1_0(2) |\n                             USB_USBMODE_SLOM;\n\n      // Clear transceiver selection\n      LPC_USBx->PORTSC1_D &= ~(USB_PORTSC1_D_PTS_MSK | USB_PORTSC1_D_PFSC);\n#if (RTE_USB_USB1_HS_PHY_EN)\n      // ULPI Selected\n      LPC_USBx->PORTSC1_D |= USB_PORTSC1_D_PTS(2);\n#else\n      // Serial/1.1 PHY selected and Full speed forced\n      LPC_USBx->PORTSC1_D |= USB_PORTSC1_D_PTS(3UL) |\n                             USB_PORTSC1_D_PFSC;\n#endif\n\n      // Enable interrupts\n      LPC_USBx->USBINTR_D  = USB_USBINTR_D_UE  |  // USB interrupt enable\n                             USB_USBINTR_D_PCE |  // Port change detect interrupt enable\n                             USB_USBINTR_D_SLE |  // Suspend interrupt enable\n                             USB_USBINTR_D_URE ;  // Reset interrupt enable\n\n      SCU_USB1_PinConfigure (SCU_USB1_PIN_CFG_ESEA |\n                             SCU_USB1_PIN_CFG_EPWR);\n\n      usbd_flags = USB_INITIALIZED | USB_POWERED;\n\n      NVIC_ClearPendingIRQ(USB1_IRQn);\n      NVIC_EnableIRQ(USB1_IRQn);\n      break;\n\n    default:\n      return ARM_DRIVER_ERROR_UNSUPPORTED;\n  }\n  return ARM_DRIVER_OK;\n}\n\n/**\n  \\fn          int32_t USBD_DeviceConnect (void)\n  \\brief       Connect USB Device.\n  \\return      \\ref execution_status\n*/\nstatic int32_t USBD_DeviceConnect (void) {\n\n  if ((usbd_flags & USB_POWERED) == 0) {\n    // Device not powered\n    return ARM_DRIVER_ERROR;\n  }\n\n  if (usbd_flags & USB_CONNECTED) {\n    // Device is already connected\n    return ARM_DRIVER_OK;\n  }\n\n  // Attach the device\n  LPC_USBx->USBCMD_D |= USB_USBCMD_D_RS;\n\n  usbd_flags |= USB_CONNECTED;\n\n  return ARM_DRIVER_OK;\n}\n\n/**\n  \\fn          int32_t USBD_DeviceDisconnect (void)\n  \\brief       Disconnect USB Device.\n  \\return      \\ref execution_status\n*/\nstatic int32_t USBD_DeviceDisconnect (void) {\n\n  if ((usbd_flags & USB_POWERED) == 0) {\n    // Device not powered\n    return ARM_DRIVER_ERROR;\n  }\n\n  if ((usbd_flags & USB_CONNECTED) == 0) {\n    // Device is already disconnected\n    return ARM_DRIVER_OK;\n  }\n\n  // Detach the device\n  LPC_USBx->USBCMD_D &= ~USB_USBCMD_D_RS;\n\n  usbd_state.active   =  false;\n  usbd_flags         &= ~USB_CONNECTED;\n\n#if (RTE_USB1_IND0_PIN_EN)\n    // Clear indicator LED0\n    LPC_USBx->PORTSC1_D &= ~USB_PORTSC1_D_PIC1_0(1);\n#endif\n\n  return ARM_DRIVER_OK;\n}\n\n/**\n  \\fn          ARM_USBD_STATE USBD_DeviceGetState (void)\n  \\brief       Get current USB Device State.\n  \\return      Device State \\ref ARM_USBD_STATE\n*/\nstatic ARM_USBD_STATE USBD_DeviceGetState (void) {\n  return usbd_state;\n}\n\n/**\n  \\fn          int32_t USBD_DeviceRemoteWakeup (void)\n  \\brief       Trigger USB Remote Wakeup.\n  \\return      \\ref execution_status\n*/\nstatic int32_t USBD_DeviceRemoteWakeup (void) {\n\n  if ((usbd_flags & USB_CONNECTED) == 0) {\n    // Device is not connected\n    return ARM_DRIVER_ERROR;\n  }\n\n  // Enable PHY clock\n  LPC_USBx->PORTSC1_D &= ~USB_PORTSC1_D_PHCD;\n\n  // Force port resume\n  LPC_USBx->PORTSC1_D |=  USB_PORTSC1_D_FPR;\n\n  return ARM_DRIVER_OK;\n}\n\n/**\n  \\fn          int32_t USBD_DeviceSetAddress (uint8_t dev_addr)\n  \\brief       Set USB Device Address.\n  \\param[in]   dev_addr  Device Address\n  \\return      \\ref execution_status\n*/\nstatic int32_t USBD_DeviceSetAddress (uint8_t dev_addr) {\n\n  if ((usbd_flags & USB_CONNECTED) == 0) {\n    // Device is not connected\n    return ARM_DRIVER_ERROR;\n  }\n\n  LPC_USBx->DEVICEADDR  = (dev_addr << USB_DEVICEADDR_USBADR_POS) &\n                           USB_DEVICEADDR_USBADR_MSK;\n  LPC_USBx->DEVICEADDR |= USB_DEVICEADDR_USBADRA;\n\n  return ARM_DRIVER_OK;\n}\n\n/**\n  \\fn          int32_t USBD_ReadSetupPacket (uint8_t *setup)\n  \\brief       Read setup packet received over Control Endpoint.\n  \\param[out]  setup  Pointer to buffer for setup packet\n  \\return      \\ref execution_status\n*/\nstatic int32_t USBD_ReadSetupPacket (uint8_t *setup) {\n\n  if ((usbd_flags & USB_CONNECTED) == 0) {\n    // Device is not connected\n    return ARM_DRIVER_ERROR;\n  }\n\n  if (setup_flag == 0) {\n    // No setup packet waiting\n    return ARM_DRIVER_ERROR;\n  }\n\n  setup_flag = 0;\n  memcpy(setup, setup_buf, 8);\n\n  if (setup_flag) {\n    // Interrupted with new setup packet\n    return ARM_DRIVER_ERROR;\n  }\n\n  return ARM_DRIVER_OK;\n}\n\n/**\n  \\fn          int32_t USBD_EndpointConfigure (uint8_t  ep_addr,\n                                               uint8_t  ep_type,\n                                               uint16_t ep_max_packet_size)\n  \\brief       Configure USB Endpoint.\n  \\param[in]   ep_addr  Endpoint Address\n                - ep_addr.0..3: Address\n                - ep_addr.7:    Direction\n  \\param[in]   ep_type  Endpoint Type (ARM_USB_ENDPOINT_xxx)\n  \\param[in]   ep_max_packet_size Endpoint Maximum Packet Size\n  \\return      \\ref execution_status\n*/\nstatic int32_t USBD_EndpointConfigure (uint8_t ep_addr,\n                                       uint8_t  ep_type,\n                                       uint16_t ep_max_packet_size) {\n  uint32_t val, num;\n  uint16_t sz;\n\n  if ((usbd_flags & USB_CONNECTED) == 0) {\n    // Device is not connected\n    return ARM_DRIVER_ERROR;\n  }\n\n  if (EPQHx[EP_IDX(ep_addr)].ep.flags & USBD_EP_FLAG_BUSY) {\n    // Endpoint is busy\n    return ARM_DRIVER_ERROR_BUSY;\n  }\n\n  if (EPQHx[EP_IDX(ep_addr)].ep.flags & USBD_EP_FLAG_CONFIGURED) {\n    // Endpoint is already configured\n    return ARM_DRIVER_OK;\n  }\n\n  num =  EP_NUM(ep_addr);\n  val =  EP_VAL(ep_addr);\n  sz =   ep_max_packet_size & ARM_USB_ENDPOINT_MAX_PACKET_SIZE_MASK;\n\n  // Check if endpoint number is valid\n  if ((USBD1_EP_MASK & (1 << num)) == 0) return ARM_DRIVER_ERROR;\n\n  // Set Endpoint queue head\n  EPQHx[EP_IDX(ep_addr)].ep.buffer         =  NULL;\n  EPQHx[EP_IDX(ep_addr)].ep.dataSize       =  0;\n  EPQHx[EP_IDX(ep_addr)].ep.maxPacketSize  =  sz;\n  EPQHx[EP_IDX(ep_addr)].ep.type           =  ep_type;\n  EPQHx[EP_IDX(ep_addr)].cap               =  USB_EPQH_CAP_MAX_PACKET_LEN(sz) |\n                                              USB_EPQH_CAP_ZLT;\n  if (ep_addr == 0)\n    EPQHx[EP_IDX(ep_addr)].cap            |=  USB_EPQH_CAP_IOS;\n\n  EPQHx[EP_IDX(ep_addr)].next_dTD          =  1;\n\n  EPQHx[EP_IDX(ep_addr)].dTD_token         =  0;\n\n  if (USBD_EndpointFlush(ep_addr) == false) return ARM_DRIVER_ERROR;\n\n  // Reset endpoint control settings\n  ENDPTCTRL(num) &= ~((USB_ENDPTCTRL_RXS     |\n                       USB_ENDPTCTRL_RXT_MSK |\n                       USB_ENDPTCTRL_RXI     |\n                       USB_ENDPTCTRL_RXR     |\n                       USB_ENDPTCTRL_RXE) << val);\n\n  // Set endpoint control\n  ENDPTCTRL(num) |=  ((USB_ENDPTCTRL_RXT(ep_type) |     // Endpoint type\n                       USB_ENDPTCTRL_RXR          |     // Data toggle reset\n                       USB_ENDPTCTRL_RXE) << val);      // Endpoint enable\n\n  // Set Endpoint configured flag\n  EPQHx[EP_IDX(ep_addr)].ep.flags |= USBD_EP_FLAG_CONFIGURED;\n\n  return ARM_DRIVER_OK;\n}\n\n/**\n  \\fn          int32_t USBD_EndpointUnconfigure (uint8_t ep_addr)\n  \\brief       Unconfigure USB Endpoint.\n  \\param[in]   ep_addr  Endpoint Address\n                - ep_addr.0..3: Address\n                - ep_addr.7:    Direction\n  \\return      \\ref execution_status\n*/\nstatic int32_t USBD_EndpointUnconfigure (uint8_t ep_addr) {\n  uint32_t val, num;\n\n  if ((usbd_flags & USB_CONNECTED) == 0) {\n    // Device is not connected\n    return ARM_DRIVER_ERROR;\n  }\n\n  if (EPQHx[EP_IDX(ep_addr)].ep.flags & USBD_EP_FLAG_BUSY) {\n    // Endpoint is busy\n    return ARM_DRIVER_ERROR_BUSY;\n  }\n\n  if ((EPQHx[EP_IDX(ep_addr)].ep.flags & USBD_EP_FLAG_CONFIGURED) == 0) {\n    // Endpoint is not configured\n    return ARM_DRIVER_OK;\n  }\n\n  num =  EP_NUM(ep_addr);\n  val =  EP_VAL(ep_addr);\n\n  // Reset endpoint control settings\n  ENDPTCTRL(num) &= ~((USB_ENDPTCTRL_RXS     |\n                       USB_ENDPTCTRL_RXT_MSK |\n                       USB_ENDPTCTRL_RXI     |\n                       USB_ENDPTCTRL_RXR     |\n                       USB_ENDPTCTRL_RXE) << val);\n\n  // Data toggle reset\n  ENDPTCTRL(num) |=  (USB_ENDPTCTRL_RXR << val);\n\n  // Clear endpoint queue head and endpoint transfer descriptor\n  memset(&(EPQHx[EP_IDX(ep_addr)]), 0, sizeof(EPQH));\n  memset(&(dTDx[EP_IDX(ep_addr)]),  0, sizeof(dTD));\n\n  return ARM_DRIVER_OK;\n}\n\n/**\n  \\fn          int32_t USBD_EndpointStall (uint8_t ep_addr, bool stall)\n  \\brief       Set/Clear Stall for USB Endpoint.\n  \\param[in]   ep_addr  Endpoint Address\n                - ep_addr.0..3: Address\n                - ep_addr.7:    Direction\n  \\param[in]   stall  Operation\n                - \\b false Clear\n                - \\b true Set\n  \\return      \\ref execution_status\n*/\nstatic int32_t USBD_EndpointStall (uint8_t ep_addr, bool stall) {\n  uint32_t val, num;\n\n  if ((usbd_flags & USB_CONNECTED) == 0) {\n    // Device is not connected\n    return ARM_DRIVER_ERROR;\n  }\n\n  if ((EPQHx[EP_IDX(ep_addr)].ep.flags & USBD_EP_FLAG_CONFIGURED) == 0) {\n    // Endpoint is not configured\n    return ARM_DRIVER_ERROR;\n  }\n\n  if (EPQHx[EP_IDX(ep_addr)].ep.flags & USBD_EP_FLAG_BUSY) {\n    // Endpoint is busy\n    return ARM_DRIVER_ERROR_BUSY;\n  }\n\n  num =  EP_NUM(ep_addr);\n  val =  EP_VAL(ep_addr);\n  \n  if (stall) {\n    // Set endpoint stall\n    ENDPTCTRL(num) |=  (USB_ENDPTCTRL_RXS << val);\n  } else {\n    // Clear endpoint stall\n    ENDPTCTRL(num) &= ~(USB_ENDPTCTRL_RXS << val);\n\n    EPQHx[EP_IDX(ep_addr)].dTD_token = 0;\n    if (USBD_EndpointFlush(ep_addr) == false) return ARM_DRIVER_ERROR;\n\n    // Data toggle reset\n    ENDPTCTRL(num) |=  (USB_ENDPTCTRL_RXR << val);\n  }\n  return ARM_DRIVER_OK;\n}\n\n/**\n  \\fn          int32_t USBD_EndpointTransfer (uint8_t ep_addr, uint8_t *data, uint32_t num)\n  \\brief       Read data from or Write data to USB Endpoint.\n  \\param[in]   ep_addr  Endpoint Address\n                - ep_addr.0..3: Address\n                - ep_addr.7:    Direction\n  \\param[out]  data Pointer to buffer for data to read or with data to write\n  \\param[in]   num  Number of data bytes to transfer\n  \\return      \\ref execution_status\n*/\nstatic int32_t USBD_EndpointTransfer (uint8_t ep_addr, uint8_t *data, uint32_t num) {\n\n  if ((usbd_flags & USB_CONNECTED) == 0) {\n    // Device is not connected\n    return ARM_DRIVER_ERROR;\n  }\n\n  if ((EPQHx[EP_IDX(ep_addr)].ep.flags & USBD_EP_FLAG_CONFIGURED) == 0) {\n    // Endpoint is not configured\n    return ARM_DRIVER_ERROR;\n  }\n\n  if (EPQHx[EP_IDX(ep_addr)].ep.flags & USBD_EP_FLAG_BUSY) {\n    // Endpoint is busy\n    return ARM_DRIVER_ERROR_BUSY;\n  }\n\n  // Set endpoint busy\n  EPQHx[EP_IDX(ep_addr)].ep.flags |= USBD_EP_FLAG_BUSY;\n\n  // Save buffer information\n  EPQHx[EP_IDX(ep_addr)].ep.bufferIndex = 0;\n  EPQHx[EP_IDX(ep_addr)].ep.dataSize    = num;\n  EPQHx[EP_IDX(ep_addr)].ep.buffer      = data;\n\n  // Prime endpoint\n  USBD_EndpointPrime (ep_addr, data, num);\n\n  return ARM_DRIVER_OK;\n}\n\n/**\n  \\fn          uint32_t USBD_EndpointTransferGetResult (uint8_t ep_addr)\n  \\brief       Get result of USB Endpoint transfer.\n  \\param[in]   ep_addr  Endpoint Address\n                - ep_addr.0..3: Address\n                - ep_addr.7:    Direction\n  \\return      number of successfully transfered data bytes\n*/\nstatic uint32_t USBD_EndpointTransferGetResult (uint8_t ep_addr) {\n\n  return (EPQHx[EP_IDX(ep_addr)].ep.bufferIndex);\n}\n\n/**\n  \\fn          int32_t USBD_EndpointTransferAbort (uint8_t ep_addr)\n  \\brief       Abort current USB Endpoint transfer.\n  \\param[in]   ep_addr  Endpoint Address\n                - ep_addr.0..3: Address\n                - ep_addr.7:    Direction\n  \\return      \\ref execution_status\n*/\nstatic int32_t USBD_EndpointTransferAbort (uint8_t ep_addr) {\n  uint32_t val, num;\n\n  if ((usbd_flags & USB_CONNECTED) == 0) {\n    // Device is not connected\n    return ARM_DRIVER_ERROR;\n  }\n\n  if ((EPQHx[EP_IDX(ep_addr)].ep.flags & USBD_EP_FLAG_CONFIGURED) == 0) {\n    // Endpoint is not configured\n    return ARM_DRIVER_ERROR;\n  }\n\n  num =  EP_NUM(ep_addr);\n  val =  EP_VAL(ep_addr);\n\n  if (USBD_EndpointFlush(ep_addr) == false) return ARM_DRIVER_ERROR;\n\n  // Clear completed flag\n  LPC_USBx->ENDPTCOMPLETE     = (1 << (num + val));\n\n  // Data toggle reset\n  ENDPTCTRL(num) |=  (USB_ENDPTCTRL_RXR << val);\n\n  EPQHx[EP_IDX(ep_addr)].dTD_token  &= ~0xFF;\n  EPQHx[EP_IDX(ep_addr)].ep.buffer   = NULL;\n  EPQHx[EP_IDX(ep_addr)].ep.dataSize = 0;\n\n  // Clear endpoint busy\n  EPQHx[EP_IDX(ep_addr)].ep.flags &= ~USBD_EP_FLAG_BUSY;\n\n  return ARM_DRIVER_OK;\n}\n\n/**\n  \\fn          uint16_t USBD_GetFrameNumber (void)\n  \\brief       Get current USB Frame Number.\n  \\return      Frame Number\n*/\nstatic uint16_t USBD_GetFrameNumber (void) {\n\n  return ((LPC_USBx->FRINDEX_D & USB_FRINDEX_D_FRINDEX13_3_MSK) >>\n           USB_FRINDEX_D_FRINDEX13_3_POS);\n}\n\n/**\n  \\fn          void USBD1_IRQ (void)\n  \\brief       USB Device Interrupt Routine (IRQ).\n*/\nvoid USBD1_IRQ (void) {\n  uint32_t sts, cmpl, num, len, ep_addr, dev_evt;\n\n  // Save USB and endpoint status\n  sts  = LPC_USBx->USBSTS_D & LPC_USBx->USBINTR_D;\n  cmpl = LPC_USBx->ENDPTCOMPLETE;\n\n  // Clear endpoint complete flag\n  LPC_USBx->ENDPTCOMPLETE = cmpl;\n\n  // Clear interrupt flag\n  LPC_USBx->USBSTS_D = sts;\n\n  // Reset device event variable\n  dev_evt = 0;\n\n  // Reset interrupt\n  if (sts & USB_USBDSTS_D_URI) {\n    USBD_Reset();\n    dev_evt |= ARM_USBD_EVENT_RESET;\n  }\n\n  // Suspend interrupt\n  if (sts & USB_USBDSTS_D_SLI) {\n    usbd_state.active = false;\n    dev_evt |= ARM_USBD_EVENT_SUSPEND;\n\n#if (RTE_USB1_IND0_PIN_EN)\n    // Clear indicator LED0\n    LPC_USBx->PORTSC1_D &= ~USB_PORTSC1_D_PIC1_0(1);\n#endif\n  }\n\n  // Sort change detect interrupt\n  if (sts & USB_USBDSTS_D_PCI) {\n    if (((LPC_USBx->PORTSC1_D & USB_PORTSC1_D_PSPD_MSK) >>\n          USB_PORTSC1_D_PSPD_POS) == 2) {\n      usbd_state.speed = ARM_USB_SPEED_HIGH;\n      dev_evt |= ARM_USBD_EVENT_HIGH_SPEED;\n    } else {\n      usbd_state.speed = ARM_USB_SPEED_FULL;\n    }\n    usbd_state.active = true;\n#if (RTE_USB1_IND0_PIN_EN)\n    // Set indicator LED0\n    LPC_USBx->PORTSC1_D |= USB_PORTSC1_D_PIC1_0(1);\n#endif\n    dev_evt |= ARM_USBD_EVENT_RESUME;\n  }\n\n  // Signal device event\n  if (dev_evt && cbDeviceEvent) cbDeviceEvent(dev_evt);\n\n  // USB interrupt - completed transfer\n  if (sts & USB_USBDSTS_D_UI) {\n    // Setup Packet\n    if (LPC_USBx->ENDPTSETUPSTAT) {\n      if (USBD_ReadSetup() == true) {\n        setup_flag = 1;\n        cbEndpointEvent(0, ARM_USBD_EVENT_SETUP);\n      }\n    }\n    // IN Packet\n    if (cmpl & USB_ENDPTCOMPLETE_ETCE_MSK) {\n      // For each physical IN endpoint\n      for (num = 0; num <= USBD_EP_NUM; num++) {\n        \n        //Check if endpoint complete is set\n        if ((cmpl  & USB_ENDPTCOMPLETE_ETCE_MSK) & \n            (1 << (num + USB_ENDPTCOMPLETE_ETCE_POS))) {\n\n          ep_addr = num | ARM_USB_ENDPOINT_DIRECTION_MASK;\n\n          // Check if all required IN data is sent\n          if (EPQHx[EP_IDX(ep_addr)].ep.dataSize == EPQHx[EP_IDX(ep_addr)].ep.bufferIndex) {\n\n            // Clear endpoint busy\n            EPQHx[EP_IDX(ep_addr)].ep.flags &= ~USBD_EP_FLAG_BUSY;\n\n            // Set IN endpoint event\n            cbEndpointEvent(ep_addr, ARM_USBD_EVENT_IN);\n\n          } else {\n            // Prepare next transfer\n            len = EPQHx[EP_IDX(ep_addr)].ep.dataSize - EPQHx[EP_IDX(ep_addr)].ep.bufferIndex;\n\n            USBD_EndpointPrime (ep_addr, (uint8_t *) (EPQHx[EP_IDX(ep_addr)].ep.buffer + EPQHx[EP_IDX(ep_addr)].ep.bufferIndex), len);\n          }\n        }\n      }\n    }\n\n    // OUT Packet\n    if (cmpl & USB_ENDPTCOMPLETE_ERCE_MSK) {\n      // For each physical OUT endpoint\n      for (num = 0; num <= USBD_EP_NUM; num++) {\n\n        // Check if endpoint complete is set\n        if ((cmpl & USB_ENDPTCOMPLETE_ERCE_MSK) & (1 << num)) {\n\n          // Update buffer index, regarding size of received data\n          len = EPQHx[EP_IDX(num)].ep.dataSize -\n                ((dTDx[EP_IDX(num)].dTD_token & USB_bTD_TOKEN_TOTAL_BYTES_MSK) >>\n                  USB_bTD_TOKEN_TOTAL_BYTES_POS);\n\n          EPQHx[EP_IDX(num)].ep.bufferIndex += len;\n          EPQHx[EP_IDX(num)].ep.dataSize    -= len;\n\n          // Check if all OUT data is received:\n          //  - Data terminated with ZLP or short packet\n          //  - All required data received\n          if ((len % EPQHx[EP_IDX(num)].ep.maxPacketSize) ||\n              (EPQHx[EP_IDX(num)].ep.dataSize == 0)) {\n\n            // Clear endpoint busy\n            EPQHx[EP_IDX(num)].ep.flags &= ~USBD_EP_FLAG_BUSY;\n\n            // Set OUT endpoint event\n            cbEndpointEvent(num, ARM_USBD_EVENT_OUT);\n\n          } else {\n            // Prepare next out transaction \n            USBD_EndpointPrime (num, (uint8_t *) (EPQHx[EP_IDX(num)].ep.buffer + EPQHx[EP_IDX(num)].ep.bufferIndex), EPQHx[EP_IDX(num)].ep.dataSize);\n          }\n        }\n      }\n    }\n  }\n}\n\nARM_DRIVER_USBD Driver_USBD1 = {\n  USBD_GetVersion,\n  USBD_GetCapabilities,\n  USBD_Initialize,\n  USBD_Uninitialize,\n  USBD_PowerControl,\n  USBD_DeviceConnect,\n  USBD_DeviceDisconnect,\n  USBD_DeviceGetState,\n  USBD_DeviceRemoteWakeup,\n  USBD_DeviceSetAddress,\n  USBD_ReadSetupPacket,\n  USBD_EndpointConfigure,\n  USBD_EndpointUnconfigure,\n  USBD_EndpointStall,\n  USBD_EndpointTransfer,\n  USBD_EndpointTransferGetResult,\n  USBD_EndpointTransferAbort,\n  USBD_GetFrameNumber\n};\n\n", "comment_ratio": 0.13861386138613863}
{"lang": "c", "code": "#include <string.h>\n\n#include \"tusb.h\"\n\n#include \"py/gc.h\"\n#include \"py/runtime.h\"\n#include \"shared-bindings/usb_hid/__init__.h\"\n#include \"shared-module/usb_hid/Device.h\"\n#include \"supervisor/memory.h\"\n#include \"supervisor/usb.h\"\n\nstatic const uint8_t usb_hid_descriptor_template[] = {\n    0x09,        //  0 bLength\n    0x04,        //  1 bDescriptorType (Interface)\n    0xFF,        //  2 bInterfaceNumber 3\n#define HID_DESCRIPTOR_INTERFACE_INDEX (2)\n    0x00,        //  3 bAlternateSetting\n    0x02,        //  4 bNumEndpoints 2\n    0x03,        //  5 bInterfaceClass: HID\n    0x00,        //  6 bInterfaceSubClass: NOBOOT\n    0x00,        //  7 bInterfaceProtocol: NONE\n    0xFF,        //  8 iInterface (String Index)  [SET AT RUNTIME]\n#define HID_DESCRIPTOR_INTERFACE_STRING_INDEX (8)\n\n    0x09,        //  9 bLength\n    0x21,        // 10 bDescriptorType (HID)\n    0x11, 0x01,  // 11,12 bcdHID 1.11\n    0x00,        // 13 bCountryCode\n    0x01,        // 14 bNumDescriptors\n    0x22,        // 15 bDescriptorType[0] (HID)\n    0xFF, 0xFF,  // 16,17 wDescriptorLength[0]   [SET AT RUNTIME: lo, hi]\n#define HID_DESCRIPTOR_LENGTH_INDEX (16)\n\n    0x07,        // 18 bLength\n    0x05,        // 19 bDescriptorType (Endpoint)\n    0xFF,        // 20 bEndpointAddress (IN/D2H) [SET AT RUNTIME: 0x80 | endpoint]\n#define HID_IN_ENDPOINT_INDEX (20)\n    0x03,        // 21 bmAttributes (Interrupt)\n    0x40, 0x00,  // 22,23  wMaxPacketSize 64\n    0x08,        // 24 bInterval 8 (unit depends on device speed)\n\n    0x07,        // 25 bLength\n    0x05,        // 26 bDescriptorType (Endpoint)\n    0xFF,        // 27 bEndpointAddress (OUT/H2D)  [SET AT RUNTIME]\n#define HID_OUT_ENDPOINT_INDEX (27)\n    0x03,        // 28 bmAttributes (Interrupt)\n    0x40, 0x00,  // 29,30 wMaxPacketSize 64\n    0x08,        // 31 bInterval 8 (unit depends on device speed)\n};\n\n#define MAX_HID_DEVICES 8\n\nstatic supervisor_allocation *hid_report_descriptor_allocation;\nstatic usb_hid_device_obj_t hid_devices[MAX_HID_DEVICES];\n// If 0, USB HID is disabled.\nstatic mp_int_t num_hid_devices;\n\n// This tuple is store in usb_hid.devices.\nstatic mp_obj_tuple_t *hid_devices_tuple;\n\nstatic mp_obj_tuple_t default_hid_devices_tuple = {\n    .base = {\n        .type = &mp_type_tuple,\n    },\n    .len = 3,\n    .items = {\n        MP_OBJ_FROM_PTR(&usb_hid_device_keyboard_obj),\n        MP_OBJ_FROM_PTR(&usb_hid_device_mouse_obj),\n        MP_OBJ_FROM_PTR(&usb_hid_device_consumer_control_obj),\n    },\n};\n\nbool usb_hid_enabled(void) {\n    return num_hid_devices > 0;\n}\n\nvoid usb_hid_set_defaults(void) {\n    common_hal_usb_hid_enable(\n        CIRCUITPY_USB_HID_ENABLED_DEFAULT ? &default_hid_devices_tuple : mp_const_empty_tuple);\n}\n\n// This is the interface descriptor, not the report descriptor.\nsize_t usb_hid_descriptor_length(void) {\n    return sizeof(usb_hid_descriptor_template);\n}\n\nstatic const char usb_hid_interface_name[] = USB_INTERFACE_NAME \" HID\";\n\n// This is the interface descriptor, not the report descriptor.\nsize_t usb_hid_add_descriptor(uint8_t *descriptor_buf, descriptor_counts_t *descriptor_counts, uint8_t *current_interface_string, uint16_t report_descriptor_length) {\n    memcpy(descriptor_buf, usb_hid_descriptor_template, sizeof(usb_hid_descriptor_template));\n\n    descriptor_buf[HID_DESCRIPTOR_INTERFACE_INDEX] = descriptor_counts->current_interface;\n    descriptor_counts->current_interface++;\n\n    usb_add_interface_string(*current_interface_string, usb_hid_interface_name);\n    descriptor_buf[HID_DESCRIPTOR_INTERFACE_STRING_INDEX] = *current_interface_string;\n    (*current_interface_string)++;\n\n    descriptor_buf[HID_DESCRIPTOR_LENGTH_INDEX] = report_descriptor_length & 0xFF;\n    descriptor_buf[HID_DESCRIPTOR_LENGTH_INDEX + 1] = (report_descriptor_length >> 8);\n\n    descriptor_buf[HID_IN_ENDPOINT_INDEX] =\n        0x80 | (USB_HID_EP_NUM_IN ? USB_HID_EP_NUM_IN : descriptor_counts->current_endpoint);\n    descriptor_counts->num_in_endpoints++;\n    descriptor_buf[HID_OUT_ENDPOINT_INDEX] =\n        USB_HID_EP_NUM_OUT ? USB_HID_EP_NUM_OUT : descriptor_counts->current_endpoint;\n    descriptor_counts->num_out_endpoints++;\n    descriptor_counts->current_endpoint++;\n\n    return sizeof(usb_hid_descriptor_template);\n}\n\n// Make up a fresh tuple containing the device objects saved in the static\n// devices table. Save the tuple in usb_hid.devices.\nstatic void usb_hid_set_devices_from_hid_devices(void) {\n    mp_obj_t tuple_items[num_hid_devices];\n    for (mp_int_t i = 0; i < num_hid_devices; i++) {\n        tuple_items[i] = &hid_devices[i];\n    }\n\n    // Remember tuple for gc purposes.\n    hid_devices_tuple = mp_obj_new_tuple(num_hid_devices, tuple_items);\n    usb_hid_set_devices(hid_devices_tuple);\n}\n\nbool common_hal_usb_hid_disable(void) {\n    return common_hal_usb_hid_enable(mp_const_empty_tuple);\n}\n\nbool common_hal_usb_hid_enable(const mp_obj_t devices) {\n    // We can't change the devices once we're connected.\n    if (tud_connected()) {\n        return false;\n    }\n\n    const mp_int_t num_devices = MP_OBJ_SMALL_INT_VALUE(mp_obj_len(devices));\n    if (num_devices > MAX_HID_DEVICES) {\n        mp_raise_ValueError_varg(translate(\"No more than %d HID devices allowed\"), MAX_HID_DEVICES);\n    }\n\n    num_hid_devices = num_devices;\n\n    // Remember the devices in static storage so they live across VMs.\n    for (mp_int_t i = 0; i < num_hid_devices; i++) {\n        // devices has already been validated to contain only usb_hid_device_obj_t objects.\n        usb_hid_device_obj_t *device =\n            MP_OBJ_TO_PTR(mp_obj_subscr(devices, MP_OBJ_NEW_SMALL_INT(i), MP_OBJ_SENTINEL));\n        memcpy(&hid_devices[i], device, sizeof(usb_hid_device_obj_t));\n    }\n\n    usb_hid_set_devices_from_hid_devices();\n\n    return true;\n}\n\n// Called when HID devices are ready to be used, when code.py or the REPL starts running.\nvoid usb_hid_setup_devices(void) {\n    usb_hid_set_devices_from_hid_devices();\n\n    // Create report buffers on the heap.\n    for (mp_int_t i = 0; i < num_hid_devices; i++) {\n        usb_hid_device_create_report_buffers(&hid_devices[i]);\n    }\n}\n\n// Total length of the report descriptor, with all configured devices.\nsize_t usb_hid_report_descriptor_length(void) {\n    size_t total_hid_report_descriptor_length = 0;\n    for (mp_int_t i = 0; i < num_hid_devices; i++) {\n        total_hid_report_descriptor_length += hid_devices[i].report_descriptor_length;\n    }\n\n    // Don't need space for a report id if there's only one device.\n    if (num_hid_devices == 1) {\n        total_hid_report_descriptor_length -= 2;\n    }\n    return total_hid_report_descriptor_length;\n}\n\n// Build the combined HID report descriptor in the given space.\nvoid usb_hid_build_report_descriptor(uint8_t *report_descriptor_space, size_t report_descriptor_length) {\n    if (!usb_hid_enabled()) {\n        return;\n    }\n\n    uint8_t *report_descriptor_start = report_descriptor_space;\n\n    for (mp_int_t i = 0; i < num_hid_devices; i++) {\n        usb_hid_device_obj_t *device = &hid_devices[i];\n        // Copy the report descriptor for this device.\n        if (num_hid_devices == 1) {\n            // There's only one device, so it shouldn't have a report ID.\n            // Copy the descriptor, but splice out the report id indicator and value (2 bytes).\n            memcpy(report_descriptor_start, device->report_descriptor, device->report_id_index - 1);\n            report_descriptor_start += device->report_id_index - 1;\n            memcpy(report_descriptor_start, device->report_descriptor + device->report_id_index + 1,\n                device->report_descriptor_length - device->report_id_index - 1);\n        } else {\n            // Copy the whole descriptor and fill in the report id.\n            memcpy(report_descriptor_start, device->report_descriptor, device->report_descriptor_length);\n            report_descriptor_start[device->report_id_index] = i + 1;\n\n            // Remember the report id that was assigned.\n            device->report_id = i + 1;\n\n            // Advance to the next free chunk for the next report descriptor.x\n            report_descriptor_start += device->report_descriptor_length;\n        }\n        // Clear the heap pointer to the bytes of the descriptor.\n        // We don't need it any more and it will get lost when the heap goes away.\n        device->report_descriptor = NULL;\n    }\n}\n\n// Call this after the heap and VM are finished.\nvoid usb_hid_save_report_descriptor(uint8_t *report_descriptor_space, size_t report_descriptor_length) {\n    if (!usb_hid_enabled()) {\n        return;\n    }\n\n    // Allocate storage that persists across VMs to hold the combined report descriptor.\n    // and to remember the device details.\n\n    // Copy the descriptor from the temporary area to a supervisor storage allocation that\n    // will leave between VM instantiations.\n    hid_report_descriptor_allocation =\n        allocate_memory(align32_size(report_descriptor_length),\n            /*high_address*/ false, /*movable*/ false);\n    memcpy((uint8_t *)hid_report_descriptor_allocation->ptr, report_descriptor_space, report_descriptor_length);\n}\n\nvoid usb_hid_gc_collect(void) {\n    gc_collect_ptr(hid_devices_tuple);\n\n    // Mark possible heap pointers in the static device list as in use.\n    for (mp_int_t i = 0; i < num_hid_devices; i++) {\n        // Cast away the const for .report_descriptor. It could be in flash or on the heap.\n        // Constant report descriptors must be const so that they are used directly from flash\n        // and not copied into RAM.\n        gc_collect_ptr((void *)hid_devices[i].report_descriptor);\n        gc_collect_ptr(hid_devices[i].in_report_buffer);\n        gc_collect_ptr(hid_devices[i].out_report_buffer);\n    }\n}\n\nusb_hid_device_obj_t *usb_hid_get_device_with_report_id(uint8_t report_id) {\n    for (uint8_t i = 0; i < num_hid_devices; i++) {\n        usb_hid_device_obj_t *device = &hid_devices[i];\n        if (device->report_id == report_id) {\n            return &hid_devices[i];\n        }\n    }\n    return NULL;\n}\n\n// Invoked when GET HID REPORT DESCRIPTOR is received.\n// Application return pointer to descriptor\n// Descriptor contents must exist long enough for transfer to complete\nuint8_t const *tud_hid_descriptor_report_cb(uint8_t itf) {\n    return (uint8_t *)hid_report_descriptor_allocation->ptr;\n}\n\n", "comment_ratio": 0.22145328719723184}
{"lang": "c", "code": "#ifndef FRAGMENT_SET_H\n#define FRAGMENT_SET_H 1\n\n/*\nManages contiguous data in a set.  Contiguous data that does not abut must be split up\ninto pairs of start and end indices called a data_fragment_t\nUsed by LtpFragmentSet and AGGREGATE CUSTODY SIGNAL(ACS) / CUSTODY TRANSFER ENHANCEMENT BLOCK(CTEB)\n*/\n\n#include <cstdint>\n#include <vector>\n#include <set>\n#include \"hdtn_util_export.h\"\n\nclass HDTN_UTIL_EXPORT FragmentSet {\npublic:\n    struct HDTN_UTIL_EXPORT data_fragment_t {\n        uint64_t beginIndex;\n        uint64_t endIndex;\n\n        data_fragment_t(); //a default constructor: X()\n        data_fragment_t(uint64_t paramBeginIndex, uint64_t paramEndIndex);\n        ~data_fragment_t(); //a destructor: ~X()\n        data_fragment_t(const data_fragment_t& o); //a copy constructor: X(const X&)\n        data_fragment_t(data_fragment_t&& o); //a move constructor: X(X&&)\n        data_fragment_t& operator=(const data_fragment_t& o); //a copy assignment: operator=(const X&)\n        data_fragment_t& operator=(data_fragment_t&& o); //a move assignment: operator=(X&&)\n        bool operator==(const data_fragment_t & o) const; //operator ==\n        bool operator!=(const data_fragment_t & o) const; //operator !=\n        bool operator<(const data_fragment_t & o) const; //operator < (no overlap no abut)\n        static bool SimulateSetKeyFind(const data_fragment_t & key, const data_fragment_t & keyInSet);\n    };\n\npublic:\n    \n    static void InsertFragment(std::set<data_fragment_t> & fragmentSet, data_fragment_t key);\n    static bool ContainsFragmentEntirely(const std::set<data_fragment_t> & fragmentSet, const data_fragment_t & key);\n    static bool DoesNotContainFragmentEntirely(const std::set<data_fragment_t> & fragmentSet, const data_fragment_t & key);\n    static void RemoveFragment(std::set<data_fragment_t> & fragmentSet, const data_fragment_t & key);\n    static void PrintFragmentSet(const std::set<data_fragment_t> & fragmentSet);\n};\n\n#endif // FRAGMENT_SET_H\n\n\n", "comment_ratio": 0.2222222222222222}
{"lang": "c", "code": "#ifndef __DESCRIBE_H__\n#define __DESCRIBE_H__ 1\n\n#include \"assertion-macros.h\"\n\n#define DESCRIBE_VERSION \"0.0.0\"\n\n#define DESCRIBE_OK \"\u2713\"\n#define DESCRIBE_FAIL \"\u2716\"\n\n/*\n * Describe `fn` with `title`\n */\n\n#define describe(title, fn) ({ \\\n  printf(\"\\n  %s\\n\", title); \\\n  fn; \\\n});\n\n/*\n * Describe `fn` with `specification`\n */\n\n#define it(specification, fn) ({ \\\n  int before = assert_failures(); \\\n  fn; \\\n  if (assert_failures() == before) { \\\n    printf(\"    \\e[92m%s \\e[90m%s\\e[0m\\n\", DESCRIBE_OK, specification); \\\n  } else { \\\n    printf(\"    \\e[90m%s \\e[90m%s\\e[0m\\n\", DESCRIBE_FAIL, specification); \\\n  } \\\n});\n\n#endif\n\n", "comment_ratio": 0.13636363636363635}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n\n@class JLUserRecord, JLUser;\n\n@interface JLResult : NSObject <NSCoding, NSCopying>\n\n@property (nonatomic, strong) JLUserRecord *userRecord;\n@property (nonatomic, strong) NSString *showTime;\n@property (nonatomic, strong) JLUser *user;\n@property (nonatomic, strong) NSString *sessionId;\n\n+ (instancetype)modelObjectWithDictionary:(NSDictionary *)dict;\n- (instancetype)initWithDictionary:(NSDictionary *)dict;\n- (NSDictionary *)dictionaryRepresentation;\n\n@end\n\n", "comment_ratio": 0.25}
{"lang": "c", "code": "//\n// Created by nicholas on 06/02/17.\n//\n\n#ifndef UNITY3D_INJECT_TYPES_H\n#define UNITY3D_INJECT_TYPES_H\n\n#if defined __linux__\n  #define UNITY3D_INJECT_LINUX\n#elif defined __WIN32\n  #error \"Windows is not yet supported\"\n  #define UNITY3D_INJECT_WINDOWS\n#elif defined __APPLE__\n  #error \"OS X is not yet supported\"\n  #define UNITY3D_INJECT_OSX\n#endif\n\n#if defined __i386__ || defined _M_IX86\n#define MonoPtr int32_t\n#elif defined __amd64__ || defined _M_AMD64\n#define MonoPtr int64_t\n#endif\n\n#endif //UNITY3D_INJECT_TYPES_H\n\n", "comment_ratio": 0.16}
{"lang": "c", "code": "//\n//  Generated by the J2ObjC translator.  DO NOT EDIT!\n//  source: ./analysis/common/src/java/org/apache/lucene/analysis/da/package-info.java\n//\n\n/*!\n @brief Analyzer for Danish.\n */\n#include \"J2ObjC_header.h\"\n\n#pragma push_macro(\"INCLUDE_ALL_OrgApacheLuceneAnalysisDaPackage_info\")\n#ifdef RESTRICT_OrgApacheLuceneAnalysisDaPackage_info\n#define INCLUDE_ALL_OrgApacheLuceneAnalysisDaPackage_info 0\n#else\n#define INCLUDE_ALL_OrgApacheLuceneAnalysisDaPackage_info 1\n#endif\n#undef RESTRICT_OrgApacheLuceneAnalysisDaPackage_info\n\n#if __has_feature(nullability)\n#pragma clang diagnostic push\n#pragma GCC diagnostic ignored \"-Wnullability\"\n#pragma GCC diagnostic ignored \"-Wnullability-completeness\"\n#endif\n\n\n#if __has_feature(nullability)\n#pragma clang diagnostic pop\n#endif\n#pragma pop_macro(\"INCLUDE_ALL_OrgApacheLuceneAnalysisDaPackage_info\")\n\n", "comment_ratio": 0.13333333333333333}
{"lang": "c", "code": "#define BAUDRATE 9600\n#define FCY 7370000/2\n\nvoid configPins(void);\nvoid configUART1(void);\nvoid outChar1(unsigned char c);\nvoid my_puts(char *str);\n\nvoid my_puts(char *str) {\n    while (*str) {\n        outChar1(*str);\n        str++;\n    }\n}\n\nvoid configPins(void) {\n    RPINR18bits.U1RXR = 20;     // map UART1 RX to remappable pin RP20 (pin 12)\n    RPOR1bits.RP36R = 1;        // map UART1 TX to remappable pin RP36 (pin 11)          \n}\n\nvoid outChar1(unsigned char c){\n    while(U1STAbits.UTXBF);     // wait for transmit buffer to be empty\n    U1TXREG = c;                // write character to transmit register\n}\n\nvoid configUART1(void) {\n    /*  Calculate the Baud Rate generator value     */\n    int brg = (FCY/BAUDRATE/4)-1;\n    U1MODEbits.BRGH = 1;        // High speed mode\n    U1BRG = brg;                // store the value in the register\n    \n    U1MODEbits.PDSEL = 0;       // 8 bit data, no parity\n    U1MODEbits.STSEL = 0;       // 1 stop bit\n    \n    U1MODEbits.UEN = 0b00;      // UxTX and UxRX pins are enabled and used;\n                                // also, no flow control pins\n    U1MODEbits.UARTEN = 1;      // enable UART RX/TX\n    U1STAbits.UTXEN = 1;        //Enable the transmitter\n \n}\n", "comment_ratio": 0.25}
{"lang": "c", "code": "//\r\n// defmisc.c\r\n//\r\n#include \"deflate.h\"\r\n#include <string.h>\r\n#include <stdio.h>\r\n#include <crtdbg.h>\r\n\r\n\r\n//\r\n// Fix the frequency data of the provided literal and distance trees such that no\r\n// element has a zero frequency.  We must never allow the cumulative frequency of\r\n// either tree to be >= 65536, so we divide all of the frequencies by two to make\r\n// sure.\r\n//\r\nvoid NormaliseFrequencies(USHORT *literal_tree_freq, USHORT *dist_tree_freq)\r\n{\r\n    int i;\r\n\r\n    // don't allow any zero frequency items to exist\r\n    // also make sure we don't overflow 65535 cumulative frequency\r\n    for (i = 0; i < MAX_DIST_TREE_ELEMENTS; i++)\r\n    {\r\n        // avoid overflow\r\n        dist_tree_freq[i] >>= 1;\r\n\r\n        if (dist_tree_freq[i] == 0)\r\n            dist_tree_freq[i] = 1;\r\n    }\r\n\r\n    for (i = 0; i < MAX_LITERAL_TREE_ELEMENTS; i++)\r\n    {\r\n        // avoid overflow\r\n        literal_tree_freq[i] >>= 1;\r\n\r\n        if (literal_tree_freq[i] == 0)\r\n            literal_tree_freq[i] = 1;\r\n    }\r\n}\r\n\n", "comment_ratio": 0.325}
{"lang": "c", "code": "#import <CoreLocation/CoreLocation.h>\n\n@interface RootViewController : UITableViewController <CLLocationManagerDelegate> {\n    \n    NSMutableArray *eventsArray;\n    NSManagedObjectContext *managedObjectContex;\n    \n    CLLocationManager *locationManager;\n    UIBarButtonItem *addButton;\n    \n}\n\n@property(nonatomic,retain) NSMutableArray *eventsArray;\n@property(nonatomic,retain) NSManagedObjectContext *managedObjectContex;\n\n@property(nonatomic,retain) CLLocationManager *locationManager;\n@property(nonatomic,retain) UIBarButtonItem *addButton;\n\n-(void) addEvent;\n\n@end\n\n", "comment_ratio": 0.25806451612903225}
{"lang": "c", "code": "// PotentialBuilder.h: interface for the PotentialBuilder class.\n//\n//////////////////////////////////////////////////////////////////////\n\n#if !defined(AFX_POTENTIALBUILDER_H__7E70611B_49D6_44A2_9465_B908C87ED5A4__INCLUDED_)\n#define AFX_POTENTIALBUILDER_H__7E70611B_49D6_44A2_9465_B908C87ED5A4__INCLUDED_\n\n#if _MSC_VER > 1000\n#pragma once\n#endif // _MSC_VER > 1000\n\n#include <istream>\n#include <ostream>\n\n#include \"Potential.h\"\n\nclass PotentialBuilder  \n{\npublic:\n\tPotentialBuilder();\n\tvirtual ~PotentialBuilder();\n\n\tvirtual Potential* loadPotential(std::istream* inputStream) = 0;\n\tvirtual void storePotential(Potential* potential, std::ostream* outputStream) = 0;\n};\n\n#endif // !defined(AFX_POTENTIALBUILDER_H__7E70611B_49D6_44A2_9465_B908C87ED5A4__INCLUDED_)\n\n", "comment_ratio": 0.17857142857142858}
{"lang": "c", "code": "#ifndef ZSPACE_TS_GEOMETRY_GRAPH_POLYHEDRA_H\n#define ZSPACE_TS_GEOMETRY_GRAPH_POLYHEDRA_H\n\n#pragma once\n\n#include <headers/zInterface/functionsets/zFnMesh.h>\n#include <headers/zInterface/functionsets/zFnGraph.h>\n#include <headers/zInterface/functionsets/zFnParticle.h>\n#include <headers/zInterface/model/zModel.h>\n\nnamespace zSpace\n{\n\n\t/** \\addtogroup zToolsets\n\t*\t\\brief Collection of toolsets for applications.\n\t*  @{\n\t*/\n\n\t/** \\addtogroup zTsGeometry\n\t*\t\\brief tool sets for geometry related utilities.\n\t*  @{\n\t*/\n\n\t/*! \\class zTsGraphPolyhedra\n\t*\t\\brief A function set to convert graph data to polyhedra.\n\t*\t\\since version 0.0.4\n\t*/\n\n\t/** @}*/\n\n\t/** @}*/\n\n\tclass ZSPACE_TOOLS zTsGraphPolyhedra\n\t{\n\tprotected:\n\t\t//--------------------------\n\t\t//---- PROTECTED ATTRIBUTES\n\t\t//--------------------------\n\n\t\t/*!\t\\brief pointer to graph Object  */\n\t\tzObjGraph *graphObj;\t\t\n\n\t\t/*!\t\\brief container of  form particle objects  */\n\t\tvector<zObjParticleArray> formParticlesObj;\t\t\n\n\t\t/*!\t\\brief container of form particle function set  */\n\t\tvector<vector<zFnParticle>> fnFormParticles;\n\n\t\t/*!\t\\brief DISCRIPTION  */\n\t\tzUtilsCore coreUtils;\n\n\t\t/*!\t\\brief DISCRIPTION  */\n\t\tzObjMeshArray convexHullMeshes;\n\n\t\t/*!\t\\brief DISCRIPTION  */\n\t\tzObjMeshArray dualMeshes;\n\n\t\t/*!\t\\brief DISCRIPTION  */\n\t\tvector<zIntPairArray> c_graphHalfEdge_dualCellFace;\n\n\t\tvector<zVectorArray> dualCellFace_NormTargets;\n\n\t\tvector<zDoubleArray> dualCellFace_AreaTargets;\n\n\t\t/*!\t\\brief DISCRIPTION  */\n\t\tvector<pair<zPoint, zPoint>> dualConnectivityLines;\n\n\t\t/*!\t\\brief DISCRIPTION  */\n\t\tzIntArray nodeId;\n\n\tpublic:\n\t\t//--------------------------\n\t\t//---- PUBLIC ATTRIBUTES\n\t\t//--------------------------\n\n\t\t/*!\t\\brief form function set  */\n\t\tzFnGraph fnGraph;\n\n\t\tzDomainDouble deviations[2];\n\n\t\t// TMP!!\n\t\tint snapSteps = 0;\n\n\t\t//--------------------------\n\t\t//---- CONSTRUCTOR\n\t\t//--------------------------\n\n\t\t/*! \\brief Default constructor.\n\t\t*\n\t\t*\t\\since version 0.0.4\n\t\t*/\n\t\tzTsGraphPolyhedra();\n\n\t\t/*! \\brief Overloaded constructor.\n\t\t*\n\t\t*\t\\param\t\t[in]\t_graphObj\t\t\t- input graph object.\n\t\t*\t\\since version 0.0.4\n\t\t*/\n\t\tzTsGraphPolyhedra(zObjGraph &_graphObj);\n\n\t\t//--------------------------\n\t\t//---- DESTRUCTOR\n\t\t//--------------------------\n\n\t\t/*! \\brief Default destructor.\n\t\t*\n\t\t*\t\\since version 0.0.4\n\t\t*/\n\t\t~zTsGraphPolyhedra();\n\n\t\t//--------------------------\n\t\t//---- CREATE METHODS\n\t\t//--------------------------\n\n\t\t/*! \\brief DISCRIPTION\n\t\t*\n\t\t*\t\\since version 0.0.4\n\t\t*/\n\t\tvoid createGraphFromFile(string &_path, zFileTpye _type, bool _staticGeom = false);\n\n\t\t/*! \\brief DISCRIPTION\n\t\t*\n\t\t*\t\\since version 0.0.4\n\t\t*/\n\t\tvoid createGraphFromMesh(zObjMesh &_inMeshObj, zVector &_verticalForce);\n\n\t\t/*! \\brief DISCRIPTION\n\t\t*\n\t\t*\t\\since version 0.0.4\n\t\t*/\n\t\tvoid create();\n\n\t\t//--------------------------\n\t\t//---- UPDATE METHODS\n\t\t//--------------------------\n\n\t\tbool equilibrium(bool &compTargets, double dT, zIntergrationType type, int numIterations = 1000, double angleTolerance = EPS, double areaTolerance = EPS, bool printInfo = false);\n\n\n#if defined (ZSPACE_UNREAL_INTEROP) || defined (ZSPACE_MAYA_INTEROP) || defined (ZSPACE_RHINO_INTEROP)\n\t\t// Do Nothing\n#else\n\n\t\t//--------------------------\n\t\t//---- DISPLAY SET METHODS\n\t\t//--------------------------\n\n\t\t/*! \\brief This method sets the display model not for Unreal.\n\t\t*\n\t\t*\t\\param\t\t[in]\t_index\t\t\t\t- input housing unit index\n\t\t*\t\\since version 0.0.4\n\t\t*/\n\t\tvoid setDisplayModel(zModel&_model);\n\n\t\t//--------------------------\n\t\t//---- DRAW METHODS\n\t\t//--------------------------\n\n\t\t/*! \\brief DISCRIPTION\n\t\t*\n\t\t*\t\\since version 0.0.4\n\t\t*/\n\t\tvoid setDisplayGraphElements(bool _drawGraph, bool _drawVertIds = false, bool _drawEdgeIds = false);\n\n\t\t/*! \\brief DISCRIPTION\n\t\t*\n\t\t*\t\\since version 0.0.4\n\t\t*/\n\t\tvoid setDisplayHullElements(bool _drawConvexHulls, bool _drawFaces = true, bool _drawVertIds = false, bool _drawEdgeIds = false, bool _drawFaceIds = false);\n\n\t\t/*! \\brief DISCRIPTION\n\t\t*\n\t\t*\t\\since version 0.0.4\n\t\t*/\n\t\tvoid setDisplayPolyhedraElements(bool _drawDualMesh, bool _drawFaces = true, bool _drawVertIds = false, bool _drawEdgeIds = false, bool _drawFaceIds = false);\n\n\tprotected:\n\t\t\n\t\t/*!\t\\brief DISCRIPTION  */\n\t\t\tzModel *model;\n#endif\n\n\tprivate:\n\t\t//--------------------------\n\t\t//---- PRIVATE CREATE METHODS\n\t\t//--------------------------\n\n\t\t/*! \\brief DISCRIPTION\n\t\t*\n\t\t*\t\\since version 0.0.4\n\t\t*/\n\t\tvoid createDualMesh(zItGraphVertex &_graphVertex);\n\n\t\t//--------------------------\n\t\t//---- PRIVATE COMPUTE / UPDATE METHODS\n\t\t//--------------------------\n\t\t   \t\n\t\tvoid computeTargets();\n\n\t\tvoid updateDual(double &dT, zIntergrationType &type, int &numIterations);\n\n\t\tbool checkParallelity(zDomainDouble &deviations, double &angleTolerance,  bool &printInfo);\n\n\t\tbool checkArea(zDomainDouble &deviations, double &areaTolerance, bool &printInfo);\n\n\t\t//--------------------------\n\t\t//---- PRIVATE UTILITY METHODS\n\t\t//--------------------------\n\n\t\t/*! \\brief DISCRIPTION\n\t\t*\n\t\t*\t\\since version 0.0.4\n\t\t*/\n\t\tvoid sortGraphVertices(zItGraphVertexArray &_graphVertices);\n\n\t\t/*! \\brief DISCRIPTION\n\t\t*\n\t\t*\t\\since version 0.0.4\n\t\t*/\n\t\tvoid cleanConvexHull(zItGraphVertex &_vIt);\n\n\t\t/*! \\brief DISCRIPTION\n\t\t*\n\t\t*\t\\since version 0.0.4\n\t\t*/\n\t\tvoid colorDualFaceConnectivity();\n\n\t\t/*! \\brief DISCRIPTION\n\t\t*\n\t\t*\t\\since version 0.0.4\n\t\t*/\n\t\tvoid snapDualCells(zItGraphVertexArray &bsf, zItGraphVertexArray &gCenters);\n\t};\n}\n\n#if defined(ZSPACE_STATIC_LIBRARY)  || defined(ZSPACE_DYNAMIC_LIBRARY)\n// All defined OK so do nothing\n#else\n#include<source/zToolsets/geometry/zTsGraphPolyhedra.cpp>\n#endif\n\n#endif\n", "comment_ratio": 0.18503937007874016}
{"lang": "c", "code": "#ifndef MAINWINDOW_H\n#define MAINWINDOW_H\n\n#include <QMainWindow>\n#include <dialog.h>\n#include <QPaintEvent>\n#include <QPainter>\n#include <QPen>\n#include <QBrush>\n#include <QMessageBox>\n#include <QWidget>\n#include <QTime>\n#include <QTimer>\n#include <QFileDialog>\n#include <vector>\n#include <queue>\n#include <iostream>\n#include <utility>\n#include <qrandom.h>\n#include <QStringList>\n#include <QString>\n#include <time.h>\n#include <QSound>\n#include <set>\n#include <queue>\n#include <QPixmap>\n\nnamespace Ui {\nclass MainWindow;\n}\nclass Drop : public QWidget\n{\n    Q_OBJECT\npublic:\n    Drop(int x,int y,int z);\n    Drop(const Drop & tmp){\n        x = tmp.x;\n        y = tmp.y;\n        color_r = tmp.color_r;\n        color_g = tmp.color_g;\n        color_b = tmp.color_b;\n//        exist   = tmp.exist;\n        circle  = tmp.circle;\n        move    = tmp.move;\n        does    = tmp.does;\n        swag    = tmp.swag;\n    }\n\n    int x = 0;\n    int y = 0;\n    int color_r = 0;\n    int color_g = 0;\n    int color_b = 0;\n    int time = 0;\n//    bool exist = true;\n    int circle = 1;\n    bool does = true;\n    std::set<std::pair<int,int>> swag;\n    std::vector<std::pair<int,std::pair<int,int>>> move;    //<time,<x,y>>\n};\n\n//class Ellispe : public Drop\n//{\n//public :\n//    int x_direction = 0;\n//    int y_direction = 0;\n//    int circle = 0;\n//    Ellispe(int x1,int y1,int x_dir,int y_dir,int t)\n//    {\n//        time = t;\n//        x = x1;\n//        y = y1;\n//        x_direction = x_dir;\n//        y_direction = y_dir;\n//    }\n//};\n\nclass MainWindow : public QMainWindow\n{\n    Q_OBJECT\n\npublic:\n    explicit MainWindow(QWidget *parent = nullptr);\n    ~MainWindow();\n\n    Dialog *dialog;\n    int x = 0;\n    int y = 0;\n    int input_num = 0;\n    int *input_x;\n    int *input_y;\n    int output_x;\n    int output_y;\n    bool create_picture = false;\n    int ***board;\n    QTimer *timer;\n    int collect_time = 0;\n    bool input_file = false;\n    QPixmap *pixmap;\n\n    bool draw_pollution_num = false;\n    int ** pollution;\n    bool wrong = false;\n    int collect = 0;\n\n    void paintEvent(QPaintEvent *e);\n    void file_input();\n    void split(QString);\n    void sort();\n    void execute_order();\n\n    void wash(int now_x,int now_y,int out_x,int out_y);\n    QTimer *wash_timer;\n    bool can_use_wash = false;\n    bool use_wash = false;\n    bool after_use_wash = false;\n    bool search_path(int now_x,int now_y,int to_x,int to_y);\n    int **wash_board;\n    std::vector<std::pair<int,std::pair<int,int>>> path;\n    int count_time = 0;\n    int **have_gone;\n    bool no_pollute = false;\n    std::queue<int> ** save_time;\n    void mousePressEvent(QMouseEvent *e);\n\n    QStringList time;\n    QStringList order;\n    QStringList *pace;\n\n    QSound *dragon;\n    QSound *frog;\n    QSound *GM;\n    QSound *kiki;\n    bool only_once = false;\n\nprivate slots:\n    void on_actioncaidan_triggered();\n    void accept_num();\n    void on_actionfile_triggered();\n\n    void on_pushButton_clicked();\n    void time_up();\n    void on_pushButton_4_clicked();\n\n    void on_pushButton_2_clicked();\n\n    void on_pushButton_3_clicked();\n\n    void on_checkBox_clicked();\n\nprivate:\n    Ui::MainWindow *ui;\n\n\nsignals:\n    void to_stop();\n};\n\n#endif // MAINWINDOW_H\n\n", "comment_ratio": 0.11875}
{"lang": "c", "code": "#pragma  once\r\n\r\nclass RigidBodyConstructionInfo\r\n{\r\npublic:\r\n\tfloat\t\t\tm_mass;\r\n\r\n\tVector3         worldTranslation;\r\n\tQuaternion      worldRotation;\r\n\r\n\tVector3\t\t\tm_localInertia;\r\n\tfloat\t\t\tm_linearDamping;\r\n\tfloat\t\t\tm_angularDamping;\r\n\r\n\t///best simulation results when friction is non-zero\r\n\tfloat\t\t\tm_friction;\r\n\t///best simulation results using zero restitution.\r\n\tfloat\t\t\tm_restitution;\r\n\r\n\tfloat\t\t\tm_linearSleepingThreshold;\r\n\tfloat\t\t\tm_angularSleepingThreshold;\r\n\r\n\t//Additional damping can help avoiding lowpass jitter motion, help stability for ragdolls etc.\r\n\t//Such damping is undesirable, so once the overall simulation quality of the rigid body dynamics system has improved, this should become obsolete\r\n\tbool\t\t\tm_additionalDamping;\r\n\tfloat\t\t\tm_additionalDampingFactor;\r\n\tfloat\t\t\tm_additionalLinearDampingThresholdSqr;\r\n\tfloat\t\t\tm_additionalAngularDampingThresholdSqr;\r\n\tfloat\t\t\tm_additionalAngularDampingFactor;\r\n\r\n\tvoid toBullet(btRigidBody::btRigidBodyConstructionInfo& bulletInfo, btMotionState* motionState, btCollisionShape* collisionShape)\r\n\t{\r\n\t\tbulletInfo.m_mass = m_mass;\r\n\r\n\t\t///When a motionState is provided, the rigid body will initialize its world transform from the motion state\r\n\t\t///In this case, m_startWorldTransform is ignored.\r\n\t\tbulletInfo.m_motionState = motionState;\r\n\t\tbulletInfo.m_startWorldTransform.setOrigin(worldTranslation.toBullet());\r\n\t\tbulletInfo.m_startWorldTransform.setRotation(worldRotation.toBullet());\r\n\r\n\t\tbulletInfo.m_collisionShape = collisionShape;\r\n\t\tbulletInfo.m_localInertia = m_localInertia.toBullet();\r\n\t\tbulletInfo.m_linearDamping = m_linearDamping;\r\n\t\tbulletInfo.m_angularDamping = m_angularDamping;\r\n\r\n\t\t///best simulation results when friction is non-zero\r\n\t\tbulletInfo.m_friction = m_friction;\r\n\t\t///best simulation results using zero restitution.\r\n\t\tbulletInfo.m_restitution = m_restitution;\r\n\r\n\t\tbulletInfo.m_linearSleepingThreshold = m_linearSleepingThreshold;\r\n\t\tbulletInfo.m_angularSleepingThreshold = m_angularSleepingThreshold;\r\n\r\n\t\t//Additional damping can help avoiding lowpass jitter motion, help stability for ragdolls etc.\r\n\t\t//Such damping is undesirable, so once the overall simulation quality of the rigid body dynamics system has improved, this should become obsolete\r\n\t\tbulletInfo.m_additionalDamping = m_additionalDamping;\r\n\t\tbulletInfo.m_additionalDampingFactor = m_additionalDampingFactor;\r\n\t\tbulletInfo.m_additionalLinearDampingThresholdSqr = m_additionalLinearDampingThresholdSqr;\r\n\t\tbulletInfo.m_additionalAngularDampingThresholdSqr = m_additionalAngularDampingThresholdSqr;\r\n\t\tbulletInfo.m_additionalAngularDampingFactor = m_additionalAngularDampingFactor;\r\n\t}\r\n};\n", "comment_ratio": 0.16129032258064516}
{"lang": "c", "code": "#import \"NSObject-Protocol.h\"\n\n@class CSDConversationParticipant, NSData, NSNumber, NSString;\n\n@protocol CSDAVCSession <NSObject>\n@property(nonatomic, getter=isVideoPaused) _Bool videoPaused;\n@property(nonatomic, getter=isVideoEnabled) _Bool videoEnabled;\n@property(nonatomic, getter=isAudioEnabled) _Bool audioEnabled;\n@property(nonatomic, getter=isUplinkMuted) _Bool uplinkMuted;\n@property(nonatomic, getter=isAudioReady) _Bool audioReady;\n@property(readonly, nonatomic) long long maxVideoDecodesAllowed;\n@property(readonly, nonatomic) long long sessionToken;\n@property(readonly, copy, nonatomic) NSString *sessionIdentifier;\n@property(readonly, copy, nonatomic) NSData *localParticipantData;\n- (void)stop;\n- (void)start;\n- (void)setRelaying:(_Bool)arg1;\n- (void)commitParticipantUpdates;\n- (void)beginParticipantUpdates;\n- (void)setVideoQuality:(unsigned long long)arg1 visibility:(NSNumber *)arg2 prominence:(NSNumber *)arg3 forParticipantWithIdentifier:(unsigned long long)arg4;\n- (void)setAudioAndVideoMuted:(_Bool)arg1 forParticipantWithIdentifier:(unsigned long long)arg2;\n- (void)setVideoEnabled:(_Bool)arg1 forParticipantWithIdentifier:(unsigned long long)arg2;\n- (void)setAudioEnabled:(_Bool)arg1 forParticipantWithIdentifier:(unsigned long long)arg2;\n- (void)setDownlinkMuted:(_Bool)arg1 forParticipantWithIdentifier:(unsigned long long)arg2;\n- (void)removeParticipant:(CSDConversationParticipant *)arg1;\n- (void)addParticipant:(CSDConversationParticipant *)arg1 withVideoEnabled:(_Bool)arg2;\n@end\n\n\n", "comment_ratio": 0.14285714285714285}
{"lang": "c", "code": "#import <objc/NSObject.h>\n\n@interface NSStringHelper : NSObject\n{\n}\n\n+ (_Bool)ISMcID:(id)arg1;\n+ (_Bool)ISTwID:(id)arg1;\n+ (_Bool)ISHkID:(id)arg1;\n+ (_Bool)isTaiBaoID:(id)arg1;\n+ (_Bool)isHuiXiangID:(id)arg1;\n+ (_Bool)invalidateID:(id)arg1;\n+ (_Bool)isUserIDNum:(id)arg1;\n+ (_Bool)isBankCardNum:(id)arg1;\n+ (_Bool)isPhoneNum:(id)arg1;\n+ (_Bool)isDigit:(id)arg1 Length:(unsigned long long)arg2;\n\n@end\n\n\n", "comment_ratio": 0.19230769230769232}
{"lang": "c", "code": "#ifndef CPROVER_GOTO_INSTRUMENT_NONDET_STATIC_H\n#define CPROVER_GOTO_INSTRUMENT_NONDET_STATIC_H\n\n#include <util/options.h>\n\nclass goto_modelt;\nclass namespacet;\nclass goto_functionst;\nclass symbol_exprt;\n\nbool is_nondet_initializable_static(\n  const symbol_exprt &symbol_expr,\n  const namespacet &ns);\n\nvoid nondet_static(\n  const namespacet &ns,\n  goto_functionst &goto_functions);\n\nvoid nondet_static(goto_modelt &);\n\nvoid nondet_static(goto_modelt &, const optionst::value_listt &);\n\n#endif // CPROVER_GOTO_INSTRUMENT_NONDET_STATIC_H\n\n", "comment_ratio": 0.13953488372093023}
{"lang": "c", "code": "#import \"NSObject.h\"\n\n@class NSString, WCPayOverseaTransferGetCurrencyCgiRespObject;\n\n@protocol WCPayOverseaTransferGetCurrencyCgiDelegate <NSObject>\n- (void)onWCPayOverseaTransferGetCurrencyBizErrorWithRetCode:(int)arg1 ErrorMsg:(NSString *)arg2;\n- (void)onWCPayOverseaTransferGetCurrencyCgiErrorWithRetCode:(int)arg1 ErrorMsg:(NSString *)arg2;\n- (void)onWCPayOverseaTransferGetCurrencyCgiOkArgument:(WCPayOverseaTransferGetCurrencyCgiRespObject *)arg1;\n@end\n\n\n", "comment_ratio": 0.29411764705882354}
{"lang": "c", "code": "//\n//  AppDelegate.h\n//  OC_Test\n//\n//  Created by \u542f\u4e1a\u4e9103 on 2021/8/25.\n//\n\n#import <UIKit/UIKit.h>\n\n@interface AppDelegate : UIResponder <UIApplicationDelegate>\n\n\n@end\n\n\n", "comment_ratio": 0.4}
{"lang": "c", "code": "#include \"../hookapi.h\"\n\n#define BLACKLIST_ACCOUNT \"rno8D3qi5VrBvxTUE7nsem5kcJDnQUooQy\"\n\nint64_t cbak(int64_t reserved)\n{\n    // we never emit anything from this hook so this will never be called\n    return 0;   \n}\n\nint64_t hook(int64_t reserved)\n{\n    GUARD(1);\n\n    // fetch the originating account ID\n    uint8_t otxn_accid[20];\n    if (otxn_field(otxn_accid, 20, sfAccount) != 20)\n        rollback(SBUF(\"Firewall: Could not fetch sfAccount from originating transaction!!!\"), 100);\n\n    // RH NOTE in production you should always specify account IDs directly as a preset 20 byte array\n    // translating from r-addr here is just for demonstration purposes.\n    uint8_t blacklist_accid[20];\n    if (util_accid(SBUF(blacklist_accid), SBUF(BLACKLIST_ACCOUNT)) != 20)\n        rollback(SBUF(\"Firewall: Could not decode blacklist account id.\"), 200);\n\n    // look up the account ID in the foreign state (blacklist account's hook state)\n    uint8_t blacklist_status[1] = { 0 };\n    int64_t lookup = state_foreign(SBUF(blacklist_status), SBUF(otxn_accid), SBUF(blacklist_accid));\n    if (lookup == INVALID_ACCOUNT)\n        trace(SBUF(\"Firewall: Warning specified blacklist account does not exist.\"), 0, 0, 0);\n\n    if (blacklist_status[0] == 0)\n        accept(SBUF(\"Firewall: Allowing transaction.\"), 0);\n\n    rollback(SBUF(\"Firewall: Blocking transaction from blacklisted account.\"), 1);\n\n    return 0;\n}\n\n", "comment_ratio": 0.1282051282051282}
{"lang": "c", "code": "#ifndef AliPHOSCpv3GConnection_h\n#define AliPHOSCpv3GConnection_h\n/* Copyright(c) 1998-1999, ALICE Experiment at CERN, All rights reserved. *\n * See cxx source for full Copyright notice                               */\n\n// Connection tables of pads within one 3Gassiplex card.\n// 3Gassiplex card is a matrix of 8x6 pads.\n// This class sets a correspondence between the absolute pad ID (0..47) and \n// (x,z) position of this pad within a 3Gassiplex card\n// Author: Sergey Evdokimov, IHEP Protvino. Oct-2014\n\n#include \"Rtypes.h\"\n\nclass AliPHOSCpv3GConnection\n{\npublic:\n  AliPHOSCpv3GConnection();\n  Int_t Pad2X(Int_t pad)         {return pad2x[pad];  }\n  Int_t Pad2Y(Int_t pad)         {return pad2y[pad];  }\n  Int_t XY2Pad(Int_t x, Int_t y) {return xy2pad[x][y];}\nprivate:\n  Int_t pad2x[48];    //array of 48 elements containing 3gassiplex x coordinate for every channel\n  Int_t pad2y[48];    //array of 48 elements containing 3gassiplex x coordinate for every channel\n  Int_t xy2pad[8][6]; //2D array containing channels for every pad in 3gassiplex card\n};\n\n#endif //AliPHOSCpv3GConnection_h\n\n", "comment_ratio": 0.32142857142857145}
{"lang": "c", "code": "//\n//  TPSettings.h\n//  Pods\n//\n//  Created by Kerem Karatal on 1/30/14.\n//\n//\n\n#import <Foundation/Foundation.h>\n#import \"TPCommon.h\"\n\n@interface TPSettings : NSObject\n+ (NSDictionary *) loadSettings;\n+ (NSDateFormatter *) dateFormatter;\n+ (NSDateFormatter *) dateOnlyFormatter;\n+ (NSString *) filePathForFilename:(NSString *) filename;\n+ (NSString *) filePathForFilename:(NSString *)filename folderName:(NSString *) folderName;\n+ (NSDictionary *) dictionaryFromPageInfo:(TPPageInfo) pageInfo;\n+ (TPPageInfo) pageInfoFromDictionary:(NSDictionary *) dict;\n@end\n\n", "comment_ratio": 0.3333333333333333}
{"lang": "c", "code": "#ifndef C0P_PARAM_POST_OBJECTS_SURFER__US_8O0__SURFTIMEPREFACTOR_3O5_PX_GROUP_MEMBER_PASSIVE_CHOICE_H\n#define C0P_PARAM_POST_OBJECTS_SURFER__US_8O0__SURFTIMEPREFACTOR_3O5_PX_GROUP_MEMBER_PASSIVE_CHOICE_H\n#pragma once\n\n// THIS FILE SHOULD NOT BE EDITED DIRECTLY BY THE USERS.\n// THIS FILE WILL BE AUTOMATICALLY EDITED WHEN THE\n// CHOOSE COMMAND IS USED\n\n// choose your post\n#include \"core/post/objects/object/post/passive/position/core.h\"\n#include \"param/post/objects/surfer__us_8o0__surftimeprefactor_3o5/px/group/_member/passive/position/parameters.h\"\n\nnamespace c0p {\n    template<typename TypeSurferUs8O0Surftimeprefactor3O5Step>\n    using PostSurferUs8O0Surftimeprefactor3O5PxGroupMemberPassive = PostPostPassivePosition<PostSurferUs8O0Surftimeprefactor3O5PxGroupMemberPassivePositionParameters, TypeSurferUs8O0Surftimeprefactor3O5Step>;\n}\n\n#endif\n\n", "comment_ratio": 0.21052631578947367}
{"lang": "c", "code": "#pragma once\n\ntypedef struct _PAYLOAD_HEADER_V1 {\n    ULONG ImageSize;\n    IO_STATUS_BLOCK IoStatus;\n\n    //\n    // Variant specific fields.\n    // \n    pfnPsCreateSystemThread PsCreateSystemThread;\n    pfnZwClose ZwClose;\n\n    //BYTE Payload[ANYSIZE_ARRAY]; //following header, not a part of this structure\n} PAYLOAD_HEADER_V1, * PPAYLOAD_HEADER_V1;\n\ntypedef struct _PAYLOAD_HEADER_V2 {\n    ULONG ImageSize;\n    IO_STATUS_BLOCK IoStatus;\n\n    //\n    // Variant specific fields.\n    //\n    pfnExQueueWorkItem ExQueueWorkItem;\n\n    //BYTE Payload[ANYSIZE_ARRAY]; //following header, not a part of this structure\n} PAYLOAD_HEADER_V2, * PPAYLOAD_HEADER_V2;\n\ntypedef struct _PAYLOAD_HEADER_V3 {\n    ULONG ImageSize;\n    IO_STATUS_BLOCK IoStatus;\n\n    //\n    // Variant specific fields.\n    //\n    PVOID IoDriverObjectType;\n    pfnObCreateObject ObCreateObject;\n    pfnObInsertObject ObInsertObject;\n    pfnObMakeTemporaryObject ObMakeTemporaryObject;\n    pfnZwMakeTemporaryObject ZwMakeTemporaryObject;\n    pfnZwClose ZwClose;\n\n    FIXED_UNICODE_STRING ObjectName;\n    FIXED_UNICODE_STRING RegistryPath;\n\n    //BYTE Payload[ANYSIZE_ARRAY]; //following header, not a part of this structure\n} PAYLOAD_HEADER_V3, * PPAYLOAD_HEADER_V3;\n\nSIZE_T ScGetViewSize(\n    _In_ ULONG ShellVersion,\n    _In_ PVOID ShellCodePtr);\n\nDWORD ScSizeOf(\n    _In_ ULONG ShellVersion,\n    _Out_opt_ PULONG PayloadSize);\n\nBOOLEAN ScCreateFixedUnicodeString(\n    _Inout_ PFIXED_UNICODE_STRING DestinationString,\n    _In_ PCWSTR SourceString);\n\nHANDLE ScCreateReadyEvent(\n    _In_ ULONG ShellVersion,\n    _In_ PVOID ShellPtr);\n\nBOOLEAN ScStoreVersionSpecificData(\n    _In_ PKDU_CONTEXT Context,\n    _In_ PVOID PayloadPtr);\n\nVOID ScFree(\n    _In_ PVOID ShellPtr);\n\nBOOLEAN ScResolveImportForPayload(\n    _In_ ULONG ShellVersion,\n    _In_ PVOID PayloadHead,\n    _In_ ULONG_PTR KernelImage,\n    _In_ ULONG_PTR KernelBase);\n\nPVOID ScAllocate(\n    _In_ ULONG ShellVersion,\n    _In_ HANDLE SectionHandle,\n    _In_ SIZE_T SectionViewSize,\n    _In_ ULONG_PTR KernelImage,\n    _In_ ULONG_PTR KernelBase,\n    _In_ ULONG MemoryTag,\n    _Out_ PULONG ShellSize);\n\n", "comment_ratio": 0.11650485436893204}
{"lang": "c", "code": "#ifndef CHROME_BROWSER_UI_VIEWS_AUTOFILL_AUTOFILL_BUBBLE_HANDLER_IMPL_H_\n#define CHROME_BROWSER_UI_VIEWS_AUTOFILL_AUTOFILL_BUBBLE_HANDLER_IMPL_H_\n\n#include \"base/memory/raw_ptr.h\"\n#include \"base/scoped_observation.h\"\n#include \"chrome/browser/ui/autofill/autofill_bubble_handler.h\"\n#include \"chrome/browser/ui/views/profiles/avatar_toolbar_button.h\"\n#include \"components/autofill/core/browser/personal_data_manager.h\"\n#include \"components/autofill/core/browser/personal_data_manager_observer.h\"\n\nclass Browser;\nclass ToolbarButtonProvider;\n\nnamespace content {\nclass WebContents;\n}\n\nnamespace autofill {\nclass AutofillBubbleBase;\nclass LocalCardMigrationBubbleController;\nclass SaveCardBubbleController;\nclass SaveUPIBubble;\n\nclass AutofillBubbleHandlerImpl : public AutofillBubbleHandler,\n                                  public PersonalDataManagerObserver,\n                                  public AvatarToolbarButton::Observer {\n public:\n  AutofillBubbleHandlerImpl(Browser* browser,\n                            ToolbarButtonProvider* toolbar_button_provider);\n\n  AutofillBubbleHandlerImpl(const AutofillBubbleHandlerImpl&) = delete;\n  AutofillBubbleHandlerImpl& operator=(const AutofillBubbleHandlerImpl&) =\n      delete;\n\n  ~AutofillBubbleHandlerImpl() override;\n\n  // AutofillBubbleHandler:\n  AutofillBubbleBase* ShowSaveCreditCardBubble(\n      content::WebContents* web_contents,\n      SaveCardBubbleController* controller,\n      bool is_user_gesture) override;\n  AutofillBubbleBase* ShowLocalCardMigrationBubble(\n      content::WebContents* web_contents,\n      LocalCardMigrationBubbleController* controller,\n      bool is_user_gesture) override;\n  AutofillBubbleBase* ShowOfferNotificationBubble(\n      content::WebContents* contents,\n      OfferNotificationBubbleController* controller,\n      bool is_user_gesture) override;\n  SaveUPIBubble* ShowSaveUPIBubble(\n      content::WebContents* web_contents,\n      SaveUPIBubbleController* controller) override;\n  AutofillBubbleBase* ShowSaveAddressProfileBubble(\n      content::WebContents* web_contents,\n      SaveUpdateAddressProfileBubbleController* controller,\n      bool is_user_gesture) override;\n  AutofillBubbleBase* ShowUpdateAddressProfileBubble(\n      content::WebContents* web_contents,\n      SaveUpdateAddressProfileBubbleController* controller,\n      bool is_user_gesture) override;\n  AutofillBubbleBase* ShowEditAddressProfileDialog(\n      content::WebContents* web_contents,\n      EditAddressProfileDialogController* controller) override;\n  AutofillBubbleBase* ShowVirtualCardManualFallbackBubble(\n      content::WebContents* web_contents,\n      VirtualCardManualFallbackBubbleController* controller,\n      bool is_user_gesture) override;\n\n  void OnPasswordSaved() override;\n\n  // PersonalDataManagerObserver:\n  void OnCreditCardSaved(bool should_show_sign_in_promo_if_applicable) override;\n\n  // AvatarToolbarButton::Observer:\n  void OnAvatarHighlightAnimationFinished() override;\n\n private:\n  // Executes highlight animation on toolbar's avatar icon.\n  void ShowAvatarHighlightAnimation();\n\n  raw_ptr<Browser> browser_ = nullptr;\n\n  raw_ptr<ToolbarButtonProvider> toolbar_button_provider_ = nullptr;\n\n  // Whether a save local card sign in promo bubble could pop up from the avatar\n  // button after the highlight animation finishes.\n  bool should_show_sign_in_promo_if_applicable_ = false;\n\n  base::ScopedObservation<PersonalDataManager, PersonalDataManagerObserver>\n      personal_data_manager_observation_{this};\n  base::ScopedObservation<AvatarToolbarButton, AvatarToolbarButton::Observer>\n      avatar_toolbar_button_observation_{this};\n};\n\n}  // namespace autofill\n\n#endif  // CHROME_BROWSER_UI_VIEWS_AUTOFILL_AUTOFILL_BUBBLE_HANDLER_IMPL_H_\n\n", "comment_ratio": 0.10784313725490197}
{"lang": "c", "code": "#ifndef MI_BASE_CONDITION_H\n#define MI_BASE_CONDITION_H\n\n#include <mi/base/config.h>\n#include <mi/base/types.h>\n\n#ifndef MI_PLATFORM_WINDOWS\n#include <cerrno>\n#include <pthread.h>\n#include <sys/time.h>\n#else\n#include <mi/base/miwindows.h>\n#endif\n\nnamespace mi {\n\nnamespace base {\n\n/** \\addtogroup mi_base_threads\n@{\n*/\n\n/// Conditions allow threads to signal an event and to wait for such a signal, respectively.\nclass Condition\n{\npublic:\n    /// Constructor\n    Condition()\n    {\n#ifndef MI_PLATFORM_WINDOWS\n        m_signaled = false;\n        pthread_mutex_init( &m_mutex, NULL);\n        pthread_cond_init( &m_condvar, NULL);\n#else\n        m_handle = CreateEvent( NULL, false, false, NULL);\n#endif\n    }\n\n    /// Destructor\n    ~Condition()\n    {\n#ifndef MI_PLATFORM_WINDOWS\n        pthread_mutex_destroy( &m_mutex);\n        pthread_cond_destroy( &m_condvar);\n#else\n        CloseHandle( m_handle);\n#endif\n    }\n\n    /// Waits for the condition to be signaled.\n    ///\n    /// If the condition is already signaled at this time the call will return immediately.\n    void wait()\n    {\n#ifndef MI_PLATFORM_WINDOWS\n        pthread_mutex_lock( &m_mutex);\n        while( !m_signaled) //-V776 PVS\n            pthread_cond_wait( &m_condvar, &m_mutex);\n        m_signaled = false;\n        pthread_mutex_unlock( &m_mutex);\n#else\n        WaitForSingleObject( m_handle, INFINITE);\n#endif\n    }\n\n    /// Waits for the condition to be signaled until a given timeout.\n    ///\n    /// If the condition is already signaled at this time the call will return immediately.\n    ///\n    /// \\param timeout    Maximum time period (in seconds) to wait for the condition to be signaled.\n    /// \\return           \\c true if the timeout was hit, and \\c false if the condition was\n    ///                   signaled.\n    bool timed_wait( Float64 timeout) {\n#ifndef MI_PLATFORM_WINDOWS\n        struct timeval now;\n        gettimeofday( &now, NULL);\n        struct timespec timeout_abs;\n        timeout_abs.tv_sec = now.tv_sec + static_cast<long>( floor( timeout));\n        timeout_abs.tv_nsec\n            = 1000 * now.tv_usec + static_cast<long>( 1E9 * ( timeout - floor( timeout)));\n        if( timeout_abs.tv_nsec > 1000000000) {\n            timeout_abs.tv_sec  += 1;\n            timeout_abs.tv_nsec -= 1000000000;\n        }\n\n        bool timed_out = false;\n        pthread_mutex_lock( &m_mutex);\n        while( !m_signaled)\n        {\n            int result = pthread_cond_timedwait( &m_condvar, &m_mutex, &timeout_abs);\n            timed_out = result == ETIMEDOUT;\n            if( result != EINTR)\n                break;\n        }\n        m_signaled = false;\n        pthread_mutex_unlock( &m_mutex);\n        return timed_out;\n#else\n        DWORD timeout_ms = static_cast<DWORD>( 1000 * timeout);\n        DWORD result = WaitForSingleObject( m_handle, timeout_ms);\n        return result == WAIT_TIMEOUT;   \n#endif    \n    }\n\n    /// Signals the condition.\n    ///\n    /// This will wake up one thread waiting for the condition. It does not matter if the call to\n    /// #signal() or #wait() comes first.\n    ///\n    /// \\note If there are two or more calls to #signal() without a call to #wait() in between (and\n    /// no outstanding #wait() call), all calls to #signal() except the first one are ignored, i.e.,\n    /// calls to #signal() do not increment some counter, but just set a flag.\n    void signal()\n    {\n#ifndef MI_PLATFORM_WINDOWS\n        pthread_mutex_lock( &m_mutex);\n        m_signaled = true;\n        pthread_cond_signal( &m_condvar);\n        pthread_mutex_unlock( &m_mutex);\n#else\n        SetEvent( m_handle);\n#endif\n    }\n\n    /// Resets the condition.\n    ///\n    /// This will undo the effect of a #signal() call if there was no outstanding #wait() call.\n    void reset()\n    {\n#ifndef MI_PLATFORM_WINDOWS\n        pthread_mutex_lock( &m_mutex);\n        m_signaled = false;\n        pthread_mutex_unlock( &m_mutex);\n#else\n        ResetEvent( m_handle);\n#endif\n    }\n\nprivate:\n#ifndef MI_PLATFORM_WINDOWS\n    /// The mutex to be used to protect the m_signaled variable.\n    pthread_mutex_t m_mutex;\n    /// The condition used to let the thread sleep.\n    pthread_cond_t m_condvar;\n    /// A variable storing the signaled state.\n    bool m_signaled;\n#else\n    /// The event handle\n    HANDLE m_handle;\n#endif\n};\n\n/*@}*/ // end group mi_base_threads\n\n} // namespace base\n\n} // namespace mi\n\n#endif // MI_BASE_CONDITION_H\n\n", "comment_ratio": 0.22023809523809523}
{"lang": "c", "code": "/*  Overworld Trigger\r\n *\r\n *  From: https://github.com/PokemonAutomation/Arduino-Source\r\n *\r\n */\r\n\r\n#ifndef PokemonAutomation_PokemonBDSP_OverworldTrigger_H\r\n#define PokemonAutomation_PokemonBDSP_OverworldTrigger_H\r\n\r\n#include \"CommonFramework/Options/BatchOption/GroupOption.h\"\r\n#include \"CommonFramework/Options/EnumDropdownOption.h\"\r\n#include \"NintendoSwitch/Framework/NintendoSwitch_SingleSwitchProgram.h\"\r\n#include \"NintendoSwitch/Options/TimeExpressionOption.h\"\r\n#include \"CommonFramework/Tools/ConsoleHandle.h\"\r\n\r\nnamespace PokemonAutomation{\r\nnamespace NintendoSwitch{\r\nnamespace PokemonBDSP{\r\n\r\n//  Program component to trigger an overworld encounter.\r\nclass OverworldTrigger : public GroupOption{\r\npublic:\r\n    OverworldTrigger();\r\n\r\n    //  Move character back and forth or use Sweet Scent to trigger an encounter.\r\n    //  Return true if the start of a battle is detected.\r\n    //  Return false if an unexpected battle happens where the battle menu is detected but\r\n    //  not the starting animation.\r\n    //  Throw exception if inference times out after Sweet Scent is used.\r\n    bool find_encounter(SingleSwitchProgramEnvironment& env) const;\r\n\r\nprivate:\r\n    //  Move character up and down or left and right once.\r\n    void run_trigger(const BotBaseContext& context) const;\r\n\r\npublic:\r\n    EnumDropdownOption TRIGGER_METHOD;\r\n    TimeExpressionOption<uint16_t> MOVE_DURATION;\r\n    EnumDropdownOption SWEET_SCENT_POKEMON_LOCATION;\r\n};\r\n\r\n\r\n\r\n}\r\n}\r\n}\r\n#endif\r\n\n", "comment_ratio": 0.16666666666666666}
{"lang": "c", "code": "#ifndef _VDLIB_STATISTICS_H_\n#define _VDLIB_STATISTICS_H_\n\n#include <vdlib/Common.h>\n\nnamespace vdlib {\n\n// Return struct for Min-Max operations.\n// Stores computed minimum and maximum vertex values for each axis.\nclass MinMax\n{\npublic:\n\tvr::vec3f minValues;\n\tvr::vec3f maxValues;\n};\n\n// Main algorithms\nclass Statistics\n{\npublic:\n\t// Geometric mean of vertices.\n\t// Average equation:\n\t// Average = 1/n * SUM( all vertices )\n\tstatic void average( vr::vec3f& average, const float* vertices, int size );\n\n\t// Covariance around average parameter.\n\t// Elements of the Covariance matrix have the following closed form:\n\t// C[i][j] = 1/n * SUM( vm[i] * vm[j] )\n\t// m = average\n\t// vm = v - m\n\tstatic void covariance( float covariance[3][3], const vr::vec3f& average, const float* vertices, int size );\n\n\t// Computes the minimum and maximum vertex values, along each axis X, Y and Z.\n\tstatic void minMaxVertices( MinMax& result, const float* vertices, int size );\n\n\t// Computes the minimum and maximum vertex values along three specified axis, using center as reference point.\n\tstatic void axisMinMaxValues( MinMax& result, const vr::vec3f axis[3], const vr::vec3f& center, \n\t\t                          const float* vertices, int size );\n};\n\n} // namespace vdlib\n\n#endif // _VDLIB_STATISTICS_H_\n\n", "comment_ratio": 0.30612244897959184}
{"lang": "c", "code": "#ifndef PCB_H_INCLUDED\n#define PCB_H_INCLUDED\n\ntypedef struct cpu_context {\n\t// CPU state for the LC-3 processor\n\tunsigned int pc;\n\tunsigned int ir;\n\tunsigned int psr;\n\tunsigned int r0;\n\tunsigned int r1;\n\tunsigned int r2;\n\tunsigned int r3;\n\tunsigned int r4;\n\tunsigned int r5;\n\tunsigned int r6;\n\tunsigned int r7;\n} CPU_context_s;\t// _s means this is a structure definition\n\ntypedef CPU_context_s * CPU_context_p; // _p means that this is a pointer to structure\n\nenum state_type {NEW, READY, RUNNING, INTERRUPTED, WAITING, HALTED};\n\ntypedef struct pcb {\n\tunsigned int pid;\t//process identification\n\tenum state_type state;\t//process state (running waiting, etc.)\n\tunsigned int parent;\t// parent process pid\n\tunsigned char priority;\t// 0 is highest - 15 is lowest\n\tunsigned char * mem;\t// start of process in memory\n\tunsigned int size;\t// number of bytes in process\n\tunsigned char channel_no;\t// which I/O device or service Q\n\t// if process is blocked, which queue it is in\n\tCPU_context_p context;\t// set of cpu registers\n\t//other items to be added as needed\n} PCB_s;\n\ntypedef PCB_s * PCB_p;\n\n\nCPU_context_p context_new(void);\n\nPCB_p pcb_new(void);\n\nvoid pcb_init(PCB_p);\n\nvoid pcb_destroy(PCB_p);\n\nunsigned int pcb_get_pid(PCB_p);\n\nvoid pcb_assign_pid(PCB_p);\n\nenum state_type pcb_get_state(PCB_p);\n\nvoid pcb_set_state(PCB_p, enum state_type);\n\nunsigned int pcb_get_parent(PCB_p);\n\nvoid pcb_set_parent(PCB_p, unsigned int);\n\nunsigned char pcb_get_priority(PCB_p);\n\nvoid pcb_set_priority(PCB_p, unsigned char);\n\nchar * pcb_to_string(PCB_p, char *);\n\nunsigned int pcb_get_pc(PCB_p);\n\n#endif\n\n", "comment_ratio": 0.19117647058823528}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n\n#import \"AFURLResponseSerialization.h\"\n#import \"AFURLRequestSerialization.h\"\n#import \"AFSecurityPolicy.h\"\n#import \"AFNetworkReachabilityManager.h\"\n\n/**\n `AFURLSessionManager` creates and manages an `NSURLSession` object based on a specified `NSURLSessionConfiguration` object, which conforms to `<NSURLSessionTaskDelegate>`, `<NSURLSessionDataDelegate>`, `<NSURLSessionDownloadDelegate>`, and `<NSURLSessionDelegate>`.\n \n ## Subclassing Notes\n \n This is the base class for `AFHTTPSessionManager`, which adds functionality specific to making HTTP requests. If you are looking to extend `AFURLSessionManager` specifically for HTTP, consider subclassing `AFHTTPSessionManager` instead.\n \n ## NSURLSession & NSURLSessionTask Delegate Methods\n \n `AFURLSessionManager` implements the following delegate methods:\n \n ### `NSURLSessionDelegate`\n \n - `URLSession:didBecomeInvalidWithError:`\n - `URLSession:didReceiveChallenge:completionHandler:`\n\n ### `NSURLSessionTaskDelegate`\n \n - `URLSession:willPerformHTTPRedirection:newRequest:completionHandler:`\n - `URLSession:task:didReceiveChallenge:completionHandler:`\n - `URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:`\n - `URLSession:task:didCompleteWithError:`\n\n ### `NSURLSessionDataDelegate`\n \n - `URLSession:dataTask:didReceiveResponse:completionHandler:`\n - `URLSession:dataTask:didBecomeDownloadTask:`\n - `URLSession:dataTask:didReceiveData:`\n - `URLSession:dataTask:willCacheResponse:completionHandler:`\n - `URLSessionDidFinishEventsForBackgroundURLSession:`\n\n ### `NSURLSessionDownloadDelegate`\n\n - `URLSession:downloadTask:didFinishDownloadingToURL:`\n - `URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesWritten:totalBytesExpectedToWrite:`\n - `URLSession:downloadTask:didResumeAtOffset:expectedTotalBytes:`\n \n If any of these methods are overridden in a subclass, they _must_ call the `super` implementation first.\n \n ## Network Reachability Monitoring\n\n Network reachability status and change monitoring is available through the `reachabilityManager` property. Applications may choose to monitor network reachability conditions in order to prevent or suspend any outbound requests. See `AFNetworkReachabilityManager` for more details.\n \n ## NSCoding Caveats\n \n - Encoded managers do not include any block properties. Be sure to set delegate callback blocks when using `-initWithCoder:` or `NSKeyedUnarchiver`.\n\n ## NSCopying Caveats\n\n - `-copy` and `-copyWithZone:` return a new manager with a new `NSURLSession` created from the configuration of the original.\n - Operation copies do not include any delegate callback blocks, as they often strongly captures a reference to `self`, which would otherwise have the unintuitive side-effect of pointing to the _original_ session manager when copied.\n */\n\n#if (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && __IPHONE_OS_VERSION_MIN_REQUIRED >= 70000) || (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED >= 1090)\n\n@interface AFURLSessionManager : NSObject <NSURLSessionDelegate, NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate, NSCoding, NSCopying>\n\n/**\n The managed session.\n */\n@property (readonly, nonatomic, strong) NSURLSession *session;\n\n/**\n The operation queue on which delegate callbacks are run.\n */\n@property (readonly, nonatomic, strong) NSOperationQueue *operationQueue;\n\n/**\n Responses sent from the server in data tasks created with `dataTaskWithRequest:success:failure:` and run using the `GET` / `POST` / et al. convenience methods are automatically validated and serialized by the response serializer. By default, this property is set to an instance of `AFJSONResponseSerializer`.\n\n @warning `responseSerializer` must not be `nil`.\n */\n@property (nonatomic, strong) id <AFURLResponseSerialization> responseSerializer;\n\n///-------------------------------\n/// @name Managing Security Policy\n///-------------------------------\n\n/**\n The security policy used by created request operations to evaluate server trust for secure connections. `AFURLSessionManager` uses the `defaultPolicy` unless otherwise specified.\n */\n@property (nonatomic, strong) AFSecurityPolicy *securityPolicy;\n\n///--------------------------------------\n/// @name Monitoring Network Reachability\n///--------------------------------------\n\n/**\n The network reachability manager. `AFURLSessionManager` uses the `sharedManager` by default.\n */\n@property (readonly, nonatomic, strong) AFNetworkReachabilityManager *reachabilityManager;\n\n///----------------------------\n/// @name Getting Session Tasks\n///----------------------------\n\n/**\n The data, upload, and download tasks currently run by the managed session.\n */\n@property (readonly, nonatomic, strong) NSArray *tasks;\n\n/**\n The data tasks currently run by the managed session.\n */\n@property (readonly, nonatomic, strong) NSArray *dataTasks;\n\n/**\n The upload tasks currently run by the managed session.\n */\n@property (readonly, nonatomic, strong) NSArray *uploadTasks;\n\n/**\n The download tasks currently run by the managed session.\n */\n@property (readonly, nonatomic, strong) NSArray *downloadTasks;\n\n///---------------------------------\n/// @name Managing Callback Queues\n///---------------------------------\n\n/**\n The dispatch queue for `completionBlock`. If `NULL` (default), the main queue is used.\n */\n@property (nonatomic, strong) dispatch_queue_t completionQueue;\n\n/**\n The dispatch group for `completionBlock`. If `NULL` (default), a private dispatch group is used.\n */\n@property (nonatomic, strong) dispatch_group_t completionGroup;\n\n///---------------------\n/// @name Initialization\n///---------------------\n\n/**\n Creates and returns a manager for a session created with the specified configuration. This is the designated initializer.\n \n @param configuration The configuration used to create the managed session.\n \n @return A manager for a newly-created session.\n */\n- (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration;\n\n/**\n Invalidates the managed session, optionally canceling pending tasks.\n \n @param cancelPendingTasks Whether or not to cancel pending tasks.\n */\n- (void)invalidateSessionCancelingTasks:(BOOL)cancelPendingTasks;\n\n///-------------------------\n/// @name Running Data Tasks\n///-------------------------\n\n/**\n Creates an `NSURLSessionDataTask` with the specified request.\n\n @param request The HTTP request for the request.\n @param completionHandler A block object to be executed when the task finishes. This block has no return value and takes three arguments: the server response, the response object created by that serializer, and the error that occurred, if any.\n */\n- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request\n                            completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler;\n\n///---------------------------\n/// @name Running Upload Tasks\n///---------------------------\n\n/**\n Creates an `NSURLSessionUploadTask` with the specified request for a local file.\n\n @param request The HTTP request for the request.\n @param fileURL A URL to the local file to be uploaded.\n @param progress A block object to be executed multiple times as data is uploaded. This block has no return value and takes three arguments: the number of bytes written since the last time the progress block was called, the total bytes written, and the total bytes expected to be written during the request, as initially determined by the length of the HTTP body.\n @param completionHandler A block object to be executed when the task finishes. This block has no return value and takes three arguments: the server response, the response object created by that serializer, and the error that occurred, if any.\n */\n- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request\n                                         fromFile:(NSURL *)fileURL\n                                         progress:(NSProgress * __autoreleasing *)progress\n                                completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler;\n\n/**\n Creates an `NSURLSessionUploadTask` with the specified request for an HTTP body.\n\n @param request The HTTP request for the request.\n @param bodyData A data object containing the HTTP body to be uploaded.\n @param progress A block object to be executed multiple times as data is uploaded. This block has no return value and takes three arguments: the number of bytes written since the last time the progress block was called, the total bytes written, and the total bytes expected to be written during the request, as initially determined by the length of the HTTP body.\n @param completionHandler A block object to be executed when the task finishes. This block has no return value and takes three arguments: the server response, the response object created by that serializer, and the error that occurred, if any.\n */\n- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request\n                                         fromData:(NSData *)bodyData\n                                         progress:(NSProgress * __autoreleasing *)progress\n                                completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler;\n\n/**\n Creates an `NSURLSessionUploadTask` with the specified streaming request.\n\n @param request The HTTP request for the request.\n @param progress A block object to be executed multiple times as data is uploaded. This block has no return value and takes three arguments: the number of bytes written since the last time the progress block was called, the total bytes written, and the total bytes expected to be written during the request, as initially determined by the length of the HTTP body.\n @param completionHandler A block object to be executed when the task finishes. This block has no return value and takes three arguments: the server response, the response object created by that serializer, and the error that occurred, if any.\n */\n- (NSURLSessionUploadTask *)uploadTaskWithStreamedRequest:(NSURLRequest *)request\n                                                 progress:(NSProgress * __autoreleasing *)progress\n                                        completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler;\n\n///-----------------------------\n/// @name Running Download Tasks\n///-----------------------------\n\n/**\n Creates an `NSURLSessionDownloadTask` with the specified request.\n\n @param request The HTTP request for the request.\n @param progress A block object to be executed multiple times as data is downloaded. This block has no return value and takes three arguments: the number of bytes read since the last time the progress block was called, the total bytes read, and the total bytes expected to be read from the server, as initially determined by the expected content size of the response object.\n @param destination A block object to be executed in order to determine the destination of the downloaded file. This block takes two arguments, the target path & the server response, and returns the desired file URL of the resulting download. The temporary file used during the download will be automatically deleted after being moved to the returned URL.\n @param completionHandler A block to be executed when a task finishes. This block has no return value and takes three arguments: the server response, the path of the downloaded file, and the error describing the network or parsing error that occurred, if any.\n */\n- (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request\n                                             progress:(NSProgress * __autoreleasing *)progress\n                                          destination:(NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination\n                                    completionHandler:(void (^)(NSURLResponse *response, NSURL *filePath, NSError *error))completionHandler;\n\n/**\n Creates an `NSURLSessionDownloadTask` with the specified resume data.\n\n @param resumeData The data used to resume downloading.\n @param progress A block object to be executed multiple times as data is downloaded. This block has no return value and takes three arguments: the number of bytes read since the last time the progress block was called, the total bytes read, and the total bytes expected to be read from the server, as initially determined by the expected content size of the response object.\n @param destination A block object to be executed in order to determine the destination of the downloaded file. This block takes two arguments, the target path & the server response, and returns the desired file URL of the resulting download. The temporary file used during the download will be automatically deleted after being moved to the returned URL.\n @param completionHandler A block to be executed when a task finishes. This block has no return value and takes three arguments: the server response, the path of the downloaded file, and the error describing the network or parsing error that occurred, if any.\n */\n- (NSURLSessionDownloadTask *)downloadTaskWithResumeData:(NSData *)resumeData\n                                                progress:(NSProgress * __autoreleasing *)progress\n                                             destination:(NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination\n                                       completionHandler:(void (^)(NSURLResponse *response, NSURL *filePath, NSError *error))completionHandler;\n\n///-----------------------------------------\n/// @name Setting Session Delegate Callbacks\n///-----------------------------------------\n\n/**\n Sets a block to be executed when the managed session becomes invalid, as handled by the `NSURLSessionDelegate` method `URLSession:didBecomeInvalidWithError:`.\n \n @param block A block object to be executed when the managed session becomes invalid. The block has no return value, and takes two arguments: the session, and the error related to the cause of invalidation.\n */\n- (void)setSessionDidBecomeInvalidBlock:(void (^)(NSURLSession *session, NSError *error))block;\n\n/**\n Sets a block to be executed when a connection level authentication challenge has occurred, as handled by the `NSURLSessionDelegate` method `URLSession:didReceiveChallenge:completionHandler:`.\n\n @param block A block object to be executed when a connection level authentication challenge has occurred. The block returns the disposition of the authentication challenge, and takes three arguments: the session, the authentication challenge, and a pointer to the credential that should be used to resolve the challenge.\n */\n- (void)setSessionDidReceiveAuthenticationChallengeBlock:(NSURLSessionAuthChallengeDisposition (^)(NSURLSession *session, NSURLAuthenticationChallenge *challenge, NSURLCredential * __autoreleasing *credential))block;\n\n///--------------------------------------\n/// @name Setting Task Delegate Callbacks\n///--------------------------------------\n\n/**\n Sets a block to be executed when an HTTP request is attempting to perform a redirection to a different URL, as handled by the `NSURLSessionTaskDelegate` method `URLSession:willPerformHTTPRedirection:newRequest:completionHandler:`.\n \n @param block A block object to be executed when an HTTP request is attempting to perform a redirection to a different URL. The block returns the request to be made for the redirection, and takes four arguments: the session, the task, the redirection response, and the request corresponding to the redirection response.\n */\n- (void)setTaskWillPerformHTTPRedirectionBlock:(NSURLRequest * (^)(NSURLSession *session, NSURLSessionTask *task, NSURLResponse *response, NSURLRequest *request))block;\n\n/**\n Sets a block to be executed when a session task has received a request specific authentication challenge, as handled by the `NSURLSessionTaskDelegate` method `URLSession:task:didReceiveChallenge:completionHandler:`.\n \n @param block A block object to be executed when a session task has received a request specific authentication challenge. The block returns the disposition of the authentication challenge, and takes four arguments: the session, the task, the authentication challenge, and a pointer to the credential that should be used to resolve the challenge.\n */\n- (void)setTaskDidReceiveAuthenticationChallengeBlock:(NSURLSessionAuthChallengeDisposition (^)(NSURLSession *session, NSURLSessionTask *task, NSURLAuthenticationChallenge *challenge, NSURLCredential * __autoreleasing *credential))block;\n\n/**\n Sets a block to be executed periodically to track upload progress, as handled by the `NSURLSessionTaskDelegate` method `URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:`.\n \n @param block A block object to be called when an undetermined number of bytes have been uploaded to the server. This block has no return value and takes five arguments: the session, the task, the number of bytes written since the last time the upload progress block was called, the total bytes written, and the total bytes expected to be written during the request, as initially determined by the length of the HTTP body. This block may be called multiple times, and will execute on the main thread.\n */\n- (void)setTaskDidSendBodyDataBlock:(void (^)(NSURLSession *session, NSURLSessionTask *task, int64_t bytesSent, int64_t totalBytesSent, int64_t totalBytesExpectedToSend))block;\n\n/**\n Sets a block to be executed as the last message related to a specific task, as handled by the `NSURLSessionTaskDelegate` method `URLSession:task:didCompleteWithError:`.\n \n @param block A block object to be executed when a session task is completed. The block has no return value, and takes three arguments: the session, the task, and any error that occurred in the process of executing the task.\n */\n- (void)setTaskDidCompleteBlock:(void (^)(NSURLSession *session, NSURLSessionTask *task, NSError *error))block;\n\n///-------------------------------------------\n/// @name Setting Data Task Delegate Callbacks\n///-------------------------------------------\n\n/**\n Sets a block to be executed when a data task has received a response, as handled by the `NSURLSessionDataDelegate` method `URLSession:dataTask:didReceiveResponse:completionHandler:`.\n\n @param block A block object to be executed when a data task has received a response. The block returns the disposition of the session response, and takes three arguments: the session, the data task, and the received response.\n */\n- (void)setDataTaskDidReceiveResponseBlock:(NSURLSessionResponseDisposition (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSURLResponse *response))block;\n\n/**\n Sets a block to be executed when a data task has become a download task, as handled by the `NSURLSessionDataDelegate` method `URLSession:dataTask:didBecomeDownloadTask:`.\n \n @param block A block object to be executed when a data task has become a download task. The block has no return value, and takes three arguments: the session, the data task, and the download task it has become.\n */\n- (void)setDataTaskDidBecomeDownloadTaskBlock:(void (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSURLSessionDownloadTask *downloadTask))block;\n\n/**\n Sets a block to be executed when a data task receives data, as handled by the `NSURLSessionDataDelegate` method `URLSession:dataTask:didReceiveData:`.\n \n @param block A block object to be called when an undetermined number of bytes have been downloaded from the server. This block has no return value and takes three arguments: the session, the data task, and the data received. This block may be called multiple times, and will execute on the session manager operation queue.\n */\n- (void)setDataTaskDidReceiveDataBlock:(void (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSData *data))block;\n\n/**\n Sets a block to be executed to determine the caching behavior of a data task, as handled by the `NSURLSessionDataDelegate` method `URLSession:dataTask:willCacheResponse:completionHandler:`.\n \n @param block A block object to be executed to determine the caching behavior of a data task. The block returns the response to cache, and takes three arguments: the session, the data task, and the proposed cached URL response.\n */\n- (void)setDataTaskWillCacheResponseBlock:(NSCachedURLResponse * (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSCachedURLResponse *proposedResponse))block;\n\n/**\n Sets a block to be executed once all messages enqueued for a session have been delivered, as handled by the `NSURLSessionDataDelegate` method `URLSessionDidFinishEventsForBackgroundURLSession:`.\n \n @param block A block object to be executed once all messages enqueued for a session have been delivered. The block has no return value and takes a single argument: the session.\n */\n- (void)setDidFinishEventsForBackgroundURLSessionBlock:(void (^)(NSURLSession *session))block;\n\n///-----------------------------------------------\n/// @name Setting Download Task Delegate Callbacks\n///-----------------------------------------------\n\n/**\n Sets a block to be executed when a download task has completed a download, as handled by the `NSURLSessionDownloadDelegate` method `URLSession:downloadTask:didFinishDownloadingToURL:`.\n \n @param block A block object to be executed when a download task has completed. The block returns the URL the download should be moved to, and takes three arguments: the session, the download task, and the temporary location of the downloaded file. If the file manager encounters an error while attempting to move the temporary file to the destination, an `AFURLSessionDownloadTaskDidFailToMoveFileNotification` will be posted, with the download task as its object, and the user info of the error.\n */\n- (void)setDownloadTaskDidFinishDownloadingBlock:(NSURL * (^)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, NSURL *location))block;\n\n/**\n Sets a block to be executed periodically to track download progress, as handled by the `NSURLSessionDownloadDelegate` method `URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesWritten:totalBytesExpectedToWrite:`.\n \n @param block A block object to be called when an undetermined number of bytes have been downloaded from the server. This block has no return value and takes five arguments: the session, the download task, the number of bytes read since the last time the download progress block was called, the total bytes read, and the total bytes expected to be read during the request, as initially determined by the expected content size of the `NSHTTPURLResponse` object. This block may be called multiple times, and will execute on the session manager operation queue.\n */\n- (void)setDownloadTaskDidWriteDataBlock:(void (^)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, int64_t bytesWritten, int64_t totalBytesWritten, int64_t totalBytesExpectedToWrite))block;\n\n/**\n Sets a block to be executed when a download task has been resumed, as handled by the `NSURLSessionDownloadDelegate` method `URLSession:downloadTask:didResumeAtOffset:expectedTotalBytes:`.\n \n @param block A block object to be executed when a download task has been resumed. The block has no return value and takes four arguments: the session, the download task, the file offset of the resumed download, and the total number of bytes expected to be downloaded.\n */\n- (void)setDownloadTaskDidResumeBlock:(void (^)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, int64_t fileOffset, int64_t expectedTotalBytes))block;\n\n@end\n\n#endif\n\n///--------------------\n/// @name Notifications\n///--------------------\n\n/**\n Posted when a task begins executing.\n */\nextern NSString * const AFNetworkingTaskDidStartNotification;\n\n/**\n Posted when a task finishes executing. Includes a userInfo dictionary with additional information about the task.\n */\nextern NSString * const AFNetworkingTaskDidFinishNotification;\n\n/**\n Posted when a task suspends its execution.\n */\nextern NSString * const AFNetworkingTaskDidSuspendNotification;\n\n/**\n Posted when a session is invalidated.\n */\nextern NSString * const AFURLSessionDidInvalidateNotification;\n\n/**\n Posted when a session download task encountered an error when moving the temporary download file to a specified destination.\n */\nextern NSString * const AFURLSessionDownloadTaskDidFailToMoveFileNotification;\n\n/**\n The raw response data of the task. Included in the userInfo dictionary of the `AFNetworkingTaskDidFinishNotification` if response data exists for the task.\n */\nextern NSString * const AFNetworkingTaskDidFinishResponseDataKey;\n\n/**\n The serialized response object of the task. Included in the userInfo dictionary of the `AFNetworkingTaskDidFinishNotification` if the response was serialized.\n */\nextern NSString * const AFNetworkingTaskDidFinishSerializedResponseKey;\n\n/**\n The response serializer used to serialize the response. Included in the userInfo dictionary of the `AFNetworkingTaskDidFinishNotification` if the task has an associated response serializer.\n */\nextern NSString * const AFNetworkingTaskDidFinishResponseSerializerKey;\n\n/**\n The file path associated with the download task. Included in the userInfo dictionary of the `AFNetworkingTaskDidFinishNotification` if an the response data has been stored directly to disk.\n */\nextern NSString * const AFNetworkingTaskDidFinishAssetPathKey;\n\n/**\n Any error associated with the task, or the serialization of the response. Included in the userInfo dictionary of the `AFNetworkingTaskDidFinishNotification` if an error exists.\n */\nextern NSString * const AFNetworkingTaskDidFinishErrorKey;\n\n", "comment_ratio": 0.13793103448275862}
{"lang": "c", "code": "#ifdef USB\n#include \"upnp_dbg.h\"\n#include \"upnp_osl.h\"\n#include \"upnp.h\"\n#include \"lanusbifcfgparams.h\"\n\nstatic VarTemplate StateVariables[] = {\n    { \"Enable\", \"1\", VAR_EVENTED|VAR_BOOL},\n    { \"Status\", \"\", VAR_EVENTED|VAR_STRING},\t\n    { \"MACAddress\", \"\", VAR_EVENTED|VAR_STRING},\t\n    { \"MACAddressControlEnabled\", \"\", VAR_EVENTED|VAR_BOOL },    \n    { \"Standard\",  \"\", VAR_EVENTED|VAR_STRING },\n    { \"BytesSent\", \"\", VAR_EVENTED|VAR_ULONG},\n    { \"Type\",  \"\", VAR_EVENTED|VAR_STRING },\n    { \"Rate\", \"\", VAR_EVENTED|VAR_STRING},    \n    { \"BytesReceived\", \"\", VAR_EVENTED|VAR_ULONG},\n    { \"PacketsSent\", \"\", VAR_EVENTED|VAR_ULONG},\n    { \"PacketsReceived\", \"\", VAR_EVENTED|VAR_ULONG},\n    { NULL }\n};\n\nstatic Action _GetInfo = {\n    \"GetInfo\", GetInfo,\n   (Param []) {\n        { \"NewEnable\", VAR_Enable, VAR_OUT},\n        { \"NewStatus\", VAR_Status, VAR_OUT},\t\n        { \"NewMACAddress\", VAR_MACAddress, VAR_OUT},\n        { \"NewMACAddressControlEnabled\",  VAR_MACAddressControlEnabled, VAR_OUT },\n        { \"NewStandard\", VAR_Standard, VAR_OUT },\n        { 0 }\n    }\n};\n\nstatic Action _GetStatistics = {\n    \"GetStatistics\", GetStatistics,\n   (Param []) {\n        { \"NewBytesSent\", VAR_BytesSent, VAR_OUT},\n        { \"NewBytesReceived\", VAR_BytesReceived, VAR_OUT},\n        { \"NewPacketsSent\", VAR_PacketsSent, VAR_OUT},\n        { \"NewPacketsReceived\",  VAR_PacketsReceived, VAR_OUT },\n        { 0 }\n    }\n};\n\nstatic Action _SetEnable = {\n    \"SetEnable\", SetUSBEnable,\n   (Param []) {\n        { \"NewEnable\", VAR_Enable, VAR_IN},\n        { 0 }\n    }\n};\n\nstatic PAction Actions[] = {\n    &_GetInfo,\n    &_GetStatistics,\n    &_SetEnable,\n    NULL\n};\n\nServiceTemplate Template_LANUSBInterfaceConfig = {\n    \"LANUSBInterfaceConfig:\",\n    NULL,\n    LANUSBIFCfg_GetVar,\n    NULL,   /* SVCXML */\n    ARRAYSIZE(StateVariables)-1, StateVariables,\n    Actions,\n    0,\n    \"urn:dslforum-org:serviceId:LANUSBInterfaceConfig\"\n};\n#endif\n\n\n", "comment_ratio": 0.15730337078651685}
{"lang": "c", "code": "/**********************************************************************************************/\n/* The MIT License                                                                            */\n/*                                                                                            */\n/* Copyright 2016-2017 Twitch Interactive, Inc. or its affiliates. All Rights Reserved.       */\n/*                                                                                            */\n/* Permission is hereby granted, free of charge, to any person obtaining a copy               */\n/* of this software and associated documentation files (the \"Software\"), to deal              */\n/* in the Software without restriction, including without limitation the rights               */\n/* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell                  */\n/* copies of the Software, and to permit persons to whom the Software is                      */\n/* furnished to do so, subject to the following conditions:                                   */\n/*                                                                                            */\n/* The above copyright notice and this permission notice shall be included in                 */\n/* all copies or substantial portions of the Software.                                        */\n/*                                                                                            */\n/* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR                 */\n/* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,                   */\n/* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE                */\n/* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER                     */\n/* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,              */\n/* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN                  */\n/* THE SOFTWARE.                                                                              */\n/**********************************************************************************************/\n\n#include \"eia608.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unistd.h>\n// all possible utf8 valies, including invalid ones\nvoid encode_utf8ish(int32_t in, char out[7])\n{\n    if (0 > in) {\n        out[0] = 0;\n        return;\n    }\n\n    // 0xxxxxxx, 7 bits\n    if (0x80 > in) {\n        out[0] = in;\n        out[1] = 0;\n        return;\n    }\n\n    // 110xxxxx   10xxxxxx, 11 bits\n    if (0x800 > in) {\n        out[0] = 0xC0 | ((in >> (6 * 1)) & 0x1F);\n        out[1] = 0x80 | ((in >> (6 * 0)) & 0x3F);\n        out[2] = 0;\n        return;\n    }\n\n    // 1110xxxx   10xxxxxx    10xxxxxx, 16 bits\n    if (0x10000 > in) {\n        out[0] = 0xE0 | ((in >> (6 * 2)) & 0x0F);\n        out[1] = 0x80 | ((in >> (6 * 1)) & 0x3F);\n        out[2] = 0x80 | ((in >> (6 * 0)) & 0x3F);\n        out[3] = 0;\n        return;\n    }\n\n    // 11110xxx   10xxxxxx    10xxxxxx    10xxxxxx, 21 bits\n    if (0x200000 > in) {\n        out[0] = 0xF0 | ((in >> (6 * 3)) & 0x07);\n        out[1] = 0x80 | ((in >> (6 * 2)) & 0x3F);\n        out[2] = 0x80 | ((in >> (6 * 1)) & 0x3F);\n        out[3] = 0x80 | ((in >> (6 * 0)) & 0x3F);\n        out[4] = 0;\n        return;\n    }\n\n    // 111110xx   10xxxxxx    10xxxxxx    10xxxxxx    10xxxxxx, 26 bits\n    if (0x4000000 > in) {\n        out[0] = 0xF8 | ((in >> (6 * 4)) & 0x03);\n        out[1] = 0x80 | ((in >> (6 * 3)) & 0x3F);\n        out[2] = 0x80 | ((in >> (6 * 2)) & 0x3F);\n        out[3] = 0x80 | ((in >> (6 * 1)) & 0x3F);\n        out[4] = 0x80 | ((in >> (6 * 0)) & 0x3F);\n        out[5] = 0;\n        return;\n    }\n\n    // 1111110x   10xxxxxx    10xxxxxx    10xxxxxx    10xxxxxx    10xxxxxx, 31 bits\n    if (0x80000000 > in) {\n        out[0] = 0xFC | ((in >> (6 * 5)) & 0x01);\n        out[1] = 0x80 | ((in >> (6 * 4)) & 0x3F);\n        out[2] = 0x80 | ((in >> (6 * 3)) & 0x3F);\n        out[3] = 0x80 | ((in >> (6 * 2)) & 0x3F);\n        out[4] = 0x80 | ((in >> (6 * 1)) & 0x3F);\n        out[5] = 0x80 | ((in >> (6 * 0)) & 0x3F);\n        out[6] = 0;\n        return;\n    }\n}\n\nvoid test_all_utf8()\n{\n    char s[7];\n    size_t size, count = 0;\n    uint16_t code1, code2;\n\n    for (int i = 0; i < 0x80000000; ++i) {\n        encode_utf8ish(i, &s[0]);\n        code1 = eia608_from_utf8((const char*)&s[0], 0, &size);\n\n        // code2 = eia608_from_utf8 ( (const char*) &s[0], 1, &size);\n        if (code1) {\n            ++count;\n            printf(\"%d: string: '%s' code: %04X\\n\", count, &s[0], code1);\n        }\n    }\n\n    // Count must be 177\n    // 176 charcters, pile we have two mapping for left quote mark\n}\n\n#define BIN \"%d%d%d%d%d%d%d%d %d%d%d%d%d%d%d%d\"\n#define BIND(D) ((D) >> 15) & 0x01, ((D) >> 14) & 0x01, ((D) >> 13) & 0x01, ((D) >> 12) & 0x01, ((D) >> 11) & 0x01, ((D) >> 10) & 0x01, ((D) >> 9) & 0x01, ((D) >> 8) & 0x01, ((D) >> 7) & 0x01, ((D) >> 6) & 0x01, ((D) >> 5) & 0x01, ((D) >> 4) & 0x01, ((D) >> 3) & 0x01, ((D) >> 2) & 0x01, ((D) >> 1) & 0x01, ((D) >> 0) & 0x01\n\nvoid print_bin(int n)\n{\n    int mask = 0x80;\n\n    for (int mask = 0x80; mask; mask >>= 1) {\n        printf(\"%s\", n & mask ? \"1\" : \"0\");\n    }\n\n    printf(\"\\n\");\n}\n\nvoid void_test_all_possible_code_words()\n{\n    for (int i = 0; i <= 0x3FFF; ++i) {\n        int16_t code = eia608_parity(((i << 1) & 0x7F00) | (i & 0x7F));\n\n        int count = eia608_cc_data_is_extended_data_service(code) + eia608_cc_data_is_basic_north_american_character(code) + eia608_cc_data_is_special_north_american_character(code) + eia608_cc_data_is_extended_western_european_character(code) + eia608_cc_data_is_nonwestern_norpak_character(code) + eia608_cc_data_is_row_preamble(code) + eia608_cc_data_is_control_command(code);\n\n        if (1 < count) {\n            printf(\"code 0x%04X matched >1\\n\", code & 0x7F7F);\n        }\n\n        // if (0 == count) {\n        //     printf (\"code 0x%04X not matched %d\\n\",eia608_strip_parity_bits (code), i);\n        // }\n    }\n}\n\nvoid print_charmap()\n{\n    for (int i = 0; i < EIA608_CHAR_COUNT; ++i) {\n        printf(\"%s\", eia608_char_map[i]);\n    }\n\n    printf(\"\\n\");\n}\n\nvoid dance()\n{\n    for (int i = 0; i < 100; ++i) {\n        const char* l = 0 == rand() % 2 ? EIA608_CHAR_BOX_DRAWINGS_LIGHT_UP_AND_RIGHT : EIA608_CHAR_BOX_DRAWINGS_LIGHT_DOWN_AND_RIGHT;\n        const char* r = 0 == rand() % 2 ? EIA608_CHAR_BOX_DRAWINGS_LIGHT_DOWN_AND_LEFT : EIA608_CHAR_BOX_DRAWINGS_LIGHT_UP_AND_LEFT;\n        printf(\"%s %s%s%s%s%s%s%s %s \", EIA608_CHAR_EIGHTH_NOTE, l, EIA608_CHAR_LEFT_PARENTHESIS, EIA608_CHAR_EM_DASH, EIA608_CHAR_LOW_LINE, EIA608_CHAR_EM_DASH,\n            EIA608_CHAR_RIGHT_PARENTHESIS, r, EIA608_CHAR_EIGHTH_NOTE);\n    }\n}\n\nint main(int argc, const char** arg)\n{\n    // print_charmap();\n    // // return 0;\n    // srand (time (0));\n    // // test_all_utf8();\n    // // void_test_all_possible_code_words();\n    // // return 0;\n    // // print_charmap();\n    // dance();\n    // return 0;\n    for (int i = 0; i <= 0x3FFF; ++i) {\n        uint16_t code1 = eia608_parity(((i << 1) & 0x7F00) | (i & 0x7F));\n\n        switch (eia608_cc_data_type(code1)) {\n        default:\n        case EIA608_CC_DATA_UNKNOWN:\n            // printf (\"Unknown code %04X\\n\",code);\n            break;\n\n        case EIA608_CC_DATA_CONTROL_COMMAND: {\n            int cc;\n            eia608_control_t cmd = eia608_parse_control(code1, &cc);\n            uint16_t code2 = eia608_control_command(cmd, cc);\n\n            if (code1 != code2) {\n                printf(BIN \" != \" BIN \" (0x%04x != 0x%04x) cc: %d\\n\", BIND(code1), BIND(code2), code1, code2, cc);\n            }\n        } break;\n\n        case EIA608_CC_DATA_BASIC_NORTH_AMERICAN_CHARACTER: {\n            char char1[5], char2[5];\n            int chan;\n            size_t size;\n\n            if (eia608_to_utf8(code1, &chan, &char1[0], &char2[0])) {\n                uint16_t code2 = eia608_from_utf8_2(&char1[0], &char2[0]);\n\n                // if the second char is invalid, mask it off, we will accept the first\n                if (0x80 < (code1 & 0x007F) || 0x20 > (code1 & 0x007F)) {\n                    code1 = (code1 & 0xFF00) | 0x0080;\n                }\n\n                if (code1 == code2) {\n                    // printf (\"%s \" BIN \" == \" BIN \" (0x%04x == 0x%04x)\\n\", &char1[0], BIND (code1), BIND (code2),code1,code2);\n                } else {\n                    printf(\"%s %s \" BIN \" != \" BIN \" (0x%04x != 0x%04x)\\n\", &char1[0], &char2[0], BIND(code1), BIND(code2), code1, code2);\n                }\n            }\n\n        } break;\n\n        case EIA608_CC_DATA_SPECIAL_NORTH_AMERICAN_CHARACTER:\n        case EIA608_CC_DATA_EXTENDED_WESTERN_EUROPEAN_CHARACTER: {\n            char char1[5], char2[5];\n            int chan;\n            size_t size;\n\n            if (eia608_to_utf8(code1, &chan, &char1[0], &char2[0])) {\n                uint16_t code2 = eia608_from_utf8(&char1[0], chan, &size);\n\n                if (code1 == code2) {\n                    // printf (\"%s \" BIN \" == \" BIN \" (0x%04x == 0x%04x)\\n\", &char1[0], BIND (code1), BIND (code2),code1,code2);\n                } else {\n                    printf(\"%s \" BIN \" != \" BIN \" (0x%04x != 0x%04x)\\n\", &char1[0], BIND(code1), BIND(code2), code1, code2);\n                }\n            }\n        } break;\n\n            // #define EIA608_CODE_ROW_PREAMBLE                        4\n            // #define EIA608_CODE_EXTENDED_DATA_SERVICE               5\n            // #define EIA608_CODE_CONTROL_COMMAND                     6\n        }\n    }\n\n    return 0;\n}\n\n//     for (uint16_t i  = 0 ; i < 0x4000; ++i) {\n//         int chan;\n//         char str[7];\n//         uint16_t code = ( (i<<1) &0x7F00) | (i & 0x007F);\n//\n//         if (eia608_to_utf8 (code,&chan,str)) {\n//             printf (\"code: 0x%04X  str: '%s'\\n\", code,str);\n//         }\n//     }\n//\n//     // for(int i = 0 ; i < cie608_char_count ; ++i)\n//     // {\n//     //     cie608_char_map[i]\n//     //\n//     // }\n//\n//\n//     for (int i = 0 ; i < 128 ; ++i) {\n//         // print_bin( B7( i ) );\n//         // print_bin( eia608_parity_table[i] );\n//         printf (\"%d  %d %d\\n\", i, 0x7F & eia608_parity_table[i], eia608_parity_table[i]);\n//         // if ( i != eia608_parity_table[i] )\n//         // {\n//         //   printf( \"ERROR\\n\" );\n//         //\n//         // }\n//     }\n//\n// }\n\n", "comment_ratio": 0.2116788321167883}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n#import \"TLUser.h\"\n\n@interface TLUserGroup : NSObject\n\n/// tag\n@property (nonatomic, assign) NSInteger tag;\n\n@property (nonatomic, strong) NSString *groupName;\n\n@property (nonatomic, strong) NSMutableArray *users;\n\n@property (nonatomic, assign, readonly) NSInteger count;\n\n- (id)initWithGroupName:(NSString *)groupName users:(NSMutableArray *)users;\n\n- (void)addObject:(id)anObject;\n\n- (id)objectAtIndex:(NSUInteger)index;\n\n@end\n\n", "comment_ratio": 0.26666666666666666}
{"lang": "c", "code": "#ifndef SRC_UTIL_MATH2_H_\n#define SRC_UTIL_MATH2_H_\n\n#include \"util/noexcept.h\"\n\ntemplate<typename T>\nstatic T\nmax(T a, T b) noexcept {\n    return a < b ? b : a;\n}\n\ntemplate<typename T>\nstatic T\nmin(T a, T b) noexcept {\n    return a < b ? a : b;\n}\n\ntemplate<typename T>\nstatic T\nbound(T value, T min, T max) noexcept {\n    if (value < min) {\n        return min;\n    }\n    else if (value > max) {\n        return max;\n    }\n    else {\n        return value;\n    }\n}\n\ntemplate<typename T>\nstatic T\nwrap(T min, T value, T max) noexcept {\n    while (value < min) {\n        value += max;\n    }\n    return value % max;\n}\n\n#endif  // SRC_UTIL_MATH2_H_\n\n", "comment_ratio": 0.2898550724637681}
{"lang": "c", "code": "//\n//  MUPaperBaseView.h\n//  AFNetworking\n//\n//  Created by Jekity on 2017/12/8.\n//\n\n#import <UIKit/UIKit.h>\n\n@interface MUPaperBaseView : UIView\n\n@property(nonatomic, assign)NSUInteger tabType;\n@property(nonatomic, strong)  UIScrollView *contentScollView;//\u5185\u5bb9\u89c6\u56fe\n@property(nonatomic, strong)  UIScrollView *tabbarScollView;\n@property(nonatomic, strong)  NSArray *titleArray;\n@property(nonatomic, strong)  NSArray *objectArray;\n@property (assign, nonatomic) CGFloat tabbarItemHeight; /**< TopTab\u9ad8\u5ea6 **/\n@property (strong, nonatomic) UIColor *underlineOrBlockColor; /**< \u4e0b\u5212\u7ebf\u6216\u6ed1\u5757\u989c\u8272 **/\n@property(nonatomic, strong)  UIColor *normalColor;\n@property(nonatomic, strong)  UIColor *highlightedColor;\n@property(nonatomic, assign)  CGFloat tabbarHeight;\n@property (assign, nonatomic) CGFloat blockHeight; /**< \u6ed1\u5757\u9ad8\u5ea6 **/\n@property (assign, nonatomic) BOOL autoFitTitleLine; /**< \u4e0b\u5212\u7ebf\u662f\u5426\u81ea\u9002\u5e94\u6807\u9898\u5bbd\u5ea6 **/\n@property (assign, nonatomic) CGFloat bottomLineHeight; /**< \u4e0b\u5212\u7ebf\u9ad8\u5ea6 **/\n@property (assign, nonatomic) CGFloat titlesFont; /**< \u6807\u9898\u5b57\u4f53\u5927\u5c0f **/\n@property (assign, nonatomic) CGFloat titleScale; /**< \u6807\u9898\u7f29\u653e\u6bd4\u4f8b **/\n@property (assign, nonatomic) NSInteger currentPageNumber; /**<  \u9875\u7801   **/\n@property (assign, nonatomic) BOOL slideEnabled; /**< \u5141\u8bb8\u4e0b\u65b9\u5de6\u53f3\u6ed1\u52a8 **/\n@property (assign, nonatomic) CGFloat cornerRadiusRatio; /**< \u6ed1\u5757\u5706\u89d2 **/\n@property (assign, nonatomic) BOOL fontSizeAutoFit; /**< \u6587\u5b57\u81ea\u9002\u5e94 > **/\n@property (assign, nonatomic) NSInteger defaultPage; /**< \u8bbe\u7f6e\u9ed8\u8ba4\u52a0\u8f7d\u7684\u754c\u9762 **/\n@property (assign, nonatomic) BOOL separationLineHidden;\n\n@property(nonatomic, copy)void (^changedBlock)(NSUInteger previous ,NSUInteger selcted);\n\n-(instancetype)initWithFrame:(CGRect)frame WithTopTabType:(NSInteger)type;\n\n@end\n\n", "comment_ratio": 0.1794871794871795}
{"lang": "c", "code": "#ifndef QUICHE_QUIC_CORE_CRYPTO_CHACHA20_POLY1305_TLS_ENCRYPTER_H_\n#define QUICHE_QUIC_CORE_CRYPTO_CHACHA20_POLY1305_TLS_ENCRYPTER_H_\n\n#include \"quic/core/crypto/chacha_base_encrypter.h\"\n#include \"quic/platform/api/quic_export.h\"\n\nnamespace quic {\n\n// A ChaCha20Poly1305Encrypter is a QuicEncrypter that implements the\n// AEAD_CHACHA20_POLY1305 algorithm specified in RFC 7539 for use in IETF QUIC.\n//\n// It uses an authentication tag of 16 bytes (128 bits). It uses a 12 byte IV\n// that is XOR'd with the packet number to compute the nonce.\nclass QUIC_EXPORT_PRIVATE ChaCha20Poly1305TlsEncrypter\n    : public ChaChaBaseEncrypter {\n public:\n  enum {\n    kAuthTagSize = 16,\n  };\n\n  ChaCha20Poly1305TlsEncrypter();\n  ChaCha20Poly1305TlsEncrypter(const ChaCha20Poly1305TlsEncrypter&) = delete;\n  ChaCha20Poly1305TlsEncrypter& operator=(const ChaCha20Poly1305TlsEncrypter&) =\n      delete;\n  ~ChaCha20Poly1305TlsEncrypter() override;\n\n  QuicPacketCount GetConfidentialityLimit() const override;\n};\n\n}  // namespace quic\n\n#endif  // QUICHE_QUIC_CORE_CRYPTO_CHACHA20_POLY1305_TLS_ENCRYPTER_H_\n\n", "comment_ratio": 0.2702702702702703}
{"lang": "c", "code": "#pragma once\n#import <FunSDK/JObject.h>\n\n#define JK_Tour \"Tour\" \nclass Tour : public JObject\n{\npublic:\n\tJIntObj\t\tId; //\u5de1\u822a\u70b9ID\n\tJStrObj\t\tName; //\u5de1\u822a\u70b9\u540d\u79f0\n\tJIntObj\t\tTime; //\u6bcf\u4e2a\u5de1\u822a\u70b9\u505c\u7559\u65f6\u95f4\n\npublic:\n    Tour(JObject *pParent = NULL, const char *szName = JK_Tour):\n    JObject(pParent,szName),\n\tId(this, \"Id\"),\n\tName(this, \"Name\"),\n\tTime(this, \"Time\"){\n\t};\n\n    ~Tour(void){};\n};\n\n", "comment_ratio": 0.13636363636363635}
{"lang": "c", "code": "#import \"OFMAdManager.h\"\n#import \"OFMInterstitialDelegate.h\"\n\nNS_ASSUME_NONNULL_BEGIN\n\nextern NSString *const kOFMInterstitialExtraAdSizeKey;//Supported by TT interstitial, defaults to ScreenWidth * ScreenHeight\n\n@interface OFMInterstitialAdManager : OFMAdManager\n-(void) showInterstitialWithPlacementID:(NSString*)placementID inViewController:(UIViewController*)viewController delegate:(id<OFMInterstitialDelegate>)delegate;\n-(void) showInterstitialWithPlacementID:(NSString*)placementID scene:(NSString*)scene inViewController:(UIViewController*)viewController delegate:(id<OFMInterstitialDelegate>)delegate;\n@end\n\nNS_ASSUME_NONNULL_END\n\n", "comment_ratio": 0.36363636363636365}
{"lang": "c", "code": "#line 1 \"/home/diego/Cooties-Attack/cooties/src/fonts/Font3x5.h\"\n#pragma once\n\n#include <Arduino.h>\n#include <Print.h>\n\nclass Font3x5 : public Print {\n    \n  public:\n\n    Font3x5(uint8_t lineSpacing = 8);   \n\n    virtual size_t write(uint8_t); // used by the Arduino Print class\n    void printChar(const char c, const int8_t x, int8_t y);\n    void setCursor(const int8_t x, const int8_t y);\n\n    void setTextColor(const uint8_t color);\n    void setHeight(const uint8_t color);\n    \n\n  private:\n\n    int8_t _cursorX;    // Default is 0.\n    int8_t _baseX;      // needed for linebreak.\n    int8_t _cursorY;    // Default is 0.\n\n    int8_t _textColor;  // BLACK == 0, everything else is WHITE. Default is WHITE.\n\n    uint8_t _letterSpacing;  // letterSpacing controls the distance between letters. Default is 1.\n    uint8_t _lineHeight;     // lineHeight controls the height between lines breakend by \\n. Default is 8.\n\n};\n\n", "comment_ratio": 0.21212121212121213}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n#import <ReactiveCocoa/ReactiveCocoa.h>\n\n@interface DRPReactiveCoreLocationManager : NSObject\n\n+ (instancetype)sharedLocationManager;\n\n// start updating location (might prompt for permission)\n- (void)startUpdatingLocation;\n\n// stop updating location\n- (void)stopUpdatingLocation;\n\n// get CLLocation when location changes\n- (RACSignal *)locationChangedSignal;\n\n// get NSNumber of current and future CLAuthorizationStatus values\n- (RACSignal *)authorizationChangedSignal;\n\n@end\n\n", "comment_ratio": 0.3793103448275862}
{"lang": "c", "code": "//\n//  NSObject+Factory.h\n//  AUULayout\n//\n//  Created by JyHu on 2017/4/23.\n//\n//\n\n#import <UIKit/UIKit.h>\n\n@interface NSObject (Factory)\n\n@end\n\n@interface UIView (Factory)\n\n+ (instancetype)generateView;\n\n@end\n\n@interface UILabel (Factory)\n\n+ (instancetype)generateWithTtile:(NSString *)title;\n+ (instancetype)generate;\n\n@end\n\n@interface NSArray (Factory)\n\n+ (NSArray *)mapNumber:(NSUInteger)num map:(id (^)(void))map;\n\n@end\n\n@interface UIColor (Factory)\n\n+ (UIColor *)generate;\n\n@end\n\n", "comment_ratio": 0.1794871794871795}
{"lang": "c", "code": "#pragma once\n\n#include \"base/AFSingleton.hpp\"\n#include \"base/AFMap.hpp\"\n#include \"interface/AFIPluginManager.h\"\n#include \"AFCDynLib.h\"\n\nnamespace ark\n{\n\n    class AFCPluginManager : public AFIPluginManager, public AFSingleton<AFCPluginManager>\n    {\n    public:\n        AFCPluginManager();\n\n        bool Init() override;\n        bool PostInit() override;\n        bool CheckConfig() override;\n        bool PreUpdate() override;\n        bool Update() override;\n        bool PreShut() override;\n        bool Shut() override;\n\n        //////////////////////////////////////////////////////////////////////////\n\n        void Register(AFIPlugin* pPlugin) override;\n        void Deregister(AFIPlugin* pPlugin) override;\n        //////////////////////////////////////////////////////////////////////////\n\n        AFIPlugin* FindPlugin(const std::string& strPluginName) override;\n\n        void AddModule(const std::string& strModuleName, AFIModule* pModule) override;\n        void RemoveModule(const std::string& strModuleName) override;\n        AFIModule* FindModule(const std::string& strModuleName) override;\n\n        const std::string& AppName() const override;\n        void SetAppName(const std::string& app_name) override;\n\n        int64_t GetNowTime() const override;\n\n        const std::string& GetResPath() const override;\n\n        void SetPluginConf(const std::string& strFileName) override;\n\n        void SetLogPath(const std::string& log_path) override;\n        const std::string& GetLogPath() const override;\n\n    protected:\n        bool LoadPluginConf();\n\n        //bool CreatePluginLogicThread(AFILogicThreadManager* logic_thread_manager, int thread_logic_id);\n\n        bool LoadPluginLibrary(const std::string& strPluginDLLName);\n        bool UnloadPluginLibrary(const std::string& plugin_name);\n\n    private:\n        //Current time(ms)\n        int64_t cur_time_{ 0 };\n        //plugin so/dll file path\n        std::string plugin_path_{};\n        //Resource path\n        std::string res_path_{};\n        //app.plugin file path\n        std::string plugin_conf_path_{};\n        //app name\n        std::string app_name_{};\n        //log output path\n        std::string log_path_{};\n        typedef void(*DLL_ENTRY_PLUGIN_FUNC)(AFIPluginManager* pm);\n        typedef void(*DLL_EXIT_PLUGIN_FUNC)(AFIPluginManager* pm);\n\n        std::map<std::string, bool> mxPluginNameMap;\n        std::vector<std::string> mxPluginNameVec; // order\n        AFMap<std::string, AFCDynLib> mxPluginLibMap;\n        AFMap<std::string, AFIPlugin> mxPluginInstanceMap;\n        AFMap<std::string, AFIModule> mxModuleInstanceMap;\n        std::vector<AFIModule*> mxModuleInstanceVec; // order\n    };\n\n}\n", "comment_ratio": 0.13}
{"lang": "c", "code": "#ifndef _CUSHION_H_\n#define _CUSHION_H_\n\n#include <string>\n#include <iostream>\n\n#include <cstdlib>\n#include <cstdio>\n#include <cmath>\n\n#include \"GeomUtils.h\"\n#include \"CollidingObject.h\"\n\nclass Cushion : public CollidingObject {\n\npublic:\n  // return velocity is REFLECTION_COEFF * incident velocity\n  static const FP REFLECTION_COEFF;\n\nprivate:\n  // A cushion is a straight line between\n  // two points 'start' and 'end'\n  // where we move from 'start' to 'end' going around\n  // the table in counterclockwise direction\n  //\n  // The cushion is represented by the equation\n  // r*end + (1-r)*start, where 0 <= r <= 1;\n  unsigned m_id;\n  LineSegment m_line;\n\npublic:\n  Cushion(const unsigned id, const Vec2& start, const Vec2& end)\n      : CollidingObject(), m_id(id), m_line(start, end) {}\n\n  const LineSegment& getLineSegment(void) const { return m_line; }\n\n  virtual bool isStationary() const { return true; }\n\n  // Collision Counter for Cushion and other stationary objects\n  // remains fixed\n  virtual unsigned collCounter() const { return 0; }\n\n  virtual unsigned getID() const { return m_id; }\n\n  virtual void incrCollCounter() {}\n\n  virtual void simulate(const Event& e);\n\n  virtual std::string str() const {\n\n    char s[256];\n    sprintf(s, \"[Cushion-%d, %s]\", m_id, m_line.str().c_str());\n    return s;\n  }\n};\n\n#endif // _CUSHION_H_\n\n", "comment_ratio": 0.14285714285714285}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n#import \"Tweet.h\"\n#import \"TTTAttributedLabel.h\"\n\n@interface TweetCell : UITableViewCell\n@property (weak, nonatomic) IBOutlet UIImageView *profileView;\n@property (weak, nonatomic) IBOutlet UILabel *profileName;\n@property (weak, nonatomic) IBOutlet TTTAttributedLabel *tweetContent;\n@property (strong, nonatomic) Tweet *tweet;\n@property (weak, nonatomic) IBOutlet UIButton *retweetButton;\n@property (weak, nonatomic) IBOutlet UIButton *favoriteButton;\n@property (weak, nonatomic) IBOutlet UIButton *shareButton;\n@property (weak, nonatomic) IBOutlet UILabel *dateCreated;\n@property (weak, nonatomic) IBOutlet UIButton *replyButton;\n@property (weak, nonatomic) IBOutlet UILabel *date;\n@property (weak, nonatomic) IBOutlet UILabel *screenName;\n@property (weak, nonatomic) IBOutlet UIImageView *embeddedImage;\n@property (weak, nonatomic) IBOutlet UITextView *testTextView;\n@property (weak, nonatomic) IBOutlet NSLayoutConstraint *heightConstraint;\n\n- (void)setTweet;\n\n@end\n\n", "comment_ratio": 0.21875}
{"lang": "c", "code": "#ifndef COMMON_MATHUTIL_H_\n#define COMMON_MATHUTIL_H_\n\n#include <math.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <algorithm>\n#include <limits>\n\n#include <anglebase/numerics/safe_math.h>\n\n#include \"common/debug.h\"\n#include \"common/platform.h\"\n\nnamespace angle\n{\nusing base::CheckedNumeric;\nusing base::IsValueInRangeForNumericType;\n}  // namespace angle\n\nnamespace gl\n{\n\nconst unsigned int Float32One   = 0x3F800000;\nconst unsigned short Float16One = 0x3C00;\n\ntemplate <typename T>\ninline constexpr bool isPow2(T x)\n{\n    static_assert(std::is_integral<T>::value, \"isPow2 must be called on an integer type.\");\n    return (x & (x - 1)) == 0 && (x != 0);\n}\n\ninline int log2(int x)\n{\n    int r = 0;\n    while ((x >> r) > 1)\n        r++;\n    return r;\n}\n\ninline unsigned int ceilPow2(unsigned int x)\n{\n    if (x != 0)\n        x--;\n    x |= x >> 1;\n    x |= x >> 2;\n    x |= x >> 4;\n    x |= x >> 8;\n    x |= x >> 16;\n    x++;\n\n    return x;\n}\n\ntemplate <typename DestT, typename SrcT>\ninline DestT clampCast(SrcT value)\n{\n    // For floating-point types with denormalization, min returns the minimum positive normalized\n    // value. To find the value that has no values less than it, use numeric_limits::lowest.\n    constexpr const long double destLo =\n        static_cast<long double>(std::numeric_limits<DestT>::lowest());\n    constexpr const long double destHi =\n        static_cast<long double>(std::numeric_limits<DestT>::max());\n    constexpr const long double srcLo =\n        static_cast<long double>(std::numeric_limits<SrcT>::lowest());\n    constexpr long double srcHi = static_cast<long double>(std::numeric_limits<SrcT>::max());\n\n    if (destHi < srcHi)\n    {\n        DestT destMax = std::numeric_limits<DestT>::max();\n        if (value >= static_cast<SrcT>(destMax))\n        {\n            return destMax;\n        }\n    }\n\n    if (destLo > srcLo)\n    {\n        DestT destLow = std::numeric_limits<DestT>::lowest();\n        if (value <= static_cast<SrcT>(destLow))\n        {\n            return destLow;\n        }\n    }\n\n    return static_cast<DestT>(value);\n}\n\n// Specialize clampCast for bool->int conversion to avoid MSVS 2015 performance warning when the max\n// value is casted to the source type.\ntemplate <>\ninline unsigned int clampCast(bool value)\n{\n    return static_cast<unsigned int>(value);\n}\n\ntemplate <>\ninline int clampCast(bool value)\n{\n    return static_cast<int>(value);\n}\n\ntemplate <typename T, typename MIN, typename MAX>\ninline T clamp(T x, MIN min, MAX max)\n{\n    // Since NaNs fail all comparison tests, a NaN value will default to min\n    return x > min ? (x > max ? max : x) : min;\n}\n\ninline float clamp01(float x)\n{\n    return clamp(x, 0.0f, 1.0f);\n}\n\ntemplate <const int n>\ninline unsigned int unorm(float x)\n{\n    const unsigned int max = 0xFFFFFFFF >> (32 - n);\n\n    if (x > 1)\n    {\n        return max;\n    }\n    else if (x < 0)\n    {\n        return 0;\n    }\n    else\n    {\n        return (unsigned int)(max * x + 0.5f);\n    }\n}\n\ninline bool supportsSSE2()\n{\n#if defined(ANGLE_USE_SSE)\n    static bool checked  = false;\n    static bool supports = false;\n\n    if (checked)\n    {\n        return supports;\n    }\n\n#    if defined(ANGLE_PLATFORM_WINDOWS) && !defined(_M_ARM) && !defined(_M_ARM64)\n    {\n        int info[4];\n        __cpuid(info, 0);\n\n        if (info[0] >= 1)\n        {\n            __cpuid(info, 1);\n\n            supports = (info[3] >> 26) & 1;\n        }\n    }\n#    endif  // defined(ANGLE_PLATFORM_WINDOWS) && !defined(_M_ARM) && !defined(_M_ARM64)\n    checked = true;\n    return supports;\n#else  // defined(ANGLE_USE_SSE)\n    return false;\n#endif\n}\n\ntemplate <typename destType, typename sourceType>\ndestType bitCast(const sourceType &source)\n{\n    size_t copySize = std::min(sizeof(destType), sizeof(sourceType));\n    destType output;\n    memcpy(&output, &source, copySize);\n    return output;\n}\n\n// https://stackoverflow.com/a/37581284\ntemplate <typename T>\nstatic constexpr double normalize(T value)\n{\n    return value < 0 ? -static_cast<double>(value) / std::numeric_limits<T>::min()\n                     : static_cast<double>(value) / std::numeric_limits<T>::max();\n}\n\ninline unsigned short float32ToFloat16(float fp32)\n{\n    unsigned int fp32i = bitCast<unsigned int>(fp32);\n    unsigned int sign  = (fp32i & 0x80000000) >> 16;\n    unsigned int abs   = fp32i & 0x7FFFFFFF;\n\n    if (abs > 0x7F800000)\n    {  // NaN\n        return 0x7FFF;\n    }\n    else if (abs > 0x47FFEFFF)\n    {  // Infinity\n        return static_cast<uint16_t>(sign | 0x7C00);\n    }\n    else if (abs < 0x38800000)  // Denormal\n    {\n        unsigned int mantissa = (abs & 0x007FFFFF) | 0x00800000;\n        int e                 = 113 - (abs >> 23);\n\n        if (e < 24)\n        {\n            abs = mantissa >> e;\n        }\n        else\n        {\n            abs = 0;\n        }\n\n        return static_cast<unsigned short>(sign | (abs + 0x00000FFF + ((abs >> 13) & 1)) >> 13);\n    }\n    else\n    {\n        return static_cast<unsigned short>(\n            sign | (abs + 0xC8000000 + 0x00000FFF + ((abs >> 13) & 1)) >> 13);\n    }\n}\n\nfloat float16ToFloat32(unsigned short h);\n\nunsigned int convertRGBFloatsTo999E5(float red, float green, float blue);\nvoid convert999E5toRGBFloats(unsigned int input, float *red, float *green, float *blue);\n\ninline unsigned short float32ToFloat11(float fp32)\n{\n    const unsigned int float32MantissaMask     = 0x7FFFFF;\n    const unsigned int float32ExponentMask     = 0x7F800000;\n    const unsigned int float32SignMask         = 0x80000000;\n    const unsigned int float32ValueMask        = ~float32SignMask;\n    const unsigned int float32ExponentFirstBit = 23;\n    const unsigned int float32ExponentBias     = 127;\n\n    const unsigned short float11Max          = 0x7BF;\n    const unsigned short float11MantissaMask = 0x3F;\n    const unsigned short float11ExponentMask = 0x7C0;\n    const unsigned short float11BitMask      = 0x7FF;\n    const unsigned int float11ExponentBias   = 14;\n\n    const unsigned int float32Maxfloat11 = 0x477E0000;\n    const unsigned int float32Minfloat11 = 0x38800000;\n\n    const unsigned int float32Bits = bitCast<unsigned int>(fp32);\n    const bool float32Sign         = (float32Bits & float32SignMask) == float32SignMask;\n\n    unsigned int float32Val = float32Bits & float32ValueMask;\n\n    if ((float32Val & float32ExponentMask) == float32ExponentMask)\n    {\n        // INF or NAN\n        if ((float32Val & float32MantissaMask) != 0)\n        {\n            return float11ExponentMask |\n                   (((float32Val >> 17) | (float32Val >> 11) | (float32Val >> 6) | (float32Val)) &\n                    float11MantissaMask);\n        }\n        else if (float32Sign)\n        {\n            // -INF is clamped to 0 since float11 is positive only\n            return 0;\n        }\n        else\n        {\n            return float11ExponentMask;\n        }\n    }\n    else if (float32Sign)\n    {\n        // float11 is positive only, so clamp to zero\n        return 0;\n    }\n    else if (float32Val > float32Maxfloat11)\n    {\n        // The number is too large to be represented as a float11, set to max\n        return float11Max;\n    }\n    else\n    {\n        if (float32Val < float32Minfloat11)\n        {\n            // The number is too small to be represented as a normalized float11\n            // Convert it to a denormalized value.\n            const unsigned int shift = (float32ExponentBias - float11ExponentBias) -\n                                       (float32Val >> float32ExponentFirstBit);\n            float32Val =\n                ((1 << float32ExponentFirstBit) | (float32Val & float32MantissaMask)) >> shift;\n        }\n        else\n        {\n            // Rebias the exponent to represent the value as a normalized float11\n            float32Val += 0xC8000000;\n        }\n\n        return ((float32Val + 0xFFFF + ((float32Val >> 17) & 1)) >> 17) & float11BitMask;\n    }\n}\n\ninline unsigned short float32ToFloat10(float fp32)\n{\n    const unsigned int float32MantissaMask     = 0x7FFFFF;\n    const unsigned int float32ExponentMask     = 0x7F800000;\n    const unsigned int float32SignMask         = 0x80000000;\n    const unsigned int float32ValueMask        = ~float32SignMask;\n    const unsigned int float32ExponentFirstBit = 23;\n    const unsigned int float32ExponentBias     = 127;\n\n    const unsigned short float10Max          = 0x3DF;\n    const unsigned short float10MantissaMask = 0x1F;\n    const unsigned short float10ExponentMask = 0x3E0;\n    const unsigned short float10BitMask      = 0x3FF;\n    const unsigned int float10ExponentBias   = 14;\n\n    const unsigned int float32Maxfloat10 = 0x477C0000;\n    const unsigned int float32Minfloat10 = 0x38800000;\n\n    const unsigned int float32Bits = bitCast<unsigned int>(fp32);\n    const bool float32Sign         = (float32Bits & float32SignMask) == float32SignMask;\n\n    unsigned int float32Val = float32Bits & float32ValueMask;\n\n    if ((float32Val & float32ExponentMask) == float32ExponentMask)\n    {\n        // INF or NAN\n        if ((float32Val & float32MantissaMask) != 0)\n        {\n            return float10ExponentMask |\n                   (((float32Val >> 18) | (float32Val >> 13) | (float32Val >> 3) | (float32Val)) &\n                    float10MantissaMask);\n        }\n        else if (float32Sign)\n        {\n            // -INF is clamped to 0 since float11 is positive only\n            return 0;\n        }\n        else\n        {\n            return float10ExponentMask;\n        }\n    }\n    else if (float32Sign)\n    {\n        // float10 is positive only, so clamp to zero\n        return 0;\n    }\n    else if (float32Val > float32Maxfloat10)\n    {\n        // The number is too large to be represented as a float11, set to max\n        return float10Max;\n    }\n    else\n    {\n        if (float32Val < float32Minfloat10)\n        {\n            // The number is too small to be represented as a normalized float11\n            // Convert it to a denormalized value.\n            const unsigned int shift = (float32ExponentBias - float10ExponentBias) -\n                                       (float32Val >> float32ExponentFirstBit);\n            float32Val =\n                ((1 << float32ExponentFirstBit) | (float32Val & float32MantissaMask)) >> shift;\n        }\n        else\n        {\n            // Rebias the exponent to represent the value as a normalized float11\n            float32Val += 0xC8000000;\n        }\n\n        return ((float32Val + 0x1FFFF + ((float32Val >> 18) & 1)) >> 18) & float10BitMask;\n    }\n}\n\ninline float float11ToFloat32(unsigned short fp11)\n{\n    unsigned short exponent = (fp11 >> 6) & 0x1F;\n    unsigned short mantissa = fp11 & 0x3F;\n\n    if (exponent == 0x1F)\n    {\n        // INF or NAN\n        return bitCast<float>(0x7f800000 | (mantissa << 17));\n    }\n    else\n    {\n        if (exponent != 0)\n        {\n            // normalized\n        }\n        else if (mantissa != 0)\n        {\n            // The value is denormalized\n            exponent = 1;\n\n            do\n            {\n                exponent--;\n                mantissa <<= 1;\n            } while ((mantissa & 0x40) == 0);\n\n            mantissa = mantissa & 0x3F;\n        }\n        else  // The value is zero\n        {\n            exponent = static_cast<unsigned short>(-112);\n        }\n\n        return bitCast<float>(((exponent + 112) << 23) | (mantissa << 17));\n    }\n}\n\ninline float float10ToFloat32(unsigned short fp11)\n{\n    unsigned short exponent = (fp11 >> 5) & 0x1F;\n    unsigned short mantissa = fp11 & 0x1F;\n\n    if (exponent == 0x1F)\n    {\n        // INF or NAN\n        return bitCast<float>(0x7f800000 | (mantissa << 17));\n    }\n    else\n    {\n        if (exponent != 0)\n        {\n            // normalized\n        }\n        else if (mantissa != 0)\n        {\n            // The value is denormalized\n            exponent = 1;\n\n            do\n            {\n                exponent--;\n                mantissa <<= 1;\n            } while ((mantissa & 0x20) == 0);\n\n            mantissa = mantissa & 0x1F;\n        }\n        else  // The value is zero\n        {\n            exponent = static_cast<unsigned short>(-112);\n        }\n\n        return bitCast<float>(((exponent + 112) << 23) | (mantissa << 18));\n    }\n}\n\n// Convers to and from float and 16.16 fixed point format.\n\ninline float ConvertFixedToFloat(uint32_t fixedInput)\n{\n    return static_cast<float>(fixedInput) / 65536.0f;\n}\n\ninline uint32_t ConvertFloatToFixed(float floatInput)\n{\n    static constexpr uint32_t kHighest = 32767 * 65536 + 65535;\n    static constexpr uint32_t kLowest  = static_cast<uint32_t>(-32768 * 65536 + 65535);\n\n    if (floatInput > 32767.65535)\n    {\n        return kHighest;\n    }\n    else if (floatInput < -32768.65535)\n    {\n        return kLowest;\n    }\n    else\n    {\n        return static_cast<uint32_t>(floatInput * 65536);\n    }\n}\n\ntemplate <typename T>\ninline float normalizedToFloat(T input)\n{\n    static_assert(std::numeric_limits<T>::is_integer, \"T must be an integer.\");\n\n    if (sizeof(T) > 2)\n    {\n        // float has only a 23 bit mantissa, so we need to do the calculation in double precision\n        constexpr double inverseMax = 1.0 / std::numeric_limits<T>::max();\n        return static_cast<float>(input * inverseMax);\n    }\n    else\n    {\n        constexpr float inverseMax = 1.0f / std::numeric_limits<T>::max();\n        return input * inverseMax;\n    }\n}\n\ntemplate <unsigned int inputBitCount, typename T>\ninline float normalizedToFloat(T input)\n{\n    static_assert(std::numeric_limits<T>::is_integer, \"T must be an integer.\");\n    static_assert(inputBitCount < (sizeof(T) * 8), \"T must have more bits than inputBitCount.\");\n\n    if (inputBitCount > 23)\n    {\n        // float has only a 23 bit mantissa, so we need to do the calculation in double precision\n        constexpr double inverseMax = 1.0 / ((1 << inputBitCount) - 1);\n        return static_cast<float>(input * inverseMax);\n    }\n    else\n    {\n        constexpr float inverseMax = 1.0f / ((1 << inputBitCount) - 1);\n        return input * inverseMax;\n    }\n}\n\ntemplate <typename T>\ninline T floatToNormalized(float input)\n{\n    if (sizeof(T) > 2)\n    {\n        // float has only a 23 bit mantissa, so we need to do the calculation in double precision\n        return static_cast<T>(std::numeric_limits<T>::max() * static_cast<double>(input) + 0.5);\n    }\n    else\n    {\n        return static_cast<T>(std::numeric_limits<T>::max() * input + 0.5f);\n    }\n}\n\ntemplate <unsigned int outputBitCount, typename T>\ninline T floatToNormalized(float input)\n{\n    static_assert(outputBitCount < (sizeof(T) * 8), \"T must have more bits than outputBitCount.\");\n\n    if (outputBitCount > 23)\n    {\n        // float has only a 23 bit mantissa, so we need to do the calculation in double precision\n        return static_cast<T>(((1 << outputBitCount) - 1) * static_cast<double>(input) + 0.5);\n    }\n    else\n    {\n        return static_cast<T>(((1 << outputBitCount) - 1) * input + 0.5f);\n    }\n}\n\ntemplate <unsigned int inputBitCount, unsigned int inputBitStart, typename T>\ninline T getShiftedData(T input)\n{\n    static_assert(inputBitCount + inputBitStart <= (sizeof(T) * 8),\n                  \"T must have at least as many bits as inputBitCount + inputBitStart.\");\n    const T mask = (1 << inputBitCount) - 1;\n    return (input >> inputBitStart) & mask;\n}\n\ntemplate <unsigned int inputBitCount, unsigned int inputBitStart, typename T>\ninline T shiftData(T input)\n{\n    static_assert(inputBitCount + inputBitStart <= (sizeof(T) * 8),\n                  \"T must have at least as many bits as inputBitCount + inputBitStart.\");\n    const T mask = (1 << inputBitCount) - 1;\n    return (input & mask) << inputBitStart;\n}\n\ninline unsigned int CountLeadingZeros(uint32_t x)\n{\n    // Use binary search to find the amount of leading zeros.\n    unsigned int zeros = 32u;\n    uint32_t y;\n\n    y = x >> 16u;\n    if (y != 0)\n    {\n        zeros = zeros - 16u;\n        x     = y;\n    }\n    y = x >> 8u;\n    if (y != 0)\n    {\n        zeros = zeros - 8u;\n        x     = y;\n    }\n    y = x >> 4u;\n    if (y != 0)\n    {\n        zeros = zeros - 4u;\n        x     = y;\n    }\n    y = x >> 2u;\n    if (y != 0)\n    {\n        zeros = zeros - 2u;\n        x     = y;\n    }\n    y = x >> 1u;\n    if (y != 0)\n    {\n        return zeros - 2u;\n    }\n    return zeros - x;\n}\n\ninline unsigned char average(unsigned char a, unsigned char b)\n{\n    return ((a ^ b) >> 1) + (a & b);\n}\n\ninline signed char average(signed char a, signed char b)\n{\n    return ((short)a + (short)b) / 2;\n}\n\ninline unsigned short average(unsigned short a, unsigned short b)\n{\n    return ((a ^ b) >> 1) + (a & b);\n}\n\ninline signed short average(signed short a, signed short b)\n{\n    return ((int)a + (int)b) / 2;\n}\n\ninline unsigned int average(unsigned int a, unsigned int b)\n{\n    return ((a ^ b) >> 1) + (a & b);\n}\n\ninline int average(int a, int b)\n{\n    long long average = (static_cast<long long>(a) + static_cast<long long>(b)) / 2ll;\n    return static_cast<int>(average);\n}\n\ninline float average(float a, float b)\n{\n    return (a + b) * 0.5f;\n}\n\ninline unsigned short averageHalfFloat(unsigned short a, unsigned short b)\n{\n    return float32ToFloat16((float16ToFloat32(a) + float16ToFloat32(b)) * 0.5f);\n}\n\ninline unsigned int averageFloat11(unsigned int a, unsigned int b)\n{\n    return float32ToFloat11((float11ToFloat32(static_cast<unsigned short>(a)) +\n                             float11ToFloat32(static_cast<unsigned short>(b))) *\n                            0.5f);\n}\n\ninline unsigned int averageFloat10(unsigned int a, unsigned int b)\n{\n    return float32ToFloat10((float10ToFloat32(static_cast<unsigned short>(a)) +\n                             float10ToFloat32(static_cast<unsigned short>(b))) *\n                            0.5f);\n}\n\ntemplate <typename T>\nclass Range\n{\n  public:\n    Range() {}\n    Range(T lo, T hi) : mLow(lo), mHigh(hi) {}\n\n    T length() const { return (empty() ? 0 : (mHigh - mLow)); }\n\n    bool intersects(Range<T> other)\n    {\n        if (mLow <= other.mLow)\n        {\n            return other.mLow < mHigh;\n        }\n        else\n        {\n            return mLow < other.mHigh;\n        }\n    }\n\n    // Assumes that end is non-inclusive.. for example, extending to 5 will make \"end\" 6.\n    void extend(T value)\n    {\n        mLow  = value < mLow ? value : mLow;\n        mHigh = value >= mHigh ? (value + 1) : mHigh;\n    }\n\n    bool empty() const { return mHigh <= mLow; }\n\n    bool contains(T value) const { return value >= mLow && value < mHigh; }\n\n    class Iterator final\n    {\n      public:\n        Iterator(T value) : mCurrent(value) {}\n\n        Iterator &operator++()\n        {\n            mCurrent++;\n            return *this;\n        }\n        bool operator==(const Iterator &other) const { return mCurrent == other.mCurrent; }\n        bool operator!=(const Iterator &other) const { return mCurrent != other.mCurrent; }\n        T operator*() const { return mCurrent; }\n\n      private:\n        T mCurrent;\n    };\n\n    Iterator begin() const { return Iterator(mLow); }\n\n    Iterator end() const { return Iterator(mHigh); }\n\n    T low() const { return mLow; }\n    T high() const { return mHigh; }\n\n    void invalidate()\n    {\n        mLow  = std::numeric_limits<T>::max();\n        mHigh = std::numeric_limits<T>::min();\n    }\n\n  private:\n    T mLow;\n    T mHigh;\n};\n\ntypedef Range<int> RangeI;\ntypedef Range<unsigned int> RangeUI;\n\nstruct IndexRange\n{\n    struct Undefined\n    {};\n    IndexRange(Undefined) {}\n    IndexRange() : IndexRange(0, 0, 0) {}\n    IndexRange(size_t start_, size_t end_, size_t vertexIndexCount_)\n        : start(start_), end(end_), vertexIndexCount(vertexIndexCount_)\n    {\n        ASSERT(start <= end);\n    }\n\n    // Number of vertices in the range.\n    size_t vertexCount() const { return (end - start) + 1; }\n\n    // Inclusive range of indices that are not primitive restart\n    size_t start;\n    size_t end;\n\n    // Number of non-primitive restart indices\n    size_t vertexIndexCount;\n};\n\n// Combine a floating-point value representing a mantissa (x) and an integer exponent (exp) into a\n// floating-point value. As in GLSL ldexp() built-in.\ninline float Ldexp(float x, int exp)\n{\n    if (exp > 128)\n    {\n        return std::numeric_limits<float>::infinity();\n    }\n    if (exp < -126)\n    {\n        return 0.0f;\n    }\n    double result = static_cast<double>(x) * std::pow(2.0, static_cast<double>(exp));\n    return static_cast<float>(result);\n}\n\n// First, both normalized floating-point values are converted into 16-bit integer values.\n// Then, the results are packed into the returned 32-bit unsigned integer.\n// The first float value will be written to the least significant bits of the output;\n// the last float value will be written to the most significant bits.\n// The conversion of each value to fixed point is done as follows :\n// packSnorm2x16 : round(clamp(c, -1, +1) * 32767.0)\ninline uint32_t packSnorm2x16(float f1, float f2)\n{\n    int16_t leastSignificantBits = static_cast<int16_t>(roundf(clamp(f1, -1.0f, 1.0f) * 32767.0f));\n    int16_t mostSignificantBits  = static_cast<int16_t>(roundf(clamp(f2, -1.0f, 1.0f) * 32767.0f));\n    return static_cast<uint32_t>(mostSignificantBits) << 16 |\n           (static_cast<uint32_t>(leastSignificantBits) & 0xFFFF);\n}\n\n// First, unpacks a single 32-bit unsigned integer u into a pair of 16-bit unsigned integers. Then,\n// each component is converted to a normalized floating-point value to generate the returned two\n// float values. The first float value will be extracted from the least significant bits of the\n// input; the last float value will be extracted from the most-significant bits. The conversion for\n// unpacked fixed-point value to floating point is done as follows: unpackSnorm2x16 : clamp(f /\n// 32767.0, -1, +1)\ninline void unpackSnorm2x16(uint32_t u, float *f1, float *f2)\n{\n    int16_t leastSignificantBits = static_cast<int16_t>(u & 0xFFFF);\n    int16_t mostSignificantBits  = static_cast<int16_t>(u >> 16);\n    *f1 = clamp(static_cast<float>(leastSignificantBits) / 32767.0f, -1.0f, 1.0f);\n    *f2 = clamp(static_cast<float>(mostSignificantBits) / 32767.0f, -1.0f, 1.0f);\n}\n\n// First, both normalized floating-point values are converted into 16-bit integer values.\n// Then, the results are packed into the returned 32-bit unsigned integer.\n// The first float value will be written to the least significant bits of the output;\n// the last float value will be written to the most significant bits.\n// The conversion of each value to fixed point is done as follows:\n// packUnorm2x16 : round(clamp(c, 0, +1) * 65535.0)\ninline uint32_t packUnorm2x16(float f1, float f2)\n{\n    uint16_t leastSignificantBits = static_cast<uint16_t>(roundf(clamp(f1, 0.0f, 1.0f) * 65535.0f));\n    uint16_t mostSignificantBits  = static_cast<uint16_t>(roundf(clamp(f2, 0.0f, 1.0f) * 65535.0f));\n    return static_cast<uint32_t>(mostSignificantBits) << 16 |\n           static_cast<uint32_t>(leastSignificantBits);\n}\n\n// First, unpacks a single 32-bit unsigned integer u into a pair of 16-bit unsigned integers. Then,\n// each component is converted to a normalized floating-point value to generate the returned two\n// float values. The first float value will be extracted from the least significant bits of the\n// input; the last float value will be extracted from the most-significant bits. The conversion for\n// unpacked fixed-point value to floating point is done as follows: unpackUnorm2x16 : f / 65535.0\ninline void unpackUnorm2x16(uint32_t u, float *f1, float *f2)\n{\n    uint16_t leastSignificantBits = static_cast<uint16_t>(u & 0xFFFF);\n    uint16_t mostSignificantBits  = static_cast<uint16_t>(u >> 16);\n    *f1                           = static_cast<float>(leastSignificantBits) / 65535.0f;\n    *f2                           = static_cast<float>(mostSignificantBits) / 65535.0f;\n}\n\n// Helper functions intended to be used only here.\nnamespace priv\n{\n\ninline uint8_t ToPackedUnorm8(float f)\n{\n    return static_cast<uint8_t>(roundf(clamp(f, 0.0f, 1.0f) * 255.0f));\n}\n\ninline int8_t ToPackedSnorm8(float f)\n{\n    return static_cast<int8_t>(roundf(clamp(f, -1.0f, 1.0f) * 127.0f));\n}\n\n}  // namespace priv\n\n// Packs 4 normalized unsigned floating-point values to a single 32-bit unsigned integer. Works\n// similarly to packUnorm2x16. The floats are clamped to the range 0.0 to 1.0, and written to the\n// unsigned integer starting from the least significant bits.\ninline uint32_t PackUnorm4x8(float f1, float f2, float f3, float f4)\n{\n    uint8_t bits[4];\n    bits[0]         = priv::ToPackedUnorm8(f1);\n    bits[1]         = priv::ToPackedUnorm8(f2);\n    bits[2]         = priv::ToPackedUnorm8(f3);\n    bits[3]         = priv::ToPackedUnorm8(f4);\n    uint32_t result = 0u;\n    for (int i = 0; i < 4; ++i)\n    {\n        int shift = i * 8;\n        result |= (static_cast<uint32_t>(bits[i]) << shift);\n    }\n    return result;\n}\n\n// Unpacks 4 normalized unsigned floating-point values from a single 32-bit unsigned integer into f.\n// Works similarly to unpackUnorm2x16. The floats are unpacked starting from the least significant\n// bits.\ninline void UnpackUnorm4x8(uint32_t u, float *f)\n{\n    for (int i = 0; i < 4; ++i)\n    {\n        int shift    = i * 8;\n        uint8_t bits = static_cast<uint8_t>((u >> shift) & 0xFF);\n        f[i]         = static_cast<float>(bits) / 255.0f;\n    }\n}\n\n// Packs 4 normalized signed floating-point values to a single 32-bit unsigned integer. The floats\n// are clamped to the range -1.0 to 1.0, and written to the unsigned integer starting from the least\n// significant bits.\ninline uint32_t PackSnorm4x8(float f1, float f2, float f3, float f4)\n{\n    int8_t bits[4];\n    bits[0]         = priv::ToPackedSnorm8(f1);\n    bits[1]         = priv::ToPackedSnorm8(f2);\n    bits[2]         = priv::ToPackedSnorm8(f3);\n    bits[3]         = priv::ToPackedSnorm8(f4);\n    uint32_t result = 0u;\n    for (int i = 0; i < 4; ++i)\n    {\n        int shift = i * 8;\n        result |= ((static_cast<uint32_t>(bits[i]) & 0xFF) << shift);\n    }\n    return result;\n}\n\n// Unpacks 4 normalized signed floating-point values from a single 32-bit unsigned integer into f.\n// Works similarly to unpackSnorm2x16. The floats are unpacked starting from the least significant\n// bits, and clamped to the range -1.0 to 1.0.\ninline void UnpackSnorm4x8(uint32_t u, float *f)\n{\n    for (int i = 0; i < 4; ++i)\n    {\n        int shift   = i * 8;\n        int8_t bits = static_cast<int8_t>((u >> shift) & 0xFF);\n        f[i]        = clamp(static_cast<float>(bits) / 127.0f, -1.0f, 1.0f);\n    }\n}\n\n// Returns an unsigned integer obtained by converting the two floating-point values to the 16-bit\n// floating-point representation found in the OpenGL ES Specification, and then packing these\n// two 16-bit integers into a 32-bit unsigned integer.\n// f1: The 16 least-significant bits of the result;\n// f2: The 16 most-significant bits.\ninline uint32_t packHalf2x16(float f1, float f2)\n{\n    uint16_t leastSignificantBits = static_cast<uint16_t>(float32ToFloat16(f1));\n    uint16_t mostSignificantBits  = static_cast<uint16_t>(float32ToFloat16(f2));\n    return static_cast<uint32_t>(mostSignificantBits) << 16 |\n           static_cast<uint32_t>(leastSignificantBits);\n}\n\n// Returns two floating-point values obtained by unpacking a 32-bit unsigned integer into a pair of\n// 16-bit values, interpreting those values as 16-bit floating-point numbers according to the OpenGL\n// ES Specification, and converting them to 32-bit floating-point values. The first float value is\n// obtained from the 16 least-significant bits of u; the second component is obtained from the 16\n// most-significant bits of u.\ninline void unpackHalf2x16(uint32_t u, float *f1, float *f2)\n{\n    uint16_t leastSignificantBits = static_cast<uint16_t>(u & 0xFFFF);\n    uint16_t mostSignificantBits  = static_cast<uint16_t>(u >> 16);\n\n    *f1 = float16ToFloat32(leastSignificantBits);\n    *f2 = float16ToFloat32(mostSignificantBits);\n}\n\ninline uint8_t sRGBToLinear(uint8_t srgbValue)\n{\n    float value = srgbValue / 255.0f;\n    if (value <= 0.04045f)\n    {\n        value = value / 12.92f;\n    }\n    else\n    {\n        value = std::pow((value + 0.055f) / 1.055f, 2.4f);\n    }\n    return static_cast<uint8_t>(clamp(value * 255.0f + 0.5f, 0.0f, 255.0f));\n}\n\ninline uint8_t linearToSRGB(uint8_t linearValue)\n{\n    float value = linearValue / 255.0f;\n    if (value <= 0.0f)\n    {\n        value = 0.0f;\n    }\n    else if (value < 0.0031308f)\n    {\n        value = value * 12.92f;\n    }\n    else if (value < 1.0f)\n    {\n        value = std::pow(value, 0.41666f) * 1.055f - 0.055f;\n    }\n    else\n    {\n        value = 1.0f;\n    }\n    return static_cast<uint8_t>(clamp(value * 255.0f + 0.5f, 0.0f, 255.0f));\n}\n\n// Reverse the order of the bits.\ninline uint32_t BitfieldReverse(uint32_t value)\n{\n    // TODO(oetuaho@nvidia.com): Optimize this if needed. There don't seem to be compiler intrinsics\n    // for this, and right now it's not used in performance-critical paths.\n    uint32_t result = 0u;\n    for (size_t j = 0u; j < 32u; ++j)\n    {\n        result |= (((value >> j) & 1u) << (31u - j));\n    }\n    return result;\n}\n\n// Count the 1 bits.\n#if defined(_MSC_VER) && (defined(_M_IX86) || defined(_M_X64))\n#    define ANGLE_HAS_BITCOUNT_32\ninline int BitCount(uint32_t bits)\n{\n    return static_cast<int>(__popcnt(bits));\n}\n#    if defined(_M_X64)\n#        define ANGLE_HAS_BITCOUNT_64\ninline int BitCount(uint64_t bits)\n{\n    return static_cast<int>(__popcnt64(bits));\n}\n#    endif  // defined(_M_X64)\n#endif      // defined(_M_IX86) || defined(_M_X64)\n\n#if defined(ANGLE_PLATFORM_POSIX)\n#    define ANGLE_HAS_BITCOUNT_32\ninline int BitCount(uint32_t bits)\n{\n    return __builtin_popcount(bits);\n}\n\n#    if defined(ANGLE_IS_64_BIT_CPU)\n#        define ANGLE_HAS_BITCOUNT_64\ninline int BitCount(uint64_t bits)\n{\n    return __builtin_popcountll(bits);\n}\n#    endif  // defined(ANGLE_IS_64_BIT_CPU)\n#endif      // defined(ANGLE_PLATFORM_POSIX)\n\nint BitCountPolyfill(uint32_t bits);\n\n#if !defined(ANGLE_HAS_BITCOUNT_32)\ninline int BitCount(const uint32_t bits)\n{\n    return BitCountPolyfill(bits);\n}\n#endif  // !defined(ANGLE_HAS_BITCOUNT_32)\n\n#if !defined(ANGLE_HAS_BITCOUNT_64)\ninline int BitCount(const uint64_t bits)\n{\n    return BitCount(static_cast<uint32_t>(bits >> 32)) + BitCount(static_cast<uint32_t>(bits));\n}\n#endif  // !defined(ANGLE_HAS_BITCOUNT_64)\n#undef ANGLE_HAS_BITCOUNT_32\n#undef ANGLE_HAS_BITCOUNT_64\n\ninline int BitCount(uint8_t bits)\n{\n    return BitCount(static_cast<uint32_t>(bits));\n}\n\ninline int BitCount(uint16_t bits)\n{\n    return BitCount(static_cast<uint32_t>(bits));\n}\n\n#if defined(ANGLE_PLATFORM_WINDOWS)\n// Return the index of the least significant bit set. Indexing is such that bit 0 is the least\n// significant bit. Implemented for different bit widths on different platforms.\ninline unsigned long ScanForward(uint32_t bits)\n{\n    ASSERT(bits != 0u);\n    unsigned long firstBitIndex = 0ul;\n    unsigned char ret           = _BitScanForward(&firstBitIndex, bits);\n    ASSERT(ret != 0u);\n    return firstBitIndex;\n}\n\n#    if defined(ANGLE_IS_64_BIT_CPU)\ninline unsigned long ScanForward(uint64_t bits)\n{\n    ASSERT(bits != 0u);\n    unsigned long firstBitIndex = 0ul;\n    unsigned char ret           = _BitScanForward64(&firstBitIndex, bits);\n    ASSERT(ret != 0u);\n    return firstBitIndex;\n}\n#    endif  // defined(ANGLE_IS_64_BIT_CPU)\n#endif      // defined(ANGLE_PLATFORM_WINDOWS)\n\n#if defined(ANGLE_PLATFORM_POSIX)\ninline unsigned long ScanForward(uint32_t bits)\n{\n    ASSERT(bits != 0u);\n    return static_cast<unsigned long>(__builtin_ctz(bits));\n}\n\n#    if defined(ANGLE_IS_64_BIT_CPU)\ninline unsigned long ScanForward(uint64_t bits)\n{\n    ASSERT(bits != 0u);\n    return static_cast<unsigned long>(__builtin_ctzll(bits));\n}\n#    endif  // defined(ANGLE_IS_64_BIT_CPU)\n#endif      // defined(ANGLE_PLATFORM_POSIX)\n\ninline unsigned long ScanForward(uint8_t bits)\n{\n    return ScanForward(static_cast<uint32_t>(bits));\n}\n\ninline unsigned long ScanForward(uint16_t bits)\n{\n    return ScanForward(static_cast<uint32_t>(bits));\n}\n\n// Return the index of the most significant bit set. Indexing is such that bit 0 is the least\n// significant bit.\ninline unsigned long ScanReverse(unsigned long bits)\n{\n    ASSERT(bits != 0u);\n#if defined(ANGLE_PLATFORM_WINDOWS)\n    unsigned long lastBitIndex = 0ul;\n    unsigned char ret          = _BitScanReverse(&lastBitIndex, bits);\n    ASSERT(ret != 0u);\n    return lastBitIndex;\n#elif defined(ANGLE_PLATFORM_POSIX)\n    return static_cast<unsigned long>(sizeof(unsigned long) * CHAR_BIT - 1 - __builtin_clzl(bits));\n#else\n#    error Please implement bit-scan-reverse for your platform!\n#endif\n}\n\n// Returns -1 on 0, otherwise the index of the least significant 1 bit as in GLSL.\ntemplate <typename T>\nint FindLSB(T bits)\n{\n    static_assert(std::is_integral<T>::value, \"must be integral type.\");\n    if (bits == 0u)\n    {\n        return -1;\n    }\n    else\n    {\n        return static_cast<int>(ScanForward(bits));\n    }\n}\n\n// Returns -1 on 0, otherwise the index of the most significant 1 bit as in GLSL.\ntemplate <typename T>\nint FindMSB(T bits)\n{\n    static_assert(std::is_integral<T>::value, \"must be integral type.\");\n    if (bits == 0u)\n    {\n        return -1;\n    }\n    else\n    {\n        return static_cast<int>(ScanReverse(bits));\n    }\n}\n\n// Returns whether the argument is Not a Number.\n// IEEE 754 single precision NaN representation: Exponent(8 bits) - 255, Mantissa(23 bits) -\n// non-zero.\ninline bool isNaN(float f)\n{\n    // Exponent mask: ((1u << 8) - 1u) << 23 = 0x7f800000u\n    // Mantissa mask: ((1u << 23) - 1u) = 0x7fffffu\n    return ((bitCast<uint32_t>(f) & 0x7f800000u) == 0x7f800000u) &&\n           (bitCast<uint32_t>(f) & 0x7fffffu);\n}\n\n// Returns whether the argument is infinity.\n// IEEE 754 single precision infinity representation: Exponent(8 bits) - 255, Mantissa(23 bits) -\n// zero.\ninline bool isInf(float f)\n{\n    // Exponent mask: ((1u << 8) - 1u) << 23 = 0x7f800000u\n    // Mantissa mask: ((1u << 23) - 1u) = 0x7fffffu\n    return ((bitCast<uint32_t>(f) & 0x7f800000u) == 0x7f800000u) &&\n           !(bitCast<uint32_t>(f) & 0x7fffffu);\n}\n\nnamespace priv\n{\ntemplate <unsigned int N, unsigned int R>\nstruct iSquareRoot\n{\n    static constexpr unsigned int solve()\n    {\n        return (R * R > N)\n                   ? 0\n                   : ((R * R == N) ? R : static_cast<unsigned int>(iSquareRoot<N, R + 1>::value));\n    }\n    enum Result\n    {\n        value = iSquareRoot::solve()\n    };\n};\n\ntemplate <unsigned int N>\nstruct iSquareRoot<N, N>\n{\n    enum result\n    {\n        value = N\n    };\n};\n\n}  // namespace priv\n\ntemplate <unsigned int N>\nconstexpr unsigned int iSquareRoot()\n{\n    return priv::iSquareRoot<N, 1>::value;\n}\n\n// Sum, difference and multiplication operations for signed ints that wrap on 32-bit overflow.\n//\n// Unsigned types are defined to do arithmetic modulo 2^n in C++. For signed types, overflow\n// behavior is undefined.\n\ntemplate <typename T>\ninline T WrappingSum(T lhs, T rhs)\n{\n    uint32_t lhsUnsigned = static_cast<uint32_t>(lhs);\n    uint32_t rhsUnsigned = static_cast<uint32_t>(rhs);\n    return static_cast<T>(lhsUnsigned + rhsUnsigned);\n}\n\ntemplate <typename T>\ninline T WrappingDiff(T lhs, T rhs)\n{\n    uint32_t lhsUnsigned = static_cast<uint32_t>(lhs);\n    uint32_t rhsUnsigned = static_cast<uint32_t>(rhs);\n    return static_cast<T>(lhsUnsigned - rhsUnsigned);\n}\n\ninline int32_t WrappingMul(int32_t lhs, int32_t rhs)\n{\n    int64_t lhsWide = static_cast<int64_t>(lhs);\n    int64_t rhsWide = static_cast<int64_t>(rhs);\n    // The multiplication is guaranteed not to overflow.\n    int64_t resultWide = lhsWide * rhsWide;\n    // Implement the desired wrapping behavior by masking out the high-order 32 bits.\n    resultWide = resultWide & 0xffffffffll;\n    // Casting to a narrower signed type is fine since the casted value is representable in the\n    // narrower type.\n    return static_cast<int32_t>(resultWide);\n}\n\ninline float scaleScreenDimensionToNdc(float dimensionScreen, float viewportDimension)\n{\n    return 2.0f * dimensionScreen / viewportDimension;\n}\n\ninline float scaleScreenCoordinateToNdc(float coordinateScreen, float viewportDimension)\n{\n    float halfShifted = coordinateScreen / viewportDimension;\n    return 2.0f * (halfShifted - 0.5f);\n}\n\n}  // namespace gl\n\nnamespace rx\n{\n\ntemplate <typename T>\nT roundUp(const T value, const T alignment)\n{\n    auto temp = value + alignment - static_cast<T>(1);\n    return temp - temp % alignment;\n}\n\ntemplate <typename T>\nconstexpr T roundUpPow2(const T value, const T alignment)\n{\n    ASSERT(gl::isPow2(alignment));\n    return (value + alignment - 1) & ~(alignment - 1);\n}\n\ntemplate <typename T>\nangle::CheckedNumeric<T> CheckedRoundUp(const T value, const T alignment)\n{\n    angle::CheckedNumeric<T> checkedValue(value);\n    angle::CheckedNumeric<T> checkedAlignment(alignment);\n    return roundUp(checkedValue, checkedAlignment);\n}\n\ninline constexpr unsigned int UnsignedCeilDivide(unsigned int value, unsigned int divisor)\n{\n    unsigned int divided = value / divisor;\n    return (divided + ((value % divisor == 0) ? 0 : 1));\n}\n\n#if defined(__has_builtin)\n#    define ANGLE_HAS_BUILTIN(x) __has_builtin(x)\n#else\n#    define ANGLE_HAS_BUILTIN(x) 0\n#endif\n\n#if defined(_MSC_VER)\n\n#    define ANGLE_ROTL(x, y) _rotl(x, y)\n#    define ANGLE_ROTL64(x, y) _rotl64(x, y)\n#    define ANGLE_ROTR16(x, y) _rotr16(x, y)\n\n#elif defined(__clang__) && ANGLE_HAS_BUILTIN(__builtin_rotateleft32) && \\\n    ANGLE_HAS_BUILTIN(__builtin_rotateleft64) && ANGLE_HAS_BUILTIN(__builtin_rotateright16)\n\n#    define ANGLE_ROTL(x, y) __builtin_rotateleft32(x, y)\n#    define ANGLE_ROTL64(x, y) __builtin_rotateleft64(x, y)\n#    define ANGLE_ROTR16(x, y) __builtin_rotateright16(x, y)\n\n#else\n\ninline uint32_t RotL(uint32_t x, int8_t r)\n{\n    return (x << r) | (x >> (32 - r));\n}\n\ninline uint64_t RotL64(uint64_t x, int8_t r)\n{\n    return (x << r) | (x >> (64 - r));\n}\n\ninline uint16_t RotR16(uint16_t x, int8_t r)\n{\n    return (x >> r) | (x << (16 - r));\n}\n\n#    define ANGLE_ROTL(x, y) ::rx::RotL(x, y)\n#    define ANGLE_ROTL64(x, y) ::rx::RotL64(x, y)\n#    define ANGLE_ROTR16(x, y) ::rx::RotR16(x, y)\n\n#endif  // namespace rx\n\nconstexpr unsigned int Log2(unsigned int bytes)\n{\n    return bytes == 1 ? 0 : (1 + Log2(bytes / 2));\n}\n}  // namespace rx\n\n#endif  // COMMON_MATHUTIL_H_\n\n", "comment_ratio": 0.10749432248296745}
{"lang": "c", "code": "/* -*- C++ -*- */\r\n// CLASSIX_Addr.h,v 1.3 2000/03/18 12:16:14 nanbor Exp\r\n\r\n// ============================================================================\r\n//\r\n// = LIBRARY\r\n//    ACE\r\n//\r\n// = FILENAME\r\n//    CLASSIX_Addr.h\r\n//\r\n// = AUTHOR\r\n//    Nokia Telecommunications\r\n//\r\n// ============================================================================\r\n\r\n#ifndef ACE_CLASSIX_ADDR_H\r\n#include \"ace/pre.h\"\r\n#define ACE_CLASSIX_ADDR_H\r\n\r\n#include \"ace/ACE.h\"\r\n\r\n#if !defined (ACE_LACKS_PRAGMA_ONCE)\r\n# pragma once\r\n#endif /* ACE_LACKS_PRAGMA_ONCE */\r\n\r\n#include \"ace/Addr.h\"\r\n\r\n#include <ipc/chIpc.h>\r\n#include <ace/CLASSIX/CLASSIX_OS.h>\r\n\r\nclass ACE_Export ACE_CLASSIX_Addr : public ACE_Addr\r\n{\r\n  // = TITLE\r\n  //    Defines the ClassiX IPC address format.\r\n  //\r\n  // = DESCRIPTION\r\n  //   This class defines basic interfaces for \"ACE-like\" address for\r\n  //   Chorus port.\r\npublic:\r\n  enum\r\n  {\r\n    ACE_CLASSIX_ADDR_UNKNOWN = ACE_INVALID_HANDLE, /* K_NONEPORT */\r\n    ACE_CLASSIX_ADDR_DEFAULT = K_DEFAULTPORT,\r\n    AF_CLASSIX               = AF_MAX + 1\r\n  };\r\n\r\n  enum Addr_Type\r\n  {\r\n    PORT,                       // use Peer_Port\r\n    GROUP,                      // use Peer_Group\r\n    STAMP,                      // use peer_Stamp\r\n    DYNAMIC,                    // use Peer_Group\r\n    UNDEFINED\r\n  };\r\n\r\n\r\n  /* -----------------------------------------------------*/\r\n  // = INITIALIZATION\r\n  ACE_CLASSIX_Addr(int /* size of the underlying address structure*/);\r\n  virtual ~ACE_CLASSIX_Addr (void);\r\n\r\n\r\n  /* -----------------------------------------------------*/\r\n  // = Direct initialization methods (useful after the object has been\r\n  // constructed).\r\n  // Returns 0 on success, -1 otherwise.\r\n  //\r\n\r\n  /* -----------------------------------------------------*/\r\n  // = ACCESS\r\n  //\r\n  virtual const KnUniqueId& get_id (void) const;\r\n  // Returns a reference to the unique identifier\r\n\r\n  virtual ACE_HANDLE get_port_number(void) const;\r\n  virtual ACE_HANDLE get_handle(void) const;\r\n  // Returns the local port no( can be used as an ACE_HANDLE)\r\n\r\n  virtual int is_configured(void) const;\r\n  // Returns 1, if address information is proper; Returns 0 otherwise\r\n  virtual ACE_CLASSIX_Addr::Addr_Type is_type(void) const;\r\n  // returns the type of the address\r\n\r\n  // = HELPER\r\n  virtual void dump(void) const;\r\n\r\n  ACE_ALLOC_HOOK_DECLARE;\r\n  // Declares the dynamic allocation hooks.\r\n\r\nprivate:\r\n};\r\n\r\n#if defined (__ACE_INLINE__)\r\n#include \"ace/CLASSIX/CLASSIX_Addr.i\"\r\n#endif /* __ACE_INLINE__ */\r\n\r\n#include \"ace/post.h\"\r\n#endif /* ACE_CLASSIX_ADDR_H */\r\n\n", "comment_ratio": 0.36}
{"lang": "c", "code": "#pragma once\n\n#include <stdlib.h>\n\n#include \"libsecurity/storage/secureStorage.h\"\n#include \"libsecurity/entity/entityManager.h\"\n#include \"libsecurity/otp/otp.h\"\n\ntypedef struct {\n  int16_t Cliff; // The provider will refuse connections from a user after T\n  // unsuccessful\n  // authentication attempts, Default is 100\n  int16_t DurationSec; // Throttling duration in seconds between each wrong atempt\n  MicroSecTimeStamp throttlingTimerHotp; // Next time the code could be verified for HOTP\n  MicroSecTimeStamp throttlingTimerTotp; // Next time the code could be verified for TOTP\n  int16_t CheckHotpWindow; // The window size of next codes to be checked before\n  // reject the code as\n  // not match\n  int16_t consErrorCounter; // Counter of consecutive errors\n  int16_t AutoUnblockSec; // Number of seconds to release block, 0 means that\n  // the release should be\n  // manuel\n  MicroSecTimeStamp unblockTimer; // When to unblock the user\n  int16_t CheckTotpWindowSec; // The window size in seconds tfor backword check:\n  // to handle clock\n  // driffts\n  char *lastTotpCode; // save the last totp code to avoid reuse of code in the\n  // same time period\n} throttelingS;\n\ntypedef struct {\n  bool Blocked;\n  throttelingS *Throttle; // Handle all the throttle parameters\n  HotpS *BaseHotp;\n  TotpS *BaseTotp;\n} OtpUserS;\n\ntypedef enum { HOTP_TYPE, TOTP_TYPE } OtpType;\n\nvoid OtpUser_PrintUser(FILE *ofp, const char *header, const void *user);\nbool OtpUser_IsValid(const OtpUserS *u);\nbool OtpUser_NewUser(OtpUserS **user, const unsigned char *secret, bool lock, int16_t cliffLen, int16_t thrTimeSec, int16_t autoUnblockSec,\n                     int16_t hotpWindowSize, int16_t totpWindowSize, int64_t startCount);\nvoid OtpUser_FreeUser(void *user);\nbool OtpUser_NewSimpleUser(OtpUserS **user, const unsigned char *secret);\nbool OtpUser_GetBlockState(const OtpUserS *u);\nbool OtpUser_SetBlockedState(OtpUserS *u, bool val);\nbool OtpUser_VerifyCode(OtpUserS *u, const char *code, int16_t otpType);\nbool OtpUser_IsUserBlocked(OtpUserS *user);\nbool OtpUser_Store(const void *user, const SecureStorageS *storage, const char *prefix);\nbool OtpUser_Load(void **user, const SecureStorageS *storage, const char *prefix, char **retName);\n\nbool OtpUserTest_IsEqual(const void *u1, const void *u2);\nbool OtpUserTest_IsEqualThrottling(const throttelingS *thr1, const throttelingS *thr2);\n\n", "comment_ratio": 0.36363636363636365}
{"lang": "c", "code": "#pragma once\n\nnamespace Management\n{\n    namespace FaultAnalysisService\n    {\n        class GetChaosReportMessageBody : public ServiceModel::ClientServerMessageBody\n        {\n        public:\n            GetChaosReportMessageBody() : getChaosReportDescription_() {}\n\n            explicit GetChaosReportMessageBody(GetChaosReportDescription const & getChaosReportDescription) : getChaosReportDescription_(getChaosReportDescription) { }\n\n            __declspec(property(get = get_ReportDescription)) GetChaosReportDescription const & ReportDescription;\n\n            GetChaosReportDescription const & get_ReportDescription() const { return getChaosReportDescription_; }\n\n            FABRIC_FIELDS_01(getChaosReportDescription_);\n\n        private:\n            GetChaosReportDescription getChaosReportDescription_;\n        };\n    }\n}\n\n", "comment_ratio": 0.12903225806451613}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n\nNS_ASSUME_NONNULL_BEGIN\n\ntypedef void(^PickerResult)(id);\n\n@protocol DYPickerViewProtocol <NSObject>\n\n- (void)setupContentView;\n- (void)confirmBtnClick;\n\n@end\n\n@interface DYPickerView : UIView <DYPickerViewProtocol>\n\n@property (nonatomic,copy) NSString *title;\n@property (nonatomic,copy) PickerResult selectResult;\n\n\n+ (instancetype)pickerView;\n\n- (void)show;\n- (void)dismiss;\n\n@end\n\n\n@interface DYSinglePickerView : DYPickerView\n\n@property (nonatomic,copy) NSArray<NSString *> *sources;\n\n\n@end\n\n\nNS_ASSUME_NONNULL_END\n\n", "comment_ratio": 0.15555555555555556}
{"lang": "c", "code": "#include <macadam/details/math/mc_exp.h>\n#include <macadam/details/rand/mc_rand_gamma.h>\n\n#ifndef MC_RAND_BETA_H\n#define MC_RAND_BETA_H\n\n#pragma mark - mc_rand_beta -\n\nMC_TARGET_FUNC float mc_rand_betaf(const float a, const float b)\n{\n//!# Beta distribution generator.\n\tconst float x = mc_rand_gammaf(a, 1.0f);\n\tconst float y = mc_rand_gammaf(b, 1.0f);\n\tconst float z = x + y;\n\treturn z != 0.0f ? x / z : 0.0f;\n}\n\nMC_TARGET_FUNC double mc_rand_betaff(const float a, const float b)\n{\n//!# Beta distribution generator.\n\tconst double x = mc_rand_gammaff(a, 1.0f);\n\tconst double y = mc_rand_gammaff(b, 1.0f);\n\tconst double z = x + y;\n\treturn z != 0.0 ? x / z : 0.0;\n}\n\nMC_TARGET_FUNC double mc_rand_beta(const double a, const double b)\n{\n//!# Beta distribution generator.\n\tconst double x = mc_rand_gamma(a, 1.0);\n\tconst double y = mc_rand_gamma(b, 1.0);\n\tconst double z = x + y;\n\treturn z != 0.0 ? x / z : 0.0;\n}\n\nMC_TARGET_FUNC long double mc_rand_betal(const long double a, const long double b)\n{\n//!# Beta distribution generator.\n\tconst long double x = mc_rand_gammal(a, 1.0L);\n\tconst long double y = mc_rand_gammal(b, 1.0L);\n\tconst long double z = x + y;\n\treturn z != 0.0L ? x / z : 0.0L;\n}\n\n#endif /* !MC_RAND_BETA_H */\n\n/* EOF */\n", "comment_ratio": 0.18181818181818182}
{"lang": "c", "code": "#ifndef MACE_KERNELS_LSTMCELL_H_\n#define MACE_KERNELS_LSTMCELL_H_\n\n#include <algorithm>\n#include <limits>\n#include <memory>\n#include <vector>\n\n#include \"mace/core/future.h\"\n#include \"mace/core/runtime/opencl/cl2_header.h\"\n#include \"mace/core/tensor.h\"\n#include \"mace/kernels/kernel.h\"\n\n#if defined(MACE_ENABLE_NEON)\n#include <arm_neon.h>\n#endif\n\nnamespace mace {\nnamespace kernels {\n\ntemplate <DeviceType D, typename T>\nstruct LSTMCellFunctor;\n\nclass OpenCLLSTMCellKernel {\n public:\n  virtual MaceStatus Compute(\n      OpKernelContext *context,\n      const Tensor *input,\n      const Tensor *pre_output,\n      const Tensor *weight,\n      const Tensor *bias,\n      const Tensor *pre_cell,\n      Tensor *cell,\n      Tensor *output,\n      StatsFuture *future) = 0;\n  MACE_VIRTUAL_EMPTY_DESTRUCTOR(OpenCLLSTMCellKernel);\n};\ntemplate <typename T>\nstruct LSTMCellFunctor<DeviceType::GPU, T> : OpKernel{\n  LSTMCellFunctor(OpKernelContext *context, T forget_bias);\n  MaceStatus operator()(const Tensor *input,\n                        const Tensor *pre_output,\n                        const Tensor *weight,\n                        const Tensor *bias,\n                        const Tensor *pre_cell,\n                        Tensor *cell,\n                        Tensor *output,\n                        StatsFuture *future);\n\n  std::unique_ptr<OpenCLLSTMCellKernel> kernel_;\n};\n\n}  // namespace kernels\n}  // namespace mace\n\n#endif  // MACE_KERNELS_LSTMCELL_H_\n\n", "comment_ratio": 0.22535211267605634}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n#import <UIKit/UIKit.h>\n#import <UMSocialCore/UMSocialCore.h>\n#import \"XIU_ShareModel.h\"\n@interface XIU_UMManager : UMSocialHandler\n\n+(void)UmengMobClickFunc;\n\n+(void)UmengShareFunc;\n\n+ (void)shareObjectWithSnsName:(NSString *)snsName WithMessageValue:(XIU_ShareModel *)model;\n\n\n+ (NSMutableArray *)removeObjOfUninstallProduct:(NSMutableArray *)resultSnsValues;\n@end\n\n", "comment_ratio": 0.2916666666666667}
{"lang": "c", "code": "#ifndef Mod_turb_hyd_base_included\n#define Mod_turb_hyd_base_included\n\n\n#define CMU 0.09\n\n#include <Turbulence_paroi.h>\n// generalisation du modele.\n#include <Support_Champ_Masse_Volumique.h>\nclass Motcle;\nclass Zone_dis;\nclass Zone_Cl_dis;\nclass Equation_base;\nclass Schema_Temps_base;\nclass Param;\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// .DESCRIPTION\n//    Classe Mod_turb_hyd_base\n//    Cette classe sert de base a la hierarchie des classes\n//    qui representent un modele de turbulence pour les\n//    equations de Navier-Stokes. Il existe deja deux classes derivees\n//    qui representent le modele de turbulence (k,e) et le modele\n//    de turbulence sous maille. Ces deux modeles ont en commun\n//    le calcul d'une viscosite turbulente.\n//\n//    B.Mat. : la classe herite de support_champ_masse_volumique.\n//     en Front-Tracking (et plus tard en qc), elle fournit le\n//     mecanisme pour recuperer rho.\n// .SECTION voir aussi\n//    Mod_turb_hyd_ss_maille Modele_turbulence_hyd_K_Eps\n//    Classe abstraite\n//    Methode abstraite\n//      void mettre_a_jour(double )\n//      Entree& lire(const Motcle&, Entree&)\n//////////////////////////////////////////////////////////////////////////////\nclass Mod_turb_hyd_base : public Objet_U,\n  public Support_Champ_Masse_Volumique,\n  public Champs_compris_interface\n{\n\n  Declare_base_sans_constructeur(Mod_turb_hyd_base);\n\npublic:\n  inline Mod_turb_hyd_base();\n  inline const Champ_Fonc& viscosite_turbulente() const;\n  inline Equation_base& equation();\n  inline const Equation_base& equation() const;\n  inline const Turbulence_paroi& loi_paroi() const\n  {\n    return loipar;\n  };\n  inline Turbulence_paroi& loi_paroi()\n  {\n    return loipar;\n  };\n  bool utiliser_loi_paroi() const\n  {\n    return loi_paroi().non_nul() ? loipar->use_shear() : false;\n  };\n  virtual bool calcul_tenseur_Re(const DoubleTab& nu_turb, const DoubleTab& grad, DoubleTab& Re) const\n  {\n    // Not coded\n    return false;\n  };\n  virtual void set_param(Param& param);\n  virtual int lire_motcle_non_standard(const Motcle&, Entree&);\n  virtual int preparer_calcul();\n  virtual bool initTimeStep(double dt);\n  virtual void mettre_a_jour(double ) =0;\n  virtual void discretiser();\n  void discretiser_visc_turb(const Schema_Temps_base&, Zone_dis&, Champ_Fonc&) const;\n  void discretiser_corr_visc_turb(const Schema_Temps_base&, Zone_dis&, Champ_Fonc&) const;\n  void discretiser_K(const Schema_Temps_base&, Zone_dis&, Champ_Fonc&) const; // Utilise par les modeles de tubulence dans TrioCFD\n  virtual void completer();\n  void associer_eqn(const Equation_base& );\n  virtual void associer(const Zone_dis& , const Zone_Cl_dis& );\n  virtual int reprendre(Entree& );\n\n  //Methodes de l interface des champs postraitables\n  /////////////////////////////////////////////////////\n  virtual void creer_champ(const Motcle& motlu);\n  virtual const Champ_base& get_champ(const Motcle& nom) const;\n  virtual void get_noms_champs_postraitables(Noms& nom,Option opt=NONE) const;\n  /////////////////////////////////////////////////////\n\n  inline Champs_compris& champs_compris();\n\n  virtual void imprimer(Sortie&) const;\n  void a_faire(Sortie&) const;\n  virtual int sauvegarder(Sortie&) const;\n\n  int limpr_ustar(double , double, double, double ) const;\n  inline double get_Cmu() const;\n\nprotected:\n\n  double LeCmu;\n  Champ_Fonc la_viscosite_turbulente;\n  REF(Equation_base) mon_equation;\n  Turbulence_paroi loipar;\n  double dt_impr_ustar;\n  double dt_impr_ustar_mean_only;\n  int boundaries_;\n  LIST(Nom) boundaries_list ;\n  Nom nom_fichier_;\n  void limiter_viscosite_turbulente();\n\n  Champs_compris champs_compris_;\nprivate :\n\n\n  double XNUTM;\n  int calcul_borne_locale_visco_turb_;\n  double dt_diff_sur_dt_conv_;\n  Champ_Fonc corr_visco_turb;\n  DoubleVect borne_visco_turb;\n};\n\ninline Mod_turb_hyd_base::Mod_turb_hyd_base()\n{\n  LeCmu = CMU ;\n  dt_impr_ustar=1.e20;\n  dt_impr_ustar_mean_only=1.e20;\n  boundaries_=0;\n  nom_fichier_=\"\";\n  XNUTM = 1.E8 ;\n  calcul_borne_locale_visco_turb_ = 0;\n  dt_diff_sur_dt_conv_ = -1;\n}\n// Description:\n//    Renvoie la viscosite turbulente.\n// Precondition:\n// Parametre:\n//    Signification:\n//    Valeurs par defaut:\n//    Contraintes:\n//    Acces:\n// Retour: Champ_Fonc&\n//    Signification: le champ representant la viscosite turbulente\n//    Contraintes: reference constante\n// Exception:\n// Effets de bord:\n// Postcondition: la methode ne modifie pas l'objet\ninline const Champ_Fonc& Mod_turb_hyd_base::viscosite_turbulente() const\n{\n  return la_viscosite_turbulente;\n}\n\n\n// Description:\n//    Renvoie l'equation associee au modele de turbulence.\n//    (c'est une equation du type Equation_base)\n// Precondition:\n// Parametre:\n//    Signification:\n//    Valeurs par defaut:\n//    Contraintes:\n//    Acces:\n// Retour: Equation_base&\n//    Signification: l'equation associee au modele de turbulence\n//    Contraintes: reference constante\n// Exception:\n// Effets de bord:\n// Postcondition: la methode ne modifie pas l'objet\ninline Equation_base& Mod_turb_hyd_base::equation()\n{\n  if (mon_equation.non_nul()==0)\n    {\n      Cerr << \"\\nError in Mod_turb_hyd_base::equation() : The equation is unknown !\" << finl;\n      Process::exit();\n    }\n  return mon_equation.valeur();\n}\n\ninline const Equation_base& Mod_turb_hyd_base::equation() const\n{\n  if (mon_equation.non_nul()==0)\n    {\n      Cerr << \"\\nError in Mod_turb_hyd_base::equation() : The equation is unknown !\" << finl;\n      Process::exit();\n    }\n  return mon_equation.valeur();\n}\n\n// Description:\n//    Renvoie de la valeur de Cmu\n// Precondition:\n// Parametre:\n//    Signification:\n//    Valeurs par defaut:\n//    Contraintes:\n//    Acces:\n// Retour: la valeur Cmu\n//    Signification:\n//    Contraintes:\n// Exception:\n// Effets de bord:\n// Postcondition:\ninline double Mod_turb_hyd_base::get_Cmu() const\n{\n  return LeCmu;\n}\n\ninline Champs_compris&  Mod_turb_hyd_base::champs_compris()\n{\n  return champs_compris_;\n}\n#endif\n\n\n", "comment_ratio": 0.3276595744680851}
{"lang": "c", "code": "//\n//  ProfileViewController.h\n//  Instagram\n//\n//  Created by Elisa Jacobo Arill on 7/7/21.\n//\n\n#import <UIKit/UIKit.h>\n#import <Parse/Parse.h>\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface ProfileViewController : UIViewController\n\n@property (strong, nonatomic) PFUser *user;\n\n@end\n\nNS_ASSUME_NONNULL_END\n\n", "comment_ratio": 0.3}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n\n@interface AppDelegate : UIResponder <UIApplicationDelegate>\n\n@property (strong, nonatomic) UIWindow *window;\n\n\n@end\n\n\n", "comment_ratio": 0.3888888888888889}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n#import \"SampleViewController.h\"\n\n@class ASIWebPageRequest;\n\n@interface WebPageViewController : SampleViewController <UIWebViewDelegate> {\n\tUIWebView *webView;\n\tUITextField *urlField;\n\tUITextView *responseField;\n\tUISwitch *replaceURLsSwitch;\n\tASIWebPageRequest *request;\n\tNSMutableArray *requestsInProgress;\n}\n- (void)fetchURL:(NSURL *)url;\n\n@property (retain, nonatomic) ASIWebPageRequest *request;\n@property (retain, nonatomic) NSMutableArray *requestsInProgress;\n@end\n\n", "comment_ratio": 0.25925925925925924}
{"lang": "c", "code": "#ifndef C0P_PARAM_OBJECTS_SURFER__US_1O0__SURFTIMECONST_7O0__REORIENTATIONTIME_4O0_GROUP_HOMOGENEOUS_MEMBER_AGENT_BEHAVIOUR_SENSOR_VELOCITY_GRADIENTS_CHOICE_H\n#define C0P_PARAM_OBJECTS_SURFER__US_1O0__SURFTIMECONST_7O0__REORIENTATIONTIME_4O0_GROUP_HOMOGENEOUS_MEMBER_AGENT_BEHAVIOUR_SENSOR_VELOCITY_GRADIENTS_CHOICE_H\n#pragma once\n\n// THIS FILE SHOULD NOT BE EDITED DIRECTLY BY THE USERS.\n// THIS FILE WILL BE AUTOMATICALLY EDITED WHEN THE\n// CHOOSE COMMAND IS USED\n\n// choose your behaviour\n#include \"core/env/objects/object/agent/behaviour/sensor/velocity_gradients/accurate/core.h\"\n#include \"param/env/objects/surfer__us_1o0__surftimeconst_7o0__reorientationtime_4o0/group/homogeneous/_member/agent/_behaviour/_sensor/velocity_gradients/accurate/parameters.h\"\nnamespace c0p {\n    template<typename SurferUs1O0Surftimeconst7O0Reorientationtime4O0GroupHomogeneousMemberAgentActiveStep>\n    using SurferUs1O0Surftimeconst7O0Reorientationtime4O0GroupHomogeneousMemberAgentBehaviourSensorVelocityGradients = AgentBehaviourSensorVelocityGradientsAccurate<SurferUs1O0Surftimeconst7O0Reorientationtime4O0GroupHomogeneousMemberAgentBehaviourSensorVelocityGradientsAccurateParameters, SurferUs1O0Surftimeconst7O0Reorientationtime4O0GroupHomogeneousMemberAgentActiveStep>;\n}\n\n#endif\n\n", "comment_ratio": 0.2222222222222222}
{"lang": "c", "code": "// stdafx.h : include file for standard system include files,\n//  or project specific include files that are used frequently, but\n//      are changed infrequently\n\n\n#if !defined(AFX_STDAFX_H__AE78B9E2_A5B8_11D4_A1FB_00500C0076C8__INCLUDED_)\n#define AFX_STDAFX_H__AE78B9E2_A5B8_11D4_A1FB_00500C0076C8__INCLUDED_\n\n// Insert your headers here\n#define WIN32_LEAN_AND_MEAN\t\t// Exclude rarely-used stuff from Windows headers\n\n\ntypedef char dInt8;\ntypedef unsigned char dUnsigned8;\n\ntypedef short dInt16;\ntypedef unsigned short dUnsigned16;\n\ntypedef int dInt32;\ntypedef unsigned dUnsigned32;\ntypedef unsigned int dUnsigned32;\n\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdio.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n\n\n#ifdef _MSC_VER\n\t#include <windows.h>\n\t#include <crtdbg.h>\n\t//#include <gl/glut.h>\n\t#include <malloc.h>\n#else\n\t#ifdef _MIPS_ARCH\n\t\t#include <Glut/glut.h>\n\t#else\n\t\t#include <glut.h>\n\t#endif\n\t#include <unistd.h>\n#endif\n\n\n// transcendental functions\n#define\tdAbs(x)\t\tdFloat (fabs (dFloat(x))) \n#define\tdSqrt(x)\tdFloat (sqrt (dFloat(x))) \n#define\tdFloor(x)\tdFloat (floor (dFloat(x))) \n#define\tdMod(x,y)\tdFloat (fmod (dFloat(x), dFloat(y))) \n\n#define dSin(x)\t\tdFloat (sin (dFloat(x)))\n#define dCos(x)\t\tdFloat (cos (dFloat(x)))\n#define dAsin(x)\tdFloat (asin (dFloat(x)))\n#define dAcos(x)\tdFloat (acos (dFloat(x)))\n#define\tdAtan2(x,y) dFloat (atan2 (dFloat(x), dFloat(y)))\n\n\n#ifdef __USE_DOUBLE_PRECISION__\n\t#define glMultMatrix(x) glMultMatrixd(x)\n\t#define glGetFloat(x,y) glGetDoublev(x,(GLdouble *)y) \n#else\n\t#define glMultMatrix(x) glMultMatrixf(x)\n\t#define glGetFloat(x,y) glGetFloatv(x,(GLfloat  *)y) \n#endif\n\n\n// SDK include\n#include \"dList.h\"\n#include \"dVector.h\"\n#include \"dMatrix.h\"\n//#include <dQuaternion.h>\n#include \"Newton.h\"\n\n\n#ifdef _MSC_VER\n\t#pragma warning (disable: 4100) //unreferenced formal parameter\n\t#pragma warning (disable: 4505) //unreferenced local function has been removed\n\t#pragma warning (disable: 4201) //nonstandard extension used : nameless struct/union\n\t#pragma warning (disable: 4127) //conditional expression is constant\n\n\t#if (_MSC_VER >= 1400)\n\t\t#pragma warning (disable: 4996) // for 2005 users declared deprecated\n\t#endif\n\n#else\n\t//#define _ASSERTE(x) assert(x)\n\t#define _ASSERTE(x) \n\t#define min(a,b) (a < b ? a : b)\n\t#define max(a,b) (a > b ? a : b)\n\n\t#ifndef dAsin\n\t\t#define dAsin(x) ((dFloat) dAsin(x))\n\t\t#define dAcos(x) ((dFloat) dAcos(x))\n\t#endif\n#endif\n\n\n// for some reason specifying a relative does not seem to work in Linus\n// and i have to specify a absolute path\n// #define ASSETS_PATH \".\"\n\n\n#ifdef _MSC_VER\n\t\t// Windows user assets path\n\t\t#define ASSETS_PATH \".\"\n\t\tinline void GetWorkingFileName (const char* name, char* outPathName)\n\t\t{\n\t\t\tsprintf (outPathName, \"%s/%s\", ASSETS_PATH, name);\n\t\t}\n\n#else\n\n\t#ifdef _MIPS_ARCH\n\t\t// Mac user assets path\n\t\t#define ASSETS_PATH \"../../..\"\n\t\tinline void GetWorkingFileName (const char* name, char* outPathName)\n\t\t{\n\t\t\tsprintf (outPathName, \"%s/%s\", ASSETS_PATH, name);\n\t\t}\n\t#else\n\t\t// Linux user assets path\n\t\t#define ASSETS_PATH \"newtonSDK/samples/bin\"\n\t\tinline void GetWorkingFileName (const char* name, char* outPathName)\n\t\t{\n\t\t\tchar *env;\n\t\t\tenv = getenv(\"HOME\");\n\t\t\tsprintf (outPathName, \"%s/%s/%s\", env, ASSETS_PATH, name);\n\t\t}\n\t#endif\n#endif\n\n\n// little Indian/big Indian conversion\n#ifdef _MIPS_ARCH\n\t#define SWAP_INT16(x) (((x >> 8) & 0xff) + ((x & 0xff) << 8))\n\t#define SWAP_INT32(x) ((SWAP_INT16 ( x >> 16)) + (SWAP_INT16 (x) << 16))\n\n\tinline void SWAP_FLOAT32_ARRAY (dFloat *array, dInt32 count)\n\t{\n\t\tdInt32 i;\n\t\tdInt32 x;\n\n\t\tfor (i = 0; i < count; i ++) {\n\t\t\tx = SWAP_INT32 (*((dInt32*) &array[i]));\n\t\t\tarray[i] = *((dFloat*)&x);\n\t\t}\n\t}\n\n#else\n\n\t#define SWAP_INT16(x) x\n\t#define SWAP_INT32(x) x\n\tinline void SWAP_FLOAT32_ARRAY (float *array, dInt32 count)\n\t{\n\t}\n\n#endif\n\n\n#endif \n\n", "comment_ratio": 0.13414634146341464}
{"lang": "c", "code": "#ifndef STRATUM_HAL_LIB_BCM_BCM_SDK_SIM_H_\n#define STRATUM_HAL_LIB_BCM_BCM_SDK_SIM_H_\n\n#include <map>\n#include <string>\n\n#include \"absl/base/thread_annotations.h\"\n#include \"absl/synchronization/mutex.h\"\n#include \"stratum/glue/integral_types.h\"\n#include \"stratum/glue/status/status.h\"\n#include \"stratum/hal/lib/bcm/bcm_sdk_wrapper.h\"\n\nnamespace stratum {\nnamespace hal {\nnamespace bcm {\n\n// Holds all the info on all the attached simulated devices. Each device\n// corresponds to an instance of the simulator process whose PID we save here.\nstruct BcmSimDeviceInfo {\n  BcmChip::BcmChipType chip_type;\n  int pci_bus;\n  int pci_slot;\n  int rpc_port;\n  int pid;\n  BcmSimDeviceInfo() : pci_bus(-1), pci_slot(-1), rpc_port(-1), pid(-1) {}\n};\n\n// The \"BcmSdkSim\" is an implementation of BcmSdkInterface, derived from\n// BcmSdkWrapper, which is used to test most of the APIs in BcmSdkWrapper on\n// simulated ASICs.\nclass BcmSdkSim : public BcmSdkWrapper {\n public:\n  explicit BcmSdkSim(const std::string& bcm_sdk_sim_bin);\n  ~BcmSdkSim() override;\n\n  // Overloaded version of BcmSdkWrapper public methods for simulator.\n  ::util::Status InitializeSdk(\n      const std::string& config_file_path,\n      const std::string& config_flush_file_path,\n      const std::string& bcm_shell_log_file_path) override;\n  ::util::Status FindUnit(int unit, int pci_bus, int pci_slot,\n                          BcmChip::BcmChipType chip_type) override\n      LOCKS_EXCLUDED(sim_lock_);\n  ::util::Status ShutdownAllUnits() override LOCKS_EXCLUDED(sim_lock_);\n  ::util::Status StartLinkscan(int unit) override;\n  ::util::Status StopLinkscan(int unit) override;\n  ::util::Status DeleteL2EntriesByVlan(int unit, int vlan) override;\n  ::util::Status CreateKnetIntf(int unit, int vlan, std::string* netif_name,\n                                int* netif_id) override;\n  ::util::Status DestroyKnetIntf(int unit, int netif_id) override;\n  ::util::StatusOr<int> CreateKnetFilter(int unit, int netif_id,\n                                         KnetFilterType type) override;\n  ::util::Status DestroyKnetFilter(int unit, int filter_id) override;\n  ::util::Status StartRx(int unit, const RxConfig& rx_config) override;\n  ::util::Status StopRx(int unit) override;\n  ::util::Status SetRateLimit(\n      int unit, const RateLimitConfig& rate_limit_config) override;\n  ::util::Status GetKnetHeaderForDirectTx(int unit, int port, int cos,\n                                          uint64 smac, size_t packet_len,\n                                          std::string* header) override;\n  ::util::Status GetKnetHeaderForIngressPipelineTx(\n      int unit, uint64 smac, size_t packet_len, std::string* header) override;\n  size_t GetKnetHeaderSizeForRx(int unit) override;\n  ::util::Status ParseKnetHeaderForRx(int unit, const std::string& header,\n                                      int* ingress_logical_port,\n                                      int* egress_logical_port,\n                                      int* cos) override;\n\n  // Creates the singleton instance. Expected to be called once to initialize\n  // the instance.\n  static BcmSdkSim* CreateSingleton(const std::string& bcm_sdk_sim_bin)\n      LOCKS_EXCLUDED(init_lock_);\n\n  // The following public functions are specific to this class. They are to be\n  // called by SDK callbacks or functions defined in the private namespace in\n  // the .cc file only.\n\n  // Find PCI info for a simulated BDE device. To be called in the SDK method\n  // linux_bde_get_pci_info.\n  ::util::Status GetPciInfo(int unit, uint32* bus, uint32* slot)\n      LOCKS_EXCLUDED(sim_lock_);\n\n protected:\n  // Overloaded version of BcmSdkWrapper protected methods for simulator.\n  ::util::Status CleanupKnet(int unit) override;\n\n private:\n  // Brings up the simulator based on the given chip type.\n  ::util::Status InitializeSim(int unit, BcmChip::BcmChipType chip_type)\n      LOCKS_EXCLUDED(sim_lock_);\n\n  // Kills all the simulator processes. To be called in ShutdownAllUnits.\n  ::util::Status ShutdownAllSimProcesses() LOCKS_EXCLUDED(sim_lock_);\n\n  // RW mutex lock for protecting the internal simulator data structures.\n  mutable absl::Mutex sim_lock_;\n\n  // An internal map of dev_num of the simulated device (which is identical\n  // to unit number) to the BcmSimDeviceInfo holding the info on this device.\n  std::map<int, BcmSimDeviceInfo*> unit_to_dev_info_ GUARDED_BY(sim_lock_);\n\n  // Path to the BCMSIM or PCID binary.\n  std::string bcm_sdk_sim_bin_;\n};\n\n}  // namespace bcm\n}  // namespace hal\n}  // namespace stratum\n\n#endif  // STRATUM_HAL_LIB_BCM_BCM_SDK_SIM_H_\n\n", "comment_ratio": 0.23478260869565218}
{"lang": "c", "code": "#ifndef _rtmfp_h\n#define _rtmfp_h\n\n#include <stdint.h>\n\ntypedef struct RtmfpService RtmfpService;\n\n/* Return the number of reply bytes used, or 0 for no reply, or -1 for message not handled */\ntypedef int (UserDataHandler)(uint8_t *payload, int length, uint8_t *reply, int replySpace);\n\n// Create a new RtmfpService\nRtmfpService *rtmfpInitialise();\n\n// Destroy a service\nvoid rtmfpDestroy(RtmfpService *service);\n\n// Add a handler to a created service\nvoid rtmfpAddHandler(RtmfpService *service, uint8_t type, UserDataHandler *handler);\n\n// Read a datagram for a service\nint rtmfpReadDatagram(RtmfpService *service, int fd);\n\n#endif\n\n", "comment_ratio": 0.16666666666666666}
{"lang": "c", "code": "/*\tSEM\u00c1FOROS */\n\n/* Los semaforos son un mecanismo de sincronizaci\u00f3n \n \n   Protege el acceso a zonas de memoria que son secciones cr\u00edticas */\n\n\n#include <pthread.h>\n#include <semaphore.h>\n#include <stdio.h>\n\n#define iter 10000\nstatic void * funcion_hilo1(void* arg);\nstatic void * funcion_hilo2(void* arg);\n//Recurso compartido entre hilos\nstatic int cont = 0;\n\nsem_t sem1;\n\nint main(void){\n\n\t//Creamos 2 hilos\n\tpthread_t hilo1,hilo2;\n\n\tsem_init(&sem1,0,1); //Inicializamos sem\u00e1foro\n\n\t/*\n\t1 argumento : Referencia al semaforo\n\t2 argumento : Indicamos si el semaforo es compartido entre procesos\n\t3 argumento : Valor de inicializaci\u00f3n del sem\u00e1foro\n\t*/\n\n\n\tpthread_create(&hilo1,NULL, *funcion_hilo1, NULL);\n\tpthread_create(&hilo2,NULL, *funcion_hilo2, NULL);\n\n\t//Esperamos a que terminen\n\tpthread_join(hilo1,NULL);\n\tpthread_join(hilo2,NULL);\n\n\tprintf(\"EL valor de la cuenta es %d \\n\", cont);\n\n}\n\n\nstatic void * funcion_hilo1(void* arg){\n\n\t//Lo que hace este hilo es iterar para aumentar la variable cont\n\tfor (int i=0;i<iter;i++){\n\n\t\tsem_wait(&sem1); //Decrementamos el semaforo y tiene valor 0\n\t\tcont+=1;\n\t\tsem_post(&sem1); //Incrementamos el sem\u00e1foro \n\t}\n\n}\n\nstatic void * funcion_hilo2(void* arg){\n\n\t//Lo que hace este hilo es iterar para decrementar la variable cont\n\tfor (int i=0;i<iter;i++){\n\n\t\tsem_wait(&sem1); \n\t\tcont-=1;\n\t\tsem_post(&sem1);\n\t}\n\n}\n", "comment_ratio": 0.11764705882352941}
{"lang": "c", "code": "#include \"rfc822-datetime.h\"\n#include <stdio.h>\n#include <assert.h>\n#include <time.h>\n\n// Tue, 15 Nov 1994 08:12:31 GMT\n// 23 Jan 1997 15:35:06 GMT\n/*\n// RFC822 \n// 5.  DATE AND TIME SPECIFICATION\ndate-time   =  [ day \",\" ] date time        ; dd mm yy\n\t\t\t\t\t\t\t\t\t\t\t;  hh:mm:ss zzz\n\nday         =  \"Mon\"  / \"Tue\" /  \"Wed\"  / \"Thu\"\n\t\t\t/  \"Fri\"  / \"Sat\" /  \"Sun\"\n\ndate        =  1*2DIGIT month 2DIGIT        ; day month year\n\t\t\t\t\t\t\t\t\t\t\t;  e.g. 20 Jun 82\n\nmonth       =  \"Jan\"  /  \"Feb\" /  \"Mar\"  /  \"Apr\"\n\t\t\t/  \"May\"  /  \"Jun\" /  \"Jul\"  /  \"Aug\"\n\t\t\t/  \"Sep\"  /  \"Oct\" /  \"Nov\"  /  \"Dec\"\n\ntime        =  hour zone                    ; ANSI and Military\n\nhour        =  2DIGIT \":\" 2DIGIT [\":\" 2DIGIT]\n\t\t\t\t\t\t\t\t\t\t\t; 00:00:00 - 23:59:59\n\nzone        =  \"UT\"  / \"GMT\"                ; Universal Time\n\t\t\t\t\t\t\t\t\t\t\t; North American : UT\n\t\t\t/  \"EST\" / \"EDT\"                ;  Eastern:  - 5/ - 4\n\t\t\t/  \"CST\" / \"CDT\"                ;  Central:  - 6/ - 5\n\t\t\t/  \"MST\" / \"MDT\"                ;  Mountain: - 7/ - 6\n\t\t\t/  \"PST\" / \"PDT\"                ;  Pacific:  - 8/ - 7\n\t\t\t/  1ALPHA                       ; Military: Z = UT;\n\t\t\t\t\t\t\t\t\t\t\t;  A:-1; (J not used)\n\t\t\t\t\t\t\t\t\t\t\t;  M:-12; N:+1; Y:+12\n\t\t\t/ ( (\"+\" / \"-\") 4DIGIT )        ; Local differential\n\t\t\t\t\t\t\t\t\t\t\t;  hours+min. (HHMM)\n*/\n\nstatic const char* s_month[] = {\n\t\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n\t\"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"\n};\n\nstatic const char* s_week[] = {\n\t\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"\n};\n\nstatic const char* s_zone[] = {\n\t\"UTC\", \"GMT\", \"EST\", \"EDT\", \"CST\", \"CDT\",\n\t\"MST\", \"MDT\", \"PST\", \"PDT\"\n};\n\nconst char* rfc822_datetime_format(time_t time, rfc822_datetime_t datetime)\n{\n\tint r;\n\tstruct tm *tm = gmtime(&time);\n\tassert(0 <= tm->tm_wday && tm->tm_wday < 7);\n\tassert(0 <= tm->tm_mon && tm->tm_mon < 12);\n\tassert(sizeof(rfc822_datetime_t) >= 30);\n\tr = snprintf(datetime, sizeof(rfc822_datetime_t), \"%s, %02d %s %04d %02d:%02d:%02d GMT\",\n\t\ts_week[(unsigned int)tm->tm_wday % 7],\n\t\ttm->tm_mday,\n\t\ts_month[(unsigned int)tm->tm_mon % 12],\n\t\ttm->tm_year+1900,\n\t\ttm->tm_hour,\n\t\ttm->tm_min,\n\t\ttm->tm_sec);\n\treturn r > 0 && r < sizeof(rfc822_datetime_t) ? datetime : NULL;\n}\n\n//time_t datetime_parse(const char* datetime)\n//{\n//\treturn 0;\n//}\n\n", "comment_ratio": 0.10256410256410256}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n#import <AVFoundation/AVFoundation.h>\n#import \"HyAVWriterTypedef.h\"\n\nNS_ASSUME_NONNULL_BEGIN\n\n@protocol HyAVWriterProtocol;\n@protocol HyVideoWriterProtocol <NSObject>\n\n@property (nonatomic,assign) HyAVWriterStatus writerStatus;\n\n@property (nonatomic,weak) id<HyAVWriterProtocol> avWriter;\n@property (nonatomic,strong,readonly) AVAssetWriterInput *videoInput;\n\n+ (instancetype(^)(CGFloat width, CGFloat height))videoWriter;\n- (BOOL)encodeFrame:(CMSampleBufferRef)sampleBuffer;\n\n@end\n\nNS_ASSUME_NONNULL_END\n\n", "comment_ratio": 0.2413793103448276}
{"lang": "c", "code": "//=================================================================================================\n//\n// This is the header file for the benchmark itself. The main file only calls the benchmark main\n// function.\n//\n//=================================================================================================\n\n\n#ifndef BLINKY_H\n#define BLINKY_H\n\n\n//=========================================== INCLUDES ==========================================//\n\n// mbed files\n#include \"mbed.h\"\n\n// board specific files\n#include \"benchmark_target.h\"\n\n// IoT2 configuration and special interface files\n#include \"IoT2_Config.h\"\n#include \"iot2Debug.h\" \n\n\n\n//======================================== DEFINES & GLOBALS ====================================//\n\n\nextern Serial pc;\n\n//========================================= FUNCTIONS ===========================================//\n\n\nvoid benchmarkMain(void);\n\n\n#endif  // BLINKY_EXAMPLE //\n", "comment_ratio": 0.34210526315789475}
{"lang": "c", "code": "/*\n * Mario Kicherer (dev@kicherer.org) 2016\n *\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <inttypes.h>\n#include <unistd.h>\n\n#include \"intern.h\"\n#include \"core.h\"\n#include \"cache.h\"\n#include \"event_comm.h\"\n#include \"threads.h\"\n#include \"dict.h\"\n\n#define CRTX_SEREV_FLAG_EXPECT_RESPONSE 1<<0\n\nstruct serialized_event {\n\tuint8_t version;\n\tuint64_t id;\n\t\n\tuint32_t type_length;\n\tuint8_t flags;\n};\n\n\n\nvoid write_event_as_dict(struct crtx_event *event, write_fct write, void *conn_id) {\n\tstruct serialized_event sev;\n\tint ret;\n\t\n\tif (!event->data.dict) {\n\t\tret = crtx_event_raw2dict(event, 0);\n\t\t\n\t\tif (ret != CRTX_SUCCESS) {\n\t\t\tprintf(\"cannot prepare this event of type \\\"%s\\\" for transmission\\n\", event->description);\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\t#ifdef DEBUG\n\t// suppress valgrind warning\n\tmemset(&sev, 0, sizeof(struct serialized_event));\n\t#endif\n\t\n\tsev.version = 0;\n\tsev.type_length = strlen(event->description);\n\tsev.flags = 0;\n\tsev.id = 0;\n\t\n\tif (event->response_expected) {\n\t\tsev.flags |= CRTX_SEREV_FLAG_EXPECT_RESPONSE;\n\t\tsev.id = (uint64_t) (uintptr_t) event;\n\t} else {\n\t\tif (event->original_event_id)\n\t\t\tsev.id = event->original_event_id;\n\t}\n\t\n\tprintf(\"serializing event %s %d %\" PRIu64 \"\\n\", event->description, sev.flags, sev.id);\n\t\n\tret = write(conn_id, &sev, sizeof(struct serialized_event));\n\tif (ret < 0) {\n\t\tprintf(\"writeing event failed: %s\\n\", strerror(errno));\n\t\treturn;\n\t}\n\t\n\tret = write(conn_id, event->description, sev.type_length);\n\tif (ret < 0) {\n\t\tprintf(\"writeing event failed: %s\\n\", strerror(errno));\n\t\treturn;\n\t}\n\t\n\tcrtx_write_dict(write, conn_id, event->data.dict);\n}\n\n#define FREE_EVENT(event) { free((event)->description); free(event); }\n\nstruct crtx_event *read_event_as_dict(read_fct read, void *conn_id) {\n\tstruct serialized_event sev;\n\tstruct crtx_event *event;\n\tstruct crtx_dict *dict;\n\tchar ret;\n\t\n\tprintf(\"waiting on new event\\n\");\n\t\n\tret = crtx_read(read, conn_id, &sev, sizeof(struct serialized_event));\n\tif (!ret) {\n\t\treturn 0;\n\t}\n\t\n\tif (sev.version != 0) {\n\t\tprintf(\"error parsing event, version mismatch %d\\n\", sev.version);\n\t\treturn 0;\n\t}\n\t\n\tret = crtx_create_event(&event);\n\tif (ret) {\n\t\treturn 0;\n\t}\n\tevent->original_event_id = sev.id;\n\t\n\tif ((sev.flags & CRTX_SEREV_FLAG_EXPECT_RESPONSE) != 0)\n\t\tevent->response_expected = 1;\n\t\n\tevent->description = (char*) malloc(sev.type_length+1);\n\tret = crtx_read(read, conn_id, event->description, sev.type_length);\n\tif (!ret) {\n\t\tFREE_EVENT(event);\n\t\treturn 0;\n\t}\n\tevent->description[sev.type_length] = 0;\n\t\n\tprintf(\"deserializing event %s %d %\" PRIu64 \"\\n\", event->description, sev.flags, sev.id);\n\t\n// \tevent->data.dict\n\tdict = crtx_read_dict(read, conn_id);\n\tif (!dict) {\n\t\tFREE_EVENT(event);\n\t\treturn 0;\n\t}\n\t\n\tcrtx_event_set_dict_data(event, dict, 0);\n\t\n\tcrtx_print_dict(event->data.dict);\n\t\n\treturn event;\n}\n\nstatic char inbox_dispatch_handler(struct crtx_event *event, void *userdata, void **sessiondata) {\n\tadd_raw_event(event);\n\t\n\treturn 1;\n}\n\nstatic char in_create_key_cb(struct crtx_event *event, struct crtx_dict_item *key) {\n\tif (event->original_event_id) {\n\t\tchar *skey = 0;\n\t\t\n\t\tskey = (char*) malloc(sizeof(uint64_t)*2+1);\n\t\tif (!skey)\n\t\t\treturn 0;\n\t\tsnprintf(skey, sizeof(uint64_t)*2+1, \"%\" PRIu64, (uint64_t) (uintptr_t) event->original_event_id);\n\t\t\n\t\tkey->type = 's';\n\t\tkey->string = skey;\n\t\tkey->flags |= CRTX_DIF_ALLOCATED_KEY;\n\t\t\n\t\treturn 1;\n\t}\n\t\n\treturn 0;\n\t\n// \treturn key;\n}\n\nstatic char out_create_key_cb(struct crtx_event *event, struct crtx_dict_item *key) {\n\tchar *skey;\n\t\n\tskey = (char*) malloc(sizeof(uint64_t)*2+1);\n\tif (!skey)\n\t\treturn 0;\n\tsnprintf(skey, sizeof(uint64_t)*2+1, \"%\" PRIu64, (uint64_t) (uintptr_t) event);\n\t\n\tkey->type = 's';\n\tkey->string = skey;\n\tkey->flags |= CRTX_DIF_ALLOCATED_KEY;\n\t\n\treturn 1;\n\t\n// \treturn key;\n}\n\nstatic char out_cache_on_hit(struct crtx_cache_task *ct, struct crtx_dict_item *key, struct crtx_event *event, struct crtx_dict_item *c_entry) {\n\tprintf(\"ERROR duplicate event ID\\n\");\n\t\n\treturn 1;\n}\n\nstatic void out_cache_on_miss(struct crtx_cache_task *ct, struct crtx_dict_item *key, struct crtx_event *event) {\n// \tstruct crtx_cache *dc = ct->cache;\n// \tstruct crtx_dict_item *ditem;\n\t\n\tprintf(\"add event outlist\\n\");\n\t\n\t// is somebody interested in a response to this event?\n\tif (event->refs_before_release == 0)\n\t\treturn;\n\t\n\treference_event_response(event);\n\t\n\t\n\t\n\tcrtx_cache_add_entry(ct->cache, key, event, 0);\n\t\n\t\n\t\n// \tpthread_mutex_lock(&dc->mutex);\n// \t\n// // \tdc->n_entries++;\n// // \tdc->entries = (struct crtx_cache_entry *) realloc(dc->entries, sizeof(struct crtx_cache_entry)*dc->n_entries);\n// // \t\n// // \tmemset(&dc->entries[dc->n_entries-1], 0, sizeof(struct crtx_cache_entry));\n// // \tdc->entries[dc->n_entries-1].key = *key;\n// // \tdc->entries[dc->n_entries-1].value = event;\n// // \tdc->entries[dc->n_entries-1].value_size = sizeof(void*);\n// \t\n// \tditem = crtx_alloc_item(dc->entries);\n// \tditem->key = key;\n// \tditem->pointer = event;\n// \tditem->type = 'p';\n// \t\n// \tpthread_mutex_unlock(&dc->mutex);\n// \t\n// \t*key = 0;\n}\n\nstatic char in_cache_on_hit(struct crtx_cache_task *ct, struct crtx_dict_item *key, struct crtx_event *event, struct crtx_dict_item *c_entry) {\n\tstruct crtx_event *orig_event;\n\t\n\tprintf(\"in_cache_on_hit\\n\");\n\tif (!strcmp(event->description, \"cortex.socket.response\")) {\n\t\t// find entry, pass/drop\n\t\torig_event = (struct crtx_event*) c_entry->pointer;\n\t\t\n\t\torig_event->response.dict = event->data.dict;\n\t\tevent->data.dict = 0;\n\t\t\n\t\tdereference_event_response(orig_event);\n\t}\n\t\n\treturn 1;\n}\n\nstatic void in_cache_on_miss(struct crtx_cache_task *ct, struct crtx_dict_item *key, struct crtx_event *event) {\n\tif (!strcmp(event->description, \"cortex.socket.response\")) {\n\t\t// drop response\n\t}printf(\"in_cache_on_miss\\n\");\n}\n\nvoid create_in_out_box() {\n\tstruct crtx_graph *graph;\n\tstruct crtx_cache *dc;\n\tstruct crtx_cache_task *ct_out, *ct_in;\n\t\n\t\n\tdc = (struct crtx_cache*) calloc(1, sizeof(struct crtx_cache));\n// \tdc->signature = \"zp\";\n\t\n\t\n\tgraph = crtx_get_graph_for_event_description(CRTX_EVT_INBOX, crtx_evt_inbox);\n\t\n\tct_in = (struct crtx_cache_task*) calloc(1, sizeof(struct crtx_cache_task));\n\tct_in->cache = dc;\n\tct_in->on_hit = &in_cache_on_hit;\n\tct_in->on_miss = &in_cache_on_miss;\n\tct_in->create_key = &in_create_key_cb;\n\tct_in->match_event = &rcache_match_cb_t_strcmp;\n\t\n\tcrtx_create_task(graph, 90, \"response_in_matching\", &response_cache_task, ct_in);\n\t\n\tcrtx_create_task(graph, 200, \"inbox_dispatch_handler\", &inbox_dispatch_handler, 0);\n\t\n\t\n\tgraph = crtx_get_graph_for_event_description(CRTX_EVT_OUTBOX, crtx_evt_outbox);\n\t\n\tct_out = (struct crtx_cache_task*) calloc(1, sizeof(struct crtx_cache_task));\n\tct_out->cache = dc;\n\tct_out->on_hit = &out_cache_on_hit;\n\tct_out->on_miss = &out_cache_on_miss;\n\tct_out->create_key = &out_create_key_cb;\n\tct_out->match_event = &rcache_match_cb_t_strcmp;\n\t\n\tcrtx_create_task(graph, 90, \"response_out_matching\", &response_cache_task, ct_out);\n\t\n// \tcrtx_create_task(graph, 200, \"outbox_dispatch_handler\", &outbox_dispatch_handler, 0);\n}\n\n", "comment_ratio": 0.10320284697508897}
{"lang": "c", "code": "#pragma once\n#define __STDC_LIMIT_MACROS\t// Global macros turning on library features\n#include \"config.h\"\t\t// Standard includes\n#include <stdint.h>\n#include <limits.h>\n#include <string.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <errno.h>\n#if !USE_USTL\n    #include \"utf8.h\"\n#endif\n\n/// Returns the number of elements in a static vector\ntemplate <typename T, size_t N> constexpr static inline size_t ArraySize (T(&)[N]) { return N; }\n/// Returns the end() for a static vector\ntemplate <typename T, size_t N> constexpr static inline T* ArrayEnd (T(&a)[N]) { return &a[N]; }\n/// Expands into a ptr,size expression for the given static vector; useful as link arguments.\n#define ArrayBlock(v)\t&(v)[0], ArraySize(v)\n/// Expands into a begin,end expression for the given static vector; useful for algorithm arguments.\n#define ArrayRange(v)\t&(v)[0], ArrayEnd(v)\n\n// Macros to expand macro values into a string\n#define PP_STRINGIFY(x)\t\t#x\n#define PP_STRINGIFY_I(x)\tPP_STRINGIFY(x)\n\n#define PP_COUNT_ARGS(...)\t\t\\\n    _PP_COUNT_ARGS_COUNT(,##__VA_ARGS__,\\\n\t\t\t  63,62,61,60,\t\\\n\t59,58,57,56,55,54,53,52,51,50,\t\\\n\t49,48,47,46,45,44,43,42,41,40,\t\\\n\t39,38,37,36,35,34,33,32,31,30,\t\\\n\t29,28,27,26,25,24,23,22,21,20,\t\\\n\t19,18,17,16,15,14,13,12,11,10,\t\\\n\t 9, 8, 7, 6, 5, 4, 3, 2, 1, 0\t\\\n    )\n#define _PP_COUNT_ARGS_COUNT(\t\t\t\\\n\t\t\t\ta63,a62,a61,a60,\\\n\ta59,a58,a57,a56,a55,a54,a53,a52,a51,a50,\\\n\ta49,a48,a47,a46,a45,a44,a43,a42,a41,a40,\\\n\ta39,a38,a37,a36,a35,a34,a33,a32,a31,a30,\\\n\ta29,a28,a27,a26,a25,a24,a23,a22,a21,a20,\\\n\ta19,a18,a17,a16,a15,a14,a13,a12,a11,a10,\\\n\ta09,a08,a07,a06,a05,a04,a03,a02,a01,a00,\\\n\tn,...)\t\t\t\t\tn\n\nnamespace {\n// Endian-dependent stuff\n#if USTL_BYTE_ORDER == USTL_LITTLE_ENDIAN\nconstexpr static inline uint16_t vpack2 (uint8_t a, uint8_t b)\n    { return uint16_t(b)<<8|a; }\nconstexpr static inline uint32_t vpack4 (uint16_t a, uint16_t b)\n    { return uint32_t(b)<<16|a; }\nstatic inline void vunpack2 (uint16_t v, uint8_t& a, uint8_t& b)\n    { a = v; b = v>>8; }\nstatic inline void vunpack4 (uint32_t v, uint16_t& a, uint16_t& b)\n    { a = v; b = v>>16; }\nstatic inline void vunpack4 (uint32_t v, uint8_t& a, uint8_t& b, uint8_t& c, uint8_t& d)\n    { a = v; b = v>>8; c = v>>16; d = v>>24; }\nconstexpr static inline uint16_t bole_swap2 (uint16_t v)\n    { return v; }\nconstexpr static inline uint32_t bole_swap4 (uint32_t v)\n    { return v; }\nconstexpr static inline uint64_t bole_swap8 (uint64_t v)\n    { return v; }\n#else\nconstexpr static inline uint16_t vpack2 (uint8_t a, uint8_t b)\n    { return uint16_t(a)<<8|b; }\nconstexpr static inline uint32_t vpack4 (uint16_t a, uint16_t b)\n    { return uint32_t(a)<<16|b; }\nstatic inline void vunpack2 (uint16_t v, uint8_t& a, uint8_t& b)\n    { b = v; a = v>>8; }\nstatic inline void vunpack4 (uint32_t v, uint16_t& a, uint16_t& b)\n    { b = v; a = v>>16; }\nstatic inline void vunpack4 (uint32_t v, uint8_t& a, uint8_t& b, uint8_t& c, uint8_t& d)\n    { d = v; c = v>>8; b = v>>16; a = v>>24; }\nconstexpr static inline uint16_t bole_swap2 (uint16_t v)\n    { return v>>8|v<<8; }\nconstexpr static inline uint32_t bole_swap4 (uint32_t v)\n    { return uint32_t(bole_swap2(v))<<16|bole_swap2(v>>16); }\nconstexpr static inline uint64_t bole_swap8 (uint64_t v)\n    { return uint64_t(bole_swap4(v))<<32|bole_swap4(v>>32); }\n#endif\nconstexpr static inline uint32_t vpack4 (uint8_t a, uint8_t b, uint8_t c, uint8_t d)\n    { return vpack4(vpack2(a,b),vpack2(c,d)); }\n\ninline void UnpackColorToFloats (uint32_t c, float& r, float& g, float& b, float& a)\n{\n    static const float convf = 1.f/255;\n#if __x86_64__\n    asm(\"movd\t%4, %0\\n\\t\"\t// r(c000)\n\t\"xorps\t%1, %1\\n\\t\"\t// g(0000)\n\t\"punpcklbw %1, %0\\n\\t\"\t// c 1->2 expand\n\t\"shufps\t$0, %5, %5\\n\\t\"\t// a(ffff)\n\t\"punpcklwd %1, %0\\n\\t\"\t// c 2->4 expand\n\t\"cvtdq2ps %0, %0\\n\\t\"\t// c to float r(rgba)\n\t\"mulps\t%5, %0\\n\\t\"\t// normalize to 0..1\n\t\"movaps\t%0, %1\\n\\t\"\t// r(rgba) g(rgba)\n\t\"movaps\t%0, %3\\n\\t\"\t// a(rgba)\n\t\"movhlps %0, %2\\n\\t\"\t// b(ba..)\n\t\"shufps\t$1, %1, %1\\n\\t\"\t// g(g...)\n\t\"shufps\t$3, %3, %3\"\t// a(a...)\n\t:\"=x\"(r),\"=x\"(g),\"=x\"(b),\"=x\"(a):\"r\"(c),\"3\"(convf));\n#else\n    uint8_t rb, gb, bb, ab;\n    vunpack4(c,rb,gb,bb,ab);\n    r = rb*convf; g = gb*convf; b = bb*convf; a = ab*convf;\n#endif\n}\n\n} // namespace\n\ninline const char* strnext (const char* s, unsigned& n)\n{\n#if __i386__ || __x86_64__\n    if (!__builtin_constant_p(strlen(s)))\n\tasm(\"repnz\\tscasb\":\"+D\"(s),\"+c\"(n):\"a\"('\\0'));\n    else\n#endif\n\ts+=strlen(s)+1;\n    return s;\n}\n\n#if !USE_USTL\n/// Returns the index of the first set bit in \\p v or \\p nbv if none.\ninline unsigned FirstBit (uint32_t v, unsigned nbv = 0)\n{\n    unsigned n = nbv;\n#if __i386__ || __x86_64__\n    if (!__builtin_constant_p(v)) asm (\"bsr\\t%1, %k0\":\"+r,r\"(n):\"r,m\"(v)); else\n#endif\n#if __GNUC__\n    if (v) n = 31 - __builtin_clz(v);\n#else\n    if (v) for (uint32_t m = uint32_t(1)<<(n=31); !(v & m); m >>= 1) --n;\n#endif\n    return n;\n}\n#endif\n\n/// Dereferencing iterator for containers of pointers\ntemplate <typename I>\nclass dereferencing_iterator {\n    I _i;\npublic:\n#if !USE_USTL\n    using iterator_category\t\t= typename I::iterator_category;\n#endif\n    using iterator_type\t\t\t= I;\n    using difference_type\t\t= typename iterator_traits<iterator_type>::difference_type;\n    using pointer\t\t\t= typename iterator_traits<iterator_type>::value_type;\n    using value_type\t\t\t= typename remove_pointer<pointer>::type;\n    using const_pointer\t\t\t= const value_type*;\n    using reference\t\t\t= value_type&;\n    using const_reference\t\t= const value_type&;\npublic:\n    inline\t\t\t\tdereferencing_iterator (iterator_type i) :_i(i) {}\n    inline iterator_type\t\tbase (void)\t\t{ return _i; }\n    inline const iterator_type&\t\tbase (void) const\t{ return _i; }\n    inline bool\t\t\t\toperator== (const dereferencing_iterator& i) const { return base() == i.base(); }\n    inline bool\t\t\t\toperator!= (const dereferencing_iterator& i) const { return base() != i.base(); }\n    inline bool\t\t\t\toperator< (const dereferencing_iterator& i) const { return base() < i.base(); }\n    inline reference\t\t\toperator* (void)\t{ return **_i; }\n    inline const_reference\t\toperator* (void) const\t{ return **_i; }\n    inline pointer\t\t\toperator-> (void)\t{ return *_i; }\n    inline const_pointer\t\toperator-> (void) const\t{ return *_i; }\n    inline dereferencing_iterator&\toperator++ (void)\t{ ++_i; return *this; }\n    inline dereferencing_iterator&\toperator-- (void)\t{ --_i; return *this; }\n    inline dereferencing_iterator&\toperator+= (int n)\t{ _i += n; return *this; }\n    inline dereferencing_iterator&\toperator-= (int n)\t{ _i -= n; return *this; }\n    inline dereferencing_iterator\toperator+ (int n) const\t{ return dereferencing_iterator(*this) += n; }\n    inline dereferencing_iterator\toperator- (int n) const\t{ return dereferencing_iterator(*this) -= n; }\n    inline difference_type\t\toperator- (const dereferencing_iterator& i)\t{ return base()-i.base(); }\n};\n\ntemplate <typename T>\nclass unique_c_ptr {\npublic:\n    using element_type\t\t= T;\n    using pointer\t\t= element_type*;\n    using reference\t\t= element_type&;\npublic:\n    inline constexpr\t\tunique_c_ptr (void)\t\t: _p (nullptr) {}\n    inline constexpr explicit\tunique_c_ptr (pointer p)\t: _p (p) {}\n    inline\t\t\tunique_c_ptr (unique_c_ptr&& p)\t: _p (p.release()) {}\n\t\t\t\tunique_c_ptr (const unique_c_ptr&) = delete;\n    inline\t\t\t~unique_c_ptr (void)\t\t{ reset(); }\n    inline constexpr pointer\tget (void) const\t\t{ return _p; }\n    inline pointer\t\trelease (void)\t\t\t{ auto rv (_p); _p = nullptr; return rv; }\n    inline void\t\t\treset (pointer p = nullptr)\t{ assert (p != _p || !p); auto ov (_p); _p = p; if (ov) free (ov); }\n    inline void\t\t\trealloc (size_t nsz)\t\t{ _p = (pointer) ::realloc (_p, nsz); }\n    inline void\t\t\tswap (unique_c_ptr& v)\t\t{ swap (_p, v._p); }\n    inline\t\t\toperator const element_type* (void) const\t{ return get(); }\n    inline constexpr explicit\toperator bool (void) const\t{ return _p != nullptr; }\n    inline unique_c_ptr&\toperator= (pointer p)\t\t{ reset (p); return *this; }\n    inline unique_c_ptr&\toperator= (unique_c_ptr&& p)\t{ reset (p.release()); return *this; }\n    unique_c_ptr&\t\toperator=(const unique_c_ptr&) = delete;\n    inline constexpr reference\toperator* (void) const\t\t{ return *_p; }\n    inline constexpr pointer\toperator-> (void) const\t\t{ return _p; }\n    inline constexpr pointer\toperator+ (size_t o) const\t{ return _p+o; }\n    inline constexpr reference\toperator[] (size_t i) const\t{ return _p[i]; }\n    inline constexpr bool\toperator== (const pointer p) const\t{ return _p == p; }\n    inline constexpr bool\toperator== (const unique_c_ptr& p)const\t{ return _p == p._p; }\n    inline constexpr bool\toperator< (const unique_c_ptr& p) const\t{ return _p < p._p; }\nprivate:\n    pointer\t\t\t_p;\n};\n\n#if USE_USTL && USTL_VERSION < 0x230\ntemplate <typename T>\nusing unique_ptr = auto_ptr<T>;\n#endif\n\n", "comment_ratio": 0.12272727272727273}
{"lang": "c", "code": "#import \"NSObject.h\"\n\n#import \"PPNamedEntityReadOnlyServerProtocol.h\"\n\n@class NSString, PPXPCServerPipelinedBatchQueryManager, _PASBundleIdResolver;\n\n@interface PPNamedEntityReadOnlyServerRequestHandler : NSObject <PPNamedEntityReadOnlyServerProtocol>\n{\n    id <PPNamedEntityClientProtocol> _clientProxy;\n    PPXPCServerPipelinedBatchQueryManager *_queryManager;\n    NSString *_clientProcessName;\n    _PASBundleIdResolver *_bundleIdResolver;\n}\n\n@property(retain, nonatomic) _PASBundleIdResolver *bundleIdResolver; // @synthesize bundleIdResolver=_bundleIdResolver;\n@property(copy, nonatomic) NSString *clientProcessName; // @synthesize clientProcessName=_clientProcessName;\n- (void).cxx_destruct;\n- (void)registerFeedback:(id)arg1 completion:(CDUnknownBlockType)arg2;\n- (void)mapItemForPlaceName:(id)arg1 completion:(CDUnknownBlockType)arg2;\n- (void)namedEntityRecordsWithQuery:(id)arg1 queryId:(unsigned long long)arg2;\n- (void)rankedNamedEntitiesWithQuery:(id)arg1 queryId:(unsigned long long)arg2;\n- (void)setRemoteObjectProxy:(id)arg1;\n- (void)unblockPendingQueries;\n- (id)init;\n\n@end\n\n\n", "comment_ratio": 0.20588235294117646}
{"lang": "c", "code": "#ifndef DEFINITIONS_H_\n#define DEFINITIONS_H_\n\n#define ARRAY_LEN 30000\n#define PI_LEN_MIN 10000\n#define PI_LEN_MAX 100000\n#define MATRIX_SIZE 800\n\n#endif // DEFINITIONS_H_\n", "comment_ratio": 0.1111111111111111}
{"lang": "c", "code": "#ifndef INDEX_H_INCLUDED\n#define INDEX_H_INCLUDED\n\n#ifdef _MSC_VER\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <time.h>\n#include <string>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <deque>\n#include <string.h>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n\nusing namespace std;\n\ntypedef int wtype; //data type for edge weight and budget.\ntypedef float decmtype; //data type for feature rating, keyword preference weight, threshold.\n\n\n/***Structure Definitions************************/\nstruct Hop2Label {\n\tint ancid;  // the pivot node id\n\twtype dist; // the distance from the source node to the pivot node\n\n\tHop2Label(int aid, wtype dis) {\n\t\tancid = aid;\n\t\tdist = dis;\n\t}\n};\n\nstruct FtrNodePair{\n\tint nodeId;  //POI id having this feature\n\tdecmtype ftrVal; //feature value on this feature\n\n\tFtrNodePair(int nid, decmtype val){\n\t\tnodeId = nid;\n\t\tftrVal = val;\n\t}\n};\n\ntypedef unordered_map<int, vector<FtrNodePair> > KwdsMap; //for FI index: <keyword_id, list of nodes having this feature>\n\n\nstruct UserQuery{\n\tint startPOI;\n\tint endPOI;\n\twtype budget;\n\tdecmtype thres;  //threshold for feature value, i.e., theta\n\tvector <int> keywds;\n\tvector<decmtype> keywds_weights;\n\tdecmtype alpha;  //can change to a vector of alpha if we want to specify different alpha for each feature\n\n\tUserQuery(int sid, int eid, wtype b, decmtype thr, vector<int> kwds, vector<decmtype> kwds_wt, decmtype al){\n\t\tstartPOI = sid;\n\t\tendPOI = eid;\n\t\tbudget = b;\n\t\tthres = thr;\n\t\tkeywds = kwds;\n\t\tkeywds_weights = kwds_wt;\n\t\talpha = al;\n\t}\n};\n\n\n/***Global variables Declaration************************/\nextern string root;  //directory of the dataset\nextern long long node_num;\t//number of POI\nextern vector<vector<Hop2Label> > HI_orig; // HI index: stores the list of 2 hop labels for each POI\nextern KwdsMap FI; //FI index\nextern vector< vector<decmtype> > POIFtMx;  // POI-Feature  matrix\nextern int fSpaceSz; //feature space size\nextern vector<wtype> stayTimeVec;   //A more general graph can use double\nextern wtype **travelTime; // 2-d matrix for pair-wise least traveling cost\nextern wtype INF; //a large enough integer\nextern vector<wtype> nodeCost;  //each cost equals to stay cost + the cost of (min_in_edge + min_out_edge)/2, used for upper bound estimation\nextern vector<wtype> tourCostsVec; //each cost equals to travelTime[source][i] + stay cost of i + travelTime[i][destination], only useful in the Greedy algorithm\n\n\n//Parameters for each trip query, defined as globals for easy access across files\nextern int g_startNode;\nextern int g_endNode;\nextern wtype g_budget;\nextern decmtype g_val_thres;\nextern vector<int> g_kwds;\nextern vector<decmtype> g_kwds_wts;\nextern decmtype g_alpha;  //power law factor.  if 0, simply sum; if very large, simply max\nextern vector<double> PLCoeff; //diminishing factor vector\n\nextern int g_s_pos, g_t_pos; //the cut-off positions for source and destination POIs\nextern unordered_map<int, int> HI_Q_Pos; //subindex HI_Q, but we only record the cut-off positions of HI, instead of storing the labels again\nextern wtype **cmptdPair; // matrix for optimizing the distance computation, records the threshold less than which remaining budget the pair is not reachable\n\n/***Functions Declaration************************/\nbool LbAscend(Hop2Label label1, Hop2Label label2); //sort the 2-hop labels in ascending order as distance\nvoid LoadHop2Labels(string labelFileStr, string remainFileStr); //use the data structure and functions in io_ud.h\nvoid PrintHop2Labels(string of_str);\nint LoadLocationKeywords(string poiKwdsFileStr);\nint LoadInvertedKeywords(string ivtKwdsFileStr);\nint LoadStayTime(string stayFileStr);\nvoid LoadInputs(string data_header);\nvoid initPowerLaw(decmtype param); //compute the diminishing factors for each rank\nwtype CompTransitCost(int sId, int t_Id, int s_pos, int t_pos);  //least traveling cost computation\nint TruncateHop2Label(vector<Hop2Label>& inputLabel, wtype bdgt); //truncate 2-hop labels by budget to speed up traveling cost computation\nint RetrieveCandidates(UserQuery uq);\n\n\n#endif // INDEX_H_INCLUDED\n\n", "comment_ratio": 0.2644628099173554}
{"lang": "c", "code": "\ufeff#pragma once\n\n#include \"il2cpp-config.h\"\n\n#ifndef _MSC_VER\n# include <alloca.h>\n#else\n# include <malloc.h>\n#endif\n\n#include <stdint.h>\n#include <assert.h>\n#include <exception>\n\n\n#include \"codegen/il2cpp-codegen.h\"\n\n// System.Int32 System.Console/WindowsConsole::GetConsoleCP()\nextern \"C\"  int32_t WindowsConsole_GetConsoleCP_m940514957 (Il2CppObject * __this /* static, unused */, const MethodInfo* method) IL2CPP_METHOD_ATTR;\n// System.Int32 System.Console/WindowsConsole::GetConsoleOutputCP()\nextern \"C\"  int32_t WindowsConsole_GetConsoleOutputCP_m12691438 (Il2CppObject * __this /* static, unused */, const MethodInfo* method) IL2CPP_METHOD_ATTR;\n// System.Int32 System.Console/WindowsConsole::GetInputCodePage()\nextern \"C\" IL2CPP_NO_INLINE int32_t WindowsConsole_GetInputCodePage_m43304463 (Il2CppObject * __this /* static, unused */, const MethodInfo* method) IL2CPP_METHOD_ATTR;\n// System.Int32 System.Console/WindowsConsole::GetOutputCodePage()\nextern \"C\" IL2CPP_NO_INLINE int32_t WindowsConsole_GetOutputCodePage_m2831997558 (Il2CppObject * __this /* static, unused */, const MethodInfo* method) IL2CPP_METHOD_ATTR;\n\n", "comment_ratio": 0.15384615384615385}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n#import <UIKit/UIKit.h>\n\n\nNS_ASSUME_NONNULL_BEGIN\n\n/// \u57fa\u7c7b\n@interface SHRouterRequest : NSObject\n\n/// \u4f20\u503c\n@property(nonatomic, copy) NSDictionary *parameters;\n\n/// \u6e90\u63a7\u5236\u5668\n@property(nonatomic, strong) UIViewController *sourceVC;\n\n@end\n\n\n/// url\u7c7b\n@interface SHRouterURLRequest : SHRouterRequest\n\n// The url to jump. the url's priority is higher than strUrl.\n@property(nonatomic, copy) NSURL *url;\n\n// The string url to jump.\n@property(nonatomic, copy) NSString *strUrl;\n\n- (instancetype)initWithURL:(NSURL *)url;\n\n@end\n\n\n/// param\u8bf7\u6c42\u7c7b\n@interface SHRouterActionRequest : SHRouterRequest\n\n// The scheme to jump.\n@property(nonatomic, copy) NSString *scheme;\n\n// The host to jump.\n@property(nonatomic, copy) NSString *host;\n\n- (instancetype)initWithScheme:(NSString *)scheme host:(NSString *)host;\n\n- (instancetype)initWithScheme:(NSString *)scheme host:(NSString *)host parameters:(NSDictionary *)parameters;\n\n@end\nNS_ASSUME_NONNULL_END\n\n", "comment_ratio": 0.2857142857142857}
{"lang": "c", "code": "#include<config.h>\nCPS_START_NAMESPACE\n//------------------------------------------------------------------------------\n//\n// alg_rect.h\n//\n// Header file for the AlgRect class.\n//\n// AlgRect is derived from Alg and it measures the average\n// value of the rectangle, the 1x2 planar Wilson loop.\n//\n//------------------------------------------------------------------------------\n\n#ifndef INCLUDED_ALG_RECT_H\n#define INCLUDED_ALG_RECT_H\n\nCPS_END_NAMESPACE\n#include <util/lattice.h>\n#include <util/smalloc.h>\n#include <util/pmalloc.h>\n#include <alg/alg_base.h>\n#include <alg/common_arg.h>\n#include <alg/no_arg.h>\nCPS_START_NAMESPACE\n\nclass AlgRect : public Alg\n{\n private:\n    char *cname;\n\n    NoArg *alg_rect_arg;\n        // The argument structure for the rectangle\n \n    Float norm_fac;       \n        // normalization factor\n\n public:\n    AlgRect(Lattice & latt, CommonArg *c_arg, NoArg *arg);\n\n    virtual ~AlgRect();\n\n    void run(void);\n};\n\n#endif\n\nCPS_END_NAMESPACE\n\n", "comment_ratio": 0.25}
{"lang": "c", "code": "#pragma once\n\n#include \"mfx_common.h\"\n#if defined(MFX_ENABLE_AV1_VIDEO_ENCODE)\n\n#include \"mfxvideo.h\"\n\n#include \"mfxbrc.h\"\n#include \"mfx_ext_buffers.h\"\n#include \"mfxav1.h\"\n\n#include \"mfxvideo++int.h\"\n\n#include \"mfx_utils_logging.h\"\n#include \"mfx_utils_extbuf.h\"\n\n#include \"feature_blocks/mfx_feature_blocks_init_macros.h\"\n#include \"feature_blocks/mfx_feature_blocks_base.h\"\n#include \"av1ehw_utils.h\"\n#include \"av1eimplbase.h\"\n\nnamespace AV1EHW\n{\nusing namespace MfxFeatureBlocks;\n\nnamespace ExtBuffer\n{\n    using namespace MfxExtBuffer;\n}\n\nstruct FeatureBlocks\n    : FeatureBlocksCommon<BlockTracer>\n{\nMFX_FEATURE_BLOCKS_DECLARE_BQ_UTILS_IN_FEATURE_BLOCK\n#define DEF_BLOCK_Q MFX_FEATURE_BLOCKS_DECLARE_QUEUES_IN_FEATURE_BLOCK\n    #include \"av1ehw_block_queues.h\"\n#undef DEF_BLOCK_Q\n\n    virtual const char* GetFeatureName(mfxU32 featureID) override;\n    virtual const char* GetBlockName(ID id) override;\n\n    std::map<mfxU32, const BlockTracer::TFeatureTrace*> m_trace;\n};\n\n#define DEF_BLOCK_Q MFX_FEATURE_BLOCKS_DECLARE_QUEUES_EXTERNAL\n    #include \"av1ehw_block_queues.h\"\n#undef DEF_BLOCK_Q\n\nclass FeatureBase\n    : public FeatureBaseCommon<FeatureBlocks>\n{\npublic:\n    FeatureBase() = delete;\n    virtual ~FeatureBase() {}\n\n    virtual void Init(\n        mfxU32 mode/*eFeatureMode*/\n        , FeatureBlocks& blocks) override;\n\nprotected:\n#define DEF_BLOCK_Q MFX_FEATURE_BLOCKS_DECLARE_QUEUES_IN_FEATURE_BASE\n#include \"av1ehw_block_queues.h\"\n#undef DEF_BLOCK_Q\n    typedef TPushQ1NC TPushQ1;\n\n    FeatureBase(mfxU32 id)\n        : FeatureBaseCommon<FeatureBlocks>(id)\n    {}\n\n    virtual const BlockTracer::TFeatureTrace* GetTrace() { return nullptr; }\n    virtual void SetTraceName(std::string&& /*name*/) {}\n};\n\n}; //namespace AV1EHW\n\n#endif\n\n", "comment_ratio": 0.20618556701030927}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n\n@interface UIView (LSCore)\n\n\n#pragma mark - \u8bbe\u7f6e\u90e8\u5206\u5706\u89d2\n/**\n *  \u8bbe\u7f6e\u90e8\u5206\u5706\u89d2(\u7edd\u5bf9\u5e03\u5c40)\n *\n *  @param corners \u9700\u8981\u8bbe\u7f6e\u4e3a\u5706\u89d2\u7684\u89d2 UIRectCornerTopLeft | UIRectCornerTopRight | UIRectCornerBottomLeft | UIRectCornerBottomRight | UIRectCornerAllCorners\n *  @param radii   \u9700\u8981\u8bbe\u7f6e\u7684\u5706\u89d2\u5927\u5c0f \u4f8b\u5982 CGSizeMake(20.0f, 20.0f)\n */\n- (void)addRoundedCorners:(UIRectCorner)corners\n                withRadii:(CGSize)radii;\n/**\n *  \u8bbe\u7f6e\u90e8\u5206\u5706\u89d2(\u76f8\u5bf9\u5e03\u5c40)\n *\n *  @param corners \u9700\u8981\u8bbe\u7f6e\u4e3a\u5706\u89d2\u7684\u89d2 UIRectCornerTopLeft | UIRectCornerTopRight | UIRectCornerBottomLeft | UIRectCornerBottomRight | UIRectCornerAllCorners\n *  @param radii   \u9700\u8981\u8bbe\u7f6e\u7684\u5706\u89d2\u5927\u5c0f \u4f8b\u5982 CGSizeMake(20.0f, 20.0f)\n *  @param rect    \u9700\u8981\u8bbe\u7f6e\u7684\u5706\u89d2view\u7684rect\n */\n- (void)addRoundedCorners:(UIRectCorner)corners\n                withRadii:(CGSize)radii\n                 viewRect:(CGRect)rect;\n\n\n@end\n\n", "comment_ratio": 0.19444444444444445}
{"lang": "c", "code": "#ifndef STORAGEKEYBUILDER_H\n#define STORAGEKEYBUILDER_H\n\n#include <string>\n\nnamespace TailProduce {\n    // StorageKeyBuilder implements the BuildStorageKey function to convert\n    // { stream name, typed order key, secondary key } into ::TailProduce::Storage::KEY_TYPE-s.\n    template <typename T> struct StorageKeyBuilder {\n        typedef typename T::order_key_type order_key_type;\n        typedef typename T::head_pair_type head_pair_type;\n        explicit StorageKeyBuilder(const std::string& stream_name)\n            : head_storage_key(\"s:\" + stream_name),\n              prefix(\"d:\" + stream_name + \":\"),\n              end_stream_key(\"d:\" + stream_name + \":\\xff\") {\n            using TOK = ::TailProduce::OrderKey;\n            static_assert(std::is_base_of<TOK, order_key_type>::value,\n                          \"StorageKeyBuilder: T::order_key_type should be derived from OrderKey.\");\n        }\n        ::TailProduce::Storage::KEY_TYPE BuildStorageKey(const head_pair_type& key) const {\n            ::TailProduce::Storage::KEY_TYPE storage_key = prefix;\n            OrderKey::template StaticAppendAsStorageKey<order_key_type>(key.first, key.second, storage_key);\n            return storage_key;\n        }\n        static head_pair_type ParseStorageKey(::TailProduce::Storage::KEY_TYPE const& storage_key) {\n            // TODO(dkorolev): This secondary key implementation as fixed 10 bytes is not final.\n            const size_t expected_size = order_key_type::size_in_bytes + 1 + 10;\n            if (storage_key.size() != expected_size) {\n                VLOG(2) << \"Malformed key: input length \" << storage_key.size() << \", expected length \"\n                        << expected_size << \".\";\n                VLOG(3) << \"throw MalformedStorageHeadException();\";\n                throw MalformedStorageHeadException();\n            }\n            head_pair_type key;\n            key.first.DeSerializeOrderKey(storage_key);\n            // const char* p = reinterpret_cast<const char*>(&storage_key[order_key_type::size_in_bytes + 1]);\n            const char* p = storage_key.substr(storage_key.length() - 10).data();\n            if (sscanf(p, \"%u\", &key.second) != 1) {\n                VLOG(2) << \"Malformed key: cannot parse the secondary key '\"\n                        << std::string(p, reinterpret_cast<const char*>(&storage_key[0]) + storage_key.size()) << \"'\"\n                        << \" from '\" << storage_key << \".'\";\n                VLOG(3) << \"throw MalformedStorageHeadException();\";\n                throw MalformedStorageHeadException();\n            }\n            const ::TailProduce::Storage::KEY_TYPE golden =\n                OrderKey::template StaticSerializeAsStorageKey<typename T::order_key_type>(key.first, key.second);\n\n            if (storage_key != golden) {\n                VLOG(2) << \"Malformed key: input '\" << storage_key << \"', \"\n                        << \"re-generated: '\" << golden << \"'.\";\n                VLOG(3) << \"throw MalformedStorageHeadException();\";\n                throw MalformedStorageHeadException();\n            }\n            return key;\n        }\n        StorageKeyBuilder() = delete;\n        // StorageKeyBuilder(const StorageKeyBuilder&) = delete;  TODO(dkorolev): Uncomment this line.\n        // StorageKeyBuilder(StorageKeyBuilder&&) = delete;  TODO(dkorolev): Uncomment this line.\n        // void operator=(const StorageKeyBuilder&) = delete;  TODO(dkorolev): Uncomment this line.\n        ::TailProduce::Storage::KEY_TYPE const head_storage_key;\n        ::TailProduce::Storage::KEY_TYPE const prefix;\n        ::TailProduce::Storage::KEY_TYPE const end_stream_key;\n    };\n};\n\n#endif\n\n", "comment_ratio": 0.1044776119402985}
{"lang": "c", "code": "@class NSString, NSArray;\n\n@interface WFScanRequest : NSObject {\n\n\tBOOL _applyRssiThresholdFilter;\n\tNSString* _ssid;\n\tunsigned long long _dwellTime;\n\tNSArray* _channels;\n\tlong long _rssiThreshold;\n\n}\n\n@property (nonatomic,copy) NSString * ssid;                        //@synthesize ssid=_ssid - In the implementation block\n@property (nonatomic,retain) NSArray * channels;                   //@synthesize channels=_channels - In the implementation block\n@property (assign,nonatomic) long long rssiThreshold;              //@synthesize rssiThreshold=_rssiThreshold - In the implementation block\n@property (assign) BOOL applyRssiThresholdFilter;                  //@synthesize applyRssiThresholdFilter=_applyRssiThresholdFilter - In the implementation block\n@property (assign) unsigned long long dwellTime;                   //@synthesize dwellTime=_dwellTime - In the implementation block\n+(id)scanRequestForSSID:(id)arg1 channels:(id)arg2 ;\n+(id)scanRequestForChannels:(id)arg1 ;\n-(void)setDwellTime:(unsigned long long)arg1 ;\n-(unsigned long long)dwellTime;\n-(void)setSsid:(NSString *)arg1 ;\n-(void)setChannels:(NSArray *)arg1 ;\n-(void)setRssiThreshold:(long long)arg1 ;\n-(long long)rssiThreshold;\n-(id)scanParameters;\n-(void)setApplyRssiThresholdFilter:(BOOL)arg1 ;\n-(id)initWithSSID:(id)arg1 channels:(id)arg2 ;\n-(id)_defaultScanDictionary;\n-(BOOL)applyRssiThresholdFilter;\n-(id)_channelListFromArrayOfChannels:(id)arg1 ;\n-(NSString *)ssid;\n-(id)init;\n-(id)description;\n-(NSArray *)channels;\n@end\n\n\n", "comment_ratio": 0.10638297872340426}
{"lang": "c", "code": "#pragma once\n#include <GRUT.h>\n\nusing namespace GRUT::Math;\n\nclass Test : public GRUT::Component {\n    public:\n        float totalDelta = 0.0f;\n\n        void Initialize() override {\n            //DEBUG_DRAW_LINE(gameObject->transform->GetPosition(), gameObject->transform->GetPosition() + Vector<3>(2.0f, 0.0f, 0.0f), Vector<3>(0.0f, 1.0f, 0.0f));\n        }\n\n        void Update(float p_deltaTime) override {\n            //totalDelta += p_deltaTime;\n            //DEBUG_DRAW_LINE(gameObject->transform->GetPosition(), gameObject->transform->GetPosition() + Vector<3>(1.0f, 1.0f, 0.0f), Vector<3>(1.0f, 1.0f, 0.0f));\n            //DEBUG_DRAW_BOX(gameObject->transform->GetPosition(), Vector<3>(1.0f, 1.0f, 1.0f), Vector<3>(0.0f, 0.0f, 0.0f), Vector<3>(0.0f, 0.95f, 0.2f));\n        }\n};\n", "comment_ratio": 0.21052631578947367}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n\n@class UPBezierPathView;\n@class UPControl;\n@class UPGameTimer;\n@class UPGameTimerLabel;\n@class UPLabel;\n@class UPPulseView;\n\n@interface UPSpellGameView : UIView\n@property (nonatomic) UIView *tileContainerView;\n@property (nonatomic) UPControl *wordTrayControl;\n@property (nonatomic) UPControl *pauseControl;\n@property (nonatomic) UPControl *clearControl;\n@property (nonatomic) UPGameTimerLabel *timerLabel;\n@property (nonatomic) UPLabel *gameScoreLabel;\n@property (nonatomic) UPLabel *wordScoreLabel;\n@property (nonatomic) UPPulseView *pulseView;\n@property (nonatomic, readonly) NSArray<UIView *> *interactiveSubviews;\n\n+ (UPSpellGameView *)instance;\n\n- (instancetype)init;\n- (instancetype)initWithFrame:(CGRect)frame NS_UNAVAILABLE;\n\n@end\n\n", "comment_ratio": 0.125}
{"lang": "c", "code": "#ifndef __AnimationState_H__\n#define __AnimationState_H__\n\n#include \"OgrePrerequisites.h\"\n\n#include \"OgreCommon.h\"\n#include \"OgreController.h\"\n#include \"OgreControllerManager.h\"\n#include \"Threading/OgreThreadHeaders.h\"\n#include \"OgreHeaderPrefix.h\"\n\nnamespace Ogre {\n\n    template <typename T> class MapIterator;\n    template <typename T> class ConstMapIterator;\n    template <typename T> class ConstVectorIterator;\n\n    /** \\addtogroup Core\n    *  @{\n    */\n    /** \\addtogroup Animation\n    *  @{\n    */\n\n    /** Represents the state of an animation and the weight of its influence. \n    @remarks\n        Other classes can hold instances of this class to store the state of any animations\n        they are using.\n    */\n    class _OgreExport AnimationState : public AnimationAlloc\n    {\n    public:\n\n        /// Typedef for an array of float values used as a bone blend mask\n        typedef std::vector<float> BoneBlendMask;\n\n        /** Normal constructor with all params supplied\n            @param\n                animName The name of this state.\n            @param\n                parent The parent AnimationStateSet that this state will belong to.\n            @param\n                timePos The position, in seconds, where this state will begin.\n            @param\n                length The length, in seconds, of this animation state.\n            @param\n                weight Weight to apply the animation state with.\n            @param\n                enabled Whether the animation state is enabled.\n        */\n        AnimationState(const String& animName, AnimationStateSet *parent, \n            Real timePos, Real length, Real weight = 1.0, bool enabled = false);\n        /// Constructor to copy from an existing state with new parent\n        AnimationState(AnimationStateSet* parent, const AnimationState &rhs);\n        \n        /// Gets the name of the animation to which this state applies\n        const String& getAnimationName() const;\n        /// Gets the time position for this animation\n        Real getTimePosition(void) const;\n        /// Sets the time position for this animation\n        void setTimePosition(Real timePos);\n        /// Gets the total length of this animation (may be shorter than whole animation)\n        Real getLength() const;\n        /// Sets the total length of this animation (may be shorter than whole animation)\n        void setLength(Real len);\n        /// Gets the weight (influence) of this animation\n        Real getWeight(void) const;\n        /// Sets the weight (influence) of this animation\n        void setWeight(Real weight);\n        /** Modifies the time position, adjusting for animation length\n        @param offset The amount of time, in seconds, to extend the animation.\n        @remarks\n            This method loops at the edges if animation looping is enabled.\n        */\n        void addTime(Real offset);\n\n        /// Returns true if the animation has reached the end and is not looping\n        bool hasEnded(void) const;\n\n        /// Returns true if this animation is currently enabled\n        bool getEnabled(void) const;\n        /// Sets whether this animation is enabled\n        void setEnabled(bool enabled);\n\n        /// Equality operator\n        bool operator==(const AnimationState& rhs) const;\n        /// Inequality operator\n        bool operator!=(const AnimationState& rhs) const;\n\n        /** Sets whether or not an animation loops at the start and end of\n            the animation if the time continues to be altered.\n        */\n        void setLoop(bool loop) { mLoop = loop; }\n        /// Gets whether or not this animation loops            \n        bool getLoop(void) const { return mLoop; }\n     \n        /** Copies the states from another animation state, preserving the animation name\n        (unlike operator=) but copying everything else.\n        @param animState Reference to animation state which will use as source.\n        */\n        void copyStateFrom(const AnimationState& animState);\n\n        /// Get the parent animation state set\n        AnimationStateSet* getParent(void) const { return mParent; }\n\n      /** @brief Create a new blend mask with the given number of entries\n       *\n       * In addition to assigning a single weight value to a skeletal animation,\n       * it may be desirable to assign animation weights per bone using a 'blend mask'.\n       *\n       * @param blendMaskSizeHint \n       *   The number of bones of the skeleton owning this AnimationState.\n       * @param initialWeight\n       *   The value all the blend mask entries will be initialised with (negative to skip initialisation)\n       */\n      void createBlendMask(size_t blendMaskSizeHint, float initialWeight = 1.0f);\n      /// Destroy the currently set blend mask\n      void destroyBlendMask();\n      /** @brief Set the blend mask data (might be dangerous)\n       *\n       * @par The size of the array should match the number of entries the\n       *      blend mask was created with.\n       *\n       * @par Stick to the setBlendMaskEntry method if you don't know exactly what you're doing.\n       */\n      void _setBlendMaskData(const float* blendMaskData);\n      /** @brief Set the blend mask\n       *\n       * @par The size of the array should match the number of entries the\n       *      blend mask was created with.\n       *\n       * @par Stick to the setBlendMaskEntry method if you don't know exactly what you're doing.\n       */\n      void _setBlendMask(const BoneBlendMask* blendMask);\n      /// Get the current blend mask (const version, may be 0) \n      const BoneBlendMask* getBlendMask() const {return mBlendMask;}\n      /// Return whether there is currently a valid blend mask set\n      bool hasBlendMask() const {return mBlendMask != 0;}\n      /// Set the weight for the bone identified by the given handle\n      void setBlendMaskEntry(size_t boneHandle, float weight);\n      /// Get the weight for the bone identified by the given handle\n      inline float getBlendMaskEntry(size_t boneHandle) const\n      {\n          assert(mBlendMask && mBlendMask->size() > boneHandle);\n          return (*mBlendMask)[boneHandle];\n      }\n    private:\n        /// The blend mask (containing per bone weights)\n        BoneBlendMask* mBlendMask;\n\n        String mAnimationName;\n        AnimationStateSet* mParent;\n        Real mTimePos;\n        Real mLength;\n        Real mWeight;\n        bool mEnabled;\n        bool mLoop;\n\n    };\n\n    // A map of animation states\n    typedef std::map<String, AnimationState*> AnimationStateMap;\n    typedef MapIterator<AnimationStateMap> AnimationStateIterator;\n    typedef ConstMapIterator<AnimationStateMap> ConstAnimationStateIterator;\n    // A list of enabled animation states\n    typedef std::list<AnimationState*> EnabledAnimationStateList;\n    typedef ConstVectorIterator<EnabledAnimationStateList> ConstEnabledAnimationStateIterator;\n\n    /** Class encapsulating a set of AnimationState objects.\n    */\n    class _OgreExport AnimationStateSet : public AnimationAlloc\n    {\n    public:\n        /// Mutex, public for external locking if needed\n            OGRE_AUTO_MUTEX;\n        /// Create a blank animation state set\n        AnimationStateSet();\n        /// Create an animation set by copying the contents of another\n        AnimationStateSet(const AnimationStateSet& rhs);\n\n        ~AnimationStateSet();\n\n        /** Create a new AnimationState instance. \n        @param animName The name of the animation\n        @param timePos Starting time position\n        @param length Length of the animation to play\n        @param weight Weight to apply the animation with \n        @param enabled Whether the animation is enabled\n        */\n        AnimationState* createAnimationState(const String& animName,  \n            Real timePos, Real length, Real weight = 1.0, bool enabled = false);\n        /// Get an animation state by the name of the animation\n        AnimationState* getAnimationState(const String& name) const;\n        /// Tests if state for the named animation is present\n        bool hasAnimationState(const String& name) const;\n        /// Remove animation state with the given name\n        void removeAnimationState(const String& name);\n        /// Remove all animation states\n        void removeAllAnimationStates(void);\n\n        /** Get an iterator over all the animation states in this set.\n        @deprecated use getAnimationStates()\n        */\n        AnimationStateIterator getAnimationStateIterator(void);\n        /** Get an iterator over all the animation states in this set.\n        @deprecated use getAnimationStates()\n        */\n        OGRE_DEPRECATED ConstAnimationStateIterator getAnimationStateIterator(void) const;\n\n        /** Get all the animation states in this set.\n        @note\n            This method is not threadsafe,\n            you will need to manually lock the public mutex on this\n            class to ensure thread safety if you need it.\n        */\n        const AnimationStateMap& getAnimationStates() const {\n            return mAnimationStates;\n        }\n\n        /// Copy the state of any matching animation states from this to another\n        void copyMatchingState(AnimationStateSet* target) const;\n        /// Set the dirty flag and dirty frame number on this state set\n        void _notifyDirty(void);\n        /// Get the latest animation state been altered frame number\n        unsigned long getDirtyFrameNumber(void) const { return mDirtyFrameNumber; }\n\n        /// Internal method respond to enable/disable an animation state\n        void _notifyAnimationStateEnabled(AnimationState* target, bool enabled);\n        /// Tests if exists enabled animation state in this set\n        bool hasEnabledAnimationState(void) const { return !mEnabledAnimationStates.empty(); }\n        /** Get an iterator over all the enabled animation states in this set\n        @deprecated use getEnabledAnimationStates()\n        */\n        OGRE_DEPRECATED ConstEnabledAnimationStateIterator getEnabledAnimationStateIterator(void) const;\n\n        /** Get an iterator over all the enabled animation states in this set\n        @note\n            The iterator returned from this method is not threadsafe,\n            you will need to manually lock the public mutex on this\n            class to ensure thread safety if you need it.\n        */\n        const EnabledAnimationStateList& getEnabledAnimationStates() const {\n            return mEnabledAnimationStates;\n        }\n\n    private:\n        unsigned long mDirtyFrameNumber;\n        AnimationStateMap mAnimationStates;\n        EnabledAnimationStateList mEnabledAnimationStates;\n\n    };\n\n    /** ControllerValue wrapper class for AnimationState.\n    @remarks\n        In Azathoth and earlier, AnimationState was a ControllerValue but this\n        actually causes memory problems since Controllers delete their values\n        automatically when there are no further references to them, but AnimationState\n        is deleted explicitly elsewhere so this causes double-free problems.\n        This wrapper acts as a bridge and it is this which is destroyed automatically.\n    */\n    class _OgreExport AnimationStateControllerValue : public ControllerValue<Real>\n    {\n    private:\n        AnimationState* mTargetAnimationState;\n        bool mAddTime;\n    public:\n        /// @deprecated use create instead\n        AnimationStateControllerValue(AnimationState* targetAnimationState, bool addTime = false)\n            : mTargetAnimationState(targetAnimationState), mAddTime(addTime) {}\n\n        /**\n         * create an instance of this class\n         * @param targetAnimationState\n         * @param addTime if true, increment time instead of setting to an absolute position\n         */\n        static ControllerValueRealPtr create(AnimationState* targetAnimationState, bool addTime = false);\n\n        /** ControllerValue implementation. */\n        Real getValue(void) const\n        {\n            return mTargetAnimationState->getTimePosition() / mTargetAnimationState->getLength();\n        }\n\n        /** ControllerValue implementation. */\n        void setValue(Real value)\n        {\n            if(mAddTime)\n                mTargetAnimationState->addTime(value);\n            else\n                mTargetAnimationState->setTimePosition(value * mTargetAnimationState->getLength());\n        }\n    };\n\n    /** @} */   \n    /** @} */\n}\n\n#include \"OgreHeaderSuffix.h\"\n\n#endif\n\n\n", "comment_ratio": 0.11515151515151516}
{"lang": "c", "code": "#ifndef BGEO_PARSER_VERTEX_MAP_H\n#define BGEO_PARSER_VERTEX_MAP_H\n\n#include <UT/UT_JSONParser.h>\n\nnamespace ika\n{\nnamespace bgeo\n{\nnamespace parser\n{\n\nclass VertexMap\n{\npublic:\n    VertexMap();\n    ~VertexMap();\n\n    void load(UT_JSONParser& parser, int64 vertexCount);\n\n    int32* vertices;\n    int64 vertexCount;\n\n    friend std::ostream& operator << (std::ostream& co, const VertexMap& map);\n};\n\n} // namespace parser\n} // namespace bgeo\n} // namespace ika\n\n#endif // BGEO_PARSER_VERTEX_MAP_H\n\n", "comment_ratio": 0.14634146341463414}
{"lang": "c", "code": "#include \"ruby.h\"\n#include <ctype.h>\n\nstatic VALUE rb_cGeoHash;\n\n#define BASE32\t\"0123456789bcdefghjkmnpqrstuvwxyz\"\n\nstatic void decode_geohash_bbox(char *geohash, double *lat, double *lon) {\n\tint i, j, hashlen;\n\tdouble lat_err, lon_err;\n\tchar c, cd, mask, is_even=1;\n\tstatic char bits[] = {16,8,4,2,1};\n\t\n\tlat[0] = -90.0;  lat[1] = 90.0;\n\tlon[0] = -180.0; lon[1] = 180.0;\n\tlat_err = 90.0;  lon_err = 180.0;\n\thashlen = strlen(geohash);\n\t\n\tfor (i=0; i<hashlen; i++) {\n\t\tc = tolower(geohash[i]);\n\t\tcd = strchr(BASE32, c)-BASE32;\n\t\tfor (j=0; j<5; j++) {\n\t\t\tmask = bits[j];\n\t\t\tif (is_even) {\n\t\t\t\tlon_err /= 2;\n\t\t\t\tlon[!(cd&mask)] = (lon[0] + lon[1])/2;\n\t\t\t} else {\n\t\t\t\tlat_err /= 2;\n\t\t\t\tlat[!(cd&mask)] = (lat[0] + lat[1])/2;\n\t\t\t}\n\t\t\tis_even = !is_even;\n\t\t}\n\t}\n}\n\nstatic void decode_geohash(char *geohash, double *point) {\n\tdouble lat[2], lon[2];\n\n\tdecode_geohash_bbox(geohash, lat, lon);\n\n\tpoint[0] = (lat[0] + lat[1]) / 2;\n\tpoint[1] = (lon[0] + lon[1]) / 2;\n}\n\nstatic void encode_geohash(double latitude, double longitude, int precision, char *geohash) {\n\tint is_even=1, i=0;\n\tdouble lat[2], lon[2], mid;\n\tchar bits[] = {16,8,4,2,1};\n\tint bit=0, ch=0;\n\n\tlat[0] = -90.0;  lat[1] = 90.0;\n\tlon[0] = -180.0; lon[1] = 180.0;\n\t\n\twhile (i < precision) {\n\t\tif (is_even) {\n\t\t\tmid = (lon[0] + lon[1]) / 2;\n\t\t\tif (longitude > mid) {\n\t\t\t\tch |= bits[bit];\n\t\t\t\tlon[0] = mid;\n\t\t\t} else\n\t\t\t\tlon[1] = mid;\n\t\t} else {\n\t\t\tmid = (lat[0] + lat[1]) / 2;\n\t\t\tif (latitude > mid) {\n\t\t\t\tch |= bits[bit];\n\t\t\t\tlat[0] = mid;\n\t\t\t} else\n\t\t\t\tlat[1] = mid;\n\t\t}\n\t\t\n\t\tis_even = !is_even;\n\t\tif (bit < 4)\n\t\t\tbit++;\n\t\telse {\n\t\t\tgeohash[i++] = BASE32[ch];\n\t\t\tbit = 0;\n\t\t\tch = 0;\n\t\t}\n\t}\n\tgeohash[i] = 0;\n}\n\nstatic VALUE encode(VALUE self, VALUE lat, VALUE lon, VALUE precision)\n{\n\tVALUE geohash;\n\tchar str[15];\n\tint digits=10;\n\t\n\tdigits = NUM2INT(precision);\n\t\n\tCheck_Type(lat, T_FLOAT);\n\tCheck_Type(lon, T_FLOAT);\n\tif (digits <3 || digits > 12)\n\t\tdigits = 12;\n\n\tencode_geohash(RFLOAT_VALUE(lat), RFLOAT_VALUE(lon), digits, str);\n\n\tgeohash = rb_str_new2(str);\n\treturn geohash;\n}\n\nstatic VALUE decode_bbox(VALUE self, VALUE str)\n{\n\tVALUE ary, ret;\n\tdouble lat[2], lon[2];\n\tCheck_Type(str, T_STRING);\n\n\tdecode_geohash_bbox(RSTRING_PTR(str), lat, lon);\n\n\tret = rb_ary_new2(2); /* [[lat[0], lon[0]], [lat[1], lon[1]]] */\n\n\tary = rb_ary_new2(2); /* [lat[0], lon[0]] */\n\trb_ary_store(ary, 0, rb_float_new(lat[0]));\n\trb_ary_store(ary, 1, rb_float_new(lon[0]));\n\trb_ary_store(ret, 0, ary);\n\n\tary = rb_ary_new2(2); /* [lat[1], lon[1]] */\n\trb_ary_store(ary, 0, rb_float_new(lat[1]));\n\trb_ary_store(ary, 1, rb_float_new(lon[1]));\n\trb_ary_store(ret, 1, ary);\n\n\treturn ret;\n}\n\nstatic VALUE decode(VALUE self, VALUE str)\n{\n\tVALUE ary;\n\tdouble point[2];\n\tCheck_Type(str, T_STRING);\n\t\n\tdecode_geohash(RSTRING_PTR(str), point);\n\t\n\tary = rb_ary_new2(2);\n\trb_ary_store(ary, 0, rb_float_new(point[0]));\n\trb_ary_store(ary, 1, rb_float_new(point[1]));\n\treturn ary;\n}\n\n// Given a particular geohash string, a direction, and a final length\n// Compute a neighbor using base32 lookups, recursively when necessary\nvoid get_neighbor(char *str, int dir, int hashlen)\n{\n\t/* Right, Left, Top, Bottom */\n\n\tstatic char *neighbors[] = { \"bc01fg45238967deuvhjyznpkmstqrwx\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t \t \"238967debc01fg45kmstqrwxuvhjyznp\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t \t \"p0r21436x8zb9dcf5h7kjnmqesgutwvy\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   \"14365h7k9dcfesgujnmqp0r2twvyx8zb\" };\n\t\t\t\t\t\t\t\t\t\t\t\t\n\tstatic char *borders[] = { \"bcfguvyz\", \"0145hjnp\", \"prxz\", \"028b\" };\n\n\tchar last_chr, *border, *neighbor;\n\tint index = ( 2 * (hashlen % 2) + dir) % 4;\n\tneighbor = neighbors[index];\n\tborder = borders[index];\n\tlast_chr = str[hashlen-1];\n\tif (strchr(border,last_chr))\n\t\tget_neighbor(str, dir, hashlen-1);\n\tstr[hashlen-1] = BASE32[strchr(neighbor, last_chr)-neighbor];\n}\n\n// Acts as Ruby API wrapper to get_neighbor function, which is recursive and does nasty C things\nstatic VALUE calculate_adjacent(VALUE self, VALUE geohash, VALUE dir)\n{\n\tchar *str;\n\tVALUE ret_val;\n\tCheck_Type(geohash, T_STRING);\n\tCheck_Type(dir, T_FIXNUM);\n\tstr = RSTRING_PTR(geohash);\n\tif (!strlen(str)) return Qnil;\n\tret_val = rb_str_new(str,strlen(str));\n\tget_neighbor(RSTRING_PTR(ret_val), NUM2INT(dir), strlen(str));\n\treturn ret_val;\n}\n\nvoid Init_geohash_native()\n{\n\trb_cGeoHash = rb_define_class(\"GeoHash\", rb_cObject);\n\trb_define_singleton_method(rb_cGeoHash, \"decode_bbox\", decode_bbox, 1);\n\trb_define_singleton_method(rb_cGeoHash, \"decode_base\", decode, 1);\n\trb_define_singleton_method(rb_cGeoHash, \"encode_base\", encode, 3);\n\trb_define_singleton_method(rb_cGeoHash, \"calculate_adjacent\", calculate_adjacent, 2);\n}\n\n// end\n\n", "comment_ratio": 0.14084507042253522}
{"lang": "c", "code": "#ifndef _IRTKPOINTSET_H\n#define _IRTKPOINTSET_H\n\n#define POINTSET_SIZE 4096\n\n#include <irtkPoint.h>\n#ifdef HAS_VTK\nclass vtkAbstractArray;\n#endif\n\n\n/**\n\n  Point set class.\n\n*/\n\nclass irtkPointSet : public irtkObject\n{\n  irtkObjectMacro(irtkPointSet);\n\nprotected:\n\n  /// Allocated size of irtkPointSet\n  int _m;\n\n  /// Actual size of irtkPointSet\n  int _n;\n\n  /// Pointer to Points\n  irtkPoint *_data;\n\npublic:\n\n  //\n  // Constructors and destructor\n  //\n\n  /// Default constructor\n  irtkPointSet(int = 0);\n\n  /// Copy constructor\n  irtkPointSet(const irtkPointSet &);\n\n  /// Destructor\n  virtual ~irtkPointSet();\n\n  //\n  // Size get acccessor and clearing of irtkPointSet\n  //\n\n  /// Resizes container so it contains n elements\n  void Resize(int, const irtkPoint & = irtkPoint());\n\n  /// Request a change in capacity\n  void Reserve(int);\n\n  /// Return size of allocated storage capacity\n  int Capacity() const;\n\n  /// Set container size (and capacity)\n  ///\n  /// The result of this function is equivalent to\n  /// \\code\n  /// Resize(n);\n  /// ShrinkToFit();\n  /// \\endcode\n  /// but with only one reallocation operation. It sets both the size and\n  /// the capacity of the point set container.\n  void Size(int);\n\n  /// Access function for size\n  int Size() const;\n\n  /// Requests the container to reduce its capacity to fit its size\n  void ShrinkToFit();\n\n  /// Clearing of irtkPointSet\n  void Clear();\n\n  //\n  // Operators for access\n  //\n\n  /// Get n-th point\n  irtkPoint &GetPoint(int);\n\n  /// Get n-th point\n  const irtkPoint &GetPoint(int) const;\n\n  /// Get n-th point\n  void GetPoint(int, irtkPoint &) const;\n\n  /// Get n-th point\n  void GetPoint(int, double [3]) const;\n\n  /// Set n-th point\n  void SetPoint(int, const irtkPoint &);\n\n  /// Set n-th point\n  void SetPoint(int, const double [3]);\n\n  /// Operator for Point put access\n  irtkPoint &operator()(int);\n\n  /// Operator for Point get access\n  const irtkPoint &operator()(int) const;\n\n  /// Operator\n  irtkPointSet operator()(int, int) const;\n\n  //\n  // Operators for irtkPointSet arithmetic\n  //\n\n  // irtkPointSet operation for =\n  irtkPointSet &operator=(const irtkPointSet &);\n\n  // irtkPointSet operator for Point adding\n  irtkPointSet& operator+=(const irtkPoint&);\n\n  // irtkPointSet operator for Point substraction\n  irtkPointSet& operator-=(const irtkPoint&);\n\n  // irtkPointSet operator for irtkPointSet adding\n  irtkPointSet& operator+=(const irtkPointSet&);\n\n  // irtkPointSet operator for irtkPointSet substraction\n  irtkPointSet& operator-=(const irtkPointSet&);\n\n  /// Centre of gravity\n  virtual irtkPoint CenterOfGravity() const;\n\n  /// Closest point to given point\n  virtual irtkPoint ClosestPoint(irtkPoint&);\n\n  /// Point set distance to given point\n  virtual double PointDistance(irtkPoint&);\n\n  /// Bounding box\n  virtual void BoundingBox(irtkPoint &, irtkPoint &) const;\n\n  //\n  // Operators for irtkPointSet comparison\n  //\n\n  /// Test for equality\n  bool operator==(const irtkPointSet &) const;\n\n  /// Test for inequality\n  bool operator!=(const irtkPointSet &) const;\n\n  //\n  // Explicit methods to add or delete points\n  //\n\n  /// Adding of a Point to Pointset\n  void Add(const irtkPoint&);\n\n  /// Deleting of a Point from Pointset\n  void Del(const irtkPoint&);\n\n  /// Adding of a irtkPointSet to Pointset\n  void Add(const irtkPointSet &);\n\n  /// Deleting of a irtkPointSet from Pointset\n  void Del(const irtkPointSet &);\n\n  /// Adding of a Point to Pointset\n  void Add(double *);\n\n  /// Deleting of a Point from Pointset\n  void Del(double *);\n\n  //\n  // irtkPointSet in- and output\n  //\n\n  /// Interface to output stream\n  friend ostream& operator<< (ostream&, const irtkPointSet&);\n\n  /// Interface to input stream\n  friend istream& operator>> (istream&, irtkPointSet&);\n\n  /// Read pointset from file\n  void Read(const char *);\n\n  /// Write pointset to file\n  void Write(const char *) const;\n\n  /// Read pointset from file in VTK format\n  void ReadVTK(const char *);\n\n  /// Add pointset from file in VTK format\n  void AddVTK(const char *);\n\n  /// Write pointset to file in VTK format\n#ifdef HAS_VTK\n  void WriteVTK(const char *, vtkAbstractArray * = NULL) const;\n#else\n  void WriteVTK(const char *, void * = NULL) const;\n#endif\n\n  //\n  // Misc. functions\n  //\n\n  /// Computes the standard deviation ellipsoid about the centroid of a point set.\n  irtkPoint StandardDeviationEllipsoid() const;\n\n  /// Tests if a point is inside the polygon defined by the point set\n  int IsInside(double, double) const;\n\n};\n\ninline irtkPointSet::irtkPointSet(int n)\n:\n  _m(n), _n(n), _data(Allocate<irtkPoint>(n))\n{\n}\n\ninline irtkPointSet::irtkPointSet(const irtkPointSet &pset)\n:\n  irtkObject(pset),\n  _m(0), _n(0), _data(NULL)\n{\n  (*this) = pset;\n}\n\ninline irtkPointSet::~irtkPointSet()\n{\n  Clear();\n}\n\ninline irtkPoint& irtkPointSet::operator()(int j)\n{\n#ifdef NO_BOUNDS\n  return _data[j];\n#else\n  if ((j >= 0) && (j < _n)) {\n    return _data[j];\n  } else {\n    cerr << \"irtkPointSet::operator(int) parameter out of range\\n\";\n    exit(1);\n  }\n#endif\n}\n\ninline const irtkPoint &irtkPointSet::operator()(int j) const\n{\n#ifdef NO_BOUNDS\n  return _data[j];\n#else\n  if ((j >= 0) && (j < _n)) {\n    return _data[j];\n  } else {\n    cerr << \"irtkPointSet::operator(int) parameter out of range\\n\";\n    exit(1);\n  }\n#endif\n}\n\ninline irtkPoint &irtkPointSet::GetPoint(int i)\n{\n  return this->operator()(i);\n}\n\ninline const irtkPoint &irtkPointSet::GetPoint(int i) const\n{\n  return this->operator()(i);\n}\n\ninline void irtkPointSet::GetPoint(int i, irtkPoint &p) const\n{\n  p = this->operator()(i);\n}\n\ninline void irtkPointSet::GetPoint(int i, double p[3]) const\n{\n  const irtkPoint &pt = this->operator()(i);\n  p[0] = pt._x, p[1] = pt._y, p[2] = pt._z;\n}\n\ninline void irtkPointSet::SetPoint(int i, const irtkPoint &p)\n{\n  this->operator()(i) = p;\n}\n\ninline void irtkPointSet::SetPoint(int i, const double p[3])\n{\n  irtkPoint &pt = this->operator()(i);\n  pt._x = p[0], pt._y = p[1], pt._z = p[2];\n}\n\ninline irtkPointSet& irtkPointSet::operator+=(const irtkPoint &p)\n{\n  this->Add(p);\n  return *this;\n}\n\ninline irtkPointSet& irtkPointSet::operator-=(const irtkPoint &p)\n{\n  this->Del(p);\n  return *this;\n}\n\ninline irtkPointSet& irtkPointSet::operator+=(const irtkPointSet &pset)\n{\n  this->Add(pset);\n  return *this;\n}\n\ninline irtkPointSet& irtkPointSet::operator-=(const irtkPointSet &pset)\n{\n  this->Del(pset);\n  return *this;\n}\n\ninline irtkPointSet irtkPointSet::operator()(int j, int k) const\n{\n  irtkPointSet pset;\n#ifdef NO_BOUNDS\n  for (int i = j; i < k; j++) {\n    pset += _data[i];\n  }\n#else\n  if ((j >= 0) && (k < _n)) {\n    for (int i = j; i < k; j++) {\n      pset += _data[i];\n    }\n  } else {\n    cerr << \"irtkPointSet::operator(int, int) parameter out of range\\n\";\n    exit(1);\n  }\n#endif\n  return pset;\n}\n\ninline void irtkPointSet::Resize(int n, const irtkPoint &p)\n{\n  int m = _m;\n  while (n > m) m += POINTSET_SIZE;\n  this->Reserve(m);\n  _n = n;\n  for (int i = _n; i < _m; ++i) _data[i] = p;\n}\n\ninline void irtkPointSet::Reserve(int m)\n{\n  if (_m < m) {\n    _m = m;\n    irtkPoint *new_data = Allocate<irtkPoint>(m);\n    for (int i = 0; i < _n; ++i) new_data[i] = _data[i];\n    Deallocate(_data);\n    _data = new_data;\n  }\n}\n\ninline int irtkPointSet::Capacity() const\n{\n  return _m;\n}\n\ninline void irtkPointSet::Size(int n)\n{\n  if (_m != n) {\n    irtkPoint *new_data = Allocate<irtkPoint>(n);\n    for (int i = 0; i < _n; ++i) new_data[i] = _data[i];\n    Deallocate(_data);\n    _data = new_data;\n    _m = _n = n;\n  }\n}\n\ninline int irtkPointSet::Size() const\n{\n  return _n;\n}\n\ninline void irtkPointSet::ShrinkToFit()\n{\n  if (_n < _m) {\n    irtkPoint *new_data = Allocate<irtkPoint>(_n);\n    for (int i = 0; i < _n; ++i) new_data[i] = _data[i];\n    Deallocate(_data);\n    _data = new_data;\n    _m    = _n;\n  }\n}\n\ninline void irtkPointSet::Add(double *p)\n{\n  this->Add(irtkPoint(p[0], p[1], p[2]));\n}\n\ninline void irtkPointSet::Del(double *p)\n{\n  this->Del(irtkPoint(p[0], p[1], p[2]));\n}\n\n#endif\n\n\n", "comment_ratio": 0.19331742243436753}
{"lang": "c", "code": "// NewButton.h: interface for the CNewButton class.\n//\n//////////////////////////////////////////////////////////////////////\n\n#if !defined(AFX_NEWBUTTON_H__1A9CF306_F483_45F0_9375_1EC701E3DE43__INCLUDED_)\n#define AFX_NEWBUTTON_H__1A9CF306_F483_45F0_9375_1EC701E3DE43__INCLUDED_\n\n#if _MSC_VER > 1000\n#pragma once\n#endif // _MSC_VER > 1000\n\n#include \"MyButton.h\"\n\nclass CNewButton : public CMyButton  \n{\npublic:\n\tCNewButton();\n\tvirtual ~CNewButton();\n\n};\n\n#endif // !defined(AFX_NEWBUTTON_H__1A9CF306_F483_45F0_9375_1EC701E3DE43__INCLUDED_)\n\n", "comment_ratio": 0.21739130434782608}
{"lang": "c", "code": "#import <CoreUI/CUIPSDLayerEffectComponent.h>\n\n@class CUIColor;\n\n@interface CUIPSDLayerEffectBevelEmboss : CUIPSDLayerEffectComponent {\n\n\tunsigned long long _blurSize;\n\tunsigned long long _softenSize;\n\tshort _angle;\n\tunsigned long long _altitude;\n\tunsigned _direction;\n\tint _highlightBlendMode;\n\tCUIColor* _highlightColor;\n\tdouble _highlightOpacity;\n\tint _shadowBlendMode;\n\tCUIColor* _shadowColor;\n\tdouble _shadowOpacity;\n\n}\n\n@property (assign) unsigned long long blurSize;                //@synthesize blurSize=_blurSize - In the implementation block\n@property (assign) unsigned long long softenSize;              //@synthesize softenSize=_softenSize - In the implementation block\n@property (assign) short angle;                                //@synthesize angle=_angle - In the implementation block\n@property (assign) unsigned long long altitude;                //@synthesize altitude=_altitude - In the implementation block\n@property (assign) unsigned direction;                         //@synthesize direction=_direction - In the implementation block\n@property (assign) int highlightBlendMode;                     //@synthesize highlightBlendMode=_highlightBlendMode - In the implementation block\n@property (retain) CUIColor * highlightColor;                  //@synthesize highlightColor=_highlightColor - In the implementation block\n@property (assign) double highlightOpacity;                    //@synthesize highlightOpacity=_highlightOpacity - In the implementation block\n@property (assign) int shadowBlendMode;                        //@synthesize shadowBlendMode=_shadowBlendMode - In the implementation block\n@property (retain) CUIColor * shadowColor;                     //@synthesize shadowColor=_shadowColor - In the implementation block\n@property (assign) double shadowOpacity;                       //@synthesize shadowOpacity=_shadowOpacity - In the implementation block\n-(void)setBlurSize:(unsigned long long)arg1 ;\n-(void)setSoftenSize:(unsigned long long)arg1 ;\n-(void)setHighlightBlendMode:(int)arg1 ;\n-(void)setHighlightOpacity:(double)arg1 ;\n-(void)setShadowBlendMode:(int)arg1 ;\n-(BOOL)updateLayerEffectPreset:(id)arg1 error:(id*)arg2 ;\n-(id)initWithEffectFromPreset:(id)arg1 atIndex:(unsigned)arg2 ;\n-(unsigned long long)blurSize;\n-(int)highlightBlendMode;\n-(int)shadowBlendMode;\n-(unsigned long long)softenSize;\n-(double)highlightOpacity;\n-(void)dealloc;\n-(id)init;\n-(void)setShadowColor:(CUIColor *)arg1 ;\n-(void)setDirection:(unsigned)arg1 ;\n-(unsigned)direction;\n-(CUIColor *)shadowColor;\n-(void)setShadowOpacity:(double)arg1 ;\n-(double)shadowOpacity;\n-(CUIColor *)highlightColor;\n-(void)setHighlightColor:(CUIColor *)arg1 ;\n-(void)setAngle:(short)arg1 ;\n-(short)angle;\n-(void)setAltitude:(unsigned long long)arg1 ;\n-(unsigned long long)altitude;\n-(unsigned)effectType;\n@end\n\n\n", "comment_ratio": 0.15942028985507245}
{"lang": "c", "code": "#pragma once\r\n\r\nnamespace devilution {\r\n\r\nbool UiSelHeroYesNoDialog(const char *title, const char *body);\r\n\r\n} // namespace devilution\r\n\n", "comment_ratio": 0.125}
{"lang": "c", "code": "#ifndef RUNTIME_H\n#define RUNTIME_H\n\n#include <c10/cuda/CUDAStream.h>\n#include <torch/csrc/cuda/nccl.h>\n\n#include <atomic>\n#include <map>\n#include <memory>\n#include <mutex>\n#include <vector>\n\n#include \"JobContext.h\"\n\n#define VERBOSE 0\n\n/**\n * Forward declarations\n */\nclass RuntimeServiceImpl;\nnamespace grpc {\nclass Server;\n};\n\nstruct NcclGroupConfig {\n  torch::cuda::nccl::ncclUniqueId ncclGroupId;\n  torch::cuda::nccl::ncclComm_t ncclCommObj;\n  std::vector<int> ranks;\n  int myRank;\n  size_t group_key;\n};\n\n/* Get 64-bit bitmap key for a set of ranks */\nstatic inline size_t RankVecToKey(std::vector<int> ranks) {\n  size_t key = 0;\n  for (auto& i : ranks) {\n    assert(i < 64);\n    key |= 1UL << i;\n  }\n  return key;\n}\n\n/**\n * Context holding data for Runtime.\n */\nstruct RuntimeContext {\n  RuntimeContext()\n      : c10dev(c10::DeviceType::CUDA, 0),\n        torch_stream(c10::cuda::getStreamFromPool(true)),\n        xfer_stream(c10::cuda::getStreamFromPool(true)),\n        grad_sync_stream(c10::cuda::getStreamFromPool(true)) {\n    c10::cuda::setCurrentCUDAStream(torch_stream);\n  }\n\n  ~RuntimeContext();  // Defined in cpp file because of incomplete unique_ptrs.\n\n  /**\n   * Populated by commandline arguments\n   */\n  int device;\n  std::string c10dBackend;\n  int rank;\n  int worldSize;\n  bool profile_stage_time;\n  bool profile_layer_times_graph;\n  bool profile_layer_times_timers;\n  bool cuda_profile;\n  bool debug;\n  std::string logdir;\n  c10::Device c10dev;\n  bool use_fg_graph;\n  size_t iters_per_capture;\n  double be_graph_split_ms;\n  size_t min_layer_sync;\n  size_t sync_bucket_size;\n  std::string bg_json_file;\n  std::atomic<uint64_t> fgcounter{0};\n\n  std::mutex jobListMutex;\n  std::vector<std::unique_ptr<JobContext>> jobList;\n  int addTrainingJob(std::unique_ptr<JobContext> job);\n  int poll();\n\n  /**\n   *  additional variables.\n   */\n  RuntimeServiceImpl* grpcService;\n  grpc::Server* grpcServer;\n  std::atomic<bool>\n      shutdownRequested;  // Set to true when coordinator shuts down.\n  std::map<std::string, CommunicationHandler*> commHandlerMap;\n  std::vector<std::string> rankToIpAndPort;\n  std::atomic<bool> grpcCommReady;\n\n  /**\n   * variables to maintain per NCCL comm group\n   * need to be expanded if one node participates in more than one comm group\n   */\n\n  std::atomic<bool> ncclCommReady{false};\n  std::map<size_t, NcclGroupConfig> nccl_groups;\n  NcclGroupConfig maingroup;\n  c10::cuda::CUDAStream torch_stream, xfer_stream;\n  c10::cuda::CUDAStream grad_sync_stream;\n};\n\nextern RuntimeContext* rtctx;\n\n#endif  // RUNTIME_H\n", "comment_ratio": 0.13008130081300814}
{"lang": "c", "code": "//\n//  FZWUtils.h\n//  FBSnapshotTestCase\n//\n//  Created by mentos. on 2019/9/24.\n//\n\n#import <Foundation/Foundation.h>\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface FZWUtils : NSObject\n\n/**\n \u83b7\u53d6\u6839\u89c6\u56fe\u63a7\u5236\u5668\n\n @return \u6839\u89c6\u56fe\u63a7\u5236\u5668\n */\n+ (UIViewController *)getRootViewController;\n\n/**\n \u83b7\u53d6\u672c\u5730\u56fe\u7247\u8d44\u6e90\n\n @param fileName \u6587\u4ef6\u540d\u79f0\n @return \u56fe\u7247\u8d44\u6e90\n */\n+ (UIImage *)imageToBundleWithFileName:(NSString *)fileName;\n\n@end\n\nNS_ASSUME_NONNULL_END\n\n", "comment_ratio": 0.1875}
{"lang": "c", "code": "#import <CoreTelephony/CoreTelephony-Structs.h>\n#import <libobjc.A.dylib/NSCopying.h>\n#import <libobjc.A.dylib/NSSecureCoding.h>\n\n@interface CTCallCapabilities : NSObject <NSCopying, NSSecureCoding> {\n\n\tBOOL _isWifiCallingAvailable;\n\tBOOL _isVoLTECallingAvailable;\n\tBOOL _isCSCallingAvailable;\n\tBOOL _isEmergencyCallingOnWifiAllowed;\n\tBOOL _isEmergencyCallingOnWifiAvailable;\n\tBOOL _isCarrierSupportsEmergencyCallOnWifiNoLimit;\n\n}\n\n@property (assign,nonatomic) BOOL isWifiCallingAvailable;                                   //@synthesize isWifiCallingAvailable=_isWifiCallingAvailable - In the implementation block\n@property (assign,nonatomic) BOOL isVoLTECallingAvailable;                                  //@synthesize isVoLTECallingAvailable=_isVoLTECallingAvailable - In the implementation block\n@property (assign,nonatomic) BOOL isCSCallingAvailable;                                     //@synthesize isCSCallingAvailable=_isCSCallingAvailable - In the implementation block\n@property (assign,nonatomic) BOOL isEmergencyCallingOnWifiAllowed;                          //@synthesize isEmergencyCallingOnWifiAllowed=_isEmergencyCallingOnWifiAllowed - In the implementation block\n@property (assign,nonatomic) BOOL isEmergencyCallingOnWifiAvailable;                        //@synthesize isEmergencyCallingOnWifiAvailable=_isEmergencyCallingOnWifiAvailable - In the implementation block\n@property (assign,nonatomic) BOOL isCarrierSupportsEmergencyCallOnWifiNoLimit;              //@synthesize isCarrierSupportsEmergencyCallOnWifiNoLimit=_isCarrierSupportsEmergencyCallOnWifiNoLimit - In the implementation block\n+(BOOL)supportsSecureCoding;\n-(BOOL)isWifiCallingAvailable;\n-(BOOL)isVoLTECallingAvailable;\n-(BOOL)isCSCallingAvailable;\n-(BOOL)isEmergencyCallingOnWifiAllowed;\n-(BOOL)isEmergencyCallingOnWifiAvailable;\n-(BOOL)isCarrierSupportsEmergencyCallOnWifiNoLimit;\n-(void)setIsWifiCallingAvailable:(BOOL)arg1 ;\n-(void)setIsVoLTECallingAvailable:(BOOL)arg1 ;\n-(void)setIsCSCallingAvailable:(BOOL)arg1 ;\n-(void)setIsEmergencyCallingOnWifiAllowed:(BOOL)arg1 ;\n-(void)setIsEmergencyCallingOnWifiAvailable:(BOOL)arg1 ;\n-(void)setIsCarrierSupportsEmergencyCallOnWifiNoLimit:(BOOL)arg1 ;\n-(void)encodeWithCoder:(id)arg1 ;\n-(id)initWithCoder:(id)arg1 ;\n-(id)description;\n-(id)copyWithZone:(NSZone*)arg1 ;\n@end\n\n\n", "comment_ratio": 0.12244897959183673}
{"lang": "c", "code": "#ifndef ADV_DB_ADV_H\n#define ADV_DB_ADV_H\n\n#include <stdint.h>\n\n#include <lib/sds/sds.h>\n#include \"store/types.h\"\n\n#define ADV_CREATE STORE_O_CREAT\n\nstruct adv_meta\n{\n\t// Useful heuristics\n\tnode_p supernodes[10];\n\t\n\t// Statistics\n\tsize_t node_count;\n\tsize_t edge_count;\n\tsize_t disk_sz;\n\tsize_t node_file_sz;\n\tsize_t edge_file_sz;\n};\n\nstruct adv_txn\n{\n\tuint64_t txn_id;\n\t// TODO: how should we represent dirty pages?\n};\n\nstruct adv_db\n{\n\tsds path;\n\tstruct adv_meta meta;\n\tstruct store *nodes;\n\tstruct store *edges;\n};\n\n// Open/close an existing database from disk\nstruct adv_db *adv_open(const char *dbname, int flags);\nvoid adv_close(struct adv_db *db);\n\n// Maintenance\nint adv_validate(struct adv_db *db);\nint adv_repair(struct adv_db *db);\nint adv_compact(struct adv_db *db);\nint adv_backup(struct adv_db *dest, struct adv_db *src);\nvoid adv_delete(struct adv_db *db);\n\n// Transactions\nstruct adv_txn *adv_txn_begin(struct adv_db *db, int flags);\nvoid adv_txn_commit(struct adv_db *db, struct adv_txn *txn);\nvoid adv_txn_abort(struct adv_db *db, struct adv_txn *txn);\n\n// Graph operations\nnode_p adv_node_add(struct adv_db *db);\nint adv_edge_add(struct adv_db *db, node_p start, node_p end);\nint adv_edge_remove(struct adv_db *db, node_p start, node_p end);\n\n// Queries\n\n// Debug functions\nvoid adv_debug_print(struct adv_db *db);\n\n#endif\n\n", "comment_ratio": 0.13846153846153847}
{"lang": "c", "code": "#ifndef NVIM_SCREEN_H\n#define NVIM_SCREEN_H\n\n#include <stdbool.h>\n\n/*\n * flags for update_screen()\n * The higher the value, the higher the priority\n */\n#define VALID                   10  /* buffer not changed, or changes marked\n                                       with b_mod_* */\n#define INVERTED                20  /* redisplay inverted part that changed */\n#define INVERTED_ALL            25  /* redisplay whole inverted part */\n#define REDRAW_TOP              30  /* display first w_upd_rows screen lines */\n#define SOME_VALID              35  /* like NOT_VALID but may scroll */\n#define NOT_VALID               40  /* buffer needs complete redraw */\n#define CLEAR                   50  /* screen messed up, clear it */\n\n/// Status line click definition\ntypedef struct {\n  enum {\n    kStlClickDisabled = 0,  ///< Clicks to this area are ignored.\n    kStlClickTabSwitch,     ///< Switch to the given tab.\n    kStlClickTabClose,      ///< Close given tab.\n    kStlClickFuncRun,       ///< Run user function.\n  } type;      ///< Type of the click.\n  int tabnr;   ///< Tab page number.\n  char *func;  ///< Function to run.\n} StlClickDefinition;\n\n/// Used for tabline clicks\ntypedef struct {\n  StlClickDefinition def;  ///< Click definition.\n  const char *start;       ///< Location where region starts.\n} StlClickRecord;\n\n/// Array defining what should be done when tabline is clicked\nextern StlClickDefinition *tab_page_click_defs;\n\n/// Size of the tab_page_click_defs array\nextern long tab_page_click_defs_size;\n\n#ifdef INCLUDE_GENERATED_DECLARATIONS\n# include \"screen.h.generated.h\"\n#endif\n#endif  // NVIM_SCREEN_H\n\n", "comment_ratio": 0.2978723404255319}
{"lang": "c", "code": "#ifndef COLMAP_SRC_BASE_SIMILARITY_TRANSFORM_H_\n#define COLMAP_SRC_BASE_SIMILARITY_TRANSFORM_H_\n\n#include <Eigen/Core>\n#include <Eigen/Dense>\n#include <Eigen/Geometry>\n#include <vector>\n\n#include \"base/pose.h\"\n#include \"base/projection.h\"\n#include \"base/reconstruction.h\"\n#include \"estimators/rigid_transformation3D_srt.h\"\n#include \"estimators/similarity_transform.h\"\n#include \"optim/loransac.h\"\n#include \"util/alignment.h\"\n#include \"util/types.h\"\n\nnamespace colmap {\n\nstruct RANSACOptions;\nclass Reconstruction;\n\n// 3D similarity transformation with 7 degrees of freedom.\nclass SimilarityTransform3 {\n public:\n  EIGEN_MAKE_ALIGNED_OPERATOR_NEW\n\n  SimilarityTransform3();\n\n  explicit SimilarityTransform3(const Eigen::Matrix3x4d& matrix);\n\n  explicit SimilarityTransform3(\n      const Eigen::Transform<double, 3, Eigen::Affine>& transform);\n\n  SimilarityTransform3(const double scale, const Eigen::Vector4d& qvec,\n                       const Eigen::Vector3d& tvec);\n\n  void Estimate(const std::vector<Eigen::Vector3d>& src,\n                const std::vector<Eigen::Vector3d>& dst);\n\n  SimilarityTransform3 Inverse() const;\n\n  void TransformPoint(Eigen::Vector3d* xyz) const;\n  void TransformPose(Eigen::Vector4d* qvec, Eigen::Vector3d* tvec) const;\n\n  Eigen::Matrix4d Matrix() const;\n  double Scale() const;\n  Eigen::Vector4d Rotation() const;\n  Eigen::Vector3d Translation() const;\n\n private:\n  Eigen::Transform<double, 3, Eigen::Affine> transform_;\n};\n\nstruct RobustAlignmentEstimator {};\n\nstruct ReconstructionAlignmentEstimator {\n  static const int kMinNumSamples = 3;\n\n  typedef const Image* X_t;\n  typedef const Image* Y_t;\n  typedef Eigen::Matrix3x4d M_t;\n\n  void SetMaxReprojError(const double max_reproj_error) {\n    max_squared_reproj_error_ = max_reproj_error * max_reproj_error;\n  }\n\n  void SetReconstructions(const Reconstruction* reconstruction1,\n                          const Reconstruction* reconstruction2) {\n    CHECK_NOTNULL(reconstruction1);\n    CHECK_NOTNULL(reconstruction2);\n    reconstruction1_ = reconstruction1;\n    reconstruction2_ = reconstruction2;\n  }\n\n  // Estimate 3D similarity transform from corresponding projection centers.\n  std::vector<M_t> Estimate(const std::vector<X_t>& images1,\n                            const std::vector<Y_t>& images2) const {\n    const int sample_size = 3;\n\n    CHECK_GE(images1.size(), sample_size);\n    CHECK_GE(images2.size(), sample_size);\n\n    std::vector<Eigen::Vector3d> proj_centers1(images1.size());\n    std::vector<Eigen::Vector3d> proj_centers2(images2.size());\n    for (size_t i = 0; i < sample_size; ++i) {\n      CHECK_EQ(images1[i]->ImageId(), images2[i]->ImageId());\n      proj_centers1[i] = images1[i]->ProjectionCenter();\n      proj_centers2[i] = images2[i]->ProjectionCenter();\n    }\n\n    SimilarityTransform3 tform12;\n    tform12.Estimate(proj_centers1, proj_centers2);\n\n    return {tform12.Matrix().topRows<3>()};\n\n    // Eigen::MatrixXd x1 = Eigen::MatrixXd::Zero(3, sample_size);\n    // Eigen::MatrixXd x2 = Eigen::MatrixXd::Zero(3, sample_size);\n    // for (int i = 0; i < sample_size; i++) {\n    //     CHECK_EQ(images1[i]->ImageId(), images2[i]->ImageId());\n    //     x1.col(i) = images1[i]->ProjectionCenter();\n    //     x2.col(i) = images2[i]->ProjectionCenter();\n    // }\n\n    // double s = 1.0;\n    // Eigen::Vector3d t = Eigen::Vector3d::Zero();\n    // Eigen::Matrix3d R = Eigen::Matrix3d::Identity();\n    // DAGSfM::FindRTS(x1, x2, &s, &t, &R);\n    // M_t model;\n    // model.block(0, 0, 3, 3) = s * R;\n    // model.block(0, 3, 3, 1) = t;\n\n    // return { model };\n  }\n\n  // For each image, determine the ratio of 3D points that correctly project\n  // from one image to the other image and vice versa for the given alignment.\n  // The residual is then defined as 1 minus this ratio, i.e., an error\n  // threshold of 0.3 means that 70% of the points for that image must reproject\n  // within the given maximum reprojection error threshold.\n  void Residuals(const std::vector<X_t>& images1,\n                 const std::vector<Y_t>& images2, const M_t& alignment12,\n                 std::vector<double>* residuals) const {\n    CHECK_EQ(images1.size(), images2.size());\n    CHECK_NOTNULL(reconstruction1_);\n    CHECK_NOTNULL(reconstruction2_);\n\n    const Eigen::Matrix3x4d alignment21 =\n        SimilarityTransform3(alignment12).Inverse().Matrix().topRows<3>();\n\n    residuals->resize(images1.size());\n\n    for (size_t i = 0; i < images1.size(); ++i) {\n      const auto& image1 = *images1[i];\n      const auto& image2 = *images2[i];\n\n      CHECK_EQ(image1.ImageId(), image2.ImageId());\n      CHECK_EQ(image1.CameraId(), image2.CameraId());\n\n      const auto& camera1 = reconstruction1_->Camera(image1.CameraId());\n      const auto& camera2 = reconstruction2_->Camera(image2.CameraId());\n\n      const Eigen::Matrix3x4d proj_matrix1 = image1.ProjectionMatrix();\n      const Eigen::Matrix3x4d proj_matrix2 = image2.ProjectionMatrix();\n\n      CHECK_EQ(image1.NumPoints2D(), image2.NumPoints2D());\n\n      size_t num_inliers = 0;\n      size_t num_common_points = 0;\n\n      for (point2D_t point2D_idx = 0; point2D_idx < image1.NumPoints2D();\n           ++point2D_idx) {\n        // Check if both images have a 3D point.\n\n        const auto& point2D1 = image1.Point2D(point2D_idx);\n        if (!point2D1.HasPoint3D()) {\n          continue;\n        }\n\n        const auto& point2D2 = image2.Point2D(point2D_idx);\n        if (!point2D2.HasPoint3D()) {\n          continue;\n        }\n\n        num_common_points += 1;\n\n        // Reproject 3D point in image 1 to image 2.\n        const Eigen::Vector3d xyz12 =\n            alignment12 *\n            reconstruction1_->Point3D(point2D1.Point3DId()).XYZ().homogeneous();\n        if (CalculateSquaredReprojectionError(point2D2.XY(), xyz12,\n                                              proj_matrix2, camera2) >\n            max_squared_reproj_error_) {\n          continue;\n        }\n\n        // Reproject 3D point in image 2 to image 1.\n        const Eigen::Vector3d xyz21 =\n            alignment21 *\n            reconstruction2_->Point3D(point2D2.Point3DId()).XYZ().homogeneous();\n        if (CalculateSquaredReprojectionError(point2D1.XY(), xyz21,\n                                              proj_matrix1, camera1) >\n            max_squared_reproj_error_) {\n          continue;\n        }\n\n        num_inliers += 1;\n      }\n\n      if (num_common_points == 0) {\n        (*residuals)[i] = 1.0;\n      } else {\n        const double negative_inlier_ratio =\n            1.0 - static_cast<double>(num_inliers) /\n                      static_cast<double>(num_common_points);\n        (*residuals)[i] = negative_inlier_ratio * negative_inlier_ratio;\n      }\n    }\n\n    // double mean_residual = 0.0;\n    // for (auto residual : *residuals) {\n    //     mean_residual += residual;\n    // }\n    // mean_residual /= residuals->size();\n    // LOG(INFO) << \"mean residual: \" << mean_residual;\n  }\n\n private:\n  double max_squared_reproj_error_ = 0.0;\n  const Reconstruction* reconstruction1_ = nullptr;\n  const Reconstruction* reconstruction2_ = nullptr;\n};\n\n// Robustly compute alignment between reconstructions by finding images that\n// are registered in both reconstructions. The alignment is then estimated\n// robustly inside RANSAC from corresponding projection centers. An alignment\n// is verified by reprojecting common 3D point observations.\n// The min_inlier_observations threshold determines how many observations\n// in a common image must reproject within the given threshold.\nbool ComputeAlignmentBetweenReconstructions(\n    const Reconstruction& src_reconstruction,\n    const Reconstruction& ref_reconstruction,\n    const double min_inlier_observations, const double max_reproj_error,\n    Eigen::Matrix3x4d* alignment);\n\n// Robustly compute alignment between reconstructions by finding images that\n// are registered in both reconstructions. The alignment is then estimated\n// robustly inside RANSAC from corresponding projection centers. An alignment\n// is verified by reprojecting common 3D point observations.\n// The min_inlier_observations threshold determines how many observations\n// in a common image must reproject within the given threshold.\nbool ComputeAlignmentBetweenReconstructions(\n    const Reconstruction& src_reconstruction,\n    const Reconstruction& ref_reconstruction,\n    const double min_inlier_observations, const double max_reproj_error,\n    std::vector<const Image*>& src_images,\n    std::vector<const Image*>& ref_images, Eigen::Matrix3x4d* alignment);\n\n}  // namespace colmap\n\nEIGEN_DEFINE_STL_VECTOR_SPECIALIZATION_CUSTOM(colmap::SimilarityTransform3)\n\n#endif  // COLMAP_SRC_BASE_SIMILARITY_TRANSFORM_H_\n\n", "comment_ratio": 0.2727272727272727}
{"lang": "c", "code": "// Generated by gmmproc 2.54.0 -- DO NOT MODIFY!\n#ifndef _GDKMM_WINDOW_P_H\n#define _GDKMM_WINDOW_P_H\n\n\n#include <glibmm/private/object_p.h>\n\n#include <glibmm/class.h>\n\nnamespace Gdk\n{\n\nclass Window_Class : public Glib::Class\n{\npublic:\n#ifndef DOXYGEN_SHOULD_SKIP_THIS\n  using CppObjectType = Window;\n  using BaseObjectType = GdkWindow;\n  using BaseClassType = GdkWindowClass;\n  using CppClassParent = Glib::Object_Class;\n  using BaseClassParent = GObjectClass;\n\n  friend class Window;\n#endif /* DOXYGEN_SHOULD_SKIP_THIS */\n\n  const Glib::Class& init();\n\n\n  static void class_init_function(void* g_class, void* class_data);\n\n  static Glib::ObjectBase* wrap_new(GObject*);\n\nprotected:\n\n  //Callbacks (default signal handlers):\n  //These will call the *_impl member methods, which will then call the existing default signal callbacks, if any.\n  //You could prevent the original default signal handlers being called by overriding the *_impl method.\n\n  //Callbacks (virtual functions):\n};\n\n\n} // namespace Gdk\n\n\n#endif /* _GDKMM_WINDOW_P_H */\n\n\n", "comment_ratio": 0.125}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n\n@interface AppDelegate : UIResponder <UIApplicationDelegate> {\n    UIWindow * window;\n    UIViewController *_mainViewController;\n}\n\n@property (nonatomic, retain) UIWindow *window;\n\n@end\n\n", "comment_ratio": 0.3684210526315789}
{"lang": "c", "code": "// Need to define clock speed for delay functions\n#ifndef F_CPU\n#define F_CPU 1000000UL // 1 MHz clock speed\n#endif\n\n#include <avr/io.h>\n#include <util/delay.h>\n\nint main(void) {\n    \n    // Make only red LED pins output (PA7, PB2)\n    DDRA = (1 << 7);\n    DDRB = (1 << 2);\n    \n    // Set Timer 0 to fast PWM\n    TCCR0A = (1 << WGM01) | (1 << WGM00);\n    \n    // Set Compare Output modes for A and B to inverting PWM\n    TCCR0A |= (1 << COM0A1) | (1 << COM0A0);\n    TCCR0A |= (1 << COM0B1) | (1 << COM0B0);\n    \n    // Set prescaler to 1 (no prescaling)\n    TCCR0B = (1 << CS00);\n    \n    // Infinite loop\n    while(1) {\n        \n        int16_t d;\n        \n        // Increase left eye, decrease right eye\n        for ( d = 0; d <= 255; d++ ) {\n            OCR0A = (uint8_t)d;         // Left eye\n            OCR0B = (uint8_t)255 - d;   // Right eye\n            _delay_ms(2);\n        }\n        \n        // Decrease left eye, increase right eye\n        for ( d = 255; d >= 0; d-- ) {\n            OCR0A = (uint8_t)d;         // Left eye\n            OCR0B = (uint8_t)255 - d;   // Right eye\n            _delay_ms(2);\n        }\n    }\n}\n\n", "comment_ratio": 0.28888888888888886}
{"lang": "c", "code": "#ifndef PLVChatroomDefine_h\n#define PLVChatroomDefine_h\n\n@protocol PLVChatCellProtocol <NSObject>\n\n- (void)interactWithURL:(NSURL *)URL;\n\n@end\n\n#endif /* PLVChatroomDefine_h */\n\n", "comment_ratio": 0.3684210526315789}
{"lang": "c", "code": "#include \"mw_fim_default_group01.h\"\n\n\n// Sec 2: Constant Definitions, Imported Symbols, miscellaneous\n\n\n/********************************************\nDeclaration of data structure\n********************************************/\n// Sec 3: structure, uniou, enum, linked list\n\n\n/********************************************\nDeclaration of Global Variables & Functions\n********************************************/\n// Sec 4: declaration of global variable\n\n// the default value of Uart config\nconst T_HalUartConfig g_tMwFimDefaultUartConfig =\n{\n    115200,\n    DATA_BIT_8,\n    STOP_BIT_1,\n    PARITY_NONE,\n    0               // disable the flow control\n};\n\n// the address buffer of Uart config\nRET_DATA uint32_t g_ulaMwFimAddrBufferUartConfig[MW_FIM_UART_CFG_NUM];\n\n// the information table of group 01\nconst T_MwFimFileInfo g_taMwFimGroupTable01[] =\n{\n    {MW_FIM_IDX_GP01_UART_CFG, MW_FIM_UART_CFG_NUM, MW_FIM_UART_CFG_SIZE, (uint8_t*)&g_tMwFimDefaultUartConfig, g_ulaMwFimAddrBufferUartConfig},\n    // the end, don't modify and remove it\n    {0xFFFFFFFF,            0x00,              0x00,               NULL,                            NULL}\n};\n\n\n// Sec 5: declaration of global function prototype\n\n\n/***************************************************\nDeclaration of static Global Variables & Functions\n***************************************************/\n// Sec 6: declaration of static global variable\n\n\n// Sec 7: declaration of static function prototype\n\n\n/***********\nC Functions\n***********/\n// Sec 8: C Functions\n\n", "comment_ratio": 0.15217391304347827}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n#import \"CHSheetViewController.h\"\n#import \"HRColorPickerView.h\"\n\n@class HRColorPickerView;\n\n@protocol CHSheetColorPickerViewControllerDelegate <NSObject>\n- (void) colorSelected:(NSString *)colorString;\n@end\n\n@interface CHSheetColorPickerViewController : CHSheetViewController<HRColorPickerViewDelegate> {\n\tHRColorPickerView *colorPickerView;\n}\n\n@property(readwrite, nonatomic, assign) CGFloat keyboardHeight;\n@property(readwrite, nonatomic, assign) id<CHSheetColorPickerViewControllerDelegate> delegate;\n\n@end\n\n", "comment_ratio": 0.25925925925925924}
{"lang": "c", "code": "#if !defined(NAVIER_STOKES_SOLVER_H)\n#define NAVIER_STOKES_SOLVER_H\n\n#include \"CartesianMesh.h\"\n#include \"FlowDescription.h\"\n#include \"SimulationParameters.h\"\n#include \"solvers/solver.h\"\n\n#include <fstream>\n#include <memory>\n\n#include <petscdmda.h>\n#include <petscksp.h>\n\n\n/**\n * \\class NavierStokesSolver\n * \\brief Solve the incompressible Navier-Stokes equations in a rectangular or\n *        cuboidal domain.\n */\ntemplate <PetscInt dim>\nclass NavierStokesSolver\n{\npublic:\n  DM qPack,\n     lambdaPack;\n  DM pda,\n     uda,\n     vda,\n     wda;\n\n  Vec q, qStar, lambda;\n\n  Vec qxLocal, qyLocal, qzLocal;\n  Vec pMapping, uMapping, vMapping, wMapping;\n\n  Solver *velocity, *poisson;\n\n  Mat A,\n      QT,\n      BNQ,\n      QTBNQ;\n\n  Vec bc1,\n      rhs1,\n      H,\n      rn,\n      r2,\n      rhs2,\n      temp;\n\n  Vec BN,\n      RInv,\n      MHat;\n\n  CartesianMesh *mesh;\n  FlowDescription<dim> *flow;\n  SimulationParameters *parameters;\n  \n  PetscInt timeStep;\n\n  std::ofstream iterationCountsFile;\n\n  PetscLogStage stageInitialize,\n                stageRHSVelocitySystem,\n                stageSolveVelocitySystem,\n                stageRHSPoissonSystem,\n                stageSolvePoissonSystem,\n                stageProjectionStep,\n                stageWriteData;\n\n  // initialize data common to NavierStokesSolver and derived classes\n  PetscErrorCode initializeCommon();\n  // create DMDA structures for flow variables\n  virtual PetscErrorCode createDMs();\n  // create vectors used to store flow variables\n  virtual PetscErrorCode createVecs();\n  // create mapping from local flux vectors to global flux vectors\n  PetscErrorCode createLocalToGlobalMappingsFluxes();\n  // create mapping from local pressure variable to global lambda vector\n  PetscErrorCode createLocalToGlobalMappingsLambda();\n  // create the solvers for the linear systems\n  PetscErrorCode createSolvers();\n  // populate flux vectors with initial conditions\n  virtual PetscErrorCode initializeFluxes();\n  // add initial perturbation to velocity field\n  PetscErrorCode addInitialPerturbation();\n  // initialize lambda vector with previously saved data\n  PetscErrorCode initializeLambda();\n  \n  // generate diagonal matrices M and Rinv\n  PetscErrorCode generateDiagonalMatrices();\n  \n  // count number of non-zeros in the diagonal and off-diagonal portions of the parallel matrices\n  void countNumNonZeros(PetscInt *cols, size_t numCols, PetscInt rowStart, PetscInt rowEnd, \n                        PetscInt &d_nnz, PetscInt &o_nnz);\n  \n  // generate the matrix A\n  PetscErrorCode generateA();\n  \n  // compute matrix \\f$ B^N Q \\f$\n  virtual PetscErrorCode generateBNQ();\n  // generate gradient operator\n  PetscErrorCode generateGradient(Mat *G);\n  // compute matrix \\f$ Q^T B^N Q \\f$\n  PetscErrorCode generateQTBNQ();\n  // calculate and specify to the Krylov solver the null-space of the LHS matrix\n  // in the pressure-force system\n  virtual PetscErrorCode setNullSpace();\n\n  // assemble RHS of velocity system\n  PetscErrorCode assembleRHSVelocity();\n  // calculate explicit convective and diffusive terms\n  PetscErrorCode calculateExplicitTerms();\n  // update values in ghost nodes at the domain boundaries\n  PetscErrorCode updateBoundaryGhosts();\n  // assemble velocity boundary conditions vector\n  PetscErrorCode generateBC1();\n\n  // aasemble RHS of Poisson system\n  PetscErrorCode assembleRHSPoisson();\n  // assemble boundary conditions vector for the pressure-force system\n  virtual PetscErrorCode generateR2();\n\n  // advance in time\n  virtual PetscErrorCode stepTime();\n  // solve system for intermediate velocity fluxes \\f$ q^* \\f$\n  PetscErrorCode solveIntermediateVelocity();\n  // solver Poisson system for pressure and body forces\n  virtual PetscErrorCode solvePoissonSystem();\n  // project velocity onto divergence-free field with satisfaction of the no-splip condition\n  virtual PetscErrorCode projectionStep();\n\n  // read fluxes from files\n  PetscErrorCode readFluxes(std::string directory);\n  // read velocity components from files\n  PetscErrorCode readVelocities(std::string directory);\n  // read convective terms from files\n  PetscErrorCode readConvectiveTerms(std::string directory);\n  // read pressure field from file\n  virtual PetscErrorCode readLambda(std::string directory);\n#ifdef PETSC_HAVE_HDF5\n  // write grid stations of the different field variables into HDF5 files\n  PetscErrorCode writeGrids();\n#endif\n  // write fluxes into files\n  PetscErrorCode writeFluxes(std::string directory);\n  // write velocity components into files\n  PetscErrorCode writeVelocities(std::string directory);\n  // write convective terms into files\n  PetscErrorCode writeConvectiveTerms(std::string directory);\n  // write pressure field into file\n  virtual PetscErrorCode writeLambda(std::string directory);\n  // write KSP iteration counts into file\n  virtual PetscErrorCode writeIterationCounts();\n  \npublic:\n  // constructors\n  NavierStokesSolver(){ };\n  NavierStokesSolver(CartesianMesh *cartesianMesh, \n                     FlowDescription<dim> *flowDescription, \n                     SimulationParameters *simulationParameters);\n  // destructor\n  ~NavierStokesSolver(){ };\n\n  // initialize systems\n  virtual PetscErrorCode initialize();\n  // clean up at end of simulation\n  virtual PetscErrorCode finalize();\n\n  // evaluate if the simulation is completed\n  PetscBool finished();\n\n  // write numerical solution into respective files\n  virtual PetscErrorCode writeData();\n  // read numerical solution from files\n  PetscErrorCode readData();\n\n}; // NavierStokesSolver\n\n#endif\n", "comment_ratio": 0.24468085106382978}
{"lang": "c", "code": "#pragma once\n\n#include <atomic>\n#include <deque>\n#include <limits>\n#include <set>\n#include <utility>\n#include <vector>\n#include <string>\n\n#include \"db/column_family.h\"\n#include \"db/dbformat.h\"\n#include \"db/flush_scheduler.h\"\n#include \"db/internal_stats.h\"\n#include \"db/job_context.h\"\n#include \"db/log_writer.h\"\n#include \"db/memtable_list.h\"\n#include \"db/snapshot_impl.h\"\n#include \"db/version_edit.h\"\n#include \"db/write_controller.h\"\n#include \"db/write_thread.h\"\n#include \"monitoring/instrumented_mutex.h\"\n#include \"options/db_options.h\"\n#include \"port/port.h\"\n#include \"rocksdb/db.h\"\n#include \"rocksdb/env.h\"\n#include \"rocksdb/memtablerep.h\"\n#include \"rocksdb/transaction_log.h\"\n#include \"table/scoped_arena_iterator.h\"\n#include \"util/autovector.h\"\n#include \"util/event_logger.h\"\n#include \"util/stop_watch.h\"\n#include \"util/thread_local.h\"\n\nnamespace rocksdb {\n\nclass MemTable;\nclass SnapshotChecker;\nclass TableCache;\nclass Version;\nclass VersionEdit;\nclass VersionSet;\nclass Arena;\n\nclass FlushJob {\n public:\n  // TODO(icanadi) make effort to reduce number of parameters here\n  // IMPORTANT: mutable_cf_options needs to be alive while FlushJob is alive\n  FlushJob(const std::string& dbname, ColumnFamilyData* cfd,\n           const ImmutableDBOptions& db_options,\n           const MutableCFOptions& mutable_cf_options,\n           const EnvOptions env_options, VersionSet* versions,\n           InstrumentedMutex* db_mutex, std::atomic<bool>* shutting_down,\n           std::vector<SequenceNumber> existing_snapshots,\n           SequenceNumber earliest_write_conflict_snapshot,\n           SnapshotChecker* snapshot_checker, JobContext* job_context,\n           LogBuffer* log_buffer, Directory* db_directory,\n           Directory* output_file_directory, CompressionType output_compression,\n           Statistics* stats, EventLogger* event_logger, bool measure_io_stats);\n\n  ~FlushJob();\n\n  // Require db_mutex held.\n  // Once PickMemTable() is called, either Run() or Cancel() has to be called.\n  void PickMemTable();\n  Status Run(FileMetaData* file_meta = nullptr);\n  void Cancel();\n  TableProperties GetTableProperties() const { return table_properties_; }\n\n private:\n  void ReportStartedFlush();\n  void ReportFlushInputSize(const autovector<MemTable*>& mems);\n  void RecordFlushIOStats();\n  Status WriteLevel0Table();\n  const std::string& dbname_;\n  ColumnFamilyData* cfd_;\n  const ImmutableDBOptions& db_options_;\n  const MutableCFOptions& mutable_cf_options_;\n  const EnvOptions env_options_;\n  VersionSet* versions_;\n  InstrumentedMutex* db_mutex_;\n  std::atomic<bool>* shutting_down_;\n  std::vector<SequenceNumber> existing_snapshots_;\n  SequenceNumber earliest_write_conflict_snapshot_;\n  SnapshotChecker* snapshot_checker_;\n  JobContext* job_context_;\n  LogBuffer* log_buffer_;\n  Directory* db_directory_;\n  Directory* output_file_directory_;\n  CompressionType output_compression_;\n  Statistics* stats_;\n  EventLogger* event_logger_;\n  TableProperties table_properties_;\n  bool measure_io_stats_;\n\n  // Variables below are set by PickMemTable():\n  FileMetaData meta_;\n  autovector<MemTable*> mems_;\n  VersionEdit* edit_;\n  Version* base_;\n  bool pick_memtable_called;\n};\n\n}  // namespace rocksdb\n\n", "comment_ratio": 0.12389380530973451}
{"lang": "c", "code": "#ifndef CONTENT_TEST_WEBURL_LOADER_MOCK_H_\n#define CONTENT_TEST_WEBURL_LOADER_MOCK_H_\n\n#include \"base/macros.h\"\n#include \"base/memory/scoped_ptr.h\"\n#include \"base/memory/weak_ptr.h\"\n#include \"third_party/WebKit/public/platform/WebURLLoader.h\"\n\nnamespace blink {\nclass WebData;\nstruct WebURLError;\nclass WebURLLoaderClient;\nclass WebURLLoaderTestDelegate;\nclass WebURLRequest;\nclass WebURLResponse;\n}\n\nclass WebURLLoaderMockFactory;\n\n// A simple class for mocking WebURLLoader.\n// If the WebURLLoaderMockFactory it is associated with has been configured to\n// mock the request it gets, it serves the mocked resource.  Otherwise it just\n// forwards it to the default loader.\nclass WebURLLoaderMock : public blink::WebURLLoader {\n public:\n  // This object becomes the owner of |default_loader|.\n  WebURLLoaderMock(WebURLLoaderMockFactory* factory,\n                   blink::WebURLLoader* default_loader);\n  ~WebURLLoaderMock() override;\n\n  // Simulates the asynchronous request being served.\n  void ServeAsynchronousRequest(blink::WebURLLoaderTestDelegate* delegate,\n                                const blink::WebURLResponse& response,\n                                const blink::WebData& data,\n                                const blink::WebURLError& error);\n\n  // Simulates the redirect being served.\n  blink::WebURLRequest ServeRedirect(\n      const blink::WebURLRequest& request,\n      const blink::WebURLResponse& redirectResponse);\n\n  // WebURLLoader methods:\n  void loadSynchronously(const blink::WebURLRequest& request,\n                         blink::WebURLResponse& response,\n                         blink::WebURLError& error,\n                         blink::WebData& data) override;\n  void loadAsynchronously(const blink::WebURLRequest& request,\n                          blink::WebURLLoaderClient* client) override;\n  void cancel() override;\n  void setDefersLoading(bool defer) override;\n\n  bool isDeferred() { return is_deferred_; }\n\n  void setLoadingTaskRunner(blink::WebTaskRunner*) override;\n\n private:\n  WebURLLoaderMockFactory* factory_;\n  blink::WebURLLoaderClient* client_;\n  scoped_ptr<blink::WebURLLoader> default_loader_;\n  bool using_default_loader_;\n  bool is_deferred_;\n\n  base::WeakPtrFactory<WebURLLoaderMock> weak_factory_;\n\n  DISALLOW_COPY_AND_ASSIGN(WebURLLoaderMock);\n};\n\n#endif  // CONTENT_TEST_WEBURL_LOADER_MOCK_H_\n\n", "comment_ratio": 0.1643835616438356}
{"lang": "c", "code": "#pragma once\n\n//   Collision Detection\n// Dynamic VS Dynamic\nbool DetectCollisionDynamicSphereVSDynamicSphere(const CDynamicSphereInstance & c_rSphere1, const CDynamicSphereInstance & c_rSphere2);\nbool DetectCollisionDynamicZCylinderVSDynamicZCylinder(const CDynamicSphereInstance & c_rSphere1, const CDynamicSphereInstance & c_rSphere2);\n// Dynamic VS Static\n//bool DetectCollisionDynamicSphereVSStaticPlane(const CDynamicSphereInstance & c_rSphere, const TPlaneData & c_rPlaneData);\n//bool DetectCollisionDynamicSphereVSStaticSphere(const CDynamicSphereInstance & c_rSphere, const TSphereData & c_rSphereData);\n//bool DetectCollisionDynamicSphereVSStaticCylinder(const CDynamicSphereInstance & c_rSphere, const TCylinderData & c_rCylinderData);\n//bool DetectCollisionDynamicSphereVSStaticBox(const TSphereInstance & c_rSphere, const TBoxData & c_rBoxData);\n// Static VS Static\n//bool DetectCollisionStaticSphereVSStaticSphere(const CDynamicSphereInstance & c_rSphere1, const TSphereData & c_rSphere2);\n//bool DetectCollisionStaticSphereVSStaticCylinder(const CDynamicSphereInstance & c_rSphere, const TCylinderData & c_rCylinder);\n//bool DetectCollisionStaticSphereVSStaticBox(const TSphereData & c_rSphere, const TBoxData & c_rBox);\n\n// Rotation\nfloat GetDegreeFromPosition(float x, float y);\nfloat GetDegreeFromPosition2(float sx, float sy, float ex, float ey);\n\nfloat GetInterpolatedRotation(float begin, float end, float curRate);\nbool IsSameDirectionRotation();\nbool IsCWRotation(float begin, float end);\nbool IsCCWRotation(float begin, float end);\n\nbool IsCWAcuteAngle(float begin, float end);\nbool IsCCWAcuteAngle(float begin, float end);\n\n// NOTE - Finally, this code is same with upper rotating direction code.\nenum EDegree_Direction\n{\n\tDEGREE_DIRECTION_SAME = 0,\n\tDEGREE_DIRECTION_RIGHT = 1,\n\tDEGREE_DIRECTION_LEFT = 2,\n};\nfloat GetDegreeDifference(float fSource, float fTarget);\nint GetRotatingDirection(float fSource, float fTarget);\n\n// Converting Rotation\nfloat CameraRotationToCharacterRotation(float fCameraRotation);\nfloat CharacterRotationToCameraRotation(float fCharacterRotation);\n\n", "comment_ratio": 0.3333333333333333}
{"lang": "c", "code": "#ifndef GrStrokeIndirectTessellator_DEFINED\n#define GrStrokeIndirectTessellator_DEFINED\n\n#include \"src/gpu/tessellate/GrStrokeTessellateOp.h\"\n\nstruct GrVertexWriter;\nstruct SkPoint;\nnamespace skiatest { class Reporter; }\n\n// This class bins strokes into indirect draws for consumption by GrStrokeTessellateShader.\nclass GrStrokeIndirectTessellator : public GrStrokeTessellator {\npublic:\n    // Don't allow more than 2^15 stroke edges in a triangle strip. GrTessellationPathRenderer\n    // already crops paths that require more than 2^10 parametric segments, so this should only\n    // become an issue if we try to draw a stroke with an astronomically wide width.\n    constexpr static int8_t kMaxResolveLevel = 15;\n\n    GrStrokeIndirectTessellator(const SkMatrix&, const GrSTArenaList<SkPath>&,\n                                const SkStrokeRec&, int totalCombinedVerbCnt, SkArenaAlloc*);\n\n    void prepare(GrMeshDrawOp::Target*, const SkMatrix&, const GrSTArenaList<SkPath>&,\n                 const SkStrokeRec&, int totalCombinedVerbCnt) override;\n\n    void draw(GrOpFlushState*) const override;\n\nprivate:\n    int fResolveLevelCounts[kMaxResolveLevel + 1] = {0};  // # of instances at each resolve level.\n    int fTotalInstanceCount = 0;  // Total number of stroke instances we will draw.\n\n    // This array holds a resolveLevel for each stroke in the path, stored in the iteration order of\n    // GrStrokeIterator. If a stroke needs to be chopped, the array will contain a negative number\n    // whose absolute value is the number of chops required, followed by a resolveLevel for each\n    // resulting stroke after the chop(s).\n    int8_t* fResolveLevels = nullptr;\n    // fResolveLevelArrayCount != fTotalInstanceCount because we don't always need to write out\n    // resolve levels for line instances. (If they don't have round caps then their resolve level is\n    // just 0.)\n    SkDEBUGCODE(int fResolveLevelArrayCount = 0;)\n\n    // Stores the in-order chop locations for all chops indicated by fResolveLevels.\n    float* fChopTs = nullptr;\n    SkDEBUGCODE(int fChopTsArrayCount = 0;)\n\n    // GPU buffers for drawing.\n    sk_sp<const GrBuffer> fDrawIndirectBuffer;\n    sk_sp<const GrBuffer> fInstanceBuffer;\n    size_t fDrawIndirectOffset;\n    int fDrawIndirectCount = 0;\n\n    friend class GrOp;  // For ctor.\n\n#if GR_TEST_UTILS\npublic:\n    void verifyResolveLevels(skiatest::Reporter*, class GrMockOpTarget*, const SkMatrix&,\n                             const SkPath&, const SkStrokeRec&);\n    void verifyBuffers(skiatest::Reporter*, class GrMockOpTarget*, const SkMatrix&,\n                       const SkStrokeRec&);\n    class Benchmark;\n#endif\n};\n\n#endif\n\n", "comment_ratio": 0.22857142857142856}
{"lang": "c", "code": "#import \"NSObject.h\"\n\n@class ICSelectorDelayer, NSDictionary, NSMutableDictionary, NSMutableSet, NSObject<OS_dispatch_queue>, NSOperationQueue, NSTimer;\n\n@interface ICCloudContext : NSObject\n{\n    BOOL _fetchOperationsPending;\n    BOOL _needsToUpdateSubscriptions;\n    BOOL _enableLongLivedOperations;\n    BOOL _disableAutomaticallyRetryNetworkFailures;\n    BOOL _disableRetryTimer;\n    BOOL _disabled;\n    BOOL _disabledInternal;\n    BOOL _needsToProcessAllObjects;\n    BOOL _didAddObservers;\n    BOOL _fetchingEnabled;\n    BOOL _syncDisabledByServer;\n    BOOL _didCheckForLongLivedOperations;\n    id <ICCloudContextDelegate> _cloudContextDelegate;\n    long long _qualityOfService;\n    unsigned long long _discretionaryNetworkBehavior;\n    NSOperationQueue *_operationQueue;\n    NSObject<OS_dispatch_queue> *_processingQueue;\n    NSObject<OS_dispatch_queue> *_containersCreationQueue;\n    NSMutableSet *_objectIDsToRetry;\n    NSTimer *_retryTimer;\n    NSMutableDictionary *_retryCountsByOperationType;\n    NSMutableSet *_objectIDsToProcess;\n    ICSelectorDelayer *_processingSelectorDelayer;\n    ICSelectorDelayer *_syncSelectorDelayer;\n    NSDictionary *_containersByAccountID;\n    NSMutableDictionary *_accountZoneIDsNeedingFetchChanges;\n    NSMutableDictionary *_accountZoneIDsFetchingChanges;\n    NSMutableDictionary *_accountZoneIDsNeedingToBeSaved;\n    NSMutableSet *_subscribedSubscriptionIDs;\n}\n\n+ (void)deleteAllServerChangeTokens;\n+ (BOOL)shouldIgnoreErrorForBackoffTimer:(id)arg1;\n+ (id)errorCodesToIgnoreForBackoffTimer;\n+ (id)zoneIDsFromZoneInfos:(id)arg1;\n+ (id)zoneInfosFromZoneIDs:(id)arg1;\n+ (BOOL)isZoneConfigurations:(id)arg1 subsetOfZoneConfigurations:(id)arg2;\n+ (id)errorsFromError:(id)arg1;\n+ (BOOL)haveZoneIDsInAccountZoneIDs:(id)arg1;\n+ (id)allZoneIDsInAccountZoneIDs:(id)arg1;\n+ (id)deduplicatedRecordsForCloudObjects:(id)arg1;\n+ (id)objectsByDatabaseScope:(id)arg1;\n+ (id)objectsByAccount:(id)arg1;\n+ (id)sortedRecords:(id)arg1;\n+ (void)batchRecordsToSave:(id)arg1 delete:(id)arg2 maxRecordCountPerBatch:(unsigned long long)arg3 maxRecordSizePerBatch:(unsigned long long)arg4 withBlock:(CDUnknownBlockType)arg5;\n+ (id)userRecordNameForContainer:(id)arg1;\n+ (id)errorFromOperations:(id)arg1;\n+ (id)errorFromErrors:(id)arg1;\n+ (id)errorForWaitingForRetryTimer;\n+ (id)errorForDisabledCloudSyncing;\n+ (id)metadataZoneID;\n+ (id)notesZoneID;\n+ (id)newNotesContainerForAccountID:(id)arg1;\n+ (id)newNotesContainer;\n+ (id)sharedContext;\n@property(nonatomic) BOOL didCheckForLongLivedOperations; // @synthesize didCheckForLongLivedOperations=_didCheckForLongLivedOperations;\n@property(retain) NSMutableSet *subscribedSubscriptionIDs; // @synthesize subscribedSubscriptionIDs=_subscribedSubscriptionIDs;\n@property(retain, nonatomic) NSMutableDictionary *accountZoneIDsNeedingToBeSaved; // @synthesize accountZoneIDsNeedingToBeSaved=_accountZoneIDsNeedingToBeSaved;\n@property(retain, nonatomic) NSMutableDictionary *accountZoneIDsFetchingChanges; // @synthesize accountZoneIDsFetchingChanges=_accountZoneIDsFetchingChanges;\n@property(retain, nonatomic) NSMutableDictionary *accountZoneIDsNeedingFetchChanges; // @synthesize accountZoneIDsNeedingFetchChanges=_accountZoneIDsNeedingFetchChanges;\n@property(retain, nonatomic) NSDictionary *containersByAccountID; // @synthesize containersByAccountID=_containersByAccountID;\n@property(nonatomic) BOOL syncDisabledByServer; // @synthesize syncDisabledByServer=_syncDisabledByServer;\n@property(nonatomic, getter=isFetchingEnabled) BOOL fetchingEnabled; // @synthesize fetchingEnabled=_fetchingEnabled;\n@property(nonatomic) BOOL didAddObservers; // @synthesize didAddObservers=_didAddObservers;\n@property(retain) ICSelectorDelayer *syncSelectorDelayer; // @synthesize syncSelectorDelayer=_syncSelectorDelayer;\n@property(retain) ICSelectorDelayer *processingSelectorDelayer; // @synthesize processingSelectorDelayer=_processingSelectorDelayer;\n@property(retain, nonatomic) NSMutableSet *objectIDsToProcess; // @synthesize objectIDsToProcess=_objectIDsToProcess;\n@property(nonatomic) BOOL needsToProcessAllObjects; // @synthesize needsToProcessAllObjects=_needsToProcessAllObjects;\n@property(getter=isDisabledInternal) BOOL disabledInternal; // @synthesize disabledInternal=_disabledInternal;\n@property(retain, nonatomic) NSMutableDictionary *retryCountsByOperationType; // @synthesize retryCountsByOperationType=_retryCountsByOperationType;\n@property(retain) NSTimer *retryTimer; // @synthesize retryTimer=_retryTimer;\n@property(retain, nonatomic) NSMutableSet *objectIDsToRetry; // @synthesize objectIDsToRetry=_objectIDsToRetry;\n@property(retain, nonatomic) NSObject<OS_dispatch_queue> *containersCreationQueue; // @synthesize containersCreationQueue=_containersCreationQueue;\n@property(retain, nonatomic) NSObject<OS_dispatch_queue> *processingQueue; // @synthesize processingQueue=_processingQueue;\n@property(retain, nonatomic) NSOperationQueue *operationQueue; // @synthesize operationQueue=_operationQueue;\n@property(getter=isDisabled) BOOL disabled; // @synthesize disabled=_disabled;\n@property(nonatomic) BOOL disableRetryTimer; // @synthesize disableRetryTimer=_disableRetryTimer;\n@property(nonatomic) BOOL disableAutomaticallyRetryNetworkFailures; // @synthesize disableAutomaticallyRetryNetworkFailures=_disableAutomaticallyRetryNetworkFailures;\n@property(nonatomic) BOOL enableLongLivedOperations; // @synthesize enableLongLivedOperations=_enableLongLivedOperations;\n@property(nonatomic) unsigned long long discretionaryNetworkBehavior; // @synthesize discretionaryNetworkBehavior=_discretionaryNetworkBehavior;\n@property(nonatomic) long long qualityOfService; // @synthesize qualityOfService=_qualityOfService;\n@property BOOL needsToUpdateSubscriptions; // @synthesize needsToUpdateSubscriptions=_needsToUpdateSubscriptions;\n@property(readonly, nonatomic) BOOL fetchOperationsPending; // @synthesize fetchOperationsPending=_fetchOperationsPending;\n@property(nonatomic) __weak id <ICCloudContextDelegate> cloudContextDelegate; // @synthesize cloudContextDelegate=_cloudContextDelegate;\n- (void).cxx_destruct;\n- (void)observeValueForKeyPath:(id)arg1 ofObject:(id)arg2 change:(id)arg3 context:(void *)arg4;\n- (id)serverChangeTokenForChangedZonesInDatabase:(id)arg1 accountID:(id)arg2;\n- (void)deleteServerChangeTokenForChangedZonesInDatabase:(id)arg1 accountID:(id)arg2;\n- (void)saveServerChangeToken:(id)arg1 forChangedZonesInDatabase:(id)arg2 accountID:(id)arg3;\n- (void)deleteServerChangeTokenForRecordZoneID:(id)arg1 databaseScope:(long long)arg2 accountID:(id)arg3;\n- (id)serverChangeTokenForRecordZoneID:(id)arg1 databaseScope:(long long)arg2 accountID:(id)arg3;\n- (void)saveServerChangeToken:(id)arg1 forRecordZoneID:(id)arg2 databaseScope:(long long)arg3 accountID:(id)arg4;\n- (void)retryOperationsIfNecessary;\n- (void)startRetryTimerIfNecessaryWithError:(id)arg1;\n- (void)incrementOrClearRetryCountForOperationType:(id)arg1 error:(id)arg2;\n- (void)clearRetryCountForOperationType:(id)arg1;\n- (void)incrementRetryCountForOperationType:(id)arg1;\n- (void)checkForLongLivedOperations;\n- (void)updateCloudContextStateOnlyIfReachable:(BOOL)arg1;\n- (void)updateCloudContextState;\n- (BOOL)isInForeground;\n- (void)clearSubscribedSubscriptionIDs;\n- (void)saveSubscriptionsForDatabase:(id)arg1 completionHandler:(CDUnknownBlockType)arg2;\n- (void)fetchSubscriptionsForDatabase:(id)arg1 completionHandler:(CDUnknownBlockType)arg2;\n- (void)updateSubscriptionsWithCompletionHandler:(CDUnknownBlockType)arg1;\n- (id)subscriptionForDatabase:(id)arg1;\n- (void)clearZoneFetchState;\n- (void)saveZoneFetchState;\n- (void)loadZoneFetchState;\n- (void)fetchDatabaseChangesOperation:(id)arg1 finishedWithServerChangeToken:(id)arg2 accountID:(id)arg3 error:(id)arg4 completionHandler:(CDUnknownBlockType)arg5;\n- (void)fetchDatabaseChangesOperation:(id)arg1 changeTokenUpdated:(id)arg2 accountID:(id)arg3;\n- (void)fetchDatabaseChangesOperation:(id)arg1 recordZoneWithIDWasDeleted:(id)arg2 accountID:(id)arg3;\n- (void)fetchDatabaseChangesOperation:(id)arg1 recordZoneWithIDChanged:(id)arg2 accountID:(id)arg3;\n- (id)operationToFetchDatabaseChangesForDatabase:(id)arg1 completionHandler:(CDUnknownBlockType)arg2;\n- (void)fetchDatabaseChangesForDatabases:(id)arg1 reason:(id)arg2 completionHandler:(CDUnknownBlockType)arg3;\n- (void)fetchDatabaseChangesWithReason:(id)arg1 completionHandler:(CDUnknownBlockType)arg2;\n- (void)fireSyncRequest;\n- (void)syncIfNeeded;\n- (void)fetchRecordZoneChangesOperation:(id)arg1 zoneID:(id)arg2 accountID:(id)arg3 changeTokenUpdated:(id)arg4;\n- (void)fetchRecordZoneChangesOperation:(id)arg1 recordWasDeletedWithRecordID:(id)arg2 recordType:(id)arg3 context:(id)arg4;\n- (void)fetchRecordZoneChangesOperation:(id)arg1 recordChanged:(id)arg2 context:(id)arg3;\n- (void)fetchRecordZoneChangesOperationDidComplete:(id)arg1 error:(id)arg2;\n- (void)fetchRecordZoneChangesOperation:(id)arg1 completedFetchForZoneID:(id)arg2 serverChangeToken:(id)arg3 error:(id)arg4;\n- (id)newOperationToFetchRecordZoneChangesWithZoneConfigurations:(id)arg1 database:(id)arg2;\n- (id)operationToFetchRecordZoneChangesForZoneIDs:(id)arg1 database:(id)arg2;\n- (id)operationsToFetchRecordZoneChangesForZoneIDs:(id)arg1 accountID:(id)arg2;\n- (void)addOperationsToFetchRecordZoneChangesForAccountZoneIDs:(id)arg1 reason:(id)arg2 completionHandler:(CDUnknownBlockType)arg3;\n- (void)fetchRecordZoneChangesForAccountZoneIDs:(id)arg1 reason:(id)arg2 completionHandler:(CDUnknownBlockType)arg3;\n- (void)fetchRecordZoneChangesForZoneIDs:(id)arg1 accountID:(id)arg2 reason:(id)arg3 completionHandler:(CDUnknownBlockType)arg4;\n- (void)fetchRecordZoneChangesWithReason:(id)arg1 completionHandler:(CDUnknownBlockType)arg2;\n- (void)validateAccountZoneIDsNeedingFetchChanges;\n- (void)handleNotification:(id)arg1 completionHandler:(CDUnknownBlockType)arg2;\n- (void)handleDatabaseNotification:(id)arg1 completionHandler:(CDUnknownBlockType)arg2;\n- (void)_processCloudObjects:(id)arg1 operationQueue:(id)arg2 completionHandler:(CDUnknownBlockType)arg3;\n- (void)processObjectIDs:(id)arg1 operationQueue:(id)arg2 completionHandler:(CDUnknownBlockType)arg3;\n- (void)processAllCloudObjectsWithCompletionHandler:(CDUnknownBlockType)arg1;\n- (void)processPendingCloudObjectsWithCompletionHandler:(CDUnknownBlockType)arg1;\n- (void)processPendingCloudObjects;\n- (void)addOperationToProcessObjectsWithCompletionHandler:(CDUnknownBlockType)arg1;\n- (void)contextDidSave:(id)arg1;\n- (id)operationToSaveZonesForZoneIDs:(id)arg1 accountID:(id)arg2;\n- (id)operationToSaveZonesIfNecessaryForAccountID:(id)arg1;\n- (void)addDependenciesForModifyRecordsOperation:(id)arg1;\n- (void)recursiveCancelDependentOperations:(id)arg1;\n- (BOOL)partialError:(id)arg1 containsErrorCode:(long long)arg2;\n- (void)handleGenericPartialFailuresForError:(id)arg1 operation:(id)arg2;\n- (void)modifyRecordsOperation:(id)arg1 didCompleteWithSavedRecords:(id)arg2 deletedRecordIDs:(id)arg3 rootRecordIDsByShareID:(id)arg4 error:(id)arg5;\n- (void)modifyRecordsOperation:(id)arg1 perDeleteRecordIDCompletion:(id)arg2 rootRecordIDsByShareID:(id)arg3 error:(id)arg4;\n- (void)modifyRecordsOperation:(id)arg1 perSaveRecordCompletion:(id)arg2 error:(id)arg3;\n- (void)addCallbackBlocksToModifyRecordsOperation:(id)arg1 rootRecordIDsByShareID:(id)arg2;\n- (id)operationToModifyRecordsToSave:(id)arg1 delete:(id)arg2 rootRecordIDsByShareID:(id)arg3 database:(id)arg4;\n- (id)operationsToModifyRecordsToSave:(id)arg1 delete:(id)arg2 rootRecordIDsByShareID:(id)arg3 database:(id)arg4;\n- (id)operationsToModifyRecordsForCloudObjectsToSave:(id)arg1 delete:(id)arg2 deleteShares:(id)arg3 saveUserSpecificRecords:(id)arg4 operationGroupName:(id)arg5 addDependencies:(BOOL)arg6 accountID:(id)arg7;\n- (void)_addModifyRecordsOperationsWithCloudObjectsToSave:(id)arg1 delete:(id)arg2 accountID:(id)arg3 operationGroupName:(id)arg4 waitForDependencies:(BOOL)arg5 completionHandler:(CDUnknownBlockType)arg6;\n- (void)addModifyRecordsOperationsWithCloudObjectsToSave:(id)arg1 delete:(id)arg2 accountID:(id)arg3 operationGroupName:(id)arg4 waitForDependencies:(BOOL)arg5 completionHandler:(CDUnknownBlockType)arg6;\n- (void)deleteSharesForObjects:(id)arg1 accountID:(id)arg2 completionHandler:(CDUnknownBlockType)arg3;\n- (void)deleteSharesForObjects:(id)arg1 completionHandler:(CDUnknownBlockType)arg2;\n- (void)pushCloudObjects:(id)arg1 operationGroupName:(id)arg2 completionHandler:(CDUnknownBlockType)arg3;\n- (void)didFetchShare:(id)arg1 accountID:(id)arg2 context:(id)arg3;\n- (void)fetchOperation:(id)arg1 didCompleteWithRecordsByRecordID:(id)arg2 error:(id)arg3;\n- (void)fetchOperation:(id)arg1 fetchedRecord:(id)arg2 recordID:(id)arg3 error:(id)arg4;\n- (void)fetchOperation:(id)arg1 progressWithRecordID:(id)arg2 progress:(double)arg3;\n- (id)operationToFetchRecordIDs:(id)arg1 database:(id)arg2 qualityOfService:(long long)arg3;\n- (id)operationsToFetchRecordIDs:(id)arg1 database:(id)arg2 qualityOfService:(long long)arg3;\n- (id)operationsToFetchRecordIDs:(id)arg1 qualityOfService:(long long)arg2 operationGroupName:(id)arg3 accountID:(id)arg4;\n- (void)addFetchOperationsForRecordIDs:(id)arg1 accountID:(id)arg2 qualityOfService:(long long)arg3 operationGroupName:(id)arg4 completionHandler:(CDUnknownBlockType)arg5;\n- (void)fetchRecordIDs:(id)arg1 accountID:(id)arg2 operationGroupName:(id)arg3 completionHandler:(CDUnknownBlockType)arg4;\n- (void)fetchCloudObjects:(id)arg1 accountID:(id)arg2 completionHandler:(CDUnknownBlockType)arg3;\n- (id)newPlaceholderObjectForRecordID:(id)arg1 recordType:(id)arg2 accountID:(id)arg3 context:(id)arg4;\n- (id)newCloudObjectForRecord:(id)arg1 accountID:(id)arg2 context:(id)arg3;\n- (id)existingCloudObjectForUserSpecificRecordID:(id)arg1 createPlaceholderIfNecessary:(BOOL)arg2 accountID:(id)arg3 context:(id)arg4;\n- (id)existingCloudObjectForRecordID:(id)arg1 recordType:(id)arg2 accountID:(id)arg3 context:(id)arg4 excludingRecordTypes:(id)arg5;\n- (id)existingCloudObjectForRecordID:(id)arg1 recordType:(id)arg2 accountID:(id)arg3 context:(id)arg4;\n- (id)existingCloudObjectForRecord:(id)arg1 accountID:(id)arg2 context:(id)arg3;\n- (void)fetchUserRecordWithContainer:(id)arg1 completionHandler:(CDUnknownBlockType)arg2;\n- (void)fetchUserRecordWithAccountID:(id)arg1 completionHandler:(CDUnknownBlockType)arg2;\n- (void)updateAccountStatusWithCompletionHandler:(CDUnknownBlockType)arg1;\n@property(nonatomic) long long accountStatus;\n- (void)pauseCloudSyncWhileSynchronouslyPerformingBlock:(CDUnknownBlockType)arg1;\n- (void)finishOperationsForRecordID:(id)arg1 completionHandler:(CDUnknownBlockType)arg2;\n- (BOOL)canRetryImmediatelyAfterError:(id)arg1;\n- (double)timeIntervalToRetryAfterFromError:(id)arg1;\n- (BOOL)isInternetReachable;\n- (BOOL)isFetchingAllRecordZones;\n- (void)deleteRecordZonesWithZoneIDs:(id)arg1 accountID:(id)arg2 markZonesAsUserPurged:(BOOL)arg3 completionHandler:(CDUnknownBlockType)arg4;\n- (void)clearPendingActivity;\n- (void)cancelEverythingWithCompletionHandler:(CDUnknownBlockType)arg1;\n- (void)_syncWithReason:(id)arg1 completionHandler:(CDUnknownBlockType)arg2;\n- (void)syncWithReason:(id)arg1 onlyIfReachable:(BOOL)arg2 completionHandler:(CDUnknownBlockType)arg3;\n- (void)syncWithReason:(id)arg1 completionHandler:(CDUnknownBlockType)arg2;\n- (id)allCloudObjectsInContext:(id)arg1;\n- (void)receivedZoneNotFound:(id)arg1 operation:(id)arg2;\n- (id)allZoneIDs;\n- (void)addStateHandler;\n- (void)printOperationQueue;\n- (BOOL)hasPendingOperations;\n- (void)cloudKitAccountChanged:(id)arg1;\n- (void)reachabilityChanged:(id)arg1;\n@property(readonly, nonatomic) NSDictionary *cloudObjectClassesByRecordType;\n- (void)updateSelectorDelayers;\n- (void)updateConfiguration;\n- (void)disableCloudSyncingIfCurrentVersionNotSuppported;\n- (BOOL)isCloudKitAccountAvailable;\n- (BOOL)isReadyToSync;\n- (id)readinessLoggingDescription;\n- (void)dealloc;\n- (id)containerForAccountID:(id)arg1;\n- (void)clearContainers;\n- (id)init;\n\n@end\n\n\n", "comment_ratio": 0.1511111111111111}
{"lang": "c", "code": "// Position @ 40, 60, 80, 100, 120, 140, 160, 180, 200, 220 MHzstruct Filter\nstruct Filter\n{\n  uint32_t fg;\n  int control_input_a;\n  int control_input_b;\n};\n\nstruct FrequencyRange\n{\n  uint32_t START_FREQUENCY;\n  uint32_t STOP_FREQUENCY;\n  uint32_t CENTER_FREQUENCY;\n  Filter FILTER;\n  uint32_t TUNING_CENTER_POSITION;\n  uint32_t MATCHING_CENTER_POSITION;\n};\n\nconst Filter FG_71MHZ = {71000000U, HIGH, HIGH};\nconst Filter FG_120MHZ = {120000000U, LOW, HIGH};\nconst Filter FG_180MHZ = {180000000U, LOW, LOW};\nconst Filter FG_260MHZ = {260000000U, HIGH, LOW};\n\n// Settings for 100MHz -18dB\n//#define TUNING_STEPPER_HOME 34250U\n//#define MATCHING_STEPPER_HOME 45000U\nconst FrequencyRange RANGE_35_70MHZ =\n    {\n        35000000U,\n        75000000U,\n        55000000U,\n        FG_71MHZ,\n        34250U, // FIND VALUES\n        45000U, // FIND VALUES\n};\n\nconst FrequencyRange RANGE_70_125MHZ =\n    {\n        70000000U,\n        125000000U,\n        100000000U,\n        FG_120MHZ,\n        34400U,\n        48500U,\n};\n\nconst FrequencyRange RANGE_125_180MHZ =\n    {\n        125000000U,\n        180000000U,\n        150000000U,\n        FG_180MHZ,\n        34250U, // FIND VALUES\n        45000U, // FIND VALUES\n};\n\nconst FrequencyRange HOME_RANGE = RANGE_70_125MHZ;\n\n// Settings for 125MHz -30dB\n//#define TUNING_STEPPER_HOME 37550U\n//#define MATCHING_STEPPER_HOME 29500U\n", "comment_ratio": 0.18032786885245902}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n#import \"CustomIOSAlertView.h\"\n#import \"UIColor+MyColor.h\"\n\n@interface EVLoginController : UIViewController\n\n@property (nonatomic, strong) CustomIOSAlertView *alertView;\n@property (weak, nonatomic) IBOutlet UIImageView *imageView;\n@property (weak, nonatomic) IBOutlet UIButton *buttonIn;\n@property (weak, nonatomic) IBOutlet UITextField *userField;\n@property (weak, nonatomic) IBOutlet UITextField *pwdField;\n\n-(IBAction)logIn;\n\n@end\n\n", "comment_ratio": 0.2916666666666667}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n\n@class PullDownMenu;\n\n//\u4e0b\u62c9\u83dc\u5355\u6570\u636e\u6e90\u534f\u8bae\n@protocol PullDownMenuDataSource <NSObject>\n\n//\u4e0b\u62c9\u83dc\u5355\u6709\u591a\u5c11\u5217\n- (NSInteger)numberOfColsInMenu:(PullDownMenu *)pullDownMenu;\n\n//\u4e0b\u62c9\u83dc\u5355\u6bcf\u5217\u6309\u94ae\u5916\u89c2\n- (UIButton *)pullDownMenu:(PullDownMenu *)pullDownMenu buttonForColAtIndex:(NSInteger)index;\n\n//\u4e0b\u62c9\u83dc\u5355\u6bcf\u5217\u5bf9\u5e94\u7684\u63a7\u5236\u5668\n- (UIViewController *)pullDownMenu:(PullDownMenu *)pullDownMenu viewControllerForColAtIndex:(NSInteger)index;\n\n//\u4e0b\u62c9\u83dc\u5355\u6bcf\u5217\u5bf9\u5e94\u7684\u9ad8\u5ea6\n- (CGFloat)pullDownMenu:(PullDownMenu *)pullDownMenu heightForColAtIndex:(NSInteger)index;\n\n@end\n\nextern NSString * const UpdateMenuTitleNote;\n\n@protocol PullDownMenuDelegate <NSObject>\n\n-(void)PullDownMenuWithMessage:(id)message andIndex:(NSString *)indexStr;\n\n//\u4e0b\u62c9\u83dc\u5355\u6bcf\u5217\n- (void)pullDownMenu:(PullDownMenu *)pullDownMenu didSelectedForCellWithButtonTitle:(NSString *)title;\n\n@end\n\n@interface PullDownMenu : UIView\n\n@property (nonatomic, weak) id<PullDownMenuDelegate> delegate;\n\n//\u4e0b\u62c9\u83dc\u5355\u6570\u636e\u6e90\n@property (nonatomic, weak) id<PullDownMenuDataSource> dataSource;\n\n//\u5206\u5272\u7ebf\u989c\u8272\n@property (nonatomic, strong) UIColor *separateLineColor;\n\n//\u5206\u5272\u7ebf\u8ddd\u79bb\u9876\u90e8\u95f4\u8ddd\uff0c\u9ed8\u8ba410\n@property (nonatomic, assign) NSInteger separateLineTopMargin;\n\n//\u8499\u7248\u989c\u8272\n@property (nonatomic, strong) UIColor *coverColor;\n\n//\u5237\u65b0\u4e0b\u62c9\u83dc\u5355\n- (void)reload;\n\n@end\n\n", "comment_ratio": 0.29508196721311475}
{"lang": "c", "code": "#import \"DVTPagingSheetWindowController.h\"\n\n@class DVTTeamRecord, NSArray, NSError, NSMapTable, NSString;\n\n@interface IDEAccountTeamPickerWindowController : DVTPagingSheetWindowController\n{\n    BOOL _wantsMultipleSelection;\n    BOOL _wantsEmptySelectionOption;\n    DVTTeamRecord *_previouslySelectedTeam;\n    NSString *_userFacingReason;\n    NSString *_comprehensiveUserFacingReason;\n    id _teamFilter;\n    NSString *_noFilterResultsUserFacingReason;\n    NSString *_emptySelectionOptionTitle;\n    NSMapTable *_selectedAccountsToTeamsMap;\n    NSError *_error;\n    NSMapTable *_allAccountsToAllTeamDictionariesFromToken;\n    NSArray *_accountWrappers;\n}\n\n- (void).cxx_destruct;\n@property(copy, nonatomic) NSArray *accountWrappers; // @synthesize accountWrappers=_accountWrappers;\n@property(copy, nonatomic) NSMapTable *allAccountsToAllTeamDictionariesFromToken; // @synthesize allAccountsToAllTeamDictionariesFromToken=_allAccountsToAllTeamDictionariesFromToken;\n@property(retain, nonatomic) NSString *comprehensiveUserFacingReason; // @synthesize comprehensiveUserFacingReason=_comprehensiveUserFacingReason;\n@property(retain, nonatomic) NSString *emptySelectionOptionTitle; // @synthesize emptySelectionOptionTitle=_emptySelectionOptionTitle;\n@property(retain, nonatomic) NSError *error; // @synthesize error=_error;\n@property(retain, nonatomic) NSString *noFilterResultsUserFacingReason; // @synthesize noFilterResultsUserFacingReason=_noFilterResultsUserFacingReason;\n@property(retain, nonatomic) DVTTeamRecord *previouslySelectedTeam; // @synthesize previouslySelectedTeam=_previouslySelectedTeam;\n@property(retain, nonatomic) NSMapTable *selectedAccountsToTeamsMap; // @synthesize selectedAccountsToTeamsMap=_selectedAccountsToTeamsMap;\n@property(copy, nonatomic) id teamFilter; // @synthesize teamFilter=_teamFilter;\n@property(retain, nonatomic) NSString *userFacingReason; // @synthesize userFacingReason=_userFacingReason;\n@property(nonatomic) BOOL wantsEmptySelectionOption; // @synthesize wantsEmptySelectionOption=_wantsEmptySelectionOption;\n@property(nonatomic) BOOL wantsMultipleSelection; // @synthesize wantsMultipleSelection=_wantsMultipleSelection;\n- (void)windowDidLoad;\n\n@end\n\n\n", "comment_ratio": 0.2727272727272727}
{"lang": "c", "code": "#ifndef __FIRMWARE_VOLUME_IMAGE_FORMAT_H__\r\n#define __FIRMWARE_VOLUME_IMAGE_FORMAT_H__\r\n\r\n//\r\n// Bit values for AuthenticationStatus\r\n//\r\n#define EFI_AGGREGATE_AUTH_STATUS_PLATFORM_OVERRIDE 0x000001\r\n#define EFI_AGGREGATE_AUTH_STATUS_IMAGE_SIGNED      0x000002\r\n#define EFI_AGGREGATE_AUTH_STATUS_NOT_TESTED        0x000004\r\n#define EFI_AGGREGATE_AUTH_STATUS_TEST_FAILED       0x000008\r\n#define EFI_AGGREGATE_AUTH_STATUS_ALL               0x00000f\r\n\r\n#define EFI_LOCAL_AUTH_STATUS_PLATFORM_OVERRIDE     0x010000\r\n#define EFI_LOCAL_AUTH_STATUS_IMAGE_SIGNED          0x020000\r\n#define EFI_LOCAL_AUTH_STATUS_NOT_TESTED            0x040000\r\n#define EFI_LOCAL_AUTH_STATUS_TEST_FAILED           0x080000\r\n#define EFI_LOCAL_AUTH_STATUS_ALL                   0x0f0000\r\n\r\n#endif\r\n\n", "comment_ratio": 0.10256410256410256}
{"lang": "c", "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <emscripten.h>\n\n#include \"wasm3.h\"\n#include \"m3_env.h\"\n\nIM3Environment env;\n\nEMSCRIPTEN_KEEPALIVE\nvoid init() {\n    env = m3_NewEnvironment ();\n    if (!env) return;\n}\n\nEMSCRIPTEN_KEEPALIVE\nIM3Runtime new_runtime() {\n    return m3_NewRuntime (env, 64*1024, NULL);\n}\n\nEMSCRIPTEN_KEEPALIVE\nvoid free_runtime(IM3Runtime runtime) {\n    m3_FreeRuntime (runtime);\n}\n\nEMSCRIPTEN_KEEPALIVE\nvoid load(IM3Runtime runtime, uint8_t* wasm, size_t fsize) {\n    M3Result result = m3Err_none;\n\n    IM3Module module;\n    result = m3_ParseModule (env, &module, wasm, fsize);\n    if (result) return;\n\n    result = m3_LoadModule (runtime, module);\n    if (result) return;\n}\n\nEMSCRIPTEN_KEEPALIVE\nuint32_t call(IM3Runtime runtime, int argc, const char* argv[]) {\n    M3Result result = m3Err_none;\n\n    IM3Function f;\n    result = m3_FindFunction (&f, runtime, argv[0]);\n    if (result) return -1;\n\n    result = m3_CallArgv (f, argc-1, argv+1);\n    if (result) return -2;\n\n    return *(uint64_t*)(runtime->stack);\n}\n\n", "comment_ratio": 0.10344827586206896}
{"lang": "c", "code": "#ifndef NETWORK_INPUT_FILTER_PARTICLE_FILTER_H\n#define NETWORK_INPUT_FILTER_PARTICLE_FILTER_H\n\n#include <random>\n\n#include \"software/new_geom/point.h\"\n#include \"software/util/parameter/dynamic_parameters.h\"\n\n/**\n * Finds and filters the \"real\" ball from the received data\n */\nconst unsigned int num_particles       = 500;\nconst double max_ball_confidence       = 100.0;\nconst double max_particle_standard_dev = 0.05;\nconst double min_particle_standard_dev = 0.001;\n\n// This is used as a placeholder point for when we don't have real data\nconst Point TMP_POINT = Point(-99.99, -99.99);\n\n/**\n * Defines a particle used by the particle filter.\n *\n * A particle is a point with an associated confidence value that indicates how\n * likely\n * the particle is to be object you are tracking\n */\nstruct Particle\n{\n    Particle(Point p = Point(), double c = 0.0) : position(p), confidence(c) {}\n\n    Point position;\n    double confidence;\n\n    /**\n     * Overrides the less-than operator so that it compares the confidence of\n     * the particles\n     *\n     * Used with std::sort to sort a vector of Particles by their confidence\n     * values\n     */\n    inline bool operator<(const Particle& p) const\n    {\n        return confidence < p.confidence;\n    }\n};\n\n/**\n * Implements the basic mathematics of a Particle filter.\n */\nclass ParticleFilter final\n{\n   public:\n    /**\n     * The constructor for the particle filter.\n     *\n     * @param length the length of the field the particle filter is operating on\n     * @param width the width of the field the particle filter is operating on\n     */\n    explicit ParticleFilter(double length, double width);\n\n    /**\n     * Adds a point to the Particle Filter\n     *\n     * Adds a particle with the given position to the Particle Filter.\n     * The particle filter uses these points that are added\n     * as the basepoints for generating more particles\n     *\n     * @param pos the position of the particle to be added\n     */\n    void add(Point pos);\n\n    /**\n     * Updates the state of the Particle Filter, generating new particles and\n     * re-evaluating them.\n     *\n     * Steps:\n     * - Generate new particles around the given basepoints (points added with\n     * the add() function)\n     * - Evaluate each new particle and update its confidence value\n     * - Select new basepoints from the particles with the highest confidence\n     * - Repeat the above steps for the number of condensations. This should\n     *   cause the particles and basepoints to converge to the most confident\n     * position (the real ball).\n     * - Finally, take the mean of the final, most confident basepoints and use\n     * that as the ball location\n     *\n     * @param ballPredictedPos an optional parameter for the ball's predicted\n     * position. The Particle Filter uses this Point to help evaluate the\n     * particles,\n     * since particles that are closer to the ball's predicted position are more\n     * likely\n     * to be the ball\n     */\n    void update(Point ballPredictedPos = TMP_POINT);\n\n    /**\n     * Returns the ball's estimated position\n     *\n     * @return the ball's estimated position\n     */\n    Point getEstimate();\n\n    /**\n     * Returns the variance corresponding to the ball's estimated position\n     *\n     * @return the variance corresponding to the ball's estimated position\n     */\n    double getEstimateVariance();\n\n   private:\n    // Holds the list of particles the filter uses\n    std::vector<Particle> particles;\n\n    // The seed for the random number generators\n    unsigned int seed;\n\n    // The generator used with the normal_distrubution to generate\n    // values with a gaussian distribution\n    std::default_random_engine generator;\n\n    // The generator used to generate random linear values. This is used to\n    // generate Particles spread across the whole field\n    std::minstd_rand0 linearGenerator;\n\n    // Holds the list of points that are added with the add() function. We can\n    // expect these\n    // to be any ball positions detected by vision. Essentially, these are all\n    // the places the\n    // ball \"could\" be\n    std::vector<Point> detections;\n\n    // The points we are the most confident in, and the ones we will use to\n    // generate the\n    // next set of particles\n    std::vector<Point> basepoints;\n\n    // These maintain some state for the ball\n    Point ballPosition;\n    Point ballPredictedPosition;\n    double ballPositionVariance;\n\n    // How confident the filter is that the position it's reporting is the\n    // actual position of the ball.\n    // This value decays when we have no camera data (since we are only guessing\n    // based of off physics where the ball is),\n    // and increases when we do have camera data that comes close to our\n    // predictions\n    double ballConfidence;\n\n    // The filter stores the field size\n    double length_;\n    double width_;\n\n    /**\n     * Generates new particles around the given basepoints\n     *\n     * Generates PARTICLE_FILTER_NUM_PARTICLES Particles in gaussian\n     * distributions around the given basepoints. If no basepoints are given,\n     * generates the Particles randomly across the whole field. The particles\n     * will be generated within the bounds of the field.\n     *\n     * @param variance The variance to use for the Gaussian Distribution that\n     * the filter uses to generate the particles\n     */\n    void generateParticles(const std::vector<Point>& basepoints, double standard_dev);\n\n    /**\n     * Updates the confidence of each Particle in the list of particles\n     *\n     * Evaluates each particle in the filter's list of particles and assigns a\n     * new confidence value for each.\n     */\n    void updateParticleConfidences();\n\n    /**\n     * Increments or decrements the ball's confidence value by val, keeping the\n     * value clamped\n     * between 0 and MAX_BALL_CONFIDENCE\n     *\n     * @param val the amount to update the confidence by\n     */\n    void updateBallConfidence(double val);\n\n    /**\n     * Evaluates the given Point and returns a score based on how likely is it\n     * that the ball is at that location\n     *\n     * Evaluation factors:\n     * - Distance from a vision detection (closer is better)\n     * - Distance from the ball's previous position (closer is better)\n     * - Distance from the ball's previous predicted location (closer is better)\n     *\n     * @param pos the position of the particle to be evaluated\n     */\n    double evaluateParticle(const Point& pos);\n\n    /**\n     * Returns the Detection Weight as a function of distance from the ball's\n     * previous location.\n     *\n     * @param dist the distance from the ball's last known location\n     */\n    double getDetectionWeight(const double dist);\n\n    /**\n     * Return true if the Point is within the field\n     *\n     * @param p the point to check\n     * @return true if p is within the field and false\n     * otherwise\n     */\n    bool isInField(const Point& p);\n};\n\n\n#endif  // NETWORK_INPUT_FILTER_PARTICLE_FILTER_H\n\n", "comment_ratio": 0.11059907834101383}
{"lang": "c", "code": "#pragma once\n\n#include \"NodeFeatures.h\"\n\nnamespace mscl\n{\n    //Class: NodeFeatures_tclink1ch\n    //    Contains information on features for the TC-Link 1CH Node.\n    class NodeFeatures_tclink1ch : public NodeFeatures\n    {\n    public:\n        virtual ~NodeFeatures_tclink1ch() {};\n\n        //Constructor: NodeFeatures_tclink1ch\n        //    Creates a NodeFeatures_tclink1ch object.\n        NodeFeatures_tclink1ch(const NodeInfo& info);\n\n        virtual const WirelessTypes::SamplingModes samplingModes() const override;\n\n        virtual const WirelessTypes::DataFormats dataFormats() const override;\n\n        virtual const WirelessTypes::WirelessSampleRates sampleRates(WirelessTypes::SamplingMode samplingMode, WirelessTypes::DataCollectionMethod dataCollectionMethod, WirelessTypes::DataMode dataMode) const override;\n\n        virtual WirelessTypes::SettlingTime maxFilterSettlingTime(const SampleRate& rate) const override;\n\n        virtual WirelessTypes::WirelessSampleRate maxSampleRateForSettlingTime(WirelessTypes::SettlingTime filterSettlingTime, WirelessTypes::SamplingMode samplingMode, WirelessTypes::DataCollectionMethod dataCollectionMethod, WirelessTypes::DataMode dataMode) const override;\n    };\n}\n", "comment_ratio": 0.12121212121212122}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n#import <AVFoundation/AVFoundation.h>\n#import <UIKit/UIKit.h>\n\n@protocol ABI25_0_0EXFaceDetectorDelegate\n- (void)onFacesDetected:(NSArray<NSDictionary *> *)faces;\n@end\n\n@interface ABI25_0_0EXFaceDetectorManagerStub : NSObject\n\n- (NSDictionary *)constantsToExport;\n+ (NSDictionary *)constants;\n\n- (instancetype)initWithSessionQueue:(dispatch_queue_t)sessionQueue delegate:(id <ABI25_0_0EXFaceDetectorDelegate>)delegate;\n\n- (void)setIsEnabled:(id)json;\n- (void)setLandmarksDetected:(id)json;\n- (void)setClassificationsDetected:(id)json;\n- (void)setMode:(id)json;\n\n- (void)maybeStartFaceDetectionOnSession:(AVCaptureSession *)session withPreviewLayer:(AVCaptureVideoPreviewLayer *)previewLayer;\n- (void)stopFaceDetection;\n\n@end\n\n\n", "comment_ratio": 0.20588235294117646}
{"lang": "c", "code": "#ifndef PARCOURS_H\n#define PARCOURS_H\n\n#include \"array.h\"\n\n#include <dirent.h>\n#include <errno.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n\n//#include <sys/types.h>\n\n//static int maxlen = 40;\n//static int is_root = 0;\n\nstatic int debug_mode = 0;\n\nint get_permissions2(char *path, char permissions[], struct stat *fileStat);\nint num_of_slashes(char *fn);\nint get_last_slash_pos(char *name);\nchar *get_parent(char *fn);\nint free_menu(Menu *menu);\nint getParent(char *child, char **parent_out);\nint insertToMenu(char *str, char **out);\nvoid parcours(char *fn, int indent, Array *a, int recursive, Window *w);\n\n#endif  // PARCOURS_H\n\n", "comment_ratio": 0.14285714285714285}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n#import <UIKit/UIKit.h>\n@class XHRoomModel;\n\n@interface XHRoomTools : NSObject\n\n- (NSArray *)roomModelWithString:(NSString *)aString;\n\n/* \n return recent week/month/year data\n */\n+ (NSArray *)recentWeekWithRoomId:(NSUInteger)roomId;\n+ (NSArray *)recentMonthWithRoomId:(NSUInteger)roomId;\n+ (NSArray *)recentYearWithRoomId:(NSUInteger)roomId;\n\n/*\n retuan average/max/min value\n */\n+ (NSDictionary *)weekDataWithRoomId:(NSUInteger)roomId;\n+ (NSDictionary *)monthDataWithRoomId:(NSUInteger)roomId;\n+ (NSDictionary *)yearDataWithRoomId:(NSUInteger)roomId;\n\n+ (NSArray *)limitsDataWithRoomId:(NSUInteger)roomId;\n\n+ (BOOL)saveIfIsFirstDataOfToday:(XHRoomModel *)model;\n\n@end\n\n", "comment_ratio": 0.19444444444444445}
{"lang": "c", "code": "#ifndef SRC_IO_STRINGIFY_H_\n#define SRC_IO_STRINGIFY_H_\n\n#include <cassert>\n#include <string>\n#include <sstream>\n#include <type_traits>\n#include <utility>\n\nnamespace flow {\nnamespace io {\n\n// Converts the given value to the desired output type.\ntemplate<typename Output, typename Input>\nOutput Convert(const Input& value) {\n  std::stringstream ss;\n  ss << value;\n  Output out;\n  ss >> out;\n  return out;\n}\n\n// Delimiters and wrappers used for string conversions invoked by the overloaded\n// stream << operator.\n// TODO(esawin): Make thread-safe.\nstruct Stringify {\n  static std::string delim;\n  static std::string pair_div;\n  static std::string wrap_start;\n  static std::string wrap_end;\n};\n\nstd::string Stringify::delim = \", \";\nstd::string Stringify::pair_div = \": \";\nstd::string Stringify::wrap_start = \"(\";\nstd::string Stringify::wrap_end = \")\";\n\n}  // namespace io\n}  // namespace flow\n\n// Stream operator overload for container types.\ntemplate<template<typename...> class Container, typename... Args>\ntypename std::enable_if<!std::is_same<Container<Args...>, std::string>::value,\n         std::ostream&>::type\noperator<<(std::ostream& stream, const Container<Args...>& con);\n\n// Stream operator overload for pair types.\ntemplate<typename T1, typename T2>\nstd::ostream& operator<<(std::ostream& stream, const std::pair<T1, T2>& pair) {\n  return stream << pair.first << flow::io::Stringify::pair_div << pair.second;\n}\n\ntemplate<template<typename...> class Container, typename... Args>\ntypename std::enable_if<!std::is_same<Container<Args...>, std::string>::value,\n         std::ostream&>::type\noperator<<(std::ostream& stream, const Container<Args...>& con) {\n  auto begin = con.begin();\n  const auto end = con.end();\n  stream << flow::io::Stringify::wrap_start;\n  if (begin != end) {\n    stream << *begin;\n    while (++begin != end) {\n      stream << flow::io::Stringify::delim << *begin;\n    }\n  }\n  return stream << flow::io::Stringify::wrap_end;\n}\n\nnamespace flow {\nnamespace io {\n\n// Returns the string representation for the given container based on provided\n// delimiter and wrapper.\ntemplate<template<typename...> class Container, typename... Args>\nstd::string Str(const Container<Args...>& con,\n    const std::string& delim = flow::io::Stringify::delim,\n    const std::string& wrap_start = flow::io::Stringify::wrap_start,\n    const std::string& wrap_end = flow::io::Stringify::wrap_end,\n    const std::string& pair_div = flow::io::Stringify::pair_div);\n\n// Returns the string representation for the given value, args are ignored.\ntemplate<typename T>\nstd::string Str(const T& value,\n    const std::string& delim = flow::io::Stringify::delim,\n    const std::string& wrap_start = flow::io::Stringify::wrap_start,\n    const std::string& wrap_end = flow::io::Stringify::wrap_end,\n    const std::string& pair_div = flow::io::Stringify::pair_div) {\n  return Convert<std::string>(value);\n}\n\n// Returns the string representation for the given string. Huh.\ntemplate<>\nstd::string Str(const std::string& value, const std::string& delim,\n    const std::string& wrap_start, const std::string& wrap_end,\n    const std::string& pair_div) {\n  return value;\n}\n\n// Returns the string representation for the given pair based on provided\n// delimiter, wrapper and pair delimiter.\ntemplate<typename T1, typename T2>\nstd::string Str(const std::pair<T1, T2>& pair,\n    const std::string& delim = flow::io::Stringify::delim,\n    const std::string& wrap_start = flow::io::Stringify::wrap_start,\n    const std::string& wrap_end = flow::io::Stringify::wrap_end,\n    const std::string& pair_div = flow::io::Stringify::pair_div) {\n  return Str(pair.first, delim, wrap_start, wrap_end) + \": \" +\n      Str(pair.second, delim, wrap_start, wrap_end);\n}\n\ntemplate<template<typename...> class Container, typename... Args>\nstd::string Str(const Container<Args...>& con, const std::string& delim,\n    const std::string& wrap_start, const std::string& wrap_end,\n    const std::string& pair_div) {\n  auto begin = con.begin();\n  const auto end = con.end();\n  std::ostringstream ss;\n  ss << wrap_start;\n  if (begin != end) {\n    ss << Str(*begin, delim, wrap_start, wrap_end);\n    while (++begin != end) {\n      ss << delim << Str(*begin, delim, wrap_start, wrap_end);\n    }\n  }\n  ss << wrap_end;\n  return ss.str();\n}\n\n}  // namespace io\n}  // namespace flow\n#endif  // SRC_IO_STRINGIFY_H_\n\n", "comment_ratio": 0.13533834586466165}
{"lang": "c", "code": "#ifndef _NEOPROTXMLPARSER_H\n#define _NEOPROTXMLPARSER_H\n\n#include \"expat.h\"\n#include \"NeoProtXMLStructs.h\"\n\n#include \"CnprProteinGroup.h\"\n#include \"CnprProteinSummary.h\"\n\n#include <iostream>\n#include <vector>\n\n//#define XMLCLASS\t\t\n//#ifndef XML_STATIC\n//#define XML_STATIC\t// to statically link the expat libraries\n//#endif\n\n\nclass NeoProtXMLParser {\npublic:\n  NeoProtXMLParser();\n  ~NeoProtXMLParser();\n\n  CnprProteinSummary protein_summary;\n\n  bool read(const char* fn);\n  bool write(const char* fn, bool tabs=true);\n\n  //Functions for XML Parsing\n  void characters(const XML_Char *s, int len);\n  void endElement(const XML_Char *el);\n  void startElement(const XML_Char *el, const XML_Char **attr);\n\nprotected:\n  bool                killRead;\n  XML_Parser\t\t\t\t  parser;\n  std::vector<protXMLElement> activeEl;\n  int version;  //1=1.1, 2=1.2, etc.\n\n  //Functions for XML Parsing\n  inline const char* getAttrValue(const char* name, const XML_Char **attr) {\n    for (int i = 0; attr[i]; i += 2) {\n      if (isAttr(name, attr[i])) return attr[i + 1];\n    }\n    return \"\";\n  }\n  inline bool isAttr(const char *n1, const XML_Char *n2) { return (strcmp(n1, n2) == 0); }\n  inline bool isElement(const char *n1, const XML_Char *n2)\t{ return (strcmp(n1, n2) == 0); }\n\nprivate:\n\n  std::string elements[PROTXML_NUM_ELEMENTS];\n\n  void init();\n\n};\n\n#endif\n", "comment_ratio": 0.1206896551724138}
{"lang": "c", "code": "//\n//  ae_root_presenter.h\n//\n\n#pragma once\n\n#include <audio_editor_core/ae_root_presenter_dependency.h>\n\nnamespace yas::ae {\nstruct root_presenter final {\n    [[nodiscard]] static std::shared_ptr<root_presenter> make_shared(std::string const &project_id);\n\n    [[nodiscard]] observing::syncable observe_is_editing(std::function<void(bool const &)> &&);\n\n   private:\n    observing::value::holder_ptr<bool> const _is_editing;\n    observing::canceller_pool _pool;\n\n    root_presenter(std::shared_ptr<project_for_root_presenter> const &);\n\n    root_presenter(root_presenter const &) = delete;\n    root_presenter(root_presenter &&) = delete;\n    root_presenter &operator=(root_presenter const &) = delete;\n    root_presenter &operator=(root_presenter &&) = delete;\n};\n}  // namespace yas::ae\n\n", "comment_ratio": 0.14814814814814814}
{"lang": "c", "code": "/*\r\n*\r\n* Lisa He\r\n* CS 402 - SP Lab 1\r\n* 3/30/2022\r\n*\r\n*/\r\n\r\n#include <stdio.h>\r\n#include <string.h>\r\n#include <ctype.h>\r\n\r\n// constants\r\n#define MAXNAME 64\r\n#define DBMAX 1024\r\n\r\n// employee struct\r\ntypedef struct {\r\n    int id;\r\n    // C-style strings (array of chars)\r\n    char first[MAXNAME];\r\n    char last[MAXNAME];\r\n    int salary;\r\n} employee;\r\n\r\n// declare array of employees\r\nemployee company[DBMAX];\r\n// keep track of line in file\r\nint line_number = 0;\r\n\r\n// imports records from file into company[]\r\nvoid add_file(int *id, const char *first, const char *last, int *salary) {\r\n    int i;\r\n    if (line_number < DBMAX) {\r\n        // iterate \r\n        for (i = line_number - 1; i >= 0; i--) {\r\n            // check company.id vs dereferenced id ptr\r\n            if (company[i].id > *id) {\r\n                company[i + 1] = company[i];\r\n            } else {\r\n                company[i + 1].id = *id;\r\n                // copy strings to company[i+1]\r\n                strcpy(company[i + 1].first, first);\r\n                strcpy(company[i + 1].last, last);\r\n                company[i + 1].salary = *salary;\r\n                break;\r\n            }\r\n        }\r\n        if (i == -1) {\r\n            company[0].id = *id;\r\n            strcpy(company[0].first, first);\r\n            strcpy(company[0].last, last);\r\n            company[0].salary = *salary;\r\n        }\r\n        line_number++;\r\n    } else {\r\n        printf(\"Please try again with <1024 records\");\r\n    }\r\n}\r\n\r\n// displays menu\r\nint menu() {\r\n    printf(\"Employee DB Menu:\\n\");\r\n    printf(\"----------------------------------\\n\");\r\n    printf(\"  (1) Print the Database\\n\");\r\n    printf(\"  (2) Lookup by ID\\n\");\r\n    printf(\"  (3) Lookup by Last Name\\n\");\r\n    printf(\"  (4) Add an Employee\\n\");\r\n    printf(\"  (5) Quit\\n\");\r\n    printf(\"----------------------------------\\n\");\r\n    int option;\r\n    while (1) {\r\n        printf(\"Enter your choice: \");\r\n        // &option: get the address of option\r\n        scanf(\"%d\", &option);\r\n        if (option < 1 || option > 5) {\r\n            // print the value option\r\n            printf(\"Hey, %d is not between 1 and 5, try again...\\n\", option);\r\n        } else {\r\n            // break from loop if valid\r\n            break;\r\n        }\r\n    }\r\n    printf(\"\\n\");\r\n    return option;\r\n}\r\n\r\n// Option 1 method: print database\r\nvoid print_db() {\r\n    int i;\r\n    printf(\"FIRST NAME    LAST NAME            SALARY \t     ID\\n\");\r\n    printf(\"---------------------------------------------------------------\\n\");\r\n    for (i = 0; i < line_number; i++) {\r\n        printf(\"%-14s\", company[i].first);\r\n        printf(\"%-20s\", company[i].last);\r\n        printf(\"%7d\", company[i].salary);\r\n        printf(\"%17d\\n\", company[i].id);\r\n    }\r\n    printf(\"---------------------------------------------------------------\\n\");\r\n    printf(\"Number of Employees (%d)\\n\", line_number);\r\n}\r\n\r\n// Option 2 method: lookup by ID\r\nvoid lookup_id(int id) {\r\n    int i;\r\n    int size = line_number;\r\n    int found = 0;\r\n    for (i = 0; i < size; i++) {\r\n        if (company[i].id == id) {\r\n            printf(\"FIRST NAME    LAST NAME            SALARY \t     ID\\n\");\r\n            printf(\"---------------------------------------------------------------\\n\");\r\n            printf(\"%-14s\", company[i].first);\r\n            printf(\"%-20s\", company[i].last);\r\n            printf(\"%7d\", company[i].salary);\r\n            printf(\"%17d\\n\", company[i].id);\r\n            printf(\"---------------------------------------------------------------\\n\");\r\n            found = 1;\r\n            break;\r\n        }\r\n    }\r\n    if (found == 0) {\r\n        printf(\"Employee with ID %d not found in DB\\n\", id);\r\n    }\r\n}\r\n\r\n// Option 3 method: lookup by last name\r\nvoid lookup_last(const char *last) {\r\n    int i;\r\n    int size = line_number;\r\n    int found = 0;\r\n    // printf(\"working:%s\",last);\r\n    for (i = 0; i < size; i++) {\r\n        // strcmp = compareTo, strcasecmp = compareToIgnoreCase\r\n        if (strcasecmp(last, company[i].last) == 0) {\r\n            printf(\"FIRST NAME    LAST NAME            SALARY \t     ID\\n\");\r\n            printf(\"---------------------------------------------------------------\\n\");\r\n            printf(\"%-14s\", company[i].first);\r\n            printf(\"%-20s\", company[i].last);\r\n            printf(\"%7d\", company[i].salary);\r\n            printf(\"%17d\\n\", company[i].id);\r\n            printf(\"---------------------------------------------------------------\\n\");\r\n            found = 1;\r\n            break;\r\n        }\r\n    }\r\n    if (found == 0) {\r\n        printf(\"Employee with last name %s not found in DB\\n\", last);\r\n    }\r\n}\r\n\r\n// Option 4 method: add new employee\r\nvoid add_emp(const char *first, const char *last, int *salary) {\r\n    int i;\r\n    int tempID = 0;\r\n\r\n    // copy the largest ID to tempID\r\n    for (i = 0; i < line_number; i++) {\r\n        if (company[i].id > tempID) {\r\n            tempID = company[i].id;\r\n        }\r\n    }\r\n    tempID++;\r\n\r\n    // add to company[]\r\n    if (line_number < DBMAX) {\r\n        company[line_number].id = tempID;\r\n        strcpy(company[line_number].first, first);\r\n        strcpy(company[line_number].last, last);\r\n        company[line_number].salary = *salary;\r\n        line_number++;\r\n    }\r\n    printf(\"New employee added.\\n\");\r\n}\r\n\r\n// main\r\nint main(int argc, char *argv[]) {\r\n    FILE *filename = NULL;\r\n    char *file;\r\n\r\n    // if arguments from command line != 2\r\n    // the command can't be correct\r\n    // argv[0] should be the executable\r\n    // argv[1] should be the file name\r\n    if (argc < 2) {\r\n        printf(\"Missing file name\\n\");\r\n        return (1);\r\n    } else if (argc != 2) {\r\n        printf(\"Too many arguments\\n\");\r\n        return (1);\r\n    } else {\r\n        file = argv[1];\r\n        printf(\"File name: %s\\n\", file);\r\n    }\r\n\r\n    // Open file in read-only mode\r\n    filename = fopen(file, \"r\");\r\n    int id, salary;\r\n    char first[MAXNAME], last[MAXNAME];\r\n    // If file opened successfully, then print the contents\r\n    int ret;\r\n    if (filename) {\r\n        printf(\"File contents:\\n\");\r\n        while (1) {\r\n            fscanf(filename, \"%d\", &id);\r\n            fscanf(filename, \"%s\", &first);\r\n            fscanf(filename, \"%s\", &last);\r\n            ret = fscanf(filename, \"%d\", &salary);\r\n            if (ret == EOF) {\r\n                break;\r\n            }\r\n            add_file(&id, first, last, &salary);\r\n            printf(\"%d, %s, %s, %d \\n\", id, first, last, salary);\r\n        }\r\n    } else {\r\n        printf(\"Failed to open file\\n\");\r\n    }\r\n    if (filename != NULL) {\r\n        fclose(filename);\r\n    }\r\n//     print_db();\r\n\r\n    int option = menu();\r\n    int confirm;\r\n    while (option != 5) {\r\n        switch (option) {\r\n            case 1:\r\n                print_db();\r\n                option = menu();\r\n                break;\r\n            case 2:\r\n                printf(\"Enter a 6 digit employee ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"\\n\");\r\n                lookup_id(id);\r\n                printf(\"\\n\");\r\n                option = menu();        // reset option\r\n                break;\r\n            case 3:\r\n                printf(\"Enter Employee's last name (no extra spaces): \");\r\n                scanf(\"%s\", last);\r\n                printf(\"\\n\");\r\n                lookup_last(last);\r\n                printf(\"\\n\");\r\n                option = menu();\r\n                break;\r\n            case 4:\r\n                printf(\"All characters are valid just in case you are Elon Musk.\\n\");\r\n                printf(\"Enter the employee's first name: \\n\");\r\n                scanf(\"%s\", first);\r\n                printf(\"Enter the employee's last name: \\n\");\r\n                scanf(\"%s\", last);\r\n\r\n                int valid = 0;\r\n                while (!valid) {\r\n                    printf(\"Enter the employee's salary (between 30000 - 150000): \\n\");\r\n                    scanf(\"%d\", &salary);\r\n                    if (salary < 30000 || salary > 150000) {\r\n                        printf(\"Entered salary: %d\\n\", salary);\r\n                        printf(\" Salary should be between 30000 and 150000...\\n\");\r\n                    } else {\r\n//                        valid = 1;\r\n                        break;\r\n                    }\r\n                }\r\n                printf(\"Do you want to add the following employee to the DB?\\n\");\r\n                printf(\"     >%s %s Salary: %d\\n\", first, last, salary);\r\n                printf(\"(1) Yes    (0) No\\n\");\r\n                scanf(\"%d\", &confirm);\r\n                if (confirm == 1) {\r\n                    add_emp(first, last, &salary);\r\n                    option = menu();\r\n                } else\r\n                    option = menu();\r\n                break;\r\n        }\r\n    }\r\n    printf(\"goodbye!\");\r\n    return 0;\r\n}\r\n\n", "comment_ratio": 0.11071428571428571}
{"lang": "c", "code": "#ifndef OCSERVER_H_\n#define OCSERVER_H_\n\n#include \"ocstack.h\"\n\n//-----------------------------------------------------------------------------\n// Defines\n//-----------------------------------------------------------------------------\n#define TAG \"ocserver\"\n#define SAMPLE_MAX_NUM_OBSERVATIONS     8\n#define SAMPLE_MAX_NUM_POST_INSTANCE  2\n\n//-----------------------------------------------------------------------------\n// Typedefs\n//-----------------------------------------------------------------------------\n\n/* Structure to represent a Light resource */\ntypedef struct LIGHTRESOURCE{\n    OCResourceHandle handle;\n    bool state;\n    int power;\n} LightResource;\n\n/* Structure to represent the observers */\ntypedef struct {\n    OCObservationId observationId;\n    bool            valid;\n    OCResourceHandle resourceHandle;\n} Observers;\n\n//-----------------------------------------------------------------------------\n// Function prototype\n//-----------------------------------------------------------------------------\n\n/* call getResult in common.cpp to get the result in string format. */\nconst char *getResult(OCStackResult result);\n\n/* Function that creates a new Light resource by calling the\n * OCCreateResource() method.\n */\nint createLightResource (char *uri, LightResource *lightResource);\n\n/* This method converts the payload to JSON format */\nchar* constructJsonResponse (OCEntityHandlerRequest *ehRequest);\n\n/* This method changes the Light power using an independent thread\n * and notifies the observers of new state of the resource.\n */\nvoid *ChangeLightRepresentation (void *param);\n\n/* Following methods process the PUT, GET, POST, Delete,\n * & Observe requests */\nOCEntityHandlerResult ProcessGetRequest (OCEntityHandlerRequest *ehRequest,\n                                         char *payload,\n                                         uint16_t maxPayloadSize);\nOCEntityHandlerResult ProcessPutRequest (OCEntityHandlerRequest *ehRequest,\n                                         char *payload,\n                                         uint16_t maxPayloadSize);\nOCEntityHandlerResult ProcessPostRequest (OCEntityHandlerRequest *ehRequest,\n                                          OCEntityHandlerResponse *response,\n                                          char *payload,\n                                          uint16_t maxPayloadSize);\nOCEntityHandlerResult ProcessDeleteRequest (OCEntityHandlerRequest *ehRequest,\n                                            char *payload,\n                                            uint16_t maxPayloadSize);\n\nOCEntityHandlerResult ProcessNonExistingResourceRequest (OCEntityHandlerRequest *ehRequest,\n                                                         char *payload,\n                                                         uint16_t maxPayloadSize);\n\nvoid ProcessObserveRegister (OCEntityHandlerRequest *ehRequest);\nvoid ProcessObserveDeregister (OCEntityHandlerRequest *ehRequest);\n\nvoid DeleteDeviceInfo();\n\nOCStackResult SetDeviceInfo(const char *contentType, const char *dateOfManufacture,\n                const char *deviceName, const char *deviceUUID, const char *firmwareVersion,\n                const char *hostName, const char *manufacturerName, const char *manufacturerUrl,\n                const char *modelNumber, const char *platformVersion, const char *supportUrl,\n                const char *version);\n\n\n//-----------------------------------------------------------------------------\n// Callback functions\n//-----------------------------------------------------------------------------\n\n/* Entity Handler callback functions */\nOCEntityHandlerResult\nOCDeviceEntityHandlerCb (OCEntityHandlerFlag flag,\n        OCEntityHandlerRequest *entityHandlerRequest, char* uri);\n\nOCEntityHandlerResult\nOCEntityHandlerCb (OCEntityHandlerFlag flag,\n        OCEntityHandlerRequest *entityHandlerRequest);\n\n\n#endif\n\n", "comment_ratio": 0.2627118644067797}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n#import \"BaseModel.h\"\n\nextern NSString * const QQM_TABLE_NAME;\n@interface QQMDataManager : NSObject\n\n+ (QQMDataManager *)managerWithTable:(NSString *)modelName;\n\n- (void)insert:(BaseModel *)model;\n\n- (void)update:(BaseModel *)model withMainKey:(NSString *)key;\n\n- (void)remove:(BaseModel *)model;\n- (void)remove:(BaseModel *)model withMainKey:(NSString *)key;\n- (void)removeAll:(NSString *)tableName;\n\n- (NSArray<BaseModel *> * )fetch:(NSDictionary *)dic;\n\n- (NSArray<BaseModel *> * )fetchAll:(NSString *)modelName;\n\n@end\n\n", "comment_ratio": 0.23333333333333334}
{"lang": "c", "code": "#import \"ALPHASerialization.h\"\n\n/*!\n *  Measures timing of network connection.\n */\n@interface ALPHANetworkConnectionTiming : NSObject <ALPHASerializableItem>\n\n@property (nonatomic, copy) NSDate *connectionStartDate;\n\n@property (nonatomic, copy) NSDate *connectionEndDate;\n\n@property (nonatomic, copy) NSDate *redirectDate;\n\n@end\n\n", "comment_ratio": 0.30434782608695654}
{"lang": "c", "code": "\ufeff//++Dubrovnik.CodeGenerator Dubrovnik_ClientApplication_EventHelper.h\n//\n// Managed class : EventHelper\n//\n//\n// Frameworks\n//\n#import <Cocoa/Cocoa.h>\n#import <Dubrovnik/Dubrovnik.h>\n\n//\n// Optional extra import. Not auto generated. Add manually to project only if required.\n//\n#if __has_include(\"Dubrovnik_ClientApplication_EventHelper.__Extra__.h\")\n#import \"Dubrovnik_ClientApplication_EventHelper.__Extra__.h\"\n#endif\n\n//\n// Forward class and protocol declarations\n//\n@class Dubrovnik_ClientApplication_EventHelper;\n@class Dubrovnik_ClientApplication_IEventHelper;\n@class System_Boolean;\n@class System_EventArgs;\n@class System_Object;\n@class System_String;\n@class System_UnhandledExceptionEventArgs;\n@class System_Void;\n\n//\n// Import superclass and adopted protocols\n//\n#import \"Dubrovnik_ClientApplication_IEventHelper_Protocol.h\"\n\n@interface Dubrovnik_ClientApplication_EventHelper : System_Object <Dubrovnik_ClientApplication_IEventHelper_>\n\n#pragma mark -\n#pragma mark Setup\n\t// obligatory override\n\t+ (const char *)monoClassName;\n\t// obligatory override\n\t+ (const char *)monoAssemblyName;\n\n#pragma mark -\n#pragma mark Methods\n\n\t/*! \n\t\tManaged method name : ConfigureStaticEventHandler\n\t\tManaged return type : System.Void\n\t\tManaged param types : System.Object, System.String, System.String, System.Boolean\n\t */\n    + (void)configureStaticEventHandler_withObj:(System_Object *)p1 objEventName:(NSString *)p2 handlerMethodName:(NSString *)p3 attach:(BOOL)p4;\n\n\t/*! \n\t\tManaged method name : Converting\n\t\tManaged return type : System.Void\n\t\tManaged param types : System.Object, System.EventArgs\n\t */\n    + (void)converting_withSender:(System_Object *)p1 args:(System_EventArgs *)p2;\n\n\t/*! \n\t\tManaged method name : ManagedEvent_AppDomain_UnhandledException\n\t\tManaged return type : System.Void\n\t\tManaged param types : System.Object, System.UnhandledExceptionEventArgs\n\t */\n    + (void)managedEvent_AppDomain_UnhandledException_withSender:(System_Object *)p1 args:(System_UnhandledExceptionEventArgs *)p2;\n\n\t/*! \n\t\tManaged method name : ManagedEvent_ManagedObject_PropertyChanged\n\t\tManaged return type : System.Void\n\t\tManaged param types : System.Object, System.EventArgs\n\t */\n    + (void)managedEvent_ManagedObject_PropertyChanged_withSender:(System_Object *)p1 args:(System_EventArgs *)p2;\n\n\t/*! \n\t\tManaged method name : ManagedEvent_ManagedObject_PropertyChanging\n\t\tManaged return type : System.Void\n\t\tManaged param types : System.Object, System.EventArgs\n\t */\n    + (void)managedEvent_ManagedObject_PropertyChanging_withSender:(System_Object *)p1 args:(System_EventArgs *)p2;\n\n\t/*! \n\t\tManaged method name : ObjectSupportsEvent\n\t\tManaged return type : System.Boolean\n\t\tManaged param types : System.Object, System.String\n\t */\n    + (BOOL)objectSupportsEvent_withObj:(System_Object *)p1 objEventName:(NSString *)p2;\n@end\n//--Dubrovnik.CodeGenerator\n", "comment_ratio": 0.21348314606741572}
{"lang": "c", "code": "// GLKGLList.h: interface for the GLKGLList class.\n//\n//////////////////////////////////////////////////////////////////////\n\n#ifndef _GLKGLLIST\n#define _GLKGLLIST\n\n#include \"GLKLib.h\"\n#include \"GLKObList.h\"\n\nclass GLKGLList : public GLKObject  \n{\npublic:\n\tGLKGLList() {};\n\tvirtual ~GLKGLList() {};\n    virtual void draw(GLKLib *view) {};\n};\n\n#endif \n\n", "comment_ratio": 0.15}
{"lang": "c", "code": "#ifndef MERASMUS_ATTACK_H\n#define MERASMUS_ATTACK_H\n#ifdef _WIN32\n#pragma once\n#endif\n\n#include \"NextBotBehavior.h\"\n#include \"merasmus.h\"\n#include \"Path/NextBotPathFollow.h\"\n\nclass CMerasmusAttack : public Action<CMerasmus>\n{\n\tDECLARE_CLASS( CMerasmusAttack, Action<CMerasmus> )\npublic:\n\n\tvirtual ~CMerasmusAttack() {}\n\n\tvirtual char const *GetName( void ) const OVERRIDE;\n\n\tvirtual ActionResult<CMerasmus> OnStart( CMerasmus *me, Action<CMerasmus> *priorAction ) OVERRIDE;\n\tvirtual ActionResult<CMerasmus> Update( CMerasmus *me, float dt ) OVERRIDE;\n\n\tvirtual EventDesiredResult<CMerasmus> OnStuck( CMerasmus *me ) OVERRIDE;\n\tvirtual EventDesiredResult<CMerasmus> OnContact( CMerasmus *me, CBaseEntity *other, CGameTrace *result = NULL ) OVERRIDE;\n\nprivate:\n\tvoid RecomputeHomePosition( void );\n\tbool IsPotentiallyChaseable( CMerasmus *me, CTFPlayer *pVictim );\n\tvoid SelectVictim( CMerasmus *me );\n\n\tPathFollower m_PathFollower;\n\tVector m_vecHome;\n\tCountdownTimer m_recomputeHomeTimer;\n\tCountdownTimer m_staffAttackTimer;\n\tCountdownTimer m_grenadeTimer;\n\tCountdownTimer m_zapTimer;\n\tCountdownTimer m_bombHeadTimer;\n\tCountdownTimer unk11;\n\tCHandle<CTFPlayer> m_hTarget;\n\tCountdownTimer m_chooseVictimTimer;\n};\n\n#endif\n", "comment_ratio": 0.12244897959183673}
{"lang": "c", "code": "#ifndef USBL_TRANSCEIVER_PLUGIN_H_\n#define USBL_TRANSCEIVER_PLUGIN_H_\n\n#include <math.h>\n#include <ros/ros.h>\n#include <ros/callback_queue.h>\n#include <ros/subscribe_options.h>\n\n#include <std_msgs/String.h>\n#include <std_msgs/Float64.h>\n#include <std_msgs/Int8.h>\n#include <geometry_msgs/Vector3.h>\n\n#include <string>\n#include <thread>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <unordered_map>\n\n#include <gazebo/gazebo.hh>\n#include <gazebo/physics/physics.hh>\n\n#include <ignition/transport/Node.hh>\n#include <ignition/math/Pose3.hh>\n#include <ignition/common/StringUtils.hh>\n\n#include \"dave_gazebo_model_plugins/UsblCommand.h\"\n#include \"dave_gazebo_model_plugins/UsblResponse.h\"\n\nnamespace gazebo\n{\n  class TransceiverPlugin : public ModelPlugin\n  {\n    public:\n      TransceiverPlugin();\n      ~TransceiverPlugin();\n      void Load(physics::ModelPtr _model, sdf::ElementPtr _sdf);\n      void commandingResponseTestCallback(const std_msgs::StringConstPtr &msg);\n      void commandingResponseCallback\n           (const dave_gazebo_model_plugins::UsblResponseConstPtr &msg);\n      void sendCommand(int command_id, std::string& transponder_id);\n      void sendPing(const ros::TimerEvent&);\n      void channelSwitchCallback(const std_msgs::StringConstPtr &msg);\n      void temperatureRosCallback(const std_msgs::Float64ConstPtr &msg);\n      void interrogationModeRosCallback(const std_msgs::StringConstPtr &msg);\n      void receiveGezeboCallback(ConstVector3dPtr& transponder_position);\n      void publishPosition(double &bearing, double &range, double &elevation);\n      void calcuateRelativePose(ignition::math::Vector3d position,\n                                double &bearing, double &range,\n                                double &elevation);\n      void queueThread();\n\n    public:\n      // This entity's attributes\n      std::string m_namespace;\n      std::string m_transceiverDevice;\n      std::string m_transceiverID;\n      std::string m_transponderAttachedObject;\n      std::string m_channel = \"1\";\n      std::string m_interrogationMode;\n      bool m_enablePingerScheduler;\n\n    private:\n      std::string m_transponderDevice;\n      double m_temperature;\n      double m_soundSpeed;\n      std::vector<std::string> m_deployedTransponders;\n\n      // Gazebo nodes, publishers, and subscribers\n      ros::Timer m_timer;\n      physics::ModelPtr m_model;\n      transport::NodePtr m_gzNode;\n      std::vector<transport::SubscriberPtr> m_transponderPoseSub;\n\n\n      // ROS nodes, publishers and subscibers\n      std::unique_ptr<ros::NodeHandle> m_rosNode;\n      ros::Publisher m_publishTransponderRelPos;\n      ros::Publisher m_publishTransponderRelPosCartesion;\n      ros::Publisher m_cisPinger;\n      std::unordered_map<std::string, ros::Publisher> m_iisPinger;\n      std::unordered_map<std::string, ros::Publisher> m_commandPubs;\n      ros::Subscriber m_temperatureSub;\n      ros::Subscriber m_commandResponseSub;\n      ros::Subscriber m_commandResponseTestSub;\n      ros::Subscriber m_interrogationModeSub;\n      ros::Subscriber m_channelSwitchSub;\n      ros::CallbackQueue m_rosQueue;\n\n      std::thread m_rosQueueThread;\n  };\n\n  GZ_REGISTER_MODEL_PLUGIN(TransceiverPlugin)\n}\n#endif\n\n", "comment_ratio": 0.15178571428571427}
{"lang": "c", "code": "#ifndef COMPONENTS_GCM_DRIVER_CRYPTO_GCM_ENCRYPTION_PROVIDER_H_\n#define COMPONENTS_GCM_DRIVER_CRYPTO_GCM_ENCRYPTION_PROVIDER_H_\n\n#include <stdint.h>\n\n#include <memory>\n#include <string>\n\n#include \"base/callback_forward.h\"\n#include \"base/gtest_prod_util.h\"\n#include \"base/macros.h\"\n#include \"base/memory/weak_ptr.h\"\n\nnamespace base {\nclass FilePath;\nclass SequencedTaskRunner;\n}\n\nnamespace gcm {\n\nclass GCMKeyStore;\nstruct IncomingMessage;\nclass KeyPair;\n\n// Provider that enables the GCM Driver to deal with encryption key management\n// and decryption of incoming messages.\nclass GCMEncryptionProvider {\n public:\n  // Result of decrypting an incoming message. The values of these reasons must\n  // not be changed, because they are being recorded using UMA.\n  enum DecryptionResult {\n    // The message had not been encrypted by the sender.\n    DECRYPTION_RESULT_UNENCRYPTED = 0,\n\n    // The message had been encrypted by the sender, and could successfully be\n    // decrypted for the registration it has been received for.\n    DECRYPTION_RESULT_DECRYPTED = 1,\n\n    // The contents of the Encryption HTTP header could not be parsed.\n    DECRYPTION_RESULT_INVALID_ENCRYPTION_HEADER = 2,\n\n    // The contents of the Crypto-Key HTTP header could not be parsed.\n    DECRYPTION_RESULT_INVALID_CRYPTO_KEY_HEADER = 3,\n\n    // No public/private key-pair was associated with the app_id.\n    DECRYPTION_RESULT_NO_KEYS = 4,\n\n    // The shared secret cannot be derived from the keying material.\n    DECRYPTION_RESULT_INVALID_SHARED_SECRET = 5,\n\n    // The payload could not be decrypted as AES-128-GCM.\n    DECRYPTION_RESULT_INVALID_PAYLOAD = 6,\n\n    DECRYPTION_RESULT_LAST = DECRYPTION_RESULT_INVALID_PAYLOAD\n  };\n\n  // Callback to be invoked when the public key and auth secret are available.\n  using EncryptionInfoCallback = base::Callback<void(const std::string&,\n                                                     const std::string&)>;\n\n  // Callback to be invoked when a message may have been decrypted, as indicated\n  // by the |result|. The |message| contains the dispatchable message in success\n  // cases, or will be initialized to an empty, default state for failure.\n  using MessageCallback = base::Callback<void(DecryptionResult result,\n                                              const IncomingMessage& message)>;\n\n  // Converts |result| to a string describing the details of said result.\n  static std::string ToDecryptionResultDetailsString(DecryptionResult result);\n\n  GCMEncryptionProvider();\n  ~GCMEncryptionProvider();\n\n  // Initializes the encryption provider with the |store_path| and the\n  // |blocking_task_runner|. Done separately from the constructor in order to\n  // avoid needing a blocking task runner for anything using GCMDriver.\n  void Init(\n      const base::FilePath& store_path,\n      const scoped_refptr<base::SequencedTaskRunner>& blocking_task_runner);\n\n  // Retrieves the public key and authentication secret associated with the\n  // |app_id| + |authorized_entity| pair. Will create this info if necessary.\n  // |authorized_entity| should be the InstanceID token's authorized entity, or\n  // \"\" for non-InstanceID GCM registrations.\n  void GetEncryptionInfo(const std::string& app_id,\n                         const std::string& authorized_entity,\n                         const EncryptionInfoCallback& callback);\n\n  // Removes all encryption information associated with the |app_id| +\n  // |authorized_entity| pair, then invokes |callback|. |authorized_entity|\n  // should be the InstanceID token's authorized entity, or \"*\" to remove for\n  // all InstanceID tokens, or \"\" for non-InstanceID GCM registrations.\n  void RemoveEncryptionInfo(const std::string& app_id,\n                            const std::string& authorized_entity,\n                            const base::Closure& callback);\n\n  // Determines whether |message| contains encrypted content.\n  bool IsEncryptedMessage(const IncomingMessage& message) const;\n\n  // Attempts to decrypt the |message|. If the |message| is not encrypted, the\n  // |callback| will be invoked immediately. Otherwise |callback| will be called\n  // asynchronously when |message| has been decrypted. A dispatchable message\n  // will be used in case of success, an empty message in case of failure.\n  void DecryptMessage(const std::string& app_id,\n                      const IncomingMessage& message,\n                      const MessageCallback& callback);\n\n private:\n  friend class GCMEncryptionProviderTest;\n  FRIEND_TEST_ALL_PREFIXES(GCMEncryptionProviderTest,\n                           EncryptionRoundTripGCMRegistration);\n  FRIEND_TEST_ALL_PREFIXES(GCMEncryptionProviderTest,\n                           EncryptionRoundTripInstanceIDToken);\n\n  void DidGetEncryptionInfo(const std::string& app_id,\n                            const std::string& authorized_entity,\n                            const EncryptionInfoCallback& callback,\n                            const KeyPair& pair,\n                            const std::string& auth_secret);\n\n  void DidCreateEncryptionInfo(const EncryptionInfoCallback& callback,\n                               const KeyPair& pair,\n                               const std::string& auth_secret);\n\n  void DecryptMessageWithKey(const IncomingMessage& message,\n                             const MessageCallback& callback,\n                             const std::string& salt,\n                             const std::string& dh,\n                             uint64_t rs,\n                             const KeyPair& pair,\n                             const std::string& auth_secret);\n\n  std::unique_ptr<GCMKeyStore> key_store_;\n\n  base::WeakPtrFactory<GCMEncryptionProvider> weak_ptr_factory_;\n\n  DISALLOW_COPY_AND_ASSIGN(GCMEncryptionProvider);\n};\n\n}  // namespace gcm\n\n#endif  // COMPONENTS_GCM_DRIVER_CRYPTO_GCM_ENCRYPTION_PROVIDER_H_\n\n", "comment_ratio": 0.2602739726027397}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n\n@interface BNRContactCell : UITableViewCell\n\n@property (nonatomic, weak) IBOutlet UILabel *name;\n@property (nonatomic, weak) IBOutlet UILabel *phone;\n@property (nonatomic, weak) IBOutlet UILabel *address;\n\n@end\n\n", "comment_ratio": 0.3888888888888889}
{"lang": "c", "code": "#import <libobjc.A.dylib/NSSecureCoding.h>\n\n@class NSString, TVRCPINEntryAttributes, RTIDataPayload;\n\n@interface TVRCKeyboardAttributes : NSObject <NSSecureCoding> {\n\n\tBOOL _likelyPINEntry;\n\tBOOL _secure;\n\tBOOL _enablesReturnKeyAutomatically;\n\tNSString* _title;\n\tTVRCPINEntryAttributes* _PINEntryAttributes;\n\tNSString* _prompt;\n\tRTIDataPayload* _rtiDataPayload;\n\tlong long _keyboardType;\n\tlong long _returnKeyType;\n\tlong long _autocapitalizationType;\n\tlong long _autocorrectionType;\n\tlong long _spellCheckingType;\n\n}\n\n@property (nonatomic,copy) NSString * title;                                                                                                                  //@synthesize title=_title - In the implementation block\n@property (nonatomic,copy) NSString * prompt;                                                                                                                 //@synthesize prompt=_prompt - In the implementation block\n@property (nonatomic,retain) TVRCPINEntryAttributes * PINEntryAttributes;                                                                                     //@synthesize PINEntryAttributes=_PINEntryAttributes - In the implementation block\n@property (nonatomic,retain) RTIDataPayload * rtiDataPayload;                                                                                                 //@synthesize rtiDataPayload=_rtiDataPayload - In the implementation block\n@property (assign,setter=_setLikelyPINEntry:,getter=_isLikelyPINEntry,nonatomic) BOOL likelyPINEntry;                                                         //@synthesize likelyPINEntry=_likelyPINEntry - In the implementation block\n@property (assign,setter=_setSecure:,getter=_isSecure,nonatomic) BOOL secure;                                                                                 //@synthesize secure=_secure - In the implementation block\n@property (assign,setter=_setEnablesReturnKeyAutomatically:,getter=_enablesReturnKeyAutomatically,nonatomic) BOOL enablesReturnKeyAutomatically;              //@synthesize enablesReturnKeyAutomatically=_enablesReturnKeyAutomatically - In the implementation block\n@property (assign,setter=_setKeyboardType:,getter=_keyboardType,nonatomic) long long keyboardType;                                                            //@synthesize keyboardType=_keyboardType - In the implementation block\n@property (assign,setter=_setReturnKeyType:,getter=_returnKeyType,nonatomic) long long returnKeyType;                                                         //@synthesize returnKeyType=_returnKeyType - In the implementation block\n@property (assign,setter=_setAutocapitalizationType:,getter=_autocapitalizationType,nonatomic) long long autocapitalizationType;                              //@synthesize autocapitalizationType=_autocapitalizationType - In the implementation block\n@property (assign,setter=_setAutocorrectionType:,getter=_autocorrectionType,nonatomic) long long autocorrectionType;                                          //@synthesize autocorrectionType=_autocorrectionType - In the implementation block\n@property (assign,setter=_setSpellCheckingType:,getter=_spellCheckingType,nonatomic) long long spellCheckingType;                                             //@synthesize spellCheckingType=_spellCheckingType - In the implementation block\n+(BOOL)supportsSecureCoding;\n-(BOOL)isEqual:(id)arg1 ;\n-(unsigned long long)hash;\n-(id)description;\n-(void)encodeWithCoder:(id)arg1 ;\n-(id)initWithCoder:(id)arg1 ;\n-(id)_init;\n-(long long)_keyboardType;\n-(NSString *)title;\n-(void)setTitle:(NSString *)arg1 ;\n-(BOOL)_isSecure;\n-(long long)_autocorrectionType;\n-(long long)_autocapitalizationType;\n-(long long)_returnKeyType;\n-(BOOL)_enablesReturnKeyAutomatically;\n-(NSString *)prompt;\n-(void)setPrompt:(NSString *)arg1 ;\n-(BOOL)isEqualToAttributes:(id)arg1 ;\n-(TVRCPINEntryAttributes *)PINEntryAttributes;\n-(void)setPINEntryAttributes:(TVRCPINEntryAttributes *)arg1 ;\n-(RTIDataPayload *)rtiDataPayload;\n-(void)setRtiDataPayload:(RTIDataPayload *)arg1 ;\n-(BOOL)_isLikelyPINEntry;\n-(void)_setLikelyPINEntry:(BOOL)arg1 ;\n-(void)_setSecure:(BOOL)arg1 ;\n-(void)_setEnablesReturnKeyAutomatically:(BOOL)arg1 ;\n-(void)_setKeyboardType:(long long)arg1 ;\n-(void)_setReturnKeyType:(long long)arg1 ;\n-(void)_setAutocapitalizationType:(long long)arg1 ;\n-(void)_setAutocorrectionType:(long long)arg1 ;\n-(long long)_spellCheckingType;\n-(void)_setSpellCheckingType:(long long)arg1 ;\n@end\n\n\n", "comment_ratio": 0.15789473684210525}
{"lang": "c", "code": "#ifndef THIRD_PARTY_BLINK_RENDERER_CORE_FRAME_PICTURE_IN_PICTURE_CONTROLLER_H_\n#define THIRD_PARTY_BLINK_RENDERER_CORE_FRAME_PICTURE_IN_PICTURE_CONTROLLER_H_\n\n#include \"third_party/blink/renderer/core/core_export.h\"\n#include \"third_party/blink/renderer/platform/supplementable.h\"\n\nnamespace blink {\n\nclass Document;\nclass Element;\nclass HTMLElement;\nclass HTMLVideoElement;\nclass PictureInPictureOptions;\nclass ScriptPromiseResolver;\n\n// PictureInPictureController allows to know if Picture-in-Picture is allowed\n// for a video element in Blink outside of modules/ module. It\n// is an interface that the module will implement and add a provider for.\nclass CORE_EXPORT PictureInPictureController\n    : public GarbageCollected<PictureInPictureController>,\n      public Supplement<Document> {\n public:\n  static const char kSupplementName[];\n\n  PictureInPictureController(const PictureInPictureController&) = delete;\n  PictureInPictureController& operator=(const PictureInPictureController&) =\n      delete;\n  virtual ~PictureInPictureController() = default;\n\n  // Should be called before any other call to make sure a document is attached.\n  static PictureInPictureController& From(Document&);\n\n  // Returns whether the given element is currently in Picture-in-Picture. It\n  // returns false if PictureInPictureController is not attached to a document.\n  static bool IsElementInPictureInPicture(const Element*);\n\n  // List of Picture-in-Picture support statuses. If status is kEnabled,\n  // Picture-in-Picture is enabled for a document or element, otherwise it is\n  // not supported.\n  enum class Status {\n    kEnabled,\n    kFrameDetached,\n    kMetadataNotLoaded,\n    kVideoTrackNotAvailable,\n    kDisabledBySystem,\n    kDisabledByPermissionsPolicy,\n    kDisabledByAttribute,\n    kInvalidWidthOrHeightOption,\n  };\n\n  // Enter Picture-in-Picture for an element with options if any and resolve\n  // promise if any.\n  virtual void EnterPictureInPicture(HTMLElement*,\n                                     PictureInPictureOptions*,\n                                     ScriptPromiseResolver*) = 0;\n\n  // Exit Picture-in-Picture for a video element and resolve promise if any.\n  virtual void ExitPictureInPicture(HTMLVideoElement*,\n                                    ScriptPromiseResolver*) = 0;\n\n  // Returns whether a given element in a document associated with the\n  // controller is allowed to request Picture-in-Picture.\n  virtual Status IsElementAllowed(const HTMLElement&) const = 0;\n\n  // Should be called when an element has exited Picture-in-Picture.\n  virtual void OnExitedPictureInPicture(ScriptPromiseResolver*) = 0;\n\n  // Add video element to the list of video elements for the associated document\n  // that are eligible to Auto Picture-in-Picture.\n  virtual void AddToAutoPictureInPictureElementsList(HTMLVideoElement*) = 0;\n\n  // Remove video element from the list of video elements for the associated\n  // document that are eligible to Auto Picture-in-Picture.\n  virtual void RemoveFromAutoPictureInPictureElementsList(\n      HTMLVideoElement*) = 0;\n\n  // Notifies that one of the states used by Picture-in-Picture has changed.\n  virtual void OnPictureInPictureStateChange() = 0;\n\n  void Trace(Visitor*) const override;\n\n protected:\n  explicit PictureInPictureController(Document&);\n\n  // Returns whether the given element is currently in Picture-in-Picture.\n  // It is protected so that clients use the static method\n  // IsElementInPictureInPicture() that avoids creating the controller.\n  virtual bool IsPictureInPictureElement(const Element*) const = 0;\n};\n\n}  // namespace blink\n\n#endif  // THIRD_PARTY_BLINK_RENDERER_CORE_FRAME_PICTURE_IN_PICTURE_CONTROLLER_H_\n\n", "comment_ratio": 0.2857142857142857}
{"lang": "c", "code": "#ifndef V8ContextInfo_h\n#define V8ContextInfo_h\n\n#include \"platform/inspector_protocol/String16.h\"\n\n#include <v8.h>\n\nnamespace blink {\n\nclass V8ContextInfo {\npublic:\n    V8ContextInfo(v8::Local<v8::Context> context, int contextGroupId, const String16& humanReadableName)\n        : context(context)\n        , contextGroupId(contextGroupId)\n        , humanReadableName(humanReadableName)\n        , hasMemoryOnConsole(false)\n    {\n    }\n\n    v8::Local<v8::Context> context;\n    // Each v8::Context is a part of a group. The group id is used to find appropriate\n    // V8DebuggerAgent to notify about events in the context.\n    // |contextGroupId| must be non-0.\n    int contextGroupId;\n    String16 humanReadableName;\n    String16 origin;\n    String16 auxData;\n    bool hasMemoryOnConsole;\n};\n\n} // namespace blink\n\n#endif // V8ContextInfo_h\n\n", "comment_ratio": 0.21052631578947367}
{"lang": "c", "code": "//\n//  Target_NotFound.h\n//  AFNetworking\n//\n//  Created by Hayder on 2019/5/8.\n//\n\n#import <UIKit/UIKit.h>\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface Target_NotFound : NSObject\n\n- (UIViewController *)targetNotFundation:(NSDictionary *)params;\n\n@end\n\nNS_ASSUME_NONNULL_END\n\n", "comment_ratio": 0.3157894736842105}
{"lang": "c", "code": "#ifndef __CommonFG_H\n#define __CommonFG_H\n\nnamespace H5 {\n\n/*! \\class CommonFG\n    \\brief \\a CommonFG is an abstract base class of H5File and H5Group.\n\n    It provides common operations of H5File and H5Group.\n*/\n\nclass ArrayType;\nclass VarLenType;\n\nclass H5_DLLCPP CommonFG {\n   public:\n        // Creates a new group at this location which can be a file\n        // or another group.\n        Group createGroup(const char* name, size_t size_hint = 0) const;\n        Group createGroup(const H5std_string& name, size_t size_hint = 0) const;\n\n        // Opens an existing group in a location which can be a file\n        // or another group.\n        Group openGroup(const char* name) const;\n        Group openGroup(const H5std_string& name) const;\n\n        // Creates a new dataset at this location.\n        DataSet createDataSet(const char* name, const DataType& data_type, const DataSpace& data_space, const DSetCreatPropList& create_plist = DSetCreatPropList::DEFAULT) const;\n        DataSet createDataSet(const H5std_string& name, const DataType& data_type, const DataSpace& data_space, const DSetCreatPropList& create_plist = DSetCreatPropList::DEFAULT) const;\n\n        // Opens an existing dataset at this location.\n        DataSet openDataSet(const char* name) const;\n        DataSet openDataSet(const H5std_string& name) const;\n\n        // Returns the value of a symbolic link.\n        H5std_string getLinkval(const char* link_name, size_t size=0) const;\n        H5std_string getLinkval(const H5std_string& link_name, size_t size=0) const;\n\n        // Returns the number of objects in this group.\n        hsize_t getNumObjs() const;\n\n        // Retrieves the name of an object in this group, given the\n        // object's index.\n        H5std_string getObjnameByIdx(hsize_t idx) const;\n        ssize_t getObjnameByIdx(hsize_t idx, char* name, size_t size) const;\n        ssize_t getObjnameByIdx(hsize_t idx, H5std_string& name, size_t size) const;\n\n        // Retrieves the type of an object in this file or group, given the\n        // object's name\n        H5O_type_t childObjType(const H5std_string& objname) const;\n        H5O_type_t childObjType(const char* objname) const;\n        H5O_type_t childObjType(hsize_t index, H5_index_t index_type=H5_INDEX_NAME, H5_iter_order_t order=H5_ITER_INC, const char* objname=\".\") const;\n\n        // Returns the object header version of an object in this file or group,\n        // given the object's name.\n        unsigned childObjVersion(const char* objname) const;\n        unsigned childObjVersion(const H5std_string& objname) const;\n\n#ifndef H5_NO_DEPRECATED_SYMBOLS\n        // Returns the type of an object in this group, given the\n        // object's index.\n        H5G_obj_t getObjTypeByIdx(hsize_t idx) const;\n        H5G_obj_t getObjTypeByIdx(hsize_t idx, char* type_name) const;\n        H5G_obj_t getObjTypeByIdx(hsize_t idx, H5std_string& type_name) const;\n\n        // Returns information about an HDF5 object, given by its name,\n        // at this location.\n        void getObjinfo(const char* name, hbool_t follow_link, H5G_stat_t& statbuf) const;\n        void getObjinfo(const H5std_string& name, hbool_t follow_link, H5G_stat_t& statbuf) const;\n        void getObjinfo(const char* name, H5G_stat_t& statbuf) const;\n        void getObjinfo(const H5std_string& name, H5G_stat_t& statbuf) const;\n\n        // Iterates over the elements of this group - not implemented in\n        // C++ style yet.\n        int iterateElems(const char* name, int *idx, H5G_iterate_t op, void *op_data);\n        int iterateElems(const H5std_string& name, int *idx, H5G_iterate_t op, void *op_data);\n#endif /* H5_NO_DEPRECATED_SYMBOLS */\n\n        // Creates a link of the specified type from new_name to current_name;\n        // both names are interpreted relative to the specified location id.\n        void link(H5L_type_t link_type, const char* curr_name, const char* new_name) const;\n        void link(H5L_type_t link_type, const H5std_string& curr_name, const H5std_string& new_name) const;\n\n        // Removes the specified name at this location.\n        void unlink(const char* name) const;\n        void unlink(const H5std_string& name) const;\n\n        // Mounts the file 'child' onto this location.\n        void mount(const char* name, const H5File& child, const PropList& plist) const;\n        //void mount(const char* name, H5File& child, PropList& plist) const; // removed from 1.8.18 and 1.10.1\n        void mount(const H5std_string& name, const H5File& child, const PropList& plist) const;\n        //void mount(const H5std_string& name, H5File& child, PropList& plist) const; // removed from 1.8.18 and 1.10.1\n\n        // Unmounts the file named 'name' from this parent location.\n        void unmount(const char* name) const;\n        void unmount(const H5std_string& name) const;\n\n        // Renames an object at this location.\n        void move(const char* src, const char* dst) const;\n        void move(const H5std_string& src, const H5std_string& dst) const;\n\n        // Opens a generic named datatype in this location.\n        DataType openDataType(const char* name) const;\n        DataType openDataType(const H5std_string& name) const;\n\n        // Opens a named array datatype in this location.\n        ArrayType openArrayType(const char* name) const;\n        ArrayType openArrayType(const H5std_string& name) const;\n\n        // Opens a named compound datatype in this location.\n        CompType openCompType(const char* name) const;\n        CompType openCompType(const H5std_string& name) const;\n\n        // Opens a named enumeration datatype in this location.\n        EnumType openEnumType(const char* name) const;\n        EnumType openEnumType(const H5std_string& name) const;\n\n        // Opens a named integer datatype in this location.\n        IntType openIntType(const char* name) const;\n        IntType openIntType(const H5std_string& name) const;\n\n        // Opens a named floating-point datatype in this location.\n        FloatType openFloatType(const char* name) const;\n        FloatType openFloatType(const H5std_string& name) const;\n\n        // Opens a named string datatype in this location.\n        StrType openStrType(const char* name) const;\n        StrType openStrType(const H5std_string& name) const;\n\n        // Opens a named variable length datatype in this location.\n        VarLenType openVarLenType(const char* name) const;\n        VarLenType openVarLenType(const H5std_string& name) const;\n\n#ifndef DOXYGEN_SHOULD_SKIP_THIS\n        /// For subclasses, H5File and Group, to return the correct\n        /// object id, i.e. file or group id.\n        virtual hid_t getLocId() const = 0;\n\n\n        /// For subclasses, H5File and Group, to throw appropriate exception.\n        virtual void throwException(const H5std_string& func_name, const H5std_string& msg) const = 0;\n\n        // Default constructor.\n        CommonFG();\n\n        // Noop destructor.\n        virtual ~CommonFG();\n\n    protected:\n        virtual void p_setId(const hid_t new_id) = 0;\n\n#endif // DOXYGEN_SHOULD_SKIP_THIS\n\n}; // end of CommonFG\n} // namespace H5\n\n#endif // __CommonFG_H\n\n", "comment_ratio": 0.27325581395348836}
{"lang": "c", "code": "#ifndef __MERKLE_TREE_H__\n#define __MERKLE_TREE_H__\n\n/*******************************************************************************\n   merkleTree.h\n\n   Merkle Tree\n   - Standard Peer-2-Peer hashing of a sequence of blocks\n   - Handles building of data sequence in random order ...\n   - Merkle, R. C. (1988). \"A Digital Signature Based on a Conventional Encryption Function\".\n     Advances in Cryptology \u2014 CRYPTO '87. Lecture Notes in Computer Science 293. p. 369\n\n   Author: brian.monahan@hpe.com\n      \n   (c) Copyright 2017 Hewlett Packard Enterprise Development LP \n\n   Redistribution and use in source and binary forms, with or without\n   modification, are permitted provided that the following conditions are\n   met: \n\n   1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer. \n\n   2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution. \n\n   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n   IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n   TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n   PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n   HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n   TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. \n*******************************************************************************/\n\n#include \"utils.h\"\n#include \"bytevector.h\"\n#include \"stringbuffer.h\"\n#include \"hashlib.h\"\n\n// Sequential blocks\ntypedef struct merkleTree MTree_t;\n\n// Merkle Tree state\n// - Merkle tree operations cycle: init->partial->complete->final\ntypedef int MTreeState_t;\n\n// Merkle Tree state\n// - a complete sequence means there are no missing blocks (i.e. no gaps between 0 and current max position).\n// - even if we have a complete sequence, there could still be more input.\n#define MTree_NULL       0   // Not a valid state (i.e. uninitialised)\n#define MTree_Initial    1   // Initial state (empty sequence)\n#define MTree_Partial    2   // Partial state (partial sequence) - in progress/under construction\n#define MTree_Complete   3   // Complete state (completed initial sequence, but there could be more input ...)\n#define MTree_Final      4   // Final state (completed sequence, and no more blocks to be added)\n\n// The default auto clean option\n// - If set autoClean TRUE, deallocate tree nodes as soon as possible.\nBoolean_t autoCleanDefault;\n\n// New Merkle Tree\n// - initialises the tree object\n// - Auto clean is set to the default as defined by autoCleanDefault.\nMTree_t *new_MT(HashSpec_t hSpec);\n\n// Allocates Merkle Tree\n// - initialises the tree object\n// - The autoClean setting can be defined.\nMTree_t *allocate_MT(HashSpec_t hSpec, Boolean_t autoClean);\n\n// Deallocate/recycle Merkle Tree object\nvoid deallocate_MT(MTree_t *mTree);\n\n// Resets the given hash tree\n// - The existing autoClean state from mTree is reused.\nvoid reset_MT(MTree_t *mTree, HashSpec_t hSpec);\n\n// Inspect current state ...\nMTreeState_t getState_MT(MTree_t *mTree);\n\n// Show current state ...\nchar *showState_MT(MTree_t *mTree);\n\n// Gets current Hash Spec\nHashSpec_t getHashSpec_MT(MTree_t *mTree);\n\n// Gets Top Hash - if defined\n// - This clones the mTree's digest object into given digest, dgst.\n// - Returns TRUE only if digest was cloned.\nBoolean_t getTopHash_MT(Digest_t *dgst, MTree_t *mTree);\n\n// Gets the total number of blocks so far.\nint getNumBlocks_MT(MTree_t *mTree);\n\n// Gets the total number of tree nodes (i.e. internal nodes and leaves).\nint getTotalNodes_MT(MTree_t *mTree);\n\n// Gets the auto clean flag.\n// - if TRUE, deallocate tree nodes as soon as possible.\nBoolean_t getAutoClean_MT(MTree_t *mTree);\n\n// Gets the height of the hash tree ...\nint getHeight_MT(MTree_t *mTree);\n\n// Show hash tree by appending to stringbuffer\n// - set indent string\n// - set incrment indent string\n// - set compact display\n// - set max depth (if positive)\nvoid show_MT(MTree_t *mTree, StringBuf_t *sbuf);\nvoid setShowIndent_MT(char * indent);\nvoid setShowIncrIndent_MT(char * indent);\nvoid setShowCompact_MT(Boolean_t isCompact);\nvoid setShowMaxDepth_MT(int maxDepth);\n\n// Adds data block into sequence\n// - position is 1-based i.e. from 1 to N\nvoid addDataBlock_MT(MTree_t *mTree, int position, ByteVec_t *dataVec);\n\n// Finalise the tree (if possible)\n// - Returns true if successfully finalised, otherwise false.\nBoolean_t finalise_MT(MTree_t *mTree);\n\n// Maximum indent length\n#define  MAX_INDENT_LENGTH    20\n\n// Maximum Tree Height ...\n#define MAX_TREE_HEIGHT   32\n\n#endif\n\n", "comment_ratio": 0.3235294117647059}
{"lang": "c", "code": "#ifndef LLVM_LIB_CODEGEN_MODULOSCHEDULE_H\n#define LLVM_LIB_CODEGEN_MODULOSCHEDULE_H\n\n#include \"llvm/CodeGen/MachineFunction.h\"\n#include \"llvm/CodeGen/MachineLoopInfo.h\"\n#include \"llvm/CodeGen/MachineLoopUtils.h\"\n#include \"llvm/CodeGen/TargetInstrInfo.h\"\n#include \"llvm/CodeGen/TargetSubtargetInfo.h\"\n#include <deque>\n#include <vector>\n\nnamespace llvm {\nclass MachineBasicBlock;\nclass MachineInstr;\nclass LiveIntervals;\n\n/// Represents a schedule for a single-block loop. For every instruction we\n/// maintain a Cycle and Stage.\nclass ModuloSchedule {\nprivate:\n  /// The block containing the loop instructions.\n  MachineLoop *Loop;\n\n  /// The instructions to be generated, in total order. Cycle provides a partial\n  /// order; the total order within cycles has been decided by the schedule\n  /// producer.\n  std::vector<MachineInstr *> ScheduledInstrs;\n\n  /// The cycle for each instruction.\n  DenseMap<MachineInstr *, int> Cycle;\n\n  /// The stage for each instruction.\n  DenseMap<MachineInstr *, int> Stage;\n\n  /// The number of stages in this schedule (Max(Stage) + 1).\n  int NumStages;\n\npublic:\n  /// Create a new ModuloSchedule.\n  /// \\arg ScheduledInstrs The new loop instructions, in total resequenced\n  ///    order.\n  /// \\arg Cycle Cycle index for all instructions in ScheduledInstrs. Cycle does\n  ///    not need to start at zero. ScheduledInstrs must be partially ordered by\n  ///    Cycle.\n  /// \\arg Stage Stage index for all instructions in ScheduleInstrs.\n  ModuloSchedule(MachineFunction &MF, MachineLoop *Loop,\n                 std::vector<MachineInstr *> ScheduledInstrs,\n                 DenseMap<MachineInstr *, int> Cycle,\n                 DenseMap<MachineInstr *, int> Stage)\n      : Loop(Loop), ScheduledInstrs(ScheduledInstrs), Cycle(std::move(Cycle)),\n        Stage(std::move(Stage)) {\n    NumStages = 0;\n    for (auto &KV : this->Stage)\n      NumStages = std::max(NumStages, KV.second);\n    ++NumStages;\n  }\n\n  /// Return the single-block loop being scheduled.\n  MachineLoop *getLoop() const { return Loop; }\n\n  /// Return the number of stages contained in this schedule, which is the\n  /// largest stage index + 1.\n  int getNumStages() const { return NumStages; }\n\n  /// Return the first cycle in the schedule, which is the cycle index of the\n  /// first instruction.\n  int getFirstCycle() { return Cycle[ScheduledInstrs.front()]; }\n\n  /// Return the final cycle in the schedule, which is the cycle index of the\n  /// last instruction.\n  int getFinalCycle() { return Cycle[ScheduledInstrs.back()]; }\n\n  /// Return the stage that MI is scheduled in, or -1.\n  int getStage(MachineInstr *MI) {\n    auto I = Stage.find(MI);\n    return I == Stage.end() ? -1 : I->second;\n  }\n\n  /// Return the cycle that MI is scheduled at, or -1.\n  int getCycle(MachineInstr *MI) {\n    auto I = Cycle.find(MI);\n    return I == Cycle.end() ? -1 : I->second;\n  }\n\n  /// Return the rescheduled instructions in order.\n  ArrayRef<MachineInstr *> getInstructions() { return ScheduledInstrs; }\n\n  void dump() { print(dbgs()); }\n  void print(raw_ostream &OS);\n};\n\n/// The ModuloScheduleExpander takes a ModuloSchedule and expands it in-place,\n/// rewriting the old loop and inserting prologs and epilogs as required.\nclass ModuloScheduleExpander {\npublic:\n  using InstrChangesTy = DenseMap<MachineInstr *, std::pair<unsigned, int64_t>>;\n\nprivate:\n  using ValueMapTy = DenseMap<unsigned, unsigned>;\n  using MBBVectorTy = SmallVectorImpl<MachineBasicBlock *>;\n  using InstrMapTy = DenseMap<MachineInstr *, MachineInstr *>;\n\n  ModuloSchedule &Schedule;\n  MachineFunction &MF;\n  const TargetSubtargetInfo &ST;\n  MachineRegisterInfo &MRI;\n  const TargetInstrInfo *TII;\n  LiveIntervals &LIS;\n\n  MachineBasicBlock *BB;\n  MachineBasicBlock *Preheader;\n  MachineBasicBlock *NewKernel = nullptr;\n  std::unique_ptr<TargetInstrInfo::PipelinerLoopInfo> LoopInfo;\n\n  /// Map for each register and the max difference between its uses and def.\n  /// The first element in the pair is the max difference in stages. The\n  /// second is true if the register defines a Phi value and loop value is\n  /// scheduled before the Phi.\n  std::map<unsigned, std::pair<unsigned, bool>> RegToStageDiff;\n\n  /// Instructions to change when emitting the final schedule.\n  InstrChangesTy InstrChanges;\n\n  void generatePipelinedLoop();\n  void generateProlog(unsigned LastStage, MachineBasicBlock *KernelBB,\n                      ValueMapTy *VRMap, MBBVectorTy &PrologBBs);\n  void generateEpilog(unsigned LastStage, MachineBasicBlock *KernelBB,\n                      ValueMapTy *VRMap, MBBVectorTy &EpilogBBs,\n                      MBBVectorTy &PrologBBs);\n  void generateExistingPhis(MachineBasicBlock *NewBB, MachineBasicBlock *BB1,\n                            MachineBasicBlock *BB2, MachineBasicBlock *KernelBB,\n                            ValueMapTy *VRMap, InstrMapTy &InstrMap,\n                            unsigned LastStageNum, unsigned CurStageNum,\n                            bool IsLast);\n  void generatePhis(MachineBasicBlock *NewBB, MachineBasicBlock *BB1,\n                    MachineBasicBlock *BB2, MachineBasicBlock *KernelBB,\n                    ValueMapTy *VRMap, InstrMapTy &InstrMap,\n                    unsigned LastStageNum, unsigned CurStageNum, bool IsLast);\n  void removeDeadInstructions(MachineBasicBlock *KernelBB,\n                              MBBVectorTy &EpilogBBs);\n  void splitLifetimes(MachineBasicBlock *KernelBB, MBBVectorTy &EpilogBBs);\n  void addBranches(MachineBasicBlock &PreheaderBB, MBBVectorTy &PrologBBs,\n                   MachineBasicBlock *KernelBB, MBBVectorTy &EpilogBBs,\n                   ValueMapTy *VRMap);\n  bool computeDelta(MachineInstr &MI, unsigned &Delta);\n  void updateMemOperands(MachineInstr &NewMI, MachineInstr &OldMI,\n                         unsigned Num);\n  MachineInstr *cloneInstr(MachineInstr *OldMI, unsigned CurStageNum,\n                           unsigned InstStageNum);\n  MachineInstr *cloneAndChangeInstr(MachineInstr *OldMI, unsigned CurStageNum,\n                                    unsigned InstStageNum);\n  void updateInstruction(MachineInstr *NewMI, bool LastDef,\n                         unsigned CurStageNum, unsigned InstrStageNum,\n                         ValueMapTy *VRMap);\n  MachineInstr *findDefInLoop(unsigned Reg);\n  unsigned getPrevMapVal(unsigned StageNum, unsigned PhiStage, unsigned LoopVal,\n                         unsigned LoopStage, ValueMapTy *VRMap,\n                         MachineBasicBlock *BB);\n  void rewritePhiValues(MachineBasicBlock *NewBB, unsigned StageNum,\n                        ValueMapTy *VRMap, InstrMapTy &InstrMap);\n  void rewriteScheduledInstr(MachineBasicBlock *BB, InstrMapTy &InstrMap,\n                             unsigned CurStageNum, unsigned PhiNum,\n                             MachineInstr *Phi, unsigned OldReg,\n                             unsigned NewReg, unsigned PrevReg = 0);\n  bool isLoopCarried(MachineInstr &Phi);\n\n  /// Return the max. number of stages/iterations that can occur between a\n  /// register definition and its uses.\n  unsigned getStagesForReg(int Reg, unsigned CurStage) {\n    std::pair<unsigned, bool> Stages = RegToStageDiff[Reg];\n    if ((int)CurStage > Schedule.getNumStages() - 1 && Stages.first == 0 &&\n        Stages.second)\n      return 1;\n    return Stages.first;\n  }\n\n  /// The number of stages for a Phi is a little different than other\n  /// instructions. The minimum value computed in RegToStageDiff is 1\n  /// because we assume the Phi is needed for at least 1 iteration.\n  /// This is not the case if the loop value is scheduled prior to the\n  /// Phi in the same stage.  This function returns the number of stages\n  /// or iterations needed between the Phi definition and any uses.\n  unsigned getStagesForPhi(int Reg) {\n    std::pair<unsigned, bool> Stages = RegToStageDiff[Reg];\n    if (Stages.second)\n      return Stages.first;\n    return Stages.first - 1;\n  }\n\npublic:\n  /// Create a new ModuloScheduleExpander.\n  /// \\arg InstrChanges Modifications to make to instructions with memory\n  ///   operands.\n  /// FIXME: InstrChanges is opaque and is an implementation detail of an\n  ///   optimization in MachinePipeliner that crosses abstraction boundaries.\n  ModuloScheduleExpander(MachineFunction &MF, ModuloSchedule &S,\n                         LiveIntervals &LIS, InstrChangesTy InstrChanges)\n      : Schedule(S), MF(MF), ST(MF.getSubtarget()), MRI(MF.getRegInfo()),\n        TII(ST.getInstrInfo()), LIS(LIS),\n        InstrChanges(std::move(InstrChanges)) {}\n\n  /// Performs the actual expansion.\n  void expand();\n  /// Performs final cleanup after expansion.\n  void cleanup();\n\n  /// Returns the newly rewritten kernel block, or nullptr if this was\n  /// optimized away.\n  MachineBasicBlock *getRewrittenKernel() { return NewKernel; }\n};\n\n/// A reimplementation of ModuloScheduleExpander. It works by generating a\n/// standalone kernel loop and peeling out the prologs and epilogs.\nclass PeelingModuloScheduleExpander {\n  ModuloSchedule &Schedule;\n  MachineFunction &MF;\n  const TargetSubtargetInfo &ST;\n  MachineRegisterInfo &MRI;\n  const TargetInstrInfo *TII;\n  LiveIntervals *LIS;\n\n  /// The original loop block that gets rewritten in-place.\n  MachineBasicBlock *BB;\n  /// The original loop preheader.\n  MachineBasicBlock *Preheader;\n  /// All prolog and epilog blocks.\n  SmallVector<MachineBasicBlock *, 4> Prologs, Epilogs;\n  /// For every block, the stages that are produced.\n  DenseMap<MachineBasicBlock *, BitVector> LiveStages;\n  /// For every block, the stages that are available. A stage can be available\n  /// but not produced (in the epilog) or produced but not available (in the\n  /// prolog).\n  DenseMap<MachineBasicBlock *, BitVector> AvailableStages;\n\n  /// CanonicalMIs and BlockMIs form a bidirectional map between any of the\n  /// loop kernel clones.\n  DenseMap<MachineInstr *, MachineInstr *> CanonicalMIs;\n  DenseMap<std::pair<MachineBasicBlock *, MachineInstr *>, MachineInstr *>\n      BlockMIs;\n\n  /// State passed from peelKernel to peelPrologAndEpilogs().\n  std::deque<MachineBasicBlock *> PeeledFront, PeeledBack;\n\npublic:\n  PeelingModuloScheduleExpander(MachineFunction &MF, ModuloSchedule &S,\n                                LiveIntervals *LIS)\n      : Schedule(S), MF(MF), ST(MF.getSubtarget()), MRI(MF.getRegInfo()),\n        TII(ST.getInstrInfo()), LIS(LIS) {}\n\n  void expand();\n\n  /// Runs ModuloScheduleExpander and treats it as a golden input to validate\n  /// aspects of the code generated by PeelingModuloScheduleExpander.\n  void validateAgainstModuloScheduleExpander();\n\nprotected:\n  /// Converts BB from the original loop body to the rewritten, pipelined\n  /// steady-state.\n  void rewriteKernel();\n\nprivate:\n  /// Peels one iteration of the rewritten kernel (BB) in the specified\n  /// direction.\n  MachineBasicBlock *peelKernel(LoopPeelDirection LPD);\n  /// Peel the kernel forwards and backwards to produce prologs and epilogs,\n  /// and stitch them together.\n  void peelPrologAndEpilogs();\n  /// All prolog and epilog blocks are clones of the kernel, so any produced\n  /// register in one block has an corollary in all other blocks.\n  Register getEquivalentRegisterIn(Register Reg, MachineBasicBlock *BB);\n  /// Change all users of MI, if MI is predicated out\n  /// (LiveStages[MI->getParent()] == false).\n  void rewriteUsesOf(MachineInstr *MI);\n  /// Insert branches between prologs, kernel and epilogs.\n  void fixupBranches();\n  /// Create a poor-man's LCSSA by cloning only the PHIs from the kernel block\n  /// to a block dominated by all prologs and epilogs. This allows us to treat\n  /// the loop exiting block as any other kernel clone.\n  MachineBasicBlock *CreateLCSSAExitingBlock();\n  /// Helper to get the stage of an instruction in the schedule.\n  unsigned getStage(MachineInstr *MI) {\n    if (CanonicalMIs.count(MI))\n      MI = CanonicalMIs[MI];\n    return Schedule.getStage(MI);\n  }\n};\n\n/// Expander that simply annotates each scheduled instruction with a post-instr\n/// symbol that can be consumed by the ModuloScheduleTest pass.\n///\n/// The post-instr symbol is a way of annotating an instruction that can be\n/// roundtripped in MIR. The syntax is:\n///   MYINST %0, post-instr-symbol <mcsymbol Stage-1_Cycle-5>\nclass ModuloScheduleTestAnnotater {\n  MachineFunction &MF;\n  ModuloSchedule &S;\n\npublic:\n  ModuloScheduleTestAnnotater(MachineFunction &MF, ModuloSchedule &S)\n      : MF(MF), S(S) {}\n\n  /// Performs the annotation.\n  void annotate();\n};\n\n} // end namespace llvm\n\n#endif // LLVM_LIB_CODEGEN_MODULOSCHEDULE_H\n\n", "comment_ratio": 0.3967391304347826}
{"lang": "c", "code": "#ifndef ABOUT_WINDOW_H\n#define ABOUT_WINDOW_H\n\n#include \"ui_window.h\"\n\nnamespace polaris::ui::window::windows\n{\n    //!  Simple window including credits and build id.\n    class AboutWindow : public UIWindow\n    {\n    public:\n        void Draw() override;\n    };\n}\n\n#endif // !ABOUT_WINDOW_H\n\n", "comment_ratio": 0.11764705882352941}
{"lang": "c", "code": "#ifndef __ANIMAL3D_DEMOSCENEOBJECT_H\n#define __ANIMAL3D_DEMOSCENEOBJECT_H\n\n\n// math library\n#include \"animal3D-A3DM/animal3D-A3DM.h\"\n\n\n//-----------------------------------------------------------------------------\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#else\t// !__cplusplus\n\ttypedef struct a3_DemoSceneObject\ta3_DemoSceneObject;\n\ttypedef struct a3_DemoProjector\t\ta3_DemoProjector;\n\ttypedef struct a3_DemoPointLight\ta3_DemoPointLight;\n#endif\t// __cplusplus\n\n\t\n//-----------------------------------------------------------------------------\n\n\n\t// general scene objects\n\tstruct a3_DemoSceneObject\n\t{\n\t\ta3mat4 modelMat;\t// model matrix: transform relative to scene\n\t\ta3mat4 modelMatInv;\t// inverse model matrix: scene relative to this\n\t\ta3vec3 euler;\t\t// euler angles for direct rotation control\n\t\ta3vec3 position;\t// scene position for direct control\n\t\ta3vec3 scale;\t\t// scale (not accounted for in update)\n\t\ta3i32 scaleMode;\t\t// 0 = off; 1 = uniform; other = non-uniform (nightmare)\n\t};\n\n\t// projector/camera/viewer\n\tstruct a3_DemoProjector\n\t{\n\t\ta3_DemoSceneObject *sceneObject;\t// pointer to scene object\n\t\ta3mat4 projectionMat;\t\t\t\t// projection matrix\n\t\ta3mat4 projectionMatInv;\t\t\t// inverse projection matrix\n\t\ta3mat4 viewProjectionMat;\t\t\t// concatenation of view-projection\n\t\ta3boolean perspective;\t\t\t\t// perspective or orthographic\n\t\ta3real fovy;\t\t\t\t\t\t// persp: vert field of view/ortho: vert size\n\t\ta3real aspect;\t\t\t\t\t\t// aspect ratio\n\t\ta3real znear, zfar;\t\t\t\t\t// near and far clipping planes\n\t\ta3real ctrlMoveSpeed;\t\t\t\t// how fast controlled camera moves\n\t\ta3real ctrlRotateSpeed;\t\t\t\t// control rotate speed (degrees)\n\t\ta3real ctrlZoomSpeed;\t\t\t\t// control zoom speed (degrees)\n\t};\n\n\t// simple point light\n\tstruct a3_DemoPointLight\n\t{\n\t\ta3vec4 worldPos;\t\t\t\t\t// position in world space\n\t\ta3vec4 viewPos;\t\t\t\t\t\t// position in viewer space\n\t\ta3vec4 color;\t\t\t\t\t\t// RGB color with padding\n\t\ta3real radius;\t\t\t\t\t\t// radius (distance of effect from center)\n\t\ta3real radiusInvSq;\t\t\t\t\t// radius inverse squared (attenuation factor)\n\t\ta3real pad[2];\t\t\t\t\t\t// padding\n\t};\n\n\n//-----------------------------------------------------------------------------\n\n\t// scene object initializers and updates\n\tinline void a3demo_initSceneObject(a3_DemoSceneObject *sceneObject);\n\tinline void a3demo_updateSceneObject(a3_DemoSceneObject *sceneObject, const a3boolean useZYX);\n\tinline a3i32 a3demo_rotateSceneObject(a3_DemoSceneObject *sceneObject, const a3real speed, const a3real deltaX, const a3real deltaY, const a3real deltaZ);\n\tinline a3i32 a3demo_moveSceneObject(a3_DemoSceneObject *sceneObject, const a3real speed, const a3real deltaX, const a3real deltaY, const a3real deltaZ);\n\n\tinline void a3demo_setProjectorSceneObject(a3_DemoProjector *projector, a3_DemoSceneObject *sceneObject);\n\tinline void a3demo_initProjector(a3_DemoProjector * projector);\n\tinline void a3demo_updateProjectorProjectionMat(a3_DemoProjector * projector);\n\tinline void a3demo_updateProjectorViewProjectionMat(a3_DemoProjector * projector);\n\n\n//-----------------------------------------------------------------------------\n\n\n#ifdef __cplusplus\n}\n#endif\t// __cplusplus\n\n\n#endif\t// !__ANIMAL3D_DEMOSCENEOBJECT_H\n", "comment_ratio": 0.3394495412844037}
{"lang": "c", "code": "#include \"About.h\"\n\n// VERSION =========================================================================================\n\nint NH_WEBIDL_VERSION_P[4] = {\n    NH_WEBIDL_API_VERSION, \n    NH_WEBIDL_MAJOR_VERSION, \n    NH_WEBIDL_MINOR_VERSION,\n    NH_WEBIDL_PATCH_VERSION,\n};\n\n\n", "comment_ratio": 0.13636363636363635}
{"lang": "c", "code": "//\n//\n//\n#ifndef FREQUENCY_H\n#define FREQUENCY_H\n\n#define FREQUENCY 16000000UL\n\n#endif\n\n", "comment_ratio": 0.3}
{"lang": "c", "code": "#pragma once\n#include <Windows.h>\n#define DLLAPI __declspec(dllexport)\nBOOL InjectDLL(HANDLE hProcess, LPCWSTR dllFilePathName);//Inject dll to the signal process\nextern \"C\" DLLAPI HANDLE  InjectSelfTo(char inptr[]);//Inject self\nsigned int Fake_Sub();//hooked function point\n\n\nDWORD WINAPI fGetGlyphOutlineW(\n    _In_ HDC hdc,\n    _In_ UINT uChar,\n    _In_ UINT fuFormat,\n    _Out_ LPGLYPHMETRICS lpgm,\n    _In_ DWORD cjBuffer,\n    _Out_writes_bytes_opt_(cjBuffer) LPVOID pvBuffer,\n    _In_ CONST MAT2* lpmat2\n);\nBOOL  WINAPI fTextOutW(_In_ HDC hdc, _In_ int x, _In_ int y, _In_reads_(c) LPCWSTR lpString, _In_ int c);\n\n\nextern \"C\" DLLAPI void start();//start hook\nextern \"C\" DLLAPI void end();//end hook\n\nextern \"C\" DLLAPI void start_g();//start hook\nextern \"C\" DLLAPI void end_g();//end hook\n\nextern \"C\" DLLAPI void start_t();//start hook\nextern \"C\" DLLAPI void end_t();//end hook\n\nextern \"C\" DLLAPI void StartReplace();\nextern \"C\" DLLAPI void EndReplace();\n\nextern \"C\" DLLAPI void ChangeGToT();\nextern \"C\" DLLAPI void ChangeTToG();\n\nextern \"C\" DLLAPI void LoadExerte();\n\nextern \"C\" DLLAPI WCHAR * GetResultData();\n\nPVOID GetProcAddressEx(HANDLE hProc, HMODULE hModule, LPCSTR lpProcName);\n", "comment_ratio": 0.225}
{"lang": "c", "code": "#ifndef ROOT_TVectorD\n#define ROOT_TVectorD\n\n//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// TVectorD                                                             //\n//                                                                      //\n//  Instantation of TVectorT<Double_t>                                  //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n#include \"TVectorT.h\"\n#include \"TVectorDfwd.h\"\n#include \"TMatrixD.h\"\n#include \"TMatrixDSym.h\"\n#include \"TMatrixDSparse.h\"\n\n#endif\n\n", "comment_ratio": 0.25925925925925924}
{"lang": "c", "code": "#if __IPHONE_OS_VERSION_MAX_ALLOWED >= 120400 && __IPHONE_OS_VERSION_MAX_ALLOWED < 130000\n\n#import \"Xcode_10_3_XCTAutomationSupport_CDStructures.h\"\n#import \"Xcode_10_3_SharedHeader.h\"\n#import <Foundation/Foundation.h>\n\n//\n//     Generated by class-dump 3.5 (64 bit).\n//\n//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.\n//\n\n@interface NSArray (XCTElementQueryAdditions)\n- (id)_xct_objectAfterObject:(id)arg1;\n@end\n\n#endif\n", "comment_ratio": 0.29411764705882354}
{"lang": "c", "code": "#pragma once\n\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n\n#include \"common/types.h\"\n#include \"proto/types.pb.h\"\n\n#pragma pack(push, 1)\n\nnamespace galileo {\nnamespace common {\n\nstruct EntityRequest {\n  size_t Capacity() const { return types_.Capacity() + counts_.Capacity(); }\n  ArraySpec<uint8_t> types_;\n  ArraySpec<uint32_t> counts_;\n};\n\nstruct VertexReply {\n  size_t Capacity() const {\n    size_t total_size = sizeof(size_t);\n    for (size_t i = 0; i < ids_.size(); ++i) {\n      total_size += ids_[i].Capacity();\n    }\n    return total_size;\n  }\n  std::vector<ArraySpec<galileo::common::VertexID>> ids_;\n};\n\nstruct EdgeReply {\n  size_t Capacity() const {\n    size_t total_size = sizeof(size_t);\n    for (size_t i = 0; i < ids_.size(); ++i) {\n      total_size += ids_[i].Capacity();\n    }\n    return total_size;\n  }\n  std::vector<ArraySpec<galileo::common::EdgeID>> ids_;\n};\n\nstruct NeighborRequest {\n  size_t Capacity() const {\n    return ids_.Capacity() + edge_types_.Capacity() + sizeof(cnt) +\n           sizeof(need_weight_);\n  }\n  ArraySpec<galileo::common::VertexID> ids_;\n  ArraySpec<uint8_t> edge_types_;\n  uint32_t cnt;\n  bool need_weight_;\n};\n\nstruct NeighborReplyWithWeight {\n  size_t Capacity() const {\n    size_t neighbors_size = sizeof(size_t);\n    for (auto &neighbor : neighbors_) {\n      neighbors_size += neighbor.Capacity();\n    }\n    return neighbors_size;\n  }\n  std::vector<ArraySpec<IDWeight>> neighbors_;\n};\n\nstruct NeighborReplyWithoutWeight {\n  size_t Capacity() const {\n    size_t neighbors_size = sizeof(size_t);\n    for (auto &neighbor : neighbors_) {\n      neighbors_size += neighbor.Capacity();\n    }\n    return neighbors_size;\n  }\n  std::vector<ArraySpec<VertexID>> neighbors_;\n};\n\nstruct VertexFeatureRequest {\n  size_t Capacity() const {\n    size_t fname_size = sizeof(size_t);\n    for (auto &name : features_) {\n      fname_size += name.Capacity();\n    }\n    return ids_.Capacity() + fname_size + max_dims_.Capacity();\n  }\n  ArraySpec<galileo::common::VertexID> ids_;\n  std::vector<ArraySpec<char>> features_;\n  ArraySpec<uint32_t> max_dims_;\n};\n\nstruct EdgeFeatureRequest {\n  size_t Capacity() const {\n    size_t fname_size = sizeof(size_t);\n    for (auto &name : features_) {\n      fname_size += name.Capacity();\n    }\n    return ids_.Capacity() + fname_size + max_dims_.Capacity();\n  }\n  ArraySpec<galileo::common::EdgeID> ids_;\n  std::vector<ArraySpec<char>> features_;\n  ArraySpec<uint32_t> max_dims_;\n};\n\nstruct FeatureReply {\n  size_t Capacity() const {\n    size_t feature_size = sizeof(size_t);\n    for (auto &feature : features_) {\n      feature_size += sizeof(size_t);\n      for (auto &f : feature) {\n        feature_size += f.Capacity();\n      }\n    }\n    return features_type_.Capacity() + feature_size;\n  }\n  std::vector<std::vector<ArraySpec<char>>> features_;\n  ArraySpec<galileo::proto::DataType> features_type_;\n};\n\n}  // namespace common\n}  // namespace galileo\n\n#pragma pack(pop)\n\n", "comment_ratio": 0.11678832116788321}
{"lang": "c", "code": "#ifndef ALGAC_COMMON_STACK_H_\n#define ALGAC_COMMON_STACK_H_\n\n#include <stack>\n\nnamespace algac {\n\nusing std::stack;\n\n}  // namespace algac\n\n#endif  // ALGAC_COMMON_STACK_H_\n\n", "comment_ratio": 0.21428571428571427}
{"lang": "c", "code": "#pragma once\n\nnamespace ABI { namespace Microsoft { namespace Graphics { namespace Canvas { namespace Effects \n{\n    using namespace ::Microsoft::WRL;\n    using namespace ABI::Microsoft::Graphics::Canvas;\n\n    class CompositeEffect : public RuntimeClass<\n        ICompositeEffect,\n        MixIn<CompositeEffect, CanvasEffect>>,\n        public CanvasEffect\n    {\n        InspectableClass(RuntimeClass_Microsoft_Graphics_Canvas_Effects_CompositeEffect, BaseTrust);\n\n    public:\n        CompositeEffect(ICanvasDevice* device = nullptr, ID2D1Effect* effect = nullptr);\n\n        static IID const& EffectId() { return CLSID_D2D1Composite; }\n\n        EFFECT_PROPERTY(Mode, CanvasComposite);\n        EFFECT_SOURCES_PROPERTY();\n\n        EFFECT_PROPERTY_MAPPING();\n    };\n}}}}}\n\n", "comment_ratio": 0.125}
{"lang": "c", "code": "#import \"CDStructures.h\"\n\n@class NSArray, NSString;\n\n@interface IDEDeviceThinningTraits : NSObject\n{\n    NSString *_productType;\n    NSString *_artworkDeviceIdiom;\n    long long _artworkDeviceScaleFactor;\n    long long _artworkDeviceSubtype;\n    long long _devicePerformanceMemoryClass;\n    NSString *_deviceGraphicsFeatureSetClass;\n    NSArray *_deviceGraphicsFeatureSetFallbacks;\n    NSArray *_artworkHostedIdioms;\n}\n\n+ (id)deviceTraitInfoForProductType:(id)arg1 fromPlatform:(id)arg2 error:(id *)arg3;\n@property(readonly) NSArray *artworkHostedIdioms; // @synthesize artworkHostedIdioms=_artworkHostedIdioms;\n@property(readonly) NSArray *deviceGraphicsFeatureSetFallbacks; // @synthesize deviceGraphicsFeatureSetFallbacks=_deviceGraphicsFeatureSetFallbacks;\n@property(readonly) NSString *deviceGraphicsFeatureSetClass; // @synthesize deviceGraphicsFeatureSetClass=_deviceGraphicsFeatureSetClass;\n@property(readonly) long long devicePerformanceMemoryClass; // @synthesize devicePerformanceMemoryClass=_devicePerformanceMemoryClass;\n@property(readonly) long long artworkDeviceSubtype; // @synthesize artworkDeviceSubtype=_artworkDeviceSubtype;\n@property(readonly) long long artworkDeviceScaleFactor; // @synthesize artworkDeviceScaleFactor=_artworkDeviceScaleFactor;\n@property(readonly) NSString *artworkDeviceIdiom; // @synthesize artworkDeviceIdiom=_artworkDeviceIdiom;\n@property(readonly) NSString *productType; // @synthesize productType=_productType;\n- (id)initWithProductType:(id)arg1 artworkDeviceIdiom:(id)arg2 artworkDeviceScaleFactor:(long long)arg3 artworkDeviceSubtype:(long long)arg4 devicePerformanceMemoryClass:(long long)arg5 deviceGraphicsFeatureSetClass:(id)arg6 deviceGraphicsFeatureSetFallbacks:(id)arg7 artworkHostedIdioms:(id)arg8;\n\n@end\n\n\n", "comment_ratio": 0.3611111111111111}
{"lang": "c", "code": "//\n//  WGRSA.h\n//  Pods\n//\n//  Created by panwg on 2018/6/29.\n//\n\n#import <Foundation/Foundation.h>\n\n@interface WGRSA : NSObject\n\n/**\n \u4f7f\u7528\u79c1\u94a5\u8fdb\u884c\u7b7e\u540d \u7b97\u6cd5\u662fSHA1WithRSA \uff0c\u6ce8\u610f RSA\u7b97\u6cd5\u56e0\u4e3a\u4f20\u5165\u7684\u53c2\u6570\u4e0d\u540c\u53ef\u80fd\u4f1a\u6709\u4e0d\u540c\uff0c\u8fd9\u4e2a\u5730\u65b9\u4e00\u5b9a\u8981\u548c\u540e\u53f0\u4e00\u81f4\uff0c\u5728\u8be5\u65b9\u6cd5\u4e2d\u5c06\u8bc1\u4e66\u52a0\u8f7d\u5199\u5728\u4e86\u4e00\u8d77\n\n @param plainText \u660e\u6587\u5b57\u7b26\u4e32\n @return \u7b7e\u540d\u5b57\u7b26\u4e32\uff08base64\u7f16\u7801\u8fc7\u7684\uff09\n */\n- (NSString *)signTheDataSHA1WithRSA:(NSString *)plainText;\n\n/**\n @param plainData \u660e\u6587\n @param signature \u7b7e\u540d \u6b64\u5904\u7684\u7b7e\u540d\u9700\u8981\u7684\u662f \u8fd9\u6837\u7684 [[NSData alloc]initWithBase64EncodedString:signString options:0]\n @param publicKey \u516c\u94a5\n @return \u9a8c\u7b7e\u7ed3\u679c\n */\nBOOL PKCSVerifyBytesSHA1withRSA(NSData* plainData, NSData* signature, SecKeyRef publicKey);\n\n\n/**\n \u52a0\u8f7d\u516c\u94a5\n\n @return \u516c\u94a5\u5f15\u7528 \u4f20\u5165\u4e0a\u9762\u7684\u51fd\u6570\u53c2\u6570\u4e2d\n */\n- (SecKeyRef)getPublicKey;\n\n@end\n\n", "comment_ratio": 0.16216216216216217}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n\n@class ACLocalRequest;\n\n@interface ACLocalRequestQueue : NSObject\n\n+ (instancetype)localDeviceMsgQueue;\n\n- (NSInteger)getMsgId;\n\n- (void)addRequest:(ACLocalRequest *)request;\n\n- (void)removeRequest:(ACLocalRequest *)request;\n\n- (ACLocalRequest *)getRequestById:(NSInteger)msgId;\n\n@end\n\n", "comment_ratio": 0.2692307692307692}
{"lang": "c", "code": "#ifndef GLOW_TOOLS_LOADER_LOADER_H\n#define GLOW_TOOLS_LOADER_LOADER_H\n\n#include \"glow/ExecutionEngine/ExecutionEngine.h\"\n\nnamespace glow {\n\nclass Tensor;\n\n/// \\return true if emit bundle mode is enabled.\nbool emittingBundle();\n\n/// Driver class for loading, compiling, and running inference for ONNX and\n/// Caffe2 models.\nclass Loader {\n  /// Caffe2 network file name.\n  std::string caffe2NetDescFilename_;\n  /// Caffe2 weights file name.\n  std::string caffe2NetWeightFilename_;\n  /// ONNX model file name.\n  std::string onnxModelFilename_;\n  /// Execution engine for compiling and running.\n  ExecutionEngine EE_{};\n  /// Function containing the model.\n  Function *F_{nullptr};\n\npublic:\n  /// Getter for the Function.\n  Function *getFunction() { return F_; }\n  /// Getter for the Caffe2 network file name.\n  llvm::StringRef getCaffe2NetDescFilename() { return caffe2NetDescFilename_; }\n  /// Getter for the Caffe2 weights file name.\n  llvm::StringRef getCaffe2NetWeightFilename() {\n    return caffe2NetWeightFilename_;\n  }\n  /// Getter for the ONNX model file name.\n  llvm::StringRef getOnnxModelFilename() { return onnxModelFilename_; }\n\n  /// Compiles the Function F_. Handles quantization, emitting bundles, and\n  /// dumping debug information.\n  void compile();\n\n  /// Runs inference, unless emit bundle mode is enabled. If inference is run\n  /// then it will \\return true, else false.\n  void runInference(llvm::ArrayRef<Variable *> variables,\n                    llvm::ArrayRef<Tensor *> tensors);\n\n  /// Create the Loader driver object, and parse/verify the command line\n  /// parameters.\n  Loader(int argc, char **argv);\n};\n\n} // namespace glow\n\n#endif // GLOW_TOOLS_LOADER_LOADER_H\n\n", "comment_ratio": 0.29577464788732394}
{"lang": "c", "code": "//\n//  AppDelegate.h\n//  Mac\n//\n//  Created by Felix Krause on 10/14/15.\n//\n\n#import <Cocoa/Cocoa.h>\n\n@interface AppDelegate : NSObject <NSApplicationDelegate>\n\n\n@end\n\n\n", "comment_ratio": 0.4}
{"lang": "c", "code": "#ifndef SdInfo_h\n#define SdInfo_h\n#include <stdint.h>\n// Based on the document:\n//\n// SD Specifications\n// Part 1\n// Physical Layer\n// Simplified Specification\n// Version 5.00\n// Aug 10, 2016\n//\n// https://www.sdcard.org/downloads/pls/\n//------------------------------------------------------------------------------\n// SD card errors\n// See the SD Specification for command info.\ntypedef enum {\n  SD_CARD_ERROR_NONE = 0,\n\n  // Basic commands and switch command.\n  SD_CARD_ERROR_CMD0 = 0X20,\n  SD_CARD_ERROR_CMD2,\n  SD_CARD_ERROR_CMD3,\n  SD_CARD_ERROR_CMD6,\n  SD_CARD_ERROR_CMD7,\n  SD_CARD_ERROR_CMD8,\n  SD_CARD_ERROR_CMD9,\n  SD_CARD_ERROR_CMD10,\n  SD_CARD_ERROR_CMD12,\n  SD_CARD_ERROR_CMD13,\n\n  // Read, write, erase, and extension commands.\n  SD_CARD_ERROR_CMD17 = 0X30,\n  SD_CARD_ERROR_CMD18,\n  SD_CARD_ERROR_CMD24,\n  SD_CARD_ERROR_CMD25,\n  SD_CARD_ERROR_CMD32,\n  SD_CARD_ERROR_CMD33,\n  SD_CARD_ERROR_CMD38,\n  SD_CARD_ERROR_CMD58,\n  SD_CARD_ERROR_CMD59,\n\n  // Application specific commands.\n  SD_CARD_ERROR_ACMD6 = 0X40,\n  SD_CARD_ERROR_ACMD13,\n  SD_CARD_ERROR_ACMD23,\n  SD_CARD_ERROR_ACMD41,\n\n  // Read/write errors\n  SD_CARD_ERROR_READ = 0X50,\n  SD_CARD_ERROR_READ_FIFO,\n  SD_CARD_ERROR_READ_REG,\n  SD_CARD_ERROR_READ_START,\n  SD_CARD_ERROR_READ_TIMEOUT,\n  SD_CARD_ERROR_STOP_TRAN,\n  SD_CARD_ERROR_WRITE,\n  SD_CARD_ERROR_WRITE_FIFO,\n  SD_CARD_ERROR_WRITE_START,\n  SD_CARD_ERROR_WRITE_TIMEOUT,\n\n    // Misc errors.\n  SD_CARD_ERROR_DMA = 0X60,\n  SD_CARD_ERROR_ERASE,\n  SD_CARD_ERROR_ERASE_SINGLE_BLOCK,\n  SD_CARD_ERROR_ERASE_TIMEOUT,\n  SD_CARD_ERROR_INIT_NOT_CALLED,\n  SD_CARD_ERROR_FUNCTION_NOT_SUPPORTED\n} sd_error_code_t;\n//------------------------------------------------------------------------------\n// card types\n/** Standard capacity V1 SD card */\nconst uint8_t SD_CARD_TYPE_SD1  = 1;\n/** Standard capacity V2 SD card */\nconst uint8_t SD_CARD_TYPE_SD2  = 2;\n/** High Capacity SD card */\nconst uint8_t SD_CARD_TYPE_SDHC = 3;\n//------------------------------------------------------------------------------\n#define SD_SCK_HZ(maxSpeed) SPISettings(maxSpeed, MSBFIRST, SPI_MODE0)\n#define SD_SCK_MHZ(maxMhz) SPISettings(1000000UL*maxMhz, MSBFIRST, SPI_MODE0)\n// SPI divisor constants\n/** Set SCK to max rate of F_CPU/2. */\n#define SPI_FULL_SPEED SD_SCK_MHZ(50)\n/** Set SCK rate to F_CPU/3 for Due */\n#define SPI_DIV3_SPEED SD_SCK_HZ(F_CPU/3)\n/** Set SCK rate to F_CPU/4. */\n#define SPI_HALF_SPEED SD_SCK_HZ(F_CPU/4)\n/** Set SCK rate to F_CPU/6 for Due */\n#define SPI_DIV6_SPEED SD_SCK_HZ(F_CPU/6)\n/** Set SCK rate to F_CPU/8. */\n#define SPI_QUARTER_SPEED SD_SCK_HZ(F_CPU/8)\n/** Set SCK rate to F_CPU/16. */\n#define SPI_EIGHTH_SPEED SD_SCK_HZ(F_CPU/16)\n/** Set SCK rate to F_CPU/32. */\n#define SPI_SIXTEENTH_SPEED SD_SCK_HZ(F_CPU/32)\n//------------------------------------------------------------------------------\n// SD operation timeouts\n/** init timeout ms */\nconst uint16_t SD_INIT_TIMEOUT = 2000;\n/** erase timeout ms */\nconst uint16_t SD_ERASE_TIMEOUT = 10000;\n/** read timeout ms */\nconst uint16_t SD_READ_TIMEOUT = 300;\n/** write time out ms */\nconst uint16_t SD_WRITE_TIMEOUT = 600;\n//------------------------------------------------------------------------------\n// SD card commands\n/** GO_IDLE_STATE - init card in spi mode if CS low */\nconst uint8_t CMD0 = 0X00;\n/** ALL_SEND_CID - Asks any card to send the CID. */\nconst uint8_t CMD2 = 0X02;\n/** SEND_RELATIVE_ADDR - Ask the card to publish a new RCA. */\nconst uint8_t CMD3 = 0X03;\n/** SWITCH_FUNC - Switch Function Command */\nconst uint8_t CMD6 = 0X06;\n/** SELECT/DESELECT_CARD - toggles between the stand-by and transfer states. */\nconst uint8_t CMD7 = 0X07;\n/** SEND_IF_COND - verify SD Memory Card interface operating condition.*/\nconst uint8_t CMD8 = 0X08;\n/** SEND_CSD - read the Card Specific Data (CSD register) */\nconst uint8_t CMD9 = 0X09;\n/** SEND_CID - read the card identification information (CID register) */\nconst uint8_t CMD10 = 0X0A;\n/** STOP_TRANSMISSION - end multiple block read sequence */\nconst uint8_t CMD12 = 0X0C;\n/** SEND_STATUS - read the card status register */\nconst uint8_t CMD13 = 0X0D;\n/** READ_SINGLE_BLOCK - read a single data block from the card */\nconst uint8_t CMD17 = 0X11;\n/** READ_MULTIPLE_BLOCK - read a multiple data blocks from the card */\nconst uint8_t CMD18 = 0X12;\n/** WRITE_BLOCK - write a single data block to the card */\nconst uint8_t CMD24 = 0X18;\n/** WRITE_MULTIPLE_BLOCK - write blocks of data until a STOP_TRANSMISSION */\nconst uint8_t CMD25 = 0X19;\n/** ERASE_WR_BLK_START - sets the address of the first block to be erased */\nconst uint8_t CMD32 = 0X20;\n/** ERASE_WR_BLK_END - sets the address of the last block of the continuous\n    range to be erased*/\nconst uint8_t CMD33 = 0X21;\n/** ERASE - erase all previously selected blocks */\nconst uint8_t CMD38 = 0X26;\n/** APP_CMD - escape for application specific command */\nconst uint8_t CMD55 = 0X37;\n/** READ_OCR - read the OCR register of a card */\nconst uint8_t CMD58 = 0X3A;\n/** CRC_ON_OFF - enable or disable CRC checking */\nconst uint8_t CMD59 = 0X3B;\n/** SET_BUS_WIDTH - Defines the data bus width for data transfer. */\nconst uint8_t ACMD6 = 0X06;\n/** SD_STATUS - Send the SD Status. */\nconst uint8_t ACMD13 = 0X0D;\n/** SET_WR_BLK_ERASE_COUNT - Set the number of write blocks to be\n     pre-erased before writing */\nconst uint8_t ACMD23 = 0X17;\n/** SD_SEND_OP_COMD - Sends host capacity support information and\n    activates the card's initialization process */\nconst uint8_t ACMD41 = 0X29;\n//==============================================================================\n// CARD_STATUS\n/** The command's argument was out of the allowed range for this card. */\nconst uint32_t CARD_STATUS_OUT_OF_RANGE = 1UL << 31;\n/** A misaligned address which did not match the block length. */\nconst uint32_t CARD_STATUS_ADDRESS_ERROR = 1UL << 30;\n/** The transferred block length is not allowed for this card. */\nconst uint32_t CARD_STATUS_BLOCK_LEN_ERROR = 1UL << 29;\n/** An error in the sequence of erase commands occurred. */\nconst uint32_t CARD_STATUS_ERASE_SEQ_ERROR = 1UL <<28;\n/** An invalid selection of write-blocks for erase occurred. */\nconst uint32_t CARD_STATUS_ERASE_PARAM = 1UL << 27;\n/** Set when the host attempts to write to a protected block. */\nconst uint32_t CARD_STATUS_WP_VIOLATION = 1UL << 26;\n/** When set, signals that the card is locked by the host. */\nconst uint32_t CARD_STATUS_CARD_IS_LOCKED = 1UL << 25;\n/** Set when a sequence or password error has been detected. */\nconst uint32_t CARD_STATUS_LOCK_UNLOCK_FAILED = 1UL << 24;\n/** The CRC check of the previous command failed. */\nconst uint32_t CARD_STATUS_COM_CRC_ERROR = 1UL << 23;\n/** Command not legal for the card state. */\nconst uint32_t CARD_STATUS_ILLEGAL_COMMAND = 1UL << 22;\n/** Card internal ECC was applied but failed to correct the data. */\nconst uint32_t CARD_STATUS_CARD_ECC_FAILED = 1UL << 21;\n/** Internal card controller error */\nconst uint32_t CARD_STATUS_CC_ERROR = 1UL << 20;\n/** A general or an unknown error occurred during the operation. */\nconst uint32_t CARD_STATUS_ERROR = 1UL << 19;\n// bits 19, 18, and 17 reserved.\n/** Permanent WP set or attempt to change read only values of  CSD. */\nconst uint32_t CARD_STATUS_CSD_OVERWRITE = 1UL <<16;\n/** partial address space was erased due to write protect. */\nconst uint32_t CARD_STATUS_WP_ERASE_SKIP = 1UL << 15;\n/** The command has been executed without using the internal ECC. */\nconst uint32_t CARD_STATUS_CARD_ECC_DISABLED = 1UL << 14;\n/** out of erase sequence command was received. */\nconst uint32_t CARD_STATUS_ERASE_RESET = 1UL << 13;\n/** The state of the card when receiving the command.\n * 0 = idle\n * 1 = ready\n * 2 = ident\n * 3 = stby\n * 4 = tran\n * 5 = data\n * 6 = rcv\n * 7 = prg\n * 8 = dis\n * 9-14 = reserved\n * 15 = reserved for I/O mode\n */\nconst uint32_t CARD_STATUS_CURRENT_STATE = 0XF << 9;\n/** Shift for current state. */\nconst uint32_t CARD_STATUS_CURRENT_STATE_SHIFT = 9;\n/** Corresponds to buffer empty signaling on the bus. */\nconst uint32_t CARD_STATUS_READY_FOR_DATA = 1UL << 8;\n// bit 7 reserved.\n/** Extension Functions may set this bit to get host to deal with events. */\nconst uint32_t CARD_STATUS_FX_EVENT = 1UL << 6;\n/** The card will expect ACMD, or the command has been interpreted as ACMD */\nconst uint32_t CARD_STATUS_APP_CMD = 1UL << 5;\n// bit 4 reserved.\n/** Error in the sequence of the authentication process. */\nconst uint32_t CARD_STATUS_AKE_SEQ_ERROR = 1UL << 3;\n// bits 2,1, and 0 reserved for manufacturer test mode.\n//==============================================================================\n/** status for card in the ready state */\nconst uint8_t R1_READY_STATE = 0X00;\n/** status for card in the idle state */\nconst uint8_t R1_IDLE_STATE = 0X01;\n/** status bit for illegal command */\nconst uint8_t R1_ILLEGAL_COMMAND = 0X04;\n/** start data token for read or write single block*/\nconst uint8_t DATA_START_BLOCK = 0XFE;\n/** stop token for write multiple blocks*/\nconst uint8_t STOP_TRAN_TOKEN = 0XFD;\n/** start data token for write multiple blocks*/\nconst uint8_t WRITE_MULTIPLE_TOKEN = 0XFC;\n/** mask for data response tokens after a write block operation */\nconst uint8_t DATA_RES_MASK = 0X1F;\n/** write data accepted token */\nconst uint8_t DATA_RES_ACCEPTED = 0X05;\n//==============================================================================\n/**\n * \\class CID\n * \\brief Card IDentification (CID) register.\n */\ntypedef struct CID {\n  // byte 0\n  /** Manufacturer ID */\n  unsigned char mid;\n  // byte 1-2\n  /** OEM/Application ID */\n  char oid[2];\n  // byte 3-7\n  /** Product name */\n  char pnm[5];\n  // byte 8\n  /** Product revision least significant digit */\n  unsigned char prv_m : 4;\n  /** Product revision most significant digit */\n  unsigned char prv_n : 4;\n  // byte 9-12\n  /** Product serial number */\n  uint32_t psn;\n  // byte 13\n  /** Manufacturing date year low digit */\n  unsigned char mdt_year_high : 4;\n  /** not used */\n  unsigned char reserved : 4;\n  // byte 14\n  /** Manufacturing date month */\n  unsigned char mdt_month : 4;\n  /** Manufacturing date year low digit */\n  unsigned char mdt_year_low : 4;\n  // byte 15\n  /** not used always 1 */\n  unsigned char always1 : 1;\n  /** CRC7 checksum */\n  unsigned char crc : 7;\n} __attribute__((packed)) cid_t;\n\n//==============================================================================\n/**\n * \\class CSDV1\n * \\brief CSD register for version 1.00 cards .\n */\ntypedef struct CSDV1 {\n  // byte 0\n  unsigned char reserved1 : 6;\n  unsigned char csd_ver : 2;\n  // byte 1\n  unsigned char taac;\n  // byte 2\n  unsigned char nsac;\n  // byte 3\n  unsigned char tran_speed;\n  // byte 4\n  unsigned char ccc_high;\n  // byte 5\n  unsigned char read_bl_len : 4;\n  unsigned char ccc_low : 4;\n  // byte 6\n  unsigned char c_size_high : 2;\n  unsigned char reserved2 : 2;\n  unsigned char dsr_imp : 1;\n  unsigned char read_blk_misalign : 1;\n  unsigned char write_blk_misalign : 1;\n  unsigned char read_bl_partial : 1;\n  // byte 7\n  unsigned char c_size_mid;\n  // byte 8\n  unsigned char vdd_r_curr_max : 3;\n  unsigned char vdd_r_curr_min : 3;\n  unsigned char c_size_low : 2;\n  // byte 9\n  unsigned char c_size_mult_high : 2;\n  unsigned char vdd_w_cur_max : 3;\n  unsigned char vdd_w_curr_min : 3;\n  // byte 10\n  unsigned char sector_size_high : 6;\n  unsigned char erase_blk_en : 1;\n  unsigned char c_size_mult_low : 1;\n  // byte 11\n  unsigned char wp_grp_size : 7;\n  unsigned char sector_size_low : 1;\n  // byte 12\n  unsigned char write_bl_len_high : 2;\n  unsigned char r2w_factor : 3;\n  unsigned char reserved3 : 2;\n  unsigned char wp_grp_enable : 1;\n  // byte 13\n  unsigned char reserved4 : 5;\n  unsigned char write_partial : 1;\n  unsigned char write_bl_len_low : 2;\n  // byte 14\n  unsigned char reserved5: 2;\n  unsigned char file_format : 2;\n  unsigned char tmp_write_protect : 1;\n  unsigned char perm_write_protect : 1;\n  unsigned char copy : 1;\n  /** Indicates the file format on the card */\n  unsigned char file_format_grp : 1;\n  // byte 15\n  unsigned char always1 : 1;\n  unsigned char crc : 7;\n} __attribute__((packed)) csd1_t;\n//==============================================================================\n/**\n * \\class CSDV2\n * \\brief CSD register for version 2.00 cards.\n */\ntypedef struct CSDV2 {\n  // byte 0\n  unsigned char reserved1 : 6;\n  unsigned char csd_ver : 2;\n  // byte 1\n  /** fixed to 0X0E */\n  unsigned char taac;\n  // byte 2\n  /** fixed to 0 */\n  unsigned char nsac;\n  // byte 3\n  unsigned char tran_speed;\n  // byte 4\n  unsigned char ccc_high;\n  // byte 5\n  /** This field is fixed to 9h, which indicates READ_BL_LEN=512 Byte */\n  unsigned char read_bl_len : 4;\n  unsigned char ccc_low : 4;\n  // byte 6\n  /** not used */\n  unsigned char reserved2 : 4;\n  unsigned char dsr_imp : 1;\n  /** fixed to 0 */\n  unsigned char read_blk_misalign : 1;\n  /** fixed to 0 */\n  unsigned char write_blk_misalign : 1;\n  /** fixed to 0 - no partial read */\n  unsigned char read_bl_partial : 1;\n  // byte 7\n  /** high part of card size */\n  unsigned char c_size_high : 6;\n  /** not used */\n  unsigned char reserved3 : 2;\n  // byte 8\n  /** middle part of card size */\n  unsigned char c_size_mid;\n  // byte 9\n  /** low part of card size */\n  unsigned char c_size_low;\n  // byte 10\n  /** sector size is fixed at 64 KB */\n  unsigned char sector_size_high : 6;\n  /** fixed to 1 - erase single is supported */\n  unsigned char erase_blk_en : 1;\n  /** not used */\n  unsigned char reserved4 : 1;\n  // byte 11\n  unsigned char wp_grp_size : 7;\n  /** sector size is fixed at 64 KB */\n  unsigned char sector_size_low : 1;\n  // byte 12\n  /** write_bl_len fixed for 512 byte blocks */\n  unsigned char write_bl_len_high : 2;\n  /** fixed value of 2 */\n  unsigned char r2w_factor : 3;\n  /** not used */\n  unsigned char reserved5 : 2;\n  /** fixed value of 0 - no write protect groups */\n  unsigned char wp_grp_enable : 1;\n  // byte 13\n  unsigned char reserved6 : 5;\n  /** always zero - no partial block read*/\n  unsigned char write_partial : 1;\n  /** write_bl_len fixed for 512 byte blocks */\n  unsigned char write_bl_len_low : 2;\n  // byte 14\n  unsigned char reserved7: 2;\n  /** Do not use always 0 */\n  unsigned char file_format : 2;\n  unsigned char tmp_write_protect : 1;\n  unsigned char perm_write_protect : 1;\n  unsigned char copy : 1;\n  /** Do not use always 0 */\n  unsigned char file_format_grp : 1;\n  // byte 15\n  /** not used always 1 */\n  unsigned char always1 : 1;\n  /** checksum */\n  unsigned char crc : 7;\n} __attribute__((packed)) csd2_t;\n//==============================================================================\n/**\n * \\class csd_t\n * \\brief Union of old and new style CSD register.\n */\nunion csd_t {\n  csd1_t v1;\n  csd2_t v2;\n};\n//-----------------------------------------------------------------------------\ninline uint32_t sdCardCapacity(csd_t* csd) {\n  if (csd->v1.csd_ver == 0) {\n    uint8_t read_bl_len = csd->v1.read_bl_len;\n    uint16_t c_size = (csd->v1.c_size_high << 10)\n                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;\n    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)\n                          | csd->v1.c_size_mult_low;\n    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);\n  } else if (csd->v2.csd_ver == 1) {\n    uint32_t c_size = 0X10000L * csd->v2.c_size_high + 0X100L\n                      * (uint32_t)csd->v2.c_size_mid + csd->v2.c_size_low;\n    return (c_size + 1) << 10;\n  } else {\n    return 0;\n  }\n}\n#endif  // SdInfo_h\n\n", "comment_ratio": 0.16842105263157894}
{"lang": "c", "code": "#include \"EditLexer.h\"\n#include \"EditStyleX.h\"\n\nstatic KEYWORDLIST Keywords_Kotlin = {{\n//++Autogenerated -- start of section automatically generated\n\"abstract actual annotation as break by catch class companion const constructor continue crossinline \"\n\"data delegate do dynamic else enum expect external false field file final finally for fun get \"\n\"if import in infix init inline inner interface internal is it lateinit noinline null object open operator out override \"\n\"package param private property protected public receiver reified return sealed set setparam super suspend \"\n\"tailrec this throw true try typealias typeof val var vararg when where while \"\n\n, // 1 class\n\"AbstractCollection AbstractIterator AbstractList \"\n\"AbstractMap AbstractMutableCollection AbstractMutableList AbstractMutableMap AbstractMutableSet AbstractSet Any \"\n\"Array ArrayList \"\n\"Boolean BooleanArray Byte ByteArray Char CharArray Double DoubleArray Enum Error Exception Float FloatArray \"\n\"HashMap HashSet IndexedValue Int IntArray LinkedHashMap LinkedHashSet Long LongArray MatchGroup Nothing Number Pair \"\n\"Random Regex Result RuntimeException Short ShortArray String StringBuilder Throwable Triple \"\n\"UByte UByteArray UInt UIntArray ULong ULongArray UShort UShortArray Unit \"\n\n, // 2 interface\n\"Annotation Appendable CharSequence Collection Comparable Comparator Function Grouping Iterable Iterator \"\n\"Lazy List ListIterator \"\n\"Map MatchGroupCollection MatchResult \"\n\"MutableCollection MutableIterable MutableIterator MutableList MutableListIterator MutableMap MutableSet \"\n\"RandomAccess Set \"\n\n, // 3 enum\n\"AnnotationRetention AnnotationTarget DeprecationLevel LazyThreadSafetyMode RegexOption \"\n\n, // 4 annotation\n\"Deprecated Metadata MustBeDocumented Repeatable ReplaceWith Retention Suppress Target \"\n\n, // 5 function\n\"assert( check( error( print( println( readLine( require( \"\n\n, // 6 KDoc\n\"author constructor exception param property receiver return sample see since suppress throws \"\n\n, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL\n//--Autogenerated -- end of section automatically generated\n}};\n\nstatic EDITSTYLE Styles_Kotlin[] = {\n\tEDITSTYLE_DEFAULT,\n\t{ SCE_KOTLIN_WORD, NP2StyleX_Keyword, L\"fore:#0000FF\" },\n\t{ SCE_KOTLIN_ANNOTATION, NP2StyleX_Annotation, L\"fore:#FF8000\" },\n\t{ SCE_KOTLIN_CLASS, NP2StyleX_Class, L\"fore:#0080FF\" },\n\t{ SCE_KOTLIN_INTERFACE, NP2StyleX_Interface, L\"bold; fore:#1E90FF\" },\n\t{ SCE_KOTLIN_ENUM, NP2StyleX_Enumeration, L\"fore:#FF8000\" },\n\t{ SCE_KOTLIN_FUNCTION, NP2StyleX_Function, L\"fore:#A46000\" },\n\t{ MULTI_STYLE(SCE_KOTLIN_COMMENTBLOCK, SCE_KOTLIN_COMMENTLINE, 0, 0), NP2StyleX_Comment, L\"fore:#608060\" },\n\t{ SCE_KOTLIN_COMMENTDOCWORD, NP2StyleX_DocCommentTag, L\"fore:#408080\" },\n\t{ MULTI_STYLE(SCE_KOTLIN_COMMENTBLOCKDOC, SCE_KOTLIN_COMMENTLINEDOC, 0, 0), NP2StyleX_DocComment, L\"fore:#408040\" },\n\t{ MULTI_STYLE(SCE_KOTLIN_CHARACTER, SCE_KOTLIN_STRING, 0, 0), NP2StyleX_String, L\"fore:#008000\" },\n\t{ MULTI_STYLE(SCE_KOTLIN_RAWSTRING, SCE_KOTLIN_RAWSTRINGSTART, SCE_KOTLIN_RAWSTRINGEND, 0), NP2StyleX_RawString, L\"fore:#F08000\" },\n\t{ SCE_KOTLIN_ESCAPECHAR, NP2StyleX_EscapeSequence, L\"fore:#0080C0\" },\n\t{ SCE_KOTLIN_BACKTICKS, NP2StyleX_Backticks, L\"fore:#9E4D2A\" },\n\t{ SCE_KOTLIN_LABEL, NP2StyleX_Label, L\"fore:#7C5AF3\" },\n\t{ SCE_KOTLIN_NUMBER, NP2StyleX_Number, L\"fore:#FF0000\" },\n\t{ SCE_KOTLIN_VARIABLE, NP2StyleX_Variable, L\"fore:#9E4D2A\" },\n\t{ MULTI_STYLE(SCE_KOTLIN_OPERATOR, SCE_KOTLIN_OPERATOR2, 0, 0), NP2StyleX_Operator, L\"fore:#B000B0\" },\n};\n\nEDITLEXER lexKotlin = {\n\tSCLEX_KOTLIN, NP2LEX_KOTLIN,\n\tEDITLEXER_HOLE(L\"Kotlin Source\", Styles_Kotlin),\n\tL\"kt; kts\",\n\t&Keywords_Kotlin,\n\tStyles_Kotlin\n};\n\n", "comment_ratio": 0.1111111111111111}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface CCTireAbnormalInfoModel : NSObject\n@property (nonatomic,copy)NSString    *error_type;\n@property (nonatomic,copy)NSString    *pos;\n@property (nonatomic,copy)NSString    *temperature;\n@property (nonatomic,copy)NSString    *time;\n@property (nonatomic,copy)NSString    *value;\n@property (nonatomic,copy)NSString    *vin;\n@end\n\nNS_ASSUME_NONNULL_END\n\n", "comment_ratio": 0.30434782608695654}
{"lang": "c", "code": "#ifndef OPENDNP3_GROUP50_H\n#define OPENDNP3_GROUP50_H\n\n#include <openpal/container/ReadBufferView.h>\n#include <openpal/container/WriteBufferView.h>\n#include \"opendnp3/app/GroupVariationID.h\"\n#include \"opendnp3/app/DNP3Serializer.h\"\n#include \"opendnp3/app/TimeAndInterval.h\"\n\nnamespace opendnp3 {\n\nstruct Group50Var1\n{\n  static GroupVariationID ID() { return GroupVariationID(50,1); }\n  static uint32_t Size() { return 6; }\n  static Group50Var1 Read(openpal::ReadBufferView&);\n  static void Write(const Group50Var1&, openpal::WriteBufferView&);\n  uint64_t time;\n};\n\nstruct Group50Var4\n{\n  static GroupVariationID ID() { return GroupVariationID(50,4); }\n  static uint32_t Size() { return 11; }\n  static Group50Var4 Read(openpal::ReadBufferView&);\n  static void Write(const Group50Var4&, openpal::WriteBufferView&);\n\n  static DNP3Serializer<TimeAndInterval> Inst() { return DNP3Serializer<TimeAndInterval>(ID(), Size(), &ReadTarget, &WriteTarget); }\n\n  typedef TimeAndInterval Target;\n  static TimeAndInterval ReadTarget(openpal::ReadBufferView&);\n  static void WriteTarget(const TimeAndInterval&, openpal::WriteBufferView&);\n\n  uint64_t time;\n  uint32_t interval;\n  uint8_t units;\n};\n\n\n}\n\n#endif\n\n", "comment_ratio": 0.30158730158730157}
{"lang": "c", "code": "#import <libAWDSupportFramework.dylib/libAWDSupportFramework.dylib-Structs.h>\n#import <ProtocolBuffer/PBCodable.h>\n#import <libobjc.A.dylib/NSCopying.h>\n\n@interface AWDOMICntrs : PBCodable <NSCopying> {\n\n\tunsigned _heOmitxDlmursdrec;\n\tunsigned _heOmitxDlmursdrecAck;\n\tunsigned _heOmitxDur;\n\tunsigned _heOmitxRetries;\n\tunsigned _heOmitxSched;\n\tunsigned _heOmitxSuccess;\n\tunsigned _heOmitxTxnsts;\n\tunsigned _heOmitxTxnstsAck;\n\tunsigned _heOmitxUlmucfg;\n\tunsigned _heOmitxUlmucfgAck;\n\tSCD_Struct_AW14 _has;\n\n}\n\n@property (assign,nonatomic) BOOL hasHeOmitxSched; \n@property (assign,nonatomic) unsigned heOmitxSched;                      //@synthesize heOmitxSched=_heOmitxSched - In the implementation block\n@property (assign,nonatomic) BOOL hasHeOmitxSuccess; \n@property (assign,nonatomic) unsigned heOmitxSuccess;                    //@synthesize heOmitxSuccess=_heOmitxSuccess - In the implementation block\n@property (assign,nonatomic) BOOL hasHeOmitxRetries; \n@property (assign,nonatomic) unsigned heOmitxRetries;                    //@synthesize heOmitxRetries=_heOmitxRetries - In the implementation block\n@property (assign,nonatomic) BOOL hasHeOmitxDur; \n@property (assign,nonatomic) unsigned heOmitxDur;                        //@synthesize heOmitxDur=_heOmitxDur - In the implementation block\n@property (assign,nonatomic) BOOL hasHeOmitxUlmucfg; \n@property (assign,nonatomic) unsigned heOmitxUlmucfg;                    //@synthesize heOmitxUlmucfg=_heOmitxUlmucfg - In the implementation block\n@property (assign,nonatomic) BOOL hasHeOmitxUlmucfgAck; \n@property (assign,nonatomic) unsigned heOmitxUlmucfgAck;                 //@synthesize heOmitxUlmucfgAck=_heOmitxUlmucfgAck - In the implementation block\n@property (assign,nonatomic) BOOL hasHeOmitxTxnsts; \n@property (assign,nonatomic) unsigned heOmitxTxnsts;                     //@synthesize heOmitxTxnsts=_heOmitxTxnsts - In the implementation block\n@property (assign,nonatomic) BOOL hasHeOmitxTxnstsAck; \n@property (assign,nonatomic) unsigned heOmitxTxnstsAck;                  //@synthesize heOmitxTxnstsAck=_heOmitxTxnstsAck - In the implementation block\n@property (assign,nonatomic) BOOL hasHeOmitxDlmursdrec; \n@property (assign,nonatomic) unsigned heOmitxDlmursdrec;                 //@synthesize heOmitxDlmursdrec=_heOmitxDlmursdrec - In the implementation block\n@property (assign,nonatomic) BOOL hasHeOmitxDlmursdrecAck; \n@property (assign,nonatomic) unsigned heOmitxDlmursdrecAck;              //@synthesize heOmitxDlmursdrecAck=_heOmitxDlmursdrecAck - In the implementation block\n-(BOOL)isEqual:(id)arg1 ;\n-(unsigned long long)hash;\n-(id)copyWithZone:(NSZone*)arg1 ;\n-(id)description;\n-(id)dictionaryRepresentation;\n-(BOOL)readFrom:(id)arg1 ;\n-(void)writeTo:(id)arg1 ;\n-(void)mergeFrom:(id)arg1 ;\n-(void)copyTo:(id)arg1 ;\n-(void)setHeOmitxSched:(unsigned)arg1 ;\n-(void)setHasHeOmitxSched:(BOOL)arg1 ;\n-(BOOL)hasHeOmitxSched;\n-(void)setHeOmitxSuccess:(unsigned)arg1 ;\n-(void)setHasHeOmitxSuccess:(BOOL)arg1 ;\n-(BOOL)hasHeOmitxSuccess;\n-(void)setHeOmitxRetries:(unsigned)arg1 ;\n-(void)setHasHeOmitxRetries:(BOOL)arg1 ;\n-(BOOL)hasHeOmitxRetries;\n-(void)setHeOmitxDur:(unsigned)arg1 ;\n-(void)setHasHeOmitxDur:(BOOL)arg1 ;\n-(BOOL)hasHeOmitxDur;\n-(void)setHeOmitxUlmucfg:(unsigned)arg1 ;\n-(void)setHasHeOmitxUlmucfg:(BOOL)arg1 ;\n-(BOOL)hasHeOmitxUlmucfg;\n-(void)setHeOmitxUlmucfgAck:(unsigned)arg1 ;\n-(void)setHasHeOmitxUlmucfgAck:(BOOL)arg1 ;\n-(BOOL)hasHeOmitxUlmucfgAck;\n-(void)setHeOmitxTxnsts:(unsigned)arg1 ;\n-(void)setHasHeOmitxTxnsts:(BOOL)arg1 ;\n-(BOOL)hasHeOmitxTxnsts;\n-(void)setHeOmitxTxnstsAck:(unsigned)arg1 ;\n-(void)setHasHeOmitxTxnstsAck:(BOOL)arg1 ;\n-(BOOL)hasHeOmitxTxnstsAck;\n-(void)setHeOmitxDlmursdrec:(unsigned)arg1 ;\n-(void)setHasHeOmitxDlmursdrec:(BOOL)arg1 ;\n-(BOOL)hasHeOmitxDlmursdrec;\n-(void)setHeOmitxDlmursdrecAck:(unsigned)arg1 ;\n-(void)setHasHeOmitxDlmursdrecAck:(BOOL)arg1 ;\n-(BOOL)hasHeOmitxDlmursdrecAck;\n-(unsigned)heOmitxSched;\n-(unsigned)heOmitxSuccess;\n-(unsigned)heOmitxRetries;\n-(unsigned)heOmitxDur;\n-(unsigned)heOmitxUlmucfg;\n-(unsigned)heOmitxUlmucfgAck;\n-(unsigned)heOmitxTxnsts;\n-(unsigned)heOmitxTxnstsAck;\n-(unsigned)heOmitxDlmursdrec;\n-(unsigned)heOmitxDlmursdrecAck;\n@end\n\n\n", "comment_ratio": 0.1}
{"lang": "c", "code": "#ifndef EXTENSIONS_RENDERER_V8_HELPERS_H_\n#define EXTENSIONS_RENDERER_V8_HELPERS_H_\n\n#include <stdint.h>\n#include <string.h>\n\n#include \"base/strings/string_number_conversions.h\"\n#include \"v8/include/v8.h\"\n\nnamespace extensions {\nnamespace v8_helpers {\n\n// Helper functions for V8 APIs.\n\n// Converts |str| to a V8 string. Returns true on success.\ninline bool ToV8String(v8::Isolate* isolate,\n                       const char* str,\n                       v8::Local<v8::String>* out) {\n  return v8::String::NewFromUtf8(isolate, str, v8::NewStringType::kNormal)\n      .ToLocal(out);\n}\n\ninline bool ToV8String(v8::Isolate* isolate,\n                       const std::string& str,\n                       v8::Local<v8::String>* out) {\n  return ToV8String(isolate, str.c_str(), out);\n}\n\n// Converts |str| to a V8 string.\n// This crashes when strlen(str) > v8::String::kMaxLength.\ninline v8::Local<v8::String> ToV8StringUnsafe(\n    v8::Isolate* isolate,\n    const char* str,\n    v8::NewStringType string_type = v8::NewStringType::kNormal) {\n  DCHECK(strlen(str) <= v8::String::kMaxLength);\n  return v8::String::NewFromUtf8(isolate, str, string_type)\n      .ToLocalChecked();\n}\n\ninline v8::Local<v8::String> ToV8StringUnsafe(\n    v8::Isolate* isolate,\n    const std::string& str,\n    v8::NewStringType string_type = v8::NewStringType::kNormal) {\n  return ToV8StringUnsafe(isolate, str.c_str(), string_type);\n}\n\n// Returns true if |maybe| is both a value, and that value is true.\ninline bool IsTrue(v8::Maybe<bool> maybe) {\n  return maybe.IsJust() && maybe.FromJust();\n}\n\n// SetProperty() family wraps V8::Object::DefineOwnProperty().\n// Returns true on success.\n// NOTE: Think about whether you want this or SetPrivateProperty() below.\n// TODO(devlin): Sort through more of the callers of this and see if we can\n// convert more to be private.\ninline bool SetProperty(v8::Local<v8::Context> context,\n                        v8::Local<v8::Object> object,\n                        v8::Local<v8::String> key,\n                        v8::Local<v8::Value> value) {\n  return IsTrue(object->DefineOwnProperty(context, key, value));\n}\n\n// Wraps v8::Object::SetPrivate(). When possible, prefer this to SetProperty().\ninline bool SetPrivateProperty(v8::Local<v8::Context> context,\n                               v8::Local<v8::Object> object,\n                               v8::Local<v8::String> key,\n                               v8::Local<v8::Value> value) {\n  return IsTrue(object->SetPrivate(\n      context, v8::Private::ForApi(context->GetIsolate(), key), value));\n}\n\ninline bool SetPrivateProperty(v8::Local<v8::Context> context,\n                               v8::Local<v8::Object> object,\n                               const char* key,\n                               v8::Local<v8::Value> value) {\n  v8::Local<v8::String> v8_key;\n  return ToV8String(context->GetIsolate(), key, &v8_key) &&\n         IsTrue(object->SetPrivate(\n             context, v8::Private::ForApi(context->GetIsolate(), v8_key),\n             value));\n}\n\n// GetProperty() family calls V8::Object::Get() and extracts a value from\n// returned MaybeLocal. Returns true on success.\n// NOTE: Think about whether you want this or GetPrivateProperty() below.\ntemplate <typename Key>\ninline bool GetProperty(v8::Local<v8::Context> context,\n                        v8::Local<v8::Object> object,\n                        Key key,\n                        v8::Local<v8::Value>* out) {\n  return object->Get(context, key).ToLocal(out);\n}\n\ninline bool GetProperty(v8::Local<v8::Context> context,\n                        v8::Local<v8::Object> object,\n                        const char* key,\n                        v8::Local<v8::Value>* out) {\n  v8::Local<v8::String> v8_key;\n  if (!ToV8String(context->GetIsolate(), key, &v8_key))\n    return false;\n  return GetProperty(context, object, v8_key, out);\n}\n\n// Wraps v8::Object::GetPrivate(). When possible, prefer this to GetProperty().\ninline bool GetPrivateProperty(v8::Local<v8::Context> context,\n                               v8::Local<v8::Object> object,\n                               v8::Local<v8::String> key,\n                               v8::Local<v8::Value>* out) {\n  return object\n      ->GetPrivate(context, v8::Private::ForApi(context->GetIsolate(), key))\n      .ToLocal(out);\n}\n\ninline bool GetPrivateProperty(v8::Local<v8::Context> context,\n                               v8::Local<v8::Object> object,\n                               const char* key,\n                               v8::Local<v8::Value>* out) {\n  v8::Local<v8::String> v8_key;\n  return ToV8String(context->GetIsolate(), key, &v8_key) &&\n         GetPrivateProperty(context, object, v8_key, out);\n}\n\n// GetPropertyUnsafe() family wraps v8::Object::Get(). They crash when an\n// exception is thrown.\ninline v8::Local<v8::Value> GetPropertyUnsafe(v8::Local<v8::Context> context,\n                                              v8::Local<v8::Object> object,\n                                              v8::Local<v8::Value> key) {\n  return object->Get(context, key).ToLocalChecked();\n}\n\ninline v8::Local<v8::Value> GetPropertyUnsafe(\n    v8::Local<v8::Context> context,\n    v8::Local<v8::Object> object,\n    const char* key,\n    v8::NewStringType string_type = v8::NewStringType::kNormal) {\n  return object->Get(context,\n                     ToV8StringUnsafe(context->GetIsolate(), key, string_type))\n      .ToLocalChecked();\n}\n\n// Wraps v8::Function::Call(). Returns true on success.\ninline bool CallFunction(v8::Local<v8::Context> context,\n                         v8::Local<v8::Function> function,\n                         v8::Local<v8::Value> recv,\n                         int argc,\n                         v8::Local<v8::Value> argv[],\n                         v8::Local<v8::Value>* out) {\n  v8::MicrotasksScope microtasks_scope(\n      context->GetIsolate(), v8::MicrotasksScope::kDoNotRunMicrotasks);\n  return function->Call(context, recv, argc, argv).ToLocal(out);\n}\n\n}  // namespace v8_helpers\n}  // namespace extensions\n\n#endif  // EXTENSIONS_RENDERER_V8_HELPERS_H_\n\n", "comment_ratio": 0.14814814814814814}
{"lang": "c", "code": "#include <stdio.h>     // para entradas e saida\n#include <stddef.h>    // para definicoes basicas\n#include <stdlib.h>    // para a biblioteca padrao\n#include <string.h>    // para cadeias de caracteres\n#include <stdarg.h>    // para tratar argumentos\n#include <stdbool.h>   // para definicoes logicas\n#include <ctype.h>     // para tipos padroes\n#include <math.h>      // para definicoes matematicas\n#include <time.h>      // para medir tempo\n\nint readint (const char* text)\n{\n  int result = 0;\n\n  printf ( \"%s\\n\", text );\n  scanf  ( \"%d\", &result);\n  getchar ();\n  //\n  return ( result );\n}\n\nvoid Metodo00 ( )\n{\n    printf (\"Aperte zero para parar a execucao do programa!\\n\");\n    printf ( \"\\nApertar ENTER para continuar.\\n\" );\n    getchar ();\n  //\n}//end\nvoid Metodo01 ( )\n{\n    printf (\"Executa o Metodo01 \");\n\t  int X = 0;\n\t\t\t\n\t\t\tprintf (\"Insira um valor para X!\\n\");\n\t\t\tscanf  (\"%d\", &X);\n\t\t\t\n\t\t\n\t\t\tif (X%2 == 0 && X >= 0)\n\t\t\t{\n\t\t\t\tprintf (\"Eh par!\\n\");\n\t\t\t}\n\t\t\n\t\t\telse if (X%2 != 0)\n\t\t\t{\n\t\t\t\tprintf (\"Eh impar!\\n\");\n\t\t\t}\n\t\t\telse if (X%2 == 0 && X < 0)\n\t\t\t{\n\t\t\t\t\tprintf (\"Eh par!\\n\");\n\t\t\t}\t\n\t\t\telse if (X%2 != 0 && X < 0)\n\t\t\t{\n\t\t\t\t\tprintf (\"Eh impar!\\n\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t\tprintf (\"Tente novamente!\");\n\t\t\t}\n    printf ( \"\\nApertar ENTER para continuar.\\n\" );\n    getchar( );\n      //\n}//end Metodo01\n\nvoid Metodo02 ( )\n{\n    printf (\"Executa o Metodo02 \\n\");\n    int X = 0;\n\t\t\t\n\t\t\tprintf (\"Insira um valor inteiro para X!\\n\");\n\t\t\tscanf  (\"%d\", &X);\n\t\t\t\n\t\t\tif (X >= 20 && X <= 45 && X >= 33 && X <= 66)\n\t\t\t{\n\t\t\t\t\tprintf (\"Pertence a ambos os intervalos!\\n\");\n\t\t\t}\n\t\t\telse if (X >= 20 && X <= 45)\n\t\t\t{\n\t\t\t\t\tprintf (\"Pertene somente ao primeiro intervalo fechado!\\n\");\n\t\t\t}\n\t\t\telse if (X >= 33 && X <= 66)\n\t\t\t{\n\t\t\t\t\tprintf (\"Pertence somente ao segundo intervalo!\\n\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t\tprintf (\"Nao pertence a intervalo algum!\\n\");\n\t\t\t}\n    printf ( \"\\nApertar ENTER para continuar.\\n\" );\n    getchar( );\n    \n  //\n}//end Metodo02\n\nvoid Metodo03 ( )\n{\n    printf (\"Executa o Metodo03\\n\");\n\t\t\tint X = 0;\n\t\t\t\n\t\t\t\tprintf (\"Insira o valor de X!\\n\");\n\t\t\t\tscanf  (\"%d\", &X);\n\t\t\t\t\n\t\t\t\tif (X > 30 && X < 75)\n\t\t\t\t{\n\t\t\t\t\t\tprintf (\"Esta dentro do intervalo!\\n\");\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t\tprintf (\"Esta fora do intervalo!\\n\");\n\t\t\t\t}\n    printf ( \"\\nApertar ENTER para continuar.\\n\" );\n    getchar( );\n\n}//end Metodo03\n\nvoid Metodo04 ( )\n{\n    printf (\"Executa o Metodo04\\n\");\n\t\t\tint X = 0;\n\t\t\n\t\t\t printf (\"Insira um valr inteiro para X!\\n\");\n\t\t\t scanf  (\"%d\", &X);\n\t\t\n\t\t\tif (X >= 30 && X <= 75)\n\t\t\t{\n\t\t\t\t\tprintf (\"Pertence ao intervalo!\\n\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t\tprintf (\"Nao pertence ao intervalo!\\n\");\n\t\t\t}\n    printf ( \"\\nApertar ENTER para continuar.\\n\" );\n    getchar( );\n    \n}//end Metodo04\n\nvoid Metodo05 ( )\n{\n    printf (\"Executa o Metodo05\\n\");\n\t\t\tint X = 0;\n\t\t\t\n\t\t\tprintf (\"Insira um valor inteiro para X!\\n\");\n\t\t\tscanf  (\"%d\", &X);\n\t\t\t\n\t\t\tif (X >= 20 && X <= 45 && X >= 33 && X <= 66)\n\t\t\t{\n\t\t\t\t\tprintf (\"Pertence a ambos os intervalos!\\n\");\n\t\t\t}\n\t\t\telse if (X >= 20 && X <= 45)\n\t\t\t{\n\t\t\t\t\tprintf (\"Pertene somente ao primeiro intervalo fechado!\\n\");\n\t\t\t}\n\t\t\telse if (X >= 33 && X <= 66)\n\t\t\t{\n\t\t\t\t\tprintf (\"Pertence somente ao segundo intervalo!\\n\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t\tprintf (\"Nao pertence a intervalo algum!\\n\");\n\t\t\t}\n    printf ( \"\\nApertar ENTER para continuar.\\n\" );\n    getchar( );\n    \n}//end Metodo05\n\nvoid Metodo06 ( )\n{\n    printf (\"Executa o Metodo06\\n\");\n\t\t\tint X = 0;\n\t\t\tint Y = 0;\n\t\t\t\n         printf (\"Insira um valor inteiro para X!\\n\");\n         scanf  (\"%d\", &X);\n\t\t\t\n         printf (\"Insira um valor inteiro para Y!\\n\");\n         scanf  (\"%d\", &Y);\n\t\t\t\t\t\t\n\t\t\tif (X%2 == 0 && Y%2 != 0 && X != 0 && Y != 0)\n\t\t\t{\n\t\t\t\t\tprintf (\" %i Eh par e %i eh impar!\\n\", X, Y); \n\t\t\t}\n\t\t\telse if (X%2 != 0 && Y%2 == 0 && X != 0 && Y != 0)\n\t\t\t{\n\t\t\t\t\t\tprintf (\"Eh impar %i e %i eh impar!\\n\", X, Y);\n\t\t\t}\n\t\t\telse\n         {\n            printf (\"Volte e reveja seu c\u00f3digo!!!!\");\n         }\n    printf ( \"\\nApertar ENTER para continuar.\\n\" );\n    getchar( );\n\n}//end Metod06\n\nvoid Metodo07 ( )\n{\n    printf (\"Executa o Metodo07\\n\");\n\t\tint X = 0;\n\t\tint Y = 0;\n\t\t\n\t\tprintf (\"Insira um valor inteiro para X!\\n\");\n\t\tscanf  (\"%d\", &X);\n\t\t\n\t    printf (\"Insira o valor inteiro para Y!\\n\");\n\t\tscanf  (\"%d\", &Y);\n\t\t//Verificando se X \u00e9 positivo e par e Y \u00e9 negativo e \u00edmpar\n\t\tif (X%2 == 0 && Y%2 != 0 && X > 0 && Y < 0)\n\t\t{\n\t\t\t\tprintf (\"%d Eh par e positivo\\n\", X);\n\t\t\t\tprintf (\"%d Eh impar e negativo\\n\", Y);\n\t\t}\n\t\t//Verificando se X \u00e9 par e negtivo e se Y \u00e9 \u00edmpar e positivo\n\t\telse if (X%2 == 0 && Y%2 != 0 && X < 0 && Y > 0)\n\t\t{\n\t\t\tprintf (\"%d Eh par e negativo\\n\", X);\n\t\t\tprintf (\"%d Eh impar e positivo\", Y);\n\t\t}\n\t\t//Verifica se \u00e9 par e negativo e \u00edmpar e positivo\n\t\telse if (X%2 != 0 && Y%2 == 0 && X < 0 && Y > 0)\n\t\t{\n\t\t\tprintf (\"%d Eh impar e negativo\\n\", X);\n\t\t\tprintf (\"%d Eh par e positivo\", Y);\n\t\t\t\n\t\t}\n\t\t//Verifica se eh par negativo e impar negativo\n\t\telse if (X%2 == 0 && Y%2 != 0 && X < 0 && Y < 0)\n\t\t{\n\t\t\t\tprintf (\"%d Eh par e negativo\\n\", X);\n\t\t\t\tprintf (\"%d Eh impar e negativo\\n\", Y);\n\t\t}\n\t\t//Verifica se \u00e9 par positivo e \u00edmpar positivo\n\t\telse if (X%2 == 0 && Y%2 != 0 && X > 0 && Y > 0)\n\t\t{\n\t\t\tprintf (\"%d Eh par e positivo\\n\", X);\n\t\t\tprintf (\"%d Eh impar e positivo\\n\", Y);\n\t\t\t\n\t\t}\n\t\t//Verifica se ambos sao pares e negativos\n\t\telse if (X%2 == 0 && Y%2 == 0 && X < 0 && Y < 0)\n\t\t{\n\t\t\tprintf (\"%d Eh par e negatitivo\\n\", X);\n\t\t\tprintf (\"%d Eh par e negativo\\n\", Y);\n\t\t}\n\t\t//Verifica se ambos s\u00e3o impares e negativos\n\t\telse if (X%2 != 0 && Y%2 != 0 && X < 0 && Y < 0)\n\t\t{\n\t\t\tprintf (\"%d Eh impar e negativo\\n\", X);\n\t\t\tprintf (\"%d Eh impar e negativo\\n\", Y);\n\t\t}\n\t\t//Verifica se ambos s\u00e3o impares e positivos\n\t\telse if (X%2 != 0 && Y%2 != 0 && X > 0 && Y > 0)\n\t\t{\n\t\t\tprintf (\"%d Eh impar e positivo\\n\", X);\n\t\t\tprintf (\"%d Eh impar e positivo\\n\", Y);\n\t\t}\t\n\t\t//Verifica se s\u00e3o pares e positivos\n\t\telse if (X%2 == 0 && Y%2 == 0 && X > 0 && Y > 0)\n\t\t{\n\t\t\tprintf (\"%d Eh par e positivo\\n\", X);\n\t\t\tprintf (\"%d Eh par e positivo\\n\", Y);\n\t\t}\n\t\t//Verificando se X \u00e9 negativo e \u00edmpar e Y \u00e9 negativo e par\n\t\telse if (X%2 != 0 && Y%2 == 0 && X < 0 && Y < 0)\n\t\t{\n\t\t\t\tprintf (\"%d Eh impar e negativo\\n\", X);\n\t\t\t\tprintf (\"%d Eh par e positivo\\n\", Y);\n\t\t}\n\t\t//Verifica se X \u00e9 impar positivo e Y par positivo\n\t\telse if (X%2 != 0 && Y%2 == 0 && X > 0 && Y > 0)\n\t\t{\n\t\t\t\tprintf (\"%d Eh impar e positivo\\n\", X);\n\t\t\t\tprintf (\"%d Eh par e positivo\\n\", Y);\n\t\t}\n\t\t//Verifica se ambos s\u00e3o pares positivos\n\t\telse if (X%2 == 0 && Y%2 == 0 && X > 0 && Y > 0)\n\t\t{\n\t\t\t\tprintf (\"%d Eh par e positivo\\n\", X);\n\t\t\t\tprintf (\"%d Eh par e positivo\\n\", Y);\n\t\t}\n\t\t//Verifica se ambos s\u00e3o impares positivos\n\t\telse if (X%2 != 0 && Y%2 != 0 && X > 0 && Y > 0)\n\t\t{\n\t\t\t\tprintf (\"%d Eh impar e positivo\\n\", X);\n\t\t\t\tprintf (\"%d Eh par e positivo\\n\", Y);\n\t\t}\n\t\t//Verifica se ambos s\u00e3o impares negativos\n\t\telse if (X%2 != 0 && Y%2 != 0 && X < 0 && Y < 0)\n\t\t{\n\t\t\t\tprintf (\"%d Eh impar e negativo\\n\", X);\n\t\t\t\tprintf (\"%d Eh impar e negativo\\n\", Y);\n\t\t}\n\t\t//Verifica se ambos s\u00e3o impares e positivos\n\t\telse if (X%2 != 0 && Y%2 != 0 && X > 0 && Y > 0)\n\t\t{\n\t\t\t\tprintf (\"%d Eh impar e positivo\", X);\n\t\t\t\tprintf (\"%d Eh impar e positivo\", Y);\n\t\t}\n\t\t//Verifica se X \u00e9 impar negativo e Y \u00e9 impar positivo\n\t\telse if (X%2 != 0 && Y%2 != 0 && X < 0 && Y > 0)\n\t\t{\n\t\t\t\tprintf (\"%d Eh impar e negativo\\n\", X);\n\t\t\t\tprintf (\"%d Eh par e positivo\\n\", Y);\n\t\t}\n\t\t//Verifica se X \u00e9 impar positivo e Y \u00e9 impar negativo\n\t\telse if (X%2 != 0 && Y%2 != 0 && X > 0 && Y < 0)\n\t\t{\n\t\t\t\tprintf (\"%d Eh impar e positivo\\n\", X);\n\t\t\t\tprintf (\"%d Eh par e negativo\\n\", Y);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t\tprintf (\"Eh igual a zero!\");\n\t\t}\n    printf ( \"\\nApertar ENTER para continuar.\\n\" );\n    getchar( );\n\n}//end Metodo07\n\nvoid Metodo08 ( )\n{\n    printf (\"Executa o Metodo08\\n\");\n\t\tint X = 0;\n\t\tint Y = 0;\n\t\t\n      printf (\"Insira um valor inteiro para X!\\n\");\n      scanf  (\"%d\", &X);\n\t\t\n      printf (\"Insira um vlaor inteiro para T!\\n\");\n      scanf  (\"%d\", &Y);\n\t\tif (X > Y)\n\t\t{\n\t\t\tprintf (\"O primeiro eh maior do que o segundo\\n\");\n\t\t}\n\t\telse if (X < Y)\n\t\t{\n\t\t\t\tprintf (\"O primeiro eh menor do que o segundo\\n\");\n\t\t}\n\t\telse if (X == Y)\n\t\t{\n\t\t\t\tprintf (\"O primeiro eh igual ao segundo\\n\");\n\t\t}\n\t\telse if (Y < X)\n\t\t{\n\t\t\tprintf (\"O primeiro eh maior do que o segundo\\n\");\n\t\t}\n\t\telse if (Y > X)\n\t\t{\n\t\t\tprintf (\"O primeiro eh menor do que o segundo\\n\");\n\t\t}\n\t\telse if (Y == X)\n\t\t{\n\t\t\t\tprintf (\"O primeiro eh igual ao o segundo\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\t\tprintf (\"Fora do proposto pelo programa!\");\n\t\t}\n    printf ( \"\\nApertar ENTER para continuar.\\n\" );\n    getchar( );\n \n}//end Metodo 08\n\nvoid Metodo09 ( )\n{\n    printf (\"Executa o Metodo09\\n\");\n\t\tint X = 0;\n\t\tint Y = 0;\n\t\tint Z = 0;\n\t\t\n      printf (\"Insira um valor inteiro para X!\\n\");\n      scanf  (\"%i\", &X);\n      \n\t  printf (\"Insira um valor inteiro para Y\\n\");\n      scanf  (\"%i\", &Y);\n      \n      printf (\"Insira um valor inteiro para Z\\n\");\n      scanf  (\"%i\", &Z);\n\t\t\n\t\tif (Y < X && Z > X && Y != Z)\n\t\t{\n\t\t\tprintf (\"O primeiro esta entre o segundo e o terceiro e sao diferentes entre si!\\n\");\n\t\t}//end if\n\t\telse if (X < Y && X > Z && Y != Z)\n\t\t{\n\t\t\t\tprintf (\"O primeiro esta entre o segundo e o terceiro e sao diferentes entre si!\\n\");\n\t\t}//end else if\n\t\t\n\t\telse\n\t\t{\n\t\t\t\tprintf (\"Fora do proposto pelo exercicio!\");\n\t\t}\n    printf ( \"\\nApertar ENTER para continuar.\\n\" );\n    getchar( );\n\n}//end Metodo09\n\nvoid Metodo10 ( )\n{\n    printf (\"Executa o Metodo10\\n\");\n\t\tint X = 0;\n\t\tint Y = 0;\n\t\tint Z = 0;\n\t\t\n      printf (\"Insira um valor inteiro para X!\\n\");\n      scanf  (\"%d\", &X);\n\t\t\n      printf (\"Insira um valor inteiro para Y!\\n\");\n      scanf  (\"%d\", &Y);\n      \n      printf (\"Insira um valor inteiro para Z!\\n\");\n      scanf  (\"%d\", &Z);\n\t\t\n      if (Y < X && Z > X && Y != Z)\n\t\t{\n\t\t\tprintf (\"O primeiro esta entre o segundo e o terceiro e sao diferentes entre si!\\n\");\n\t\t}\n\t\telse if (X < Y && X > Z && Y != Z)\n\t\t{\n\t\t\t\tprintf (\"O primeiro esta entre o segundo e o terceiro e sao diferentes entre si!\\n\");\n\t\t}\n\t\telse if (Y < X && Z > X && Y == Z)\n\t\t{\n\t\t\t\tprintf (\"O segundo e o terceiro sao diferentes entre si e o primeiro nao esta entre os dois!\\n\");\n\t\t}\n\t\telse if (Y > X && Z < X && Y == Z)\n\t\t{\n\t\t\t\tprintf (\"O segundo e o terceiro nao sao diferentes entre si e o primeiro nao esta entre os dois!\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\t\tprintf (\"Nao esta entre o segundo e o terceiro e nao sao diferentes entre si!\");\n\t\t}\n    printf ( \"\\nApertar ENTER para continuar.\\n\" );\n    getchar( );\n \n}//end Metodo10\n\n/**\n  Acao principal.\n*/\nint main ( )\n{\n // definir dados/resultados\n\tint    opcao =  0;\n // identificar\n    printf ( \"Henrique Augusto Rodrigues - versao 1.0 - 2020\\n\" );\n    printf ( \"675263 - XXX\\n\" );\n    printf ( \"\\n\" );\n\n // encerrar\ndo\n{\n  printf ( \"\\n\" );\n  printf ( \"Opcoes: \\n\" );\n  printf ( \"0 - Terminar\\n\" );\n  printf ( \"1 - Dizer se o numero inteiro digitado no teclado eh par ou impar.\\n\" );\n  printf ( \"2 - Dizer se um numero eh par e menor que -100 ou impar e maior que 100.\\n\" );\n  printf ( \"3 - Dizer se o valor inteiro do teclado esta no intervalo aberto (30:75).\\n\" );\n  printf ( \"4 - Ler um valor inteiro do teclado e dizer se pertence ao intervalo fechado [30:75].\\n\" );\n  printf ( \"5 - Ler um valor inteiro do teclado e dizer se pertence aos intervalos fechados [20:45] e [33:66] ou apenas a um deles.\\n\" );\n  printf ( \"6 - Dizer se o numero inteiro digitado no teclado eh par ou impar.\\n\" );\n  printf ( \"7 - Ler dois valores e dizer se o primeiro eh par e positivo e o segundo impar e negativo.\\n\" );\n  printf ( \"8 - Ler dois valores e dizer se o primeiro eh maior, menor ou igual ao segundo.\\n\" );\n  printf ( \"9 - ler tres valores reais do teclado e dizer se o primeiro esta\u00a1 entre os outros dois quando esses forem diferentes entre si.\\n\" );\n  printf ( \"10 - ler tres valores reais do teclado e dizer se o primeiro nao esta entre os outros dois quando esses forem diferentes entre si.\\n\");\n  \n  printf ( \"Escolher a opcao\\n\" ); \t\n  opcao = readint ( \"Insira uma opcao (valor inteiro)!\\n\" );\n  \n  switch ( opcao )\n{\n  case 0:\n    Metodo00 (); //\n   break;\n  case 1:\n    Metodo01 (); //\n   break;\n  case 2:\n    Metodo02 (); //\n   break;\n  case 4:\n    Metodo04 (); //\n   break;\n  case 5:\n    Metodo05 (); //\n   break;\n  case 6:\n    Metodo06 (); //\n   break;\n  case 7:\n    Metodo07 (); //\n   break;\n  case 8:\n    Metodo08 (); //\n   break;\n  case 9:\n    Metodo09 (); //\n   break;\n  case 10:\n    Metodo10 (); //\n   break;\n  default:\n    printf (\"\\nERRO 404 option not found!\"); //\n}\n}\nwhile ( opcao != 0 );\n    printf ( \"\\nApertar ENTER para terminar.\\n\" );\n    getchar( );\n    \n    return ( 0 );\n} // fim main ( )\n\n", "comment_ratio": 0.11368015414258188}
{"lang": "c", "code": "#pragma once\n#include <span>\n#include <string>\n\n/// class MappedFile\n/// Opens a file and memory maps it using the Win32 API.\n/// Provides an interface for generating views for the mapped file.\n/// This class can be used to open or create files which can be read from and written to as if\n///   they were sections of main memory.\nclass MappedFile {\npublic:\n  enum class CreationDisposition {\n    OPEN, // Will open an existing file or throw a std::runtime_error if the file is not found.\n    CREATE // Will create a new file or throw a std::runtime_error if the file already exists.\n  };\n\n  // MappedFile constructor\n  // When disposition is OPEN, length is ignored.\n  // When disposition is CREATE, length must be non-zero.\n  // Map length can not be adjusted after creation.\n  MappedFile(const std::string& filename, CreationDisposition disposition, uint64_t desiredLength = 0);\n  MappedFile(const MappedFile&) = delete;\n  MappedFile(MappedFile&&);\n  ~MappedFile();\n\n  // Returns length (in bytes) of file/map.\n  uint64_t size() const { return length; }\n\n  class View; // forward declaration\n\n  // Returns a View object with the indicated offset and length.\n  // Length may not be zero. Use MappedFile::size() to get map length.\n  View getView(uint64_t offset, size_t length);\n\n  // class MappedFile::View\n  // Objects of this type must be instantiated using the MappedFile::getView() function.\n  // The View object inherits from std::span<byte>. The only additional behavior is a destructor \n  //   which flushes and releases the underlying WinAPI view resource.\n  // Note that views are invalidated when the MappedFile object which created them is destructed.\n  //   View behavior beyond that point is undefined, but will probably (hopefully) result in a segfault.\n  class View : public std::span<std::byte> {\n    friend View MappedFile::getView(uint64_t offset, size_t length);\n  public:\n    View(const View&) = delete;\n    View(View&&);\n    ~View();\n\n  private:\n    View(std::byte*, size_t);\n    std::byte* ptr;\n\n  };\n\nprivate:\n  void* file;\n  void* map;\n  uint64_t length;\n\n};\n\n", "comment_ratio": 0.35}
{"lang": "c", "code": "#ifndef clocktree3_hpp\n#define clocktree3_hpp\n\n#include <stdio.h>\n#include <stdio.h>\n#include <fstream>\n#include <sstream>\n#include \"clocktree.h\"\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <chrono>\n#include <random>\n#endif /* clocktree3_hpp */\n\n", "comment_ratio": 0.3181818181818182}
{"lang": "c", "code": "#ifndef CHROME_BROWSER_ANDROID_AUTOFILL_ASSISTANT_CLIENT_ANDROID_H_\n#define CHROME_BROWSER_ANDROID_AUTOFILL_ASSISTANT_CLIENT_ANDROID_H_\n\n#include <map>\n#include <memory>\n#include <string>\n\n#include \"base/android/scoped_java_ref.h\"\n#include \"base/macros.h\"\n#include \"base/memory/weak_ptr.h\"\n#include \"chrome/browser/android/autofill_assistant/ui_controller_android.h\"\n#include \"components/autofill_assistant/browser/access_token_fetcher.h\"\n#include \"components/autofill_assistant/browser/client.h\"\n#include \"components/autofill_assistant/browser/controller.h\"\n#include \"components/autofill_assistant/browser/device_context.h\"\n#include \"components/autofill_assistant/browser/service.h\"\n#include \"components/autofill_assistant/browser/website_login_manager.h\"\n#include \"content/public/browser/web_contents.h\"\n#include \"content/public/browser/web_contents_user_data.h\"\n\nnamespace autofill_assistant {\n\n// Creates a Autofill Assistant client associated with a WebContents.\n//\n// To obtain an instance of this class from the C++ side, call\n// ClientAndroid::FromWebContents(web_contents). To make sure an instance\n// exists, call ClientAndroid::CreateForWebContents first.\n//\n// From the Java side, call AutofillAssistantClient.fromWebContents.\n//\n// This class is accessible from the Java side through AutofillAssistantClient.\nclass ClientAndroid : public Client,\n                      public AccessTokenFetcher,\n                      public content::WebContentsUserData<ClientAndroid> {\n public:\n  ~ClientAndroid() override;\n\n  // Returns the corresponding Java AutofillAssistantClient.\n  base::android::ScopedJavaLocalRef<jobject> GetJavaObject();\n\n  bool Start(\n      JNIEnv* env,\n      const base::android::JavaParamRef<jobject>& jcaller,\n      const base::android::JavaParamRef<jstring>& jinitial_url,\n      const base::android::JavaParamRef<jstring>& jexperiment_ids,\n      const base::android::JavaParamRef<jstring>& jcaller_account,\n      const base::android::JavaParamRef<jobjectArray>& parameter_names,\n      const base::android::JavaParamRef<jobjectArray>& parameter_values,\n      jboolean jis_cct,\n      const base::android::JavaParamRef<jobject>& jonboarding_coordinator,\n      jboolean jonboarding_shown,\n      jlong jservice);\n  void DestroyUI(JNIEnv* env,\n                 const base::android::JavaParamRef<jobject>& jcaller);\n  void TransferUITo(\n      JNIEnv* env,\n      const base::android::JavaParamRef<jobject>& jcaller,\n      const base::android::JavaParamRef<jobject>& jother_web_contents);\n\n  base::android::ScopedJavaLocalRef<jstring> GetPrimaryAccountName(\n      JNIEnv* env,\n      const base::android::JavaParamRef<jobject>& jcaller);\n  void OnAccessToken(JNIEnv* env,\n                     const base::android::JavaParamRef<jobject>& jcaller,\n                     jboolean success,\n                     const base::android::JavaParamRef<jstring>& access_token);\n\n  void FetchWebsiteActions(\n      JNIEnv* env,\n      const base::android::JavaParamRef<jobject>& jcaller,\n      const base::android::JavaParamRef<jstring>& jexperiment_ids,\n      const base::android::JavaParamRef<jobjectArray>& jargument_names,\n      const base::android::JavaParamRef<jobjectArray>& jargument_values,\n      const base::android::JavaParamRef<jobject>& jcallback);\n\n  bool HasRunFirstCheck(\n      JNIEnv* env,\n      const base::android::JavaParamRef<jobject>& jcaller) const;\n\n  base::android::ScopedJavaLocalRef<jobjectArray> GetDirectActions(\n      JNIEnv* env,\n      const base::android::JavaParamRef<jobject>& jcaller);\n\n  bool PerformDirectAction(\n      JNIEnv* env,\n      const base::android::JavaParamRef<jobject>& jcaller,\n      const base::android::JavaParamRef<jstring>& jaction_id,\n      const base::android::JavaParamRef<jstring>& jexperiment_ids,\n      const base::android::JavaParamRef<jobjectArray>& jargument_names,\n      const base::android::JavaParamRef<jobjectArray>& jargument_values,\n      const base::android::JavaParamRef<jobject>& jonboarding_coordinator);\n\n  // Overrides Client\n  void AttachUI() override;\n  void DestroyUI() override;\n  version_info::Channel GetChannel() const override;\n  std::string GetEmailAddressForAccessTokenAccount() const override;\n  std::string GetChromeSignedInEmailAddress() const override;\n  AccessTokenFetcher* GetAccessTokenFetcher() override;\n  autofill::PersonalDataManager* GetPersonalDataManager() const override;\n  password_manager::PasswordManagerClient* GetPasswordManagerClient()\n      const override;\n  WebsiteLoginManager* GetWebsiteLoginManager() const override;\n  std::string GetLocale() const override;\n  std::string GetCountryCode() const override;\n  DeviceContext GetDeviceContext() const override;\n  bool IsAccessibilityEnabled() const override;\n  content::WebContents* GetWebContents() const override;\n  void Shutdown(Metrics::DropOutReason reason) override;\n  void RecordDropOut(Metrics::DropOutReason reason) override;\n  bool HasHadUI() const override;\n\n  // Overrides AccessTokenFetcher\n  void FetchAccessToken(\n      base::OnceCallback<void(bool, const std::string&)>) override;\n  void InvalidateAccessToken(const std::string& access_token) override;\n\n private:\n  friend class content::WebContentsUserData<ClientAndroid>;\n\n  explicit ClientAndroid(content::WebContents* web_contents);\n  void CreateController(std::unique_ptr<Service> service);\n  void DestroyController();\n  void AttachUI(\n      const base::android::JavaParamRef<jobject>& jonboarding_coordinator);\n  bool NeedsUI();\n  void OnFetchWebsiteActions(const base::android::JavaRef<jobject>& jcallback);\n\n  base::android::ScopedJavaLocalRef<jobjectArray>\n  GetDirectActionsAsJavaArrayOfStrings(JNIEnv* env) const;\n\n  base::android::ScopedJavaLocalRef<jobject>\n  ToJavaAutofillAssistantDirectAction(JNIEnv* env,\n                                      const DirectAction& direct_action) const;\n\n  // Returns the index of a direct action with that name, to pass to\n  // UiDelegate::PerformUserAction() or -1 if not found.\n  int FindDirectAction(const std::string& action_name);\n\n  WEB_CONTENTS_USER_DATA_KEY_DECL();\n\n  content::WebContents* web_contents_;\n  // Once initialized, the |password_manager_client_| is available while\n  // |web_contents_| is available.\n  mutable password_manager::PasswordManagerClient* password_manager_client_ =\n      nullptr;\n\n  base::android::ScopedJavaGlobalRef<jobject> java_object_;\n  std::unique_ptr<Controller> controller_;\n  mutable std::unique_ptr<WebsiteLoginManager> website_login_manager_;\n\n  // True if Start() was called. This turns on the tracking of dropouts.\n  bool started_ = false;\n\n  // True if the UI was ever attached.\n  bool has_had_ui_ = false;\n\n  std::unique_ptr<UiControllerAndroid> ui_controller_android_;\n\n  base::OnceCallback<void(bool, const std::string&)>\n      fetch_access_token_callback_;\n\n  base::WeakPtrFactory<ClientAndroid> weak_ptr_factory_{this};\n\n  DISALLOW_COPY_AND_ASSIGN(ClientAndroid);\n};\n\n}  // namespace autofill_assistant.\n#endif  // CHROME_BROWSER_ANDROID_AUTOFILL_ASSISTANT_CLIENT_ANDROID_H_\n\n", "comment_ratio": 0.13218390804597702}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n#import \"FlickrPhoto.h\"\n\n@interface FlickrDataSource : NSObject\n\n+ (void)retrieveFlickrPhotosWithSearchTerm:(NSString * _Nonnull)searchTerm withCompletionHandler:(void (^ _Nonnull)(NSArray * _Nullable array, NSError * _Nullable error))completion;\n\n+ (void)retrieveInfosForFlickrPhoto:(FlickrPhoto * _Nonnull)flickrPhoto withCompletionHandler:(void (^ _Nullable)(FlickrPhoto * _Nullable flickrPhoto, NSError * _Nullable error))completion;\n\n+ (void)retrieveExifForFlickrPhoto:(FlickrPhoto * _Nonnull)flickrPhoto withCompletionHandler:(void (^ _Nonnull)(NSDictionary * _Nullable dictionary, NSError * _Nullable error))completion;\n\n+ (void)retrieveFlickrPhotosWithLat:(double)lat andLon:(double)lon withCompletionHandler:(void (^ _Nonnull)(NSArray * _Nullable array, NSError * _Nullable error))completion;\n\n+ (void)downloadFlickrPhotoImage:(FlickrPhoto * _Nonnull) flickrPhoto WithCompletion:(void (^ _Nonnull)(BOOL succeeded, UIImage * _Nullable image))completionBlock;\n\n@end\n\n", "comment_ratio": 0.28}
{"lang": "c", "code": "#ifndef MCRL2_PROCESS_DETAIL_PROCESS_COMMAND_H\n#define MCRL2_PROCESS_DETAIL_PROCESS_COMMAND_H\n\n#include \"mcrl2/data/rewriter.h\"\n#include \"mcrl2/process/parse.h\"\n#include \"mcrl2/process/detail/process_io.h\"\n#include \"mcrl2/utilities/detail/command.h\"\n\nnamespace mcrl2 {\n\nnamespace process {\n\nnamespace detail {\n\nstruct process_command: public utilities::detail::command\n{\n  process::process_specification procspec;\n\n  process_command(const std::string& name,\n                  const std::string& input_filename,\n                  const std::string& output_filename,\n                  const std::vector<std::string>& options\n                 )\n    : utilities::detail::command(name, input_filename, output_filename, options)\n  {}\n\n  void execute()\n  {\n    procspec = detail::parse_process_specification(input_filename);\n  }\n};\n\n/// \\brief Process command that uses a rewrite strategy\nstruct process_rewriter_command: public process_command\n{\n  data::rewrite_strategy strategy;\n\n  process_rewriter_command(const std::string& name,\n                           const std::string& input_filename,\n                           const std::string& output_filename,\n                           const std::vector<std::string>& options,\n                           data::rewrite_strategy strategy_\n                          )\n    : process_command(name, input_filename, output_filename, options),\n      strategy(strategy_)\n  {}\n};\n\n} // namespace detail\n\n} // namespace process\n\n} // namespace mcrl2\n\n#endif // MCRL2_PROCESS_DETAIL_PROCESS_COMMAND_H\n\n", "comment_ratio": 0.22388059701492538}
{"lang": "c", "code": "#ifndef MAIN_H\n#define MAIN_H\n\n#include \"mGeneral.h\"\n#include \"mBus.h\"\n#include \"mUSB.h\"\n#include \"m_microsd.h\"\n#include <stdbool.h>\n#include <stdio.h>\n\n// fatal_error indicates whether there was an error so\n// bad that we should reset the SD card\nextern bool fatal_error;\n\n// ls.c:\nvoid ls (void);  // lists directory entries\n\n// printFile.c:\nvoid printFile (const char *fileName);  // prints the contents of a file\n\n// write.c:\nvoid writeToFile  (const char *fileName,\n                   open_option writeMode,\n                   uint32_t dataLength,\n                   uint8_t *data);  // write or append text to a file\n\n// edit.c:\nvoid edit (uint8_t file_id, const char *name);  // open the text editor for this file\n\n// keycodes.c:\nvoid keycodes (void);  // print the ASCII code of the pressed key\n\n#endif\n\n\n", "comment_ratio": 0.34285714285714286}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n@class HDBaseTableViewDataSource,HDTableViewMaker;\n@interface UITableView (HDTableViewMaker)\n\n@property(nonatomic, strong) HDBaseTableViewDataSource * hdTableViewDataSource;\n\n@property (nonatomic,strong) NSMutableDictionary *tableViewRegisterCell;\n\n\n- (UITableView *)hd_tableViewMaker:(void (^)(HDTableViewMaker * tableMaker))tableViewMaker;\n\n\n@end\n\n__attribute__((unused)) static void commitEditing(id self, SEL cmd, UITableView * tableView, UITableViewCellEditingStyle editingStyle, NSIndexPath * indexPath);\n\n__attribute__((unused)) static void scrollViewDidScroll(id self, SEL cmd, UIScrollView * scrollView);\n\n__attribute__((unused)) static void cellWillDisplay(id self, SEL cmd, UITableView *tableView,UITableViewCell *willDisplayCell,NSIndexPath *indexPath);\n\n\n", "comment_ratio": 0.2413793103448276}
{"lang": "c", "code": "#pragma once\n\n#include <stdint.h>\n\nstruct MulStaticTile2;\n\nstruct CObjectOnCursor\n{\n    MulStaticTile2 *TiledataPtr = nullptr;\n    uint32_t Serial = 0;\n    uint32_t Container = 0;\n    uint16_t Graphic = 0;\n    uint16_t Color = 0;\n    uint16_t Count = 0;\n    uint16_t TotalCount = 0;\n    uint16_t X = 0;\n    uint16_t Y = 0;\n    int8_t Z = 0;\n    uint8_t Layer = 0;\n    uint8_t Flags = 0;\n    bool IsGameFigure = false;\n    bool UpdatedInWorld = false;\n    bool Enabled = false;\n    bool Dropped = false;\n\n    void Clear();\n    uint16_t GetDrawGraphic(bool &doubleDraw);\n};\n\nextern CObjectOnCursor g_ObjectInHand;\n\n", "comment_ratio": 0.1111111111111111}
{"lang": "c", "code": "#if !defined(AFX_DEVICEDLG_H__D50B20D8_564E_4F71_B23C_8D413C17F79D__INCLUDED_)\n#define AFX_DEVICEDLG_H__D50B20D8_564E_4F71_B23C_8D413C17F79D__INCLUDED_\n\n#if _MSC_VER > 1000\n#pragma once\n#endif // _MSC_VER > 1000\n// DeviceDlg.h : header file\n//\n\n/////////////////////////////////////////////////////////////////////////////\n// CDeviceDlg dialog\n\nclass CDeviceDlg : public CDialog\n{\n// Construction\npublic:\n\tCDeviceDlg(CWnd* pParent = NULL);   // standard constructor\n\n    LONG m_lServerID;\n\tint  m_iDeviceIndex;\n    BOOL GetDeviceParam();\n    NET_DVR_NETCFG_V30 m_NetCfg;\n    NET_DVR_DEVICECFG m_DeviceCfg;\n// Dialog Data\n\t//{{AFX_DATA(CDeviceDlg)\n\tenum { IDD = IDD_DLG_SPLITTER_DEVICE_CFG };\n\tCComboBox\tm_NetFaceCtrl;\n\tCString\tm_strDeviceIp;\n\tCString\tm_strDeviceName;\n\tCString\tm_strDspSoftwareVersion;\n\tCString\tm_strGateWayIp;\n\tDWORD\tm_dwHttpPort;\n\tCString\tm_strMaskIp;\n\tDWORD\tm_dwMainPort;\n\tCString\tm_strSerial;\n\tCString\tm_strSoftwareVersion;\n\tCString\tm_strMacIp;\n\t//}}AFX_DATA\n\n\n// Overrides\n\t// ClassWizard generated virtual function overrides\n\t//{{AFX_VIRTUAL(CDeviceDlg)\n\tprotected:\n\tvirtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support\n\t//}}AFX_VIRTUAL\n\n// Implementation\nprotected:\n\n\t// Generated message map functions\n\t//{{AFX_MSG(CDeviceDlg)\n\tafx_msg void OnBtnSave();\n\t//}}AFX_MSG\n\tDECLARE_MESSAGE_MAP()\n};\n\n//{{AFX_INSERT_LOCATION}}\n// Microsoft Visual C++ will insert additional declarations immediately before the previous line.\n\n#endif // !defined(AFX_DEVICEDLG_H__D50B20D8_564E_4F71_B23C_8D413C17F79D__INCLUDED_)\n\n", "comment_ratio": 0.3548387096774194}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n#import \"Singleton.h\"\n#import \"TdLocationCallback.h\"\n#import \"ApiCallBack.h\"\n#import \"TdEventBean.h\"\n#import \"ApiCallBackForOpenMessage.h\"\n#import \"JXMutableArray.h\"\n#import \"TongDao.h\"\n@interface TdService : NSObject<TdLocationCallback,ApiCallBack,ApiCallBackForOpenMessage>\nsingleton_interface(TdService)\n\n@property(atomic)NSArray* failTrackList;\n@property(atomic,assign)BOOL isFailed;\n@property(atomic,assign)TongDaoinitData ignoreInfor;\n\n-(void)sendInitialData;\n\n-(void)sendInitialDataAndIgnore:(TongDaoinitData)ingnoreInfor;\n\n-(void)sendTrackEvent:(TdEventBean*)tdEventBean;\n\n-(void)sendOpenMessageTrackEvent:(TdEventBean*)tdEventBean;\n@end\n\n", "comment_ratio": 0.21875}
{"lang": "c", "code": "#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include \"ezsigntemplatesignature_response_compound.h\"\n\n\nchar* e_ezsigntemplatesignature_typeezsigntemplatesignature_response_compound_ToString(ezmax_api_definition__full_ezsigntemplatesignature_response_compound__e e_ezsigntemplatesignature_type) {\n    char* e_ezsigntemplatesignature_typeArray[] =  { \"NULL\", \"Acknowledgement\", \"City\", \"Handwritten\", \"Initials\", \"Name\" };\n\treturn e_ezsigntemplatesignature_typeArray[e_ezsigntemplatesignature_type];\n}\n\nezmax_api_definition__full_ezsigntemplatesignature_response_compound__e e_ezsigntemplatesignature_typeezsigntemplatesignature_response_compound_FromString(char* e_ezsigntemplatesignature_type){\n    int stringToReturn = 0;\n    char *e_ezsigntemplatesignature_typeArray[] =  { \"NULL\", \"Acknowledgement\", \"City\", \"Handwritten\", \"Initials\", \"Name\" };\n    size_t sizeofArray = sizeof(e_ezsigntemplatesignature_typeArray) / sizeof(e_ezsigntemplatesignature_typeArray[0]);\n    while(stringToReturn < sizeofArray) {\n        if(strcmp(e_ezsigntemplatesignature_type, e_ezsigntemplatesignature_typeArray[stringToReturn]) == 0) {\n            return stringToReturn;\n        }\n        stringToReturn++;\n    }\n    return 0;\n}\nchar* e_ezsigntemplatesignature_tooltippositionezsigntemplatesignature_response_compound_ToString(ezmax_api_definition__full_ezsigntemplatesignature_response_compound__e e_ezsigntemplatesignature_tooltipposition) {\n    char* e_ezsigntemplatesignature_tooltippositionArray[] =  { \"NULL\", \"TopLeft\", \"TopCenter\", \"TopRight\", \"MiddleLeft\", \"MiddleRight\", \"BottomLeft\", \"BottomCenter\", \"BottomRight\" };\n\treturn e_ezsigntemplatesignature_tooltippositionArray[e_ezsigntemplatesignature_tooltipposition];\n}\n\nezmax_api_definition__full_ezsigntemplatesignature_response_compound__e e_ezsigntemplatesignature_tooltippositionezsigntemplatesignature_response_compound_FromString(char* e_ezsigntemplatesignature_tooltipposition){\n    int stringToReturn = 0;\n    char *e_ezsigntemplatesignature_tooltippositionArray[] =  { \"NULL\", \"TopLeft\", \"TopCenter\", \"TopRight\", \"MiddleLeft\", \"MiddleRight\", \"BottomLeft\", \"BottomCenter\", \"BottomRight\" };\n    size_t sizeofArray = sizeof(e_ezsigntemplatesignature_tooltippositionArray) / sizeof(e_ezsigntemplatesignature_tooltippositionArray[0]);\n    while(stringToReturn < sizeofArray) {\n        if(strcmp(e_ezsigntemplatesignature_tooltipposition, e_ezsigntemplatesignature_tooltippositionArray[stringToReturn]) == 0) {\n            return stringToReturn;\n        }\n        stringToReturn++;\n    }\n    return 0;\n}\nchar* e_ezsigntemplatesignature_fontezsigntemplatesignature_response_compound_ToString(ezmax_api_definition__full_ezsigntemplatesignature_response_compound__e e_ezsigntemplatesignature_font) {\n    char* e_ezsigntemplatesignature_fontArray[] =  { \"NULL\", \"Normal\", \"Cursive\" };\n\treturn e_ezsigntemplatesignature_fontArray[e_ezsigntemplatesignature_font];\n}\n\nezmax_api_definition__full_ezsigntemplatesignature_response_compound__e e_ezsigntemplatesignature_fontezsigntemplatesignature_response_compound_FromString(char* e_ezsigntemplatesignature_font){\n    int stringToReturn = 0;\n    char *e_ezsigntemplatesignature_fontArray[] =  { \"NULL\", \"Normal\", \"Cursive\" };\n    size_t sizeofArray = sizeof(e_ezsigntemplatesignature_fontArray) / sizeof(e_ezsigntemplatesignature_fontArray[0]);\n    while(stringToReturn < sizeofArray) {\n        if(strcmp(e_ezsigntemplatesignature_font, e_ezsigntemplatesignature_fontArray[stringToReturn]) == 0) {\n            return stringToReturn;\n        }\n        stringToReturn++;\n    }\n    return 0;\n}\n\nezsigntemplatesignature_response_compound_t *ezsigntemplatesignature_response_compound_create(\n    int pki_ezsigntemplatesignature_id,\n    int fki_ezsigntemplatedocument_id,\n    int fki_ezsigntemplatesigner_id,\n    int i_ezsigntemplatedocumentpage_pagenumber,\n    int i_ezsigntemplatesignature_x,\n    int i_ezsigntemplatesignature_y,\n    int i_ezsigntemplatesignature_step,\n    field_e_ezsigntemplatesignature_type_t *e_ezsigntemplatesignature_type,\n    char *t_ezsigntemplatesignature_tooltip,\n    field_e_ezsigntemplatesignature_tooltipposition_t *e_ezsigntemplatesignature_tooltipposition,\n    field_e_ezsigntemplatesignature_font_t *e_ezsigntemplatesignature_font,\n    int b_ezsigntemplatesignature_customdate,\n    list_t *a_obj_ezsigntemplatesignaturecustomdate\n    ) {\n    ezsigntemplatesignature_response_compound_t *ezsigntemplatesignature_response_compound_local_var = malloc(sizeof(ezsigntemplatesignature_response_compound_t));\n    if (!ezsigntemplatesignature_response_compound_local_var) {\n        return NULL;\n    }\n    ezsigntemplatesignature_response_compound_local_var->pki_ezsigntemplatesignature_id = pki_ezsigntemplatesignature_id;\n    ezsigntemplatesignature_response_compound_local_var->fki_ezsigntemplatedocument_id = fki_ezsigntemplatedocument_id;\n    ezsigntemplatesignature_response_compound_local_var->fki_ezsigntemplatesigner_id = fki_ezsigntemplatesigner_id;\n    ezsigntemplatesignature_response_compound_local_var->i_ezsigntemplatedocumentpage_pagenumber = i_ezsigntemplatedocumentpage_pagenumber;\n    ezsigntemplatesignature_response_compound_local_var->i_ezsigntemplatesignature_x = i_ezsigntemplatesignature_x;\n    ezsigntemplatesignature_response_compound_local_var->i_ezsigntemplatesignature_y = i_ezsigntemplatesignature_y;\n    ezsigntemplatesignature_response_compound_local_var->i_ezsigntemplatesignature_step = i_ezsigntemplatesignature_step;\n    ezsigntemplatesignature_response_compound_local_var->e_ezsigntemplatesignature_type = e_ezsigntemplatesignature_type;\n    ezsigntemplatesignature_response_compound_local_var->t_ezsigntemplatesignature_tooltip = t_ezsigntemplatesignature_tooltip;\n    ezsigntemplatesignature_response_compound_local_var->e_ezsigntemplatesignature_tooltipposition = e_ezsigntemplatesignature_tooltipposition;\n    ezsigntemplatesignature_response_compound_local_var->e_ezsigntemplatesignature_font = e_ezsigntemplatesignature_font;\n    ezsigntemplatesignature_response_compound_local_var->b_ezsigntemplatesignature_customdate = b_ezsigntemplatesignature_customdate;\n    ezsigntemplatesignature_response_compound_local_var->a_obj_ezsigntemplatesignaturecustomdate = a_obj_ezsigntemplatesignaturecustomdate;\n\n    return ezsigntemplatesignature_response_compound_local_var;\n}\n\n\nvoid ezsigntemplatesignature_response_compound_free(ezsigntemplatesignature_response_compound_t *ezsigntemplatesignature_response_compound) {\n    if(NULL == ezsigntemplatesignature_response_compound){\n        return ;\n    }\n    listEntry_t *listEntry;\n    if (ezsigntemplatesignature_response_compound->e_ezsigntemplatesignature_type) {\n        field_e_ezsigntemplatesignature_type_free(ezsigntemplatesignature_response_compound->e_ezsigntemplatesignature_type);\n        ezsigntemplatesignature_response_compound->e_ezsigntemplatesignature_type = NULL;\n    }\n    if (ezsigntemplatesignature_response_compound->t_ezsigntemplatesignature_tooltip) {\n        free(ezsigntemplatesignature_response_compound->t_ezsigntemplatesignature_tooltip);\n        ezsigntemplatesignature_response_compound->t_ezsigntemplatesignature_tooltip = NULL;\n    }\n    if (ezsigntemplatesignature_response_compound->e_ezsigntemplatesignature_tooltipposition) {\n        field_e_ezsigntemplatesignature_tooltipposition_free(ezsigntemplatesignature_response_compound->e_ezsigntemplatesignature_tooltipposition);\n        ezsigntemplatesignature_response_compound->e_ezsigntemplatesignature_tooltipposition = NULL;\n    }\n    if (ezsigntemplatesignature_response_compound->e_ezsigntemplatesignature_font) {\n        field_e_ezsigntemplatesignature_font_free(ezsigntemplatesignature_response_compound->e_ezsigntemplatesignature_font);\n        ezsigntemplatesignature_response_compound->e_ezsigntemplatesignature_font = NULL;\n    }\n    if (ezsigntemplatesignature_response_compound->a_obj_ezsigntemplatesignaturecustomdate) {\n        list_ForEach(listEntry, ezsigntemplatesignature_response_compound->a_obj_ezsigntemplatesignaturecustomdate) {\n            ezsigntemplatesignaturecustomdate_response_compound_free(listEntry->data);\n        }\n        list_freeList(ezsigntemplatesignature_response_compound->a_obj_ezsigntemplatesignaturecustomdate);\n        ezsigntemplatesignature_response_compound->a_obj_ezsigntemplatesignaturecustomdate = NULL;\n    }\n    free(ezsigntemplatesignature_response_compound);\n}\n\ncJSON *ezsigntemplatesignature_response_compound_convertToJSON(ezsigntemplatesignature_response_compound_t *ezsigntemplatesignature_response_compound) {\n    cJSON *item = cJSON_CreateObject();\n\n    // ezsigntemplatesignature_response_compound->pki_ezsigntemplatesignature_id\n    if (!ezsigntemplatesignature_response_compound->pki_ezsigntemplatesignature_id) {\n        goto fail;\n    }\n    if(cJSON_AddNumberToObject(item, \"pkiEzsigntemplatesignatureID\", ezsigntemplatesignature_response_compound->pki_ezsigntemplatesignature_id) == NULL) {\n    goto fail; //Numeric\n    }\n\n\n    // ezsigntemplatesignature_response_compound->fki_ezsigntemplatedocument_id\n    if (!ezsigntemplatesignature_response_compound->fki_ezsigntemplatedocument_id) {\n        goto fail;\n    }\n    if(cJSON_AddNumberToObject(item, \"fkiEzsigntemplatedocumentID\", ezsigntemplatesignature_response_compound->fki_ezsigntemplatedocument_id) == NULL) {\n    goto fail; //Numeric\n    }\n\n\n    // ezsigntemplatesignature_response_compound->fki_ezsigntemplatesigner_id\n    if (!ezsigntemplatesignature_response_compound->fki_ezsigntemplatesigner_id) {\n        goto fail;\n    }\n    if(cJSON_AddNumberToObject(item, \"fkiEzsigntemplatesignerID\", ezsigntemplatesignature_response_compound->fki_ezsigntemplatesigner_id) == NULL) {\n    goto fail; //Numeric\n    }\n\n\n    // ezsigntemplatesignature_response_compound->i_ezsigntemplatedocumentpage_pagenumber\n    if (!ezsigntemplatesignature_response_compound->i_ezsigntemplatedocumentpage_pagenumber) {\n        goto fail;\n    }\n    if(cJSON_AddNumberToObject(item, \"iEzsigntemplatedocumentpagePagenumber\", ezsigntemplatesignature_response_compound->i_ezsigntemplatedocumentpage_pagenumber) == NULL) {\n    goto fail; //Numeric\n    }\n\n\n    // ezsigntemplatesignature_response_compound->i_ezsigntemplatesignature_x\n    if (!ezsigntemplatesignature_response_compound->i_ezsigntemplatesignature_x) {\n        goto fail;\n    }\n    if(cJSON_AddNumberToObject(item, \"iEzsigntemplatesignatureX\", ezsigntemplatesignature_response_compound->i_ezsigntemplatesignature_x) == NULL) {\n    goto fail; //Numeric\n    }\n\n\n    // ezsigntemplatesignature_response_compound->i_ezsigntemplatesignature_y\n    if (!ezsigntemplatesignature_response_compound->i_ezsigntemplatesignature_y) {\n        goto fail;\n    }\n    if(cJSON_AddNumberToObject(item, \"iEzsigntemplatesignatureY\", ezsigntemplatesignature_response_compound->i_ezsigntemplatesignature_y) == NULL) {\n    goto fail; //Numeric\n    }\n\n\n    // ezsigntemplatesignature_response_compound->i_ezsigntemplatesignature_step\n    if (!ezsigntemplatesignature_response_compound->i_ezsigntemplatesignature_step) {\n        goto fail;\n    }\n    if(cJSON_AddNumberToObject(item, \"iEzsigntemplatesignatureStep\", ezsigntemplatesignature_response_compound->i_ezsigntemplatesignature_step) == NULL) {\n    goto fail; //Numeric\n    }\n\n\n    // ezsigntemplatesignature_response_compound->e_ezsigntemplatesignature_type\n    if (ezmax_api_definition__full_ezsigntemplatesignature_response_compound__NULL == ezsigntemplatesignature_response_compound->e_ezsigntemplatesignature_type) {\n        goto fail;\n    }\n    cJSON *e_ezsigntemplatesignature_type_local_JSON = field_e_ezsigntemplatesignature_type_convertToJSON(ezsigntemplatesignature_response_compound->e_ezsigntemplatesignature_type);\n    if(e_ezsigntemplatesignature_type_local_JSON == NULL) {\n        goto fail; // custom\n    }\n    cJSON_AddItemToObject(item, \"eEzsigntemplatesignatureType\", e_ezsigntemplatesignature_type_local_JSON);\n    if(item->child == NULL) {\n        goto fail;\n    }\n\n\n    // ezsigntemplatesignature_response_compound->t_ezsigntemplatesignature_tooltip\n    if(ezsigntemplatesignature_response_compound->t_ezsigntemplatesignature_tooltip) {\n    if(cJSON_AddStringToObject(item, \"tEzsigntemplatesignatureTooltip\", ezsigntemplatesignature_response_compound->t_ezsigntemplatesignature_tooltip) == NULL) {\n    goto fail; //String\n    }\n    }\n\n\n    // ezsigntemplatesignature_response_compound->e_ezsigntemplatesignature_tooltipposition\n    if(ezsigntemplatesignature_response_compound->e_ezsigntemplatesignature_tooltipposition != ezmax_api_definition__full_ezsigntemplatesignature_response_compound__NULL) {\n    cJSON *e_ezsigntemplatesignature_tooltipposition_local_JSON = field_e_ezsigntemplatesignature_tooltipposition_convertToJSON(ezsigntemplatesignature_response_compound->e_ezsigntemplatesignature_tooltipposition);\n    if(e_ezsigntemplatesignature_tooltipposition_local_JSON == NULL) {\n        goto fail; // custom\n    }\n    cJSON_AddItemToObject(item, \"eEzsigntemplatesignatureTooltipposition\", e_ezsigntemplatesignature_tooltipposition_local_JSON);\n    if(item->child == NULL) {\n        goto fail;\n    }\n    }\n\n\n    // ezsigntemplatesignature_response_compound->e_ezsigntemplatesignature_font\n    if(ezsigntemplatesignature_response_compound->e_ezsigntemplatesignature_font != ezmax_api_definition__full_ezsigntemplatesignature_response_compound__NULL) {\n    cJSON *e_ezsigntemplatesignature_font_local_JSON = field_e_ezsigntemplatesignature_font_convertToJSON(ezsigntemplatesignature_response_compound->e_ezsigntemplatesignature_font);\n    if(e_ezsigntemplatesignature_font_local_JSON == NULL) {\n        goto fail; // custom\n    }\n    cJSON_AddItemToObject(item, \"eEzsigntemplatesignatureFont\", e_ezsigntemplatesignature_font_local_JSON);\n    if(item->child == NULL) {\n        goto fail;\n    }\n    }\n\n\n    // ezsigntemplatesignature_response_compound->b_ezsigntemplatesignature_customdate\n    if(ezsigntemplatesignature_response_compound->b_ezsigntemplatesignature_customdate) {\n    if(cJSON_AddBoolToObject(item, \"bEzsigntemplatesignatureCustomdate\", ezsigntemplatesignature_response_compound->b_ezsigntemplatesignature_customdate) == NULL) {\n    goto fail; //Bool\n    }\n    }\n\n\n    // ezsigntemplatesignature_response_compound->a_obj_ezsigntemplatesignaturecustomdate\n    if(ezsigntemplatesignature_response_compound->a_obj_ezsigntemplatesignaturecustomdate) {\n    cJSON *a_obj_ezsigntemplatesignaturecustomdate = cJSON_AddArrayToObject(item, \"a_objEzsigntemplatesignaturecustomdate\");\n    if(a_obj_ezsigntemplatesignaturecustomdate == NULL) {\n    goto fail; //nonprimitive container\n    }\n\n    listEntry_t *a_obj_ezsigntemplatesignaturecustomdateListEntry;\n    if (ezsigntemplatesignature_response_compound->a_obj_ezsigntemplatesignaturecustomdate) {\n    list_ForEach(a_obj_ezsigntemplatesignaturecustomdateListEntry, ezsigntemplatesignature_response_compound->a_obj_ezsigntemplatesignaturecustomdate) {\n    cJSON *itemLocal = ezsigntemplatesignaturecustomdate_response_compound_convertToJSON(a_obj_ezsigntemplatesignaturecustomdateListEntry->data);\n    if(itemLocal == NULL) {\n    goto fail;\n    }\n    cJSON_AddItemToArray(a_obj_ezsigntemplatesignaturecustomdate, itemLocal);\n    }\n    }\n    }\n\n    return item;\nfail:\n    if (item) {\n        cJSON_Delete(item);\n    }\n    return NULL;\n}\n\nezsigntemplatesignature_response_compound_t *ezsigntemplatesignature_response_compound_parseFromJSON(cJSON *ezsigntemplatesignature_response_compoundJSON){\n\n    ezsigntemplatesignature_response_compound_t *ezsigntemplatesignature_response_compound_local_var = NULL;\n\n    // define the local variable for ezsigntemplatesignature_response_compound->e_ezsigntemplatesignature_type\n    field_e_ezsigntemplatesignature_type_t *e_ezsigntemplatesignature_type_local_nonprim = NULL;\n\n    // define the local variable for ezsigntemplatesignature_response_compound->e_ezsigntemplatesignature_tooltipposition\n    field_e_ezsigntemplatesignature_tooltipposition_t *e_ezsigntemplatesignature_tooltipposition_local_nonprim = NULL;\n\n    // define the local variable for ezsigntemplatesignature_response_compound->e_ezsigntemplatesignature_font\n    field_e_ezsigntemplatesignature_font_t *e_ezsigntemplatesignature_font_local_nonprim = NULL;\n\n    // define the local list for ezsigntemplatesignature_response_compound->a_obj_ezsigntemplatesignaturecustomdate\n    list_t *a_obj_ezsigntemplatesignaturecustomdateList = NULL;\n\n    // ezsigntemplatesignature_response_compound->pki_ezsigntemplatesignature_id\n    cJSON *pki_ezsigntemplatesignature_id = cJSON_GetObjectItemCaseSensitive(ezsigntemplatesignature_response_compoundJSON, \"pkiEzsigntemplatesignatureID\");\n    if (!pki_ezsigntemplatesignature_id) {\n        goto end;\n    }\n\n    \n    if(!cJSON_IsNumber(pki_ezsigntemplatesignature_id))\n    {\n    goto end; //Numeric\n    }\n\n    // ezsigntemplatesignature_response_compound->fki_ezsigntemplatedocument_id\n    cJSON *fki_ezsigntemplatedocument_id = cJSON_GetObjectItemCaseSensitive(ezsigntemplatesignature_response_compoundJSON, \"fkiEzsigntemplatedocumentID\");\n    if (!fki_ezsigntemplatedocument_id) {\n        goto end;\n    }\n\n    \n    if(!cJSON_IsNumber(fki_ezsigntemplatedocument_id))\n    {\n    goto end; //Numeric\n    }\n\n    // ezsigntemplatesignature_response_compound->fki_ezsigntemplatesigner_id\n    cJSON *fki_ezsigntemplatesigner_id = cJSON_GetObjectItemCaseSensitive(ezsigntemplatesignature_response_compoundJSON, \"fkiEzsigntemplatesignerID\");\n    if (!fki_ezsigntemplatesigner_id) {\n        goto end;\n    }\n\n    \n    if(!cJSON_IsNumber(fki_ezsigntemplatesigner_id))\n    {\n    goto end; //Numeric\n    }\n\n    // ezsigntemplatesignature_response_compound->i_ezsigntemplatedocumentpage_pagenumber\n    cJSON *i_ezsigntemplatedocumentpage_pagenumber = cJSON_GetObjectItemCaseSensitive(ezsigntemplatesignature_response_compoundJSON, \"iEzsigntemplatedocumentpagePagenumber\");\n    if (!i_ezsigntemplatedocumentpage_pagenumber) {\n        goto end;\n    }\n\n    \n    if(!cJSON_IsNumber(i_ezsigntemplatedocumentpage_pagenumber))\n    {\n    goto end; //Numeric\n    }\n\n    // ezsigntemplatesignature_response_compound->i_ezsigntemplatesignature_x\n    cJSON *i_ezsigntemplatesignature_x = cJSON_GetObjectItemCaseSensitive(ezsigntemplatesignature_response_compoundJSON, \"iEzsigntemplatesignatureX\");\n    if (!i_ezsigntemplatesignature_x) {\n        goto end;\n    }\n\n    \n    if(!cJSON_IsNumber(i_ezsigntemplatesignature_x))\n    {\n    goto end; //Numeric\n    }\n\n    // ezsigntemplatesignature_response_compound->i_ezsigntemplatesignature_y\n    cJSON *i_ezsigntemplatesignature_y = cJSON_GetObjectItemCaseSensitive(ezsigntemplatesignature_response_compoundJSON, \"iEzsigntemplatesignatureY\");\n    if (!i_ezsigntemplatesignature_y) {\n        goto end;\n    }\n\n    \n    if(!cJSON_IsNumber(i_ezsigntemplatesignature_y))\n    {\n    goto end; //Numeric\n    }\n\n    // ezsigntemplatesignature_response_compound->i_ezsigntemplatesignature_step\n    cJSON *i_ezsigntemplatesignature_step = cJSON_GetObjectItemCaseSensitive(ezsigntemplatesignature_response_compoundJSON, \"iEzsigntemplatesignatureStep\");\n    if (!i_ezsigntemplatesignature_step) {\n        goto end;\n    }\n\n    \n    if(!cJSON_IsNumber(i_ezsigntemplatesignature_step))\n    {\n    goto end; //Numeric\n    }\n\n    // ezsigntemplatesignature_response_compound->e_ezsigntemplatesignature_type\n    cJSON *e_ezsigntemplatesignature_type = cJSON_GetObjectItemCaseSensitive(ezsigntemplatesignature_response_compoundJSON, \"eEzsigntemplatesignatureType\");\n    if (!e_ezsigntemplatesignature_type) {\n        goto end;\n    }\n\n    \n    e_ezsigntemplatesignature_type_local_nonprim = field_e_ezsigntemplatesignature_type_parseFromJSON(e_ezsigntemplatesignature_type); //custom\n\n    // ezsigntemplatesignature_response_compound->t_ezsigntemplatesignature_tooltip\n    cJSON *t_ezsigntemplatesignature_tooltip = cJSON_GetObjectItemCaseSensitive(ezsigntemplatesignature_response_compoundJSON, \"tEzsigntemplatesignatureTooltip\");\n    if (t_ezsigntemplatesignature_tooltip) { \n    if(!cJSON_IsString(t_ezsigntemplatesignature_tooltip))\n    {\n    goto end; //String\n    }\n    }\n\n    // ezsigntemplatesignature_response_compound->e_ezsigntemplatesignature_tooltipposition\n    cJSON *e_ezsigntemplatesignature_tooltipposition = cJSON_GetObjectItemCaseSensitive(ezsigntemplatesignature_response_compoundJSON, \"eEzsigntemplatesignatureTooltipposition\");\n    if (e_ezsigntemplatesignature_tooltipposition) { \n    e_ezsigntemplatesignature_tooltipposition_local_nonprim = field_e_ezsigntemplatesignature_tooltipposition_parseFromJSON(e_ezsigntemplatesignature_tooltipposition); //custom\n    }\n\n    // ezsigntemplatesignature_response_compound->e_ezsigntemplatesignature_font\n    cJSON *e_ezsigntemplatesignature_font = cJSON_GetObjectItemCaseSensitive(ezsigntemplatesignature_response_compoundJSON, \"eEzsigntemplatesignatureFont\");\n    if (e_ezsigntemplatesignature_font) { \n    e_ezsigntemplatesignature_font_local_nonprim = field_e_ezsigntemplatesignature_font_parseFromJSON(e_ezsigntemplatesignature_font); //custom\n    }\n\n    // ezsigntemplatesignature_response_compound->b_ezsigntemplatesignature_customdate\n    cJSON *b_ezsigntemplatesignature_customdate = cJSON_GetObjectItemCaseSensitive(ezsigntemplatesignature_response_compoundJSON, \"bEzsigntemplatesignatureCustomdate\");\n    if (b_ezsigntemplatesignature_customdate) { \n    if(!cJSON_IsBool(b_ezsigntemplatesignature_customdate))\n    {\n    goto end; //Bool\n    }\n    }\n\n    // ezsigntemplatesignature_response_compound->a_obj_ezsigntemplatesignaturecustomdate\n    cJSON *a_obj_ezsigntemplatesignaturecustomdate = cJSON_GetObjectItemCaseSensitive(ezsigntemplatesignature_response_compoundJSON, \"a_objEzsigntemplatesignaturecustomdate\");\n    if (a_obj_ezsigntemplatesignaturecustomdate) { \n    cJSON *a_obj_ezsigntemplatesignaturecustomdate_local_nonprimitive = NULL;\n    if(!cJSON_IsArray(a_obj_ezsigntemplatesignaturecustomdate)){\n        goto end; //nonprimitive container\n    }\n\n    a_obj_ezsigntemplatesignaturecustomdateList = list_createList();\n\n    cJSON_ArrayForEach(a_obj_ezsigntemplatesignaturecustomdate_local_nonprimitive,a_obj_ezsigntemplatesignaturecustomdate )\n    {\n        if(!cJSON_IsObject(a_obj_ezsigntemplatesignaturecustomdate_local_nonprimitive)){\n            goto end;\n        }\n        ezsigntemplatesignaturecustomdate_response_compound_t *a_obj_ezsigntemplatesignaturecustomdateItem = ezsigntemplatesignaturecustomdate_response_compound_parseFromJSON(a_obj_ezsigntemplatesignaturecustomdate_local_nonprimitive);\n\n        list_addElement(a_obj_ezsigntemplatesignaturecustomdateList, a_obj_ezsigntemplatesignaturecustomdateItem);\n    }\n    }\n\n\n    ezsigntemplatesignature_response_compound_local_var = ezsigntemplatesignature_response_compound_create (\n        pki_ezsigntemplatesignature_id->valuedouble,\n        fki_ezsigntemplatedocument_id->valuedouble,\n        fki_ezsigntemplatesigner_id->valuedouble,\n        i_ezsigntemplatedocumentpage_pagenumber->valuedouble,\n        i_ezsigntemplatesignature_x->valuedouble,\n        i_ezsigntemplatesignature_y->valuedouble,\n        i_ezsigntemplatesignature_step->valuedouble,\n        e_ezsigntemplatesignature_type_local_nonprim,\n        t_ezsigntemplatesignature_tooltip ? strdup(t_ezsigntemplatesignature_tooltip->valuestring) : NULL,\n        e_ezsigntemplatesignature_tooltipposition ? e_ezsigntemplatesignature_tooltipposition_local_nonprim : NULL,\n        e_ezsigntemplatesignature_font ? e_ezsigntemplatesignature_font_local_nonprim : NULL,\n        b_ezsigntemplatesignature_customdate ? b_ezsigntemplatesignature_customdate->valueint : 0,\n        a_obj_ezsigntemplatesignaturecustomdate ? a_obj_ezsigntemplatesignaturecustomdateList : NULL\n        );\n\n    return ezsigntemplatesignature_response_compound_local_var;\nend:\n    if (e_ezsigntemplatesignature_type_local_nonprim) {\n        field_e_ezsigntemplatesignature_type_free(e_ezsigntemplatesignature_type_local_nonprim);\n        e_ezsigntemplatesignature_type_local_nonprim = NULL;\n    }\n    if (e_ezsigntemplatesignature_tooltipposition_local_nonprim) {\n        field_e_ezsigntemplatesignature_tooltipposition_free(e_ezsigntemplatesignature_tooltipposition_local_nonprim);\n        e_ezsigntemplatesignature_tooltipposition_local_nonprim = NULL;\n    }\n    if (e_ezsigntemplatesignature_font_local_nonprim) {\n        field_e_ezsigntemplatesignature_font_free(e_ezsigntemplatesignature_font_local_nonprim);\n        e_ezsigntemplatesignature_font_local_nonprim = NULL;\n    }\n    if (a_obj_ezsigntemplatesignaturecustomdateList) {\n        listEntry_t *listEntry = NULL;\n        list_ForEach(listEntry, a_obj_ezsigntemplatesignaturecustomdateList) {\n            ezsigntemplatesignaturecustomdate_response_compound_free(listEntry->data);\n            listEntry->data = NULL;\n        }\n        list_freeList(a_obj_ezsigntemplatesignaturecustomdateList);\n        a_obj_ezsigntemplatesignaturecustomdateList = NULL;\n    }\n    return NULL;\n\n}\n\n", "comment_ratio": 0.11691022964509394}
{"lang": "c", "code": "#ifndef INC_GLV_PLOTS_H\n#define INC_GLV_PLOTS_H\n\n/*\tGraphics Library of Views (GLV) - GUI Building Toolkit\n\tSee COPYRIGHT file for authors and license information */\n\n#include <algorithm>\n#include <vector>\n#include <set>\n#include \"glv_core.h\"\n#include \"glv_draw.h\"\n#include \"glv_grid.h\"\n#include \"glv_texture.h\"\n#include \"glv_widget.h\"\n\nnamespace glv{\n\nclass Plot;\nclass Plottable;\n\n\n\n/// Map from model data to graphics data\nclass GraphicsMap{\npublic:\n\tvirtual ~GraphicsMap(){}\n\t\n\t/// Routine to generate graphics from model data\n\tvirtual void onMap(GraphicsData& b, const Data& d, const Indexer& ind) = 0;\n};\n\n\n\n/// Defines a routine for generating plot graphics from model data\nclass Plottable : public GraphicsMap{\npublic:\n\n\t/// @param[in] prim\t\tdrawing primitive\n\t/// @param[in] stroke\twidth of lines or points\n\t/// @param[in] col\t\tcolor\n\tPlottable(int prim=draw::Points, float stroke=1, const Color& col=Color(1,0,0))\n\t:\tmPrim(prim), mStroke(stroke), mColor(col), mDrawUnder(false)\n\t{}\n\n\tvirtual ~Plottable(){}\n\n\t/// Called when a new graphics context is created\n\tvirtual void onContextCreate(){}\n\t\n\t/// Called when the current graphics context is destroyed\n\tvirtual void onContextDestroy(){}\n\n\tvirtual void onMap(GraphicsData& b, const Data& d, const Indexer& ind){}\n\n\t/// Get color\n\tconst Color& color() const { return mColor; }\n\tPlottable& color(const Color& v){ mColor=v; return *this; }\n\n\t/// Get data\n\tconst Data& data() const { return mData; }\n\tData& data(){ return mData; }\n\t\n\tbool drawUnderGrid() const { return mDrawUnder; }\n\tPlottable& drawUnderGrid(bool v){ mDrawUnder=v; return *this; }\n\t\n\t/// Get geometric primitive\n\tint prim() const { return mPrim; }\t\n\tPlottable& prim(int v){ mPrim=v; return *this; }\n\n\t/// Get stroke width (for lines and points)\n\tint stroke() const { return mStroke; }\t\n\tPlottable& stroke(int v){ mStroke=v; return *this; }\n\n\t/// Add a graphics map\n\tPlottable& add(GraphicsMap& v);\n\n\t/// Remove a graphics map\n\tPlottable& remove(GraphicsMap& v);\n\nprotected:\n\tfriend class Plot;\n\n\ttypedef std::vector<GraphicsMap *> GraphicsMaps;\n\n\tint mPrim;\n\tfloat mStroke;\n\tColor mColor;\n\tData mData;\n\tGraphicsMaps mGraphicsMaps;\n\tbool mDrawUnder;\n\t\n\tvoid doPlot(GraphicsData& gd, const Data& d);\n\t\n\t// defines how graphics data should be drawn\n\tvirtual void onDraw(GraphicsData& gd, const Data& d){\n\t\tdraw::paint(prim(), gd);\n\t}\n};\n\n\n\n\n/// Density plotter\nclass PlotDensity : public Plottable{\npublic:\n\n\t/// @param[in] color\t\tplot color\n\t/// @param[in] hueSpread\tamount spread hue for positive and negative values\n\t/// @param[in] interpolate\tinterpolation (0=none, 1=linear)\n\tPlotDensity(const Color& color=Color(1,0,0), float hueSpread=0, int interpolate=0);\n\n\tPlotDensity& hueSpread(float v){ mHueSpread=v; return *this; }\n\n\t/// Set interpolation mode (0=none, 1=linear)\n\tPlotDensity& interpolate(int v){ mIpol=v; return *this; }\n\t\n//\tstatic GraphicsMap& defaultColorMap();\n//\n//\tstruct DefaultColorMap : public GraphicsMap{\n//\t\tvirtual void onMap(GraphicsData& b, const Data& d, const Indexer& ind);\n//\t};\n\n\tvirtual void onMap(GraphicsData& b, const Data& d, const Indexer& ind);\n\nprotected:\n\tvirtual void onContextCreate();\n\tvirtual void onContextDestroy();\n\tvirtual void onDraw(GraphicsData& gd, const Data& d);\n\tTexture2 mTex;\n\tfloat mHueSpread;\n\tint mIpol;\n};\n\n\n/// One-dimensional function plotter\nclass PlotFunction1D : public Plottable{\npublic:\n\n\t/// @param[in] color\tplot color\n\tPlotFunction1D(const Color& color=Color(0));\n\n\tstatic GraphicsMap& defaultVertexMap();\n\n\tstruct DefaultVertexMap : public GraphicsMap{\n\t\tvirtual void onMap(GraphicsData& b, const Data& d, const Indexer& ind);\n\t};\n};\n\n\n/// Two-dimensional function plotter\nclass PlotFunction2D : public Plottable{\npublic:\n\n\t/// @param[in] color\tplot color\n\tPlotFunction2D(const Color& color=Color(0));\n\n\tstatic GraphicsMap& defaultVertexMap();\n\n\tstruct DefaultVertexMap : public GraphicsMap{\n\t\tvirtual void onMap(GraphicsData& b, const Data& d, const Indexer& ind);\n\t};\n};\n\n\n\n/// Plots data according to one or more attached Plottables\nclass Plot : public Grid {\npublic:\n\ttypedef std::vector<Plottable *> Plottables;\n\n\tPlot(const Rect& r=Rect(0));\n\n\tPlot(const Rect& r, Plottable& p);\n\n\tPlottables& plottables(){ return mPlottables; }\n\tconst Plottables& plottables() const { return mPlottables; }\n\n\tint valueIndex(int i) const { return mValInd[i]; }\n\n\t/// Add new plotting routine\n\tPlot& add(Plottable& v);\n\n\tPlot& remove(Plottable& v);\n\n\tPlot& valueIndex(int from, int to){\n\t\tmValInd[from] = to; return *this;\n\t}\n\n\tvirtual const char * className() const { return \"Plot\"; }\n\tvirtual void onDraw(GLV& g);\n\tvirtual bool onEvent(Event::t e, GLV& g);\n\nprotected:\n\tPlottables mPlottables;\n\tint mValInd[4];\n\t\n\tvoid resetValInd(){\n\t\tfor(int i=0; i<4; ++i) mValInd[i]=i;\n\t}\n};\n\n\n} // glv::\n#endif\n\n", "comment_ratio": 0.15609756097560976}
{"lang": "c", "code": "//\n//  SceneDelegate.h\n//  BlueToothManager\n//\n//  Created by Huasali on 2021/11/22.\n//\n\n#import <UIKit/UIKit.h>\n\n@interface SceneDelegate : UIResponder <UIWindowSceneDelegate>\n\n@property (strong, nonatomic) UIWindow * window;\n\n@end\n\n\n", "comment_ratio": 0.375}
{"lang": "c", "code": "//\n// Created by Happy on 21/05/2020.\n//\n\n#ifndef SUBPROCESS_PROCESSPIPEINPUT_H\n#define SUBPROCESS_PROCESSPIPEINPUT_H\n\n#include \"util/StatusOr.h\"\n#include <boost/iostreams/device/file_descriptor.hpp>\n#include <boost/iostreams/stream.hpp>\n#include <ostream>\n\nnamespace io = boost::iostreams;\n\nclass ProcessPipeInput {\npublic:\n    ProcessPipeInput();\n    util::StatusOr<std::pair<int, int>> GetFDs();\n    io::stream<io::file_descriptor_sink> &Stream() { return sink_; }\n\nprivate:\n    io::file_descriptor_sink fd_;\n    io::stream<io::file_descriptor_sink> sink_;\n};\n\n\n#endif//SUBPROCESS_PROCESSPIPEINPUT_H\n\n", "comment_ratio": 0.14285714285714285}
{"lang": "c", "code": "#ifndef IOS_CHROME_BROWSER_UI_INFOBARS_MODALS_INFOBAR_SAVE_ADDRESS_PROFILE_MODAL_CONSUMER_H_\n#define IOS_CHROME_BROWSER_UI_INFOBARS_MODALS_INFOBAR_SAVE_ADDRESS_PROFILE_MODAL_CONSUMER_H_\n\n#import <Foundation/Foundation.h>\n\nnamespace {\n// Pref keys passed through setupModalViewControllerWithPrefs:.\nNSString* kNamePrefKey = @\"NamePrefKey\";\nNSString* kAddressLine1PrefKey = @\"AddressLine1PrefKey\";\nNSString* kAddressLine2PrefKey = @\"AddressLine2PrefKey\";\nNSString* kCityPrefKey = @\"CityPrefKey\";\nNSString* kStatePrefKey = @\"StatePrefKey\";\nNSString* kCountryPrefKey = @\"CountryPrefKey\";\nNSString* kZipPrefKey = @\"ZipPrefKey\";\nNSString* kPhonePrefKey = @\"PhonePrefKey\";\nNSString* kEmailPrefKey = @\"EmailPrefKey\";\nNSString* kCurrentAddressProfileSavedPrefKey = @\"currentAddressProfileSaved\";\n}  // namespace\n\n// Consumer for model to push configurations to the SaveAddressProfile UI.\n@protocol InfobarSaveAddressProfileModalConsumer <NSObject>\n\n// Informs the consumer of the current state of important prefs.\n- (void)setupModalViewControllerWithPrefs:(NSDictionary*)prefs;\n\n@end\n\n#endif  // IOS_CHROME_BROWSER_UI_INFOBARS_MODALS_INFOBAR_SAVE_ADDRESS_PROFILE_MODAL_CONSUMER_H_\n\n", "comment_ratio": 0.24242424242424243}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n#import \"BCRequestStatus.h\"\n\ntypedef NSString * BCHeaderFieldKey;\n\nFOUNDATION_EXPORT BCHeaderFieldKey const BCHeaderFieldKeyDeviceId;\nFOUNDATION_EXPORT BCHeaderFieldKey const BCHeaderFieldKeyImei;\nFOUNDATION_EXPORT BCHeaderFieldKey const BCHeaderFieldKeyImsi;\nFOUNDATION_EXPORT BCHeaderFieldKey const BCHeaderFieldKeyMac;\nFOUNDATION_EXPORT BCHeaderFieldKey const BCHeaderFieldKeyPlatform;\nFOUNDATION_EXPORT BCHeaderFieldKey const BCHeaderFieldKeyOsVersion;\nFOUNDATION_EXPORT BCHeaderFieldKey const BCHeaderFieldKeyDeviceName;\nFOUNDATION_EXPORT BCHeaderFieldKey const BCHeaderFieldKeyScreenSize;\n\nFOUNDATION_EXPORT BCHeaderFieldKey const BCHeaderFieldKeyNetwork;\nFOUNDATION_EXPORT BCHeaderFieldKey const BCHeaderFieldKeyLbs;\nFOUNDATION_EXPORT BCHeaderFieldKey const BCHeaderFieldKeyNotificationStatus;\nFOUNDATION_EXPORT BCHeaderFieldKey const BCHeaderFieldKeyTimestamp;\n\n@protocol BCNetworkBaseHeaderUpdateProtocol\n- (void)updateStoreage:(NSMutableDictionary *)dict;\n- (void)removeFromStoreage:(NSMutableDictionary *)dict;\n@end\n\n@interface BCDeviceInfo : NSObject <BCNetworkBaseHeaderUpdateProtocol>\n\n@property (nonatomic, copy) NSString *deviceId;\n@property (nonatomic, copy) NSString *imei;\n@property (nonatomic, copy) NSString *imsi;\n@property (nonatomic, copy) NSString *mac;\n@property (nonatomic, assign) NSInteger platform;\n@property (nonatomic, copy) NSString *osVersion;\n@property (nonatomic, copy) NSString *deviceName;\n@property (nonatomic, copy) NSString *screenSize;\n\n@end\n\n\n@interface BCNetworkSession : NSObject\n\n@property (nonatomic, copy) NSDictionary *session;\n@property (nonatomic, copy) NSSet *allHttpKeys;//\u9700\u8981\u653e\u5230httpbody \u4e2d\u7684\u5b57\u6bb5\n@property (nonatomic, copy) NSSet *allTailKeys;//\u672c\u5730\u8ddf\u8e2a\u72b6\u6001\u7528\u7684key\n\n//@property (nonatomic, assign) NSInteger sessionType;\n//@property (nonatomic, copy) NSString *userId;\n//@property (nonatomic, copy) NSString *token;\n\n@end\n\n\ntypedef NS_ENUM(NSUInteger, BCDeviceStatusNetStatus) {\n    BCDeviceStatusNetStatusDisable = 0,\n    BCDeviceStatusNetStatus2G = 2,\n    BCDeviceStatusNetStatus3G = 3,\n    BCDeviceStatusNetStatus4G = 4,\n    BCDeviceStatusNetStatusWifi = 20,\n    BCDeviceStatusNetStatusWWan = 21,\n    BCDeviceStatusNetStatusUnknown = 22,\n};\n\n@interface BCDeviceStatus : NSObject <BCNetworkBaseHeaderUpdateProtocol>\n\n@property (nonatomic, assign, readonly) BCDeviceStatusNetStatus network;\n@property (nonatomic, copy, readonly) NSString *lbs;\n\n//0 \u672a\u77e5\uff0c 1 \u5f00 2\u5173\n@property (nonatomic, assign, readonly) NSInteger nofiticationStatus;\n@property (nonatomic, assign, readonly) CFTimeInterval timestamp;\n\n@end\n\n\n@class BCEnvConfig;\n@interface BCNetworkManager : NSObject\n\n@property (nonatomic, strong, readonly) BCDeviceInfo *deviceInfo;\n\n//\u8bbe\u5907\u7684\u72b6\u6001\n@property (nonatomic, strong, readonly) BCDeviceStatus *deviceStatus;\n\n@property (nonatomic, strong, readonly) BCNetworkSession *networkSession;\n\n/**\n \u6dfb\u52a0config\n\n @param config \u5982\u679c\u5df2\u7ecf\u5b58\u5728config.name \u76f8\u5bf9\u5e94\u7684config\uff0c \u5219\u4f1a\u7528\u65b0\u7684config\u8986\u76d6\u65e7\u7684config\n */\n- (void)addEnvConfig:(BCEnvConfig *)config;\n\n\n/**\n \u5220\u9664config\n\n @param config \u8981\u5220\u9664\u7684config\n */\n- (void)removeEnvConfig:(BCEnvConfig *)config;\n\n/**\n \u5220\u9664config\n \n @param name \u901a\u8fc7name\u5220\u9664\n */\n- (void)removeEnvConfigForName:(NSString *)name;\n\n- (BCEnvConfig *)getEnvConfigForName:(NSString *)name;\n\n- (NSDictionary *)getAllEnvConfigs;\n\n- (void)updateNetworkSession:(BCNetworkSession *)session;\n\n+ (instancetype)sharedInstance;\n\n@end\n\nFOUNDATION_EXPORT NSString * const BCNetworkNotifityNameGatewayError;\n\n\n\n\n", "comment_ratio": 0.109375}
{"lang": "c", "code": "\ufeff#pragma once\n\n// Name: SeaOfThieves, Version: 2.0.23\n\n\n/*!!DEFINE!!*/\n\n/*!!HELPER_DEF!!*/\n\n/*!!HELPER_INC!!*/\n\n#ifdef _MSC_VER\n\t#pragma pack(push, 0x01)\n#endif\n\nnamespace CG\n{\n//---------------------------------------------------------------------------\n// Classes\n//---------------------------------------------------------------------------\n\n// BlueprintGeneratedClass BP_FishingFish_AncientScale_05_Colour_03_Smoke.BP_FishingFish_AncientScale_05_Colour_03_Smoke_C\n// 0x0000 (FullSize[0x0920] - InheritedSize[0x0920])\nclass ABP_FishingFish_AncientScale_05_Colour_03_Smoke_C : public ABP_FishingFish_AncientScale_05_C\n{\npublic:\n\n\n\tstatic UClass* StaticClass()\n\t{\n\t\tstatic auto ptr = UObject::FindClass(\"BlueprintGeneratedClass BP_FishingFish_AncientScale_05_Colour_03_Smoke.BP_FishingFish_AncientScale_05_Colour_03_Smoke_C\");\n\t\treturn ptr;\n\t}\n\n\n\n\tvoid UserConstructionScript();\n\tvoid AfterRead();\n\tvoid BeforeDelete();\n\n};\n\n}\n\n#ifdef _MSC_VER\n\t#pragma pack(pop)\n#endif\n\n", "comment_ratio": 0.125}
{"lang": "c", "code": "#ifndef FASTMODALT_H\n#define FASTMODALT_H\n\n// collection of alternative functions to those offered in fastmod.h\n// they may be faster or more convenient.\n\n\n#include <stdint.h>\n#include <stdbool.h>\n\n// could be faster than   \"return (v<0) ? -v : v\" on some systems\nstatic inline int32_t fast_abs(int32_t v) {\n  int32_t zero_or_minus1 = v >> 31;\n  return  (v ^ zero_or_minus1)-zero_or_minus1;\n}\n\nstatic inline bool is_positive_power_of_two(int32_t d) {\n  return (d & (d-1)) == 0;\n}\n\n\n\n#define IMUL64HIGH(rh, i1, i2)                                                 \\\n  do { int64_t unused_output;                                                  \\\n    asm(\"imulq %3\" : \"=d\"(rh),\"=a\"(unused_output) : \"a\"(i1), \"r\"(i2) : \"cc\");} \\\n  while(0)\n\n#define MUL64HIGH(rh, i1, i2)                                                 \\\n  do { int64_t unused_output;                                                  \\\n    asm(\"mulq %3\" : \"=d\"(rh),\"=a\"(unused_output) : \"a\"(i1), \"r\"(i2) : \"cc\");} \\\n  while(0)\n\n\n\n// use with computeM_s32\n// this option is broken for 1,-1, 2, -2, and -2**31\nstatic inline int32_t fastdiv_s32_ofk_special(int32_t a, uint64_t M, int32_t d) {\n\n  int64_t quotient3;\n  const int64_t corrector = d >> 31;\n  const int64_t numer_corrector = a >> 31;\n\n  IMUL64HIGH(quotient3, (int64_t) a, M);\n  int32_t quotient2 = quotient3 - numer_corrector;\n\n  // negate if necessary\n  int32_t quotient = (quotient2 ^ corrector) - corrector;\n  return quotient;\n}\n\n\n// broken for +-1 also minor breakage d= -2**31 since d/d gives 0\nstatic inline int32_t fastdiv_s32_ofk2(int32_t a, uint64_t M, int32_t d) {\n\n  int64_t quotient3;\n  const int64_t corrector = d >> 31;\n  const int64_t numer_corrector = a >> 31;\n\n  // based on the instructions used with unsigned 128bit multiplication\n  MUL64HIGH(quotient3, (int64_t) a, M);\n  quotient3 -= (M & numer_corrector);  // except should be cheaper and equivalent\n\n  int32_t quotient2 = quotient3 - numer_corrector;\n\n  // negate if necessary\n  int32_t quotient = (quotient2 ^ corrector) - corrector;\n  return quotient;\n}\n\nstatic inline uint64_t computeM_s32_ofk(int32_t d) {\n  const uint32_t abs_d = fast_abs(d);\n  if (is_positive_power_of_two(abs_d)) {\n    return __builtin_ctz(d);\n  }\n  else {\n    const uint64_t M = 1 + (UINT64_C(0xffffffffffffffff) / abs_d);\n    return M;\n  }\n}\n\n//  work for all nonzero d\nstatic inline int32_t fastdiv_s32_ofk(int32_t a, uint64_t M, int32_t d) {\n  const int64_t corrector = d >> 31;\n  int32_t quotient;\n\n  if (is_positive_power_of_two(fast_abs(d))) {\n      // code from libdivide\n      // uses 3 shifts, 2 add/sub and and AND.  But much faster than the usual\n      // sequence from Warren (same number of instructions).\n      // M was co-opted to be a shift amount for d a power of 2\n      const uint32_t uq = (uint32_t)(a + ((a >> 31) & ((1U << M) -1)));\n      quotient = (int32_t) uq;\n      quotient = quotient >> M;\n  }\n  else {\n    int64_t quotient3;\n    const int64_t numer_corrector = a >> 31;\n\n    IMUL64HIGH(quotient3, (int64_t) a, M);\n    quotient = quotient3 - numer_corrector;\n  }\n  // negate if necessary\n  quotient = (quotient ^ corrector) - corrector;\n  return quotient;\n}\n\n\n#endif\n\n", "comment_ratio": 0.14678899082568808}
{"lang": "c", "code": "#ifndef CC_BASE_ROLLING_TIME_DELTA_HISTORY_H_\n#define CC_BASE_ROLLING_TIME_DELTA_HISTORY_H_\n\n#include <stddef.h>\n\n#include <set>\n\n#include \"base/containers/circular_deque.h\"\n#include \"base/containers/flat_map.h\"\n#include \"base/time/time.h\"\n#include \"cc/base/base_export.h\"\n\nnamespace cc {\n\n// Stores a limited number of samples. When the maximum size is reached, each\n// insertion results in the deletion of the oldest remaining sample.\nclass CC_BASE_EXPORT RollingTimeDeltaHistory {\n public:\n  explicit RollingTimeDeltaHistory(size_t max_size);\n  RollingTimeDeltaHistory(const RollingTimeDeltaHistory&) = delete;\n\n  ~RollingTimeDeltaHistory();\n\n  RollingTimeDeltaHistory& operator=(const RollingTimeDeltaHistory&) = delete;\n\n  void InsertSample(base::TimeDelta time);\n  void RemoveOldestSample();\n  size_t sample_count() const { return sample_set_.size(); }\n\n  void Clear();\n\n  // Returns the smallest sample that is greater than or equal to the specified\n  // percent of samples. If there aren't any samples, returns base::TimeDelta().\n  base::TimeDelta Percentile(double percent) const;\n\n private:\n  typedef std::multiset<base::TimeDelta> TimeDeltaMultiset;\n\n  base::TimeDelta ComputePercentile(double percent) const;\n\n  TimeDeltaMultiset sample_set_;\n  base::circular_deque<TimeDeltaMultiset::iterator> chronological_sample_deque_;\n  size_t max_size_;\n\n  mutable base::flat_map<double, base::TimeDelta> percentile_cache_;\n};\n\n}  // namespace cc\n\n#endif  // CC_BASE_ROLLING_TIME_DELTA_HISTORY_H_\n\n", "comment_ratio": 0.16363636363636364}
{"lang": "c", "code": "#import <StoreServices/StoreServices-Structs.h>\n#import <libobjc.A.dylib/NSCopying.h>\n\n@protocol SSVSAPContext;\n@class NSString, NSArray, NSDictionary;\n\n@interface SSVPlatformContext : NSObject <NSCopying> {\n\n\tNSString* _lookupURLString;\n\tid<SSVSAPContext> _sapContext;\n\tNSArray* _signedHeaders;\n\tNSArray* _signedQueryParameters;\n\tNSString* _unpersonalizedLookupURLString;\n\n}\n\n@property (nonatomic,readonly) NSDictionary * bagDictionary; \n@property (nonatomic,readonly) NSString * lookupURLString;                            //@synthesize lookupURLString=_lookupURLString - In the implementation block\n@property (nonatomic,readonly) NSString * unpersonalizedLookupURLString;              //@synthesize unpersonalizedLookupURLString=_unpersonalizedLookupURLString - In the implementation block\n@property (nonatomic,readonly) NSArray * signedHeaders;                               //@synthesize signedHeaders=_signedHeaders - In the implementation block\n@property (nonatomic,readonly) NSArray * signedQueryParameters;                       //@synthesize signedQueryParameters=_signedQueryParameters - In the implementation block\n@property (nonatomic,retain) id<SSVSAPContext> SAPContext;                            //@synthesize sapContext=_sapContext - In the implementation block\n-(id)initWithLookupURL:(id)arg1 unpersonalizedLookupURL:(id)arg2 signedHeaders:(id)arg3 signedQueryParameters:(id)arg4 ;\n-(NSString *)lookupURLString;\n-(id<SSVSAPContext>)SAPContext;\n-(void)setSAPContext:(id<SSVSAPContext>)arg1 ;\n-(NSArray *)signedHeaders;\n-(NSArray *)signedQueryParameters;\n-(NSString *)unpersonalizedLookupURLString;\n-(NSDictionary *)bagDictionary;\n-(id)initWithBagDictionary:(id)arg1 ;\n-(id)copyWithZone:(NSZone*)arg1 ;\n@end\n\n\n", "comment_ratio": 0.11627906976744186}
{"lang": "c", "code": "/*\n * \u8e22\u4e00\u4e2a\u7403\n *      1. \u8d70\u8fd1\u7403\n        2. \u811a\u5bf9\u51c6\u7403\n        3. kick\n */\noption(KickOnce)\n{\n  float she_X = -500.0f;\n  //float she_X = 0.0f;\n  float she_Y = 0.0f;\n  float distance;\n  initial_state(start)\n  {\n    transition\n    {\n      //if(state_time > 15000)\n       // goto turnToBall;\n       goto walkToBall;\n    }\n    action\n    {\n      theHeadControlMode = HeadControl::lookForward;\n      //WalkAtRelativeSpeed(Pose2f(1.f, 0.f, 0.f));\n      Stand();\n    }\n  }\n\n///////////////////////////////////\n  state(turnToBall)\n  {\n    transition\n    {\n      if(theLibCodeRelease.timeSinceBallWasSeen > theBehaviorParameters.ballNotSeenTimeOut)\n        goto searchForBall;\n      if(std::abs(theBallModel.estimate.position.angle()) < 5_deg)\n        goto walkToBall;\n    }\n    action\n    {\n      theHeadControlMode = HeadControl::lookForward;\n      WalkToTarget(Pose2f(50.f, 50.f, 50.f), Pose2f(theBallModel.estimate.position.angle(), 0.f, 0.f));\n    }\n  }\n\n  state(walkToBall)\n  {\n    transition\n    {\n      if(theLibCodeRelease.timeSinceBallWasSeen > theBehaviorParameters.ballNotSeenTimeOut)\n        goto searchForBall;\n      if(theBallModel.estimate.position.norm() < 500.f)\n        goto alignBehindBall;\n    }\n    action\n    {\n      theHeadControlMode = HeadControl::lookForward;\n      WalkToTarget(Pose2f(50.f, 50.f, 50.f), theBallModel.estimate.position);\n    }\n  }\n\n//  state(alignToGoal)\n//  {\n//    transition\n//    {\n//      if(theLibCodeRelease.timeSinceBallWasSeen > theBehaviorParameters.ballNotSeenTimeOut)\n//        goto searchForBall;\n//      if(std::abs(theLibCodeRelease.angleToOwnGoal+90) < 10_deg && std::abs(theBallModel.estimate.position.y()) < 100.f)\n//        goto alignBehindBall;\n//    }\n//    action\n//    {\n//      theHeadControlMode = HeadControl::lookForward;\n//      WalkToTarget(Pose2f(100.f, 100.f, 100.f), Pose2f(theLibCodeRelease.angleToOwnGoal+90, theBallModel.estimate.position.x() - 350.f, theBallModel.estimate.position.y()));\n//    }\n//  }\n\n  state(alignBehindBall)\n  {\n    transition\n    {\n      if(theLibCodeRelease.timeSinceBallWasSeen > theBehaviorParameters.ballNotSeenTimeOut)\n        goto searchForBall;\n      if(theLibCodeRelease.between(theBallModel.estimate.position.y(), 40.f, 70.f)\n      && theLibCodeRelease.between(theBallModel.estimate.position.x(), 160.f, 220.f))\n     //&& std::abs(theLibCodeRelease.angleToOwnGoal) < 2_deg)\n        goto kick;\n    }\n    action\n    {\n      theHeadControlMode = HeadControl::focusBall;\n      // WalkToTarget(Pose2f(80.f, 80.f, 80.f), Pose2f(theLibCodeRelease.angleToOwnGoal, theBallModel.estimate.position.x() - 200.f, theBallModel.estimate.position.y() - 50.f));\n      WalkToTarget(Pose2f(80.f, 80.f, 80.f), Pose2f(0.f, theBallModel.estimate.position.x() - 200.f, theBallModel.estimate.position.y() - 50.f));\n    }\n  }\n\n  state(kick)\n  {\n    transition\n    {\n      if(state_time > 5000)\n        goto tui;\n    }\n    action\n    {\n      theHeadControlMode = HeadControl::lookForward;\n      KickForWard(KickRequest::kickForward,true);\n      //InWalkKick(WalkKickVariant(WalkKicks::forward, Legs::left), Pose2f(theLibCodeRelease.angleToGoal, theBallModel.estimate.position.x() - 160.f, theBallModel.estimate.position.y() - 55.f));\n    }\n  }\n  \n  state(tui)\n  {\n    transition\n    {\n        if(state_time > 5000)\n            goto kickEnd;\n            // goto searchForBall;\n            // Stand();\n    }\n    action\n    {\n        theHeadControlMode = HeadControl::leftAndRight;\n        WalkToTarget(Pose2f(30.f, 30.f, 30.f), Pose2f(0_deg,-550.f, 0.f));  \n    }\n  }\n  \n  state(kickEnd)\n  {\n      transition\n      {\n          \n      }\n      action\n      {\n          theHeadControlMode = HeadControl::lookForward;\n          Stand();\n      }\n  }\n  \n  state(searchForBall)\n  {\n    transition\n    {\n      if(theLibCodeRelease.timeSinceBallWasSeen < 300)\n        goto standMiddel;\n    }\n    action\n    {\n      theHeadControlMode = HeadControl::leftAndRight;\n      WalkAtRelativeSpeed(Pose2f(1.f, 0.f, 0.f));\n    }\n  }\n  \n  state(standMiddel)\n  {\n    transition\n    {\n        Pose2f relatePoint = AbsolutePointToRobot(theRobotPose,she_X,she_Y);\n           distance = relatePoint.translation.norm();\n           if ( distance < 10.0 )\n           goto searchForBall;\n           if(theLibCodeRelease.timeSinceBallWasSeen < 300)\n               goto turnToBall;\n    }\n    action\n    {\n        LeftAndRight();\n          Pose2f relatePoint=AbsolutePointToRobot(theRobotPose,she_X,she_Y);\n          WalkToTarget(Pose2f(pi/8,50.f,50.f),relatePoint);\n    }\n  }\n}\n\n", "comment_ratio": 0.14367816091954022}
{"lang": "c", "code": "#ifndef CLIENT_ROCFFT_ENUM_H\n#define CLIENT_ROCFFT_ENUM_H\n\n// The partial enums copied from rocFFT repo, for hipFFT test purpose only.\n\n/*! @brief Type of transform */\ntypedef enum rocfft_transform_type_e\n{\n    rocfft_transform_type_complex_forward,\n    rocfft_transform_type_complex_inverse,\n    rocfft_transform_type_real_forward,\n    rocfft_transform_type_real_inverse,\n} rocfft_transform_type;\n\n/*! @brief Precision */\ntypedef enum rocfft_precision_e\n{\n    rocfft_precision_single,\n    rocfft_precision_double,\n} rocfft_precision;\n\n/*! @brief Result placement */\ntypedef enum rocfft_result_placement_e\n{\n    rocfft_placement_inplace,\n    rocfft_placement_notinplace,\n} rocfft_result_placement;\n\n/*! @brief Array type */\ntypedef enum rocfft_array_type_e\n{\n    rocfft_array_type_complex_interleaved,\n    rocfft_array_type_complex_planar,\n    rocfft_array_type_real,\n    rocfft_array_type_hermitian_interleaved,\n    rocfft_array_type_hermitian_planar,\n    rocfft_array_type_unset,\n} rocfft_array_type;\n\n#endif\n", "comment_ratio": 0.3333333333333333}
{"lang": "c", "code": "#ifndef SERVICES_PREFERENCES_PUBLIC_CPP_PREF_SERVICE_FACTORY_H_\n#define SERVICES_PREFERENCES_PUBLIC_CPP_PREF_SERVICE_FACTORY_H_\n\n#include <memory>\n\n#include \"base/callback.h\"\n#include \"components/prefs/pref_value_store.h\"\n#include \"services/preferences/public/mojom/preferences.mojom.h\"\n\nclass PrefRegistry;\nclass PrefService;\n\nnamespace service_manager {\nclass Connector;\n}\n\nnamespace prefs {\n\n// Note that |PrefService| might not be fully initialized yet and thus you need\n// to call |AddPrefInitObserver| on it before using it. Passed |nullptr| on\n// failure.\nusing ConnectCallback = base::Callback<void(std::unique_ptr<::PrefService>)>;\n\n// Create a |PrefService| object acting as a client library for the pref\n// service, using the provided |connector|. Connecting is asynchronous and\n// |callback| will be called when it has been established. All preferences that\n// will be accessed need to be registered in |pref_registry| first.\nvoid ConnectToPrefService(mojom::PrefStoreConnectorPtr connector,\n                          scoped_refptr<PrefRegistry> pref_registry,\n                          ConnectCallback callback);\n\n// Create a |PrefService| object acting as a client library for the pref\n// service, by connecting to the service using |connector|. Connecting is\n// asynchronous and |callback| will be called when it has been established. All\n// preferences that will be accessed need to be registered in |pref_registry|\n// first.\nvoid ConnectToPrefService(\n    service_manager::Connector* connector,\n    scoped_refptr<PrefRegistry> pref_registry,\n    ConnectCallback callback,\n    base::StringPiece service_name = mojom::kServiceName);\n\n}  // namespace prefs\n\n#endif  // SERVICES_PREFERENCES_PUBLIC_CPP_PREF_SERVICE_FACTORY_H_\n\n", "comment_ratio": 0.375}
{"lang": "c", "code": "#ifndef MZ_ZIP_RW_H\n#define MZ_ZIP_RW_H\n\n#include <stdint.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include \"mz_zip.h\"\n\n/***************************************************************************/\n\ntypedef int32_t (*mz_zip_reader_overwrite_cb)(void *handle, void *userdata, mz_zip_file *file_info, const char *path);\ntypedef int32_t (*mz_zip_reader_password_cb)(void *handle, void *userdata, mz_zip_file *file_info, char *password, int32_t max_password);\ntypedef int32_t (*mz_zip_reader_progress_cb)(void *handle, void *userdata, mz_zip_file *file_info, int64_t position);\ntypedef int32_t (*mz_zip_reader_entry_cb)(void *handle, void *userdata, mz_zip_file *file_info, const char *path);\n\n/***************************************************************************/\n\nint32_t mz_zip_reader_is_open(void *handle);\n// Checks to see if the zip file is open\n\nint32_t mz_zip_reader_open(void *handle, void *stream);\n// Opens zip file from stream\n\nint32_t mz_zip_reader_open_file(void *handle, const char *path);\n// Opens zip file from a file path\n\nint32_t mz_zip_reader_open_file_in_memory(void *handle, const char *path);\n// Opens zip file from a file path into memory for faster access\n\nint32_t mz_zip_reader_open_buffer(void *handle, uint8_t *buf, int32_t len, uint8_t copy);\n// Opens zip file from memory buffer\n\nint32_t mz_zip_reader_close(void *handle);\n// Closes the zip file\n\n/***************************************************************************/\n\nint32_t mz_zip_reader_unzip_cd(void *handle);\n// Unzip the central directory\n\n/***************************************************************************/\n\nint32_t mz_zip_reader_goto_first_entry(void *handle);\n// Goto the first entry in the zip file that matches the pattern\n\nint32_t mz_zip_reader_goto_next_entry(void *handle);\n// Goto the next entry in the zip file that matches the pattern\n\nint32_t mz_zip_reader_locate_entry(void *handle, const char *filename, uint8_t ignore_case);\n// Locates an entry by filename\n\nint32_t mz_zip_reader_entry_open(void *handle);\n// Opens an entry for reading\n\nint32_t mz_zip_reader_entry_close(void *handle);\n// Closes an entry\n\nint32_t mz_zip_reader_entry_read(void *handle, void *buf, int32_t len);\n// Reads and entry after being opened\n\nint32_t mz_zip_reader_entry_has_sign(void *handle);\n// Checks to see if the entry has a signature \n\nint32_t mz_zip_reader_entry_sign_verify(void *handle);\n// Verifies a signature stored with the entry\n\nint32_t mz_zip_reader_entry_get_hash(void *handle, uint16_t algorithm, uint8_t *digest, int32_t digest_size);\n// Gets a hash algorithm from the entry's extra field\n\nint32_t mz_zip_reader_entry_get_first_hash(void *handle, uint16_t *algorithm, uint16_t *digest_size);\n// Gets the most secure hash algorithm from the entry's extra field\n\nint32_t mz_zip_reader_entry_get_info(void *handle, mz_zip_file **file_info);\n// Gets the current entry file info\n\nint32_t mz_zip_reader_entry_is_dir(void *handle);\n// Gets the current entry is a directory\n\nint32_t mz_zip_reader_entry_save(void *handle, void *stream, mz_stream_write_cb write_cb);\n// Save the current entry to a steam\n\nint32_t mz_zip_reader_entry_save_process(void *handle, void *stream, mz_stream_write_cb write_cb);\n// Saves a portion of the current entry to a stream callback\n\nint32_t mz_zip_reader_entry_save_file(void *handle, const char *path);\n// Save the current entry to a file\n\nint32_t mz_zip_reader_entry_save_buffer(void *handle, void *buf, int32_t len);\n// Save the current entry to a memory buffer\n\nint32_t mz_zip_reader_entry_save_buffer_length(void *handle);\n// Gets the length of the buffer required to save\n\n/***************************************************************************/\n\nint32_t mz_zip_reader_save_all(void *handle, const char *destination_dir);\n// Save all files into a directory\n\n/***************************************************************************/\n\nvoid    mz_zip_reader_set_pattern(void *handle, const char *pattern, uint8_t ignore_case);\n// Sets the match pattern for entries in the zip file, if null all entries are matched\n\nvoid    mz_zip_reader_set_password(void *handle, const char *password);\n// Sets the password required for extraction\n\nvoid    mz_zip_reader_set_raw(void *handle, uint8_t raw);\n// Sets whether or not it should save the entry raw\n\nint32_t mz_zip_reader_get_raw(void *handle, uint8_t *raw);\n// Gets whether or not it should save the entry raw\n\nvoid    mz_zip_reader_set_encoding(void *handle, int32_t encoding);\n// Sets whether or not it should support cp437 in zip file names\n\nvoid    mz_zip_reader_set_sign_required(void *handle, uint8_t sign_required);\n// Sets whether or not it a signature is required \n\nvoid    mz_zip_reader_set_overwrite_cb(void *handle, void *userdata, mz_zip_reader_overwrite_cb cb);\n// Callback for what to do when a file is being overwritten\n\nvoid    mz_zip_reader_set_password_cb(void *handle, void *userdata, mz_zip_reader_password_cb cb);\n// Callback for when a password is required and hasn't been set\n\nvoid    mz_zip_reader_set_progress_cb(void *handle, void *userdata, mz_zip_reader_progress_cb cb);\n// Callback for extraction progress\n\nvoid    mz_zip_reader_set_progress_interval(void *handle, uint32_t milliseconds);\n// Let at least milliseconds pass between calls to progress callback\n\nvoid    mz_zip_reader_set_entry_cb(void *handle, void *userdata, mz_zip_reader_entry_cb cb);\n// Callback for zip file entries\n\nint32_t mz_zip_reader_get_zip_handle(void *handle, void **zip_handle);\n// Gets the underlying zip instance handle\n\nvoid*   mz_zip_reader_create(void **handle);\n// Create new instance of zip reader\n\nvoid    mz_zip_reader_delete(void **handle);\n// Delete instance of zip reader\n\n/***************************************************************************/\n\ntypedef int32_t (*mz_zip_writer_overwrite_cb)(void *handle, void *userdata, const char *path);\ntypedef int32_t (*mz_zip_writer_password_cb)(void *handle, void *userdata, mz_zip_file *file_info, char *password, int32_t max_password);\ntypedef int32_t (*mz_zip_writer_progress_cb)(void *handle, void *userdata, mz_zip_file *file_info, int64_t position);\ntypedef int32_t (*mz_zip_writer_entry_cb)(void *handle, void *userdata, mz_zip_file *file_info);\n\n/***************************************************************************/\n\nint32_t mz_zip_writer_is_open(void *handle);\n// Checks to see if the zip file is open\n\nint32_t mz_zip_writer_open(void *handle, void *stream);\n// Opens zip file from stream\n\nint32_t mz_zip_writer_open_file(void *handle, const char *path, int64_t disk_size, uint8_t append);\n// Opens zip file from a file path\n\nint32_t mz_zip_writer_open_file_in_memory(void *handle, const char *path);\n// Opens zip file from a file path into memory for faster access\n\nint32_t mz_zip_writer_close(void *handle);\n// Closes the zip file\n\n/***************************************************************************/\n\nint32_t mz_zip_writer_zip_cd(void *handle);\n// Zip the central directory\n\n/***************************************************************************/\n\nint32_t mz_zip_writer_entry_open(void *handle, mz_zip_file *file_info);\n// Opens an entry in the zip file for writing\n\nint32_t mz_zip_writer_entry_close(void *handle);\n// Closes entry in zip file\n\nint32_t mz_zip_writer_entry_write(void *handle, const void *buf, int32_t len);\n// Writes data into entry for zip\n\nint32_t mz_zip_writer_entry_sign(void *handle, uint8_t *message, int32_t message_size, \n    uint8_t *cert_data, int32_t cert_data_size, const char *cert_pwd);\n// Signs uncompressed content of entry, call before closing\n\n/***************************************************************************/\n\nint32_t mz_zip_writer_add(void *handle, void *stream, mz_stream_read_cb read_cb);\n// Writes all data to the currently open entry in the zip\n\nint32_t mz_zip_writer_add_process(void *handle, void *stream, mz_stream_read_cb read_cb);\n// Writes a portion of data to the currently open entry in the zip\n\nint32_t mz_zip_writer_add_info(void *handle, void *stream, mz_stream_read_cb read_cb, mz_zip_file *file_info);\n// Adds an entry to the zip based on the info\n\nint32_t mz_zip_writer_add_buffer(void *handle, void *buf, int32_t len, mz_zip_file *file_info);\n// Adds an entry to the zip with a memory buffer\n\nint32_t mz_zip_writer_add_file(void *handle, const char *path, const char *filename_in_zip);\n// Adds an entry to the zip from a file\n\nint32_t mz_zip_writer_add_path(void *handle, const char *path, const char *root_path, uint8_t include_path, \n    uint8_t recursive);\n// Enumerates a directory or pattern and adds entries to the zip\n\nint32_t mz_zip_writer_copy_from_reader(void *handle, void *reader);\n// Adds an entry from a zip reader instance\n\n/***************************************************************************/\n\nvoid    mz_zip_writer_set_password(void *handle, const char *password);\n// Password to use for encrypting files in the zip\n\nvoid    mz_zip_writer_set_raw(void *handle, uint8_t raw);\n// Sets whether or not we should write the entry raw\n\nint32_t mz_zip_writer_get_raw(void *handle, uint8_t *raw);\n// Gets whether or not we should write the entry raw\n\nvoid    mz_zip_writer_set_aes(void *handle, uint8_t aes);\n// Use aes encryption when adding files in zip\n\nvoid    mz_zip_writer_set_compress_method(void *handle, uint16_t compress_method);\n// Sets the compression method when adding files in zip\n\nvoid    mz_zip_writer_set_compress_level(void *handle, int16_t compress_level);\n// Sets the compression level when adding files in zip\n\nvoid    mz_zip_writer_set_zip_cd(void *handle, uint8_t flags);\n// Sets additional flags to be set when adding files in zip\n\nint32_t mz_zip_writer_set_certificate(void *handle, const char *cert_path, const char *cert_pwd);\n// Sets the certificate and timestamp url to use for signing when adding files in zip\n\nvoid    mz_zip_writer_set_overwrite_cb(void *handle, void *userdata, mz_zip_writer_overwrite_cb cb);\n// Callback for what to do when zip file already exists\n\nvoid    mz_zip_writer_set_password_cb(void *handle, void *userdata, mz_zip_writer_password_cb cb);\n// Callback for ask if a password is required for adding\n\nvoid    mz_zip_writer_set_progress_cb(void *handle, void *userdata, mz_zip_writer_progress_cb cb);\n// Callback for compression progress\n\nvoid    mz_zip_writer_set_progress_interval(void *handle, uint32_t milliseconds);\n// Let at least milliseconds pass between calls to progress callback\n\nvoid    mz_zip_writer_set_entry_cb(void *handle, void *userdata, mz_zip_writer_entry_cb cb);\n// Callback for zip file entries\n\nint32_t mz_zip_writer_get_zip_handle(void *handle, void **zip_handle);\n// Gets the underlying zip handle\n\nvoid*   mz_zip_writer_create(void **handle);\n// Create new instance of zip writer\n\nvoid    mz_zip_writer_delete(void **handle);\n// Delete instance of zip writer\n\n/***************************************************************************/\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n", "comment_ratio": 0.25886524822695034}
{"lang": "c", "code": "#import <objc/NSObject.h>\n\n@class NSString, QBBeaconRequestPackage;\n\n@interface QBBeaconReqDataPackage : NSObject\n{\n    QBBeaconRequestPackage *requestPackage;\n    NSString *reqKey;\n    NSString *reqServant;\n    NSString *reqFunc;\n    int zipAlg;\n    int encAlg;\n    NSString *encKey;\n    NSString *aesKeyEncrypt;\n    NSString *encPubKey;\n}\n\n+ (id)initWithRequestPkg:(id)arg1;\n@property(retain, nonatomic) NSString *encPubKey; // @synthesize encPubKey;\n@property(retain, nonatomic) NSString *aesKeyEncrypt; // @synthesize aesKeyEncrypt;\n@property(retain, nonatomic) NSString *encKey; // @synthesize encKey;\n@property(nonatomic) int encAlg; // @synthesize encAlg;\n@property(nonatomic) int zipAlg; // @synthesize zipAlg;\n@property(retain, nonatomic) NSString *reqFunc; // @synthesize reqFunc;\n@property(retain, nonatomic) NSString *reqServant; // @synthesize reqServant;\n@property(retain, nonatomic) NSString *reqKey; // @synthesize reqKey;\n@property(retain, nonatomic) QBBeaconRequestPackage *requestPackage; // @synthesize requestPackage;\n- (void).cxx_destruct;\n- (void)dealloc;\n- (id)getWithRspData:(id)arg1 error:(id *)arg2;\n- (id)createReqData:(id *)arg1;\n- (id)init;\n\n@end\n\n\n", "comment_ratio": 0.3333333333333333}
{"lang": "c", "code": "#ifndef STN_SRC_LONGLINK_PACKER_H_\n#define STN_SRC_LONGLINK_PACKER_H_\n\n#include <stdlib.h>\n\n#define LONGLINK_UNPACK_CONTINUE (-2)\n#define LONGLINK_UNPACK_FALSE (-1)\n#define LONGLINK_UNPACK_OK (0)\n\n#ifndef __cplusplus\n#error \"support cpp only\"\n#endif\n\nclass AutoBuffer;\n\nvoid longlink_pack(uint32_t _cmdid, uint32_t _seq, const void* _raw, size_t _raw_len, AutoBuffer& _packed);\nint  longlink_unpack(const AutoBuffer& _packed, uint32_t& _cmdid, uint32_t& _seq, size_t& _package_len, AutoBuffer& _body);\n\n//heartbeat signal to keep longlink network alive\nuint32_t longlink_noop_cmdid();\nuint32_t longlink_noop_resp_cmdid();\nvoid longlink_noop_req_body(AutoBuffer& _body);\nvoid longlink_noop_resp_body(AutoBuffer& _body);\n\n#endif // STN_SRC_LONGLINKPACKER_H_\n\n", "comment_ratio": 0.2391304347826087}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n\n#import <Parse/PFConstants.h>\n\n#import \"PFDataProvider.h\"\n\n@class BFTask<__covariant BFGenericType>;\n@class PFRESTCommand;\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface PFCommandURLRequestConstructor : NSObject\n\n@property (nonatomic, weak, readonly) id<PFInstallationIdentifierStoreProvider> dataSource;\n@property (nonatomic, strong, readonly) NSURL *serverURL;\n\n///--------------------------------------\n#pragma mark - Init\n///--------------------------------------\n\n- (instancetype)init NS_UNAVAILABLE;\n+ (instancetype)new NS_UNAVAILABLE;\n\n+ (instancetype)constructorWithDataSource:(id<PFInstallationIdentifierStoreProvider>)dataSource serverURL:(NSURL *)serverURL;\n\n///--------------------------------------\n#pragma mark - Data\n///--------------------------------------\n\n- (BFTask<NSURLRequest *> *)getDataURLRequestAsyncForCommand:(PFRESTCommand *)command;\n\n///--------------------------------------\n#pragma mark - File Upload\n///--------------------------------------\n\n- (BFTask<NSURLRequest *> *)getFileUploadURLRequestAsyncForCommand:(PFRESTCommand *)command\n                                                   withContentType:(NSString *)contentType\n                                             contentSourceFilePath:(NSString *)contentFilePath;\n\n///--------------------------------------\n#pragma mark - Headers\n///--------------------------------------\n\n+ (NSDictionary *)defaultURLRequestHeadersForApplicationId:(NSString *)applicationId\n                                                 clientKey:(nullable NSString *)clientKey\n                                                    bundle:(NSBundle *)bundle;\n\n@end\n\nNS_ASSUME_NONNULL_END\n\n", "comment_ratio": 0.13333333333333333}
{"lang": "c", "code": "#ifndef NAGI_UI_MSG_H\n#define NAGI_UI_MSG_H\n\nextern u8 *cmd_print(u8 *c);\nextern u8 *cmd_print_v(u8 *c);\nextern u8 *cmd_print_at(u8 *c);\nextern u8 *cmd_print_at_v(u8 *c);\nextern u8 *cmd_close_window(u8 *c);\nextern u8 *cmd_display(u8 *c);\nextern u8 *cmd_display_v(u8 *c);\n\nextern int message_box(const char *var8);\nextern void message_box_draw(const char *str, u16 row, u16 w, u16 toggle);\nextern char *str_wordwrap(char *msg, const char *str, u16 w);\nextern const char *logic_msg(u16 msg_num);\n\n\nstruct msgstate_struct\n{\n\t// writable settings --------------\n\t\n\t// wanted width and position.\n\tu16 wanted_width;\n\tTPOS wanted_pos;\n\t// related to hgc.. not really useful I don't think.\n\tu16 dialogue_open;\n\t// '\\' character.. if this exists then the next character is automatically put in.\n\t// it probably changes since the directories would be a bugger to print in save/restore functions\n\tchar newline_char;\t\t// 0x40 or 0x5c\n\t\n\t// internal settings ---------------------\n\t\n\t// visible == 1 window is displayed over picture buffer\n\t// visible == 0 no window is displayed\n\tu16 active;\n\t\n\t// text in messagebox\n\tTPOS tpos;\t\t// top left pos of text to display\n\tTPOS tpos_edge;\t// lower right pos of text to display\n\tAGISIZE tsize;\t\t// height and width of the text displayed\n\t\n\t// added by me.. Nick\n\tu16 printed_height;\t// the printed height.. for stretched msgs\n\t\n\t// background graphic (white with red border)\n\tPOS bgpos;\t\t// lower left position of bg\n\tAGISIZE bgsize;\t// size of bg\n};\ntypedef struct msgstate_struct MSGSTATE;\n\n#define HEIGHT_MAX 20\n#define LINE_SIZE 8\n\n//extern u16 dialogue_open;\n//extern u8 newline_char ;\t// 0x40 or 0x5c\n//extern TPOS msg_tpos;\n//extern TPOS msg_tpos_edge;\n\nextern MSGSTATE msgstate;\n\n#endif /* NAGI_UI_MSG_H */\n\n", "comment_ratio": 0.3548387096774194}
{"lang": "c", "code": "#import \"CDAVideoModelProtocal.h\"\n#import \"CDACamdoraMediaInfo.h\"\n\n@interface CDALocalMedia : NSObject<CDAVideoModelProtocal>\n///  \u56fe\u7247/\u89c6\u9891\u7684\u5b8c\u6574\u8def\u5f84\n@property (nonatomic,copy) NSString *mediaUrl;\n///  \u56fe\u7247\u5730\u5740\n@property (nonatomic,copy) NSString *thumbnailUrl;\n@property (nonatomic, copy)NSString *name;\n@property (nonatomic, copy)NSString *id;\n@property (nonatomic, strong)NSDate *createdAt;\n@property (nonatomic, assign)long long size;\n@property (nonatomic, assign)int duration;\n@property (nonatomic, copy)NSString *mediaType;//\u5217:Norma,Panorama,StereoHemisphere,StereoFlat,StereoPanorama\n@property (nonatomic, assign)int width;\n@property (nonatomic, assign)int height;\n@property (nonatomic, assign)BOOL isDrafted;\n@property (nonatomic, copy)NSString *title;\n@property (nonatomic, copy)NSString *videoDescription;\n///  \u533a\u5206\u56fe\u7247\u548c\u89c6\u9891 YES ==\u56fe\u7247  NO == \u89c6\u9891\n@property (nonatomic, assign)BOOL isPicture;\n// Camdora Media Info\n@property (nonatomic, assign)int camdoraMediaInfoCount;\n@property (nonatomic, assign)int camdoraMediaInfoHeight;\n@property (nonatomic, assign)int camdoraMediaInfoWidth;\n@property (nonatomic, assign)int camdoraMediaInfoFov;\n@property (nonatomic, assign)int camdoraMediaInfoOrder;\n@property (nonatomic, assign)int camdoraMediaInfoOrientation;\n@property (nonatomic, assign)int camdoraMediaInfoMount;\n@property (nonatomic, assign)int camdoraMediaInfoProjection;\n@property (nonatomic, assign)BOOL camdoraMediaInfoNeedStitch;\n@property (nonatomic, assign)int filterID;\n\n@property (nonatomic, copy)NSString *calibrationData;\n\n- (void) setCamdoraMediaInfo: (CDACamdoraMediaInfo *) camdoraMediaInfo;\n///  Camdora \u79c1\u6709Media Info\n@property (readonly) CDACamdoraMediaInfo *camdoraMediaInfo;\n- (BOOL) isVideo;\n\n@end\n\n", "comment_ratio": 0.26}
{"lang": "c", "code": "\r\n//a C++ version of sub-sequence DTW, which do the length normalization on the fly\r\n\r\n#include <infra.h>\r\n#include <math.h>\r\n#include <string>\r\n\r\n#define WINDOWSIZE 60\r\n#define STEP 5 \r\n#define LEN_PENALTY_DIAG 2\r\n\r\n// unterance-level mean variance normalization\r\n\r\n// smooth the distance matrix\r\nvoid smooth(const infra::matrix& dist, infra::matrix& sdist, int context = 1)\r\n{\r\n\r\n\tunsigned long nHeight = dist.height();\r\n\tunsigned long nWidth = dist.width();\r\n\r\n\tint length = 2*context + 1;\r\n\r\n\tfor (int i = 0; i < nHeight; i++)\r\n\t\tfor(int j = 0; j < nWidth; j++)\r\n\t\t{\r\n\t\t\tfloat sum = dist(i,j); \r\n\t\t\tfor (int k=1; k <= context; k++)\r\n\t\t\t{\r\n\t\t\t\tint ii = std::max(0,i-k);\r\n\t\t\t\tint jj = std::max(0,j-k);\r\n\t\t\t\tsum+=dist(ii,jj);\r\n\t\t\t\tii = std::min(int(nHeight-1),i+k);\r\n\t\t\t\tjj = std::min(int(nWidth-1),j+k);\r\n\t\t\t\tsum+=dist(ii,jj);\r\n\t\t\t}\r\n\t\t\tsdist(i,j) = sum/length;\r\n\t\t}\r\n\r\n}\r\n\r\n\r\nvoid mvn(infra::matrix& feature)\r\n{\r\n\tunsigned long nHeight = feature.height();\r\n\tunsigned long nWidth = feature.width();\r\n\r\n\tfor(int i = 0; i < nWidth; i++)\r\n\t{\r\n\t\tfloat mean = feature.column(i).sum()/nHeight;\t\r\n\t\tfeature.column(i) -= mean; // centralize\r\n\t    float std  = sqrt((feature.column(i)*feature.column(i))/nHeight);\r\n\t\tfeature.column(i) /= std;  \r\n\t\t\t\r\n\t}\r\n\r\n}\r\n\r\nvoid normalizeFea(infra::matrix& feature)\r\n{\r\n\tunsigned long nHeight = feature.height();\r\n\tunsigned long nWidth = feature.width();\r\n\r\n\tfor(int i = 0; i < nHeight; i++)\r\n\t{\r\n\t\tfloat sum=0;\r\n\t\tfor(int j = 0; j < nWidth; j++)\r\n\t\t\tsum += feature(i,j)*feature(i,j);\r\n\r\n\t    float mod = sqrt(sum);\t\r\n\t\tfor(int j = 0; j < nWidth; j++)\r\n\t        feature(i,j) /= mod;\t\r\n\t}\r\n}\r\n\r\nvoid computeDist( const infra::matrix& query, const infra::matrix& test, infra::matrix& dist_matrix, std::string featureType)\r\n{\r\n\tunsigned long nHeight = dist_matrix.height();\r\n\tunsigned long nWidth = dist_matrix.width();\r\n\t\r\n\tif(featureType == \"mfc\" || featureType == \"isa\"|| featureType == \"vtlnmfc\" || featureType == \"sbnf\")\r\n\t{\r\n\t\tinfra::prod_t(query,test,dist_matrix); // dist_matrix = query*test.T\r\n\r\n\t\tinfra::vector query_norm(query.height());\r\n\t\tfor(int i = 0; i < query.height(); i++)\r\n\t\t{\r\n\t\t\tfloat sum=0;\r\n\t\t\tfor(int j = 0; j < query.width();j++)\r\n\t\t\t{\r\n\t\t\t\tsum += query(i,j)*query(i,j);\r\n\t\t\t}\r\n\t\t\tquery_norm[i] = sqrt(sum);\r\n\t\t}\r\n\t  \r\n\t\tinfra::vector test_norm(test.height());\r\n\t\tfor(int i = 0; i < test.height(); i++)\r\n\t\t{\r\n\t\t\tfloat sum = 0;\r\n\t\t\tfor( int j = 0; j < test.width(); j++)\r\n\t\t\t{\r\n\t\t\t\tsum += test(i,j)*test(i,j);\r\n\t\t\t}\t\r\n\t\t\ttest_norm[i] = sqrt(sum);\r\n\t\t}\r\n\t\t\r\n\t\tfor( int i = 0; i < nHeight; i++)\r\n\t\t\tfor( int j = 0; j < nWidth;j++)\r\n\t\t\t{\r\n\t\t\t\tdist_matrix(i,j) = dist_matrix(i,j)/(query_norm[i]*test_norm[j]);\r\n\t\t\t}\r\n\r\n\t\tdist_matrix = 1 - dist_matrix;\r\n\t}\r\n\telse if(featureType==\"vtln_k_256_gpg\"||featureType==\"vtln_k_1024_gpg\" || featureType == \"enpg\" || featureType ==\"ruspg\"||featureType == \"czpg\"||featureType == \"hupg\") // \"pg\" denote any kind of posteriorgram.\r\n\t{\r\n\t\tinfra::prod_t(query,test,dist_matrix); // outcome = query*test.T\r\n\t\tdist_matrix =  0 - dist_matrix.log();      // outcome = -log(x.T*y)\r\n\t}\r\n\telse\r\n\t{\r\n\t\tstd::cout<<\"This type of feature representation is not supported\"<<std::endl;\r\n\t\texit(1);\r\n\t}\r\n\r\n// the so-called test normalization\t\r\n\tfor( int i = 0; i < nHeight; i++)\r\n\t{\r\n\t\tdouble dmin = dist_matrix.row(i).min();\r\n\t\tdouble dmax = dist_matrix.row(i).max();\r\n\t\tfor( int j = 0; j < nWidth;j++)\r\n\t\t{\r\n\t\t\tdist_matrix(i,j) = (dist_matrix(i,j)-dmin)/(dmax - dmin);\r\n\t\t}\r\n\t}\r\n\t\r\n}\r\n\r\n\r\nfloat subsequnceDTW(const infra::matrix& dist)\r\n{\r\n\tunsigned long nHeight = dist.height();\r\n\tunsigned long nWidth = dist.width();\r\n\tdouble min_cost = 1; // the maximum cost \r\n\r\n\tint window = ( (WINDOWSIZE > nHeight) ? nHeight : WINDOWSIZE );\r\n\r\n\tinfra::matrix avg_cost(window,nWidth);\r\n\tinfra::matrix cost(window,nWidth);\r\n\tinfra::matrix length(window,nWidth);\r\n\t\r\n\tfor(int start= 0; start + window - 1 < nHeight; start += STEP)\r\n\t{\r\n\t\tfor( int i = 0; i < nWidth; i++)\r\n\t\t{\r\n\t\t\tcost(0,i) = dist(start,i);\r\n\t\t\tlength(0,i) = 1;\r\n\t\t\tavg_cost(0,i) = cost(0,i);\r\n\t\t}\r\n\r\n\t\tfor( int i = 1; i < window; i++)\r\n\t\t{\r\n\t\t\tlength(i,0) = i+1;\r\n\t\t\tcost(i,0) = dist(start + i,0)+cost(i-1,0);\r\n\t\t\tavg_cost(i,0)= cost(i,0)/length(i,0);\r\n\t\t}\r\n\r\n\t// fill the three matrices in a dynamic programming style.\r\n\t\tfor( int i = 1; i < window; i++)\r\n\t\t\tfor( int j = 1; j < nWidth; j++)\r\n\t\t\t{\r\n\t\t\t\t// compute the three possible costs\r\n\t\t\t\tdouble cost_0 = dist(i + start,j )+cost(i-1,j);\r\n\t\t\t\tdouble cost_1 = dist(i + start,j )+cost(i,j-1);\r\n\t\t\t\tdouble cost_2 = dist(i + start,j )+cost(i-1,j-1);\r\n\t\t\t\tdouble avg_cost_0 = cost_0/(1+length(i-1,j));\r\n\t\t\t\tdouble avg_cost_1 = cost_1/(1+length(i,j-1));\r\n\t\t\t\tdouble avg_cost_2 = cost_2/(LEN_PENALTY_DIAG+length(i-1,j-1));\r\n\t\t\t\t\r\n\t\t\t\t// choose the one which lead to the minimum cost as the precedent point \r\n\t\t\t\tif(avg_cost_0 < avg_cost_1)\r\n\t\t\t\t{\r\n\t\t\t\t\tif(avg_cost_0 < avg_cost_2)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tavg_cost(i,j) = avg_cost_0;\r\n\t\t\t\t\t\tcost(i,j) = cost_0;\r\n\t\t\t\t\t\tlength(i,j) = 1 + length(i-1,j);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tavg_cost(i,j) = avg_cost_2;\r\n\t\t\t\t\t\tcost(i,j) = cost_2;\r\n\t\t\t\t\t\tlength(i,j) = LEN_PENALTY_DIAG + length(i-1,j-1);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse if(avg_cost_1 < avg_cost_2)\r\n\t\t\t\t{\r\n\t\t\t\t\tavg_cost(i,j) = avg_cost_1;\r\n\t\t\t\t\tcost(i,j) = cost_1;\r\n\t\t\t\t\tlength(i,j) = 1 + length(i,j-1);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tavg_cost(i,j) = avg_cost_2;\r\n\t\t\t\t\tcost(i,j) = cost_2;\r\n\t\t\t\t\tlength(i,j) = LEN_PENALTY_DIAG + length(i-1,j-1);\r\n\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t}\r\n\r\n\t\tmin_cost =std::min( avg_cost.row( window - 1 ).min(), min_cost );\r\n\r\n\r\n\t}\r\n\r\n// backtrack to find the alignment path, just used to debug.\t\r\n//\tunsigned index = avg_cost.row( nHeight - 1 ).argmin();\r\n//\tinfra::matrix path(nHeight+nWidth,2);\r\n//\r\n//\tunsigned i = nHeight -1;\r\n//\tunsigned j = index;\r\n//\tint p  = nHeight + nWidth -1;\r\n//\tint l = 0;\r\n//\tfor(;p>=0;p--)\r\n//\t{\r\n//\t\tpath(l,0)=i;\r\n//\t\tpath(l,1)=j;\r\n//\t\tl++;\r\n//\t\tif(i==0) break;\r\n//\t\tswitch(int(trace(i,j)))\r\n//\t\t{\r\n//\t\t\tcase 0: i--;break; // the precedent point is (i-1,j)\r\n//\t\t\tcase 1: j--;break; // the precedent point is (i,j-1)\r\n//\t\t\tdefault: i--;j--;  // the precedent point is (i-1,j-1)\r\n//\t\t}\r\n//\r\n//\t}\t\r\n//\r\n//\tpath.resize(l,2);\r\n//\tstd::cout<<path<<std::endl;\r\n//\r\n\r\n\treturn 1 - min_cost;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n", "comment_ratio": 0.1517509727626459}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n\n#import \"DWNavigationAppearance.h\"\n\nNS_ASSUME_NONNULL_BEGIN\n\n@class DWLocalCurrencyViewController;\n\n@protocol DWLocalCurrencyViewControllerDelegate <NSObject>\n\n- (void)localCurrencyViewController:(DWLocalCurrencyViewController *)controller\n                  didSelectCurrency:(NSString *)currencyCode;\n- (void)localCurrencyViewControllerDidCancel:(DWLocalCurrencyViewController *)controller;\n\n@end\n\n@interface DWLocalCurrencyViewController : UITableViewController\n\n@property (nullable, nonatomic, weak) id<DWLocalCurrencyViewControllerDelegate> delegate;\n@property (nonatomic, assign) BOOL isGlobal;\n\n- (instancetype)initWithNavigationAppearance:(DWNavigationAppearance)navigationAppearance\n                                currencyCode:(nullable NSString *)currencyCode;\n\n@end\n\nNS_ASSUME_NONNULL_END\n\n", "comment_ratio": 0.35555555555555557}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n#import \"VZFSizeRange.h\"\n#import \"VZFNodeProvider.h\"\n#import \"VZFStateUpdateMode.h\"\n\n\n@class VZFNodeHostingView;\n@class VZFNode;\n@class VZFluxStore;\n@protocol VZFNodeHostingView <NSObject>\n@optional\n- (void)hostingView:(VZFNodeHostingView* )view DidInvalidate:(CGSize )sz;\n\n@end\n\n/**\n *  HostingView\u7528\u6765\u627f\u8f7dRootNode\n *\n *  @discussion:\u5982\u679c\u9700\u8981\u8003\u8651view\u590d\u7528\u7684\u573a\u666f\uff0c\u4e0d\u5efa\u8bae\u4f7f\u7528hostingview\n *  tableView cell\u590d\u7528\u7684\u573a\u666f\u8bf7\u4f7f\u7528VZFNodeListItemRecycler\n *\n */\n@interface VZFNodeHostingView : UIView\n\n@property(nonatomic,weak)id<VZFNodeHostingView> delegate;\n@property(nonatomic,weak)VZFluxStore* store;\n@property(nonatomic,assign)BOOL shouldResize;\n\n\n- (id)initWithNodeProvider:(Class<VZFNodeProvider>)nodeProvider RangeType:(VZFSizeRange)rangeType;\n- (void)update:(id)model context:(id)context;\n- (void)updateState;\n- (void)reset;\n\n- (instancetype)init __attribute__((unavailable(\"Not the designated initializer\")));\n- (instancetype)initWithFrame:(CGRect)frame __attribute__((unavailable(\"Not the designated initializer\")));\n\n\n@end\n\n", "comment_ratio": 0.14583333333333334}
{"lang": "c", "code": "#ifndef EXAMPLE_H_INCLUDED\r\n#define EXAMPLE_H_INCLUDED\r\n\r\n#include <string>\r\n\r\nstd::string example();\r\n\r\n#endif // EXAMPLE_H_INCLUDED\n", "comment_ratio": 0.125}
{"lang": "c", "code": "//  CDC code from https://github.com/Apress/Beg-STM32-Devel-FreeRTOS-libopencm3-GCC/blob/master/rtos/usbcdcdemo/usbcdc.c\n#include <libopencm3/usb/usbd.h>\n#include <libopencm3/usb/cdc.h>\n#include \"usb_conf.h\"\n#include \"cdc.h\"\n\n#define CONTROL_CALLBACK_TYPE (USB_REQ_TYPE_CLASS | USB_REQ_TYPE_INTERFACE)\n#define CONTROL_CALLBACK_MASK (USB_REQ_TYPE_TYPE | USB_REQ_TYPE_RECIPIENT)\n#define USB_CDC_REQ_GET_LINE_CODING\t\t0x21\n\n//  Line config to be returned.\nstatic const struct usb_cdc_line_coding line_coding = {\n\t.dwDTERate = 115200,\n\t.bCharFormat = USB_CDC_1_STOP_BITS,\n\t.bParityType = USB_CDC_NO_PARITY,\n\t.bDataBits = 0x08\n};\n\ncdc_receive_callback receive_callback = NULL;\nusbd_device* transmit_device = NULL;\nvolatile bool cdc_sending = false;\n\nint cdcacm_control_request(\n  usbd_device *usbd_dev __attribute__((unused)),\n  struct usb_setup_data *req,\n  uint8_t **buf __attribute__((unused)),\n  uint16_t *len,\n  void (**complete)(\n    usbd_device *usbd_dev,\n    struct usb_setup_data *req\n  ) __attribute__((unused))\n) {\n\t//  Handle USB Control Requests\n\t//  dump_usb_request(\"*** cdc\", req); ////\n\tswitch (req->bRequest) {\n\t\tcase USB_CDC_REQ_SET_CONTROL_LINE_STATE: {\n\t\t\t/* From https://github.com/libopencm3/libopencm3-examples/blob/master/examples/stm32/f3/stm32f3-discovery/usb_cdcacm/cdcacm.c\n\t\t\t* This Linux cdc_acm driver requires this to be implemented\n\t\t\t* even though it's optional in the CDC spec, and we don't\n\t\t\t* advertise it in the ACM functional descriptor. */\n#ifdef NOTUSED\n\t\t\tchar local_buf[10];\n\t\t\tstruct usb_cdc_notification *notif = (void *)local_buf;\n\n\t\t\t/* We echo signals back to host as notification. */\n\t\t\tnotif->bmRequestType = 0xA1;\n\t\t\tnotif->bNotification = USB_CDC_NOTIFY_SERIAL_STATE;\n\t\t\tnotif->wValue = 0;\n\t\t\tnotif->wIndex = 0;\n\t\t\tnotif->wLength = 2;\n\t\t\tlocal_buf[8] = req->wValue & 3;\n\t\t\tlocal_buf[9] = 0;\n\t\t\t// usbd_ep_write_packet(0x83, buf, 10);\n#endif  //  NOTUSED\n\t\t\treturn USBD_REQ_HANDLED;\n\t\t}\n\t\tcase USB_CDC_REQ_GET_LINE_CODING: {\n\t\t\t//  Windows requires this request, not Mac or Linux.\n\t\t\t//  From https://github.com/PX4/Bootloader/blob/master/stm32/cdcacm.c\n\t\t\tif ( *len < sizeof(struct usb_cdc_line_coding) ) {\n\t\t\t\tdebug_print(\"*** cdcacm_control notsupp line_coding \"); debug_print_unsigned(sizeof(struct usb_cdc_line_coding)); \n\t\t\t\tdebug_print(\", len \"); debug_print_unsigned(*len);\n\t\t\t\tdebug_println(\"\"); debug_flush(); ////\n\t\t\t\treturn USBD_REQ_NOTSUPP;\n\t\t\t}\n\t\t\t*buf = (uint8_t *) &line_coding;\n\t\t\t*len = sizeof(struct usb_cdc_line_coding);\n\t\t\treturn USBD_REQ_HANDLED;\n\t\t}\n\t\tcase USB_CDC_REQ_SET_LINE_CODING: {\n\t\t\tif ( *len < sizeof(struct usb_cdc_line_coding) ) {\n\t\t\t\tdebug_print(\"*** cdcacm_control notsupp line_coding \"); debug_print_unsigned(sizeof(struct usb_cdc_line_coding)); \n\t\t\t\tdebug_print(\", len \"); debug_print_unsigned(*len);\n\t\t\t\tdebug_println(\"\"); debug_flush(); ////\n\t\t\t\treturn USBD_REQ_NOTSUPP;\n\t\t\t}\n\t\t\treturn USBD_REQ_HANDLED;\n\t\t}\n\t}\n\t//  dump_usb_request(\"*** cdc next\", req); ////\n\treturn USBD_REQ_NEXT_CALLBACK;  //  Previously USBD_REQ_NOTSUPP\n}\n\n//  TODO: TX Up to MAX_USB_PACKET_SIZE\n//  usbd_ep_write_packet(usbd_dev, DATA_IN, txbuf, txlen)\n\nstatic char cdcbuf[MAX_USB_PACKET_SIZE + 1];   // rx buffer\n\n/*\n * USB Receive Callback:\n */\nstatic void\ncdcacm_data_rx_cb(\n  usbd_device *usbd_dev,\n  uint8_t ep __attribute__((unused))\n) {\n\tuint16_t len = usbd_ep_read_packet(usbd_dev, DATA_OUT, cdcbuf, MAX_USB_PACKET_SIZE);\n    if (len == 0) { return; }\n    uint16_t pos = (len < MAX_USB_PACKET_SIZE) ? len : MAX_USB_PACKET_SIZE;\n    cdcbuf[pos] = 0;\n\n//\tusbd_ep_write_packet(usbd_dev, DATA_IN, cdcbuf, pos); ////  Echo the packet.\n\t\n//    debug_print(\"[\"); debug_println(cdcbuf); debug_print(\"]\"); // debug_flush(); ////\n//dbg(cdcbuf);\n  if (receive_callback)\n    receive_callback((uint8_t*)cdcbuf, pos);\n}\n\nstatic void cdcacm_data_tx_cb(usbd_device *usbd_dev, uint8_t ep)\n{\n  cdc_sending = false;\n}\n\nstatic void\ncdcacm_comm_cb(\n  usbd_device *usbd_dev,\n  uint8_t ep __attribute__((unused))) \n{\n// TODO: toto tu nema byt!!!\n//  cdc_sending = false;\n}\n\n/*\n * USB Configuration:\n */\nstatic void\ncdcacm_set_config(\n  usbd_device *usbd_dev,\n  uint16_t wValue __attribute__((unused))\n) {\n\t//  From https://github.com/libopencm3/libopencm3-examples/blob/master/examples/stm32/f3/stm32f3-discovery/usb_cdcacm/cdcacm.c\n    //  debug_println(\"*** cdcacm_set_config\"); ////\n\tusbd_ep_setup(usbd_dev, DATA_OUT, USB_ENDPOINT_ATTR_BULK, MAX_USB_PACKET_SIZE, cdcacm_data_rx_cb);\n\tusbd_ep_setup(usbd_dev, DATA_IN, USB_ENDPOINT_ATTR_BULK, MAX_USB_PACKET_SIZE, cdcacm_data_tx_cb);\n\tusbd_ep_setup(usbd_dev, COMM_IN, USB_ENDPOINT_ATTR_INTERRUPT, COMM_PACKET_SIZE, cdcacm_comm_cb);\n\tint status = aggregate_register_callback(\n\t\tusbd_dev,\n\t\tCONTROL_CALLBACK_TYPE,\n\t\tCONTROL_CALLBACK_MASK,\n\t\tcdcacm_control_request);\n\n\tif (status < 0) { debug_println(\"*** cdcacm_set_config failed\"); debug_flush(); }\n}\n\nvoid cdc_setup(usbd_device* usbd_dev) {\n    //  debug_println(\"*** cdc_setup\"); ////\n\tint status = aggregate_register_config_callback(usbd_dev, cdcacm_set_config);\n\tif (status < 0) { debug_println(\"*** cdc_setup failed\"); debug_flush(); }\n  transmit_device = usbd_dev;\n}\n\nvoid cdc_set_receive_callback(cdc_receive_callback callback)\n{\n  receive_callback = callback;\n}\n\nvoid cdc_yield()\n{\n}\n\nbool cdc_waitSync()\n{\n  for (uint32_t i=0; i<100000; i++) \n  {\n    if (!cdc_sending)\n      return true;\n    cdc_yield();\n  }\n  return false;\n}\n\nbool cdc_transmit(uint8_t* buffer, int len)\n{\n  if (!cdc_waitSync())\n  {\n    // handle unreceived transmission\n    return false;\n  }\n\n  cdc_sending = true;\n  usbd_ep_write_packet(transmit_device, DATA_IN, buffer, len);\n  return true;\n}\n\n", "comment_ratio": 0.13513513513513514}
{"lang": "c", "code": "\ufeff#pragma once\n\n#include \"il2cpp-config.h\"\n\n#ifndef _MSC_VER\n# include <alloca.h>\n#else\n# include <malloc.h>\n#endif\n\n#include <stdint.h>\n#include <assert.h>\n#include <exception>\n\n// System.ArgumentOutOfRangeException\nstruct ArgumentOutOfRangeException_t279959794;\n// System.String\nstruct String_t;\n// System.Object\nstruct Il2CppObject;\n// System.Runtime.Serialization.SerializationInfo\nstruct SerializationInfo_t228987430;\n\n#include \"codegen/il2cpp-codegen.h\"\n#include \"mscorlib_System_String2029220233.h\"\n#include \"mscorlib_System_Object2689449295.h\"\n#include \"mscorlib_System_Runtime_Serialization_Serialization228987430.h\"\n#include \"mscorlib_System_Runtime_Serialization_StreamingCon1417235061.h\"\n\n// System.Void System.ArgumentOutOfRangeException::.ctor()\nextern \"C\"  void ArgumentOutOfRangeException__ctor_m15523695 (ArgumentOutOfRangeException_t279959794 * __this, const MethodInfo* method) IL2CPP_METHOD_ATTR;\n// System.Void System.ArgumentOutOfRangeException::.ctor(System.String)\nextern \"C\"  void ArgumentOutOfRangeException__ctor_m1595007065 (ArgumentOutOfRangeException_t279959794 * __this, String_t* ___paramName0, const MethodInfo* method) IL2CPP_METHOD_ATTR;\n// System.Void System.ArgumentOutOfRangeException::.ctor(System.String,System.String)\nextern \"C\"  void ArgumentOutOfRangeException__ctor_m4234257711 (ArgumentOutOfRangeException_t279959794 * __this, String_t* ___paramName0, String_t* ___message1, const MethodInfo* method) IL2CPP_METHOD_ATTR;\n// System.Void System.ArgumentOutOfRangeException::.ctor(System.String,System.Object,System.String)\nextern \"C\"  void ArgumentOutOfRangeException__ctor_m4090631565 (ArgumentOutOfRangeException_t279959794 * __this, String_t* ___paramName0, Il2CppObject * ___actualValue1, String_t* ___message2, const MethodInfo* method) IL2CPP_METHOD_ATTR;\n// System.Void System.ArgumentOutOfRangeException::.ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)\nextern \"C\"  void ArgumentOutOfRangeException__ctor_m2861707692 (ArgumentOutOfRangeException_t279959794 * __this, SerializationInfo_t228987430 * ___info0, StreamingContext_t1417235061  ___context1, const MethodInfo* method) IL2CPP_METHOD_ATTR;\n// System.String System.ArgumentOutOfRangeException::get_Message()\nextern \"C\"  String_t* ArgumentOutOfRangeException_get_Message_m741913712 (ArgumentOutOfRangeException_t279959794 * __this, const MethodInfo* method) IL2CPP_METHOD_ATTR;\n// System.Void System.ArgumentOutOfRangeException::GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)\nextern \"C\"  void ArgumentOutOfRangeException_GetObjectData_m2398419311 (ArgumentOutOfRangeException_t279959794 * __this, SerializationInfo_t228987430 * ___info0, StreamingContext_t1417235061  ___context1, const MethodInfo* method) IL2CPP_METHOD_ATTR;\n\n", "comment_ratio": 0.25}
{"lang": "c", "code": "#ifndef CLASS_NIFS_C_FACE_BND_WALL_DIR_PRES_H\r\n#define CLASS_NIFS_C_FACE_BND_WALL_DIR_PRES_H\r\n\r\n#include \"face_bnd_wall.h\"\r\n\r\nnamespace NIFS{    \r\n\r\n//--- INTERFACE ---\r\n\r\nclass c_face_bnd_wall_dir_pres : public c_face_bnd_wall {\r\n\tpublic:\r\n\t\tc_face_bnd_wall_dir_pres();\r\n\t\tvirtual ~c_face_bnd_wall_dir_pres() {}\r\n\r\n\tprotected:\r\n\t\tvirtual void calc_coef_1();\r\n\t\tvirtual void calc_coef_c();\r\n\t\tvirtual void calc_bc();\r\n\t\tvirtual void calc_state();\r\n};\r\n\r\n} //--- namespace NIFS\r\n\r\n#endif //--- CLASS_NIFS_C_FACE_BND_WALL_DIR_PRES_H\r\n\r\n\n", "comment_ratio": 0.2571428571428571}
{"lang": "c", "code": "#ifndef BROWSER_DEVTOOLS_NETWORK_CONDITIONS_H_\n#define BROWSER_DEVTOOLS_NETWORK_CONDITIONS_H_\n\n#include <string>\n#include <vector>\n\n#include \"base/macros.h\"\n#include \"url/gurl.h\"\n\nnamespace brightray {\n\nclass DevToolsNetworkConditions {\n public:\n  explicit DevToolsNetworkConditions(bool offline);\n  DevToolsNetworkConditions(bool offline,\n                            double latency,\n                            double download_throughput,\n                            double upload_throughput);\n  ~DevToolsNetworkConditions();\n\n  bool IsThrottling() const;\n\n  bool offline() const { return offline_; }\n  double latency() const { return latency_; }\n  double download_throughput() const { return download_throughput_; }\n  double upload_throughput() const { return upload_throughput_; }\n\n private:\n  const bool offline_;\n  const double latency_;\n  const double download_throughput_;\n  const double upload_throughput_;\n\n  DISALLOW_COPY_AND_ASSIGN(DevToolsNetworkConditions);\n};\n\n}  // namespace brightray\n\n#endif  // BROWSER_DEVTOOLS_NETWORK_CONDITIONS_H_\n\n", "comment_ratio": 0.11363636363636363}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n#import \"MultilevelTableDataModel.h\"\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface MultilevelTableDataManager : NSObject\n\n@property (nonatomic, strong) NSMutableArray <NSMutableArray<MultilevelTableDataModel *>*>* dataSource;\n@property (nonatomic, assign) NSInteger currentSection;\n\n- (void)configDataSource;\n- (void)updateDataWithModel:(MultilevelTableDataModel *)model;\n\n@end\n\nNS_ASSUME_NONNULL_END\n\n", "comment_ratio": 0.28}
{"lang": "c", "code": "#import <LunaKit/LKTableView.h>\n\n@interface LKKeyDetailTable : LKTableView\n{\n}\n\n- (void)_drawDropHighlightOffScreenIndicatorPointingUp:(BOOL)arg1 atOffset:(double)arg2;\n- (void)draggingExited:(id)arg1;\n- (void)draggedImage:(id)arg1 movedTo:(struct CGPoint)arg2;\n- (unsigned long long)draggingEntered:(id)arg1;\n- (BOOL)_validDropLocation:(struct CGPoint)arg1;\n- (void)draggedImage:(id)arg1 endedAt:(struct CGPoint)arg2 operation:(unsigned long long)arg3;\n- (id)dragImageForRowsWithIndexes:(id)arg1 tableColumns:(id)arg2 event:(id)arg3 offset:(struct CGPoint *)arg4;\n\n@end\n\n\n", "comment_ratio": 0.21739130434782608}
{"lang": "c", "code": "\ufeff#pragma once\n\n#include \"il2cpp-config.h\"\n\n#ifndef _MSC_VER\n# include <alloca.h>\n#else\n# include <malloc.h>\n#endif\n\n#include <stdint.h>\n#include <assert.h>\n#include <exception>\n\n\n#include \"codegen/il2cpp-codegen.h\"\n#include \"mscorlib_System_Collections_Generic_Dictionary_2_V2868685323MethodDeclarations.h\"\n\n// System.Void System.Collections.Generic.Dictionary`2/ValueCollection<System.Int32,UnityEngine.EventSystems.PointerEventData>::.ctor(System.Collections.Generic.Dictionary`2<TKey,TValue>)\n#define ValueCollection__ctor_m2765697613(__this, ___dictionary0, method) ((  void (*) (ValueCollection_t546619975 *, Dictionary_2_t1846014262 *, const MethodInfo*))ValueCollection__ctor_m30082295_gshared)(__this, ___dictionary0, method)\n// System.Void System.Collections.Generic.Dictionary`2/ValueCollection<System.Int32,UnityEngine.EventSystems.PointerEventData>::System.Collections.Generic.ICollection<TValue>.Add(TValue)\n#define ValueCollection_System_Collections_Generic_ICollectionU3CTValueU3E_Add_m3560901701(__this, ___item0, method) ((  void (*) (ValueCollection_t546619975 *, PointerEventData_t1848751023 *, const MethodInfo*))ValueCollection_System_Collections_Generic_ICollectionU3CTValueU3E_Add_m701709403_gshared)(__this, ___item0, method)\n// System.Void System.Collections.Generic.Dictionary`2/ValueCollection<System.Int32,UnityEngine.EventSystems.PointerEventData>::System.Collections.Generic.ICollection<TValue>.Clear()\n#define ValueCollection_System_Collections_Generic_ICollectionU3CTValueU3E_Clear_m3955745678(__this, method) ((  void (*) (ValueCollection_t546619975 *, const MethodInfo*))ValueCollection_System_Collections_Generic_ICollectionU3CTValueU3E_Clear_m3824389796_gshared)(__this, method)\n// System.Boolean System.Collections.Generic.Dictionary`2/ValueCollection<System.Int32,UnityEngine.EventSystems.PointerEventData>::System.Collections.Generic.ICollection<TValue>.Contains(TValue)\n#define ValueCollection_System_Collections_Generic_ICollectionU3CTValueU3E_Contains_m1874542533(__this, ___item0, method) ((  bool (*) (ValueCollection_t546619975 *, PointerEventData_t1848751023 *, const MethodInfo*))ValueCollection_System_Collections_Generic_ICollectionU3CTValueU3E_Contains_m91415663_gshared)(__this, ___item0, method)\n// System.Boolean System.Collections.Generic.Dictionary`2/ValueCollection<System.Int32,UnityEngine.EventSystems.PointerEventData>::System.Collections.Generic.ICollection<TValue>.Remove(TValue)\n#define ValueCollection_System_Collections_Generic_ICollectionU3CTValueU3E_Remove_m427525546(__this, ___item0, method) ((  bool (*) (ValueCollection_t546619975 *, PointerEventData_t1848751023 *, const MethodInfo*))ValueCollection_System_Collections_Generic_ICollectionU3CTValueU3E_Remove_m4014492884_gshared)(__this, ___item0, method)\n// System.Collections.Generic.IEnumerator`1<TValue> System.Collections.Generic.Dictionary`2/ValueCollection<System.Int32,UnityEngine.EventSystems.PointerEventData>::System.Collections.Generic.IEnumerable<TValue>.GetEnumerator()\n#define ValueCollection_System_Collections_Generic_IEnumerableU3CTValueU3E_GetEnumerator_m3055078606(__this, method) ((  Il2CppObject* (*) (ValueCollection_t546619975 *, const MethodInfo*))ValueCollection_System_Collections_Generic_IEnumerableU3CTValueU3E_GetEnumerator_m4048472420_gshared)(__this, method)\n// System.Void System.Collections.Generic.Dictionary`2/ValueCollection<System.Int32,UnityEngine.EventSystems.PointerEventData>::System.Collections.ICollection.CopyTo(System.Array,System.Int32)\n#define ValueCollection_System_Collections_ICollection_CopyTo_m3432639250(__this, ___array0, ___index1, method) ((  void (*) (ValueCollection_t546619975 *, Il2CppArray *, int32_t, const MethodInfo*))ValueCollection_System_Collections_ICollection_CopyTo_m1511207592_gshared)(__this, ___array0, ___index1, method)\n// System.Collections.IEnumerator System.Collections.Generic.Dictionary`2/ValueCollection<System.Int32,UnityEngine.EventSystems.PointerEventData>::System.Collections.IEnumerable.GetEnumerator()\n#define ValueCollection_System_Collections_IEnumerable_GetEnumerator_m2846545057(__this, method) ((  Il2CppObject * (*) (ValueCollection_t546619975 *, const MethodInfo*))ValueCollection_System_Collections_IEnumerable_GetEnumerator_m3055859895_gshared)(__this, method)\n// System.Boolean System.Collections.Generic.Dictionary`2/ValueCollection<System.Int32,UnityEngine.EventSystems.PointerEventData>::System.Collections.Generic.ICollection<TValue>.get_IsReadOnly()\n#define ValueCollection_System_Collections_Generic_ICollectionU3CTValueU3E_get_IsReadOnly_m149718392(__this, method) ((  bool (*) (ValueCollection_t546619975 *, const MethodInfo*))ValueCollection_System_Collections_Generic_ICollectionU3CTValueU3E_get_IsReadOnly_m2661558818_gshared)(__this, method)\n// System.Boolean System.Collections.Generic.Dictionary`2/ValueCollection<System.Int32,UnityEngine.EventSystems.PointerEventData>::System.Collections.ICollection.get_IsSynchronized()\n#define ValueCollection_System_Collections_ICollection_get_IsSynchronized_m2813673304(__this, method) ((  bool (*) (ValueCollection_t546619975 *, const MethodInfo*))ValueCollection_System_Collections_ICollection_get_IsSynchronized_m3650032386_gshared)(__this, method)\n// System.Object System.Collections.Generic.Dictionary`2/ValueCollection<System.Int32,UnityEngine.EventSystems.PointerEventData>::System.Collections.ICollection.get_SyncRoot()\n#define ValueCollection_System_Collections_ICollection_get_SyncRoot_m3129356618(__this, method) ((  Il2CppObject * (*) (ValueCollection_t546619975 *, const MethodInfo*))ValueCollection_System_Collections_ICollection_get_SyncRoot_m179750644_gshared)(__this, method)\n// System.Void System.Collections.Generic.Dictionary`2/ValueCollection<System.Int32,UnityEngine.EventSystems.PointerEventData>::CopyTo(TValue[],System.Int32)\n#define ValueCollection_CopyTo_m2164001620(__this, ___array0, ___index1, method) ((  void (*) (ValueCollection_t546619975 *, PointerEventDataU5BU5D_t1428124854*, int32_t, const MethodInfo*))ValueCollection_CopyTo_m1295975294_gshared)(__this, ___array0, ___index1, method)\n// System.Collections.Generic.Dictionary`2/ValueCollection/Enumerator<TKey,TValue> System.Collections.Generic.Dictionary`2/ValueCollection<System.Int32,UnityEngine.EventSystems.PointerEventData>::GetEnumerator()\n#define ValueCollection_GetEnumerator_m2405991206(__this, method) ((  Enumerator_t4072814966  (*) (ValueCollection_t546619975 *, const MethodInfo*))ValueCollection_GetEnumerator_m848222311_gshared)(__this, method)\n// System.Int32 System.Collections.Generic.Dictionary`2/ValueCollection<System.Int32,UnityEngine.EventSystems.PointerEventData>::get_Count()\n#define ValueCollection_get_Count_m2117322642(__this, method) ((  int32_t (*) (ValueCollection_t546619975 *, const MethodInfo*))ValueCollection_get_Count_m2227591228_gshared)(__this, method)\n\n", "comment_ratio": 0.2978723404255319}
{"lang": "c", "code": "/*\n * File: ipc.h \n *\n * Description:\n *     IPC - ( Inter-Process Comunication ). \n *     ring 0\n *     \n * History:\n *     2015 - Created by Fred Nora.\n */\n\n\n#ifndef  ____IPC_H\n#define ____IPC_H\n\n\n// #todo\n// Use those structures.\n\n\n/*\nstruct ipc_message_d\n{\n    void *window;   // Fake in ring0.\n    int msg;\n    unsigned long long1;\n    unsigned long long2;\n    \n    void *buffer;\n    size_t buffer_size;\n    \n    struct ipc_message_d *next;\n};\n\nstruct ipc_port_d\n{\n    int id;\n    int used;\n    int magic;\n     \n    char *name;\n    \n    struct process_d *process;\n    \n    struct ipc_message_d *msg;\n\n    struct ipc_port_d *next;\n};\n\nunsigned long ipcportList[32];\n*/\n\n    \n    \n\nvoid ipc_send_message_to_process ( unsigned long msg_buffer, int pid );\nvoid ipc_send_message_to_thread ( unsigned long msg_buffer, int tid );\nint ipc_init (void);\n\n\n#endif    //____IPC_H\n\n\n//\n// End.\n//\n\n\n", "comment_ratio": 0.10294117647058823}
{"lang": "c", "code": "//\n//  CommentController.h\n//  StarClub\n//\n//  Created by MAYA on 1/3/14.\n//\n//\n\n#import \"BaseViewController.h\"\n\n@protocol CommentControllerDelegate\n\n- (void) commentDone:(int) index comments:(NSArray*) arrComment;\n\n@end\n\n\n@interface CommentController : BaseViewController<UITextViewDelegate>\n{\n    IBOutlet UIView * viewSend;\n    IBOutlet UITextView * txtPost;\n    IBOutlet UIImageView * imgAvatar;\n    \n    BOOL    keyboardVisible;\n\n}\n\n@property (nonatomic, strong) id<CommentControllerDelegate> delegate;\n\n\n-(id) initWithData:(NSDictionary*) dic index:(int) index;\n-(id) initWithAddComment:(NSDictionary*) dic index:(int) index;\n\n\n@end\n\n", "comment_ratio": 0.19444444444444445}
{"lang": "c", "code": "#ifndef QTEXTOBJECT_P_H\n#define QTEXTOBJECT_P_H\n\n//\n//  W A R N I N G\n//  -------------\n//\n// This file is not part of the Qt API.  It exists for the convenience\n// of other Qt classes.  This header file may change from version to\n// version without notice, or even be removed.\n//\n// We mean it.\n//\n\n#include <QtGui/private/qtguiglobal_p.h>\n#include \"QtGui/qtextobject.h\"\n#include \"private/qobject_p.h\"\n#include \"QtGui/qtextdocument.h\"\n\nQT_BEGIN_NAMESPACE\n\nclass QTextDocumentPrivate;\n\nclass QTextObjectPrivate : public QObjectPrivate\n{\n    Q_DECLARE_PUBLIC(QTextObject)\npublic:\n    QTextObjectPrivate(QTextDocument *doc)\n        : pieceTable(doc->d_func()), objectIndex(-1)\n    {\n    }\n    QTextDocumentPrivate *pieceTable;\n    int objectIndex;\n};\n\nclass QTextBlockGroupPrivate : public QTextObjectPrivate\n{\n    Q_DECLARE_PUBLIC(QTextBlockGroup)\npublic:\n    QTextBlockGroupPrivate(QTextDocument *doc)\n        : QTextObjectPrivate(doc)\n    {\n    }\n    typedef QList<QTextBlock> BlockList;\n    BlockList blocks;\n    void markBlocksDirty();\n};\n\nclass QTextFrameLayoutData;\n\nclass QTextFramePrivate : public QTextObjectPrivate\n{\n    friend class QTextDocumentPrivate;\n    Q_DECLARE_PUBLIC(QTextFrame)\npublic:\n    QTextFramePrivate(QTextDocument *doc)\n        : QTextObjectPrivate(doc), fragment_start(0), fragment_end(0), parentFrame(0), layoutData(0)\n    {\n    }\n    virtual void fragmentAdded(QChar type, uint fragment);\n    virtual void fragmentRemoved(QChar type, uint fragment);\n    void remove_me();\n\n    uint fragment_start;\n    uint fragment_end;\n\n    QTextFrame *parentFrame;\n    QList<QTextFrame *> childFrames;\n    QTextFrameLayoutData *layoutData;\n};\n\nQT_END_NAMESPACE\n\n#endif // QTEXTOBJECT_P_H\n\n", "comment_ratio": 0.14912280701754385}
{"lang": "c", "code": "#ifndef CHROME_BROWSER_UI_ASH_APP_LIST_APP_LIST_PRESENTER_DELEGATE_MUS_H_\n#define CHROME_BROWSER_UI_ASH_APP_LIST_APP_LIST_PRESENTER_DELEGATE_MUS_H_\n\n#include \"base/macros.h\"\n#include \"ui/app_list/presenter/app_list_presenter_delegate.h\"\n#include \"ui/views/pointer_watcher.h\"\n\nnamespace app_list {\nclass AppListPresenterImpl;\nclass AppListView;\nclass AppListViewDelegateFactory;\n}  // namespace app_list\n\n// Mus+ash implementation of AppListPresetnerDelegate.\n// Responsible for laying out the app list UI as well as dismissing the app list\n// on in response to certain events (e.g. on mouse/touch gesture outside of the\n// app list bounds).\nclass AppListPresenterDelegateMus : public app_list::AppListPresenterDelegate,\n                                    public views::PointerWatcher {\n public:\n  AppListPresenterDelegateMus(\n      app_list::AppListPresenterImpl* presenter,\n      app_list::AppListViewDelegateFactory* view_delegate_factory);\n  ~AppListPresenterDelegateMus() override;\n\n  // app_list::AppListPresenterDelegate:\n  app_list::AppListViewDelegate* GetViewDelegate() override;\n  void Init(app_list::AppListView* view,\n            int64_t display_id,\n            int current_apps_page) override;\n  void OnShown(int64_t display_id) override;\n  void OnDismissed() override;\n  void UpdateBounds() override;\n  gfx::Vector2d GetVisibilityAnimationOffset(\n      aura::Window* root_window) override;\n\n private:\n  // views::PointerWatcher:\n  void OnPointerEventObserved(const ui::PointerEvent& event,\n                              const gfx::Point& location_in_screen,\n                              views::Widget* target) override;\n\n  // Not owned. Pointer is guaranteed to be valid while this object is alive.\n  app_list::AppListPresenterImpl* presenter_;\n\n  // Not owned. Pointer is guaranteed to be valid while this object is alive.\n  app_list::AppListViewDelegateFactory* view_delegate_factory_;\n\n  // The current AppListView, owned by its widget.\n  app_list::AppListView* view_ = nullptr;\n\n  DISALLOW_COPY_AND_ASSIGN(AppListPresenterDelegateMus);\n};\n\n#endif  // CHROME_BROWSER_UI_ASH_APP_LIST_APP_LIST_PRESENTER_DELEGATE_MUS_H_\n\n", "comment_ratio": 0.23333333333333334}
{"lang": "c", "code": "#ifndef DAWNNATIVE_OPENGLBACKEND_H_\n#define DAWNNATIVE_OPENGLBACKEND_H_\n\ntypedef void* EGLImage;\n\n#include <dawn/dawn_wsi.h>\n#include <dawn_native/DawnNative.h>\n\nnamespace dawn_native { namespace opengl {\n\n    struct DAWN_NATIVE_EXPORT AdapterDiscoveryOptions : public AdapterDiscoveryOptionsBase {\n        AdapterDiscoveryOptions();\n\n        void* (*getProc)(const char*);\n    };\n\n    struct DAWN_NATIVE_EXPORT AdapterDiscoveryOptionsES : public AdapterDiscoveryOptionsBase {\n        AdapterDiscoveryOptionsES();\n\n        void* (*getProc)(const char*);\n    };\n\n    using PresentCallback = void (*)(void*);\n    DAWN_NATIVE_EXPORT DawnSwapChainImplementation\n    CreateNativeSwapChainImpl(WGPUDevice device, PresentCallback present, void* presentUserdata);\n    DAWN_NATIVE_EXPORT WGPUTextureFormat\n    GetNativeSwapChainPreferredFormat(const DawnSwapChainImplementation* swapChain);\n\n    struct DAWN_NATIVE_EXPORT ExternalImageDescriptorEGLImage : ExternalImageDescriptor {\n      public:\n        ExternalImageDescriptorEGLImage();\n\n        ::EGLImage image;\n    };\n\n    DAWN_NATIVE_EXPORT WGPUTexture\n    WrapExternalEGLImage(WGPUDevice device, const ExternalImageDescriptorEGLImage* descriptor);\n\n}}  // namespace dawn_native::opengl\n\n#endif  // DAWNNATIVE_OPENGLBACKEND_H_\n\n", "comment_ratio": 0.26785714285714285}
{"lang": "c", "code": "#import \"WAReportBaseItem.h\"\n\n@class NSString;\n\n@interface WAReportPageFrameInjectItem : WAReportBaseItem\n{\n    _Bool _isFromTaskPreload;\n    unsigned int _appServiceType;\n    int _injectCostTime;\n    unsigned int _pageFrameLength;\n    NSString *_instanceId;\n    unsigned long long _injectStartTime;\n    unsigned long long _injectEndTime;\n    NSString *_moduleName;\n}\n\n@property(nonatomic) _Bool isFromTaskPreload; // @synthesize isFromTaskPreload=_isFromTaskPreload;\n@property(nonatomic) unsigned int pageFrameLength; // @synthesize pageFrameLength=_pageFrameLength;\n@property(copy, nonatomic) NSString *moduleName; // @synthesize moduleName=_moduleName;\n@property(nonatomic) unsigned long long injectEndTime; // @synthesize injectEndTime=_injectEndTime;\n@property(nonatomic) unsigned long long injectStartTime; // @synthesize injectStartTime=_injectStartTime;\n@property(nonatomic) int injectCostTime; // @synthesize injectCostTime=_injectCostTime;\n@property(nonatomic) unsigned int appServiceType; // @synthesize appServiceType=_appServiceType;\n@property(copy, nonatomic) NSString *instanceId; // @synthesize instanceId=_instanceId;\n- (void).cxx_destruct;\n- (id)reportString;\n- (int)reportID;\n\n@end\n\n\n", "comment_ratio": 0.35135135135135137}
{"lang": "c", "code": "\ufeff#ifndef _IPL_EXECUTE_H\n#define _IPL_EXECUTE_H\n\n#include \"executeSentence.h\"\n#define  _EPS 0.000001\n//-----------------------------------------------------------------------------------------\n//---*** EXECUTION ***---------------------------------------------------------------------\nINTEGER  toTypeInt (myvar*);\nchar*    toTypeStr (myvar*,char*);\nFLOAT    toTypeFlt (myvar*);\n\nmyvar*   toTypeAny (names_table *Names_table, myvar *to, myvar *from);\n//------------------------------------\nvoid     variables_swap (names_table *Names_table, myvar *name);\nmyvar*   findRegWord    (hash_table *RegularWords, rwenum RedWord);\n//------------------------------------\nint      isTrueMyVar (myvar*);\nmyvar*   isTrueExpr  (exSentence*);\n//-----------------------------------------------------------------------------------------\nmyvar*   exInterpreter (exSentence*,list_pmv*,int*);\nmyvar*   exPostfix     (exSentence*,int);\nmyvar*   exOneWord     (exSentence*,int);\nmyvar*   exResulted    (exSentence*);\n\nmyvar*   exProgram     (exSentence*);\nmyvar*   exIfElse      (exSentence*);\nmyvar*   exWhile       (exSentence*);\nmyvar*   exFor         (exSentence*);\n\nmyvar*   ex_input     (names_table*,list_pmv*);\nmyvar*   ex_output    (names_table*,list_pmv*);\nmyvar*   ex_length    (names_table*,list_pmv*);\nmyvar*   ex_type      (names_table*,list_pmv*);\nmyvar*   ex_cast      (names_table*,list_pmv*);\nmyvar*   ex_random    (names_table*,list_pmv*);\nmyvar*   ex_break     (names_table*,list_pmv*);\nmyvar*   ex_user_func (names_table*,list_pmv*,myvar*);\n\nmyvar*   ex_bind      (names_table*,list_pmv*);\nmyvar*   ex_not       (names_table*,list_pmv*);\nmyvar*   ex_add       (names_table*,list_pmv*);\nmyvar*   ex_sub       (names_table*,list_pmv*);\nmyvar*   ex_mul       (names_table*,list_pmv*);\nmyvar*   ex_div       (names_table*,list_pmv*);\nmyvar*   ex_mod       (names_table*,list_pmv*);\nmyvar*   ex_and       (names_table*,list_pmv*);\nmyvar*   ex_or        (names_table*,list_pmv*);\n//myvar* ex_xor       (names_table*,list_pmv*);\n\nmyvar*   ex_equal     (names_table*,list_pmv*);\nmyvar*   ex_no_eq     (names_table*,list_pmv*);\nmyvar*   ex_gt_eq     (names_table*,list_pmv*);\nmyvar*   ex_ls_eq     (names_table*,list_pmv*);\nmyvar*   ex_great     (names_table*,list_pmv*);\nmyvar*   ex_less      (names_table*,list_pmv*);\n\nmyvar*  ex_cnt_add    (names_table*,list_pmv*);\nmyvar*  ex_cnt_del    (names_table*,list_pmv*);\nmyvar*  ex_cnt_fnd    (names_table*,list_pmv*);\nmyvar*  ex_cnt_clr    (names_table*,list_pmv*);\nmyvar*  ex_cnt_srt    (names_table*,list_pmv*);\nmyvar*  ex_cnt_index  (names_table*,list_pmv*);\n//-----------------------------------------------------------------------------------------\n#endif\n\n", "comment_ratio": 0.1076923076923077}
{"lang": "c", "code": "#ifndef CHROME_BROWSER_VIEWS_BROWSER_DIALOGS_H_\n#define CHROME_BROWSER_VIEWS_BROWSER_DIALOGS_H_\n\n#include \"app/gfx/native_widget_types.h\"\n\n// This file contains functions for running a variety of browser dialogs and\n// popups. The dialogs here are the ones that the caller does not need to\n// access the class of the popup. It allows us to break dependencies by\n// allowing the callers to not depend on the classes implementing the dialogs.\n\nclass Browser;\nclass BrowserView;\nclass EditSearchEngineControllerDelegate;\nclass FilePath;\nclass FindBar;\nclass GURL;\nclass HtmlDialogUIDelegate;\nclass InfoBubbleDelegate;\nclass Profile;\nclass TabContents;\nclass TemplateURL;\n\nnamespace gfx {\nclass Rect;\n}  // namespace gfx\n\nnamespace views {\nclass Widget;\nclass Window;\n}  // namespace views\n\nnamespace browser {\n\n// Shows the \"Report a problem with this page\" dialog box. See BugReportView.\nvoid ShowBugReportView(views::Window* parent,\n                       Profile* profile,\n                       TabContents* tab);\n\n// Shows the \"Clear browsing data\" dialog box. See ClearBrowsingDataView.\nvoid ShowClearBrowsingDataView(gfx::NativeWindow parent,\n                               Profile* profile);\n\n// Shows the \"Select profile\" dialog. See SelectProfileDialog.\nvoid ShowSelectProfileDialog();\n\n// Shows the \"Importer\" dialog. See ImporterView.\nvoid ShowImporterView(views::Widget* parent,\n                      Profile* profile);\n\n// Shows or hides the global bookmark bubble for the star button.\nvoid ShowBookmarkBubbleView(views::Window* parent,\n                            const gfx::Rect& bounds,\n                            InfoBubbleDelegate* delegate,\n                            Profile* profile,\n                            const GURL& url,\n                            bool newly_bookmarked);\nvoid HideBookmarkBubbleView();\nbool IsBookmarkBubbleViewShowing();\n\n// Shows the bookmark manager.\nvoid ShowBookmarkManagerView(Profile* profile);\n\n// Shows the about dialog. See AboutChromeView.\nvoid ShowAboutChromeView(gfx::NativeWindow parent,\n                         Profile* profile);\n\n// Shows an HTML dialog. See HtmlDialogView.\nvoid ShowHtmlDialogView(gfx::NativeWindow parent, Browser* browser,\n                        HtmlDialogUIDelegate* delegate);\n\n// Creates and returns a find bar for the given browser window. See FindBarWin.\nFindBar* CreateFindBar(BrowserView* browser_view);\n\n// Shows the \"Save passwords and exceptions\" dialog.\n// See PasswordsExceptionsWindowView.\nvoid ShowPasswordsExceptionsWindowView(Profile* profile);\n\n// Shows the keyword editor. See KeywordEditorView.\nvoid ShowKeywordEditorView(Profile* profile);\n\n// Shows the \"new profile\" dialog box. See NewProfileDialog.\nvoid ShowNewProfileDialog();\n\n// Shows the Task Manager.\nvoid ShowTaskManager();\n\n#if defined(OS_CHROMEOS)\n// Shows the Login Manager.\nvoid ShowLoginManager(const FilePath& pipe_name);\n#endif\n\n// Shows a dialog box that allows a search engine to be edited. |template_url|\n// is the search engine being edited. If it is NULL, then the dialog will add a\n// new search engine with the data the user supplies. |delegate| is an object\n// to be notified when the user is done editing, or NULL. If NULL, the dialog\n// will update the model with the user's edits directly.\nvoid EditSearchEngine(gfx::NativeWindow parent,\n                      const TemplateURL* template_url,\n                      EditSearchEngineControllerDelegate* delegate,\n                      Profile* profile);\n\n// Shows the repost form confirmation dialog box.\nvoid ShowRepostFormWarningDialog(gfx::NativeWindow parent_window,\n                                 TabContents* tab_contents);\n\n// Shows the create web app shortcut dialog box.\nvoid ShowCreateShortcutsDialog(gfx::NativeWindow parent_window,\n                               TabContents* tab_contents);\n\n}  // namespace browser\n\n#endif  // CHROME_BROWSER_VIEWS_BROWSER_DIALOGS_H_\n\n", "comment_ratio": 0.28205128205128205}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n\n@interface TimelineCell : UITableViewCell\n\n+(TimelineCell *)timelineCell;\n\n@property (retain, nonatomic) UILabel *activityDescriptionLabel;\n@property (weak, nonatomic) IBOutlet UIImageView *backgroundImageView;\n@property (weak, nonatomic) IBOutlet UIImageView *iconImageView;\n@property (weak, nonatomic) IBOutlet UILabel *activityDetailLabel;\n@property (weak, nonatomic) IBOutlet UITextView *textView;\n\n@end\n\n", "comment_ratio": 0.17142857142857143}
{"lang": "c", "code": "#pragma once\n\n#include \"opencv/cv.h\"\n\nusing namespace cv;\n\n#define USER_DEFINED_WINDOW_MIN 50//50//4\n#define USER_DEFINED_WINDOW_MAX 1200//800//101//200\n#define USER_DEFINED_WINDOW_MIN_NEW 8//10//50//4\n#define USER_DEFINED_WINDOW_MAX_NEW 200//800//101//200\n\nvoid windowthreshold(Mat& cropped,Mat& thr);\nvoid windowthreshold_new(Mat& cropped,Mat& thr);\nMat divisionthreshold(Mat cropped);\n\n", "comment_ratio": 0.26666666666666666}
{"lang": "c", "code": "#ifndef TRACECHILD_H\n#define TRACECHILD_H\n\n#include <sys/types.h>//pid_t etc\nint traceChildProcess( pid_t tracedPid );\n#endif\n\n", "comment_ratio": 0.14285714285714285}
{"lang": "c", "code": "//\r\n// Created by Matthias Preymann on 26.07.2019.\r\n//\r\n\r\n#ifndef PROMISE_CRASH_H\r\n#define PROMISE_CRASH_H\r\n\r\n/**\r\n * Static Crash Manager Class\r\n * Automatically sets up handlers for uncaught exceptions and\r\n * OS signals\r\n */\r\nclass CrashManager {\r\nprivate:\r\n    static constexpr unsigned int traceBufferLength= 1024;\r\n    static constexpr unsigned int traceSymbolNameLength= 1024;\r\n    static constexpr unsigned int maxPathLength= 1024;\r\n\r\n    // Internal single instance\r\n    static CrashManager m_manager;\r\n\r\n    // private static constructor\r\n    CrashManager();\r\n\r\n\r\n    static void resolveSymbols(void **, unsigned int);\r\n    static void printAddresses(void **, unsigned int);\r\npublic:\r\n\r\n    /**\r\n     * Print the call stack frames as stacktrace\r\n     * Addresses are tried to be resolved to symbol names based\r\n     * on available debug information\r\n     */\r\n    static void printStacktrace();\r\n\r\n    /**\r\n     * Handler called if the application terminates due to an\r\n     * uncaught exception\r\n     */\r\n    static void terminateHandler();\r\n\r\n    /**\r\n     * Handler called if the application receives a signal (SIGSEGV)\r\n     */\r\n    static void signalHandler(int);\r\n};\r\n\r\n\r\n\r\n#endif //PROMISE_CRASH_H\r\n\r\n\n", "comment_ratio": 0.11320754716981132}
{"lang": "c", "code": "#ifndef GRIDVIEW_H\n#define GRIDVIEW_H\n\n#include <FL/Fl.H>\n#include <FL/Fl_Box.H>\n#include \"LocCommWin.h\"\n#include \"ConcurrencyWin.h\"\n\n#include \"DataModel.h\"\n#include \"DataView.h\"\n\n#include <string>\n\nstatic  const int minBoxSize = 6;\n\nclass GridView : public DataView {\n\n  // Information stored for each locale\n\n  struct localeInfo {\n    // locale box location on view area\n    int x;\n    int y;\n    int w;\n    int h;\n    // Locale Window information. -- code commented out\n    // LocCommWin *win;\n    // Concurrency Window information.\n    // ConcurrencyWin *ccwin;\n    // boxes ... for tool tips.\n    Fl_Box *bT;  // Top row box\n    Fl_Box *bL;  // Left column box\n  };\n\n  // Information stored for every comm direction\n  // X -> Y and Y -> X for all X & Y.  (2d array)\n  // b for the tool tip\n\n  struct commInfo {\n    int x;\n    int y;\n    // LocCommWin *win;\n    Fl_Box *b;\n  };\n\n  // Tag names may appear multiple times in the data,\n  // Associates unique tag number with name.\n\n  struct tagInfo {\n    int tagNo;\n    char *tagName;\n  };\n\n private:\n\n    // Data arrays for the locales (1D) and communication (2D)\n    localeInfo *theLocales; // Need to de/reallocate after changing numlocales\n    int getSize;            // size used for doing deallocate after changeing numlocales\n    commInfo **comms;       // Also need to de/reallocate after changing numlocales\n    int boxSize;            // Size of locale boxes\n\n    // Methods\n\n    void allocArrays ();\n\n  public:\n\n    GridView (int bx, int by, int bw, int bh, const char *label = 0);\n\n    //  Virtual methods to override\n    void draw (void);\n    int handle (int event);\n\n    // Processing routines\n\n    void selectData (int tagNum);\n\n    void setNumLocales (int n)\n    {\n      //printf(\"NumLocalse set to %d\\n\", n);\n      numlocales = n;\n      if ((n+2)*minBoxSize+40 > w())\n        size((n+2)*minBoxSize+40, (n+2)*minBoxSize+40);\n      boxSize = ((w()-60)/(numlocales+2));\n      allocArrays();\n    }\n\n    int  getNumLocales (void) { return numlocales; }\n\n    // Add an invisible under the locale and comm boxes\n    void setLocTooltip ( int ix, bool isInt, int ival, double fval);\n    void setCommTooltip ( int i, int j, int val);\n\n    // Draw a \"locale box, with ix as the label on it\n    void drawLocale (int ix, Fl_Color col);\n\n    // Draw a comm line between loc1 and loc2, color changing in the middle\n    void drawCommBox (int ix1, Fl_Color col1,  int ix2, Fl_Color col2);\n\n#if 0\n    // Window show/hide functions ...\n    void hideAllCommWindows (void)\n    {\n      int ix1, ix2;\n      for (ix1 = 0; ix1 < numlocales; ix1++)\n        for (ix2 = 0; ix2 < numlocales; ix2++)\n          if (comms[ix1][ix2].win != NULL)\n            comms[ix1][ix2].win->hide();\n    }\n\n    void showAllCommWindows (void)\n    {\n      int ix1, ix2;\n      for (ix1 = 0; ix1 < numlocales; ix1++)\n        for (ix2 = 0; ix2 < numlocales; ix2++)\n          if (comms[ix1][ix2].win != NULL)\n            comms[ix1][ix2].win->show();\n    }\n\n    void hideAllLocCommWindows (void)\n    {\n      int ix;\n      for (ix = 0; ix < numlocales; ix++) {\n        if (theLocales[ix].win != NULL)\n          theLocales[ix].win->hide();\n        if (theLocales[ix].ccwin != NULL)\n          theLocales[ix].ccwin->hide();\n      }\n    }\n\n    void showAllLocCommWindows (void)\n    {\n      int ix;\n      for (ix = 0; ix < numlocales; ix++) {\n        if (theLocales[ix].win != NULL)\n          theLocales[ix].win->show();\n        if (theLocales[ix].ccwin != NULL)\n          theLocales[ix].ccwin->show();\n      }\n    }\n#endif\n\n    void redrawAllWindows (void);\n\n    void resize(int X, int Y, int W, int H);\n\n};\n\n#endif\n\n", "comment_ratio": 0.17058823529411765}
{"lang": "c", "code": "#ifndef CHARM_CHARMTASK_H_\n#define CHARM_CHARMTASK_H_\n\n#include \"charm++.h\"\n#include \"pup_stl.h\"\n\n#include \"../Definitions.h\"\n#include \"../TaskGraph.h\"\n#include \"../Payload.h\"\n\n#include \"charm_babelflow.decl.h\"\n\n//! Global function returning the callbacks\n//! Must be implemented by the calling application code\nextern BabelFlow::Callback registered_callback(BabelFlow::CallbackId id);\n\n//! Global function to create a task graph\n//! Must be implemented by the calling application code\nextern BabelFlow::TaskGraph* make_task_graph(BabelFlow::Payload buffer);\n\n\nnamespace BabelFlow {\nnamespace charm {\n\n//! Allow us to send Payload buffers using charm++\ninline void operator|(PUP::er &p, BabelFlow::Payload& buffer) {\n\n  p|buffer.mSize;\n  if (p.isUnpacking())\n    buffer.mBuffer = new char[buffer.size()];\n  PUParray(p, buffer.buffer(), buffer.size());\n\n\n  // If charm will delete the object make sure that we release the\n  // memory buffer\n  if (p.isDeleting())\n    delete[] buffer.buffer();\n}\n\n//! Make defining the global task graph function easy\ntemplate<class TaskGraphClass>\nTaskGraph *make_task_graph_template(Payload buffer)\n{\n  TaskGraph* graph =  new TaskGraphClass();\n  graph->deserialize(buffer);\n\n  return graph;\n}\n\n\n//! Default message for charm\ntypedef std::vector<char> Buffer;\n\nclass CharmTask : public CBase_CharmTask\n{\npublic:\n\n  //! Constructor which sets the callback and decodes destinations\n  CharmTask(Payload buffer);\n\n  //! Default\n  CharmTask(CkMigrateMessage *m) {}\n\n  ~CharmTask() {}\n\n\n  //! The main compute call for the task\n  void exec();\n\n  //! Call to add new input data\n  void addInput(TaskId source, Buffer buffer);\n\nprivate:\n\n  //! The corresponding base task\n  Task mTask;\n\n  //! The array of inputs\n  std::vector<Payload> mInputs;\n\n  //! The global charm-ids of all outputs\n  std::vector<std::vector<uint64_t> > mOutputs;\n};\n\n\n\n}\n}\n\n\n\n\n\n\n#endif /* CHARM_CHARMTASK_H_ */\n\n", "comment_ratio": 0.128}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n\n#if TARGET_IPHONE_SIMULATOR\n#include <net/route.h>\n#else\n#include \"route.h\"\n#endif\n\n\n@interface RouteRecord : NSObject\n@property (copy, nonatomic) NSString *destination;\n@property (copy, nonatomic) NSString *gateway;\n@property (copy, nonatomic) NSString *flags;\n@property (assign, nonatomic) NSInteger refs;\n@property (assign, nonatomic) NSInteger mtu;\n@property (assign, nonatomic) NSInteger use;\n@property (copy, nonatomic) NSString *netif;\n@property (assign, nonatomic) NSInteger expire;\n\n- (instancetype)initWithRtm:(struct rt_msghdr2 *)rtm;\n@end\n\n", "comment_ratio": 0.22580645161290322}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n\n@interface LYFGithubAPIClient : NSObject\n\n+(void)requestMembershipforOrg:(NSString*)orgName options:(NSUInteger)LY_HTTPRequestType pagination:(NSUInteger)totalPages WithCompletion:(void (^)(NSURLSessionDataTask *task, NSArray *repos))completionBlock;\n+(void)requestRepositoriesforOrg:(NSString*)orgName options:(NSUInteger)LY_HTTPRequestType WithCompletion:(void (^)(NSURLSessionDataTask *task, NSArray *repos))completionBlock;\n+(void)requestRepositoriesforUser:(NSString*)userName options:(NSUInteger)LY_HTTPRequestType WithCompletion:(void (^)(NSURLSessionDataTask *task, NSArray *repos))completionBlock;\n+(void)requestCurrentUserRepositoriesWithOptions:(NSUInteger)LY_HTTPRequestType WithCompletion:(void (^)(NSURLSessionDataTask *task, NSArray *repos))completionBlock;\n+(void)requestRepositoriesForkedFromParentRepo:(NSString *)repoFullName options:(NSUInteger)LY_HTTPRequestType WithCompletion:(void (^)(NSURLSessionDataTask *task, NSArray *repos))completionBlock;\n\n+(NSUInteger)paginationFromHeaderInDataTask:(NSURLSessionDataTask*)task;\n\n@end\n\n", "comment_ratio": 0.3181818181818182}
{"lang": "c", "code": "#ifndef DYNAMIC_GRAPH_EXCEPTION_TRACES_H\n# define DYNAMIC_GRAPH_EXCEPTION_TRACES_H\n# include <string>\n\n# include <dynamic-graph/fwd.hh>\n# include <dynamic-graph/dynamic-graph-api.h>\n# include <dynamic-graph/exception-abstract.h>\n\nnamespace dynamicgraph\n{\n  /// \\ingroup error\n  ///\n  /// \\brief Exceptions raised when an error related to traces happen.\n  class DYNAMIC_GRAPH_DLLAPI ExceptionTraces : public ExceptionAbstract\n  {\n  public:\n    enum ErrorCodeEnum\n    {\n      GENERIC = ExceptionAbstract::TRACES\n      ,NOT_OPEN\n    };\n\n    static const std::string EXCEPTION_NAME;\n\n    explicit ExceptionTraces (const ExceptionTraces::ErrorCodeEnum& errcode,\n\t\t\t      const std::string & msg = \"\");\n    ExceptionTraces (const ExceptionTraces::ErrorCodeEnum& errcode,\n\t\t     const std::string& msg, const char* format, ...);\n    virtual ~ExceptionTraces () throw ()\n    {}\n\n    virtual const std::string& getExceptionName () const\n    {\n      return EXCEPTION_NAME;\n    }\n  };\n} // end of namespace dynamicgraph.\n\n#endif //! DYNAMIC_GRAPH_EXCEPTION_TRACES_H\n\n", "comment_ratio": 0.3684210526315789}
{"lang": "c", "code": "#ifndef LLVM_CLANG_LIB_INDEX_CLANGINDEXRECORDWRITER_H\n#define LLVM_CLANG_LIB_INDEX_CLANGINDEXRECORDWRITER_H\n\n#include \"IndexRecordHasher.h\"\n#include \"clang/AST/Mangle.h\"\n#include \"clang/Index/IndexRecordWriter.h\"\n#include \"clang/Index/IndexingAction.h\"\n#include \"llvm/ADT/SmallString.h\"\n\nnamespace clang {\n  class ASTContext;\n  class Decl;\n\nnamespace index {\n  class FileIndexRecord;\n\nclass ClangIndexRecordWriter {\n  IndexRecordWriter Impl;\n\n  ASTContext &Ctx;\n  RecordingOptions RecordOpts;\n\n  std::unique_ptr<ASTNameGenerator> ASTNameGen;\n  llvm::BumpPtrAllocator Allocator;\n  llvm::DenseMap<const Decl *, StringRef> USRByDecl;\n  IndexRecordHasher Hasher;\n\npublic:\n  ClangIndexRecordWriter(ASTContext &Ctx, RecordingOptions Opts);\n  ~ClangIndexRecordWriter();\n\n  ASTContext &getASTContext() { return Ctx; }\n  ASTNameGenerator *getASTNameGen() { return ASTNameGen.get(); }\n\n  bool writeRecord(StringRef Filename, const FileIndexRecord &Record,\n                   std::string &Error, std::string *RecordFile = nullptr);\n  StringRef getUSR(const Decl *D);\n\nprivate:\n  StringRef getUSRNonCached(const Decl *D);\n};\n\n} // end namespace index\n} // end namespace clang\n\n#endif\n\n", "comment_ratio": 0.17857142857142858}
{"lang": "c", "code": "#pragma once\n\n\nnamespace RE\n{\n\tnamespace BSResource\n\t{\n\t\tstruct Info\n\t\t{\n\t\tpublic:\n\t\t\t// members\n\t\t\tFILETIME\t  modifyTime;  // 00\n\t\t\tFILETIME\t  createTime;  // 08\n\t\t\tLARGE_INTEGER fileSize;\t   // 10\n\t\t};\n\t\tSTATIC_ASSERT(sizeof(Info) == 0x18);\n\t}\n}\n\n", "comment_ratio": 0.21052631578947367}
{"lang": "c", "code": "8500 // Boot loader.\n8501 //\n8502 // Part of the boot sector, along with bootasm.S, which calls bootmain().\n8503 // bootasm.S has put the processor into protected 32-bit mode.\n8504 // bootmain() loads an ELF kernel image from the disk starting at\n8505 // sector 1 and then jumps to the kernel entry routine.\n8506 \n8507 #include \"types.h\"\n8508 #include \"elf.h\"\n8509 #include \"x86.h\"\n8510 #include \"memlayout.h\"\n8511 \n8512 #define SECTSIZE  512\n8513 \n8514 void readseg(uchar*, uint, uint);\n8515 \n8516 void\n8517 bootmain(void)\n8518 {\n8519   struct elfhdr *elf;\n8520   struct proghdr *ph, *eph;\n8521   void (*entry)(void);\n8522   uchar* pa;\n8523 \n8524   elf = (struct elfhdr*)0x10000;  // scratch space\n8525 \n8526   // Read 1st page off disk\n8527   readseg((uchar*)elf, 4096, 0);\n8528 \n8529   // Is this an ELF executable?\n8530   if(elf->magic != ELF_MAGIC)\n8531     return;  // let bootasm.S handle error\n8532 \n8533   // Load each program segment (ignores ph flags).\n8534   ph = (struct proghdr*)((uchar*)elf + elf->phoff);\n8535   eph = ph + elf->phnum;\n8536   for(; ph < eph; ph++){\n8537     pa = (uchar*)ph->paddr;\n8538     readseg(pa, ph->filesz, ph->off);\n8539     if(ph->memsz > ph->filesz)\n8540       stosb(pa + ph->filesz, 0, ph->memsz - ph->filesz);\n8541   }\n8542 \n8543   // Call the entry point from the ELF header.\n8544   // Does not return!\n8545   entry = (void(*)(void))(elf->entry);\n8546   entry();\n8547 }\n8548 \n8549 \n8550 void\n8551 waitdisk(void)\n8552 {\n8553   // Wait for disk ready.\n8554   while((inb(0x1F7) & 0xC0) != 0x40)\n8555     ;\n8556 }\n8557 \n8558 // Read a single sector at offset into dst.\n8559 void\n8560 readsect(void *dst, uint offset)\n8561 {\n8562   // Issue command.\n8563   waitdisk();\n8564   outb(0x1F2, 1);   // count = 1\n8565   outb(0x1F3, offset);\n8566   outb(0x1F4, offset >> 8);\n8567   outb(0x1F5, offset >> 16);\n8568   outb(0x1F6, (offset >> 24) | 0xE0);\n8569   outb(0x1F7, 0x20);  // cmd 0x20 - read sectors\n8570 \n8571   // Read data.\n8572   waitdisk();\n8573   insl(0x1F0, dst, SECTSIZE/4);\n8574 }\n8575 \n8576 // Read 'count' bytes at 'offset' from kernel into physical address 'pa'.\n8577 // Might copy more than asked.\n8578 void\n8579 readseg(uchar* pa, uint count, uint offset)\n8580 {\n8581   uchar* epa;\n8582 \n8583   epa = pa + count;\n8584 \n8585   // Round down to sector boundary.\n8586   pa -= offset % SECTSIZE;\n8587 \n8588   // Translate from bytes to sectors; kernel starts at sector 1.\n8589   offset = (offset / SECTSIZE) + 1;\n8590 \n8591   // If this is too slow, we could read lots of sectors at a time.\n8592   // We'd write more to memory than asked, but it doesn't matter --\n8593   // we load in increasing order.\n8594   for(; pa < epa; pa += SECTSIZE, offset++)\n8595     readsect(pa, offset);\n8596 }\n8597 \n8598 \n8599 \n\n", "comment_ratio": 0.25742574257425743}
{"lang": "c", "code": "#ifndef PXR_USD_SDR_REGISTRY_H\n#define PXR_USD_SDR_REGISTRY_H\n\n/// \\file sdr/registry.h\n\n#include \"pxr/pxr.h\"\n#include \"pxr/base/tf/singleton.h\"\n#include \"pxr/usd/sdr/api.h\"\n#include \"pxr/usd/ndr/registry.h\"\n#include \"pxr/usd/sdr/declare.h\"\n#include \"pxr/usd/sdr/shaderNode.h\"\n\nPXR_NAMESPACE_OPEN_SCOPE\n\n/// \\class SdrRegistry\n///\n/// The shading-specialized version of `NdrRegistry`.\n///\nclass SdrRegistry : public NdrRegistry\n{\npublic:\n    /// Get the single `SdrRegistry` instance.\n    SDR_API\n    static SdrRegistry& GetInstance();\n\n    /// Exactly like `NdrRegistry::GetNodeByIdentifier()`, but returns a\n    /// `SdrShaderNode` pointer instead of a `NdrNode` pointer.\n    SDR_API\n    SdrShaderNodeConstPtr GetShaderNodeByIdentifier(\n        const NdrIdentifier& identifier,\n        const NdrTokenVec& typePriority = NdrTokenVec());\n\n    /// Exactly like `NdrRegistry::GetNodeByIdentifierAndType()`, but returns\n    /// a `SdrShaderNode` pointer instead of a `NdrNode` pointer.\n    SDR_API\n    SdrShaderNodeConstPtr GetShaderNodeByIdentifierAndType(\n        const NdrIdentifier& identifier,\n        const TfToken& nodeType);\n\n    /// Exactly like `NdrRegistry::GetNodeByName()`, but returns a\n    /// `SdrShaderNode` pointer instead of a `NdrNode` pointer.\n    SDR_API\n    SdrShaderNodeConstPtr GetShaderNodeByName(\n        const std::string& name,\n        const NdrTokenVec& typePriority = NdrTokenVec(),\n        NdrVersionFilter filter = NdrVersionFilterDefaultOnly);\n\n    /// Exactly like `NdrRegistry::GetNodeByNameAndType()`, but returns a\n    /// `SdrShaderNode` pointer instead of a `NdrNode` pointer.\n    SDR_API\n    SdrShaderNodeConstPtr GetShaderNodeByNameAndType(\n        const std::string& name,\n        const TfToken& nodeType,\n        NdrVersionFilter filter = NdrVersionFilterDefaultOnly);\n\n    /// Wrapper method for NdrRegistry::GetNodeFromAsset(). \n    /// Returns a valid SdrShaderNode pointer upon success.\n    SDR_API\n    SdrShaderNodeConstPtr GetShaderNodeFromAsset(\n        const SdfAssetPath &shaderAsset,\n        const NdrTokenMap &metadata=NdrTokenMap(),\n        const TfToken &subIdentifier=TfToken(),\n        const TfToken &sourceType=TfToken());\n\n    /// Wrapper method for NdrRegistry::GetNodeFromSourceCode(). \n    /// Returns a valid SdrShaderNode pointer upon success.\n    SDR_API\n    SdrShaderNodeConstPtr GetShaderNodeFromSourceCode(\n        const std::string &sourceCode,\n        const TfToken &sourceType,\n        const NdrTokenMap &metadata=NdrTokenMap());\n\n    /// Exactly like `NdrRegistry::GetNodesByIdentifier()`, but returns a vector\n    /// of `SdrShaderNode` pointers instead of a vector of `NdrNode` pointers.\n    SDR_API\n    SdrShaderNodePtrVec GetShaderNodesByIdentifier(const NdrIdentifier& identifier);\n\n    /// Exactly like `NdrRegistry::GetNodesByName()`, but returns a vector of\n    /// `SdrShaderNode` pointers instead of a vector of `NdrNode` pointers.\n    SDR_API\n    SdrShaderNodePtrVec GetShaderNodesByName(\n        const std::string& name,\n        NdrVersionFilter filter = NdrVersionFilterDefaultOnly);\n\n    /// Exactly like `NdrRegistry::GetNodesByFamily()`, but returns a vector of\n    /// `SdrShaderNode` pointers instead of a vector of `NdrNode` pointers.\n    SDR_API\n    SdrShaderNodePtrVec GetShaderNodesByFamily(\n        const TfToken& family = TfToken(),\n        NdrVersionFilter filter = NdrVersionFilterDefaultOnly);\n\nprotected:\n    // Allow TF to construct the class\n    friend class TfSingleton<SdrRegistry>;\n\n    SdrRegistry();\n    ~SdrRegistry();\n};\n\nPXR_NAMESPACE_CLOSE_SCOPE\n\n#endif // PXR_USD_SDR_REGISTRY_H\n\n", "comment_ratio": 0.3858267716535433}
{"lang": "c", "code": "#ifndef OOMPH_ANNULAR_DOMAIN_HEADER\n#define OOMPH_ANNULAR_DOMAIN_HEADER\n\n// Generic oomph-lib includes\n#include \"../generic/quadtree.h\"\n#include \"../generic/domain.h\"\n#include \"../generic/geom_objects.h\"\n\nnamespace oomph\n{\n  //=================================================================\n  /// Annular domain\n  //=================================================================\n  class AnnularDomain : public Domain\n  {\n  public:\n    /// Constructor: Specify azimuthal fraction (1.0 is 360 degrees)\n    /// number of macro elements in azimuthal and radial direction,\n    /// inner radius and thickness. Rotate mesh by angle phi.\n    AnnularDomain(const double& azimuthal_fraction,\n                  const unsigned& ntheta,\n                  const unsigned& nr,\n                  const double& a,\n                  const double& h,\n                  const double& phi)\n      : Azimuthal_fraction(azimuthal_fraction),\n        Inner_radius(a),\n        Thickness(h),\n        Ntheta(ntheta),\n        Nr(nr),\n        Phi(phi)\n    {\n      const unsigned n_macro = ntheta * nr;\n      Macro_element_pt.resize(n_macro);\n\n      // Create the macro elements\n      for (unsigned i = 0; i < n_macro; i++)\n      {\n        Macro_element_pt[i] = new QMacroElement<2>(this, i);\n      }\n    }\n\n    /// Broken copy constructor\n    AnnularDomain(const AnnularDomain&) = delete;\n\n    /// Broken assignment operator\n    void operator=(const AnnularDomain&) = delete;\n\n    /// Destructor: Empty; cleanup done in base class\n    ~AnnularDomain() {}\n\n\n    /// Vector representation of the  i_macro-th macro element\n    /// boundary i_direct (N/S/W/E) at time level t\n    /// (t=0: present; t>0: previous):\n    /// f(s).\n    void macro_element_boundary(const unsigned& t,\n                                const unsigned& i_macro,\n                                const unsigned& i_direct,\n                                const Vector<double>& s,\n                                Vector<double>& f);\n\n  private:\n    /// Azimuthal fraction\n    double Azimuthal_fraction;\n\n    /// Inner radius\n    double Inner_radius;\n\n    /// Thickness\n    double Thickness;\n\n    /// Number of macro elements in azimuthal direction\n    unsigned Ntheta;\n\n    /// Number of macro elements in radial direction\n    unsigned Nr;\n\n    /// Rotation angle\n    double Phi;\n  };\n\n\n  /// //////////////////////////////////////////////////////////////////////\n  /// //////////////////////////////////////////////////////////////////////\n  /// //////////////////////////////////////////////////////////////////////\n\n\n  //=================================================================\n  /// Vector representation of the  imacro-th macro element\n  /// boundary idirect (N/S/W/E) at time level t\n  /// (t=0: present; t>0: previous): f(s)\n  //=================================================================\n  void AnnularDomain::macro_element_boundary(const unsigned& t,\n                                             const unsigned& imacro,\n                                             const unsigned& idirect,\n                                             const Vector<double>& s,\n                                             Vector<double>& f)\n  {\n    using namespace QuadTreeNames;\n\n    // Get coordinates of macro element\n    unsigned i_theta = imacro % Ntheta;\n    unsigned i_r = (imacro - i_theta) / Ntheta;\n\n    // Angle and radius limits\n    double theta_lo = Azimuthal_fraction * 2.0 * MathematicalConstants::Pi *\n                      double(i_theta) / double(Ntheta);\n\n    double theta_hi = Azimuthal_fraction * 2.0 * MathematicalConstants::Pi *\n                      double(i_theta + 1) / double(Ntheta);\n\n    // Revert direction (convoluted -- don't ask. It mirrors what happens\n    // in the mesh...\n    theta_lo = -MathematicalConstants::Pi +\n               Azimuthal_fraction * 2.0 * MathematicalConstants::Pi - theta_lo;\n    theta_hi = -MathematicalConstants::Pi +\n               Azimuthal_fraction * 2.0 * MathematicalConstants::Pi - theta_hi;\n\n    double r_lo = Inner_radius + Thickness * double(i_r) / double(Nr);\n    double r_hi = Inner_radius + Thickness * double(i_r + 1) / double(Nr);\n\n    // Actual radius and angle\n    double r = 0.0;\n    double theta = 0.0;\n\n    // Which direction?\n    switch (idirect)\n    {\n      case N:\n\n        theta = theta_lo + 0.5 * (s[0] + 1.0) * (theta_hi - theta_lo);\n        r = r_hi;\n\n        break;\n\n      case S:\n\n        theta = theta_lo + 0.5 * (s[0] + 1.0) * (theta_hi - theta_lo);\n        r = r_lo;\n\n        break;\n\n      case W:\n\n        theta = theta_lo;\n        r = r_lo + 0.5 * (s[0] + 1.0) * (r_hi - r_lo);\n\n        break;\n\n      case E:\n\n        theta = theta_hi;\n        r = r_lo + 0.5 * (s[0] + 1.0) * (r_hi - r_lo);\n\n        break;\n\n      default:\n        std::ostringstream error_stream;\n        error_stream << \"idirect is \" << idirect << \" not one of N, S, W, E\"\n                     << std::endl;\n\n        throw OomphLibError(\n          error_stream.str(), OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);\n    }\n\n    f[0] = r * cos(theta + Phi);\n    f[1] = r * sin(theta + Phi);\n  }\n\n} // namespace oomph\n\n#endif\n\n", "comment_ratio": 0.3065326633165829}
{"lang": "c", "code": "typedef vector<bool>            INT_BOOLVECTOR;\r\ntypedef vector<int>             INT_INDEXLIST;\r\ntypedef set<int>                INT_INDEXSET;\r\n\r\n#endif\r\n\n", "comment_ratio": 0.1896551724137931}
{"lang": "c", "code": "//General values for Project\n#ifndef SICT_wpgeneral_H_\n#define _CRT_SECURE_NO_WARNINGS\n#define TAX 0.13\n#define MAX_SKU_LEN 4\n#define MIN_YEAR 2000\n#define MAX_YEAR 2030\n#define MAX_NO_RECS 2000\n#define MAX_UPC_LEN 7\n#endif\n", "comment_ratio": 0.1}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n\n@class CGUpnpAvController;\n\n@interface RendererTableViewController : UITableViewController\n@property (nonatomic, retain)NSArray* dataSource;\n\n- (id)initWithAvController:(CGUpnpAvController*)aController;\n@end\n\n", "comment_ratio": 0.3888888888888889}
{"lang": "c", "code": "#ifndef STJTREEINDEXLIST_H\n#define STJTREEINDEXLIST_H\n\n#include \"StjTreeIndex.h\"\n\n#include <vector>\n\ntypedef std::vector<StjTreeIndex> StjTreeIndexList;\n\ninline bool operator==(const StjTreeIndexList& v1, const StjTreeIndexList& v2){\n  if(v1.size() != v2.size()) return false;\n  for(size_t i = 0; i < v1.size(); ++i) if(v1[i] != v2[i]) return false;\n  return true;\n}\n\ninline std::ostream& operator<<(std::ostream& out, const StjTreeIndexList& v)\n{\n  out << \"StjTreeIndexList size: \" << v.size();\n  return out;\n}\n\n#endif // STJTREEINDEXLIST_H\n\n", "comment_ratio": 0.15384615384615385}
{"lang": "c", "code": "#ifndef hifi_PhysicalEntitySimulation_h\n#define hifi_PhysicalEntitySimulation_h\n\n#include <stdint.h>\n\n#include <btBulletDynamicsCommon.h>\n#include <BulletCollision/CollisionDispatch/btGhostObject.h>\n\n#include <EntityItem.h>\n#include <EntitySimulation.h>\n\n#include \"PhysicsEngine.h\"\n#include \"EntityMotionState.h\"\n\ntypedef QSet<EntityMotionState*> SetOfEntityMotionStates;\n\nclass PhysicalEntitySimulation :public EntitySimulation {\npublic:\n    PhysicalEntitySimulation();\n    ~PhysicalEntitySimulation();\n\n    void init(EntityTree* tree, PhysicsEngine* engine, EntityEditPacketSender* packetSender);\n\n    virtual void applyActionChanges();\n\nprotected: // only called by EntitySimulation\n    // overrides for EntitySimulation\n    virtual void updateEntitiesInternal(const quint64& now);\n    virtual void addEntityInternal(EntityItemPointer entity);\n    virtual void removeEntityInternal(EntityItemPointer entity);\n    virtual void changeEntityInternal(EntityItemPointer entity);\n    virtual void clearEntitiesInternal();\n\npublic:\n    VectorOfMotionStates& getObjectsToDelete();\n    VectorOfMotionStates& getObjectsToAdd();\n    VectorOfMotionStates& getObjectsToChange();\n\n    void handleOutgoingChanges(VectorOfMotionStates& motionStates, const QUuid& sessionID);\n    void handleCollisionEvents(CollisionEvents& collisionEvents);\n\nprivate:\n    // incoming changes\n    SetOfEntityMotionStates _pendingRemoves; // EntityMotionStates to be removed from PhysicsEngine (and deleted)\n    SetOfEntities _pendingAdds; // entities to be be added to PhysicsEngine (and a their EntityMotionState created)\n    SetOfEntityMotionStates _pendingChanges; // EntityMotionStates already in PhysicsEngine that need their physics changed\n\n    // outgoing changes\n    SetOfEntityMotionStates _outgoingChanges; // EntityMotionStates for which we need to send updates to entity-server\n\n    SetOfMotionStates _physicalObjects; // MotionStates of entities in PhysicsEngine\n    VectorOfMotionStates _tempVector; // temporary array reference, valid immediately after getObjectsToRemove() (and friends)\n\n    PhysicsEngine* _physicsEngine = nullptr;\n    EntityEditPacketSender* _entityPacketSender = nullptr;\n\n    uint32_t _lastStepSendPackets = 0;\n};\n\n#endif // hifi_PhysicalEntitySimulation_h\n\n", "comment_ratio": 0.2916666666666667}
{"lang": "c", "code": "#include \"tusb_option.h\"\n\n#if TUSB_OPT_DEVICE_ENABLED\n\n#include \"tusb.h\"\n#include \"device/usbd_pvt.h\"\n#include \"dcd.h\"\n\nenum\n{\n  EDPT_CTRL_OUT = 0x00,\n  EDPT_CTRL_IN  = 0x80\n};\n\ntypedef struct\n{\n  tusb_control_request_t request;\n\n  uint8_t* buffer;\n  uint16_t data_len;\n  uint16_t total_xferred;\n\n  bool (*complete_cb) (uint8_t, tusb_control_request_t const *);\n} usbd_control_xfer_t;\n\nstatic usbd_control_xfer_t _ctrl_xfer;\n\nCFG_TUSB_MEM_SECTION CFG_TUSB_MEM_ALIGN static uint8_t _usbd_ctrl_buf[CFG_TUD_ENDPOINT0_SIZE];\n\n\n//--------------------------------------------------------------------+\n// Application API\n//--------------------------------------------------------------------+\n\nstatic inline bool _status_stage_xact(uint8_t rhport, tusb_control_request_t const * request)\n{\n  // status direction is reversed to one in the setup packet\n  // some requests type like set_configuration, set_feature, we need to send a zero length packet\n  // to end the setup stage\n\n  switch (request->bRequest)\n  {\n    case TUSB_REQ_SET_CONFIGURATION:\n    case TUSB_REQ_SET_FEATURE:\n    case TUSB_REQ_CLEAR_FEATURE:\n    case TUSB_REQ_SET_ADDRESS:\n    case TUSB_REQ_SET_INTERFACE: \n        return dcd_edpt_xfer(rhport, request->bmRequestType_bit.direction ? EDPT_CTRL_OUT : EDPT_CTRL_IN, NULL, 0);\n    default:\n        return true;\n  }\n}\n\nbool tud_control_status(uint8_t rhport, tusb_control_request_t const * request)\n{\n  _ctrl_xfer.request       = (*request);\n  _ctrl_xfer.buffer        = NULL;\n  _ctrl_xfer.total_xferred = 0;\n  _ctrl_xfer.data_len      = 0;\n\n  return _status_stage_xact(rhport, request);\n}\n\n// Transfer an transaction in Data Stage\n// Each transaction has up to Endpoint0's max packet size.\n// This function can also transfer an zero-length packet\nstatic bool _data_stage_xact(uint8_t rhport)\n{\n  uint8_t ep_addr = EDPT_CTRL_OUT;\n\n  if ( _ctrl_xfer.request.bmRequestType_bit.direction == TUSB_DIR_IN )\n  {\n    ep_addr = EDPT_CTRL_IN;\n  }\n\n  return dcd_edpt_xfer(rhport, ep_addr, _ctrl_xfer.buffer, _ctrl_xfer.data_len);\n}\n\nbool tud_control_xfer(uint8_t rhport, tusb_control_request_t const * request, void* buffer, uint16_t len)\n{\n  _ctrl_xfer.request       = (*request);\n  _ctrl_xfer.buffer        = (uint8_t*) buffer;\n  _ctrl_xfer.total_xferred = 0;\n  _ctrl_xfer.data_len      = tu_min16(len, request->wLength);\n\n\n  if (request->wLength > 0U)\n  {\n    if(_ctrl_xfer.data_len > 0U)\n    {\n      TU_ASSERT(buffer);\n    }\n\n    // TU_LOG2(\"  Control total data length is %u bytes\\r\\n\", _ctrl_xfer.data_len);\n\n    // Data stage\n    TU_ASSERT( _data_stage_xact(rhport) );\n  }\n  else\n  {\n    // Status stage\n    TU_ASSERT( _status_stage_xact(rhport, request) );\n  }\n\n  return true;\n}\n\n//--------------------------------------------------------------------+\n// USBD API\n//--------------------------------------------------------------------+\n\nvoid usbd_control_reset (uint8_t rhport)\n{\n  (void) rhport;\n  tu_varclr(&_ctrl_xfer);\n}\n\n// TODO may find a better way\nvoid usbd_control_set_complete_callback( bool (*fp) (uint8_t, tusb_control_request_t const * ) )\n{\n  _ctrl_xfer.complete_cb = fp;\n}\n\n// callback when a transaction complete on\n// - DATA stage of control endpoint or\n// - Status stage\nbool usbd_control_xfer_cb (uint8_t rhport, uint8_t ep_addr, xfer_result_t result, uint32_t xferred_bytes)\n{\n  (void) result;\n\n  // Endpoint Address is opposite to direction bit, this is Status Stage complete event\n  if ( tu_edpt_dir(ep_addr) != _ctrl_xfer.request.bmRequestType_bit.direction )\n  {\n    TU_ASSERT(0 == xferred_bytes);\n    return true;\n  }\n\n  if ( _ctrl_xfer.request.bmRequestType_bit.direction == TUSB_DIR_OUT )\n  {\n    TU_VERIFY(_ctrl_xfer.buffer);\n    memcpy(_ctrl_xfer.buffer, _usbd_ctrl_buf, xferred_bytes);\n  }\n\n  _ctrl_xfer.total_xferred += xferred_bytes;\n  _ctrl_xfer.buffer += xferred_bytes;\n\n  // Data Stage is complete when all request's length are transferred or\n  // a short packet is sent including zero-length packet.\n  if ( (_ctrl_xfer.request.wLength == _ctrl_xfer.total_xferred) || xferred_bytes < CFG_TUD_ENDPOINT0_SIZE )\n  {\n    // DATA stage is complete\n    bool is_ok = true;\n\n    // invoke complete callback if set\n    // callback can still stall control in status phase e.g out data does not make sense\n    if ( _ctrl_xfer.complete_cb )\n    {\n      is_ok = _ctrl_xfer.complete_cb(rhport, &_ctrl_xfer.request);\n    }\n\n    if ( is_ok )\n    {\n      // Send status\n      TU_ASSERT( _status_stage_xact(rhport, &_ctrl_xfer.request) );\n    }else\n    {\n      // Stall both IN and OUT control endpoint\n      dcd_edpt_stall(rhport, EDPT_CTRL_OUT);\n      dcd_edpt_stall(rhport, EDPT_CTRL_IN);\n    }\n  }\n  else\n  {\n    // More data to transfer\n    TU_ASSERT( _data_stage_xact(rhport) );\n  }\n\n  return true;\n}\n\n#endif\n\n", "comment_ratio": 0.1346153846153846}
{"lang": "c", "code": "#import <PhotosUICore/PhotosUICore-Structs.h>\n#import <PhotosUICore/PXTilingLayout.h>\n\n@class PXOverlayBadgeTileUserData, PXAssetsDataSource, PXIndexPathSet, PXSelectionBadgeTileUserData, PXBasicTileUserData, NSIndexSet;\n\n@interface PXAssetsTilingLayout : PXTilingLayout {\n\n\tPXOverlayBadgeTileUserData* _overlayBadgeTileUserData;\n\tPXAssetsDataSource* _dataSource;\n\tPXIndexPathSet* _hiddenIndexPaths;\n\tPXIndexPathSet* _selectedIndexPaths;\n\tPXIndexPathSet* _draggingIndexPaths;\n\tunsigned long long _selectionBadgeOptions;\n\tunsigned long long _badgeOptions;\n\tunsigned long long _animatedOverlayBehavior;\n\tPXSelectionBadgeTileUserData* __selectedUserData;\n\tPXSelectionBadgeTileUserData* __unselectedUserData;\n\tPXBasicTileUserData* __highlightedDimmingUserData;\n\tPXBasicTileUserData* __selectedDimmingUserData;\n\tPXBasicTileUserData* __draggingDimmingUserData;\n\tNSIndexSet* _additionalAccessoryTileKinds;\n\tPXSimpleIndexPath _highlightedIndexPath;\n\tPXSimpleIndexPath _focusedIndexPath;\n\n}\n\n@property (nonatomic,readonly) PXSelectionBadgeTileUserData * _selectedUserData;                                                  //@synthesize _selectedUserData=__selectedUserData - In the implementation block\n@property (nonatomic,readonly) PXSelectionBadgeTileUserData * _unselectedUserData;                                                //@synthesize _unselectedUserData=__unselectedUserData - In the implementation block\n@property (nonatomic,readonly) PXBasicTileUserData * _highlightedDimmingUserData;                                                 //@synthesize _highlightedDimmingUserData=__highlightedDimmingUserData - In the implementation block\n@property (nonatomic,readonly) PXBasicTileUserData * _selectedDimmingUserData;                                                    //@synthesize _selectedDimmingUserData=__selectedDimmingUserData - In the implementation block\n@property (nonatomic,readonly) PXBasicTileUserData * _draggingDimmingUserData;                                                    //@synthesize _draggingDimmingUserData=__draggingDimmingUserData - In the implementation block\n@property (setter=_setContentTileUserData:,nonatomic,retain) PXOverlayBadgeTileUserData * _overlayBadgeTileUserData;              //@synthesize overlayBadgeTileUserData=_overlayBadgeTileUserData - In the implementation block\n@property (nonatomic,retain) NSIndexSet * additionalAccessoryTileKinds;                                                           //@synthesize additionalAccessoryTileKinds=_additionalAccessoryTileKinds - In the implementation block\n@property (nonatomic,readonly) PXAssetsDataSource * dataSource;                                                                   //@synthesize dataSource=_dataSource - In the implementation block\n@property (nonatomic,retain) PXIndexPathSet * hiddenIndexPaths;                                                                   //@synthesize hiddenIndexPaths=_hiddenIndexPaths - In the implementation block\n@property (assign,nonatomic) PXSimpleIndexPath highlightedIndexPath;                                                              //@synthesize highlightedIndexPath=_highlightedIndexPath - In the implementation block\n@property (assign,nonatomic) PXSimpleIndexPath focusedIndexPath;                                                                  //@synthesize focusedIndexPath=_focusedIndexPath - In the implementation block\n@property (nonatomic,retain) PXIndexPathSet * selectedIndexPaths;                                                                 //@synthesize selectedIndexPaths=_selectedIndexPaths - In the implementation block\n@property (nonatomic,retain) PXIndexPathSet * draggingIndexPaths;                                                                 //@synthesize draggingIndexPaths=_draggingIndexPaths - In the implementation block\n@property (assign,nonatomic) unsigned long long selectionBadgeOptions;                                                            //@synthesize selectionBadgeOptions=_selectionBadgeOptions - In the implementation block\n@property (assign,nonatomic) unsigned long long badgeOptions;                                                                     //@synthesize badgeOptions=_badgeOptions - In the implementation block\n@property (assign,nonatomic) unsigned long long animatedOverlayBehavior;                                                          //@synthesize animatedOverlayBehavior=_animatedOverlayBehavior - In the implementation block\n-(id)description;\n-(id)init;\n-(PXAssetsDataSource *)dataSource;\n-(id)initWithDataSource:(id)arg1 ;\n-(PXSimpleIndexPath)highlightedIndexPath;\n-(void)setHighlightedIndexPath:(PXSimpleIndexPath)arg1 ;\n-(BOOL)getGeometry:(out PXTileGeometry*)arg1 group:(out unsigned long long*)arg2 userData:(out id*)arg3 forTileWithIdentifier:(PXTileIdentifier)arg4 ;\n-(void)adjustGeometry:(PXTileGeometry*)arg1 forContentTileWithIndexPath:(PXSimpleIndexPath)arg2 ;\n-(CGSize)playButtonSizeForItemAtIndexPath:(PXSimpleIndexPath)arg1 contentTileSize:(CGSize)arg2 ;\n-(CGSize)_preferredSelectionBadgeSize;\n-(BOOL)getAdditionalAccessoryTileIdentifier:(out PXTileIdentifier*)arg1 outGeometry:(out PXTileGeometry*)arg2 group:(out unsigned long long*)arg3 userData:(out id*)arg4 forTileKind:(unsigned long long)arg5 contentTileGeometry:(const PXTileGeometry*)arg6 indexPath:(PXSimpleIndexPath)arg7 ;\n-(double)zPositionOffsetForKind:(unsigned long long)arg1 ;\n-(void)setFocusedIndexPath:(PXSimpleIndexPath)arg1 ;\n-(PXSimpleIndexPath)focusedIndexPath;\n-(void)setSelectedIndexPaths:(PXIndexPathSet *)arg1 ;\n-(PXIndexPathSet *)selectedIndexPaths;\n-(PXOverlayBadgeTileUserData *)_overlayBadgeTileUserData;\n-(void)setBadgeOptions:(unsigned long long)arg1 ;\n-(void)setHiddenIndexPaths:(PXIndexPathSet *)arg1 ;\n-(void)setSelectionBadgeOptions:(unsigned long long)arg1 ;\n-(void)setDraggingIndexPaths:(PXIndexPathSet *)arg1 ;\n-(void)setAnimatedOverlayBehavior:(unsigned long long)arg1 ;\n-(void)enumerateAccessoryTilesForContentTileWithIndexPath:(PXSimpleIndexPath)arg1 geometry:(const PXTileGeometry*)arg2 withOptions:(id)arg3 usingBlock:(/*^block*/id)arg4 ;\n-(BOOL)_getSelectionBadgeTileIdentifier:(out PXTileIdentifier*)arg1 outGeometry:(out PXTileGeometry*)arg2 group:(out unsigned long long*)arg3 userData:(out id*)arg4 forContentTileGeometry:(const PXTileGeometry*)arg5 indexPath:(PXSimpleIndexPath)arg6 ;\n-(BOOL)_getPlayButtonTileIdentifier:(out PXTileIdentifier*)arg1 outGeometry:(out PXTileGeometry*)arg2 group:(out unsigned long long*)arg3 userData:(out id*)arg4 forContentTileGeometry:(const PXTileGeometry*)arg5 indexPath:(PXSimpleIndexPath)arg6 ;\n-(BOOL)_getLivePhotoOverlayTileIdentifier:(out PXTileIdentifier*)arg1 outGeometry:(out PXTileGeometry*)arg2 group:(out unsigned long long*)arg3 userData:(out id*)arg4 forContentTileGeometry:(const PXTileGeometry*)arg5 indexPath:(PXSimpleIndexPath)arg6 ;\n-(BOOL)_getVideoOverlayTileIdentifier:(out PXTileIdentifier*)arg1 outGeometry:(out PXTileGeometry*)arg2 group:(out unsigned long long*)arg3 userData:(out id*)arg4 forContentTileGeometry:(const PXTileGeometry*)arg5 indexPath:(PXSimpleIndexPath)arg6 ;\n-(BOOL)_getLoopingVideoOverlayTileIdentifier:(out PXTileIdentifier*)arg1 outGeometry:(out PXTileGeometry*)arg2 group:(out unsigned long long*)arg3 userData:(out id*)arg4 forContentTileGeometry:(const PXTileGeometry*)arg5 indexPath:(PXSimpleIndexPath)arg6 ;\n-(BOOL)_getAnimatedImageOverlayTileIdentifier:(out PXTileIdentifier*)arg1 outGeometry:(out PXTileGeometry*)arg2 group:(out unsigned long long*)arg3 userData:(out id*)arg4 forContentTileGeometry:(const PXTileGeometry*)arg5 indexPath:(PXSimpleIndexPath)arg6 ;\n-(BOOL)_getDimmingTileIdentifier:(out PXTileIdentifier*)arg1 outGeometry:(out PXTileGeometry*)arg2 group:(out unsigned long long*)arg3 userData:(out id*)arg4 forContentTileGeometry:(const PXTileGeometry*)arg5 indexPath:(PXSimpleIndexPath)arg6 ;\n-(BOOL)_getOverlayBadgeTileIdentifier:(out PXTileIdentifier*)arg1 outGeometry:(out PXTileGeometry*)arg2 group:(out unsigned long long*)arg3 userData:(out id*)arg4 forContentTileGeometry:(const PXTileGeometry*)arg5 indexPath:(PXSimpleIndexPath)arg6 ;\n-(void)_invalidateAllSelectionTiles;\n-(void)_invalidateAllAnimatedOverlayTiles;\n-(void)_setContentTileUserData:(id)arg1 ;\n-(PXIndexPathSet *)hiddenIndexPaths;\n-(PXIndexPathSet *)draggingIndexPaths;\n-(unsigned long long)selectionBadgeOptions;\n-(unsigned long long)badgeOptions;\n-(unsigned long long)animatedOverlayBehavior;\n-(PXSelectionBadgeTileUserData *)_selectedUserData;\n-(PXSelectionBadgeTileUserData *)_unselectedUserData;\n-(PXBasicTileUserData *)_highlightedDimmingUserData;\n-(PXBasicTileUserData *)_selectedDimmingUserData;\n-(PXBasicTileUserData *)_draggingDimmingUserData;\n-(NSIndexSet *)additionalAccessoryTileKinds;\n-(void)setAdditionalAccessoryTileKinds:(NSIndexSet *)arg1 ;\n@end\n\n\n", "comment_ratio": 0.16161616161616163}
{"lang": "c", "code": "#include \"stdlib.h\"\n#include <stdbool.h>\n\nstruct node {\n    int value;\n    struct node* next;\n};\ntypedef struct node node_t;\n\nstruct stack {\n    node_t* head;\n};\ntypedef struct stack stack_t;\n\n/*@\npredicate nodes(node_t* node, int size) =\n    !node ? size == 0 : 0 < size &*&\n    node->value |-> ?value &*& node->next |-> ?next &*&\n    malloc_block_node(node) &*& nodes(next, size - 1);\n\npredicate stack(stack_t* stack, int size) =\n    0 <= size &*& stack->head |-> ?head &*&\n    malloc_block_stack(stack) &*& nodes(head, size);\n@*/\n\nstack_t* create_stack()\n    //@ requires true;\n    //@ ensures  stack(result, 0);\n{\n    stack_t* stack = malloc(sizeof(stack_t));\n    if (!stack) abort();\n    stack->head = 0;\n    //@ close nodes(0, 0);\n    //@ close stack(stack, 0);\n\n    return stack;\n}\n\nvoid stack_push(stack_t* stack, int value)\n    //@ requires stack(stack, ?size);\n    //@ ensures  stack(stack, size + 1);\n{\n    node_t* new_node = malloc(sizeof(node_t));\n    if (!new_node) abort();\n    new_node->value = value;\n\n    //@ open stack(stack, size);\n    new_node->next = stack->head;\n    stack->head = new_node;\n    //@ close nodes(new_node, size + 1);\n    //@ close stack(stack, size + 1);\n}\n\nint stack_pop(stack_t* stack)\n    //@ requires stack(stack, ?size) &*& 0 < size;\n    //@ ensures  stack(stack, size -1);\n{\n    //@ open stack(stack, size);\n    node_t* head = stack->head;\n    //@ open nodes(head, size);\n    int value = head->value;\n\n    stack->head = head->next;\n    free(head);\n    //@ close stack(stack, size - 1);\n\n    return value;\n}\n\nvoid nodes_dispose(node_t* node)\n    //@ requires nodes(node, _);\n    //@ ensures  true;\n{\n    //@ open nodes(node, _);\n    if (node != 0) {\n        nodes_dispose(node->next);\n        free(node);\n    }\n}\n\nvoid stack_dispose(stack_t* stack)\n    //@ requires stack(stack, _);\n    //@ ensures  true;\n{\n    //@ open stack(stack, _);\n    nodes_dispose(stack->head);\n    free(stack);\n}\n\nbool stack_is_empty(stack_t* stack)\n    //@ requires stack(stack, ?size);\n    //@ ensures  stack(stack, size) &*& result == (size == 0);\n{\n    //@ open stack(stack, size);\n    node_t* head = stack->head;\n\n    //@ open nodes(head, size);\n    return stack->head == 0;\n    //@ close nodes(head, size);\n    //@ close stack(stack, size);\n}\n\nint main()\n    //@ requires true;\n    //@ ensures  true;\n{\n    stack_t* stack = create_stack();\n    stack_push(stack, 10);\n    stack_push(stack, 20);\n    stack_pop(stack);\n    stack_pop(stack);\n    stack_dispose(stack);\n\n    return 0;\n}\n\n", "comment_ratio": 0.2413793103448276}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n#import \"JRFPPopoverController.h\"\n#import \"JRHintViewController.h\"\n#import \"JRAlert.h\"\n#import \"JRAlertTypes.h\"\n\n@interface JRAlertManager : NSObject\n\n+ (JRAlertManager *)sharedManager;\n\n- (JRFPPopoverController *)messagePopoverWithType:(JRMessagePopoverType)popoverType withStringParams:(NSArray *)stringParams andUnderlyingView:(UIView *)underlyingView;\n- (JRFPPopoverController *)messagePopoverWithType:(JRMessagePopoverType)popoverType withStringParams:(NSArray *)stringParams andUnderlyingView:(UIView *)underlyingView maxNumberOfShowing:(NSInteger)maxNumberOfShowing;\n\n- (JRAlert *)alertWithId:(JRAlertType)alertType withStringParams:(NSArray *)stringParams andDelegate:(id<JRAlertDelegate>) delegate;\n- (JRAlert *)showAlertWithId:(JRAlertType)alertType withStringParams:(NSArray *)stringParams andDelegate:(id<JRAlertDelegate>) delegate;\n- (JRAlert *)showAlertWithId:(JRAlertType)alertType withStringParams:(NSArray *)stringParams andBlock:(void (^)(NSInteger clickedButtonAtIndex))actionBlock;\n\n- (BOOL)screenshotsShowNextAlert;\n- (BOOL)screenshotsShowNextPopoverUnderlyingView:(UIView *)underlyingView;\n\n@end\n\n", "comment_ratio": 0.20689655172413793}
{"lang": "c", "code": "#ifndef GN_SW2DCV_H\n#define GN_SW2DCV_H\n#include \"ArgumentsDict.h\"\n#include \"CompKernel.h\"\n#include \"ModelFactory.h\"\n#include \"xtensor-python/pyarray.hpp\"\n#include <assert.h>\n#include <cmath>\n#include <iostream>\n#include <valarray>\n\nnamespace py = pybind11;\n\n#define GLOBAL_FCT 0\n#define POWER_SMOOTHNESS_INDICATOR 4\n#define VEL_FIX_POWER 2.\n#define REESTIMATE_MAX_EDGE_BASED_CFL 0\n#define LAMBDA_MGN 1\n#define IF_BOTH_GAMMA_BRANCHES 0\n#define LIMITING_ITERATION 2\n\nnamespace proteus {\n\n// for mGN stuff \"max\" wave speeds. See section 4.4 of first mGN paper by\n// Guermond, Popov, Tovar, Kees for formulas\ninline double GN_nu1(const double &g, const double &hL, const double &uL,\n                     const double &etaL, const double &meshSizeL) {\n\n  double augL = LAMBDA_MGN / (3. * meshSizeL) * (6. * hL + 12. * (hL - etaL));\n\n  if (etaL >= hL) {\n    augL = LAMBDA_MGN / (3. * meshSizeL) * (6. * hL);\n  }\n  augL = augL * std::pow(meshSizeL / fmax(meshSizeL, hL), 2);\n\n  return uL - sqrt(g * hL) * sqrt(1. + augL);\n}\ninline double GN_nu3(const double &g, const double &hR, const double &uR,\n                     const double &etaR, const double &meshSizeR) {\n  // See section 4.4 of first mGN paper by Guermond, Popov, Tovar, Kees for\n  // formulas\n  double augR = LAMBDA_MGN / (3. * meshSizeR) * (6. * hR + 12. * (hR - etaR));\n\n  if (etaR >= hR) {\n    augR = LAMBDA_MGN / (3. * meshSizeR) * (6. * hR);\n  }\n  augR = augR * std::pow(meshSizeR / fmax(meshSizeR, hR), 2);\n  return uR + sqrt(g * hR) * sqrt(1 + augR);\n}\n\n// FOR CELL BASED ENTROPY VISCOSITY\ninline double ENTROPY(const double &g, const double &h, const double &hu,\n                      const double &hv, const double &z,\n                      const double &one_over_hReg) {\n  return 0.5 *\n         (g * h * h + one_over_hReg * (hu * hu + hv * hv) + 2. * g * h * z);\n}\ninline double DENTROPY_DH(const double &g, const double &h, const double &hu,\n                          const double &hv, const double &z,\n                          const double &one_over_hReg) {\n  return g * h - 0.5 * (hu * hu + hv * hv) * std::pow(one_over_hReg, 2) + g * z;\n}\ninline double DENTROPY_DHU(const double &g, const double &h, const double &hu,\n                           const double &hv, const double &z,\n                           const double &one_over_hReg) {\n  return hu * one_over_hReg;\n}\ninline double DENTROPY_DHV(const double &g, const double &h, const double &hu,\n                           const double &hv, const double &z,\n                           const double &one_over_hReg) {\n  return hv * one_over_hReg;\n}\ninline double ENTROPY_FLUX1(const double &g, const double &h, const double &hu,\n                            const double &hv, const double &z,\n                            const double &one_over_hReg) {\n  return (ENTROPY(g, h, hu, hv, z, one_over_hReg) + 0.5 * g * h * h +\n          g * h * z) *\n         hu * one_over_hReg;\n}\ninline double ENTROPY_FLUX2(const double &g, const double &h, const double &hu,\n                            const double &hv, const double &z,\n                            const double &one_over_hReg) {\n  return (ENTROPY(g, h, hu, hv, z, one_over_hReg) + 0.5 * g * h * h +\n          g * h * z) *\n         hv * one_over_hReg;\n}\n// FOR ESTIMATING MAX WAVE SPEEDS\ninline double f(const double &g, const double &h, const double &hZ) {\n  return ((h <= hZ) ? 2. * (sqrt(g * h) - sqrt(g * hZ))\n                    : (h - hZ) * sqrt(0.5 * g * (h + hZ) / h / hZ));\n}\ninline double phi(const double &g, const double &h, const double &hL,\n                  const double &hR, const double &uL, const double &uR) {\n  return (f(g, h, hL) + f(g, h, hR) + uR - uL);\n}\ninline double fp(const double &g, const double &h, const double &hZ) {\n  return ((h <= hZ)\n              ? sqrt(g / h)\n              : g * (2 * h * h + h * hZ + hZ * hZ) /\n                    (2 * sqrt(2 * g) * h * h * hZ * sqrt(1 / h + 1 / hZ)));\n}\ninline double phip(const double &g, const double &h, const double &hL,\n                   const double &hR) {\n  return (fp(g, h, hL) + fp(g, h, hR));\n}\ninline double nu1(const double &g, const double &hStar, const double &hL,\n                  const double &uL) {\n  return (uL - sqrt(g * hL) * sqrt((1. + fmax((hStar - hL) / 2. / hL, 0.0)) *\n                                   (1. + fmax((hStar - hL) / hL, 0.))));\n}\ninline double nu3(const double &g, const double &hStar, const double &hR,\n                  const double &uR) {\n  return (uR + sqrt(g * hR) * sqrt((1. + fmax((hStar - hR) / 2. / hR, 0.0)) *\n                                   (1. + fmax((hStar - hR) / hR, 0.))));\n}\ninline double phiDiff(const double &g, const double &h1k, const double &h2k,\n                      const double &hL, const double &hR, const double &uL,\n                      const double &uR) {\n  return ((phi(g, h2k, hL, hR, uL, uR) - phi(g, h1k, hL, hR, uL, uR)) /\n          (h2k - h1k));\n}\ninline double phiDDiff1(const double &g, const double &h1k, const double &h2k,\n                        const double &hL, const double &hR, const double &uL,\n                        const double &uR) {\n  return ((phiDiff(g, h1k, h2k, hL, hR, uL, uR) - phip(g, h1k, hL, hR)) /\n          (h2k - h1k));\n}\ninline double phiDDiff2(const double &g, const double &h1k, const double &h2k,\n                        const double &hL, const double &hR, const double &uL,\n                        const double &uR) {\n  return ((phip(g, h2k, hL, hR) - phiDiff(g, h1k, h2k, hL, hR, uL, uR)) /\n          (h2k - h1k));\n}\ninline double hStarLFromQuadPhiFromAbove(const double &g, const double &hStarL,\n                                         const double &hStarR, const double &hL,\n                                         const double &hR, const double &uL,\n                                         const double &uR) {\n  return (hStarL -\n          2 * phi(g, hStarL, hL, hR, uL, uR) /\n              (phip(g, hStarL, hL, hR) +\n               sqrt(std::pow(phip(g, hStarL, hL, hR), 2) -\n                    4 * phi(g, hStarL, hL, hR, uL, uR) *\n                        phiDDiff1(g, hStarL, hStarR, hL, hR, uL, uR))));\n}\ninline double hStarRFromQuadPhiFromBelow(const double &g, const double &hStarL,\n                                         const double &hStarR, const double &hL,\n                                         const double &hR, const double &uL,\n                                         const double &uR) {\n  return (hStarR -\n          2 * phi(g, hStarR, hL, hR, uL, uR) /\n              (phip(g, hStarR, hL, hR) +\n               sqrt(std::pow(phip(g, hStarR, hL, hR), 2) -\n                    4 * phi(g, hStarR, hL, hR, uL, uR) *\n                        phiDDiff2(g, hStarL, hStarR, hL, hR, uL, uR))));\n}\n} // namespace proteus\n\nnamespace proteus {\nclass GN_SW2DCV_base {\npublic:\n  std::valarray<double> Rneg, Rpos, Rneg_heta, Rpos_heta, hLow, huLow, hvLow,\n      hetaLow, hwLow, Kmax;\n  virtual ~GN_SW2DCV_base() {}\n  virtual void convexLimiting(arguments_dict &args) = 0;\n  virtual double calculateEdgeBasedCFL(arguments_dict &args) = 0;\n  virtual void calculateResidual(arguments_dict &args) = 0;\n  virtual void calculateMassMatrix(arguments_dict &args) = 0;\n  virtual void calculateLumpedMassMatrix(arguments_dict &args) = 0;\n};\n\ntemplate <class CompKernelType, int nSpace, int nQuadraturePoints_element,\n          int nDOF_mesh_trial_element, int nDOF_trial_element,\n          int nDOF_test_element, int nQuadraturePoints_elementBoundary>\nclass GN_SW2DCV : public GN_SW2DCV_base {\npublic:\n  const int nDOF_test_X_trial_element;\n  CompKernelType ck;\n  GN_SW2DCV()\n      : nDOF_test_X_trial_element(nDOF_test_element * nDOF_trial_element),\n        ck() {\n    std::cout << \"Constructing GN_SW2DCV<CompKernelTemplate<\" << nSpace << \",\"\n              << nQuadraturePoints_element << \",\" << nDOF_mesh_trial_element\n              << \",\" << nDOF_trial_element << \",\" << nDOF_test_element << \",\"\n              << nQuadraturePoints_elementBoundary << \">());\" << std::endl\n              << std::flush;\n  }\n\n  inline double maxWaveSpeedSharpInitialGuess(double g, double nx, double ny,\n                                              double hL, double huL, double hvL,\n                                              double hetaL, double lumpedL,\n                                              double hR, double huR, double hvR,\n                                              double hetaR, double lumpedR,\n                                              double hEpsL, double hEpsR,\n                                              bool debugging) {\n    double lambda1, lambda3;\n\n    double hVelL = nx * huL + ny * hvL;\n    double hVelR = nx * huR + ny * hvR;\n    double velL = 2.0 * hL / (hL * hL + std::pow(fmax(hL, hEpsL), 2)) * hVelL;\n    double velR = 2.0 * hR / (hR * hR + std::pow(fmax(hR, hEpsR), 2)) * hVelR;\n    double etaL = 2.0 * hL / (hL * hL + std::pow(fmax(hL, hEpsL), 2)) * hetaL;\n    double etaR = 2.0 * hR / (hR * hR + std::pow(fmax(hR, hEpsR), 2)) * hetaR;\n    double meshSizeL = sqrt(lumpedL);\n    double meshSizeR = sqrt(lumpedR);\n\n    /* See equation 4.12 from mGN paper:\n      1-eigenvalue: uL-sqrt(g*hL)*sqrt(1 + augL)\n      3-eigenvalue: uR+sqrt(g*hR)*sqrt(1 + augR)\n    */\n    lambda1 = GN_nu1(g, hL, velL, etaL, meshSizeL);\n    lambda3 = GN_nu3(g, hR, velR, etaR, meshSizeR);\n\n    return fmax(fabs(lambda1), fabs(lambda3));\n  }\n\n  /* I'm not sure if this is needed. -EJT */\n  inline void calculateCFL(const double &elementDiameter, const double &g,\n                           const double &h, const double &hu, const double &hv,\n                           const double hEps, double &cfl) {\n    double cflx, cfly, c = sqrt(fmax(g * hEps, g * h));\n    double u = 2 * h / (h * h + std::pow(fmax(h, hEps), 2)) * hu;\n    double v = 2 * h / (h * h + std::pow(fmax(h, hEps), 2)) * hv;\n\n    if (u > 0.0)\n      cflx = (u + c) / elementDiameter;\n    else\n      cflx = fabs(u - c) / elementDiameter;\n\n    if (v > 0.0)\n      cfly = (v + c) / elementDiameter;\n    else\n      cfly = fabs(v - c) / elementDiameter;\n    cfl = sqrt(cflx * cflx + cfly * cfly); // hack, conservative estimate\n  }\n  void convexLimiting(arguments_dict &args) {\n    double dt = args.m_dscalar[\"dt\"];\n    int NNZ = args.m_iscalar[\"NNZ\"];\n    int numDOFs = args.m_iscalar[\"numDOFs\"];\n    xt::pyarray<double> &lumped_mass_matrix =\n        args.m_darray[\"lumped_mass_matrix\"];\n    xt::pyarray<double> &h_old = args.m_darray[\"h_old\"];\n    xt::pyarray<double> &hu_old = args.m_darray[\"hu_old\"];\n    xt::pyarray<double> &hv_old = args.m_darray[\"hv_old\"];\n    xt::pyarray<double> &heta_old = args.m_darray[\"heta_old\"];\n    xt::pyarray<double> &hw_old = args.m_darray[\"hw_old\"];\n    xt::pyarray<double> &b_dof = args.m_darray[\"b_dof\"];\n    xt::pyarray<double> &high_order_hnp1 = args.m_darray[\"high_order_hnp1\"];\n    xt::pyarray<double> &high_order_hunp1 = args.m_darray[\"high_order_hunp1\"];\n    xt::pyarray<double> &high_order_hvnp1 = args.m_darray[\"high_order_hvnp1\"];\n    xt::pyarray<double> &high_order_hetanp1 =\n        args.m_darray[\"high_order_hetanp1\"];\n    xt::pyarray<double> &high_order_hwnp1 = args.m_darray[\"high_order_hwnp1\"];\n    xt::pyarray<double> &extendedSourceTerm_hu =\n        args.m_darray[\"extendedSourceTerm_hu\"];\n    xt::pyarray<double> &extendedSourceTerm_hv =\n        args.m_darray[\"extendedSourceTerm_hv\"];\n    xt::pyarray<double> &extendedSourceTerm_heta =\n        args.m_darray[\"extendedSourceTerm_heta\"];\n    xt::pyarray<double> &extendedSourceTerm_hw =\n        args.m_darray[\"extendedSourceTerm_hw\"];\n    xt::pyarray<double> &limited_hnp1 = args.m_darray[\"limited_hnp1\"];\n    xt::pyarray<double> &limited_hunp1 = args.m_darray[\"limited_hunp1\"];\n    xt::pyarray<double> &limited_hvnp1 = args.m_darray[\"limited_hvnp1\"];\n    xt::pyarray<double> &limited_hetanp1 = args.m_darray[\"limited_hetanp1\"];\n    xt::pyarray<double> &limited_hwnp1 = args.m_darray[\"limited_hwnp1\"];\n    xt::pyarray<int> &csrRowIndeces_DofLoops =\n        args.m_iarray[\"csrRowIndeces_DofLoops\"];\n    xt::pyarray<int> &csrColumnOffsets_DofLoops =\n        args.m_iarray[\"csrColumnOffsets_DofLoops\"];\n    xt::pyarray<double> &MassMatrix = args.m_darray[\"MassMatrix\"];\n    xt::pyarray<double> &dH_minus_dL = args.m_darray[\"dH_minus_dL\"];\n    xt::pyarray<double> &muH_minus_muL = args.m_darray[\"muH_minus_muL\"];\n    double hEps = args.m_dscalar[\"hEps\"];\n    xt::pyarray<double> &hReg = args.m_darray[\"hReg\"];\n    int LUMPED_MASS_MATRIX = args.m_iscalar[\"LUMPED_MASS_MATRIX\"];\n    xt::pyarray<double> &dLow = args.m_darray[\"dLow\"];\n    xt::pyarray<double> &hBT = args.m_darray[\"hBT\"];\n    xt::pyarray<double> &huBT = args.m_darray[\"huBT\"];\n    xt::pyarray<double> &hvBT = args.m_darray[\"hvBT\"];\n    xt::pyarray<double> &hetaBT = args.m_darray[\"hetaBT\"];\n    xt::pyarray<double> &hwBT = args.m_darray[\"hwBT\"];\n    xt::pyarray<double> &new_SourceTerm_hu = args.m_darray[\"new_SourceTerm_hu\"];\n    xt::pyarray<double> &new_SourceTerm_hv = args.m_darray[\"new_SourceTerm_hv\"];\n    xt::pyarray<double> &new_SourceTerm_heta =\n        args.m_darray[\"new_SourceTerm_heta\"];\n    xt::pyarray<double> &new_SourceTerm_hw = args.m_darray[\"new_SourceTerm_hw\"];\n    double size_of_domain = args.m_dscalar[\"size_of_domain\"];\n    Rneg.resize(numDOFs, 0.0);\n    Rpos.resize(numDOFs, 0.0);\n    Rneg_heta.resize(numDOFs, 0.0);\n    Rpos_heta.resize(numDOFs, 0.0);\n    hLow.resize(numDOFs, 0.0);\n    huLow.resize(numDOFs, 0.0);\n    hvLow.resize(numDOFs, 0.0);\n    hetaLow.resize(numDOFs, 0.0);\n    hwLow.resize(numDOFs, 0.0);\n    Kmax.resize(numDOFs, 0.0);\n\n    // for relaxation of bounds\n    std::valarray<double> urelax(0.0, numDOFs);\n    std::valarray<double> drelax(0.0, numDOFs);\n\n    // for h\n    std::valarray<double> h_min(0.0, numDOFs);\n    std::valarray<double> h_max(0.0, numDOFs);\n    std::valarray<double> delta_Sqd_h(0.0, numDOFs);\n    std::valarray<double> bar_deltaSqd_h(0.0, numDOFs);\n\n    // for heta\n    std::valarray<double> heta_min(0.0, numDOFs);\n    std::valarray<double> heta_max(0.0, numDOFs);\n    std::valarray<double> delta_Sqd_heta(0.0, numDOFs);\n    std::valarray<double> bar_deltaSqd_heta(0.0, numDOFs);\n\n    // for kinetic energy\n    xt::pyarray<double> kin(numDOFs);\n    xt::pyarray<double> max_of_h_and_hEps(numDOFs);\n    std::valarray<double> kin_max(0.0, numDOFs);\n    std::valarray<double> delta_Sqd_kin(0.0, numDOFs);\n    std::valarray<double> bar_deltaSqd_kin(0.0, numDOFs);\n\n    // Create FCT component matrices in vector form\n    std::valarray<double> FCT_h(0.0, dH_minus_dL.size());\n    std::valarray<double> FCT_hu(0.0, dH_minus_dL.size());\n    std::valarray<double> FCT_hv(0.0, dH_minus_dL.size());\n    std::valarray<double> FCT_heta(0.0, dH_minus_dL.size());\n    std::valarray<double> FCT_hw(0.0, dH_minus_dL.size());\n\n    // Define kinetic energy, kin = 1/2 q^2 / h\n    max_of_h_and_hEps = xt::where(h_old > hEps, h_old, hEps);\n    kin = 0.5 * (hu_old * hu_old + hv_old * hv_old);\n    kin *=\n        2.0 * h_old / (h_old * h_old + max_of_h_and_hEps * max_of_h_and_hEps);\n\n    // We first do the loops to define the relaxation quantities\n    // First relaxation loop\n    for (int i = 0; i < numDOFs; i++) {\n      urelax[i] =\n          1.0 +\n          2.0 * std::pow(sqrt(sqrt(lumped_mass_matrix[i] / size_of_domain)), 3);\n      drelax[i] =\n          1.0 -\n          2.0 * std::pow(sqrt(sqrt(lumped_mass_matrix[i] / size_of_domain)), 3);\n      for (int offset = csrRowIndeces_DofLoops[i];\n           offset < csrRowIndeces_DofLoops[i + 1]; offset++) {\n        int j = csrColumnOffsets_DofLoops[offset];\n        if (i != j) {\n          delta_Sqd_h[i] += h_old[i] - h_old[j];\n          delta_Sqd_heta[i] += heta_old[i] - heta_old[j];\n          delta_Sqd_kin[i] += kin[i] - kin[j];\n        }\n      } // j loop ends here\n    }   // i loops ends here\n\n    // Second relaxation loop\n    for (int i = 0; i < numDOFs; i++) {\n      for (int offset = csrRowIndeces_DofLoops[i];\n           offset < csrRowIndeces_DofLoops[i + 1]; offset++) {\n        int j = csrColumnOffsets_DofLoops[offset];\n        if (i != j) {\n          bar_deltaSqd_h[i] += delta_Sqd_h[j] + delta_Sqd_h[i];\n          bar_deltaSqd_heta[i] += delta_Sqd_heta[j] + delta_Sqd_heta[i];\n          bar_deltaSqd_kin[i] += delta_Sqd_kin[j] + delta_Sqd_kin[i];\n        }\n      } // j loop ends here\n      bar_deltaSqd_h[i] =\n          bar_deltaSqd_h[i] /\n          (csrRowIndeces_DofLoops[i + 1] - csrRowIndeces_DofLoops[i]) / 2.0;\n      bar_deltaSqd_heta[i] =\n          bar_deltaSqd_heta[i] /\n          (csrRowIndeces_DofLoops[i + 1] - csrRowIndeces_DofLoops[i]) / 2.0;\n      bar_deltaSqd_kin[i] =\n          bar_deltaSqd_kin[i] /\n          (csrRowIndeces_DofLoops[i + 1] - csrRowIndeces_DofLoops[i]) / 2.0;\n    } // i loops ends here\n\n    ////////////////////////////////////////////////////////\n    // Loop to define local bounds and low order solution //\n    ////////////////////////////////////////////////////////\n    int ij = 0;\n    for (int i = 0; i < numDOFs; i++) {\n\n      // define m_i\n      double mi = lumped_mass_matrix[i];\n\n      /* Initialize hmin, hmax, heta_min, heta_max */\n      h_min[i] = h_old[i];\n      h_max[i] = h_old[i];\n      heta_min[i] = heta_old[i];\n      heta_max[i] = heta_old[i];\n\n      /* Initialize low order solution */\n      hLow[i] = h_old[i];\n      huLow[i] = hu_old[i];\n      hvLow[i] = hv_old[i];\n      hetaLow[i] = heta_old[i];\n      hwLow[i] = hw_old[i];\n      Kmax[i] = kin[i];\n\n      /* LOOP OVER THE SPARSITY PATTERN (j-LOOP) */\n      for (int offset = csrRowIndeces_DofLoops[i];\n           offset < csrRowIndeces_DofLoops[i + 1]; offset++) {\n        int j = csrColumnOffsets_DofLoops[offset];\n        double psi_ij = 0;\n        double one_over_hBT =\n            2.0 * hBT[ij] /\n            (hBT[ij] * hBT[ij] + std::pow(fmax(hBT[ij], hEps), 2));\n        psi_ij = one_over_hBT * (huBT[ij] * huBT[ij] + hvBT[ij] * hvBT[ij]) /\n                 2.0; // Eqn (6.31)\n\n        // COMPUTE LOCAL BOUNDS //\n        Kmax[i] = fmax(psi_ij, Kmax[i]);\n        h_min[i] = std::min(h_min[i], hBT[ij]);\n        h_max[i] = std::max(h_max[i], hBT[ij]);\n        heta_min[i] = std::min(heta_min[i], hetaBT[ij]);\n        heta_max[i] = std::max(heta_max[i], hetaBT[ij]);\n\n        // Then do relaxation of bounds here. If confused, see (4.12) of Euler\n        // convex limiting paper.\n        Kmax[i] = std::min(urelax[i] * Kmax[i],\n                           Kmax[i] + std::abs(bar_deltaSqd_kin[i]) / 2.0);\n        h_min[i] = std::max(drelax[i] * h_min[i],\n                            h_min[i] - std::abs(bar_deltaSqd_h[i]) / 2.0);\n        h_max[i] = std::min(urelax[i] * h_max[i],\n                            h_max[i] + std::abs(bar_deltaSqd_h[i]) / 2.0);\n        heta_min[i] =\n            std::max(drelax[i] * heta_min[i],\n                     heta_min[i] - std::abs(bar_deltaSqd_heta[i]) / 2.0);\n        heta_max[i] =\n            std::min(urelax[i] * heta_max[i],\n                     heta_max[i] + std::abs(bar_deltaSqd_heta[i]) / 2.0);\n\n        /* COMPUTE LOW ORDER SOLUTION. See EQN 6.23 in SW friction paper */\n        // This is low order solution WITHOUT sources\n        if (i != j) {\n          hLow[i] += h_old[i] * (-dt / mi * 2 * dLow[ij]) +\n                     dt / mi * (2 * dLow[ij] * hBT[ij]);\n          huLow[i] += hu_old[i] * (-dt / mi * 2 * dLow[ij]) +\n                      dt / mi * (2 * dLow[ij] * huBT[ij]);\n          hvLow[i] += hv_old[i] * (-dt / mi * 2 * dLow[ij]) +\n                      dt / mi * (2 * dLow[ij] * hvBT[ij]);\n          hetaLow[i] += heta_old[i] * (-dt / mi * 2 * dLow[ij]) +\n                        dt / mi * (2 * dLow[ij] * hetaBT[ij]);\n          hwLow[i] += hw_old[i] * (-dt / mi * 2 * dLow[ij]) +\n                      dt / mi * (2 * dLow[ij] * hwBT[ij]);\n        }\n        // UPDATE ij //\n        ij += 1;\n      } // j loop ends here\n\n      // clean up hLow from round off error\n      if (hLow[i] < hEps)\n        hLow[i] = 0.0;\n    } // i loop ends here\n\n    ////////////////////////////////////////////////////\n    // Loop to define FCT matrices for each component //\n    ////////////////////////////////////////////////////\n    ij = 0;\n    for (int i = 0; i < numDOFs; i++) {\n      // read some vectors\n      double high_order_hnp1i = high_order_hnp1[i];\n      double high_order_hunp1i = high_order_hunp1[i];\n      double high_order_hvnp1i = high_order_hvnp1[i];\n      double high_order_hetanp1i = high_order_hetanp1[i];\n      double high_order_hwnp1i = high_order_hwnp1[i];\n      double hi = h_old[i];\n      double huni = hu_old[i];\n      double hvni = hv_old[i];\n      double hetani = heta_old[i];\n      double hwni = hw_old[i];\n      double Zi = b_dof[i];\n      double mi = lumped_mass_matrix[i];\n      double one_over_hiReg =\n          2 * hi / (hi * hi + std::pow(fmax(hi, hEps), 2)); // hEps\n\n      // LOOP OVER THE SPARSITY PATTERN (j-LOOP)//\n      for (int offset = csrRowIndeces_DofLoops[i];\n           offset < csrRowIndeces_DofLoops[i + 1]; offset++) {\n\n        int j = csrColumnOffsets_DofLoops[offset];\n\n        // read some vectors\n        double hj = h_old[j];\n        double hunj = hu_old[j];\n        double hvnj = hv_old[j];\n        double hetanj = heta_old[j];\n        double hwnj = hw_old[j];\n        double Zj = b_dof[j];\n        double one_over_hjReg =\n            2. * hj / (hj * hj + std::pow(fmax(hj, hEps), 2)); // hEps\n\n        // COMPUTE STAR SOLUTION // hStar, huStar, hvStar, hetaStar, and\n        // hwStar\n        double hStarij = fmax(0., hi + Zi - fmax(Zi, Zj));\n        double huStarij = huni * hStarij * one_over_hiReg;\n        double hvStarij = hvni * hStarij * one_over_hiReg;\n        double hetaStarij = hetani * std::pow(hStarij * one_over_hiReg, 2);\n        double hwStarij = hwni * std::pow(hStarij * one_over_hiReg, 2);\n\n        double hStarji = fmax(0., hj + Zj - fmax(Zi, Zj));\n        double huStarji = hunj * hStarji * one_over_hjReg;\n        double hvStarji = hvnj * hStarji * one_over_hjReg;\n        double hetaStarji = hetanj * std::pow(hStarji * one_over_hjReg, 2);\n        double hwStarji = hwnj * std::pow(hStarji * one_over_hjReg, 2);\n\n        // i-th row of flux correction matrix\n        double ML_minus_MC = (LUMPED_MASS_MATRIX == 1\n                                  ? 0.\n                                  : (i == j ? 1. : 0.) * mi - MassMatrix[ij]);\n\n        FCT_h[ij] =\n            ML_minus_MC * (high_order_hnp1[j] - hj - (high_order_hnp1i - hi)) +\n            dt * (dH_minus_dL[ij] - muH_minus_muL[ij]) * (hStarji - hStarij) +\n            dt * muH_minus_muL[ij] * (hj - hi);\n\n        FCT_hu[ij] =\n            ML_minus_MC *\n                (high_order_hunp1[j] - hunj - (high_order_hunp1i - huni)) +\n            dt * (dH_minus_dL[ij] - muH_minus_muL[ij]) * (huStarji - huStarij) +\n            dt * muH_minus_muL[ij] * (hunj - huni);\n\n        FCT_hv[ij] =\n            ML_minus_MC *\n                (high_order_hvnp1[j] - hvnj - (high_order_hvnp1i - hvni)) +\n            dt * (dH_minus_dL[ij] - muH_minus_muL[ij]) * (hvStarji - hvStarij) +\n            dt * muH_minus_muL[ij] * (hvnj - hvni);\n\n        FCT_heta[ij] = ML_minus_MC * (high_order_hetanp1[j] - hetanj -\n                                      (high_order_hetanp1i - hetani)) +\n                       dt * (dH_minus_dL[ij] - muH_minus_muL[ij]) *\n                           (hetaStarji - hetaStarij) +\n                       dt * muH_minus_muL[ij] * (hetanj - hetani);\n\n        FCT_hw[ij] =\n            ML_minus_MC *\n                (high_order_hwnp1[j] - hwnj - (high_order_hwnp1i - hwni)) +\n            dt * (dH_minus_dL[ij] - muH_minus_muL[ij]) * (hwStarji - hwStarij) +\n            dt * muH_minus_muL[ij] * (hwnj - hwni);\n        // UPDATE ij //\n        ij += 1;\n      } // j loop ends here\n    }   // i loop ends here\n\n    ////////////////////////////////////////////////////////////////////\n    // Main loop to define limiters and computed limited solution //////\n    ////////////////////////////////////////////////////////////////////\n\n    // Create Lij_array for initialization\n    std::valarray<double> Lij_array(1.0, dH_minus_dL.size());\n\n    for (int limit_iter = 0; limit_iter < LIMITING_ITERATION; limit_iter++) {\n\n      /* Loop to define FCT Rpos and Rneg values */\n      ij = 0;\n      for (int i = 0; i < numDOFs; i++) {\n        // read some vectors\n        double mi = lumped_mass_matrix[i];\n\n        // Initialize Pneg and Ppos quantities at ith node\n        double Pnegi = 0., Pposi = 0.;\n        double Pnegi_heta = 0., Pposi_heta = 0.;\n\n        // LOOP OVER THE SPARSITY PATTERN (j-LOOP)//\n        for (int offset = csrRowIndeces_DofLoops[i];\n             offset < csrRowIndeces_DofLoops[i + 1]; offset++) {\n\n          int j = csrColumnOffsets_DofLoops[offset];\n\n          // COMPUTE P VECTORS //\n          Pnegi += FCT_h[ij] * ((FCT_h[ij] < 0) ? 1. : 0.);\n          Pposi += FCT_h[ij] * ((FCT_h[ij] > 0) ? 1. : 0.);\n          Pnegi_heta += FCT_heta[ij] * ((FCT_heta[ij] < 0) ? 1. : 0.);\n          Pposi_heta += FCT_heta[ij] * ((FCT_heta[ij] > 0) ? 1. : 0.);\n\n          // UPDATE ij //\n          ij += 1;\n        } // j loop ends here\n\n        ///////////////////////\n        // COMPUTE Q VECTORS //\n        ///////////////////////\n        double Qnegi = std::min(mi * (h_min[i] - hLow[i]), 0.0);\n        double Qposi = std::max(mi * (h_max[i] - hLow[i]), 0.0);\n        double Qnegi_heta = std::min(mi * (heta_min[i] - hetaLow[i]), 0.0);\n        double Qposi_heta = std::max(mi * (heta_max[i] - hetaLow[i]), 0.0);\n\n        ///////////////////////\n        // COMPUTE R VECTORS //\n        ///////////////////////\n        if (high_order_hnp1[i] <= hEps) // hEps\n        {\n          Rneg[i] = 0.;\n          Rpos[i] = 0.;\n          Rneg_heta[i] = 0.;\n          Rpos_heta[i] = 0.;\n        } else {\n          Rneg[i] = ((Pnegi == 0) ? 1. : std::min(1.0, Qnegi / Pnegi));\n          Rpos[i] = ((Pposi == 0) ? 1. : std::min(1.0, Qposi / Pposi));\n          Rneg_heta[i] =\n              ((Pnegi_heta == 0) ? 1. : std::min(1.0, Qnegi_heta / Pnegi_heta));\n          Rpos_heta[i] =\n              ((Pposi_heta == 0) ? 1. : std::min(1.0, Qposi_heta / Pposi_heta));\n        }\n      } // i loop ends here\n\n      /* Here we compute the limiters */\n      ij = 0;\n      for (int i = 0; i < numDOFs; i++) {\n        // read some vectors\n        double high_order_hnp1i = high_order_hnp1[i];\n        double high_order_hunp1i = high_order_hunp1[i];\n        double high_order_hvnp1i = high_order_hvnp1[i];\n        double high_order_hetanp1i = high_order_hetanp1[i];\n        double high_order_hwnp1i = high_order_hwnp1[i];\n        double hi = h_old[i];\n        double huni = hu_old[i];\n        double hvni = hv_old[i];\n        double hetani = heta_old[i];\n        double hwni = hw_old[i];\n        double Zi = b_dof[i];\n        double mi = lumped_mass_matrix[i];\n        double one_over_hiReg =\n            2 * hi / (hi * hi + std::pow(fmax(hi, hEps), 2)); // hEps\n\n        double ith_Limiter_times_FluxCorrectionMatrix1 = 0.;\n        double ith_Limiter_times_FluxCorrectionMatrix2 = 0.;\n        double ith_Limiter_times_FluxCorrectionMatrix3 = 0.;\n        double ith_Limiter_times_FluxCorrectionMatrix4 = 0.;\n        double ith_Limiter_times_FluxCorrectionMatrix5 = 0.;\n\n        double ci =\n            Kmax[i] * hLow[i] -\n            0.5 * (huLow[i] * huLow[i] + hvLow[i] * hvLow[i]); // for KE lim.\n\n        // LOOP OVER THE SPARSITY PATTERN (j-LOOP)//\n        for (int offset = csrRowIndeces_DofLoops[i];\n             offset < csrRowIndeces_DofLoops[i + 1]; offset++) {\n          int j = csrColumnOffsets_DofLoops[offset];\n          // read some vectors\n          double hj = h_old[j];\n          double hunj = hu_old[j];\n          double hvnj = hv_old[j];\n          double hetanj = heta_old[j];\n          double hwnj = hw_old[j];\n          double Zj = b_dof[j];\n          double one_over_hjReg =\n              2 * hj / (hj * hj + std::pow(fmax(hj, hEps), 2)); // hEps\n\n          // COMPUTE STAR SOLUTION // hStar, huStar, hvStar, hetaStar, and\n          // hwStar\n          double hStarij = fmax(0., hi + Zi - fmax(Zi, Zj));\n          double huStarij = huni * hStarij * one_over_hiReg;\n          double hvStarij = hvni * hStarij * one_over_hiReg;\n          double hetaStarij = hetani * std::pow(hStarij * one_over_hiReg, 2);\n          double hwStarij = hwni * std::pow(hStarij * one_over_hiReg, 2);\n\n          double hStarji = fmax(0., hj + Zj - fmax(Zi, Zj));\n          double huStarji = hunj * hStarji * one_over_hjReg;\n          double hvStarji = hvnj * hStarji * one_over_hjReg;\n          double hetaStarji = hetanj * std::pow(hStarji * one_over_hjReg, 2);\n          double hwStarji = hwnj * std::pow(hStarji * one_over_hjReg, 2);\n\n          // compute limiter based on water height\n          double Lij = 1.0;\n          if (FCT_h[ij] >= 0) {\n            Lij = fmin(Lij, std::min(Rneg[j], Rpos[i]));\n            Lij_array[ij] = fmin(Lij_array[ij], std::min(Rneg[j], Rpos[i]));\n          } else {\n            Lij = fmin(Lij, std::min(Rneg[i], Rpos[j]));\n            Lij_array[ij] = fmin(Lij_array[ij], std::min(Rneg[i], Rpos[j]));\n          }\n\n          // COMPUTE LIMITER based on heta -EJT\n          // Note that we set lij = min(lij_h,lij_heta)\n          if (FCT_heta[ij] >= 0) {\n            Lij = fmin(Lij, std::min(Rneg_heta[j], Rpos_heta[i]));\n            Lij_array[ij] =\n                fmin(Lij_array[ij], std::min(Rneg_heta[j], Rpos_heta[i]));\n          } else {\n            Lij = fmin(Lij, std::min(Rneg_heta[i], Rpos_heta[j]));\n            Lij_array[ij] =\n                fmin(Lij_array[ij], std::min(Rneg_heta[i], Rpos_heta[j]));\n          }\n\n          double lambdaj =\n              csrRowIndeces_DofLoops[i + 1] - csrRowIndeces_DofLoops[i] - 1;\n          double Ph_ij = FCT_h[ij] / mi / lambdaj;\n          double Phu_ij = FCT_hu[ij] / mi / lambdaj;\n          double Phv_ij = FCT_hv[ij] / mi / lambdaj;\n\n          double ai = -0.5 * (Phu_ij * Phu_ij + Phv_ij * Phv_ij);\n          double bi = Kmax[i] * Ph_ij - (huLow[i] * Phu_ij + hvLow[i] * Phv_ij);\n\n          double r1 = ai == 0\n                          ? (bi == 0 ? 1. : -ci / bi)\n                          : (-bi + std::sqrt(bi * bi - 4 * ai * ci)) / 2. / ai;\n          double r2 = ai == 0\n                          ? (bi == 0 ? 1. : -ci / bi)\n                          : (-bi - std::sqrt(bi * bi - 4 * ai * ci)) / 2. / ai;\n          if (r1 < 0 && r2 < 0) {\n            r1 = 1.;\n            r2 = 1.;\n          }\n          double ri = fabs(fmax(r1, r2));\n\n          // root of jth-DOF (To compute transpose component)\n          double lambdai =\n              csrRowIndeces_DofLoops[j + 1] - csrRowIndeces_DofLoops[j] - 1;\n          double mj = lumped_mass_matrix[j];\n          double cj = Kmax[j] * hLow[j] -\n                      0.5 * (huLow[j] * huLow[j] + hvLow[j] * hvLow[j]);\n          double Ph_ji = -FCT_h[ij] / mj / lambdai; // Aij=-Aji\n          double Phu_ji = -FCT_hu[ij] / mj / lambdai;\n          double Phv_ji = -FCT_hv[ij] / mj / lambdai;\n          double aj = -0.5 * (Phu_ji * Phu_ji + Phv_ji * Phv_ji);\n          double bj = Kmax[j] * Ph_ji - (huLow[j] * Phu_ji + hvLow[j] * Phv_ji);\n\n          r1 = aj == 0 ? (bj == 0 ? 1. : -cj / bj)\n                       : (-bj + std::sqrt(bj * bj - 4 * aj * cj)) / 2. / aj;\n          r2 = aj == 0 ? (bj == 0 ? 1. : -cj / bj)\n                       : (-bj - std::sqrt(bj * bj - 4 * aj * cj)) / 2. / aj;\n          if (r1 < 0 && r2 < 0) {\n            r1 = 1.;\n            r2 = 1.;\n          }\n          double rj = fabs(fmax(r1, r2));\n\n          // COMPUTE LIMITER //\n          Lij = fmin(fmin(ri, Lij), fmin(rj, Lij)); // Lij=Lji\n          Lij_array[ij] =\n              fmin(fmin(ri, Lij_array[ij]), fmin(rj, Lij_array[ij]));\n\n          // COMPUTE LIMITED FLUX //\n          ith_Limiter_times_FluxCorrectionMatrix1 += Lij_array[ij] * FCT_h[ij];\n          ith_Limiter_times_FluxCorrectionMatrix2 += Lij_array[ij] * FCT_hu[ij];\n          ith_Limiter_times_FluxCorrectionMatrix3 += Lij_array[ij] * FCT_hv[ij];\n          ith_Limiter_times_FluxCorrectionMatrix4 +=\n              Lij_array[ij] * FCT_heta[ij];\n          ith_Limiter_times_FluxCorrectionMatrix5 += Lij_array[ij] * FCT_hw[ij];\n\n          // update ij\n          ij += 1;\n        }\n\n        // update ulow solution\n        double one_over_mi = 1.0 / lumped_mass_matrix[i];\n        hLow[i] += one_over_mi * ith_Limiter_times_FluxCorrectionMatrix1;\n        huLow[i] += one_over_mi * ith_Limiter_times_FluxCorrectionMatrix2;\n        hvLow[i] += one_over_mi * ith_Limiter_times_FluxCorrectionMatrix3;\n        hetaLow[i] += one_over_mi * ith_Limiter_times_FluxCorrectionMatrix4;\n        hwLow[i] += one_over_mi * ith_Limiter_times_FluxCorrectionMatrix5;\n      } // end i loop for computing limiter and sum_j(lij * Aij)\n\n      // update final limted solution, need to change to vector form\n      for (int i = 0; i < numDOFs; i++) {\n        double one_over_mi = 1.0 / lumped_mass_matrix[i];\n        limited_hnp1[i] = hLow[i];\n        limited_hunp1[i] = huLow[i] + dt * one_over_mi * new_SourceTerm_hu[i];\n        limited_hvnp1[i] = hvLow[i] + dt * one_over_mi * new_SourceTerm_hv[i];\n        limited_hetanp1[i] =\n            hetaLow[i] - dt * one_over_mi * extendedSourceTerm_heta[i];\n        limited_hwnp1[i] =\n            hwLow[i] - dt * one_over_mi * extendedSourceTerm_hw[i];\n\n        if (limited_hnp1[i] < -hEps && dt < 1.0) {\n          std::cout << \"Limited water height is negative: \\n \"\n                    << \"hLow: \" << hLow[i] << \"\\n\"\n                    << \"hHigh: \" << limited_hnp1[i] << \"\\n\"\n                    << \"hEps:  \" << hEps << \"\\n\"\n                    << \" ... aborting!\" << std::endl;\n          abort();\n        } else {\n          // clean up uHigh from round off error\n          if (limited_hnp1[i] < hEps)\n            limited_hnp1[i] = 0.0;\n          double aux = fmax(limited_hnp1[i], hEps);\n          limited_hunp1[i] *= 2 * std::pow(limited_hnp1[i], VEL_FIX_POWER) /\n                              (std::pow(limited_hnp1[i], VEL_FIX_POWER) +\n                               std::pow(aux, VEL_FIX_POWER));\n          limited_hvnp1[i] *= 2 * std::pow(limited_hnp1[i], VEL_FIX_POWER) /\n                              (std::pow(limited_hnp1[i], VEL_FIX_POWER) +\n                               std::pow(aux, VEL_FIX_POWER));\n          limited_hetanp1[i] *= 2 * std::pow(limited_hnp1[i], VEL_FIX_POWER) /\n                                (std::pow(limited_hnp1[i], VEL_FIX_POWER) +\n                                 std::pow(aux, VEL_FIX_POWER));\n          limited_hwnp1[i] *= 2 * std::pow(limited_hnp1[i], VEL_FIX_POWER) /\n                              (std::pow(limited_hnp1[i], VEL_FIX_POWER) +\n                               std::pow(aux, VEL_FIX_POWER));\n        }\n      }\n\n      // update FCT matrices as Fct = (1 - Lij)*Fct\n      FCT_h = (1.0 - Lij_array) * FCT_h;\n      FCT_hu = (1.0 - Lij_array) * FCT_hu;\n      FCT_hv = (1.0 - Lij_array) * FCT_hv;\n      FCT_heta = (1.0 - Lij_array) * FCT_heta;\n      FCT_hw = (1.0 - Lij_array) * FCT_hw;\n    } // end loop for limiting iteration\n  }   // end convex limiting function\n\n  double calculateEdgeBasedCFL(arguments_dict &args) {\n    double g = args.m_dscalar[\"g\"];\n    int numDOFsPerEqn = args.m_iscalar[\"numDOFsPerEqn\"];\n    xt::pyarray<double> &lumped_mass_matrix =\n        args.m_darray[\"lumped_mass_matrix\"];\n    xt::pyarray<double> &h_dof_old = args.m_darray[\"h_dof_old\"];\n    xt::pyarray<double> &hu_dof_old = args.m_darray[\"hu_dof_old\"];\n    xt::pyarray<double> &hv_dof_old = args.m_darray[\"hv_dof_old\"];\n    xt::pyarray<double> &heta_dof_old = args.m_darray[\"heta_dof_old\"];\n    xt::pyarray<double> &b_dof = args.m_darray[\"b_dof\"];\n    xt::pyarray<int> &csrRowIndeces_DofLoops =\n        args.m_iarray[\"csrRowIndeces_DofLoops\"];\n    xt::pyarray<int> &csrColumnOffsets_DofLoops =\n        args.m_iarray[\"csrColumnOffsets_DofLoops\"];\n    double hEps = args.m_dscalar[\"hEps\"];\n    xt::pyarray<double> &hReg = args.m_darray[\"hReg\"];\n    xt::pyarray<double> &Cx = args.m_darray[\"Cx\"];\n    xt::pyarray<double> &Cy = args.m_darray[\"Cy\"];\n    xt::pyarray<double> &CTx = args.m_darray[\"CTx\"];\n    xt::pyarray<double> &CTy = args.m_darray[\"CTy\"];\n    xt::pyarray<double> &dLow = args.m_darray[\"dLow\"];\n    double run_cfl = args.m_dscalar[\"run_cfl\"];\n    xt::pyarray<double> &edge_based_cfl = args.m_darray[\"edge_based_cfl\"];\n    int debug = args.m_iscalar[\"debug\"];\n    /* note that for the CFL condition, we use only the values of dij and\n     * don't do the dij = Max(dij,muij) thing */\n\n    std::valarray<double> psi(numDOFsPerEqn);\n    double max_edge_based_cfl = 0.;\n    int ij = 0;\n    for (int i = 0; i < numDOFsPerEqn; i++) {\n      // solution at time tn for the ith DOF\n      double hi = h_dof_old[i];\n      double hui = hu_dof_old[i];\n      double hvi = hv_dof_old[i];\n      double hetai = heta_dof_old[i];\n      double mi = lumped_mass_matrix[i];\n      double dLowii = 0.;\n\n      for (int offset = csrRowIndeces_DofLoops[i];\n           offset < csrRowIndeces_DofLoops[i + 1]; offset++) {\n        // loop in j (sparsity pattern)\n        // solution at time tn for the jth DOF\n        int j = csrColumnOffsets_DofLoops[offset];\n        double hj = h_dof_old[j];\n        double huj = hu_dof_old[j];\n        double hvj = hv_dof_old[j];\n        double hetaj = heta_dof_old[j];\n        double mj = lumped_mass_matrix[j];\n\n        if (i != j) {\n          ////////////////////////\n          // DISSIPATIVE MATRIX //\n          ////////////////////////\n          double cij_norm = sqrt(Cx[ij] * Cx[ij] + Cy[ij] * Cy[ij]);\n          double cji_norm = sqrt(CTx[ij] * CTx[ij] + CTy[ij] * CTy[ij]);\n          double nxij = Cx[ij] / cij_norm, nyij = Cy[ij] / cij_norm;\n          double nxji = CTx[ij] / cji_norm, nyji = CTy[ij] / cji_norm;\n\n          dLow[ij] =\n              fmax(maxWaveSpeedSharpInitialGuess(g, nxij, nyij, hi, hui, hvi,\n                                                 hetai, mi, hj, huj, hvj, hetaj,\n                                                 mj, hEps, hEps, debug) *\n                       cij_norm, // hEps\n                   maxWaveSpeedSharpInitialGuess(g, nxji, nyji, hj, huj, hvj,\n                                                 hetaj, mj, hi, hui, hvi, hetai,\n                                                 mi, hEps, hEps, debug) *\n                       cji_norm); // hEps\n          dLowii -= dLow[ij];\n\n        } else\n          dLow[ij] = 0.;\n        // update ij\n        ij += 1;\n      }\n      //////////////////////////////\n      // CALCULATE EDGE BASED CFL //\n      //////////////////////////////\n      edge_based_cfl[i] = 1.0 * fabs(dLowii) / mi;\n      max_edge_based_cfl = fmax(max_edge_based_cfl, edge_based_cfl[i]);\n    }\n    return max_edge_based_cfl;\n  } // End calculateEdgeBasedCFL\n\n  void calculateResidual(arguments_dict &args) {\n    xt::pyarray<double> &mesh_trial_ref = args.m_darray[\"mesh_trial_ref\"];\n    xt::pyarray<double> &mesh_grad_trial_ref =\n        args.m_darray[\"mesh_grad_trial_ref\"];\n    xt::pyarray<double> &mesh_dof = args.m_darray[\"mesh_dof\"];\n    xt::pyarray<double> &mesh_velocity_dof = args.m_darray[\"mesh_velocity_dof\"];\n    double MOVING_DOMAIN = args.m_dscalar[\"MOVING_DOMAIN\"];\n    xt::pyarray<int> &mesh_l2g = args.m_iarray[\"mesh_l2g\"];\n    xt::pyarray<double> &dV_ref = args.m_darray[\"dV_ref\"];\n    xt::pyarray<double> &h_trial_ref = args.m_darray[\"h_trial_ref\"];\n    xt::pyarray<double> &h_grad_trial_ref = args.m_darray[\"h_grad_trial_ref\"];\n    xt::pyarray<double> &h_test_ref = args.m_darray[\"h_test_ref\"];\n    xt::pyarray<double> &h_grad_test_ref = args.m_darray[\"h_grad_test_ref\"];\n    xt::pyarray<double> &vel_trial_ref = args.m_darray[\"vel_trial_ref\"];\n    xt::pyarray<double> &vel_grad_trial_ref =\n        args.m_darray[\"vel_grad_trial_ref\"];\n    xt::pyarray<double> &vel_test_ref = args.m_darray[\"vel_test_ref\"];\n    xt::pyarray<double> &vel_grad_test_ref = args.m_darray[\"vel_grad_test_ref\"];\n    xt::pyarray<double> &mesh_trial_trace_ref =\n        args.m_darray[\"mesh_trial_trace_ref\"];\n    xt::pyarray<double> &mesh_grad_trial_trace_ref =\n        args.m_darray[\"mesh_grad_trial_trace_ref\"];\n    xt::pyarray<double> &dS_ref = args.m_darray[\"dS_ref\"];\n    xt::pyarray<double> &h_trial_trace_ref = args.m_darray[\"h_trial_trace_ref\"];\n    xt::pyarray<double> &h_grad_trial_trace_ref =\n        args.m_darray[\"h_grad_trial_trace_ref\"];\n    xt::pyarray<double> &h_test_trace_ref = args.m_darray[\"h_test_trace_ref\"];\n    xt::pyarray<double> &h_grad_test_trace_ref =\n        args.m_darray[\"h_grad_test_trace_ref\"];\n    xt::pyarray<double> &vel_trial_trace_ref =\n        args.m_darray[\"vel_trial_trace_ref\"];\n    xt::pyarray<double> &vel_grad_trial_trace_ref =\n        args.m_darray[\"vel_grad_trial_trace_ref\"];\n    xt::pyarray<double> &vel_test_trace_ref =\n        args.m_darray[\"vel_test_trace_ref\"];\n    xt::pyarray<double> &vel_grad_test_trace_ref =\n        args.m_darray[\"vel_grad_test_trace_ref\"];\n    xt::pyarray<double> &normal_ref = args.m_darray[\"normal_ref\"];\n    xt::pyarray<double> &boundaryJac_ref = args.m_darray[\"boundaryJac_ref\"];\n    xt::pyarray<double> &elementDiameter = args.m_darray[\"elementDiameter\"];\n    int nElements_global = args.m_iscalar[\"nElements_global\"];\n    double useRBLES = args.m_dscalar[\"useRBLES\"];\n    double useMetrics = args.m_dscalar[\"useMetrics\"];\n    double alphaBDF = args.m_dscalar[\"alphaBDF\"];\n    double nu = args.m_dscalar[\"nu\"];\n    double g = args.m_dscalar[\"g\"];\n    xt::pyarray<int> &h_l2g = args.m_iarray[\"h_l2g\"];\n    xt::pyarray<int> &vel_l2g = args.m_iarray[\"vel_l2g\"];\n    xt::pyarray<double> &h_dof_old = args.m_darray[\"h_dof_old\"];\n    xt::pyarray<double> &hu_dof_old = args.m_darray[\"hu_dof_old\"];\n    xt::pyarray<double> &hv_dof_old = args.m_darray[\"hv_dof_old\"];\n    xt::pyarray<double> &heta_dof_old = args.m_darray[\"heta_dof_old\"];\n    xt::pyarray<double> &hw_dof_old = args.m_darray[\"hw_dof_old\"];\n    xt::pyarray<double> &b_dof = args.m_darray[\"b_dof\"];\n    xt::pyarray<double> &h_dof = args.m_darray[\"h_dof\"];\n    xt::pyarray<double> &hu_dof = args.m_darray[\"hu_dof\"];\n    xt::pyarray<double> &hv_dof = args.m_darray[\"hv_dof\"];\n    xt::pyarray<double> &heta_dof = args.m_darray[\"heta_dof\"];\n    xt::pyarray<double> &hw_dof = args.m_darray[\"hw_dof\"];\n    xt::pyarray<double> &h_dof_sge = args.m_darray[\"h_dof_sge\"];\n    xt::pyarray<double> &hu_dof_sge = args.m_darray[\"hu_dof_sge\"];\n    xt::pyarray<double> &hv_dof_sge = args.m_darray[\"hv_dof_sge\"];\n    xt::pyarray<double> &heta_dof_sge = args.m_darray[\"heta_dof_sge\"];\n    xt::pyarray<double> &hw_dof_sge = args.m_darray[\"hw_dof_sge\"];\n    xt::pyarray<double> &q_mass_acc = args.m_darray[\"q_mass_acc\"];\n    xt::pyarray<double> &q_mom_hu_acc = args.m_darray[\"q_mom_hu_acc\"];\n    xt::pyarray<double> &q_mom_hv_acc = args.m_darray[\"q_mom_hv_acc\"];\n    xt::pyarray<double> &q_mass_adv = args.m_darray[\"q_mass_adv\"];\n    xt::pyarray<double> &q_mass_acc_beta_bdf =\n        args.m_darray[\"q_mass_acc_beta_bdf\"];\n    xt::pyarray<double> &q_mom_hu_acc_beta_bdf =\n        args.m_darray[\"q_mom_hu_acc_beta_bdf\"];\n    xt::pyarray<double> &q_mom_hv_acc_beta_bdf =\n        args.m_darray[\"q_mom_hv_acc_beta_bdf\"];\n    xt::pyarray<double> &q_cfl = args.m_darray[\"q_cfl\"];\n    xt::pyarray<int> &sdInfo_hu_hu_rowptr =\n        args.m_iarray[\"sdInfo_hu_hu_rowptr\"];\n    xt::pyarray<int> &sdInfo_hu_hu_colind =\n        args.m_iarray[\"sdInfo_hu_hu_colind\"];\n    xt::pyarray<int> &sdInfo_hu_hv_rowptr =\n        args.m_iarray[\"sdInfo_hu_hv_rowptr\"];\n    xt::pyarray<int> &sdInfo_hu_hv_colind =\n        args.m_iarray[\"sdInfo_hu_hv_colind\"];\n    xt::pyarray<int> &sdInfo_hv_hv_rowptr =\n        args.m_iarray[\"sdInfo_hv_hv_rowptr\"];\n    xt::pyarray<int> &sdInfo_hv_hv_colind =\n        args.m_iarray[\"sdInfo_hv_hv_colind\"];\n    xt::pyarray<int> &sdInfo_hv_hu_rowptr =\n        args.m_iarray[\"sdInfo_hv_hu_rowptr\"];\n    xt::pyarray<int> &sdInfo_hv_hu_colind =\n        args.m_iarray[\"sdInfo_hv_hu_colind\"];\n    int offset_h = args.m_iscalar[\"offset_h\"];\n    int offset_hu = args.m_iscalar[\"offset_hu\"];\n    int offset_hv = args.m_iscalar[\"offset_hv\"];\n    int offset_heta = args.m_iscalar[\"offset_heta\"];\n    int offset_hw = args.m_iscalar[\"offset_hw\"];\n    int stride_h = args.m_iscalar[\"stride_h\"];\n    int stride_hu = args.m_iscalar[\"stride_hu\"];\n    int stride_hv = args.m_iscalar[\"stride_hv\"];\n    int stride_heta = args.m_iscalar[\"stride_heta\"];\n    int stride_hw = args.m_iscalar[\"stride_hw\"];\n    xt::pyarray<double> &globalResidual = args.m_darray[\"globalResidual\"];\n    int nExteriorElementBoundaries_global =\n        args.m_iscalar[\"nExteriorElementBoundaries_global\"];\n    xt::pyarray<int> &exteriorElementBoundariesArray =\n        args.m_iarray[\"exteriorElementBoundariesArray\"];\n    xt::pyarray<int> &elementBoundaryElementsArray =\n        args.m_iarray[\"elementBoundaryElementsArray\"];\n    xt::pyarray<int> &elementBoundaryLocalElementBoundariesArray =\n        args.m_iarray[\"elementBoundaryLocalElementBoundariesArray\"];\n    xt::pyarray<int> &isDOFBoundary_h = args.m_iarray[\"isDOFBoundary_h\"];\n    xt::pyarray<int> &isDOFBoundary_hu = args.m_iarray[\"isDOFBoundary_hu\"];\n    xt::pyarray<int> &isDOFBoundary_hv = args.m_iarray[\"isDOFBoundary_hv\"];\n    xt::pyarray<int> &isAdvectiveFluxBoundary_h =\n        args.m_iarray[\"isAdvectiveFluxBoundary_h\"];\n    xt::pyarray<int> &isAdvectiveFluxBoundary_hu =\n        args.m_iarray[\"isAdvectiveFluxBoundary_hu\"];\n    xt::pyarray<int> &isAdvectiveFluxBoundary_hv =\n        args.m_iarray[\"isAdvectiveFluxBoundary_hv\"];\n    xt::pyarray<int> &isDiffusiveFluxBoundary_hu =\n        args.m_iarray[\"isDiffusiveFluxBoundary_hu\"];\n    xt::pyarray<int> &isDiffusiveFluxBoundary_hv =\n        args.m_iarray[\"isDiffusiveFluxBoundary_hv\"];\n    xt::pyarray<double> &ebqe_bc_h_ext = args.m_darray[\"ebqe_bc_h_ext\"];\n    xt::pyarray<double> &ebqe_bc_flux_mass_ext =\n        args.m_darray[\"ebqe_bc_flux_mass_ext\"];\n    xt::pyarray<double> &ebqe_bc_flux_mom_hu_adv_ext =\n        args.m_darray[\"ebqe_bc_flux_mom_hu_adv_ext\"];\n    xt::pyarray<double> &ebqe_bc_flux_mom_hv_adv_ext =\n        args.m_darray[\"ebqe_bc_flux_mom_hv_adv_ext\"];\n    xt::pyarray<double> &ebqe_bc_hu_ext = args.m_darray[\"ebqe_bc_hu_ext\"];\n    xt::pyarray<double> &ebqe_bc_flux_hu_diff_ext =\n        args.m_darray[\"ebqe_bc_flux_hu_diff_ext\"];\n    xt::pyarray<double> &ebqe_penalty_ext = args.m_darray[\"ebqe_penalty_ext\"];\n    xt::pyarray<double> &ebqe_bc_hv_ext = args.m_darray[\"ebqe_bc_hv_ext\"];\n    xt::pyarray<double> &ebqe_bc_flux_hv_diff_ext =\n        args.m_darray[\"ebqe_bc_flux_hv_diff_ext\"];\n    xt::pyarray<double> &q_velocity = args.m_darray[\"q_velocity\"];\n    xt::pyarray<double> &ebqe_velocity = args.m_darray[\"ebqe_velocity\"];\n    xt::pyarray<double> &flux = args.m_darray[\"flux\"];\n    xt::pyarray<double> &elementResidual_h_save =\n        args.m_darray[\"elementResidual_h_save\"];\n    xt::pyarray<double> &Cx = args.m_darray[\"Cx\"];\n    xt::pyarray<double> &Cy = args.m_darray[\"Cy\"];\n    xt::pyarray<double> &CTx = args.m_darray[\"CTx\"];\n    xt::pyarray<double> &CTy = args.m_darray[\"CTy\"];\n    int numDOFsPerEqn = args.m_iscalar[\"numDOFsPerEqn\"];\n    int NNZ = args.m_iscalar[\"NNZ\"];\n    xt::pyarray<int> &csrRowIndeces_DofLoops =\n        args.m_iarray[\"csrRowIndeces_DofLoops\"];\n    xt::pyarray<int> &csrColumnOffsets_DofLoops =\n        args.m_iarray[\"csrColumnOffsets_DofLoops\"];\n    xt::pyarray<double> &lumped_mass_matrix =\n        args.m_darray[\"lumped_mass_matrix\"];\n    double cfl_run = args.m_dscalar[\"cfl_run\"];\n    double hEps = args.m_dscalar[\"hEps\"];\n    xt::pyarray<double> &hReg = args.m_darray[\"hReg\"];\n    xt::pyarray<double> &hnp1_at_quad_point =\n        args.m_darray[\"hnp1_at_quad_point\"];\n    xt::pyarray<double> &hunp1_at_quad_point =\n        args.m_darray[\"hunp1_at_quad_point\"];\n    xt::pyarray<double> &hvnp1_at_quad_point =\n        args.m_darray[\"hvnp1_at_quad_point\"];\n    xt::pyarray<double> &hetanp1_at_quad_point =\n        args.m_darray[\"hetanp1_at_quad_point\"];\n    xt::pyarray<double> &hwnp1_at_quad_point =\n        args.m_darray[\"hwnp1_at_quad_point\"];\n    xt::pyarray<double> &extendedSourceTerm_hu =\n        args.m_darray[\"extendedSourceTerm_hu\"];\n    xt::pyarray<double> &extendedSourceTerm_hv =\n        args.m_darray[\"extendedSourceTerm_hv\"];\n    xt::pyarray<double> &extendedSourceTerm_heta =\n        args.m_darray[\"extendedSourceTerm_heta\"];\n    xt::pyarray<double> &extendedSourceTerm_hw =\n        args.m_darray[\"extendedSourceTerm_hw\"];\n    xt::pyarray<double> &dH_minus_dL = args.m_darray[\"dH_minus_dL\"];\n    xt::pyarray<double> &muH_minus_muL = args.m_darray[\"muH_minus_muL\"];\n    double cE = args.m_dscalar[\"cE\"];\n    int LUMPED_MASS_MATRIX = args.m_iscalar[\"LUMPED_MASS_MATRIX\"];\n    double dt = args.m_dscalar[\"dt\"];\n    int LINEAR_FRICTION = args.m_iscalar[\"LINEAR_FRICTION\"];\n    double mannings = args.m_dscalar[\"mannings\"];\n    xt::pyarray<double> &quantDOFs = args.m_darray[\"quantDOFs\"];\n    int SECOND_CALL_CALCULATE_RESIDUAL =\n        args.m_iscalar[\"SECOND_CALL_CALCULATE_RESIDUAL\"];\n    int COMPUTE_NORMALS = args.m_iscalar[\"COMPUTE_NORMALS\"];\n    xt::pyarray<double> &normalx = args.m_darray[\"normalx\"];\n    xt::pyarray<double> &normaly = args.m_darray[\"normaly\"];\n    xt::pyarray<double> &dLow = args.m_darray[\"dLow\"];\n    xt::pyarray<double> &hBT = args.m_darray[\"hBT\"];\n    xt::pyarray<double> &huBT = args.m_darray[\"huBT\"];\n    xt::pyarray<double> &hvBT = args.m_darray[\"hvBT\"];\n    xt::pyarray<double> &hetaBT = args.m_darray[\"hetaBT\"];\n    xt::pyarray<double> &hwBT = args.m_darray[\"hwBT\"];\n    int lstage = args.m_iscalar[\"lstage\"];\n    xt::pyarray<double> &new_SourceTerm_hu = args.m_darray[\"new_SourceTerm_hu\"];\n    xt::pyarray<double> &new_SourceTerm_hv = args.m_darray[\"new_SourceTerm_hv\"];\n    xt::pyarray<double> &new_SourceTerm_heta =\n        args.m_darray[\"new_SourceTerm_heta\"];\n    xt::pyarray<double> &new_SourceTerm_hw = args.m_darray[\"new_SourceTerm_hw\"];\n    // FOR FRICTION//\n    double n2 = std::pow(mannings, 2.);\n    double gamma = 4. / 3;\n    double xi = 10.;\n\n    //////////////////////////////////////\n    // ********** CELL LOOPS ********** //\n    //////////////////////////////////////\n    // To compute:\n    //      * Time derivative term\n    //      * Cell based CFL\n    //      * Velocity and soln at quad points (for other models)\n    for (int eN = 0; eN < nElements_global; eN++) {\n      // declare local storage for element residual and initialize\n      register double elementResidual_h[nDOF_test_element],\n          elementResidual_hu[nDOF_test_element],\n          elementResidual_hv[nDOF_test_element],\n          elementResidual_heta[nDOF_test_element],\n          elementResidual_hw[nDOF_test_element];\n\n      for (int i = 0; i < nDOF_test_element; i++) {\n        elementResidual_h[i] = 0.0;\n        elementResidual_hu[i] = 0.0;\n        elementResidual_hv[i] = 0.0;\n        elementResidual_heta[i] = 0.0;\n        elementResidual_hw[i] = 0.0;\n      }\n      //\n      // loop over quadrature points and compute integrands\n      //\n      for (int k = 0; k < nQuadraturePoints_element; k++) {\n        // compute indices and declare local storage\n        register int eN_k = eN * nQuadraturePoints_element + k,\n                     eN_k_nSpace = eN_k * nSpace,\n                     eN_nDOF_trial_element = eN * nDOF_trial_element;\n        register double h = 0.0, hu = 0.0, hv = 0.0, heta = 0.0,\n                        hw = 0.0, // solution at current time\n            h_old = 0.0, hu_old = 0.0, hv_old = 0.0, heta_old = 0.0,\n                        hw_old = 0.0, // solution at lstage\n            jac[nSpace * nSpace], jacDet, jacInv[nSpace * nSpace],\n                        h_test_dV[nDOF_trial_element], dV, x, y, xt, yt;\n        // get jacobian, etc for mapping reference element\n        ck.calculateMapping_element(\n            eN, k, mesh_dof.data(), mesh_l2g.data(), mesh_trial_ref.data(),\n            mesh_grad_trial_ref.data(), jac, jacDet, jacInv, x, y);\n        // get the physical integration weight\n        dV = fabs(jacDet) * dV_ref[k];\n        // get the solution at current time\n        ck.valFromDOF(h_dof.data(), &h_l2g[eN_nDOF_trial_element],\n                      &h_trial_ref[k * nDOF_trial_element], h);\n        ck.valFromDOF(hu_dof.data(), &vel_l2g[eN_nDOF_trial_element],\n                      &vel_trial_ref[k * nDOF_trial_element], hu);\n        ck.valFromDOF(hv_dof.data(), &vel_l2g[eN_nDOF_trial_element],\n                      &vel_trial_ref[k * nDOF_trial_element], hv);\n        ck.valFromDOF(heta_dof.data(), &vel_l2g[eN_nDOF_trial_element],\n                      &vel_trial_ref[k * nDOF_trial_element], heta);\n        ck.valFromDOF(hw_dof.data(), &vel_l2g[eN_nDOF_trial_element],\n                      &vel_trial_ref[k * nDOF_trial_element], hw);\n        // get the solution at the lstage\n        ck.valFromDOF(h_dof_old.data(), &h_l2g[eN_nDOF_trial_element],\n                      &h_trial_ref[k * nDOF_trial_element], h_old);\n        ck.valFromDOF(hu_dof_old.data(), &vel_l2g[eN_nDOF_trial_element],\n                      &vel_trial_ref[k * nDOF_trial_element], hu_old);\n        ck.valFromDOF(hv_dof_old.data(), &vel_l2g[eN_nDOF_trial_element],\n                      &vel_trial_ref[k * nDOF_trial_element], hv_old);\n        ck.valFromDOF(heta_dof_old.data(), &vel_l2g[eN_nDOF_trial_element],\n                      &vel_trial_ref[k * nDOF_trial_element], heta_old);\n        ck.valFromDOF(hw_dof_old.data(), &vel_l2g[eN_nDOF_trial_element],\n                      &vel_trial_ref[k * nDOF_trial_element], hw_old);\n        // calculate cell based CFL to keep a reference\n        calculateCFL(elementDiameter[eN], g, h_old, hu_old, hv_old, hEps,\n                     q_cfl[eN_k]);\n        // precalculate test function products with integration weights\n        for (int j = 0; j < nDOF_trial_element; j++)\n          h_test_dV[j] = h_test_ref[k * nDOF_trial_element + j] * dV;\n\n        // SAVE VELOCITY // at quadrature points for other models to use\n        q_velocity[eN_k_nSpace + 0] =\n            2 * h / (h * h + std::pow(fmax(h, hEps), 2)) * hu;\n        q_velocity[eN_k_nSpace + 1] =\n            2 * h / (h * h + std::pow(fmax(h, hEps), 2)) * hv;\n        hnp1_at_quad_point[eN_k] = h;\n        hunp1_at_quad_point[eN_k] = hu;\n        hvnp1_at_quad_point[eN_k] = hv;\n        hetanp1_at_quad_point[eN_k] = heta;\n        hwnp1_at_quad_point[eN_k] = hw;\n\n        for (int i = 0; i < nDOF_test_element; i++) {\n          // compute time derivative part of global residual. NOTE: no lumping\n          elementResidual_h[i] += (h - h_old) * h_test_dV[i];\n          elementResidual_hu[i] += (hu - hu_old) * h_test_dV[i];\n          elementResidual_hv[i] += (hv - hv_old) * h_test_dV[i];\n          elementResidual_heta[i] += (heta - heta_old) * h_test_dV[i];\n          elementResidual_hw[i] += (hw - hw_old) * h_test_dV[i];\n        }\n      }\n      // distribute\n      for (int i = 0; i < nDOF_test_element; i++) {\n        register int eN_i = eN * nDOF_test_element + i;\n        int h_gi = h_l2g[eN_i];     // global i-th index for h\n        int vel_gi = vel_l2g[eN_i]; // global i-th index for velocities\n\n        // distribute time derivative to global residual\n        globalResidual[offset_h + stride_h * h_gi] += elementResidual_h[i];\n        globalResidual[offset_hu + stride_hu * vel_gi] += elementResidual_hu[i];\n        globalResidual[offset_hv + stride_hv * vel_gi] += elementResidual_hv[i];\n        globalResidual[offset_heta + stride_heta * vel_gi] +=\n            elementResidual_heta[i];\n        globalResidual[offset_hw + stride_hw * vel_gi] += elementResidual_hw[i];\n      }\n    }\n    // ********** END OF CELL LOOPS ********** //\n\n    if (SECOND_CALL_CALCULATE_RESIDUAL == 0) // This is to save some time\n    {\n      //////////////////////////////////////////////\n      // ********** FIRST LOOP ON DOFs ********** //\n      //////////////////////////////////////////////\n\n      // To compute:\n      //     * Entropy at i-th node\n      std::valarray<double> eta(numDOFsPerEqn);\n      for (int i = 0; i < numDOFsPerEqn; i++) {\n        // COMPUTE ENTROPY. NOTE: WE CONSIDER A FLAT BOTTOM\n        double hi = h_dof_old[i];\n        double one_over_hiReg =\n            2 * hi / (hi * hi + std::pow(fmax(hi, hEps), 2)); // hEps\n        eta[i] =\n            ENTROPY(g, hi, hu_dof_old[i], hv_dof_old[i], 0., one_over_hiReg);\n      }\n\n      // ********** END OF FIRST LOOP ON DOFs ********** //\n\n      ///////////////////////////////////////////////\n      // ********** SECOND LOOP ON DOFs ********** //\n      ///////////////////////////////////////////////\n      // To compute:\n      //     * Hyperbolic part of the flux\n      //     * Extended source term (eqn 6.19)\n      //     * Smoothness indicator\n      //     * global entropy residual\n      //     * dij_small to avoid division by 0\n\n      int ij = 0;\n      std::valarray<double> hyp_flux_h(numDOFsPerEqn),\n          hyp_flux_hu(numDOFsPerEqn), hyp_flux_hv(numDOFsPerEqn),\n          hyp_flux_heta(numDOFsPerEqn), hyp_flux_hw(numDOFsPerEqn),\n          global_entropy_residual(numDOFsPerEqn), psi(numDOFsPerEqn),\n          etaMax(numDOFsPerEqn), etaMin(numDOFsPerEqn);\n\n      // For dij_small\n      double dij_small = 0.0;\n      // speed = sqrt(g max(h_0)), I divide by h_epsilon to get max(h_0) -EJT\n      double speed = std::sqrt(g * hEps / 1E-5);\n\n      for (int i = 0; i < numDOFsPerEqn; i++) {\n\n        // solution at time tn for the ith DOF\n        double hi = h_dof_old[i];\n        double hui = hu_dof_old[i];\n        double hvi = hv_dof_old[i];\n        double hetai = heta_dof_old[i];\n        double hwi = hw_dof_old[i];\n        double Zi = b_dof[i];\n        // Define some things using above\n        double one_over_hiReg =\n            2 * hi / (hi * hi + std::pow(fmax(hi, hEps), 2)); // hEps\n        double ui = hui * one_over_hiReg;\n        double vi = hvi * one_over_hiReg;\n        double etai = hetai * one_over_hiReg;\n        double mi = lumped_mass_matrix[i];\n        double meshSizei = std::sqrt(mi);\n\n        // For eta min and max\n        etaMax[i] = fabs(eta[i]);\n        etaMin[i] = fabs(eta[i]);\n\n        /* COMPUTE EXTENDED SOURCE TERMS:\n         * Friction terms\n         * Potentially other sources as well\n         * Source for heta equation\n         * Source for hw equation\n         * NOTE: Be careful with sign of source terms.\n         */\n\n        // FRICTION\n        if (LINEAR_FRICTION == 1) {\n          extendedSourceTerm_hu[i] = mannings * hui * mi;\n          extendedSourceTerm_hv[i] = mannings * hvi * mi;\n          // For use in the convex limiting function -EJT\n          // actually didn't need to do this but it helps with signs\n          new_SourceTerm_hu[i] = -mannings * hui * mi;\n          new_SourceTerm_hv[i] = -mannings * hvi * mi;\n        } else {\n          double veli_norm = std::sqrt(ui * ui + vi * vi);\n          double hi_to_the_gamma = std::pow(fmax(hi, hEps), gamma);\n          double friction_aux =\n              veli_norm == 0.\n                  ? 0.\n                  : (2 * g * n2 * veli_norm * mi /\n                     (hi_to_the_gamma +\n                      fmax(hi_to_the_gamma, xi * g * n2 * dt * veli_norm)));\n          extendedSourceTerm_hu[i] = friction_aux * hui;\n          extendedSourceTerm_hv[i] = friction_aux * hvi;\n          // For use in the convex limiting function -EJT\n          new_SourceTerm_hu[i] = -friction_aux * hui;\n          new_SourceTerm_hv[i] = -friction_aux * hvi;\n        }\n\n        // Define some things for heta and hw sources\n        double ratio_i = (2.0 * hetai) / (etai * etai + hi * hi + hEps);\n        double diff_over_h_i = (hetai - hi * hi) * one_over_hiReg;\n        double hSqd_GammaPi = 6.0 * (hetai - hi * hi);\n        if (IF_BOTH_GAMMA_BRANCHES) {\n          if (hetai > std::pow(hi, 2.0)) {\n            hSqd_GammaPi = 6.0 * etai * diff_over_h_i;\n          }\n        }\n\n        // heta source\n        extendedSourceTerm_heta[i] = -hwi * mi * ratio_i;\n        new_SourceTerm_heta[i] = hwi * mi * ratio_i;\n\n        // hw source\n        extendedSourceTerm_hw[i] =\n            (LAMBDA_MGN * g / meshSizei) * hSqd_GammaPi * mi * ratio_i;\n        new_SourceTerm_hw[i] =\n            -(LAMBDA_MGN * g / meshSizei) * hSqd_GammaPi * mi * ratio_i;\n\n        /* HYPERBOLIC FLUXES */\n        hyp_flux_h[i] = 0;\n        hyp_flux_hu[i] = 0;\n        hyp_flux_hv[i] = 0;\n        hyp_flux_heta[i] = 0;\n        hyp_flux_hw[i] = 0;\n\n        // FOR ENTROPY RESIDUAL //\n        double ith_flux_term1 = 0., ith_flux_term2 = 0., ith_flux_term3 = 0.;\n        double ith_flux_term4 = 0., ith_flux_term5 = 0.;\n        double entropy_flux = 0.;\n        double sum_entprime_flux = 0.;\n        // NOTE: FLAT BOTTOM\n        double eta_prime1 = DENTROPY_DH(g, hi, hui, hvi, 0., one_over_hiReg);\n        double eta_prime2 = DENTROPY_DHU(g, hi, hui, hvi, 0., one_over_hiReg);\n        double eta_prime3 = DENTROPY_DHV(g, hi, hui, hvi, 0., one_over_hiReg);\n\n        // FOR SMOOTHNESS INDICATOR //\n        double alphai; // smoothness indicator of solution\n        double alpha_numerator = 0;\n        double alpha_denominator = 0;\n        double alpha_zero = 0.75; // if only want smoothness\n        double alpha_factor = 1.0 / (1.0 - alpha_zero);\n\n        // loop in j (sparsity pattern)\n        for (int offset = csrRowIndeces_DofLoops[i];\n             offset < csrRowIndeces_DofLoops[i + 1]; offset++) {\n\n          int j = csrColumnOffsets_DofLoops[offset];\n\n          // solution at time tn for the jth DOF\n          double hj = h_dof_old[j];\n          double huj = hu_dof_old[j];\n          double hvj = hv_dof_old[j];\n          double hetaj = heta_dof_old[j];\n          double hwj = hw_dof_old[j];\n          double Zj = b_dof[j];\n\n          // Then define some things here using above\n          double one_over_hjReg =\n              2.0 * hj / (hj * hj + std::pow(fmax(hj, hEps), 2));\n          double uj = huj * one_over_hjReg;\n          double vj = hvj * one_over_hjReg;\n          double etaj = hetaj * one_over_hjReg;\n          double meshSizej =\n              std::sqrt(lumped_mass_matrix[j]); // local mesh size in 2d\n\n          // pTilde at jth node gets defined here\n          double diff_over_h_j = (hetaj - hj * hj) * one_over_hjReg;\n          double pTildej = -(LAMBDA_MGN * g / (3.0 * meshSizej)) * 6.0 * hj *\n                           (hetaj - hj * hj);\n\n          if (IF_BOTH_GAMMA_BRANCHES) {\n            if (hetaj > std::pow(hj, 2.0)) {\n              pTildej = -(LAMBDA_MGN * g / (3.0 * meshSizej)) * 2.0 *\n                        diff_over_h_j * (etaj * etaj + etaj * hj + hj * hj);\n            }\n          }\n\n          // auxiliary functions to compute fluxes\n          double aux_h =\n              (uj * hj - ui * hi) * Cx[ij] + (vj * hj - vi * hi) * Cy[ij];\n          double aux_hu =\n              (uj * huj - ui * hui) * Cx[ij] + (vj * huj - vi * hui) * Cy[ij];\n          double aux_hv =\n              (uj * hvj - ui * hvi) * Cx[ij] + (vj * hvj - vi * hvi) * Cy[ij];\n          double aux_heta = (uj * hetaj - ui * hetai) * Cx[ij] +\n                            (vj * hetaj - vi * hetai) * Cy[ij];\n          double aux_hw =\n              (uj * hwj - ui * hwi) * Cx[ij] + (vj * hwj - vi * hwi) * Cy[ij];\n\n          /* HYPERBOLIC FLUX */\n          hyp_flux_h[i] += aux_h;\n          hyp_flux_hu[i] += aux_hu + pTildej * Cx[ij];\n          hyp_flux_hv[i] += aux_hv + pTildej * Cy[ij];\n          hyp_flux_heta[i] += aux_heta;\n          hyp_flux_hw[i] += aux_hw;\n\n          // EXTENDED SOURCE, USING 6.13 //\n          extendedSourceTerm_hu[i] += g * hi * (hj + Zj) * Cx[ij];\n          extendedSourceTerm_hv[i] += g * hi * (hj + Zj) * Cy[ij];\n\n          new_SourceTerm_hu[i] +=\n              g * (-hi * (Zj - Zi) + 0.5 * std::pow(hj - hi, 2)) * Cx[ij];\n          new_SourceTerm_hv[i] +=\n              g * (-hi * (Zj - Zi) + 0.5 * std::pow(hj - hi, 2)) * Cy[ij];\n\n          // flux for entropy\n          ith_flux_term1 += aux_h;\n          ith_flux_term2 +=\n              aux_hu + 0.5 * g * hj * hj *\n                           Cx[ij]; // g * hi * (hj + 0.) * Cx[ij]; // NOTE: Zj=0\n          ith_flux_term3 +=\n              aux_hv + 0.5 * g * hj * hj *\n                           Cy[ij]; // g * hi * (hj + 0.) * Cy[ij]; // NOTE: Zj=0\n\n          // NOTE: WE CONSIDER FLAT BOTTOM\n          entropy_flux +=\n              (Cx[ij] * ENTROPY_FLUX1(g, hj, huj, hvj, 0., one_over_hjReg) +\n               Cy[ij] * ENTROPY_FLUX2(g, hj, huj, hvj, 0., one_over_hjReg));\n\n          // COMPUTE ETA MIN AND ETA MAX //\n          etaMax[i] = fmax(etaMax[i], fabs(eta[j]));\n          etaMin[i] = fmin(etaMin[i], fabs(eta[j]));\n\n          // FOR SMOOTHNESS INDICATOR //\n          alpha_numerator += hj - hi;\n          alpha_denominator += fabs(hj - hi);\n\n          // define dij_small in j loop\n          double x = fabs(Cx[ij]) + fabs(Cy[ij]);\n          dij_small = fmax(dij_small, x * speed);\n\n          // update ij\n          ij += 1;\n        } // end j loop\n\n        // Finally define it here\n        dij_small = 1E-14 * dij_small;\n\n        // Change rescaling to match TAMU code -EJT\n        // small_recale=0.5*g*eps*H_{0,max}^2\n        double small_rescale = g * hEps * hEps / 1E-5;\n        double rescale = fmax(fabs(etaMax[i] - etaMin[i]) / 2., small_rescale);\n\n        // new rescale factor = max(|ent_flux_sum| + |-ent'*flux|, 0.0)\n        sum_entprime_flux =\n            -(ith_flux_term1 * eta_prime1 + ith_flux_term2 * eta_prime2 +\n              ith_flux_term3 * eta_prime3);\n        double new_rescale =\n            fmax(fabs(entropy_flux) + fabs(sum_entprime_flux), 1E-30);\n\n        // COMPUTE ENTROPY RESIDUAL //\n        double one_over_entNormFactori = 1.0 / new_rescale;\n        global_entropy_residual[i] =\n            one_over_entNormFactori *\n            fabs(entropy_flux -\n                 (ith_flux_term1 * eta_prime1 + ith_flux_term2 * eta_prime2 +\n                  ith_flux_term3 * eta_prime3));\n\n        // COMPUTE SMOOTHNESS INDICATOR //\n        if (hi <= hEps) {\n          alphai = 1.0;\n          psi[i] = 1.0;\n          global_entropy_residual[i] = 1.0;\n        } else {\n          // Force alphai=0 in constant states\n          if (fabs(alpha_numerator) <= hEps) {\n            alphai = 0.;\n          } else {\n            alphai =\n                (fabs(alpha_numerator) - hEps) / fabs(alpha_denominator - hEps);\n          }\n          alphai = fmax(alphai - alpha_zero, 0.0) * alpha_factor;\n          if (POWER_SMOOTHNESS_INDICATOR == 0)\n            psi[i] = 1.0;\n          else\n            psi[i] = std::pow(\n                alphai, POWER_SMOOTHNESS_INDICATOR); // NOTE: alpha^4 for mGN\n        }\n      }\n      // ********** END OF 2nd LOOP ON DOFS ********** //\n\n      /////////////////////////////////////////////\n      // ********** MAIN LOOP ON DOFs **********\n      // To compute:\n      //      * dissipative terms\n      //      * bar states\n      /////////////////////////////////////////////\n\n      ij = 0;\n      for (int i = 0; i < numDOFsPerEqn; i++) {\n\n        double hi = h_dof_old[i];\n        double hui = hu_dof_old[i];\n        double hvi = hv_dof_old[i];\n        double hetai = heta_dof_old[i];\n        double hwi = hw_dof_old[i];\n        double Zi = b_dof[i];\n        double mi = lumped_mass_matrix[i];\n\n        double one_over_hiReg =\n            2.0 * hi / (hi * hi + std::pow(fmax(hi, hEps), 2));\n        double ui = hui * one_over_hiReg;\n        double vi = hvi * one_over_hiReg;\n        double etai = hetai * one_over_hiReg;\n        double meshSizei = std::sqrt(mi); // local mesh size in 2d\n\n        // We define pTilde at ith node here\n        double diff_over_h_i = (hetai - hi * hi) * one_over_hiReg;\n        double pTildei = -(LAMBDA_MGN * g / (3.0 * meshSizei)) * 6.0 * hi *\n                         (hetai - hi * hi);\n\n        if (IF_BOTH_GAMMA_BRANCHES) {\n          if (hetai > std::pow(hi, 2.0)) {\n            pTildei = -(LAMBDA_MGN * g / (3.0 * meshSizei)) * 2.0 *\n                      diff_over_h_i * (etai * etai + etai * hi + hi * hi);\n          }\n        }\n\n        // Define full pressure at ith node for definition of bar states below\n        double pressure_i = 0.5 * g * hi * hi + pTildei;\n\n        // HIGH ORDER DISSIPATIVE TERMS, for Aij matrix\n        double ith_dHij_minus_muHij_times_hStarStates = 0.,\n               ith_dHij_minus_muHij_times_huStarStates = 0.,\n               ith_dHij_minus_muHij_times_hvStarStates = 0.,\n               ith_dHij_minus_muHij_times_hetaStarStates = 0.,\n               ith_dHij_minus_muHij_times_hwStarStates = 0.,\n               ith_muHij_times_hStates = 0., ith_muHij_times_huStates = 0.,\n               ith_muHij_times_hvStates = 0., ith_muHij_times_hetaStates = 0.,\n               ith_muHij_times_hwStates = 0.;\n\n        // loop over the sparsity pattern of the i-th DOF\n        for (int offset = csrRowIndeces_DofLoops[i];\n             offset < csrRowIndeces_DofLoops[i + 1]; offset++) {\n\n          int j = csrColumnOffsets_DofLoops[offset];\n\n          double hj = h_dof_old[j];\n          double huj = hu_dof_old[j];\n          double hvj = hv_dof_old[j];\n          double hetaj = heta_dof_old[j];\n          double hwj = hw_dof_old[j];\n          double Zj = b_dof[j];\n\n          double one_over_hjReg =\n              2.0 * hj / (hj * hj + std::pow(fmax(hj, hEps), 2));\n          double uj = huj * one_over_hjReg;\n          double vj = hvj * one_over_hjReg;\n          double etaj = hetaj * one_over_hjReg;\n          double mj = lumped_mass_matrix[j];\n          double meshSizej = std::sqrt(mj); // local mesh size in 2d\n\n          // Here we define pTilde at jth node\n          double diff_over_h_j = (hetaj - hj * hj) * one_over_hjReg;\n          double pTildej = -(LAMBDA_MGN * g / (3.0 * meshSizej)) * 6.0 * hj *\n                           (hetaj - hj * hj);\n\n          if (IF_BOTH_GAMMA_BRANCHES) {\n            if (hetaj > std::pow(hj, 2.0)) {\n              pTildej = -(LAMBDA_MGN * g / (3.0 * meshSizej)) * 2.0 *\n                        diff_over_h_j * (etaj * etaj + etaj * hj + hj * hj);\n            }\n          }\n\n          // define pressure at jth node\n          double pressure_j = 0.5 * g * hj * hj + pTildej;\n\n          // COMPUTE STAR SOLUTION // hStar, huStar, hvStar, hetaStar, hwStar\n          double hStarij = fmax(0., hi + Zi - fmax(Zi, Zj));\n          double huStarij = hui * hStarij * one_over_hiReg;\n          double hvStarij = hvi * hStarij * one_over_hiReg;\n          double hetaStarij = hetai * std::pow(hStarij * one_over_hiReg, 2);\n          double hwStarij = hwi * std::pow(hStarij * one_over_hiReg, 2);\n\n          double hStarji = fmax(0., hj + Zj - fmax(Zi, Zj));\n          double huStarji = huj * hStarji * one_over_hjReg;\n          double hvStarji = hvj * hStarji * one_over_hjReg;\n          double hetaStarji = hetaj * std::pow(hStarji * one_over_hjReg, 2);\n          double hwStarji = hwj * std::pow(hStarji * one_over_hjReg, 2);\n\n          // Dissipative well balancing term\n          double muLowij = 0., muLij = 0., muHij = 0.;\n          double dLowij = 0., dLij = 0., dHij = 0.;\n          if (i != j) // This is not necessary. See formula for\n                      // ith_dissipative_terms\n          {\n            ////////////////////////\n            // DISSIPATIVE MATRIX //\n            ////////////////////////\n            if (lstage == 0)\n              dLowij = dLow[ij];\n            else {\n              double cij_norm = sqrt(Cx[ij] * Cx[ij] + Cy[ij] * Cy[ij]);\n              double cji_norm = sqrt(CTx[ij] * CTx[ij] + CTy[ij] * CTy[ij]);\n              double nxij = Cx[ij] / cij_norm, nyij = Cy[ij] / cij_norm;\n              double nxji = CTx[ij] / cji_norm, nyji = CTy[ij] / cji_norm;\n              dLowij = fmax(maxWaveSpeedSharpInitialGuess(\n                                g, nxij, nyij, hi, hui, hvi, hetai, mi, hj, huj,\n                                hvj, hetaj, mj, hEps, hEps, false) *\n                                cij_norm,\n                            maxWaveSpeedSharpInitialGuess(\n                                g, nxji, nyji, hj, huj, hvj, hetaj, mj, hi, hui,\n                                hvi, hetai, mi, hEps, hEps, false) *\n                                cji_norm);\n            }\n            dLij = dLowij; //*fmax(psi[i],psi[j]); // enhance the order to 2nd\n                           // order. No EV\n\n            ///////////////////////////////////////\n            // WELL BALANCING DISSIPATIVE MATRIX //\n            ///////////////////////////////////////\n            muLowij = fmax(fmax(0., -(ui * Cx[ij] + vi * Cy[ij])),\n                           fmax(0., (uj * Cx[ij] + vj * Cy[ij])));\n            muLij = muLowij; //*fmax(psi[i],psi[j]); // enhance the order to 2nd\n                             // order.\n\n            // Define dLij as low order dijs\n            muLij = muLowij;\n            dLij = fmax(dLowij, muLij);\n\n            // Then save dLow for limiting step, maybe a bit confusing\n            dLow[ij] = fmax(dLij, muLij);\n\n            ////////////////////////\n            // COMPUTE BAR STATES //\n            ////////////////////////\n            double hBar_ij = 0, hTilde_ij = 0, huBar_ij = 0, huTilde_ij = 0,\n                   hvBar_ij = 0, hvTilde_ij = 0, hetaBar_ij = 0,\n                   hetaTilde_ij = 0, hwBar_ij = 0, hwTilde_ij = 0;\n\n            // h component\n            hBar_ij = -1. / (fmax(2.0 * dLij, dij_small)) *\n                          ((uj * hj - ui * hi) * Cx[ij] +\n                           (vj * hj - vi * hi) * Cy[ij]) +\n                      0.5 * (hj + hi);\n            hTilde_ij = (dLij - muLij) / (fmax(2.0 * dLij, dij_small)) *\n                        ((hStarji - hj) - (hStarij - hi));\n            // hu component\n            huBar_ij =\n                -1. / (fmax(2.0 * dLij, dij_small)) *\n                    ((uj * huj - ui * hui + pressure_j - pressure_i) * Cx[ij] +\n                     (vj * huj - vi * hui) * Cy[ij]) +\n                0.5 * (huj + hui);\n            huTilde_ij = (dLij - muLij) / (fmax(2.0 * dLij, dij_small)) *\n                         ((huStarji - huj) - (huStarij - hui));\n            // hv component\n            hvBar_ij =\n                -1. / (fmax(2.0 * dLij, dij_small)) *\n                    ((uj * hvj - ui * hvi) * Cx[ij] +\n                     (vj * hvj - vi * hvi + pressure_j - pressure_i) * Cy[ij]) +\n                0.5 * (hvj + hvi);\n            hvTilde_ij = (dLij - muLij) / (fmax(2.0 * dLij, dij_small)) *\n                         ((hvStarji - hvj) - (hvStarij - hvi));\n            // heta component\n            hetaBar_ij = -1. / (fmax(2.0 * dLij, dij_small)) *\n                             ((uj * hetaj - ui * hetai) * Cx[ij] +\n                              (vj * hetaj - vi * hetai) * Cy[ij]) +\n                         0.5 * (hetaj + hetai);\n            hetaTilde_ij = (dLij - muLij) / (fmax(2.0 * dLij, dij_small)) *\n                           ((hetaStarji - hetaj) - (hetaStarij - hetai));\n            // hw component\n            hwBar_ij = -1. / (fmax(2.0 * dLij, dij_small)) *\n                           ((uj * hwj - ui * hwi) * Cx[ij] +\n                            (vj * hwj - vi * hwi) * Cy[ij]) +\n                       0.5 * (hwj + hwi);\n            hwTilde_ij = (dLij - muLij) / (fmax(2.0 * dLij, dij_small)) *\n                         ((hwStarji - hwj) - (hwStarij - hwi));\n\n            // Here we define uBar + uTilde\n            hBT[ij] = hBar_ij + hTilde_ij;\n            huBT[ij] = huBar_ij + huTilde_ij;\n            hvBT[ij] = hvBar_ij + hvTilde_ij;\n            hetaBT[ij] = hetaBar_ij + hetaTilde_ij;\n            hwBT[ij] = hwBar_ij + hwTilde_ij;\n\n            ///////////////////////\n            // ENTROPY VISCOSITY //\n            ///////////////////////\n            double dEVij = cE * fmax(global_entropy_residual[i],\n                                     global_entropy_residual[j]);\n            dHij = fmin(dLowij, dEVij);\n            muHij = fmin(muLowij, dEVij);\n            // dHij = dLowij *\n            //        fmax(global_entropy_residual[i],\n            //        global_entropy_residual[j]);\n            // muHij = muLowij * fmax(global_entropy_residual[i],\n            //                        global_entropy_residual[j]);\n\n            // This is if we want smoothness indicator based viscosity\n            // dHij = fmax(psi[i], psi[j]) * dLij;\n            // muHij = fmax(psi[i], psi[j]) * muLij;\n\n            // compute dij_minus_muij times star solution terms\n            // see: eqn (6.13)\n            ith_dHij_minus_muHij_times_hStarStates +=\n                (dHij - muHij) * (hStarji - hStarij);\n            ith_dHij_minus_muHij_times_huStarStates +=\n                (dHij - muHij) * (huStarji - huStarij);\n            ith_dHij_minus_muHij_times_hvStarStates +=\n                (dHij - muHij) * (hvStarji - hvStarij);\n            ith_dHij_minus_muHij_times_hetaStarStates +=\n                (dHij - muHij) * (hetaStarji - hetaStarij);\n            ith_dHij_minus_muHij_times_hwStarStates +=\n                (dHij - muHij) * (hwStarji - hwStarij);\n\n            // compute muij times solution terms\n            ith_muHij_times_hStates += muHij * (hj - hi);\n            ith_muHij_times_huStates += muHij * (huj - hui);\n            ith_muHij_times_hvStates += muHij * (hvj - hvi);\n            ith_muHij_times_hetaStates += muHij * (hetaj - hetai);\n            ith_muHij_times_hwStates += muHij * (hwj - hwi);\n\n            // compute dH_minus_dL\n            dH_minus_dL[ij] = dHij - dLij;\n            muH_minus_muL[ij] = muHij - muLij;\n          } else // i==j\n          {\n            dH_minus_dL[ij] = 0.;   // Not true but the prod of this times\n                                    // Uj-Ui will be zero\n            muH_minus_muL[ij] = 0.; // Not true but the prod of this times\n            // Uj-Ui will be zero\n            // Bar states by definition satisfy Utilde_ii + Ubar_ii = U_i\n            hBT[ij] = hi;\n            huBT[ij] = hui;\n            hvBT[ij] = hvi;\n            hetaBT[ij] = hetai;\n            hwBT[ij] = hwi;\n          }\n\n          // update ij\n          ij += 1;\n\n        } // j loop ends here\n\n        /* Define global residual */\n        if (LUMPED_MASS_MATRIX == 1) {\n          globalResidual[offset_h + stride_h * i] =\n              hi - dt / mi *\n                       (hyp_flux_h[i] - ith_dHij_minus_muHij_times_hStarStates -\n                        ith_muHij_times_hStates);\n          globalResidual[offset_hu + stride_hu * i] =\n              hui - dt / mi *\n                        ((hyp_flux_hu[i] + extendedSourceTerm_hu[i]) -\n                         ith_dHij_minus_muHij_times_huStarStates -\n                         ith_muHij_times_huStates);\n          globalResidual[offset_hv + stride_hv * i] =\n              hvi - dt / mi *\n                        ((hyp_flux_hv[i] + extendedSourceTerm_hv[i]) -\n                         ith_dHij_minus_muHij_times_hvStarStates -\n                         ith_muHij_times_hvStates);\n          globalResidual[offset_heta + stride_heta * i] =\n              hetai - dt / mi *\n                          ((hyp_flux_heta[i] + extendedSourceTerm_heta[i]) -\n                           ith_dHij_minus_muHij_times_hetaStarStates -\n                           ith_muHij_times_hetaStates);\n          globalResidual[offset_hw + stride_hw * i] =\n              hwi - dt / mi *\n                        ((hyp_flux_hw[i] + extendedSourceTerm_hw[i]) -\n                         ith_dHij_minus_muHij_times_hwStarStates -\n                         ith_muHij_times_hwStates);\n\n          // clean up potential negative water height due to machine\n          // precision\n          // if (globalResidual[offset_h + stride_h * i] >= -hEps &&\n          //     globalResidual[offset_h + stride_h * i] < hEps) {\n          //   globalResidual[offset_h + stride_h * i] = 0.0;\n          //   globalResidual[offset_heta + stride_heta * i] = 0.0;\n          // }\n\n        } else {\n          // Distribute residual\n          // NOTE: MASS MATRIX IS CONSISTENT\n          globalResidual[offset_h + stride_h * i] +=\n              dt * (hyp_flux_h[i] - ith_dHij_minus_muHij_times_hStarStates -\n                    ith_muHij_times_hStates);\n          globalResidual[offset_hu + stride_hu * i] +=\n              dt * (hyp_flux_hu[i] + extendedSourceTerm_hu[i] -\n                    ith_dHij_minus_muHij_times_huStarStates -\n                    ith_muHij_times_huStates);\n          globalResidual[offset_hv + stride_hv * i] +=\n              dt * (hyp_flux_hv[i] + extendedSourceTerm_hv[i] -\n                    ith_dHij_minus_muHij_times_hvStarStates -\n                    ith_muHij_times_hvStates);\n          globalResidual[offset_heta + stride_heta * i] +=\n              dt * (hyp_flux_heta[i] + extendedSourceTerm_heta[i] -\n                    ith_dHij_minus_muHij_times_hetaStarStates -\n                    ith_muHij_times_hetaStates);\n          globalResidual[offset_hw + stride_hw * i] +=\n              dt * (hyp_flux_hw[i] + extendedSourceTerm_hw[i] -\n                    ith_dHij_minus_muHij_times_hwStarStates -\n                    ith_muHij_times_hwStates);\n        }\n      }\n      // ********** END OF LOOP IN DOFs ********** //\n    }\n\n    // ********** COMPUTE NORMALS ********** //\n    if (COMPUTE_NORMALS == 1) {\n      // This is to identify the normals and create a vector of normal\n      // components\n      for (int ebNE = 0; ebNE < nExteriorElementBoundaries_global; ebNE++) {\n        register int\n            ebN = exteriorElementBoundariesArray[ebNE],\n            eN = elementBoundaryElementsArray[ebN * 2 + 0],\n            ebN_local = elementBoundaryLocalElementBoundariesArray[ebN * 2 + 0];\n        register double normal[3];\n        {             // \"Loop\" in quad points\n          int kb = 0; // NOTE: I need to consider just one quad point since\n                      // the element is not curved so the normal is constant\n                      // per element\n          register int ebN_local_kb =\n              ebN_local * nQuadraturePoints_elementBoundary + kb;\n          register double jac_ext[nSpace * nSpace], jacDet_ext,\n              jacInv_ext[nSpace * nSpace], boundaryJac[nSpace * (nSpace - 1)],\n              metricTensor[(nSpace - 1) * (nSpace - 1)], metricTensorDetSqrt,\n              x_ext, y_ext;\n          /* compute information about mapping from reference element to\n           * physical element */\n          ck.calculateMapping_elementBoundary(\n              eN, ebN_local, kb, ebN_local_kb, mesh_dof.data(), mesh_l2g.data(),\n              mesh_trial_trace_ref.data(), mesh_grad_trial_trace_ref.data(),\n              boundaryJac_ref.data(), jac_ext, jacDet_ext, jacInv_ext,\n              boundaryJac, metricTensor, metricTensorDetSqrt, normal_ref.data(),\n              normal, x_ext, y_ext);\n        }\n        // distribute the normal vectors\n        for (int i = 0; i < nDOF_test_element; i++) {\n          int eN_i = eN * nDOF_test_element + i;\n          int gi = h_l2g[eN_i];\n          normalx[gi] += 0.5 * normal[0] * (i == ebN_local ? 0. : 1.);\n          normaly[gi] += 0.5 * normal[1] * (i == ebN_local ? 0. : 1.);\n        }\n      }\n      // normalize\n      for (int gi = 0; gi < numDOFsPerEqn; gi++) {\n        double norm_factor =\n            sqrt(std::pow(normalx[gi], 2) + std::pow(normaly[gi], 2));\n        if (norm_factor != 0) {\n          normalx[gi] /= norm_factor;\n          normaly[gi] /= norm_factor;\n        }\n      }\n    }\n    // ********** END OF COMPUTING NORMALS ********** //\n  } // namespace proteus\n\n  void calculateMassMatrix(arguments_dict &args) {\n    xt::pyarray<double> &mesh_trial_ref = args.m_darray[\"mesh_trial_ref\"];\n    xt::pyarray<double> &mesh_grad_trial_ref =\n        args.m_darray[\"mesh_grad_trial_ref\"];\n    xt::pyarray<double> &mesh_dof = args.m_darray[\"mesh_dof\"];\n    xt::pyarray<double> &mesh_velocity_dof = args.m_darray[\"mesh_velocity_dof\"];\n    double MOVING_DOMAIN = args.m_dscalar[\"MOVING_DOMAIN\"];\n    xt::pyarray<int> &mesh_l2g = args.m_iarray[\"mesh_l2g\"];\n    xt::pyarray<double> &dV_ref = args.m_darray[\"dV_ref\"];\n    xt::pyarray<double> &h_trial_ref = args.m_darray[\"h_trial_ref\"];\n    xt::pyarray<double> &h_grad_trial_ref = args.m_darray[\"h_grad_trial_ref\"];\n    xt::pyarray<double> &h_test_ref = args.m_darray[\"h_test_ref\"];\n    xt::pyarray<double> &h_grad_test_ref = args.m_darray[\"h_grad_test_ref\"];\n    xt::pyarray<double> &vel_trial_ref = args.m_darray[\"vel_trial_ref\"];\n    xt::pyarray<double> &vel_grad_trial_ref =\n        args.m_darray[\"vel_grad_trial_ref\"];\n    xt::pyarray<double> &vel_test_ref = args.m_darray[\"vel_test_ref\"];\n    xt::pyarray<double> &vel_grad_test_ref = args.m_darray[\"vel_grad_test_ref\"];\n    xt::pyarray<double> &mesh_trial_trace_ref =\n        args.m_darray[\"mesh_trial_trace_ref\"];\n    xt::pyarray<double> &mesh_grad_trial_trace_ref =\n        args.m_darray[\"mesh_grad_trial_trace_ref\"];\n    xt::pyarray<double> &dS_ref = args.m_darray[\"dS_ref\"];\n    xt::pyarray<double> &h_trial_trace_ref = args.m_darray[\"h_trial_trace_ref\"];\n    xt::pyarray<double> &h_grad_trial_trace_ref =\n        args.m_darray[\"h_grad_trial_trace_ref\"];\n    xt::pyarray<double> &h_test_trace_ref = args.m_darray[\"h_test_trace_ref\"];\n    xt::pyarray<double> &h_grad_test_trace_ref =\n        args.m_darray[\"h_grad_test_trace_ref\"];\n    xt::pyarray<double> &vel_trial_trace_ref =\n        args.m_darray[\"vel_trial_trace_ref\"];\n    xt::pyarray<double> &vel_grad_trial_trace_ref =\n        args.m_darray[\"vel_grad_trial_trace_ref\"];\n    xt::pyarray<double> &vel_test_trace_ref =\n        args.m_darray[\"vel_test_trace_ref\"];\n    xt::pyarray<double> &vel_grad_test_trace_ref =\n        args.m_darray[\"vel_grad_test_trace_ref\"];\n    xt::pyarray<double> &normal_ref = args.m_darray[\"normal_ref\"];\n    xt::pyarray<double> &boundaryJac_ref = args.m_darray[\"boundaryJac_ref\"];\n    xt::pyarray<double> &elementDiameter = args.m_darray[\"elementDiameter\"];\n    int nElements_global = args.m_iscalar[\"nElements_global\"];\n    double useRBLES = args.m_dscalar[\"useRBLES\"];\n    double useMetrics = args.m_dscalar[\"useMetrics\"];\n    double alphaBDF = args.m_dscalar[\"alphaBDF\"];\n    double nu = args.m_dscalar[\"nu\"];\n    double g = args.m_dscalar[\"g\"];\n    xt::pyarray<int> &h_l2g = args.m_iarray[\"h_l2g\"];\n    xt::pyarray<int> &vel_l2g = args.m_iarray[\"vel_l2g\"];\n    xt::pyarray<double> &b_dof = args.m_darray[\"b_dof\"];\n    xt::pyarray<double> &h_dof = args.m_darray[\"h_dof\"];\n    xt::pyarray<double> &hu_dof = args.m_darray[\"hu_dof\"];\n    xt::pyarray<double> &hv_dof = args.m_darray[\"hv_dof\"];\n    xt::pyarray<double> &heta_dof = args.m_darray[\"heta_dof\"];\n    xt::pyarray<double> &hw_dof = args.m_darray[\"hw_dof\"];\n    xt::pyarray<double> &h_dof_sge = args.m_darray[\"h_dof_sge\"];\n    xt::pyarray<double> &hu_dof_sge = args.m_darray[\"hu_dof_sge\"];\n    xt::pyarray<double> &hv_dof_sge = args.m_darray[\"hv_dof_sge\"];\n    xt::pyarray<double> &heta_dof_sge = args.m_darray[\"heta_dof_sge\"];\n    xt::pyarray<double> &hw_dof_sge = args.m_darray[\"hw_dof_sge\"];\n    xt::pyarray<double> &q_mass_acc_beta_bdf =\n        args.m_darray[\"q_mass_acc_beta_bdf\"];\n    xt::pyarray<double> &q_mom_hu_acc_beta_bdf =\n        args.m_darray[\"q_mom_hu_acc_beta_bdf\"];\n    xt::pyarray<double> &q_mom_hv_acc_beta_bdf =\n        args.m_darray[\"q_mom_hv_acc_beta_bdf\"];\n    xt::pyarray<double> &q_cfl = args.m_darray[\"q_cfl\"];\n    xt::pyarray<int> &sdInfo_hu_hu_rowptr =\n        args.m_iarray[\"sdInfo_hu_hu_rowptr\"];\n    xt::pyarray<int> &sdInfo_hu_hu_colind =\n        args.m_iarray[\"sdInfo_hu_hu_colind\"];\n    xt::pyarray<int> &sdInfo_hu_hv_rowptr =\n        args.m_iarray[\"sdInfo_hu_hv_rowptr\"];\n    xt::pyarray<int> &sdInfo_hu_hv_colind =\n        args.m_iarray[\"sdInfo_hu_hv_colind\"];\n    xt::pyarray<int> &sdInfo_hv_hv_rowptr =\n        args.m_iarray[\"sdInfo_hv_hv_rowptr\"];\n    xt::pyarray<int> &sdInfo_hv_hv_colind =\n        args.m_iarray[\"sdInfo_hv_hv_colind\"];\n    xt::pyarray<int> &sdInfo_hv_hu_rowptr =\n        args.m_iarray[\"sdInfo_hv_hu_rowptr\"];\n    xt::pyarray<int> &sdInfo_hv_hu_colind =\n        args.m_iarray[\"sdInfo_hv_hu_colind\"];\n    xt::pyarray<int> &csrRowIndeces_h_h = args.m_iarray[\"csrRowIndeces_h_h\"];\n    xt::pyarray<int> &csrColumnOffsets_h_h =\n        args.m_iarray[\"csrColumnOffsets_h_h\"];\n    xt::pyarray<int> &csrRowIndeces_h_hu = args.m_iarray[\"csrRowIndeces_h_hu\"];\n    xt::pyarray<int> &csrColumnOffsets_h_hu =\n        args.m_iarray[\"csrColumnOffsets_h_hu\"];\n    xt::pyarray<int> &csrRowIndeces_h_hv = args.m_iarray[\"csrRowIndeces_h_hv\"];\n    xt::pyarray<int> &csrColumnOffsets_h_hv =\n        args.m_iarray[\"csrColumnOffsets_h_hv\"];\n    xt::pyarray<int> &csrRowIndeces_h_heta =\n        args.m_iarray[\"csrRowIndeces_h_heta\"];\n    xt::pyarray<int> &csrColumnOffsets_h_heta =\n        args.m_iarray[\"csrColumnOffsets_h_heta\"];\n    xt::pyarray<int> &csrRowIndeces_h_hw = args.m_iarray[\"csrRowIndeces_h_hw\"];\n    xt::pyarray<int> &csrColumnOffsets_h_hw =\n        args.m_iarray[\"csrColumnOffsets_h_hw\"];\n    xt::pyarray<int> &csrRowIndeces_hu_h = args.m_iarray[\"csrRowIndeces_hu_h\"];\n    xt::pyarray<int> &csrColumnOffsets_hu_h =\n        args.m_iarray[\"csrColumnOffsets_hu_h\"];\n    xt::pyarray<int> &csrRowIndeces_hu_hu =\n        args.m_iarray[\"csrRowIndeces_hu_hu\"];\n    xt::pyarray<int> &csrColumnOffsets_hu_hu =\n        args.m_iarray[\"csrColumnOffsets_hu_hu\"];\n    xt::pyarray<int> &csrRowIndeces_hu_hv =\n        args.m_iarray[\"csrRowIndeces_hu_hv\"];\n    xt::pyarray<int> &csrColumnOffsets_hu_hv =\n        args.m_iarray[\"csrColumnOffsets_hu_hv\"];\n    xt::pyarray<int> &csrRowIndeces_hu_heta =\n        args.m_iarray[\"csrRowIndeces_hu_heta\"];\n    xt::pyarray<int> &csrColumnOffsets_hu_heta =\n        args.m_iarray[\"csrColumnOffsets_hu_heta\"];\n    xt::pyarray<int> &csrRowIndeces_hu_hw =\n        args.m_iarray[\"csrRowIndeces_hu_hw\"];\n    xt::pyarray<int> &csrColumnOffsets_hu_hw =\n        args.m_iarray[\"csrColumnOffsets_hu_hw\"];\n    xt::pyarray<int> &csrRowIndeces_hv_h = args.m_iarray[\"csrRowIndeces_hv_h\"];\n    xt::pyarray<int> &csrColumnOffsets_hv_h =\n        args.m_iarray[\"csrColumnOffsets_hv_h\"];\n    xt::pyarray<int> &csrRowIndeces_hv_hu =\n        args.m_iarray[\"csrRowIndeces_hv_hu\"];\n    xt::pyarray<int> &csrColumnOffsets_hv_hu =\n        args.m_iarray[\"csrColumnOffsets_hv_hu\"];\n    xt::pyarray<int> &csrRowIndeces_hv_hv =\n        args.m_iarray[\"csrRowIndeces_hv_hv\"];\n    xt::pyarray<int> &csrColumnOffsets_hv_hv =\n        args.m_iarray[\"csrColumnOffsets_hv_hv\"];\n    xt::pyarray<int> &csrRowIndeces_hv_heta =\n        args.m_iarray[\"csrRowIndeces_hv_heta\"];\n    xt::pyarray<int> &csrColumnOffsets_hv_heta =\n        args.m_iarray[\"csrColumnOffsets_hv_heta\"];\n    xt::pyarray<int> &csrRowIndeces_hv_hw =\n        args.m_iarray[\"csrRowIndeces_hv_hw\"];\n    xt::pyarray<int> &csrColumnOffsets_hv_hw =\n        args.m_iarray[\"csrColumnOffsets_hv_hw\"];\n    xt::pyarray<int> &csrRowIndeces_heta_h =\n        args.m_iarray[\"csrRowIndeces_heta_h\"];\n    xt::pyarray<int> &csrColumnOffsets_heta_h =\n        args.m_iarray[\"csrColumnOffsets_heta_h\"];\n    xt::pyarray<int> &csrRowIndeces_heta_hu =\n        args.m_iarray[\"csrRowIndeces_heta_hu\"];\n    xt::pyarray<int> &csrColumnOffsets_heta_hu =\n        args.m_iarray[\"csrColumnOffsets_heta_hu\"];\n    xt::pyarray<int> &csrRowIndeces_heta_hv =\n        args.m_iarray[\"csrRowIndeces_heta_hv\"];\n    xt::pyarray<int> &csrColumnOffsets_heta_hv =\n        args.m_iarray[\"csrColumnOffsets_heta_hv\"];\n    xt::pyarray<int> &csrRowIndeces_heta_heta =\n        args.m_iarray[\"csrRowIndeces_heta_heta\"];\n    xt::pyarray<int> &csrColumnOffsets_heta_heta =\n        args.m_iarray[\"csrColumnOffsets_heta_heta\"];\n    xt::pyarray<int> &csrRowIndeces_heta_hw =\n        args.m_iarray[\"csrRowIndeces_heta_hw\"];\n    xt::pyarray<int> &csrColumnOffsets_heta_hw =\n        args.m_iarray[\"csrColumnOffsets_heta_hw\"];\n    xt::pyarray<int> &csrRowIndeces_hw_h = args.m_iarray[\"csrRowIndeces_hw_h\"];\n    xt::pyarray<int> &csrColumnOffsets_hw_h =\n        args.m_iarray[\"csrColumnOffsets_hw_h\"];\n    xt::pyarray<int> &csrRowIndeces_hw_hu =\n        args.m_iarray[\"csrRowIndeces_hw_hu\"];\n    xt::pyarray<int> &csrColumnOffsets_hw_hu =\n        args.m_iarray[\"csrColumnOffsets_hw_hu\"];\n    xt::pyarray<int> &csrRowIndeces_hw_hv =\n        args.m_iarray[\"csrRowIndeces_hw_hv\"];\n    xt::pyarray<int> &csrColumnOffsets_hw_hv =\n        args.m_iarray[\"csrColumnOffsets_hw_hv\"];\n    xt::pyarray<int> &csrRowIndeces_hw_heta =\n        args.m_iarray[\"csrRowIndeces_hw_heta\"];\n    xt::pyarray<int> &csrColumnOffsets_hw_heta =\n        args.m_iarray[\"csrColumnOffsets_hw_heta\"];\n    xt::pyarray<int> &csrRowIndeces_hw_hw =\n        args.m_iarray[\"csrRowIndeces_hw_hw\"];\n    xt::pyarray<int> &csrColumnOffsets_hw_hw =\n        args.m_iarray[\"csrColumnOffsets_hw_hw\"];\n    xt::pyarray<double> &globalJacobian = args.m_darray[\"globalJacobian\"];\n    int nExteriorElementBoundaries_global =\n        args.m_iscalar[\"nExteriorElementBoundaries_global\"];\n    xt::pyarray<int> &exteriorElementBoundariesArray =\n        args.m_iarray[\"exteriorElementBoundariesArray\"];\n    xt::pyarray<int> &elementBoundaryElementsArray =\n        args.m_iarray[\"elementBoundaryElementsArray\"];\n    xt::pyarray<int> &elementBoundaryLocalElementBoundariesArray =\n        args.m_iarray[\"elementBoundaryLocalElementBoundariesArray\"];\n    xt::pyarray<int> &isDOFBoundary_h = args.m_iarray[\"isDOFBoundary_h\"];\n    xt::pyarray<int> &isDOFBoundary_hu = args.m_iarray[\"isDOFBoundary_hu\"];\n    xt::pyarray<int> &isDOFBoundary_hv = args.m_iarray[\"isDOFBoundary_hv\"];\n    xt::pyarray<int> &isAdvectiveFluxBoundary_h =\n        args.m_iarray[\"isAdvectiveFluxBoundary_h\"];\n    xt::pyarray<int> &isAdvectiveFluxBoundary_hu =\n        args.m_iarray[\"isAdvectiveFluxBoundary_hu\"];\n    xt::pyarray<int> &isAdvectiveFluxBoundary_hv =\n        args.m_iarray[\"isAdvectiveFluxBoundary_hv\"];\n    xt::pyarray<int> &isDiffusiveFluxBoundary_hu =\n        args.m_iarray[\"isDiffusiveFluxBoundary_hu\"];\n    xt::pyarray<int> &isDiffusiveFluxBoundary_hv =\n        args.m_iarray[\"isDiffusiveFluxBoundary_hv\"];\n    xt::pyarray<double> &ebqe_bc_h_ext = args.m_darray[\"ebqe_bc_h_ext\"];\n    xt::pyarray<double> &ebqe_bc_flux_mass_ext =\n        args.m_darray[\"ebqe_bc_flux_mass_ext\"];\n    xt::pyarray<double> &ebqe_bc_flux_mom_hu_adv_ext =\n        args.m_darray[\"ebqe_bc_flux_mom_hu_adv_ext\"];\n    xt::pyarray<double> &ebqe_bc_flux_mom_hv_adv_ext =\n        args.m_darray[\"ebqe_bc_flux_mom_hv_adv_ext\"];\n    xt::pyarray<double> &ebqe_bc_hu_ext = args.m_darray[\"ebqe_bc_hu_ext\"];\n    xt::pyarray<double> &ebqe_bc_flux_hu_diff_ext =\n        args.m_darray[\"ebqe_bc_flux_hu_diff_ext\"];\n    xt::pyarray<double> &ebqe_penalty_ext = args.m_darray[\"ebqe_penalty_ext\"];\n    xt::pyarray<double> &ebqe_bc_hv_ext = args.m_darray[\"ebqe_bc_hv_ext\"];\n    xt::pyarray<double> &ebqe_bc_flux_hv_diff_ext =\n        args.m_darray[\"ebqe_bc_flux_hv_diff_ext\"];\n    xt::pyarray<int> &csrColumnOffsets_eb_h_h =\n        args.m_iarray[\"csrColumnOffsets_eb_h_h\"];\n    xt::pyarray<int> &csrColumnOffsets_eb_h_hu =\n        args.m_iarray[\"csrColumnOffsets_eb_h_hu\"];\n    xt::pyarray<int> &csrColumnOffsets_eb_h_hv =\n        args.m_iarray[\"csrColumnOffsets_eb_h_hv\"];\n    xt::pyarray<int> &csrColumnOffsets_eb_hu_h =\n        args.m_iarray[\"csrColumnOffsets_eb_hu_h\"];\n    xt::pyarray<int> &csrColumnOffsets_eb_hu_hu =\n        args.m_iarray[\"csrColumnOffsets_eb_hu_hu\"];\n    xt::pyarray<int> &csrColumnOffsets_eb_hu_hv =\n        args.m_iarray[\"csrColumnOffsets_eb_hu_hv\"];\n    xt::pyarray<int> &csrColumnOffsets_eb_hv_h =\n        args.m_iarray[\"csrColumnOffsets_eb_hv_h\"];\n    xt::pyarray<int> &csrColumnOffsets_eb_hv_hu =\n        args.m_iarray[\"csrColumnOffsets_eb_hv_hu\"];\n    xt::pyarray<int> &csrColumnOffsets_eb_hv_hv =\n        args.m_iarray[\"csrColumnOffsets_eb_hv_hv\"];\n    double dt = args.m_dscalar[\"dt\"];\n    //\n    // loop over elements to compute volume integrals and load them into the\n    // element Jacobians and global Jacobian\n    //\n    for (int eN = 0; eN < nElements_global; eN++) {\n      register double elementJacobian_h_h[nDOF_test_element]\n                                         [nDOF_trial_element],\n          elementJacobian_hu_hu[nDOF_test_element][nDOF_trial_element],\n          elementJacobian_hv_hv[nDOF_test_element][nDOF_trial_element],\n          elementJacobian_heta_heta[nDOF_test_element][nDOF_trial_element],\n          elementJacobian_hw_hw[nDOF_test_element][nDOF_trial_element];\n      for (int i = 0; i < nDOF_test_element; i++)\n        for (int j = 0; j < nDOF_trial_element; j++) {\n          elementJacobian_h_h[i][j] = 0.0;\n          elementJacobian_hu_hu[i][j] = 0.0;\n          elementJacobian_hv_hv[i][j] = 0.0;\n          elementJacobian_heta_heta[i][j] = 0.0;\n          elementJacobian_hw_hw[i][j] = 0.0;\n        }\n      for (int k = 0; k < nQuadraturePoints_element; k++) {\n        int eN_k = eN * nQuadraturePoints_element +\n                   k, // index to a scalar at a quadrature point\n            eN_k_nSpace = eN_k * nSpace,\n            eN_nDOF_trial_element =\n                eN * nDOF_trial_element; // index to a vector at a\n                                         // quadrature point\n\n        // declare local storage\n        register double jac[nSpace * nSpace], jacDet, jacInv[nSpace * nSpace],\n            dV, h_test_dV[nDOF_test_element], vel_test_dV[nDOF_test_element], x,\n            y, xt, yt;\n        // get jacobian, etc for mapping reference element\n        ck.calculateMapping_element(\n            eN, k, mesh_dof.data(), mesh_l2g.data(), mesh_trial_ref.data(),\n            mesh_grad_trial_ref.data(), jac, jacDet, jacInv, x, y);\n        // get the physical integration weight\n        dV = fabs(jacDet) * dV_ref[k];\n        // precalculate test function products with integration weights\n        for (int j = 0; j < nDOF_trial_element; j++) {\n          h_test_dV[j] = h_test_ref[k * nDOF_trial_element + j] * dV;\n          vel_test_dV[j] = vel_test_ref[k * nDOF_trial_element + j] * dV;\n        }\n        for (int i = 0; i < nDOF_test_element; i++) {\n          register int i_nSpace = i * nSpace;\n          for (int j = 0; j < nDOF_trial_element; j++) {\n            register int j_nSpace = j * nSpace;\n            elementJacobian_h_h[i][j] +=\n                h_trial_ref[k * nDOF_trial_element + j] * h_test_dV[i];\n            elementJacobian_hu_hu[i][j] +=\n                vel_trial_ref[k * nDOF_trial_element + j] * vel_test_dV[i];\n            elementJacobian_hv_hv[i][j] +=\n                vel_trial_ref[k * nDOF_trial_element + j] * vel_test_dV[i];\n            elementJacobian_heta_heta[i][j] +=\n                vel_trial_ref[k * nDOF_trial_element + j] * vel_test_dV[i];\n            elementJacobian_hw_hw[i][j] +=\n                vel_trial_ref[k * nDOF_trial_element + j] * vel_test_dV[i];\n          } // j\n        }   // i\n      }     // k\n      //\n      // load into element Jacobian into global Jacobian\n      //\n      for (int i = 0; i < nDOF_test_element; i++) {\n        register int eN_i = eN * nDOF_test_element + i;\n        for (int j = 0; j < nDOF_trial_element; j++) {\n          register int eN_i_j = eN_i * nDOF_trial_element + j;\n          globalJacobian[csrRowIndeces_h_h[eN_i] +\n                         csrColumnOffsets_h_h[eN_i_j]] +=\n              elementJacobian_h_h[i][j];\n          globalJacobian[csrRowIndeces_hu_hu[eN_i] +\n                         csrColumnOffsets_hu_hu[eN_i_j]] +=\n              elementJacobian_hu_hu[i][j];\n          globalJacobian[csrRowIndeces_hv_hv[eN_i] +\n                         csrColumnOffsets_hv_hv[eN_i_j]] +=\n              elementJacobian_hv_hv[i][j];\n          globalJacobian[csrRowIndeces_heta_heta[eN_i] +\n                         csrColumnOffsets_heta_heta[eN_i_j]] +=\n              elementJacobian_heta_heta[i][j];\n          globalJacobian[csrRowIndeces_hw_hw[eN_i] +\n                         csrColumnOffsets_hw_hw[eN_i_j]] +=\n              elementJacobian_hw_hw[i][j];\n        } // j\n      }   // i\n    }     // elements\n  }\n\n  void calculateLumpedMassMatrix(arguments_dict &args) {\n    xt::pyarray<double> &mesh_trial_ref = args.m_darray[\"mesh_trial_ref\"];\n    xt::pyarray<double> &mesh_grad_trial_ref =\n        args.m_darray[\"mesh_grad_trial_ref\"];\n    xt::pyarray<double> &mesh_dof = args.m_darray[\"mesh_dof\"];\n    xt::pyarray<double> &mesh_velocity_dof = args.m_darray[\"mesh_velocity_dof\"];\n    double MOVING_DOMAIN = args.m_dscalar[\"MOVING_DOMAIN\"];\n    xt::pyarray<int> &mesh_l2g = args.m_iarray[\"mesh_l2g\"];\n    xt::pyarray<double> &dV_ref = args.m_darray[\"dV_ref\"];\n    xt::pyarray<double> &h_trial_ref = args.m_darray[\"h_trial_ref\"];\n    xt::pyarray<double> &h_grad_trial_ref = args.m_darray[\"h_grad_trial_ref\"];\n    xt::pyarray<double> &h_test_ref = args.m_darray[\"h_test_ref\"];\n    xt::pyarray<double> &h_grad_test_ref = args.m_darray[\"h_grad_test_ref\"];\n    xt::pyarray<double> &vel_trial_ref = args.m_darray[\"vel_trial_ref\"];\n    xt::pyarray<double> &vel_grad_trial_ref =\n        args.m_darray[\"vel_grad_trial_ref\"];\n    xt::pyarray<double> &vel_test_ref = args.m_darray[\"vel_test_ref\"];\n    xt::pyarray<double> &vel_grad_test_ref = args.m_darray[\"vel_grad_test_ref\"];\n    xt::pyarray<double> &mesh_trial_trace_ref =\n        args.m_darray[\"mesh_trial_trace_ref\"];\n    xt::pyarray<double> &mesh_grad_trial_trace_ref =\n        args.m_darray[\"mesh_grad_trial_trace_ref\"];\n    xt::pyarray<double> &dS_ref = args.m_darray[\"dS_ref\"];\n    xt::pyarray<double> &h_trial_trace_ref = args.m_darray[\"h_trial_trace_ref\"];\n    xt::pyarray<double> &h_grad_trial_trace_ref =\n        args.m_darray[\"h_grad_trial_trace_ref\"];\n    xt::pyarray<double> &h_test_trace_ref = args.m_darray[\"h_test_trace_ref\"];\n    xt::pyarray<double> &h_grad_test_trace_ref =\n        args.m_darray[\"h_grad_test_trace_ref\"];\n    xt::pyarray<double> &vel_trial_trace_ref =\n        args.m_darray[\"vel_trial_trace_ref\"];\n    xt::pyarray<double> &vel_grad_trial_trace_ref =\n        args.m_darray[\"vel_grad_trial_trace_ref\"];\n    xt::pyarray<double> &vel_test_trace_ref =\n        args.m_darray[\"vel_test_trace_ref\"];\n    xt::pyarray<double> &vel_grad_test_trace_ref =\n        args.m_darray[\"vel_grad_test_trace_ref\"];\n    xt::pyarray<double> &normal_ref = args.m_darray[\"normal_ref\"];\n    xt::pyarray<double> &boundaryJac_ref = args.m_darray[\"boundaryJac_ref\"];\n    xt::pyarray<double> &elementDiameter = args.m_darray[\"elementDiameter\"];\n    int nElements_global = args.m_iscalar[\"nElements_global\"];\n    double useRBLES = args.m_dscalar[\"useRBLES\"];\n    double useMetrics = args.m_dscalar[\"useMetrics\"];\n    double alphaBDF = args.m_dscalar[\"alphaBDF\"];\n    double nu = args.m_dscalar[\"nu\"];\n    double g = args.m_dscalar[\"g\"];\n    xt::pyarray<int> &h_l2g = args.m_iarray[\"h_l2g\"];\n    xt::pyarray<int> &vel_l2g = args.m_iarray[\"vel_l2g\"];\n    xt::pyarray<double> &b_dof = args.m_darray[\"b_dof\"];\n    xt::pyarray<double> &h_dof = args.m_darray[\"h_dof\"];\n    xt::pyarray<double> &hu_dof = args.m_darray[\"hu_dof\"];\n    xt::pyarray<double> &hv_dof = args.m_darray[\"hv_dof\"];\n    xt::pyarray<double> &h_dof_sge = args.m_darray[\"h_dof_sge\"];\n    xt::pyarray<double> &hu_dof_sge = args.m_darray[\"hu_dof_sge\"];\n    xt::pyarray<double> &hv_dof_sge = args.m_darray[\"hv_dof_sge\"];\n    xt::pyarray<double> &q_mass_acc_beta_bdf =\n        args.m_darray[\"q_mass_acc_beta_bdf\"];\n    xt::pyarray<double> &q_mom_hu_acc_beta_bdf =\n        args.m_darray[\"q_mom_hu_acc_beta_bdf\"];\n    xt::pyarray<double> &q_mom_hv_acc_beta_bdf =\n        args.m_darray[\"q_mom_hv_acc_beta_bdf\"];\n    xt::pyarray<double> &q_cfl = args.m_darray[\"q_cfl\"];\n    xt::pyarray<int> &sdInfo_hu_hu_rowptr =\n        args.m_iarray[\"sdInfo_hu_hu_rowptr\"];\n    xt::pyarray<int> &sdInfo_hu_hu_colind =\n        args.m_iarray[\"sdInfo_hu_hu_colind\"];\n    xt::pyarray<int> &sdInfo_hu_hv_rowptr =\n        args.m_iarray[\"sdInfo_hu_hv_rowptr\"];\n    xt::pyarray<int> &sdInfo_hu_hv_colind =\n        args.m_iarray[\"sdInfo_hu_hv_colind\"];\n    xt::pyarray<int> &sdInfo_hv_hv_rowptr =\n        args.m_iarray[\"sdInfo_hv_hv_rowptr\"];\n    xt::pyarray<int> &sdInfo_hv_hv_colind =\n        args.m_iarray[\"sdInfo_hv_hv_colind\"];\n    xt::pyarray<int> &sdInfo_hv_hu_rowptr =\n        args.m_iarray[\"sdInfo_hv_hu_rowptr\"];\n    xt::pyarray<int> &sdInfo_hv_hu_colind =\n        args.m_iarray[\"sdInfo_hv_hu_colind\"];\n    xt::pyarray<int> &csrRowIndeces_h_h = args.m_iarray[\"csrRowIndeces_h_h\"];\n    xt::pyarray<int> &csrColumnOffsets_h_h =\n        args.m_iarray[\"csrColumnOffsets_h_h\"];\n    xt::pyarray<int> &csrRowIndeces_h_hu = args.m_iarray[\"csrRowIndeces_h_hu\"];\n    xt::pyarray<int> &csrColumnOffsets_h_hu =\n        args.m_iarray[\"csrColumnOffsets_h_hu\"];\n    xt::pyarray<int> &csrRowIndeces_h_hv = args.m_iarray[\"csrRowIndeces_h_hv\"];\n    xt::pyarray<int> &csrColumnOffsets_h_hv =\n        args.m_iarray[\"csrColumnOffsets_h_hv\"];\n    xt::pyarray<int> &csrRowIndeces_h_heta =\n        args.m_iarray[\"csrRowIndeces_h_heta\"];\n    xt::pyarray<int> &csrColumnOffsets_h_heta =\n        args.m_iarray[\"csrColumnOffsets_h_heta\"];\n    xt::pyarray<int> &csrRowIndeces_h_hw = args.m_iarray[\"csrRowIndeces_h_hw\"];\n    xt::pyarray<int> &csrColumnOffsets_h_hw =\n        args.m_iarray[\"csrColumnOffsets_h_hw\"];\n    xt::pyarray<int> &csrRowIndeces_hu_h = args.m_iarray[\"csrRowIndeces_hu_h\"];\n    xt::pyarray<int> &csrColumnOffsets_hu_h =\n        args.m_iarray[\"csrColumnOffsets_hu_h\"];\n    xt::pyarray<int> &csrRowIndeces_hu_hu =\n        args.m_iarray[\"csrRowIndeces_hu_hu\"];\n    xt::pyarray<int> &csrColumnOffsets_hu_hu =\n        args.m_iarray[\"csrColumnOffsets_hu_hu\"];\n    xt::pyarray<int> &csrRowIndeces_hu_hv =\n        args.m_iarray[\"csrRowIndeces_hu_hv\"];\n    xt::pyarray<int> &csrColumnOffsets_hu_hv =\n        args.m_iarray[\"csrColumnOffsets_hu_hv\"];\n    xt::pyarray<int> &csrRowIndeces_hu_heta =\n        args.m_iarray[\"csrRowIndeces_hu_heta\"];\n    xt::pyarray<int> &csrColumnOffsets_hu_heta =\n        args.m_iarray[\"csrColumnOffsets_hu_heta\"];\n    xt::pyarray<int> &csrRowIndeces_hu_hw =\n        args.m_iarray[\"csrRowIndeces_hu_hw\"];\n    xt::pyarray<int> &csrColumnOffsets_hu_hw =\n        args.m_iarray[\"csrColumnOffsets_hu_hw\"];\n    xt::pyarray<int> &csrRowIndeces_hv_h = args.m_iarray[\"csrRowIndeces_hv_h\"];\n    xt::pyarray<int> &csrColumnOffsets_hv_h =\n        args.m_iarray[\"csrColumnOffsets_hv_h\"];\n    xt::pyarray<int> &csrRowIndeces_hv_hu =\n        args.m_iarray[\"csrRowIndeces_hv_hu\"];\n    xt::pyarray<int> &csrColumnOffsets_hv_hu =\n        args.m_iarray[\"csrColumnOffsets_hv_hu\"];\n    xt::pyarray<int> &csrRowIndeces_hv_hv =\n        args.m_iarray[\"csrRowIndeces_hv_hv\"];\n    xt::pyarray<int> &csrColumnOffsets_hv_hv =\n        args.m_iarray[\"csrColumnOffsets_hv_hv\"];\n    xt::pyarray<int> &csrRowIndeces_hv_heta =\n        args.m_iarray[\"csrRowIndeces_hv_heta\"];\n    xt::pyarray<int> &csrColumnOffsets_hv_heta =\n        args.m_iarray[\"csrColumnOffsets_hv_heta\"];\n    xt::pyarray<int> &csrRowIndeces_hv_hw =\n        args.m_iarray[\"csrRowIndeces_hv_hw\"];\n    xt::pyarray<int> &csrColumnOffsets_hv_hw =\n        args.m_iarray[\"csrColumnOffsets_hv_hw\"];\n    xt::pyarray<int> &csrRowIndeces_heta_h =\n        args.m_iarray[\"csrRowIndeces_heta_h\"];\n    xt::pyarray<int> &csrColumnOffsets_heta_h =\n        args.m_iarray[\"csrColumnOffsets_heta_h\"];\n    xt::pyarray<int> &csrRowIndeces_heta_hu =\n        args.m_iarray[\"csrRowIndeces_heta_hu\"];\n    xt::pyarray<int> &csrColumnOffsets_heta_hu =\n        args.m_iarray[\"csrColumnOffsets_heta_hu\"];\n    xt::pyarray<int> &csrRowIndeces_heta_hv =\n        args.m_iarray[\"csrRowIndeces_heta_hv\"];\n    xt::pyarray<int> &csrColumnOffsets_heta_hv =\n        args.m_iarray[\"csrColumnOffsets_heta_hv\"];\n    xt::pyarray<int> &csrRowIndeces_heta_heta =\n        args.m_iarray[\"csrRowIndeces_heta_heta\"];\n    xt::pyarray<int> &csrColumnOffsets_heta_heta =\n        args.m_iarray[\"csrColumnOffsets_heta_heta\"];\n    xt::pyarray<int> &csrRowIndeces_heta_hw =\n        args.m_iarray[\"csrRowIndeces_heta_hw\"];\n    xt::pyarray<int> &csrColumnOffsets_heta_hw =\n        args.m_iarray[\"csrColumnOffsets_heta_hw\"];\n    xt::pyarray<int> &csrRowIndeces_hw_h = args.m_iarray[\"csrRowIndeces_hw_h\"];\n    xt::pyarray<int> &csrColumnOffsets_hw_h =\n        args.m_iarray[\"csrColumnOffsets_hw_h\"];\n    xt::pyarray<int> &csrRowIndeces_hw_hu =\n        args.m_iarray[\"csrRowIndeces_hw_hu\"];\n    xt::pyarray<int> &csrColumnOffsets_hw_hu =\n        args.m_iarray[\"csrColumnOffsets_hw_hu\"];\n    xt::pyarray<int> &csrRowIndeces_hw_hv =\n        args.m_iarray[\"csrRowIndeces_hw_hv\"];\n    xt::pyarray<int> &csrColumnOffsets_hw_hv =\n        args.m_iarray[\"csrColumnOffsets_hw_hv\"];\n    xt::pyarray<int> &csrRowIndeces_hw_heta =\n        args.m_iarray[\"csrRowIndeces_hw_heta\"];\n    xt::pyarray<int> &csrColumnOffsets_hw_heta =\n        args.m_iarray[\"csrColumnOffsets_hw_heta\"];\n    xt::pyarray<int> &csrRowIndeces_hw_hw =\n        args.m_iarray[\"csrRowIndeces_hw_hw\"];\n    xt::pyarray<int> &csrColumnOffsets_hw_hw =\n        args.m_iarray[\"csrColumnOffsets_hw_hw\"];\n    xt::pyarray<double> &globalJacobian = args.m_darray[\"globalJacobian\"];\n    int nExteriorElementBoundaries_global =\n        args.m_iscalar[\"nExteriorElementBoundaries_global\"];\n    xt::pyarray<int> &exteriorElementBoundariesArray =\n        args.m_iarray[\"exteriorElementBoundariesArray\"];\n    xt::pyarray<int> &elementBoundaryElementsArray =\n        args.m_iarray[\"elementBoundaryElementsArray\"];\n    xt::pyarray<int> &elementBoundaryLocalElementBoundariesArray =\n        args.m_iarray[\"elementBoundaryLocalElementBoundariesArray\"];\n    xt::pyarray<int> &isDOFBoundary_h = args.m_iarray[\"isDOFBoundary_h\"];\n    xt::pyarray<int> &isDOFBoundary_hu = args.m_iarray[\"isDOFBoundary_hu\"];\n    xt::pyarray<int> &isDOFBoundary_hv = args.m_iarray[\"isDOFBoundary_hv\"];\n    xt::pyarray<int> &isAdvectiveFluxBoundary_h =\n        args.m_iarray[\"isAdvectiveFluxBoundary_h\"];\n    xt::pyarray<int> &isAdvectiveFluxBoundary_hu =\n        args.m_iarray[\"isAdvectiveFluxBoundary_hu\"];\n    xt::pyarray<int> &isAdvectiveFluxBoundary_hv =\n        args.m_iarray[\"isAdvectiveFluxBoundary_hv\"];\n    xt::pyarray<int> &isDiffusiveFluxBoundary_hu =\n        args.m_iarray[\"isDiffusiveFluxBoundary_hu\"];\n    xt::pyarray<int> &isDiffusiveFluxBoundary_hv =\n        args.m_iarray[\"isDiffusiveFluxBoundary_hv\"];\n    xt::pyarray<double> &ebqe_bc_h_ext = args.m_darray[\"ebqe_bc_h_ext\"];\n    xt::pyarray<double> &ebqe_bc_flux_mass_ext =\n        args.m_darray[\"ebqe_bc_flux_mass_ext\"];\n    xt::pyarray<double> &ebqe_bc_flux_mom_hu_adv_ext =\n        args.m_darray[\"ebqe_bc_flux_mom_hu_adv_ext\"];\n    xt::pyarray<double> &ebqe_bc_flux_mom_hv_adv_ext =\n        args.m_darray[\"ebqe_bc_flux_mom_hv_adv_ext\"];\n    xt::pyarray<double> &ebqe_bc_hu_ext = args.m_darray[\"ebqe_bc_hu_ext\"];\n    xt::pyarray<double> &ebqe_bc_flux_hu_diff_ext =\n        args.m_darray[\"ebqe_bc_flux_hu_diff_ext\"];\n    xt::pyarray<double> &ebqe_penalty_ext = args.m_darray[\"ebqe_penalty_ext\"];\n    xt::pyarray<double> &ebqe_bc_hv_ext = args.m_darray[\"ebqe_bc_hv_ext\"];\n    xt::pyarray<double> &ebqe_bc_flux_hv_diff_ext =\n        args.m_darray[\"ebqe_bc_flux_hv_diff_ext\"];\n    xt::pyarray<int> &csrColumnOffsets_eb_h_h =\n        args.m_iarray[\"csrColumnOffsets_eb_h_h\"];\n    xt::pyarray<int> &csrColumnOffsets_eb_h_hu =\n        args.m_iarray[\"csrColumnOffsets_eb_h_hu\"];\n    xt::pyarray<int> &csrColumnOffsets_eb_h_hv =\n        args.m_iarray[\"csrColumnOffsets_eb_h_hv\"];\n    xt::pyarray<int> &csrColumnOffsets_eb_hu_h =\n        args.m_iarray[\"csrColumnOffsets_eb_hu_h\"];\n    xt::pyarray<int> &csrColumnOffsets_eb_hu_hu =\n        args.m_iarray[\"csrColumnOffsets_eb_hu_hu\"];\n    xt::pyarray<int> &csrColumnOffsets_eb_hu_hv =\n        args.m_iarray[\"csrColumnOffsets_eb_hu_hv\"];\n    xt::pyarray<int> &csrColumnOffsets_eb_hv_h =\n        args.m_iarray[\"csrColumnOffsets_eb_hv_h\"];\n    xt::pyarray<int> &csrColumnOffsets_eb_hv_hu =\n        args.m_iarray[\"csrColumnOffsets_eb_hv_hu\"];\n    xt::pyarray<int> &csrColumnOffsets_eb_hv_hv =\n        args.m_iarray[\"csrColumnOffsets_eb_hv_hv\"];\n    double dt = args.m_dscalar[\"dt\"];\n    //\n    // loop over elements to compute volume integrals and load them into the\n    // element Jacobians and global Jacobian\n    //\n    for (int eN = 0; eN < nElements_global; eN++) {\n      register double elementJacobian_h_h[nDOF_test_element]\n                                         [nDOF_trial_element],\n          elementJacobian_hu_hu[nDOF_test_element][nDOF_trial_element],\n          elementJacobian_hv_hv[nDOF_test_element][nDOF_trial_element],\n          elementJacobian_heta_heta[nDOF_test_element][nDOF_trial_element],\n          elementJacobian_hw_hw[nDOF_test_element][nDOF_trial_element];\n      for (int i = 0; i < nDOF_test_element; i++)\n        for (int j = 0; j < nDOF_trial_element; j++) {\n          elementJacobian_h_h[i][j] = 0.0;\n          elementJacobian_hu_hu[i][j] = 0.0;\n          elementJacobian_hv_hv[i][j] = 0.0;\n          elementJacobian_heta_heta[i][j] = 0.0;\n          elementJacobian_heta_heta[i][j] = 0.0;\n        }\n      for (int k = 0; k < nQuadraturePoints_element; k++) {\n        int eN_k = eN * nQuadraturePoints_element +\n                   k, // index to a scalar at a quadrature point\n            eN_k_nSpace = eN_k * nSpace,\n            eN_nDOF_trial_element =\n                eN * nDOF_trial_element; // index to a vector at a\n                                         // quadrature point\n\n        // declare local storage\n        register double jac[nSpace * nSpace], jacDet, jacInv[nSpace * nSpace],\n            dV, h_test_dV[nDOF_test_element], vel_test_dV[nDOF_test_element], x,\n            y, xt, yt;\n        // get jacobian, etc for mapping reference element\n        ck.calculateMapping_element(\n            eN, k, mesh_dof.data(), mesh_l2g.data(), mesh_trial_ref.data(),\n            mesh_grad_trial_ref.data(), jac, jacDet, jacInv, x, y);\n        // get the physical integration weight\n        dV = fabs(jacDet) * dV_ref[k];\n        // precalculate test function products with integration weights\n        for (int j = 0; j < nDOF_trial_element; j++) {\n          h_test_dV[j] = h_test_ref[k * nDOF_trial_element + j] * dV;\n          vel_test_dV[j] = vel_test_ref[k * nDOF_trial_element + j] * dV;\n        }\n\n        for (int i = 0; i < nDOF_test_element; i++) {\n          register int i_nSpace = i * nSpace;\n          for (int j = 0; j < nDOF_trial_element; j++) {\n            register int j_nSpace = j * nSpace;\n            elementJacobian_h_h[i][j] += (i == j ? 1.0 : 0.0) * h_test_dV[i];\n            elementJacobian_hu_hu[i][j] +=\n                (i == j ? 1.0 : 0.0) * vel_test_dV[i];\n            elementJacobian_hv_hv[i][j] +=\n                (i == j ? 1.0 : 0.0) * vel_test_dV[i];\n            elementJacobian_heta_heta[i][j] +=\n                (i == j ? 1.0 : 0.0) * vel_test_dV[i];\n            elementJacobian_hw_hw[i][j] +=\n                (i == j ? 1.0 : 0.0) * vel_test_dV[i];\n          } // j\n        }   // i\n      }     // k\n      //\n      // load into element Jacobian into global Jacobian\n      //\n      for (int i = 0; i < nDOF_test_element; i++) {\n        register int eN_i = eN * nDOF_test_element + i;\n        for (int j = 0; j < nDOF_trial_element; j++) {\n          register int eN_i_j = eN_i * nDOF_trial_element + j;\n          globalJacobian[csrRowIndeces_h_h[eN_i] +\n                         csrColumnOffsets_h_h[eN_i_j]] +=\n              elementJacobian_h_h[i][j];\n          globalJacobian[csrRowIndeces_hu_hu[eN_i] +\n                         csrColumnOffsets_hu_hu[eN_i_j]] +=\n              elementJacobian_hu_hu[i][j];\n          globalJacobian[csrRowIndeces_hv_hv[eN_i] +\n                         csrColumnOffsets_hv_hv[eN_i_j]] +=\n              elementJacobian_hv_hv[i][j];\n          globalJacobian[csrRowIndeces_heta_heta[eN_i] +\n                         csrColumnOffsets_heta_heta[eN_i_j]] +=\n              elementJacobian_heta_heta[i][j];\n          globalJacobian[csrRowIndeces_hw_hw[eN_i] +\n                         csrColumnOffsets_hw_hw[eN_i_j]] +=\n              elementJacobian_hw_hw[i][j];\n        } // j\n      }   // i\n    }     // elements\n  }\n}; // GN_SW2DCV\n\ninline GN_SW2DCV_base *\nnewGN_SW2DCV(int nSpaceIn, int nQuadraturePoints_elementIn,\n             int nDOF_mesh_trial_elementIn, int nDOF_trial_elementIn,\n             int nDOF_test_elementIn, int nQuadraturePoints_elementBoundaryIn,\n             int CompKernelFlag) {\n  return proteus::chooseAndAllocateDiscretization2D<GN_SW2DCV_base, GN_SW2DCV,\n                                                    CompKernel>(\n      nSpaceIn, nQuadraturePoints_elementIn, nDOF_mesh_trial_elementIn,\n      nDOF_trial_elementIn, nDOF_test_elementIn,\n      nQuadraturePoints_elementBoundaryIn, CompKernelFlag);\n}\n} // namespace proteus\n\n#endif\n\n", "comment_ratio": 0.12751407884151247}
{"lang": "c", "code": "/*********************************************************************\n*                     SEGGER Microcontroller GmbH                    *\n*                        The Embedded Experts                        *\n**********************************************************************\n*                                                                    *\n*       (c) 1995 - 2019 SEGGER Microcontroller GmbH                  *\n*                                                                    *\n*       Internet: segger.com  Support: support_embos@segger.com      *\n*                                                                    *\n**********************************************************************\n*                                                                    *\n*       embOS * Real time operating system for microcontrollers      *\n*                                                                    *\n*       Please note:                                                 *\n*                                                                    *\n*       Knowledge of this file may under no circumstances            *\n*       be used to write a similar product or a real-time            *\n*       operating system for in-house use.                           *\n*                                                                    *\n*       Thank you for your fairness !                                *\n*                                                                    *\n**********************************************************************\n*                                                                    *\n*       OS version: 5.06.1                                           *\n*                                                                    *\n**********************************************************************\n\n-------------------------- END-OF-HEADER -----------------------------\nPurpose : Initializes and handles the hardware for embOS\n*/\n\n#include <Windows.h>\n#include <stdio.h>\n#include <time.h>\n#include <BSP.h>\n#include <OSAL.h>\n#include <OSAL_Clock.h>\n\n/*********************************************************************\n*\n*       Defines\n*\n**********************************************************************\n*/\n\n#define TICK_IN_MS 1 /* 1 millisecond */ \n\n/*********************************************************************\n * GLOBAL VARIABLES\n */\n\n/*********************************************************************\n*\n*       STATIC VARIABLES\n*\n**********************************************************************\n*/\nstatic  LARGE_INTEGER TampStart;\nstatic  LARGE_INTEGER TampFreq;\n\n/*********************************************************************\n*\n*       Local functions\n*\n**********************************************************************\n*/\n\n/*********************************************************************\n*\n*       _ISRTickThread()\n*/\nstatic void _ISRTickThread(void) {\n  int tDiffMax;\n  int tDiff;\n  int t;\n  int tLast;\n\n  //\n  // If between two iterations more than tDiffMax ticks have elapsed,\n  // then tDiff will be set to tDiffMax. This might occure when one\n  // debugs and single steps through the application. This value\n  // can be changed as desired.\n  //\n  tDiffMax = 1;\n  //\n  // Switch to higher timer resolution\n  //\n  timeBeginPeriod(1);\n  tLast = timeGetTime();\n  while (1) {\n    t     = timeGetTime();\n    tDiff = t - tLast;\n    tLast = t;\n    //\n    // Limit the time to a certain amount of ms so that single\n    // stepping does not mess things up to badly\n    //\n    if (tDiff > tDiffMax) {\n      tDiff = tDiffMax;\n    }\n    //\n    // Execute the actual ISR one time for every ms\n    //\n\n    while (tDiff-- > 0) {\n      osalAdjustTimer(TICK_IN_MS);\n    }\n\n    //\n    // SleepEx()'s second parameter *MUST* be TRUE when used with QueueUserAPC. Otherwise 'Nonpaged Pool'\n    // (cf. ProcessExplorer) is congested *COMPLETELY* since we are NOT in an alertable state and thus the\n    // queue will NEVER be flushed.\n    //\n    SleepEx(INFINITE, TRUE);\n  }\n}\n\n/*********************************************************************\n*\n*       _voidAPC()\n*\n*  Function description\n*    Dummy APC function. Is required because we (ab)use the\n*    WIN32 QueueUserAPC() API function to wake up a thread\n*/\nstatic void APIENTRY _voidAPC(DWORD Dummy) {\n  OS_USEPARA(Dummy);\n}\n\n/*********************************************************************\n*\n*       _CbSignalTickProc()\n*\n*  Function description\n*    Timer callback function which periodically queues an APC in order\n*    to resume the ISR tick thread.\n*/\nstatic void CALLBACK _CbSignalTickProc(UINT uID, UINT uMsg, DWORD dwUser, DWORD dw1, DWORD dw2) {\n  OS_USEPARA(uID);\n  OS_USEPARA(uMsg);\n  OS_USEPARA(dw1);\n  OS_USEPARA(dw2);\n  QueueUserAPC(_voidAPC, (void*)dwUser, 0);\n}\n\n/*********************************************************************\n*\n*       TimesTampInit()\n*\n*/\nstatic void TimesTampInit(void)\n{\n    // get count Frequency\n    QueryPerformanceFrequency(&TampFreq);\n\n    // get initial time\n    QueryPerformanceCounter(&TampStart);\n}\n\n/*********************************************************************\n*\n*       Global functions\n*\n**********************************************************************\n*/\n\n/*********************************************************************\n*\n*       OS_InitHW()\n*\n*  Function description\n*    Initialize the hardware required for embOS to run.\n*/\nvoid OS_InitHW(void) {\n  HANDLE hISRThread;\n\n  TimesTampInit();\n\n  SetThreadPriorityBoost(GetCurrentThread(), TRUE);  // Disable Windows priority boosting\n  //\n  // Start tick ISR\n  //\n  hISRThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) _ISRTickThread, NULL, 0, NULL);\n\n  timeSetEvent(1,0, _CbSignalTickProc, (int)hISRThread, (TIME_PERIODIC | TIME_CALLBACK_FUNCTION));\n}\n\n/*********************************************************************\n*\n*       macMcuPrecisionCount()\n* \n*/\nOS_U32 macMcuPrecisionCount(void)\n{\n    LARGE_INTEGER count_end;\n\n    // get end count\n    QueryPerformanceCounter(&count_end);\n\n    // get time (1000 000 us / 320us ) = 3125\n    return (OS_U32)((count_end.QuadPart - TampStart.QuadPart) / (TampFreq.QuadPart / 3125.0));\n}\n\n/*********************************************************************\n*\n*       GetSecondTamp()\n* \n*/\nOS_U32 GetSecondTamp(void)\n{\n    LARGE_INTEGER count_end;\n\n    // get end count\n    QueryPerformanceCounter(&count_end);\n\n    // get time\n    return (OS_U32)((count_end.QuadPart - TampStart.QuadPart) / (TampFreq.QuadPart / 1.0));\n}\n\n/*********************************************************************\n*\n*       GetMillisecondTamp()\n* \n*/\nOS_U32 GetMillisecondTamp(void)\n{\n    LARGE_INTEGER count_end;\n\n    // get end count\n    QueryPerformanceCounter(&count_end);\n\n    // get time\n    return (OS_U32)((count_end.QuadPart - TampStart.QuadPart) / (TampFreq.QuadPart / 1000.0));\n}\n\n/*********************************************************************\n*\n*       GetMicrosecondTamp()\n* \n*/\nOS_U32 GetMicrosecondTamp(void)\n{\n    LARGE_INTEGER count_end;\n\n    // get end count\n    QueryPerformanceCounter(&count_end);\n\n    // get time\n    return (OS_U32)((count_end.QuadPart - TampStart.QuadPart) / (TampFreq.QuadPart / 1000000.0));\n}\n\n/*************************** End of file ****************************/\n\n", "comment_ratio": 0.1383399209486166}
{"lang": "c", "code": "#ifndef flatzinc_h\n#define flatzinc_h\n\n#include <map>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <ostream>\n#include <sstream>\n#include <algorithm>\n\n#include <chuffed/support/vec.h>\n#include <chuffed/core/propagator.h>\n#include <chuffed/flatzinc/ast.h>\n\nextern std::map<IntVar*, std::string> intVarString;\nextern std::map<BoolView, std::string> boolVarString;\n\n// Controls whether expressions like bool_sum_eq([x[i] = j | i in 1..n], 1)\n// access the underlying literals x[i] = j or new ones via int_eq_reif(...)\n// NOTE:  Implemention isn't 100% ideal at this stage so kept it conditional\n#define EXPOSE_INT_LITS 0\n\nnamespace FlatZinc {\n\n\t/// Alias for a variable specification\n\tclass Alias {\n\tpublic:\n\t\tconst int v;\n\t\tAlias(int v0) : v(v0) {}\n\t};\n\n\t/// Optional value\n\ttemplate<class Val>\n\tstruct Option {\n\tprivate:\n\t\tbool _some;\n\t\tVal _v;\n\tpublic:\n\t\tbool operator()(void) const { return _some; }\n\t\tconst Val& some(void) const { return _v; }\n\t\tstatic Option<Val> none(void) {\n\t\t\tOption<Val> o;\n\t\t\to._some = false;\n\t\t\tnew (&o._v) Val();\n\t\t\treturn o;\n\t\t}\n\t\tstatic Option<Val> some(const Val& v) {\n\t\t\tOption<Val> o;\n\t\t\to._some = true;\n\t\t\to._v = v;\n\t\t\treturn o;\n\t\t}\n\t};\n\n\t/// Base class for variable specifications\n\tclass VarSpec {\n\tpublic:\n                /// Whether the variable has an \"output\" annotation\n                bool output;\n\t\t/// Whether the variable was introduced in the mzn2fzn translation\n\t\tbool introduced;\n\t\t/// Whether the variable *looks* introduced by the mzn2fzn translation\n\t\tbool looks_introduced;\n\t\t/// Destructor\n\t\tvirtual ~VarSpec(void) {}\n\t\t/// Variable index\n\t\tint i;\n\t\t/// Whether the variable aliases another variable\n\t\tbool alias;\n\t\t/// Whether the variable is assigned\n\t\tbool assigned;\n\t\t/// Constructor\n                VarSpec(bool output0, bool introduced0, bool looks0) : output(output0), introduced(introduced0), looks_introduced(looks0) {}\n                void set_looks_introduced(bool b) {\n                    looks_introduced = b;\n                }\n\t};\n\n\t/// Specification for integer variables\n\tclass IntVarSpec : public VarSpec {\n\tpublic:\n\t\tOption<AST::SetLit* > domain;\n                IntVarSpec(const Option<AST::SetLit* >& d, bool output, bool introduced, bool looks = false)\n                      : VarSpec(output, introduced, looks) {\n\t\t\talias = false;\n\t\t\tassigned = false;\n\t\t\tdomain = d;\n\t\t}\n\t\tIntVarSpec(int i0, bool output, bool introduced, bool looks = false) : VarSpec(output, introduced, looks) {\n\t\t\talias = false; assigned = true; i = i0;\n\t\t}\n\t\tIntVarSpec(const Alias& eq, bool output, bool introduced, bool looks = false) : VarSpec(output, introduced, looks) {\n\t\t\talias = true; i = eq.v;\n\t\t}\n\t\t~IntVarSpec(void) {\n\t\t\tif (!alias && !assigned && domain())\n\t\t\t\tdelete domain.some();\n\t\t}\n\t};\n\n\t/// Specification for Boolean variables\n\tclass BoolVarSpec : public VarSpec {\n\tpublic:\n\t\tOption<AST::SetLit* > domain;\n#if EXPOSE_INT_LITS\n\t\t// whether it aliases an int literal such as [x <= 5]: (-1=no)\n\t\tint alias_var;\n\t\tIntRelType alias_irt;\n\t\tint alias_val;\n#endif\n\t\tBoolVarSpec(Option<AST::SetLit* >& d, bool output, bool introduced, bool looks = false)\n\t\t: VarSpec(output, introduced, looks) {\n\t\t\talias = false; assigned = false; domain = d;\n#if EXPOSE_INT_LITS\n\t\t\talias_var = -1;\n#endif\n\t\t}\n\t\tBoolVarSpec(bool b, bool output, bool introduced, bool looks = false) : VarSpec(output, introduced, looks) {\n\t\t\talias = false; assigned = true; i = b;\n#if EXPOSE_INT_LITS\n\t\t\talias_var = -1;\n#endif\n\t\t}\n\t\tBoolVarSpec(const Alias& eq, bool output, bool introduced, bool looks = false) : VarSpec(output, introduced, looks) {\n\t\t\talias = true; i = eq.v;\n#if EXPOSE_INT_LITS\n\t\t\talias_var = -1;\n#endif\n\t\t}\n\t\t~BoolVarSpec(void) {\n\t\t\tif (!alias && !assigned && domain())\n\t\t\t\tdelete domain.some();\n\t\t}\n\t};\n\n\t  /// Specification for set variables\n  class SetVarSpec : public VarSpec {\n  public:\n    Option<AST::SetLit*> upperBound;\n    SetVarSpec(bool output, bool introduced, bool looks = false) : VarSpec(output, introduced, looks) {\n      alias = false; assigned = false;\n      upperBound = Option<AST::SetLit* >::none();\n    }\n    SetVarSpec(const Option<AST::SetLit* >& v, bool output, bool introduced, bool looks = false)\n    : VarSpec(output, introduced, looks) {\n      alias = false; assigned = false; upperBound = v;\n    }\n    SetVarSpec(AST::SetLit* v, bool output, bool introduced, bool looks = false) : VarSpec(output, introduced, looks) {\n      alias = false; assigned = true;\n      upperBound = Option<AST::SetLit*>::some(v);\n    }\n    SetVarSpec(const Alias& eq, bool output, bool introduced, bool looks = false) : VarSpec(output, introduced, looks) {\n      alias = true; i = eq.v;\n    }\n    ~SetVarSpec(void) {\n      if (!alias && upperBound())\n        delete upperBound.some();\n    }\n  };\n\n\t\n  /// Specification for floating point variables\n  class FloatVarSpec : public VarSpec {\n  public:\n    Option<std::vector<double>* > domain;\n    FloatVarSpec(Option<std::vector<double>* >& d, bool output, bool introduced, bool looks = false)\n    : VarSpec(output, introduced, looks) {\n      alias = false; assigned = false; domain = d;\n    }\n    FloatVarSpec(bool b, bool output, bool introduced, bool looks = false) : VarSpec(output, introduced, looks) {\n      alias = false; assigned = true; i = b;\n    }\n    FloatVarSpec(const Alias& eq, bool output, bool introduced, bool looks = false) : VarSpec(output, introduced, looks) {\n      alias = true; i = eq.v;\n    }\n    ~FloatVarSpec(void) {\n      if (!alias && !assigned && domain())\n        delete domain.some();\n    }\n  };\n\n\n\t/// Abstract representation of a constraint\n\tclass ConExpr {\n\tpublic:\n\t\t/// Identifier for the constraint\n\t\tstd::string id;\n\t\t/// Constraint arguments\n\t\tAST::Array* args;\n\t\t/// Constructor\n\t\tConExpr(const std::string& id0, AST::Array* args0) :\n\t\t\tid(id0), args(args0) {}\n\t\t/// Return argument \\a i\n\t\tAST::Node* operator[](int i) const { return args->a[i]; }\n\t\t/// Destructor\n\t\t~ConExpr(void) { delete args; }\n\t};\n\n\t/// Map from constraint identifier to constraint posting functions\n\tclass Registry {\n\tpublic:\n\t\t/// Type of constraint posting function\n\t\ttypedef void (*poster) (const ConExpr&,\tAST::Node*);\n\t\t/// Add posting function \\a p with identifier \\a id\n\t\tvoid add(const std::string& id, poster p);\n\t\t/// Post constraint specified by \\a ce\n\t\tvoid post(const ConExpr& ce, AST::Node* ann);\n\n\tprivate:\n\t\t/// The actual registry\n\t\tstd::map<std::string,poster> r;\n\t};\n\n\t/// Return global registry object\n\tRegistry& registry(void);\n\n\t/// Symbol table mapping identifiers (strings) to values\n\ttemplate<class Val>\n\tclass SymbolTable {\n\tprivate:\n\t\tstd::map<std::string,Val> m;\n\tpublic:\n\t\t/// Insert \\a val with \\a key\n\t\tvoid put(const std::string& key, const Val& val) { m[key] = val; }\n\t\t/// Return whether \\a key exists, and set \\a val if it does exist\n\t\tbool get(const std::string& key, Val& val) const {\n\t\t\ttypename std::map<std::string,Val>::const_iterator i = m.find(key);\n\t\t\tif (i == m.end())\treturn false;\n\t\t\tval = i->second;\n\t\t\treturn true;\n\t\t}\n\t};\n\n\tclass FlatZincSpace : public Problem {\n\tpublic:\n    /// Number of integer variables\n    int intVarCount;\n    /// Number of Boolean variables\n    int boolVarCount;\n\n    /// The integer variables\n    vec<IntVar*> iv;\n    /// Indicates whether an integer variable is introduced by mzn2fzn\n    std::vector<bool> iv_introduced;\n    /// The Boolean variables\n    vec<BoolView> bv;\n    /// Indicates whether a Boolean variable is introduced by mzn2fzn\n    std::vector<bool> bv_introduced;\n\n\t\tAST::Array* output;\n\n    /// Construct problem with given number of variables\n    FlatZincSpace(int intVars, int boolVars, int setVars);\n\n\t\t/// Parse the solve annotations and create corresponding branchings\n\t\tvoid parseSolveAnn(AST::Array* ann);\n\t\t/// Create final branching that fixes all variables\n\t\tvoid fixAllSearch();\n\n\t\t/// Create new integer variable from specification\n\t\tvoid newIntVar(IntVarSpec* vs);\n\t\t/// Create new Boolean variable from specification\n\t\tvoid newBoolVar(BoolVarSpec* vs);\n    /// Create new set variable from specification\n    void newSetVar(SetVarSpec* vs);\n\n\t\t/// Post a constraint specified by \\a ce\n\t\tvoid postConstraint(const ConExpr& ce, AST::Node* annotation);\n\n\t\t/// Post the solve item\n\t\tvoid solve(AST::Array* annotation);\n\t\t/// Post that integer variable \\a var should be minimized\n\t\tvoid minimize(int var, AST::Array* annotation);\n\t\t/// Post that integer variable \\a var should be maximized\n\t\tvoid maximize(int var, AST::Array* annotation);\n\n\t\t/// Define output variables\n\t\tvoid setOutputElem(AST::Node* ai) const;\n\t\tvoid setOutput();\n\n\t\tvoid printElem(AST::Node* ai, std::ostream& out = std::cout) const;\n    void print(std::ostream& out);\n\t\tvoid printStream(std::ostream& out);\n                \n                void printDomains(std::ostream& out = std::cout);\n                std::string getDomainsString(void);\n\n\t};\n\n\textern FlatZincSpace *s;\n\n\ttypedef std::pair<std::string,Option<std::vector<int>* > > intvartype;\n\ttypedef std::pair<std::string, VarSpec*> varspec;\n\n\n\t/// State of the FlatZinc parser\n\tclass ParserState {\n\tpublic:\n\t\tParserState(const std::string& b, std::ostream& err0)\n\t\t: buf(b.c_str()), pos(0), length(b.size()), fg(NULL),\n\t\t\thadError(false), err(err0) {}\n\n\t\tParserState(char* buf0, int length0, std::ostream& err0)\n\t\t: buf(buf0), pos(0), length(length0), fg(NULL),\n\t\t\thadError(false), err(err0) {}\n\n\t\tvoid* yyscanner;\n\t\tconst char* buf;\n\t\tunsigned int pos, length;\n\t\tFlatZinc::FlatZincSpace* fg;\n\t\tstd::vector<std::pair<std::string,AST::Node*> > _output;\n\n    SymbolTable<int> intvarTable;\n    SymbolTable<int> boolvarTable;\n    SymbolTable<int> floatvarTable;\n    SymbolTable<int> setvarTable;\n    SymbolTable<std::vector<int> > intvararrays;\n    SymbolTable<std::vector<int> > boolvararrays;\n    SymbolTable<std::vector<int> > floatvararrays;\n    SymbolTable<std::vector<int> > setvararrays;\n    SymbolTable<std::vector<int> > intvalarrays;\n    SymbolTable<std::vector<int> > boolvalarrays;\n    SymbolTable<int> intvals;\n    SymbolTable<bool> boolvals;\n    SymbolTable<AST::SetLit> setvals;\n    SymbolTable<std::vector<AST::SetLit> > setvalarrays;\n\n    std::vector<varspec> intvars;\n    std::vector<varspec> boolvars;\n    std::vector<varspec> setvars;\n\n\t\tstd::vector<ConExpr*> domainConstraints;\n#if EXPOSE_INT_LITS\n\t\t// for some reason the above list is posted in reverse order,\n\t\t// don't want to disturb things so add the following (forward):\n\t\tstd::vector<std::pair<ConExpr*, AST::Node*> > domainConstraints2;\n#endif\n\n\n\t\tbool hadError;\n\t\tstd::ostream& err;\n\n\t\tint fillBuffer(char* lexBuf, unsigned int lexBufSize) {\n\t\t\tif (pos >= length) return 0;\n\t\t\tint num = std::min(length - pos, lexBufSize);\n\t\t\tmemcpy(lexBuf,buf+pos,num);\n\t\t\tpos += num;\n\t\t\treturn num;    \n\t\t}\n\n\t\tvoid output(std::string x, AST::Node* n) {\n\t\t\t_output.push_back(std::pair<std::string,AST::Node*>(x,n));\n\t\t}\n\n\t\tAST::Array* getOutput(void) {\n\t\t\tstd::sort(_output.begin(), _output.end());\n\t\t\tAST::Array* a = new AST::Array();\n\t\t\tfor (unsigned int i=0; i<_output.size(); i++) {\n\t\t\t\ta->a.push_back(new AST::String(_output[i].first+\" = \"));\n\t\t\t\tif (_output[i].second->isArray()) {\n\t\t\t\t\tAST::Array* oa = _output[i].second->getArray();\n\t\t\t\t\tfor (unsigned int j=0; j<oa->a.size(); j++) {\n\t\t\t\t\t\ta->a.push_back(oa->a[j]);\n\t\t\t\t\t\toa->a[j] = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tdelete _output[i].second;\n\t\t\t\t} else {\n\t\t\t\t\ta->a.push_back(_output[i].second);\n\t\t\t\t}\n\t\t\t\ta->a.push_back(new AST::String(\";\\n\"));\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\n\t};\n\n\t/// Exception class for FlatZinc errors\n\tclass Error {\n\tprivate:\n\t\tconst std::string msg;\n\tpublic:\n\t\tError(const std::string& where, const std::string& what)\n\t\t: msg(where+\": \"+what) {}\n\t\tconst std::string& toString(void) const { return msg; }\n\t};\n\n\tvoid solve(const std::string& filename, std::ostream& err = std::cerr);\n\tvoid solve(std::istream& is, std::ostream& err = std::cerr);\n\n}\n\n#endif\n\n", "comment_ratio": 0.13221153846153846}
{"lang": "c", "code": "#include <string.h>\n#include \"qapi_ble.h\"\n#include \"qsCommon.h\"\n#include \"qsPack.h\"\n#include \"qapi_ble_gaps_common.h\"\n#include \"qapi_ble_btapityp_common.h\"\n#include \"qapi_ble_bttypes_common.h\"\n#include \"qapi_ble_gatt_common.h\"\n#include \"qapi_ble_gapstypes_common.h\"\n\nuint32_t CalcPackedSize_qapi_BLE_GAP_Preferred_Connection_Parameters_t(qapi_BLE_GAP_Preferred_Connection_Parameters_t *Structure)\n{\n    uint32_t qsResult;\n\n    if(Structure == NULL)\n    {\n        qsResult = 0;\n    }\n    else\n    {\n        qsResult = QAPI_BLE_GAP_PREFERRED_CONNECTION_PARAMETERS_T_MIN_PACKED_SIZE;\n    }\n\n    return(qsResult);\n}\n\nSerStatus_t PackedWrite_qapi_BLE_GAP_Preferred_Connection_Parameters_t(PackedBuffer_t *Buffer, qapi_BLE_GAP_Preferred_Connection_Parameters_t *Structure)\n{\n    SerStatus_t qsResult = ssSuccess;\n\n    if(Buffer->Remaining >= CalcPackedSize_qapi_BLE_GAP_Preferred_Connection_Parameters_t(Structure))\n    {\n        if(Structure != NULL)\n        {\n         if(qsResult == ssSuccess)\n             qsResult = PackedWrite_16(Buffer, (uint16_t *)&Structure->Minimum_Connection_Interval);\n\n         if(qsResult == ssSuccess)\n             qsResult = PackedWrite_16(Buffer, (uint16_t *)&Structure->Maximum_Connection_Interval);\n\n         if(qsResult == ssSuccess)\n             qsResult = PackedWrite_16(Buffer, (uint16_t *)&Structure->Slave_Latency);\n\n         if(qsResult == ssSuccess)\n             qsResult = PackedWrite_16(Buffer, (uint16_t *)&Structure->Supervision_Timeout);\n\n        }\n    }\n    else\n    {\n        qsResult = ssInvalidLength;\n    }\n\n    return(qsResult);\n}\n\nSerStatus_t PackedRead_qapi_BLE_GAP_Preferred_Connection_Parameters_t(PackedBuffer_t *Buffer, BufferListEntry_t **BufferList, qapi_BLE_GAP_Preferred_Connection_Parameters_t *Structure)\n{\n    SerStatus_t qsResult = ssSuccess;\n    Boolean_t   qsPointerValid = FALSE;\n\n    UNUSED(qsPointerValid);\n\n    if(Buffer->Remaining >= QAPI_BLE_GAP_PREFERRED_CONNECTION_PARAMETERS_T_MIN_PACKED_SIZE)\n    {\n        if(qsResult == ssSuccess)\n            qsResult = PackedRead_16(Buffer, BufferList, (uint16_t *)&Structure->Minimum_Connection_Interval);\n\n        if(qsResult == ssSuccess)\n            qsResult = PackedRead_16(Buffer, BufferList, (uint16_t *)&Structure->Maximum_Connection_Interval);\n\n        if(qsResult == ssSuccess)\n            qsResult = PackedRead_16(Buffer, BufferList, (uint16_t *)&Structure->Slave_Latency);\n\n        if(qsResult == ssSuccess)\n            qsResult = PackedRead_16(Buffer, BufferList, (uint16_t *)&Structure->Supervision_Timeout);\n\n    }\n    else\n    {\n        qsResult = ssInvalidLength;\n    }\n\n    return(qsResult);\n}\n\n", "comment_ratio": 0.1574074074074074}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n\n#import \"KPageContainerView.h\"\n\n@protocol KPageViewControllerDelegate <NSObject>\n\n@optional\n- (void)pageControllerDidSelectedAt:(NSInteger)index;\n\n@end\n\n@protocol KPageViewControllerDataSource <NSObject>\n\n@optional\n//header\n- (UIView *)pageViewControllerHeader;\n- (CGFloat)pageViewControllerHeaderHeight;\n\n//segment\n- (KSegmentControl *)pageSegmentControl;\n- (CGFloat)pageSegmentControlHeight;\n\n//page\n- (CGFloat)pageControllerTop;\n- (NSArray<KPageBaseView *> *)pageViewControllers;\n- (CGFloat)pageViewControllerHeight;\n@end\n\n@interface KPageViewController : UIViewController <KPageViewControllerDelegate, KPageViewControllerDataSource>\n\n@property (nonatomic, weak) id<KPageViewControllerDelegate> delegate;\n@property (nonatomic, weak) id<KPageViewControllerDataSource> dataSource;\n\n- (void)reloadData;\n@end\n\n", "comment_ratio": 0.22727272727272727}
{"lang": "c", "code": "#include \"control_task.h\"\r\n\r\n// Standard includes.\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\n\r\n#include \"osi.h\"\r\n#include \"string.h\"\r\n// Driverlib includes\r\n#include \"hw_memmap.h\"\r\n#include \"hw_common_reg.h\"\r\n#include \"hw_types.h\"\r\n#include \"hw_ints.h\"\r\n#include \"interrupt.h\"\r\n#include \"rom.h\"\r\n#include \"rom_map.h\"\r\n#include \"uart.h\"\r\n#include \"prcm.h\"\r\n#include \"utils.h\"\r\n#include \"pin.h\"\r\n\r\n// Common interface includes\r\n#include \"uart_if.h\"\r\n#include \"UARTnew.h\"\r\n#include \"i2cnew.h\"\r\n#include \"i2c_if.h\"\r\n#include \"timer_control.h\"\r\n#include \"gpio.h\"\r\n#include \"gpio_if.h\"\r\n#include \"command.h\"\r\n\r\n\r\nCONTROL_HANDLE_t controlHandle;\r\n/***************************************************\r\n * setter of the controlHandle\r\n * ************************************************/\r\nvoid setControlHandle(CONTROL_HANDLE_t taskHandle){\r\n\tcontrolHandle = taskHandle;\r\n}\r\n\r\n/***************************************************\r\n * control task\r\n * ************************************************/\r\nvoid control_task(){\r\n\tDATA_HANDLE_t controlDataHandle;\r\n\r\n\r\n//initialize array and check result\r\n\tuint8_t tempbuff[] = \"Control task is processing command and data for itself\\n\";\r\n\r\n\tSendControlData_S_initial();\r\n\r\nwhile(1){\r\n\r\n\t//DE-Queue\r\n\txQueueReceive( controlHandle->ControlTaskQ, &controlDataHandle, portMAX_DELAY );\r\n\t//command and data must be those for control task\r\n\r\n\t\t//processing command\r\n\t\t//here for test using UARTwrite to show program passed here\r\n\t\t//********************************test**************\r\n\r\n\t\t//using uart_task to print it\r\n\t\t//allocate new memory to hold new dataout\r\n\r\n\tSendControlData(UARTPRINT, sizeof(tempbuff), tempbuff);\r\n\r\n\tfree(controlDataHandle->dataBuffer);\r\n\tfree(controlDataHandle);\r\n\r\n}\r\n\r\n}\r\n\r\n/**************************************\r\n *Transfer data generated by this application task to\r\n * control task called by other application tasks or itself\r\n *\r\n * @para controlCommand\r\n * the new 16 bits command\r\n * @para dataSize\r\n * the new 16 bits data size\r\n * @para dataBuffer\r\n * the pointer to the new data buffer of 8 bits data unit\r\n *\r\n * precondition:\r\n * dataBuffer is mallocated space with dataSize\r\n * system has enough memory space to hold data to be sent\r\n *\r\n * postcondition:\r\n * memory allocated, it will be freed by target task\r\n ***************************************/\r\nint32_t SendControlData(uint16_t controlCommand, uint16_t dataSize, uint8_t* dataBuffer){\r\n\txSemaphoreTake( controlHandle->SendControlData_Semaphore, portMAX_DELAY ); //lock function\r\n\r\n\tcontrolHandle->task_ID = (controlCommand >> 8);\r\n\r\n\tif(controlHandle->task_ID == CONTROLTASKID){\r\n\r\n\t\t  //allocate memory fore enQueue\r\n\t\t  DATA_HANDLE_t controlDataHandle = (DATA_HANDLE_t)malloc(sizeof(DATA_STATE_t));\r\n\t\t  //check memory allocation result\r\n\t\t  if(controlDataHandle == NULL){\r\n\t\t\t  return MEMORYALOCATIONFAILED;\r\n\t\t  }\r\n\r\n\t\t  controlDataHandle->controlCommand = controlCommand;\r\n\t\t  controlDataHandle->dataSize = dataSize;\r\n\t\t  controlDataHandle->dataBuffer = (uint8_t *)malloc(controlDataHandle->dataSize * sizeof(uint8_t));\r\n\t\t  //check memory allocation result\r\n\t\t  if(controlDataHandle->dataBuffer == NULL){\r\n\t\t\t  free(controlDataHandle);\r\n\t\t\t  return MEMORYALOCATIONFAILED;\r\n\t\t  }\r\n\r\n\t\t  memcpy(controlDataHandle->dataBuffer, dataBuffer, controlDataHandle->dataSize);\r\n\r\n\t\t\t//enQueue\r\n\t\t  osi_MsgQWrite(&controlHandle->ControlTaskQ, (void *) &controlDataHandle, 0); // 0 configure no waitting time\r\n\t\t\t// or this form:\r\n\t\t\t// xQueueSend( TASK1Q, pData, ( TickType_t ) 0 );\r\n\t\t  xSemaphoreGive( controlHandle->SendControlData_Semaphore );// unlock function, sequential lock for one task using at one moment\r\n\r\n\t\t  return SUCCESS;\r\n\t}else{\r\n\r\n\t\tfor(controlHandle->loopIndex = 0; controlHandle->loopIndex < TASKNUMBER; (controlHandle->loopIndex)++){\r\n\t\t//if TASKID encoded in input controlCommand meets the TASKID stored in\r\n\t\t//structure in the taskList\r\n\t\t//remember i and break the loop\r\n\t\t\tif(((uint8_t)(controlCommand >> 8)) == controlHandle->taskList[controlHandle->loopIndex].taskID){ //first part may have bugs\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t//call function stored in structure in taskList[i]\r\n\r\n\t\tSetCommandToTask(controlHandle->taskList[controlHandle->loopIndex].taskQ, controlCommand, dataSize, dataBuffer);\r\n\r\n\t\t//return\r\n\t\txSemaphoreGive( controlHandle->SendControlData_Semaphore );// unlock function, sequential lock for one task using at one moment\r\n\r\n\t\tif(controlHandle->loopIndex >= TASKNUMBER ){\r\n\t\t\treturn NOMATCH;\r\n\t\t}else{\r\n\t\t\treturn SUCCESS;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\r\n}\r\n\r\n/***************************************************\r\n * called by other tasks to register itself to the control list\r\n * @para taskID\r\n * other task's 16 bits ID\r\n * @para pfnSetCommandToTask\r\n * other task's SetCommandToTaskN function label\r\n * ************************************************/\r\nint32_t registerTaskToControl(uint8_t taskID, OsiMsgQ_t taskQ){\r\n\tcontrolHandle->taskList[controlHandle->listIndex].taskID = taskID;\r\n\tcontrolHandle->taskList[controlHandle->listIndex].taskQ = taskQ;\r\n\tcontrolHandle->listIndex = controlHandle->listIndex + 1;\r\n\tif(controlHandle->listIndex > TASKNUMBER){\r\n\t\treturn OUTOFLIST;\r\n\t}else{\r\n\t\treturn SUCCESS;\r\n\t}\r\n}\r\n/***************************************************\r\n * called by other tasks or itself to send data using queue\r\n * @para TaskQ\r\n * The Queue of that task\r\n * @para controlCommand\r\n * new command to send\r\n * @para dataSize\r\n * new dataSize to send\r\n * @para dataBuffer\r\n * new dataBuffer to send\r\n * @return\r\n * return error check value\r\n * ************************************************/\r\nint32_t SetCommandToTask(OsiMsgQ_t TaskQ, uint16_t controlCommand, uint16_t dataSize, uint8_t* dataBuffer){\r\n\r\n\r\n  //allocate memory fore enQueue\r\n\tDATA_HANDLE_t apptaskhandle = (DATA_HANDLE_t)malloc(sizeof(DATA_STATE_t));\r\n  //check memory allocation result\r\n  if(apptaskhandle == NULL){\r\n\t  return MEMORYALOCATIONFAILED;\r\n  }\r\n\r\n  apptaskhandle->controlCommand = controlCommand;\r\n  apptaskhandle->dataSize = dataSize;\r\n  apptaskhandle->dataBuffer = (uint8_t *)malloc(apptaskhandle->dataSize * sizeof(uint8_t));\r\n  //check memory allocation result\r\n  if(apptaskhandle->dataBuffer == NULL){\r\n\t  free(apptaskhandle);\r\n\t  return MEMORYALOCATIONFAILED;\r\n  }\r\n\r\n  memcpy(apptaskhandle->dataBuffer, dataBuffer, apptaskhandle->dataSize);\r\n\r\n\t//enQueue\r\n  osi_MsgQWrite(&TaskQ, (void *) &apptaskhandle, 0); // 0 configure no waitting time\r\n\t// or this form:\r\n\t// xQueueSend( TASK2Q, pData, ( TickType_t ) 0 );\r\n\r\n  return SUCCESS;\r\n}\r\n\r\n/***************************************************\r\n * create a protecting semaphore\r\n * the semaphore is used to protect the multi-entering\r\n * of SendControlData function area\r\n * ************************************************/\r\nint32_t SendControlData_S_initial(){\r\n\tvSemaphoreCreateBinary( controlHandle->SendControlData_Semaphore ); //semaphore create\r\n\tif(controlHandle->SendControlData_Semaphore == NULL)\r\n\t\treturn ERROR;\r\n\telse\r\n\t\treturn SUCCESS;\r\n}\r\n\r\n/***************************************************\r\n * initialize control_task\r\n * the step is necessary for initializing application tasks\r\n *\r\n * @return\r\n * Handle to control_task data field\r\n * ************************************************/\r\nCONTROL_HANDLE_t initialControlTask(){\r\n\tCONTROL_HANDLE_t taskHandle;\r\n\ttaskHandle = (CONTROL_HANDLE_t)malloc(sizeof(CONTROL_STATE_t));\r\n\ttaskHandle->task_ID = CONTROLTASKID;\r\n\ttaskHandle->ControlTaskQ = taskQCreat(taskHandle->ControlTaskQ);\r\n\ttaskHandle->listIndex = 0;\r\n\treturn taskHandle;\r\n}\r\n\r\n/***************************************************\r\n *initialize a application task\r\n *precondition:\r\n *the function must be called after control_task is initialized\r\n *\r\n *@para TASKID\r\n *the task ID of the certain application task\r\n *@return\r\n *return the handle to the application task data field\r\n * ************************************************/\r\nTASK_HANDLE_t initialAppTask(uint8_t TASKID){\r\n\tTASK_HANDLE_t taskHandle;\r\n\ttaskHandle = (TASK_HANDLE_t)malloc(sizeof(TASK_STATE_t));\r\n\ttaskHandle->taskID = TASKID;\r\n\ttaskHandle->TASKQ = taskQCreat(taskHandle->TASKQ);\r\n\tregisterTaskToControl(taskHandle->taskID, taskHandle->TASKQ);\r\n\r\n\treturn taskHandle;\r\n}\r\n/***************************************************\r\n * create Queue and return\r\n * precondition:\r\n * Queue belonging task field must be constructed before\r\n *\r\n * @para TASKQ\r\n * the Queue variable in each task's data field\r\n * @return\r\n * return the reference to the created Queue of input variable\r\n * ************************************************/\r\nOsiMsgQ_t taskQCreat(OsiMsgQ_t TASKQ){\r\n\tOsiReturnVal_e osi_retVal;\r\n\t\tosi_retVal = osi_MsgQCreate(&TASKQ, \"TASKQ\", MAX_MSG_LENGTH, MAX_MSG_NUMBER);\r\n\t\t\tif(osi_retVal != OSI_OK)\r\n\t\t    {\r\n\t\t\t\t// Queue was not created and must not be used.\r\n\t\t        while(1);\r\n\t\t    }\r\n\r\n\t\t\treturn TASKQ;\r\n}\r\n\r\n/*************************************************\r\n* This method is used to monitor the control stop commend during the operating mode\r\n* usually be put in the inside task mission loop (like keeping measure data for certain time loop)\r\n* once message on task's Queue, peek the first element in Queue\r\n* if the first commend sent is a stop, then stop the current mission\r\n* and the task will be return to the Queue receive step to receive next commend\r\n*\r\n* When want to let the application task quit the current command and execute a new command\r\n* must send a TASKID||STOP command (defined in command.h) first\r\n* and then send the new command user want\r\n*/\r\nint32_t CurrentCommendStop(TASK_HANDLE_t TASKHANDLE){\r\n    DATA_HANDLE_t checkHandle;\r\n    if(uxQueueMessagesWaiting( TASKHANDLE->TASKQ ) != 0 ){\r\n        xQueuePeek( TASKHANDLE->TASKQ, &checkHandle, portMAX_DELAY );\r\n        if(checkHandle->controlCommand == TASKHANDLE->taskID || STOP){\r\n        \t//*************customer code area******************\r\n        \t//method to stop the current mission\r\n        \t//example:\r\n        \t//like force a loop to break\r\n        \t//\r\n        \t//method to clear up the current mission\r\n        \t//example:\r\n        \t//free allocated memory\r\n        \t//stop timer and other interfaces\r\n        \t//*************************************************\r\n        \tfree(checkHandle->dataBuffer);\r\n        \tfree(checkHandle); // free memory space if only the commend is a stop commend\r\n\r\n        \treturn SUCCESS;\r\n        }else{\r\n        \treturn NOMATCH;\r\n        }\r\n    }else{\r\n    \treturn NOMATCH;\r\n    }\r\n}\r\n\r\n\n", "comment_ratio": 0.2617801047120419}
{"lang": "c", "code": "#ifndef DWARFCOMPILEUNITPARAMS_H\n#define DWARFCOMPILEUNITPARAMS_H\n\n#include <libdwarf.h>\n\nclass DwarfCompileUnit;\n\nclass DwarfCompileUnitParams\n{\nprivate:\n\tDwarf_Unsigned cu_length;\n\tDwarf_Half cu_version;\n\tDwarf_Off cu_abbrev_offset;\n\tDwarf_Half cu_pointer_size;\n\tDwarf_Half cu_offset_size;\n\tDwarf_Half cu_extension_size;\n\tDwarf_Sig8 type_signature;\n\tDwarf_Unsigned type_offset;\n\tDwarf_Unsigned cu_next_offset;\n\n\tfriend class DwarfCompileUnit;\n\npublic:\n\n\tDwarf_Half GetDwarfVersion() const\n\t{\n\t\treturn cu_version;\n\t}\n\n\tDwarf_Half GetOffsetSize() const\n\t{\n\t\treturn cu_offset_size;\n\t}\n};\n\n#endif\n\n", "comment_ratio": 0.36666666666666664}
{"lang": "c", "code": "#include <stdio.h>\n#define DEF \"I am a #defined string.\"\nint main(int argc, const char * argv[]) {\n    char str1[100] = \"An array was initialized to me.\";\n    const char *str2 = \"A pointer was initialized to me.\";\n    \n    puts(\"I'm an argument to puts().\");\n    puts(DEF);\n    puts(str1);\n    puts(str2);\n    puts(&str1[5]);\n    puts(str2 + 4);\n    \n    return 0;\n}\n\n", "comment_ratio": 0.2916666666666667}
{"lang": "c", "code": "#import <objc/NSObject.h>\n\n@class NSMutableArray, NSMutableDictionary, NSMutableIndexSet, UIScrollView;\n@protocol TFNDataView, TFNDataViewHelperDelegate;\n\n@interface TFNDataViewHelper : NSObject\n{\n    UIScrollView<TFNDataView> *_dataView;\n    NSMutableDictionary *_cellLayoutsByIdentifier;\n    NSMutableDictionary *_registeredReuseIdentifiers;\n    NSMutableDictionary *_sectionUpdates;\n    _Bool _reloadData;\n    _Bool _updateAnimated;\n    id <TFNDataViewHelperDelegate> _delegate;\n    long long _batchCount;\n    NSMutableArray *_cellLayouts;\n    NSMutableIndexSet *_deleteCellLayoutSections;\n    NSMutableIndexSet *_insertCellLayoutSections;\n    NSMutableIndexSet *_reloadCellLayoutSections;\n}\n\n@property(nonatomic) _Bool updateAnimated; // @synthesize updateAnimated=_updateAnimated;\n@property(readonly, nonatomic) NSMutableIndexSet *reloadCellLayoutSections; // @synthesize reloadCellLayoutSections=_reloadCellLayoutSections;\n@property(readonly, nonatomic) NSMutableIndexSet *insertCellLayoutSections; // @synthesize insertCellLayoutSections=_insertCellLayoutSections;\n@property(readonly, nonatomic) NSMutableIndexSet *deleteCellLayoutSections; // @synthesize deleteCellLayoutSections=_deleteCellLayoutSections;\n@property(readonly, nonatomic) NSMutableArray *cellLayouts; // @synthesize cellLayouts=_cellLayouts;\n@property(nonatomic) long long batchCount; // @synthesize batchCount=_batchCount;\n@property(nonatomic) __weak id <TFNDataViewHelperDelegate> delegate; // @synthesize delegate=_delegate;\n- (void).cxx_destruct;\n- (void)setRegisteredClass:(Class)arg1 forSupplementaryViewOfKind:(id)arg2 withReuseIdentifier:(id)arg3;\n- (Class)registeredClassForSupplementaryViewOfKind:(id)arg1 withReuseIdentifier:(id)arg2;\n- (void)setRegisteredClass:(Class)arg1 forCellWithReuseIdentifier:(id)arg2;\n- (Class)registeredClassForCellWithReuseIdentifier:(id)arg1;\n- (void)_didApplyUpdates;\n- (void)_willApplyUpdates:(_Bool)arg1;\n- (id)_sectionUpdatesForSection:(long long)arg1;\n- (void)reloadDataWithBlock:(CDUnknownBlockType)arg1;\n- (void)moveSection:(long long)arg1 toSection:(long long)arg2 withBlock:(CDUnknownBlockType)arg3;\n- (void)reloadSections:(id)arg1 animated:(_Bool)arg2 withBlock:(CDUnknownBlockType)arg3;\n- (void)deleteSections:(id)arg1 animated:(_Bool)arg2 withBlock:(CDUnknownBlockType)arg3;\n- (void)insertSections:(id)arg1 animated:(_Bool)arg2 withBlock:(CDUnknownBlockType)arg3;\n- (void)moveItemAtIndexPath:(id)arg1 toIndexPath:(id)arg2 withBlock:(CDUnknownBlockType)arg3;\n- (void)reloadItemsAtIndexPaths:(id)arg1 animated:(_Bool)arg2 withBlock:(CDUnknownBlockType)arg3;\n- (void)deleteItemsAtIndexPaths:(id)arg1 animated:(_Bool)arg2 withBlock:(CDUnknownBlockType)arg3;\n- (void)insertItemsAtIndexPaths:(id)arg1 animated:(_Bool)arg2 withBlock:(CDUnknownBlockType)arg3;\n- (void)_performBatchUpdates:(CDUnknownBlockType)arg1;\n- (void)performBatchUpdates:(CDUnknownBlockType)arg1 completion:(CDUnknownBlockType)arg2;\n- (void)endUpdates;\n- (void)beginUpdates;\n- (id)_cellLayoutsForSection:(long long)arg1 create:(_Bool)arg2;\n- (long long)invalidateCellLayoutsPassingTest:(CDUnknownBlockType)arg1;\n- (void)setCellLayout:(id)arg1 forObjectIdentifier:(id)arg2;\n- (id)cellLayoutForObjectIdentifier:(id)arg1;\n- (void)setCellLayout:(id)arg1 forIndexPath:(id)arg2;\n- (id)cellLayoutForIndexPath:(id)arg1;\n- (id)initWithDataView:(id)arg1;\n\n@end\n\n\n", "comment_ratio": 0.18181818181818182}
{"lang": "c", "code": "@class NSTimer;\n\n@interface ICBackoffTimer : NSObject {\n\n\tid _userInfo;\n\tdouble _initialTimeInterval;\n\tid _target;\n\tSEL _selector;\n\tunsigned long long _backoffCount;\n\tdouble _maxTimeInterval;\n\tNSTimer* _timer;\n\n}\n\n@property (assign,nonatomic) double initialTimeInterval;                   //@synthesize initialTimeInterval=_initialTimeInterval - In the implementation block\n@property (assign,nonatomic,__weak) id target;                             //@synthesize target=_target - In the implementation block\n@property (assign,nonatomic) SEL selector;                                 //@synthesize selector=_selector - In the implementation block\n@property (nonatomic,retain) id userInfo;                                  //@synthesize userInfo=_userInfo - In the implementation block\n@property (assign,nonatomic) unsigned long long backoffCount;              //@synthesize backoffCount=_backoffCount - In the implementation block\n@property (assign,nonatomic) double maxTimeInterval;                       //@synthesize maxTimeInterval=_maxTimeInterval - In the implementation block\n@property (retain) NSTimer * timer;                                        //@synthesize timer=_timer - In the implementation block\n-(void)fire:(id)arg1 ;\n-(BOOL)isScheduled;\n-(id)initWithInitialInterval:(double)arg1 maxInterval:(double)arg2 target:(id)arg3 selector:(SEL)arg4 userInfo:(id)arg5 ;\n-(double)nextTimeInterval;\n-(void)scheduleToFire;\n-(void)setInitialTimeInterval:(double)arg1 ;\n-(void)setMaxTimeInterval:(double)arg1 ;\n-(void)setBackoffCount:(unsigned long long)arg1 ;\n-(double)initialTimeInterval;\n-(unsigned long long)backoffCount;\n-(double)maxTimeInterval;\n-(id)init;\n-(void)dealloc;\n-(id)userInfo;\n-(void)setUserInfo:(id)arg1 ;\n-(void)setTarget:(id)arg1 ;\n-(void)setSelector:(SEL)arg1 ;\n-(id)target;\n-(SEL)selector;\n-(void)invalidate;\n-(void)setTimer:(NSTimer *)arg1 ;\n-(NSTimer *)timer;\n-(void)fire;\n@end\n\n\n", "comment_ratio": 0.125}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n#import \"Parse/Parse.h\"\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface OtherProfileViewController : UIViewController <UICollectionViewDelegate,UICollectionViewDataSource>\n\n@property (strong, nonatomic) PFUser *user;\n\n@end\n\nNS_ASSUME_NONNULL_END\n\n", "comment_ratio": 0.3333333333333333}
{"lang": "c", "code": "#ifndef __SYSTEM_H\n#define __SYSTEM_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include <stdint.h>\n\n// Constants that relate to the entire system (SH-4 specific).\n#define UNCACHED_MIRROR 0xA0000000\n#define PHYSICAL_MASK 0x0FFFFFFF\n\n// Constants that relate to the Naomi's memory map.\n#define BIOS_BASE 0x00000000\n#define BIOS_SIZE 0x00200000\n#define BIOS_MASK (BIOS_SIZE - 1)\n\n#define SRAM_BASE 0x00200000\n#define SRAM_SIZE 0x00008000\n#define SRAM_MASK (SRAM_SIZE - 1)\n\n#define SOUNDRAM_BASE 0x00800000\n#define SOUNDRAM_SIZE 0x00800000\n#define SOUNDRAM_MASK (SOUNDRAM_SIZE - 1)\n\n#define TEXRAM_BASE 0x04000000\n#define TEXRAM_SIZE 0x01000000\n#define TEXRAM_MASK (TEXRAM_SIZE - 1)\n\n#define VRAM_BASE 0x05000000\n#define VRAM_SIZE 0x01000000\n#define VRAM_MASK (VRAM_SIZE - 1)\n\n#define RAM_BASE 0x0c000000\n#define RAM_SIZE 0x02000000\n#define RAM_MASK (RAM_SIZE - 1)\n\n#define STORE_QUEUE_BASE 0xE0000000\n#define STORE_QUEUE_SIZE 0x04000000\n#define STORE_QUEUE_MASK (STORE_QUEUE_SIZE - 1)\n\n// A 32-byte aligned and 32-byte multiple hardware memset that is about 3x faster than\n// the fastest tight loop that you can write in software. Returns nonzero if the copy was\n// successful or 0 if the HW was unavailable.\nint hw_memset(void *addr, uint32_t value, unsigned int amount);\n\n// A 32-byte aligned and 32-byte multiple hardware memcpy that is similarly faster than\n// the fastest tight loop that you can write in software. Returns nonzero if the copy\n// was successful or 0 if the HW was unavailable.\nint hw_memcpy(void *addr, void *src, unsigned int amount);\n\n// Call code that is outside of our C runtime, such as another program or something\n// in the BIOS that does not return. Takes care of safely shutting down interrupts,\n// threads and anything else going on so that the new code can execute without any\n// of our own calls interfering.\nvoid call_unmanaged(void (*call)());\n\n// Syscalls that request the BIOS do something.\nvoid enter_test_mode();\nvoid restart_game();\n\n// Flush a range of bytes of memory starting at addr from the instruction cache.\nvoid icache_flush_range(void *addr, unsigned int bytes);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n", "comment_ratio": 0.19718309859154928}
{"lang": "c", "code": "#import <Cocoa/Cocoa.h>\n\n\n@interface KBActionWindow : NSObject {\n\tIBOutlet id window;\n\tIBOutlet id scrollView;\n\t\n\tNSMutableArray *actions;\n}\n+ (KBActionWindow *) sharedKBActionWindow;\n\n- (void) redrawActions;\n- (void) setTitle:(NSString *)string;\n- (id) addActionWithTitle:(NSString *)tString withDescription:(NSString *)tString withIcon:(NSImage *)tImage withAbortSelector:(SEL)tSelector forTarget:(id)tTarget;\n- (void) removeAction:(id)action;\n\n- (NSWindow *) window;\n@end\n\n", "comment_ratio": 0.25925925925925924}
{"lang": "c", "code": "#ifndef TEXT_H\n#define TEXT_H\n\n#include <cmath>\n#include <string>\n#include <vector>\n#include <SDL_ttf.h>\n#include <SDL_opengl.h>\n\nclass Text\n{\nprivate:\n\t/** OpenGL textures containing the text */\n\tstd::vector<GLuint> textures;\n\t/** Width of each text */\n\tstd::vector<int> width;\n\t/** Height of each text */\n\tstd::vector<int> height;\n\n\t/** Index of the next text, that should be rendered */\n\tint nextText;\n\npublic:\n\tText()\n\t{\n\t\t// Initialize TTF if not done yet\n\t\tif (instances == 0) {\n\t\t\tif (TTF_Init() < 0) {\n\t\t        fprintf(stderr, \"\\nCould not initialize SDL_ttf\\n\" );\n\t\t        exit(-1);\n\t\t\t}\n\n\t\t\topenFont();\n\t\t}\n\n\t\tinstances++;\n\t}\n\n\t~Text()\n\t{\n\t\t// We assume that std::vector is just an array ...\n\t\tglDeleteTextures(textures.size(), &textures[0]);\n\n\t\tinstances--;\n\n\t\tif (instances == 0) {\n\t\t\tTTF_CloseFont(font);\n\t\t\tTTF_Quit();\n\t\t}\n\t}\n\n\tvoid addText(const char* text)\n\t{\n\t\tif (!font)\n\t\t\treturn;\n\n\t\t// Draw string\n\t\tSDL_Color black = {0, 0, 0, 255};\n\t\tSDL_Surface* surf = TTF_RenderText_Blended(font, text, black);\n\n\t\tif (surf) {\n\t\t\tGLuint texture;\n\n\t\t\t/* Tell GL about our new texture */\n\t\t\tglGenTextures(1, &texture);\n\t\t\tglBindTexture(GL_TEXTURE_2D, texture);\n\t\t\tglTexImage2D(GL_TEXTURE_2D, 0, 4, surf->w, surf->h, 0, GL_BGRA,\n\t\t\t\t\tGL_UNSIGNED_BYTE, surf->pixels);\n\n\t\t\twidth.push_back(surf->w);\n\t\t\theight.push_back(surf->h);\n\n\t\t\ttextures.push_back(texture);\n\n\t\t\t/* Clean up */\n\t\t\tSDL_FreeSurface(surf);\n\t\t}\n\t}\n\n\tvoid startTextMode()\n\t{\n\t\t// Enable 2D mode\n\t\tint vPort[4];\n\n\t\tglGetIntegerv(GL_VIEWPORT, vPort);\n\n\t\tglMatrixMode(GL_PROJECTION);\n\t\tglPushMatrix();\n\t\tglLoadIdentity();\n\n\t\tglOrtho(0, vPort[2], 0, vPort[3], -1, 1);\n\t\tglMatrixMode(GL_MODELVIEW);\n\t\tglPushMatrix();\n\t\tglLoadIdentity();\n\t\tglDisable(GL_DEPTH_TEST);\n\t    glEnable(GL_BLEND);\n\t\tglEnable(GL_TEXTURE_2D);\n\t    glBlendFunc(GL_ONE_MINUS_DST_COLOR, GL_ONE_MINUS_SRC_ALPHA);\n\n\t    nextText = 0;\n\t}\n\n\t/**\n\t * @return True there are more textures\n\t */\n\tbool showNextText(SDL_Rect &location)\n\t{\n\t\tif (!font)\n\t\t\treturn false;\n\n\t\tif (nextText >= textures.size())\n\t\t\t// No more textures to show\n\t\t\treturn false;\n\n\t\t/* GL_NEAREST looks horrible, if scaled... */\n\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n\n\t\t/* prepare to render our texture */\n\t\tglBindTexture(GL_TEXTURE_2D, textures[nextText]);\n\n\t\t/* Draw a quad at location */\n\t\tglBegin(GL_QUADS);\n\t\t\t/* Recall that the origin is in the lower-left corner\n\t\t\t   That is why the TexCoords specify different corners\n\t\t\t   than the Vertex coords seem to. */\n\t\t\tglTexCoord2f(0.0f, 1.0f);\n\t\t\t\tglVertex2f(location.x, location.y - height[nextText]);\n\t\t\tglTexCoord2f(1.0f, 1.0f);\n\t\t\t\tglVertex2f(location.x + width[nextText], location.y - height[nextText]);\n\t\t\tglTexCoord2f(1.0f, 0.0f);\n\t\t\t\tglVertex2f(location.x + width[nextText], location.y);\n\t\t\tglTexCoord2f(0.0f, 0.0f);\n\t\t\t\tglVertex2f(location.x, location.y);\n\t\tglEnd();\n\n\t\t/* return the deltas in the unused w,h part of the rect */\n\t\tlocation.w = width[nextText];\n\t\tlocation.h = height[nextText];\n\n\t\tnextText++;\n\n\t\treturn nextText < textures.size();\n\t}\n\n\tvoid endTextMode()\n\t{\n\t\t// Disable 2D mode\n\t\tglDisable(GL_BLEND);\n\t\tglDisable(GL_TEXTURE_2D);\n\t\tglEnable(GL_DEPTH_TEST);\n\t\tglMatrixMode(GL_PROJECTION);\n\t\tglPopMatrix();\n\t\tglMatrixMode(GL_MODELVIEW);\n\t\tglPopMatrix();\n\t}\n\nprivate:\n\tstatic void openFont()\n\t{\n\t\tstd::string fullFileName = \"\";\n\n\t\t// On unix: determine directory of exec\n#ifdef __unix__\n\t\t// Code taken from:\n\t\t// http://www.gamedev.net/community/forums/topic.asp?topic_id=459511\n\t\tstd::string path = \"\";\n\t\tpid_t pid = getpid();\n\t\tchar buf[20] = {0};\n\t\tsprintf(buf,\"%d\",pid);\n\t\tstd::string _link = \"/proc/\";\n\t\t_link.append( buf );\n\t\t_link.append( \"/exe\");\n\t\tchar proc[512];\n\t\tint ch = readlink(_link.c_str(),proc,512);\n\t\tif (ch != -1) {\n\t\t\tproc[ch] = 0;\n\t\t\tpath = proc;\n\t\t\tstd::string::size_type t = path.find_last_of(\"/\");\n\t\t\tpath = path.substr(0, t);\n\t\t}\n\n\t\tfullFileName = path + std::string(\"/\");\n#endif\n\t\tfullFileName.append(\"FreeSans.ttf\");\n\n\t\tfont = TTF_OpenFont(fullFileName.c_str(), 16);\n\n\t\tif (!font) {\n\t\t\tfprintf(stderr, \"TTF_OpenFont: %s\\n\", TTF_GetError());\n\t\t\tfprintf(stderr, \"All text will be ignored\\n\");\n\t\t}\n\t}\n\n\t/** Number of text classes */\n\tstatic unsigned int instances;\n\n\t/** The only font we use */\n\tstatic TTF_Font* font;\n};\n\n#endif // TEXT_H\n\n", "comment_ratio": 0.12612612612612611}
{"lang": "c", "code": "#pragma once\n\n#include <AzCore/std/smart_ptr/unique_ptr.h>\n#include <AzCore/std/smart_ptr/shared_ptr.h>\n#include <AzCore/std/parallel/binary_semaphore.h>\n#include <AzCore/Memory/SystemAllocator.h>\n#include <AzCore/Component/Component.h>\n#include <AzCore/Component/TickBus.h>\n\n#include <AzFramework/Asset/AssetCatalogBus.h>\n\n#include <AzToolsFramework/AssetBrowser/AssetBrowserBus.h>\n#include <AzToolsFramework/API/EditorAssetSystemAPI.h>\n#include <AzFramework/Network/SocketConnection.h>\n\n#include <AzQtComponents/Components/StyledBusyLabel.h>\n\nnamespace AzToolsFramework\n{\n    namespace AssetDatabase\n    {\n        class AssetDatabaseConnection;\n    }\n\n    namespace AssetBrowser\n    {\n        class AssetBrowserModel;\n        class SourceAssetBrowserEntry;\n        class FolderAssetBrowserEntry;\n        class RootAssetBrowserEntry;\n        class AssetEntryChangeset;\n\n        //! AssetBrowserComponent caches database entries\n        /*!\n            Database entries are cached so that they can be quickly accessed by asset browser views.\n            Additionally this class watches for any changes to the database and updates the views if such changes happen\n        */\n        class AssetBrowserComponent\n            : public AZ::Component\n            , public AssetBrowserComponentRequestBus::Handler\n            , public AssetDatabaseLocationNotificationBus::Handler\n            , public AzFramework::AssetCatalogEventBus::Handler\n            , public AZ::TickBus::Handler\n            , public AssetSystemBus::Handler\n            , public AssetBrowserInteractionNotificationBus::Handler\n        {\n        public:\n            AZ_COMPONENT(AssetBrowserComponent, \"{4BC5F93F-2F9E-412E-B00A-396C68CFB5FB}\")\n\n            AssetBrowserComponent();\n            virtual ~AssetBrowserComponent();\n\n            //////////////////////////////////////////////////////////////////////////\n            // AZ::Component\n            //////////////////////////////////////////////////////////////////////////\n            void Activate() override;\n            void Deactivate() override;\n            static void Reflect(AZ::ReflectContext* context);\n            static void GetProvidedServices(AZ::ComponentDescriptor::DependencyArrayType& services);\n            static void GetRequiredServices(AZ::ComponentDescriptor::DependencyArrayType& required);\n            static void GetIncompatibleServices(AZ::ComponentDescriptor::DependencyArrayType& incompatible);\n\n            //////////////////////////////////////////////////////////////////////////\n            // AssetDatabaseLocationNotificationBus\n            //////////////////////////////////////////////////////////////////////////\n            void OnDatabaseInitialized() override;\n\n            //////////////////////////////////////////////////////////////////////////\n            // AssetBrowserComponentRequestBus\n            //////////////////////////////////////////////////////////////////////////\n            AssetBrowserModel* GetAssetBrowserModel() override;\n            bool AreEntriesReady() override;\n            void PickAssets(AssetSelectionModel& selection, QWidget* parent) override;\n            AzQtComponents::StyledBusyLabel* GetStyledBusyLabel() override;\n\n            //////////////////////////////////////////////////////////////////////////\n            // AssetCatalogEventBus\n            //////////////////////////////////////////////////////////////////////////\n            void OnCatalogAssetAdded(const AZ::Data::AssetId& assetId) override;\n            void OnCatalogAssetChanged(const AZ::Data::AssetId& assetId) override;\n            void OnCatalogAssetRemoved(const AZ::Data::AssetId& assetId, const AZ::Data::AssetInfo& assetInfo) override;\n\n            //////////////////////////////////////////////////////////////////////////\n            // TickBus\n            //////////////////////////////////////////////////////////////////////////\n            void OnTick(float deltaTime, AZ::ScriptTimePoint time) override;\n\n            //////////////////////////////////////////////////////////////////////////\n            // AssetSystemBus\n            //////////////////////////////////////////////////////////////////////////\n            void SourceFileChanged(AZStd::string relativePath, AZStd::string scanFolder, AZ::Uuid sourceUuid) override;\n\n            //////////////////////////////////////////////////////////////////////////\n            // AssetBrowserInteractionNotificationBus\n            SourceFileDetails GetSourceFileDetails(const char* fullSourceFileName) override;\n            //////////////////////////////////////////////////////////////////////////\n\n            void AddFile(const AZ::s64& fileId);\n            void RemoveFile(const AZ::s64& fileId);\n\n            void PopulateAssets();\n            void UpdateAssets();\n        private:\n            AZStd::shared_ptr<AssetDatabase::AssetDatabaseConnection> m_databaseConnection;\n            AZStd::shared_ptr<RootAssetBrowserEntry> m_rootEntry;\n            AZStd::binary_semaphore m_updateWait;\n            AZStd::thread m_thread;\n\n            //! wait until database is ready\n            bool m_dbReady;\n            //! have entries been populated yet\n            bool m_entriesReady = false;\n            //! is query waiting for more update requests\n            AZStd::atomic_bool m_waitingForMore;\n            //! should the query thread stop\n            AZStd::atomic_bool m_disposed;\n\n            AZStd::unique_ptr<AssetBrowserModel> m_assetBrowserModel;\n            AZStd::shared_ptr<AssetEntryChangeset> m_changeset;\n\n            AzFramework::SocketConnection::TMessageCallbackHandle m_cbHandle = 0;\n\n            //! Notify to start the query thread\n            void NotifyUpdateThread();\n\n            void HandleFileInfoNotification(const void* buffer, unsigned int bufferSize);\n\n            AzQtComponents::StyledBusyLabel* m_styledBusyLabel;\n        };\n    }\n} // namespace AssetBrowser\n\n", "comment_ratio": 0.1958041958041958}
{"lang": "c", "code": "#import <PhotoPrintProduct/KHModel.h>\n\n#import \"KHJSONGeneratorProtocol.h\"\n\n@class NSArray, NSString;\n\n@interface KHBehavior : KHModel <KHJSONGeneratorProtocol>\n{\n    long long _traitId;\n    long long _categoryId;\n    NSString *_name;\n    NSString *_condition;\n    BOOL _conditionParsed;\n    NSString *_comparator;\n    NSArray *_componentArrayLeft;\n    NSArray *_componentArrayRight;\n}\n\n+ (id)behaviorForKey:(long long)arg1 fromDatabase:(id)arg2;\n+ (id)modifyModelFromJSON:(id)arg1 inDatabase:(id)arg2 bundlePath:(id)arg3;\n+ (id)generateModelFromJSON:(id)arg1 inDatabase:(id)arg2 bundlePath:(id)arg3;\n@property(retain, nonatomic) NSString *comparator; // @synthesize comparator=_comparator;\n@property(retain, nonatomic) NSArray *componentArrayRight; // @synthesize componentArrayRight=_componentArrayRight;\n@property(retain, nonatomic) NSArray *componentArrayLeft; // @synthesize componentArrayLeft=_componentArrayLeft;\n- (BOOL)isSimilarToModel:(id)arg1 skippingFields:(id)arg2 differences:(id *)arg3;\n- (void)_parseCondition;\n- (void)remove;\n- (id)attributeForKey:(id)arg1;\n- (id)attributes;\n- (void)notateAttributeAddition:(id)arg1;\n- (void)setCondition:(id)arg1;\n- (void)cacheCondition:(id)arg1;\n- (id)condition;\n- (void)setName:(id)arg1;\n- (void)cacheName:(id)arg1;\n- (id)name;\n- (void)setCategoryId:(long long)arg1;\n- (void)cacheCategoryId:(long long)arg1;\n- (long long)categoryId;\n- (void)setTraitId:(long long)arg1;\n- (void)cacheTraitId:(long long)arg1;\n- (long long)traitId;\n- (void)dealloc;\n@property(readonly, copy) NSString *description;\n- (id)JSONRepresentation;\n\n// Remaining properties\n@property(readonly, copy) NSString *debugDescription;\n@property(readonly) unsigned long long hash;\n@property(readonly) Class superclass;\n\n@end\n\n\n", "comment_ratio": 0.15}
{"lang": "c", "code": "#ifndef FIREBASE_INSTALLATIONS_SRC_IOS_INSTALLATIONS_IOS_H_\n#define FIREBASE_INSTALLATIONS_SRC_IOS_INSTALLATIONS_IOS_H_\n\n#include \"firebase/app.h\"\n#include \"app/memory/unique_ptr.h\"\n#include \"app/src/reference_counted_future_impl.h\"\n#include \"app/src/util_ios.h\"\n#include \"firebase/future.h\"\n#include \"firebase/internal/common.h\"\n\n#ifdef __OBJC__\n#import \"FIRInstallations.h\"\n#endif  // __OBJC__\n\nnamespace firebase {\nnamespace installations {\nnamespace internal {\n// Installations Client implementation for iOS.\n\n// This defines the class FIRInstallationsPointer, which is a C++-compatible\n// wrapper around the FIRInstallations Obj-C class.\nOBJ_C_PTR_WRAPPER(FIRInstallations);\n\n// This class implements functions from `firebase/installations.h` header.\n// See `firebase/installations.h` for all public functions documentation.\nclass InstallationsInternal {\n public:\n  explicit InstallationsInternal(const firebase::App& app);\n  ~InstallationsInternal();\n\n  // Platform-specific method that causes a heartbeat to be logged.\n  // See go/firebase-platform-logging-design for more information.\n  static void LogHeartbeat(const firebase::App& app);\n\n  Future<std::string> GetId();\n  Future<std::string> GetIdLastResult();\n\n  Future<void> Delete();\n  Future<void> DeleteLastResult();\n\n  Future<std::string> GetToken(bool forceRefresh);\n  Future<std::string> GetTokenLastResult();\n\n  bool Initialized() const;\n\n  void Cleanup();\n\n private:\n#ifdef __OBJC__\n  FIRInstallations* _Nullable impl() const { return impl_->get(); }\n#endif\n  // app\n  const firebase::App& app_;\n\n  UniquePtr<FIRInstallationsPointer> impl_;\n\n  /// Handle calls from Futures that the API returns.\n  ReferenceCountedFutureImpl future_impl_;\n};\n\n}  // namespace internal\n}  // namespace installations\n}  // namespace firebase\n\n#endif  // FIREBASE_INSTALLATIONS_SRC_IOS_INSTALLATIONS_IOS_H_\n\n", "comment_ratio": 0.3375}
{"lang": "c", "code": "#pragma once\n\n#include <Core/ResourceManager/ResourceHandle.h>\n#include <Foundation/Communication/Message.h>\n#include <RendererCore/RendererCoreDLL.h>\n#include <ozz/base/maths/soa_transform.h>\n\nclass ezSkeleton;\nclass ezAnimationPose;\nstruct ezSkeletonResourceDescriptor;\nclass ezEditableSkeletonJoint;\nstruct ezAnimationClipResourceDescriptor;\n\nusing ezSkeletonResourceHandle = ezTypedResourceHandle<class ezSkeletonResource>;\n\n#define ezInvalidJointIndex 0xFFFFu\n\nnamespace ozz::animation\n{\n  class Skeleton;\n}\n\nstruct ezSkeletonJointGeometryType\n{\n  typedef ezUInt8 StorageType;\n\n  enum Enum\n  {\n    None = 0,\n    Capsule,\n    Sphere,\n    Box,\n\n    Default = None\n  };\n};\n\n/// \\brief Used by components that skin a mesh to inform children whenever a new pose is being prepared.\n///\n/// The pose matrices are still in local space and in the ozz internal structure-of-arrays format.\n/// At this point individual bones can still be modified, to propagate the effect to the child bones.\nstruct EZ_RENDERERCORE_DLL ezMsgAnimationPosePreparing : public ezMessage\n{\n  EZ_DECLARE_MESSAGE_TYPE(ezMsgAnimationPosePreparing, ezMessage);\n\n  const ezSkeleton* m_pSkeleton = nullptr;\n  ezArrayPtr<ozz::math::SoaTransform> m_LocalTransforms;\n};\n\n/// \\brief Used by components that skin a mesh to inform children whenever a new pose has been computed.\n///\n/// This can be used by child nodes/components to synchronize their state to the new animation pose.\n/// The message is sent while the pose is in object space.\n/// Both skeleton and pose pointer are always valid.\nstruct EZ_RENDERERCORE_DLL ezMsgAnimationPoseUpdated : public ezMessage\n{\n  EZ_DECLARE_MESSAGE_TYPE(ezMsgAnimationPoseUpdated, ezMessage);\n\n  void ComputeFullBoneTransform(ezUInt32 uiJointIndex, ezMat4& fullTransform) const;\n  void ComputeFullBoneTransform(ezUInt32 uiJointIndex, ezMat4& fullTransform, ezQuat& rotationOnly) const;\n\n  const ezTransform* m_pRootTransform = nullptr;\n  const ezSkeleton* m_pSkeleton = nullptr;\n  ezArrayPtr<const ezMat4> m_ModelTransforms;\n  bool m_bContinueAnimating = true;\n};\n\n/// \\brief Used by components that do rope simulation and rendering.\n///\n/// The rope simulation component sends this message to components attached to the same game object,\n/// every time there is a new rope pose. There is no skeleton information, since all joints/bones are\n/// connected as one long string.\n///\n/// For a rope with N segments, N+1 poses are sent. The last pose may use the same rotation as the one before.\nstruct EZ_RENDERERCORE_DLL ezMsgRopePoseUpdated : public ezMessage\n{\n  EZ_DECLARE_MESSAGE_TYPE(ezMsgRopePoseUpdated, ezMessage);\n\n  ezArrayPtr<const ezTransform> m_LinkTransforms;\n};\n\n/// \\brief The animated mesh component listens to this message and 'answers' by filling out the skeleton resource handle.\n///\n/// This can be used by components that require a skeleton, to ask the nearby components to provide it to them.\nstruct EZ_RENDERERCORE_DLL ezMsgQueryAnimationSkeleton : public ezMessage\n{\n  EZ_DECLARE_MESSAGE_TYPE(ezMsgQueryAnimationSkeleton, ezMessage);\n\n  ezSkeletonResourceHandle m_hSkeleton;\n};\n\n/// \\brief This message is sent when animation root motion data is available.\n///\n/// Listening components can use this to move a character.\nstruct EZ_RENDERERCORE_DLL ezMsgApplyRootMotion : public ezMessage\n{\n  EZ_DECLARE_MESSAGE_TYPE(ezMsgApplyRootMotion, ezMessage);\n\n  ezVec3 m_vTranslation;\n  ezAngle m_RotationX;\n  ezAngle m_RotationY;\n  ezAngle m_RotationZ;\n};\n\n", "comment_ratio": 0.21153846153846154}
{"lang": "c", "code": "#ifndef DWF_QUEUE_WAIT_MANAGEMENT_TEST_H\n#define DWF_QUEUE_WAIT_MANAGEMENT_TEST_H\n\n#include <cppunit/extensions/HelperMacros.h>\n#include <cppunit/Portability.h>\n#include \"dwfstate.h\"\n\n/*! @class DwfQueueWaitManagementTest\n* @brief Unit tests of DwfQueue wait management\n*\n* Inherits from TestFixture\n*\n*/\nclass DwfQueueWaitManagementTest : public CPPUNIT_NS::TestFixture\n{\npublic:\n    CPPUNIT_TEST_SUITE(DwfQueueWaitManagementTest);\n        CPPUNIT_TEST(waitManagementCopy);\n        CPPUNIT_TEST(waitManagementMove);\n        CPPUNIT_TEST(waitManagementDeletion);\n    CPPUNIT_TEST_SUITE_END();\n\npublic:\n    /*!\n    * @brief Constructor of the DwfQueueWaitManagementTest class\n    *\n    * Does nothing.\n    *\n    */\n    DwfQueueWaitManagementTest();\n\n    /*!\n    * @brief Desctructor of the DwfQueueWaitManagementTest class\n    *\n    * Does nothing.\n    *\n    */\n    ~DwfQueueWaitManagementTest();\n\n    /*!\n    * @brief Prepare execution environment of every test\n    *\n    * Does nothing.\n    *\n    */\n    void setUp();\n\n    /*!\n    * @brief Cleanup environment after execution of each test\n    *\n    * Does nothing.\n    *\n    */\n    void tearDown();\n\n    /*!\n    * @brief Check wait management behavior copy version\n    *\n    * 0) Create an int queue.\n    * 1) Spawn a waiting thread and wait for elements.\n    * 2) Disable waiting and check thread exits without any element being pushed.\n    * 3) Try to wait again and check that thread does not wait\n    * 4) Enable waiting and check that an element must be pushed for wait to end.\n    *\n    */\n    void waitManagementCopy();\n\n    /*!\n    * @brief Check wait management behavior move verion\n    *\n    * 0) Create an unique_ptr<int> queue.\n    * 1) Spawn a waiting thread and wait for elements.\n    * 2) Disable waiting and check thread exits without any element being pushed.\n    * 3) Try to wait again and check that thread does not wait\n    * 4) Enable waiting and check that an element must be pushed for wait to end.\n    *\n    */\n    void waitManagementMove();\n\n    /*!\n    * @brief Check wait management behavior when deleting queue\n    *\n    * 0) Create a pointer on unique_ptr<int> queue.\n    * 1) Spawn a waiting thread and wait for elements.\n    * 2) Delete existing queue.\n    * 3) Join waiting thread\n    *\n    * No test is really performed, the aim is simply to check no memory error are produced when deleting queue\n    *\n    */\n    void waitManagementDeletion();\n};\n\n#endif // DWF_QUEUE_WAIT_MANAGEMENT_TEST_H\n\n//  ______________________________\n// |                              |\n// |    ______________________    |\n// |   |                      |   |\n// |   |         Sign         |   |\n// |   |        C0ding        |   |\n// |   |        Dw@rf         |   |\n// |   |         1.0          |   |\n// |   |______________________|   |\n// |                              |\n// |______________________________|\n//               |  |\n//               |  |\n//               |  |\n//               |  |\n//               |  |\n//               |  |\n//               |  |\n//               |  |\n//               |  |\n//               |  |\n//               |__|\n\n", "comment_ratio": 0.12631578947368421}
{"lang": "c", "code": "#pragma once\n\n#include \"zeek-config.h\"\n#include <string>\n\nnamespace zeek { class String; }\nusing BroString [[deprecated(\"Remove in v4.1. Use zeek::String instead.\")]] = zeek::String;\n\nclass Connection;\n\n// Maybe we should have a base class for generic decoders?\nclass Base64Converter {\npublic:\n\t// <conn> is used for error reporting. If it is set to zero (as,\n\t// e.g., done by the built-in functions decode_base64() and\n\t// encode_base64()), encoding-errors will go to Reporter instead of\n\t// Weird. Usage errors go to Reporter in any case. Empty alphabet\n\t// indicates the default base64 alphabet.\n\texplicit Base64Converter(Connection* conn, const std::string& alphabet = \"\");\n\t~Base64Converter();\n\n\t// A note on Decode():\n\t//\n\t// The input is specified by <len> and <data> and the output\n\t// buffer by <blen> and <buf>.  If *buf is nil, a buffer of\n\t// an appropriate size will be new'd and *buf will point\n\t// to the buffer on return. *blen holds the length of\n\t// decoded data on return.  The function returns the number of\n\t// input bytes processed, since the decoding will stop when there\n\t// is not enough output buffer space.\n\n\tint Decode(int len, const char* data, int* blen, char** buf);\n\tvoid Encode(int len, const unsigned char* data, int* blen, char** buf);\n\n\tint Done(int* pblen, char** pbuf);\n\tbool HasData() const { return base64_group_next != 0; }\n\n\t// True if an error has occurred.\n\tint Errored() const\t{ return errored; }\n\n\tconst char* ErrorMsg() const\t{ return error_msg; }\n\tvoid IllegalEncoding(const char* msg);\n\nprotected:\n\tchar error_msg[256];\n\nprotected:\n\tstatic const std::string default_alphabet;\n\tstd::string alphabet;\n\n\tstatic int* InitBase64Table(const std::string& alphabet);\n\tstatic int default_base64_table[256];\n\tchar base64_group[4];\n\tint base64_group_next;\n\tint base64_padding;\n\tint base64_after_padding;\n\tint* base64_table;\n\tint errored;\t// if true, we encountered an error - skip further processing\n\tConnection* conn;\n\n};\n\nzeek::String* decode_base64(const zeek::String* s, const zeek::String* a = nullptr, Connection* conn = nullptr);\nzeek::String* encode_base64(const zeek::String* s, const zeek::String* a = nullptr, Connection* conn = nullptr);\n\n", "comment_ratio": 0.26153846153846155}
{"lang": "c", "code": "#include <assert.h>\n\n#include <immintrin.h>\n\n#include <xnnpack/common.h>\n#include <xnnpack/intrinsics-polyfill.h>\n#include <xnnpack/vbinary.h>\n\n\nvoid xnn_f32_vdiv_ukernel__avx512f_x16(\n    size_t n,\n    const float* a,\n    const float* b,\n    float* y,\n    const union xnn_f32_output_params params[restrict static 1])\n{\n  assert(n != 0);\n  assert(n % sizeof(float) == 0);\n\n  const __m512 vy_min = _mm512_broadcast_f32x4(_mm_load_ps(params->sse.min));\n  const __m512 vy_max = _mm512_broadcast_f32x4(_mm_load_ps(params->sse.max));\n\n  for (; n >= 16 * sizeof(float); n -= 16 * sizeof(float)) {\n    const __m512 va0123456789ABCDEF = _mm512_loadu_ps(a);\n    a += 16;\n\n    const __m512 vb0123456789ABCDEF = _mm512_loadu_ps(b);\n    b += 16;\n\n    __m512 vy0123456789ABCDEF = _mm512_div_ps(va0123456789ABCDEF, vb0123456789ABCDEF);\n\n    vy0123456789ABCDEF = _mm512_max_ps(vy0123456789ABCDEF, vy_min);\n\n    vy0123456789ABCDEF = _mm512_min_ps(vy0123456789ABCDEF, vy_max);\n\n    _mm512_storeu_ps(y, vy0123456789ABCDEF);\n    y += 16;\n  }\n  for (; n >= 16 * sizeof(float); n -= 16 * sizeof(float)) {\n    const __m512 va = _mm512_loadu_ps(a);\n    a += 16;\n\n    const __m512 vb = _mm512_loadu_ps(b);\n    b += 16;\n\n    __m512 vy = _mm512_div_ps(va, vb);\n    vy = _mm512_max_ps(vy, vy_min);\n    vy = _mm512_min_ps(vy, vy_max);\n    _mm512_storeu_ps(y, vy);\n    y += 16;\n  }\n  if XNN_UNLIKELY(n != 0) {\n    assert(n >= 1 * sizeof(float));\n    assert(n <= 15 * sizeof(float));\n    // Prepare mask for valid 32-bit elements (depends on n).\n    n >>= 2 /* log2(sizeof(float)) */;\n    const __mmask16 vmask = _cvtu32_mask16((uint16_t) ((uint32_t) (UINT32_C(1) << n) - UINT32_C(1)));\n\n    const __m512 va = _mm512_maskz_loadu_ps(vmask, a);\n    const __m512 vb = _mm512_maskz_loadu_ps(vmask, b);\n\n    __m512 vy = _mm512_div_ps(va, vb);\n    vy = _mm512_max_ps(vy, vy_min);\n    vy = _mm512_min_ps(vy, vy_max);\n    _mm512_mask_storeu_ps(y, vmask, vy);\n  }\n}\n\n", "comment_ratio": 0.11688311688311688}
{"lang": "c", "code": "4150 #include \"types.h\"\n4151 #include \"defs.h\"\n4152 #include \"param.h\"\n4153 #include \"spinlock.h\"\n4154 #include \"fs.h\"\n4155 #include \"buf.h\"\n4156 \n4157 // Simple logging. Each system call that might write the file system\n4158 // should be surrounded with begin_trans() and commit_trans() calls.\n4159 //\n4160 // The log holds at most one transaction at a time. Commit forces\n4161 // the log (with commit record) to disk, then installs the affected\n4162 // blocks to disk, then erases the log. begin_trans() ensures that\n4163 // only one system call can be in a transaction; others must wait.\n4164 //\n4165 // Allowing only one transaction at a time means that the file\n4166 // system code doesn't have to worry about the possibility of\n4167 // one transaction reading a block that another one has modified,\n4168 // for example an i-node block.\n4169 //\n4170 // Read-only system calls don't need to use transactions, though\n4171 // this means that they may observe uncommitted data. I-node and\n4172 // buffer locks prevent read-only calls from seeing inconsistent data.\n4173 //\n4174 // The log is a physical re-do log containing disk blocks.\n4175 // The on-disk log format:\n4176 //   header block, containing sector #s for block A, B, C, ...\n4177 //   block A\n4178 //   block B\n4179 //   block C\n4180 //   ...\n4181 // Log appends are synchronous.\n4182 \n4183 // Contents of the header block, used for both the on-disk header block\n4184 // and to keep track in memory of logged sector #s before commit.\n4185 struct logheader {\n4186   int n;\n4187   int sector[LOGSIZE];\n4188 };\n4189 \n4190 struct log {\n4191   struct spinlock lock;\n4192   int start;\n4193   int size;\n4194   int busy; // a transaction is active\n4195   int dev;\n4196   struct logheader lh;\n4197 };\n4198 \n4199 \n4200 struct log log;\n4201 \n4202 static void recover_from_log(void);\n4203 \n4204 void\n4205 initlog(void)\n4206 {\n4207   if (sizeof(struct logheader) >= BSIZE)\n4208     panic(\"initlog: too big logheader\");\n4209 \n4210   struct superblock sb;\n4211   initlock(&log.lock, \"log\");\n4212   readsb(ROOTDEV, &sb);\n4213   log.start = sb.size - sb.nlog;\n4214   log.size = sb.nlog;\n4215   log.dev = ROOTDEV;\n4216   recover_from_log();\n4217 }\n4218 \n4219 // Copy committed blocks from log to their home location\n4220 static void\n4221 install_trans(void)\n4222 {\n4223   int tail;\n4224 \n4225   for (tail = 0; tail < log.lh.n; tail++) {\n4226     struct buf *lbuf = bread(log.dev, log.start+tail+1); // read log block\n4227     struct buf *dbuf = bread(log.dev, log.lh.sector[tail]); // read dst\n4228     memmove(dbuf->data, lbuf->data, BSIZE);  // copy block to dst\n4229     bwrite(dbuf);  // write dst to disk\n4230     brelse(lbuf);\n4231     brelse(dbuf);\n4232   }\n4233 }\n4234 \n4235 // Read the log header from disk into the in-memory log header\n4236 static void\n4237 read_head(void)\n4238 {\n4239   struct buf *buf = bread(log.dev, log.start);\n4240   struct logheader *lh = (struct logheader *) (buf->data);\n4241   int i;\n4242   log.lh.n = lh->n;\n4243   for (i = 0; i < log.lh.n; i++) {\n4244     log.lh.sector[i] = lh->sector[i];\n4245   }\n4246   brelse(buf);\n4247 }\n4248 \n4249 \n4250 // Write in-memory log header to disk.\n4251 // This is the true point at which the\n4252 // current transaction commits.\n4253 static void\n4254 write_head(void)\n4255 {\n4256   struct buf *buf = bread(log.dev, log.start);\n4257   struct logheader *hb = (struct logheader *) (buf->data);\n4258   int i;\n4259   hb->n = log.lh.n;\n4260   for (i = 0; i < log.lh.n; i++) {\n4261     hb->sector[i] = log.lh.sector[i];\n4262   }\n4263   bwrite(buf);\n4264   brelse(buf);\n4265 }\n4266 \n4267 static void\n4268 recover_from_log(void)\n4269 {\n4270   read_head();\n4271   install_trans(); // if committed, copy from log to disk\n4272   log.lh.n = 0;\n4273   write_head(); // clear the log\n4274 }\n4275 \n4276 void\n4277 begin_trans(void)\n4278 {\n4279   acquire(&log.lock);\n4280   while (log.busy) {\n4281     sleep(&log, &log.lock);\n4282   }\n4283   log.busy = 1;\n4284   release(&log.lock);\n4285 }\n4286 \n4287 \n4288 \n4289 \n4290 \n4291 \n4292 \n4293 \n4294 \n4295 \n4296 \n4297 \n4298 \n4299 \n4300 void\n4301 commit_trans(void)\n4302 {\n4303   if (log.lh.n > 0) {\n4304     write_head();    // Write header to disk -- the real commit\n4305     install_trans(); // Now install writes to home locations\n4306     log.lh.n = 0;\n4307     write_head();    // Erase the transaction from the log\n4308   }\n4309 \n4310   acquire(&log.lock);\n4311   log.busy = 0;\n4312   wakeup(&log);\n4313   release(&log.lock);\n4314 }\n4315 \n4316 // Caller has modified b->data and is done with the buffer.\n4317 // Append the block to the log and record the block number,\n4318 // but don't write the log header (which would commit the write).\n4319 // log_write() replaces bwrite(); a typical use is:\n4320 //   bp = bread(...)\n4321 //   modify bp->data[]\n4322 //   log_write(bp)\n4323 //   brelse(bp)\n4324 void\n4325 log_write(struct buf *b)\n4326 {\n4327   int i;\n4328 \n4329   if (log.lh.n >= LOGSIZE || log.lh.n >= log.size - 1)\n4330     panic(\"too big a transaction\");\n4331   if (!log.busy)\n4332     panic(\"write outside of trans\");\n4333 \n4334   for (i = 0; i < log.lh.n; i++) {\n4335     if (log.lh.sector[i] == b->sector)   // log absorbtion?\n4336       break;\n4337   }\n4338   log.lh.sector[i] = b->sector;\n4339   struct buf *lbuf = bread(b->dev, log.start+i+1);\n4340   memmove(lbuf->data, b->data, BSIZE);\n4341   bwrite(lbuf);\n4342   brelse(lbuf);\n4343   if (i == log.lh.n)\n4344     log.lh.n++;\n4345   b->flags |= B_DIRTY; // XXX prevent eviction\n4346 }\n4347 \n4348 \n4349 \n4350 // Blank page.\n4351 \n4352 \n4353 \n4354 \n4355 \n4356 \n4357 \n4358 \n4359 \n4360 \n4361 \n4362 \n4363 \n4364 \n4365 \n4366 \n4367 \n4368 \n4369 \n4370 \n4371 \n4372 \n4373 \n4374 \n4375 \n4376 \n4377 \n4378 \n4379 \n4380 \n4381 \n4382 \n4383 \n4384 \n4385 \n4386 \n4387 \n4388 \n4389 \n4390 \n4391 \n4392 \n4393 \n4394 \n4395 \n4396 \n4397 \n4398 \n4399 \n\n", "comment_ratio": 0.21115537848605578}
{"lang": "c", "code": "\r\n#ifndef TRANSF_H\r\n#define TRANSF_H\r\n\r\nclass quater;\r\n\r\nclass transf\r\n{\r\n  private:\r\n    matrix m;\r\n    vector3 v;\r\n\r\n    // multiplication\r\n    friend transf&      operator*=( transf &, transf const& );\r\n    friend transf       operator*( transf const&, transf const& );\r\n    friend vector3&      operator*=( vector3&, transf const& );\r\n    friend vector3       operator*( vector3 const&, transf const& );\r\n    friend position&    operator*=( position&, transf const& );\r\n    friend position     operator*( position const&, transf const& );\r\n    friend unit_vector& operator*=( unit_vector&, transf const& );\r\n    friend unit_vector  operator*( unit_vector const&, transf const& );\r\n\r\n    // functions\r\n    friend transf       inverse( transf const& );\r\n    friend transf       interpolate( m_real, transf const&, transf const& );\r\n\r\n\tfriend void\t\t\ttransf2float16(transf const&, float[16]);\r\n\r\n\t// stream\r\n    friend ostream& operator<<( ostream&, transf const& );\r\n    friend istream& operator>>( istream&, transf& );\r\n\r\n  public:\r\n    // constructors\r\n    transf() {}\r\n    transf( matrix const& a, vector3 const& b ) { m = a; v = b; }\r\n    transf( quater const& a, vector3 const& b ) { m = Quater2Matrix(a); v = b; }\r\n\r\n    // inquiry functions\r\n    const matrix&\taffine() const { return m; };\r\n    const vector3&\ttranslation() const { return v; };\r\n    const matrix&\tgetAffine() const { return m; };\r\n    const vector3&\tgetTranslation() const { return v; };\r\n\tconst quater\tgetRotation() const { return Matrix2Quater(m); }\r\n\r\n\tvoid\t\t\tsetAffine( matrix const& a ) { m = a; }\r\n\tvoid\t\t\tsetTranslation( vector3 const& a ) { v = a; }\r\n\tvoid\t\t\tsetRotation(quater const& q) { m = Quater2Matrix(q); }\r\n\r\n    transf\t\t\tinverse() const;\r\n};\r\n\r\n// identity transform\r\nextern transf identity_transf;\r\n\r\n// generator\r\nextern transf scale_transf( m_real );\r\nextern transf scale_transf( m_real, m_real, m_real );\r\nextern transf rotate_transf( m_real, vector3 const& );\r\nextern transf reflect_transf( vector3 const& );\r\nextern transf translate_transf( vector3 const& );\r\nextern transf translate_transf( m_real, m_real, m_real );\r\nextern transf coordinate_transf( position const&,\r\n                  unit_vector const&, unit_vector const& );\r\n\r\n#endif\r\n\n", "comment_ratio": 0.1044776119402985}
{"lang": "c", "code": "#ifndef ManzariDafaliasRO_h\r\n#define ManzariDafaliasRO_h\r\n\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <math.h>\r\n\r\n#include <NDMaterial.h>\r\n#include <Matrix.h>\r\n#include <Vector.h>\r\n\r\n#include <Information.h>\r\n//#include <MaterialResponse.h>\r\n#include <Parameter.h>\r\n\r\n#include <Channel.h>\r\n#include <FEM_ObjectBroker.h>\r\n#include <string.h>\r\n\r\n#include \"ManzariDafalias.h\"\r\n\r\n#include <elementAPI.h>\r\n\r\nclass ManzariDafaliasRO : public ManzariDafalias\r\n{\r\n  public:\r\n\r\n    // full constructor\r\n    ManzariDafaliasRO(int tag, int classTag, double G0, double nu, double B, double a1, double gamma1, double e_init, double Mc, double c, \r\n\t\t\t\t\tdouble lambda_c, double e0, double ksi, double P_atm, double m, double h0, double ch, double nb, double A0, double nd, \r\n\t\t\t\t\tdouble z_max, double cz, double mDen, double kappa = 2.0, int integrationScheme = 2, int tangentType = 2, int JacoType = 1, \r\n\t\t\t\t\tdouble TolF = 1.0e-7, double TolR = 1.0e-7);\r\n    // null constructor\r\n    ManzariDafaliasRO();\r\n    // destructor\r\n    ~ManzariDafaliasRO();\r\n \r\n    NDMaterial *getCopy(const char *type);\r\n\r\n\tvoid integrate();\r\n    int commitState(void);\r\n\r\n    NDMaterial *getCopy(void);\r\n    const char *getType(void) const;\r\n\tint\t\t\tgetOrder (void) const;\r\n\r\n    int sendSelf(int commitTag, Channel &theChannel);  \r\n    int recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker); \r\n\r\n    void Print(OPS_Stream &s, int flag =0);\r\n\t\r\n  protected:\r\n\r\n\tdouble m_B;\r\n\tdouble m_a1;\r\n\tdouble m_gamma1;\r\n\tdouble m_kappa;\r\n\t\r\n\t// internal variables\r\n\tVector mDevEpsSR;\t// deviatoric strain at shear reversal point\r\n\tVector mSigmaSR;\t// stress at shear reversal point\r\n\tdouble mChi_r;\t\t// Chi_r Ramberg-Osgood parameter\r\n\tdouble mDChi_e;\t\t// change in Chi_e Ramberg-Osgood parameter\r\n\tdouble mEta1;\t\t// eta1 Ramber-Osgood parameter\r\n\tbool   mIsFirstShear; // boolean to determine if it's first shearing\r\n\r\n\t//Member Functions specific for ManzariDafaliasRO model\r\n\tvoid\tinitialize();\r\n\tvoid\tGetElasticModuli(const Vector& sigma, const double& en, const double& en1,\r\n\t\t\t\tconst Vector& nEStrain, const Vector& cEStrain, double &K, \r\n\t\t\t\tdouble &G);\r\n\tvoid\tGetElasticModuli(const Vector& sigma, const double& en, double &K, double &G);\r\n};\r\n\r\n#endif\r\n\n", "comment_ratio": 0.1485148514851485}
{"lang": "c", "code": "#import <AppKit/NSButton.h>\n\n#import <Safari/ButtonInTabSyncGroup-Protocol.h>\n#import <Safari/NSDraggingDestination-Protocol.h>\n#import <Safari/NSMenuDelegate-Protocol.h>\n\n@class CALayer, NSColor, NSString, NSTrackingArea;\n@protocol ButtonInTabSyncGroupDelegate;\n\n__attribute__((visibility(\"hidden\")))\n@interface NewTabButton : NSButton <NSMenuDelegate, NSDraggingDestination, ButtonInTabSyncGroup>\n{\n    NSTrackingArea *_trackingArea;\n    NSColor *_backgroundColor;\n    CALayer *_topBorderLayer;\n    CALayer *_leadingBorderLayer;\n    CALayer *_backgroundLayer;\n    BOOL _mouseIsOverButton;\n    BOOL _syncedWithOtherButton;\n    BOOL _forcesActiveWindowState;\n    id <ButtonInTabSyncGroupDelegate> _buttonInTabSyncGroupDelegate;\n}\n\n+ (double)width;\n+ (id)installNewTabButtonInView:(id)arg1;\n+ (void)initialize;\n@property(nonatomic) BOOL forcesActiveWindowState; // @synthesize forcesActiveWindowState=_forcesActiveWindowState;\n@property(nonatomic, getter=isSyncedWithOtherButton) BOOL syncedWithOtherButton; // @synthesize syncedWithOtherButton=_syncedWithOtherButton;\n@property(nonatomic) __weak id <ButtonInTabSyncGroupDelegate> buttonInTabSyncGroupDelegate; // @synthesize buttonInTabSyncGroupDelegate=_buttonInTabSyncGroupDelegate;\n- (void).cxx_destruct;\n- (void)setHighlightStateToPressed:(BOOL)arg1 hovered:(BOOL)arg2;\n- (unsigned long long)_draggedURLOperationForDraggingInfo:(id)arg1;\n- (void)concludeDragOperation:(id)arg1;\n- (BOOL)performDragOperation:(id)arg1;\n- (unsigned long long)draggingEntered:(id)arg1;\n- (BOOL)_windowIsActive;\n- (void)_windowChangedKeyState;\n- (id)_topBorderDefaultColor;\n- (id)_leadingBorderDefaultColor;\n- (id)_backgroundDefaultColor;\n- (void)_updateButtonColors;\n- (void)awakeFromNib;\n- (void)mouseExited:(id)arg1;\n- (void)mouseEntered:(id)arg1;\n- (void)mouseDown:(id)arg1;\n- (BOOL)acceptsFirstMouse:(id)arg1;\n- (void)layout;\n- (void)_finishInitialization;\n- (void)menuDidClose:(id)arg1;\n- (void)_setLeadingBorderColor:(id)arg1 topBorderColor:(id)arg2 withAnimation:(id)arg3;\n- (void)_setBackgroundColor:(id)arg1 withAnimation:(id)arg2;\n- (void)_updateButtonHighlightWhenPressed:(BOOL)arg1 hovered:(BOOL)arg2 notifyButtonInTabSyncGroupDelegate:(BOOL)arg3;\n- (void)_updateButtonHighlightWhenPressed:(BOOL)arg1 hovered:(BOOL)arg2;\n- (BOOL)allowsVibrancy;\n- (id)initWithFrame:(struct CGRect)arg1;\n- (id)init;\n- (id)menuForEvent:(id)arg1;\n\n// Remaining properties\n@property(readonly, copy) NSString *debugDescription;\n@property(readonly, copy) NSString *description;\n@property(readonly) unsigned long long hash;\n@property(readonly) Class superclass;\n\n@end\n\n\n", "comment_ratio": 0.1232876712328767}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n#import \"UINavigationController+TZM.h\"\n\ntypedef enum : NSUInteger {\n    GSHYingShiDeviceWifiLinkVCTypeWIFI,\n    GSHYingShiDeviceWifiLinkVCTypeWAVE,\n} GSHYingShiDeviceWifiLinkVCType;\n\n@interface GSHYingShiDeviceWifiLinkVC : UIViewController\n+(instancetype)configWifiLinkVCWithDevice:(GSHDeviceM*)device type:(GSHYingShiDeviceWifiLinkVCType)type wifiName:(NSString*)wifiName wifiPassWord:(NSString*)wifiPassWord;\n@end\n\n", "comment_ratio": 0.35}
{"lang": "c", "code": "#ifndef GLUTILS_H\n#define GLUTILS_H\n\n#include <QPolygonF>\n#include <QRectF>\n\n#include <Eigen/Core>\n\nclass QOpenGLTexture;\n\nclass GLUtils\n{\npublic:\n    /// This function must be called before creating the first\n    /// OpenGLWidget. It sets the appropriate Qt OpenGLFormat and\n    /// sets the Qt::AA_UseDesktopOpenGL attribute.\n    static void init();\n\n    //static void UnitCircleZ();\n    //static void UnitSphere();\n    //static void Sphere(double radius);\n    static void multMatrix_RectInsideRect(const QRectF & rect1,\n                              const QRectF & rect2);\n    static void multMatrix_RectToRect(const QRectF & rect1,\n                            const QRectF & rect2);\n    static void multMatrix_QuadToQuad(const QPolygonF & quad1,\n                            const QPolygonF & quad2);\n\n    static void drawX(double x1, double y1, double z1, \n                double x2, double y2, double z2, \n                double x3, double y3, double z3, \n                double x4, double y4, double z4);\n    static void drawY(double x1, double y1, double z1, \n                double x2, double y2, double z2, \n                double x3, double y3, double z3, \n                double x4, double y4, double z4);\n    static void drawTime(double x1, double y1, double z1, \n                   double x2, double y2, double z2, \n                   double x3, double y3, double z3, \n                   double x4, double y4, double z4);\n\n    static void drawArrow(const Eigen::Vector2d & p, const Eigen::Vector2d & u);\n    \nprivate:\n    // drawing text\n    static QOpenGLTexture * genTex(const QString & filename);\n    static void drawTex(QOpenGLTexture * tex,\n                   double x1, double y1, double z1, \n                   double x2, double y2, double z2, \n                   double x3, double y3, double z3, \n                   double x4, double y4, double z4);\n    static QOpenGLTexture * textureX;\n    static QOpenGLTexture * textureY;\n    static QOpenGLTexture * textureTime;\n};\n\n#endif\n\n", "comment_ratio": 0.2972972972972973}
{"lang": "c", "code": "#ifndef __vtkSQLineSource_h\n#define __vtkSQLineSource_h\n\n#include \"vtkSciberQuestModule.h\" // for export macro\n#include \"vtkPolyDataAlgorithm.h\"\n\nclass VTKSCIBERQUEST_EXPORT vtkSQLineSource : public vtkPolyDataAlgorithm\n{\npublic:\n  static vtkSQLineSource *New();\n  vtkTypeMacro(vtkSQLineSource,vtkPolyDataAlgorithm);\n  void PrintSelf(ostream& os, vtkIndent indent);\n\n  // Description:\n  // Set position of first end point.\n  vtkSetVector3Macro(Point1,double);\n  vtkGetVectorMacro(Point1,double,3);\n\n  // Description:\n  // Set position of other end point.\n  vtkSetVector3Macro(Point2,double);\n  vtkGetVectorMacro(Point2,double,3);\n\n  // Description:\n  // Divide line into resolution number of pieces.\n  vtkSetClampMacro(Resolution,int,1,VTK_INT_MAX);\n  vtkGetMacro(Resolution,int);\n\nprotected:\n  vtkSQLineSource(int res=1);\n  ~vtkSQLineSource() {};\n\n  int RequestData(vtkInformation *, vtkInformationVector **, vtkInformationVector *);\n  int RequestInformation(vtkInformation *, vtkInformationVector **, vtkInformationVector *);\n  double Point1[3];\n  double Point2[3];\n  int Resolution;\nprivate:\n  vtkSQLineSource(const vtkSQLineSource&);  // Not implemented.\n  void operator=(const vtkSQLineSource&);  // Not implemented.\n};\n\n#endif\n\n", "comment_ratio": 0.26666666666666666}
{"lang": "c", "code": "#ifndef PIVX_KEY_IO_SAPLING_H\n#define PIVX_KEY_IO_SAPLING_H\n\n#include \"chainparams.h\"\n#include \"sapling/zip32.h\"\n\nnamespace KeyIO {\n\n    std::string EncodePaymentAddress(const libzcash::PaymentAddress& zaddr);\n    libzcash::PaymentAddress DecodePaymentAddress(const std::string& str);\n    Optional<libzcash::SaplingPaymentAddress> DecodeSaplingPaymentAddress(const std::string& str);\n    bool IsValidPaymentAddressString(const std::string& str);\n\n    std::string EncodeViewingKey(const libzcash::ViewingKey& vk);\n    libzcash::ViewingKey DecodeViewingKey(const std::string& str);\n\n    std::string EncodeSpendingKey(const libzcash::SpendingKey& zkey);\n    libzcash::SpendingKey DecodeSpendingKey(const std::string& str);\n}\n\n#endif //PIVX_KEY_IO_SAPLING_H\n\n", "comment_ratio": 0.18518518518518517}
{"lang": "c", "code": "#include \"under_test.h\"\n\n#include \"to_mock.h\"\n\n#include <gtest/gtest.h>\n\n#define UNDER_TEST_TEST_SUITE_NAME UnderTestTest\n\nTEST(UNDER_TEST_TEST_SUITE_NAME, ArrayInputFixedSizeTest) {\n    // given:\n    mock_to_mock_set_up();\n\n    int input[2] = {2, 3};\n    int output = 1;\n    when_to_mock_compute_fixed_size( // expected input parameters\n        input // input\n    )\n    ->then_provide_output(&output, 1)  // provided output parameter\n    ->then_return(TO_MOCK_ERR_OK); // return value\n\n    // when:\n    int result = do_something_fixed_size(0);\n\n    // then:\n    ASSERT_EQ(1, result);\n\n    // finally:\n    mock_to_mock_tear_down();\n}\n\nTEST(UNDER_TEST_TEST_SUITE_NAME, ArrayInputNullTerminatedTest) {\n    // given:\n    mock_to_mock_set_up();\n\n    char input_to_ignore[3] = {'a', 'c', '\\0'};\n    int output_to_ignore = 5;\n    when_to_mock_compute_null_terminated( // expected input parameters\n        input_to_ignore // input\n    )\n    ->then_provide_output(&output_to_ignore, 1)  // provided output parameter\n    ->then_return(TO_MOCK_ERR_OK); // return value\n\n    char input_to_ignore2[2] = {'a', '\\0'};\n    int output_to_ignore2 = 6;\n    when_to_mock_compute_null_terminated( // expected input parameters\n        input_to_ignore2 // input\n    )\n    ->then_provide_output(&output_to_ignore2, 1)  // provided output parameter\n    ->then_return(TO_MOCK_ERR_OK); // return value\n\n    char input[3] = {'a', 'b', '\\0'};\n    int output = 2;\n    when_to_mock_compute_null_terminated( // expected input parameters\n        input // input\n    )\n    ->then_provide_output(&output, 1)  // provided output parameter\n    ->then_return(TO_MOCK_ERR_OK); // return value\n\n    // when:\n    int result = do_something_null_terminated('a', 'b');\n\n    // then:\n    ASSERT_EQ(2, result);\n\n    // finally:\n    mock_to_mock_tear_down();\n}\n\nTEST(UNDER_TEST_TEST_SUITE_NAME, ArrayInputNullTerminatedTwiceTest) {\n    // given:\n    mock_to_mock_set_up();\n\n    char input1[2] = {'a', '\\0'};\n    int input2[3] = {5, 6, 0};\n    int output = 2;\n    when_to_mock_compute_null_terminated_twice(\n        input1,\n        input2\n    )\n    ->then_provide_output(&output, 1)\n    ->then_return(TO_MOCK_ERR_OK);\n\n    // when:\n    int result = do_something_null_terminated_twice('a', 5);\n\n    // then:\n    ASSERT_EQ(2, result);\n\n    // finally:\n    mock_to_mock_tear_down();\n}\n\nTEST(UNDER_TEST_TEST_SUITE_NAME, ArrayInputLengthDescribedTest) {\n    // given:\n    mock_to_mock_set_up();\n\n    int input[3] = {5, 6, 0};\n    int output = 7;\n    when_to_mock_compute_length_described(\n        input,\n        3\n    )\n    ->then_provide_output(&output, 1)\n    ->then_return(TO_MOCK_ERR_OK);\n\n    // when:\n    int result = do_something_length_described(0, 5);\n\n    // then:\n    ASSERT_EQ(7, result);\n\n    // finally:\n    mock_to_mock_tear_down();\n}\n\nTEST(UNDER_TEST_TEST_SUITE_NAME, ArrayInputLengthDescribedMatchCorrectByContentTest) {\n    // given:\n    mock_to_mock_set_up();\n\n    int alt_input[3] = {1, 2, 3};\n    int alt_output = 4;\n    when_to_mock_compute_length_described(\n        alt_input,\n        3\n    )\n    ->then_provide_output(&alt_output, 1)\n    ->then_return(TO_MOCK_ERR_OK);\n\n    int input[3] = {5, 6, 0};\n    int output = 7;\n    when_to_mock_compute_length_described(\n        input,\n        3\n    )\n    ->then_provide_output(&output, 1)\n    ->then_return(TO_MOCK_ERR_OK);\n\n    // when:\n    int result = do_something_length_described(0, 5);\n\n    // then:\n    ASSERT_EQ(7, result);\n\n    // finally:\n    mock_to_mock_tear_down();\n}\n\nTEST(UNDER_TEST_TEST_SUITE_NAME, ArrayInputLengthDescribedMatchCorrectByLengthTest) {\n    // given:\n    mock_to_mock_set_up();\n\n    int input_to_ignore[2] = {5, 6};\n    int output_to_ignore = 4;\n    when_to_mock_compute_length_described(\n        input_to_ignore,\n        2\n    )\n    ->then_provide_output(&output_to_ignore, 1)\n    ->then_return(TO_MOCK_ERR_OK);\n\n    int input[3] = {5, 6, 0};\n    int output = 7;\n    when_to_mock_compute_length_described(\n        input,\n        3\n    )\n    ->then_provide_output(&output, 1)\n    ->then_return(TO_MOCK_ERR_OK);\n\n    // when:\n    int result = do_something_length_described(0, 5);\n\n    // then:\n    ASSERT_EQ(7, result);\n\n    // finally:\n    mock_to_mock_tear_down();\n}\n\nTEST(UNDER_TEST_TEST_SUITE_NAME, ArrayInputUtf8StringComparisonTest) {\n    // given:\n    mock_to_mock_set_up();\n\n    wchar_t input[3] = L\"ab\";\n    int output = 7;\n    when_to_mock_compute_utf8(\n        input\n    )\n    ->then_provide_output(&output, 1)\n    ->then_return(TO_MOCK_ERR_OK);\n\n    // when:\n    int result = do_something_utf8(L'a', L'b');\n\n    // then:\n    ASSERT_EQ(7, result);\n\n    // finally:\n    mock_to_mock_tear_down();\n}\n\n", "comment_ratio": 0.21890547263681592}
{"lang": "c", "code": "#pragma once\n\n#include <iosfwd>\n\n#include \"BitFunnel/BitFunnelTypes.h\"\n#include \"BitFunnel/NonCopyable.h\"\n#include \"FixedCapacityVector.h\"\n#include \"IPlanRows.h\"\n\n\nnamespace BitFunnel\n{\n    class ISimpleIndex;\n    class IInputStream;\n\n\n    class PlanRows : public IPlanRows, NonCopyable\n    {\n    public:\n        PlanRows(const ISimpleIndex& index);\n\n        // Constructs PlanRows from data previously persisted to a stream by\n        // the Write() method.\n        PlanRows(IInputStream& stream, const ISimpleIndex& index);\n\n        virtual ~PlanRows();\n\n        //\n        // IPlanRows methods\n        //\n\n        ShardId GetShardCount() const;\n        unsigned GetRowCount() const;\n\n        const ITermTable& GetTermTable(ShardId shard) const;\n\n        // Check if the number of rows in the PlanRows has\n        // reached the limit as returned by GetRowCountLimit().\n        bool IsFull() const;\n\n        AbstractRow AddRow(Rank rank);\n\n        RowId const & PhysicalRow(ShardId shard, unsigned id) const;\n        RowId& PhysicalRow(ShardId shard, unsigned id);\n\n        // Writes the PlanRows data to a stream.\n        void Write(std::ostream& stream) const;\n\n    protected:\n\n        virtual unsigned GetRowCountLimit() const;\n\n    private:\n        class Entry\n        {\n        public:\n            Entry(unsigned id, Rank rank);\n\n            Entry(IInputStream& stream);\n\n            unsigned GetId() const;\n            Rank GetRank() const;\n\n            RowId& operator[](ShardId shard);\n            const RowId& operator[](ShardId shard) const;\n\n            void Write(std::ostream& stream) const;\n\n        private:\n            unsigned m_id;\n            Rank m_rank;\n            RowId m_rowIds[c_maxShardIdCount];\n        };\n\n        const ISimpleIndex& m_index;\n\n        FixedCapacityVector<Entry, c_maxRowsPerQuery> m_rows;\n    };\n}\n\n", "comment_ratio": 0.24271844660194175}
{"lang": "c", "code": "#ifndef WEBRTC_MODULES_AUDIO_CODING_NETEQ_INCLUDE_AUDIO_DECODER_H_\n#define WEBRTC_MODULES_AUDIO_CODING_NETEQ_INCLUDE_AUDIO_DECODER_H_\n\n#include <stdlib.h>  // NULL\n\n#include \"webrtc/base/constructormagic.h\"\n#include \"webrtc/modules/audio_coding/codecs/cng/webrtc_cng.h\"\n#include \"webrtc/typedefs.h\"\n\nnamespace webrtc {\n\n// This is the interface class for decoders in NetEQ. Each codec type will have\n// and implementation of this class.\nclass AudioDecoder {\n public:\n  enum SpeechType {\n    kSpeech = 1,\n    kComfortNoise = 2\n  };\n\n  // Used by PacketDuration below. Save the value -1 for errors.\n  enum { kNotImplemented = -2 };\n\n  AudioDecoder() = default;\n  virtual ~AudioDecoder() = default;\n\n  // Decodes |encode_len| bytes from |encoded| and writes the result in\n  // |decoded|. The maximum bytes allowed to be written into |decoded| is\n  // |max_decoded_bytes|. Returns the total number of samples across all\n  // channels. If the decoder produced comfort noise, |speech_type|\n  // is set to kComfortNoise, otherwise it is kSpeech. The desired output\n  // sample rate is provided in |sample_rate_hz|, which must be valid for the\n  // codec at hand.\n  int Decode(const uint8_t* encoded,\n             size_t encoded_len,\n             int sample_rate_hz,\n             size_t max_decoded_bytes,\n             int16_t* decoded,\n             SpeechType* speech_type);\n\n  // Same as Decode(), but interfaces to the decoders redundant decode function.\n  // The default implementation simply calls the regular Decode() method.\n  int DecodeRedundant(const uint8_t* encoded,\n                      size_t encoded_len,\n                      int sample_rate_hz,\n                      size_t max_decoded_bytes,\n                      int16_t* decoded,\n                      SpeechType* speech_type);\n\n  // Indicates if the decoder implements the DecodePlc method.\n  virtual bool HasDecodePlc() const;\n\n  // Calls the packet-loss concealment of the decoder to update the state after\n  // one or several lost packets. The caller has to make sure that the\n  // memory allocated in |decoded| should accommodate |num_frames| frames.\n  virtual size_t DecodePlc(size_t num_frames, int16_t* decoded);\n\n  // Resets the decoder state (empty buffers etc.).\n  virtual void Reset() = 0;\n\n  // Notifies the decoder of an incoming packet to NetEQ.\n  virtual int IncomingPacket(const uint8_t* payload,\n                             size_t payload_len,\n                             uint16_t rtp_sequence_number,\n                             uint32_t rtp_timestamp,\n                             uint32_t arrival_timestamp);\n\n  // Returns the last error code from the decoder.\n  virtual int ErrorCode();\n\n  // Returns the duration in samples-per-channel of the payload in |encoded|\n  // which is |encoded_len| bytes long. Returns kNotImplemented if no duration\n  // estimate is available, or -1 in case of an error.\n  virtual int PacketDuration(const uint8_t* encoded, size_t encoded_len) const;\n\n  // Returns the duration in samples-per-channel of the redandant payload in\n  // |encoded| which is |encoded_len| bytes long. Returns kNotImplemented if no\n  // duration estimate is available, or -1 in case of an error.\n  virtual int PacketDurationRedundant(const uint8_t* encoded,\n                                      size_t encoded_len) const;\n\n  // Detects whether a packet has forward error correction. The packet is\n  // comprised of the samples in |encoded| which is |encoded_len| bytes long.\n  // Returns true if the packet has FEC and false otherwise.\n  virtual bool PacketHasFec(const uint8_t* encoded, size_t encoded_len) const;\n\n  // If this is a CNG decoder, return the underlying CNG_dec_inst*. If this\n  // isn't a CNG decoder, don't call this method.\n  virtual CNG_dec_inst* CngDecoderInstance();\n\n  virtual size_t Channels() const = 0;\n\n protected:\n  static SpeechType ConvertSpeechType(int16_t type);\n\n  virtual int DecodeInternal(const uint8_t* encoded,\n                             size_t encoded_len,\n                             int sample_rate_hz,\n                             int16_t* decoded,\n                             SpeechType* speech_type) = 0;\n\n  virtual int DecodeRedundantInternal(const uint8_t* encoded,\n                                      size_t encoded_len,\n                                      int sample_rate_hz,\n                                      int16_t* decoded,\n                                      SpeechType* speech_type);\n\n private:\n  RTC_DISALLOW_COPY_AND_ASSIGN(AudioDecoder);\n};\n\n}  // namespace webrtc\n#endif  // WEBRTC_MODULES_AUDIO_CODING_NETEQ_INCLUDE_AUDIO_DECODER_H_\n\n", "comment_ratio": 0.2661290322580645}
{"lang": "c", "code": "#ifndef QT3DRENDER_RENDER_RENDERTARGETSELECTOR_H\n#define QT3DRENDER_RENDER_RENDERTARGETSELECTOR_H\n\n//\n//  W A R N I N G\n//  -------------\n//\n// This file is not part of the Qt API.  It exists for the convenience\n// of other Qt classes.  This header file may change from version to\n// version without notice, or even be removed.\n//\n// We mean it.\n//\n\n#include <Qt3DRender/private/framegraphnode_p.h>\n\nQT_BEGIN_NAMESPACE\n\nnamespace Qt3DRender {\n\nclass QRenderTargetSelector;\n\nnamespace Render {\n\nclass RenderTargetSelector : public FrameGraphNode\n{\npublic:\n    RenderTargetSelector();\n\n    void sceneChangeEvent(const Qt3DCore::QSceneChangePtr &e) override;\n\n    Qt3DCore::QNodeId renderTargetUuid() const { return m_renderTargetUuid; }\n    QVector<QRenderTargetOutput::AttachmentPoint> outputs() const { return m_outputs; }\n\nprivate:\n    void initializeFromPeer(const Qt3DCore::QNodeCreatedChangeBasePtr &change) final;\n\n    Qt3DCore::QNodeId m_renderTargetUuid;\n    QVector<QRenderTargetOutput::AttachmentPoint> m_outputs;\n};\n\n} // namespace Render\n} // namespace Qt3DRender\n\nQT_END_NAMESPACE\n\n#endif // QT3DRENDER_RENDER_RENDERTARGETSELECTOR_H\n\n", "comment_ratio": 0.21839080459770116}
{"lang": "c", "code": "#import \"UITableViewCell.h\"\n\n@class UIButton, UIScrollView;\n\n@interface MSCMoreOptionTableViewCell : UITableViewCell\n{\n    id <MSCMoreOptionTableViewCellDelegate> _delegate;\n    UIButton *_moreOptionButton;\n    UIScrollView *_cellScrollView;\n}\n\n- (void).cxx_destruct;\n@property(retain, nonatomic) UIScrollView *cellScrollView; // @synthesize cellScrollView=_cellScrollView;\n- (void)dealloc;\n@property(nonatomic) __weak id <MSCMoreOptionTableViewCellDelegate> delegate; // @synthesize delegate=_delegate;\n- (id)deleteButtonFromDeleteConfirmationView:(id)arg1;\n- (id)initWithCoder:(id)arg1;\n- (id)initWithStyle:(int)arg1 reuseIdentifier:(id)arg2;\n@property(retain, nonatomic) UIButton *moreOptionButton; // @synthesize moreOptionButton=_moreOptionButton;\n- (void)moreOptionButtonPressed:(id)arg1;\n- (void)observeValueForKeyPath:(id)arg1 ofObject:(id)arg2 change:(id)arg3 context:(void *)arg4;\n- (void)setMoreOptionButtonTitle:(id)arg1 inDeleteConfirmationView:(id)arg2;\n- (void)setupMoreOption;\n- (id)tableView;\n\n@end\n\n\n", "comment_ratio": 0.23529411764705882}
{"lang": "c", "code": "#include <stdlib.h>\n\n#ifdef __APPLE__\n#include <GLUT/glut.h>\n#else\n#include <GL/glut.h>\n#endif\n\n// all variables initialized to 1.0, meaning\n// the triangle will initially be white\nfloat red=1.0f, blue=1.0f, green=1.0f;\n\n// angle for rotating triangle\nfloat angle = 0.0f;\n\nvoid changeSize(int w, int h) {\n\n\t// Prevent a divide by zero, when window is too short\n\t// (you cant make a window of zero width).\n\tif (h == 0)\n\t\th = 1;\n\tfloat ratio =  w * 1.0 / h;\n\n        // Use the Projection Matrix\n\tglMatrixMode(GL_PROJECTION);\n\n        // Reset Matrix\n\tglLoadIdentity();\n\n\t// Set the viewport to be the entire window\n\tglViewport(0, 0, w, h);\n\n\t// Set the correct perspective.\n\tgluPerspective(45.0f, ratio, 0.1f, 100.0f);\n\n\t// Get Back to the Modelview\n\tglMatrixMode(GL_MODELVIEW);\n}\n\nvoid renderScene(void) {\n\n\t// Clear Color and Depth Buffers\n\tglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n\t// Reset transformations\n\tglLoadIdentity();\n\n\t// Set the camera\n\tgluLookAt(\t0.0f, 0.0f, 10.0f,\n\t\t\t0.0f, 0.0f,  0.0f,\n\t\t\t0.0f, 1.0f,  0.0f);\n\n\tglRotatef(angle, 0.0f, 1.0f, 0.0f);\n\n\tglColor3f(red,green,blue);\n\tglBegin(GL_TRIANGLES);\n\t\tglVertex3f(-2.0f,-2.0f, 0.0f);\n\t\tglVertex3f( 2.0f, 0.0f, 0.0);\n\t\tglVertex3f( 0.0f, 2.0f, 0.0);\n\tglEnd();\n\n\tangle+=0.1f;\n\n\tglutSwapBuffers();\n}\n\nvoid processNormalKeys(unsigned char key, int x, int y) {\n\n\tif (key == 27)\n\t\texit(0);\n}\n\nvoid processSpecialKeys(int key, int x, int y) {\n\n\tswitch(key) {\n\t\tcase GLUT_KEY_F1 :\n\t\t\t\tred = 1.0;\n\t\t\t\tgreen = 0.0;\n\t\t\t\tblue = 0.0; break;\n\t\tcase GLUT_KEY_F2 :\n\t\t\t\tred = 0.0;\n\t\t\t\tgreen = 1.0;\n\t\t\t\tblue = 0.0; break;\n\t\tcase GLUT_KEY_F3 :\n\t\t\t\tred = 0.0;\n\t\t\t\tgreen = 0.0;\n\t\t\t\tblue = 1.0; break;\n\t}\n}\n\nint main(int argc, char **argv) {\n\n\t// init GLUT and create window\n\tglutInit(&argc, argv);\n\tglutInitDisplayMode(GLUT_DEPTH | GLUT_DOUBLE | GLUT_RGBA);\n\tglutInitWindowPosition(100,100);\n\tglutInitWindowSize(320,320);\n\tglutCreateWindow(\"Lighthouse3D- GLUT Tutorial\");\n\n\t// register callbacks\n\tglutDisplayFunc(renderScene);\n\tglutReshapeFunc(changeSize);\n\tglutIdleFunc(renderScene);\n\n\t// here are the new entries\n\tglutKeyboardFunc(processNormalKeys);\n\tglutSpecialFunc(processSpecialKeys);\n\n\t// enter GLUT event processing cycle\n\tglutMainLoop();\n\n\treturn 1;\n}\n", "comment_ratio": 0.1504424778761062}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n#import <UIKit/UIKit.h>\n#import \"DemoUtils.h\"\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface ViewBuilder : NSObject\n\n+ (UIView *)buildView;\n\n+ (UILabel *)buildLbl01;\n\n+ (UITextField *)buildTxt01;\n\n+ (UITableView *)buildTableView;\n\n@end\n\nNS_ASSUME_NONNULL_END\n\n", "comment_ratio": 0.25}
{"lang": "c", "code": "#pragma once\n\n#include <memory>\n#include <mutex>\n#include <unordered_map>\n#include <curl/curl.h>\n#include \"http_agent_interface.h\"\n\n#define DO_HTTP_RANGEREQUEST_STR_LEN    48              // two 64bit numbers plus a '-' character (20 digits in UINT64)\n\nclass CurlRequests;\n\nclass HttpAgent : public IHttpAgent\n{\npublic:\n    HttpAgent(CurlRequests& curlOps, IHttpAgentEvents& callback);\n    ~HttpAgent();\n\n    static bool IsClientError(UINT httpStatusCode);\n    static std::array<char, DO_HTTP_RANGEREQUEST_STR_LEN> MakeRange(UINT64 startOffset, UINT64 lengthBytes);\n    static bool ValidateUrl(const std::string& url);\n\n    // IHttpAgent\n\n    HRESULT SendRequest(PCSTR szUrl = nullptr, PCSTR szProxyUrl = nullptr, PCSTR szRange = nullptr) override;\n    void Close() override;\n\n    // The Query* functions are supposed to be called only from within the IHttpAgentEvents callbacks\n    // function because the httpContext (which is the request handle) must be valid.\n    HRESULT QueryStatusCode(_Out_ UINT* pStatusCode) const override;\n    HRESULT QueryContentLength(_Out_ UINT64* pContentLength) override;\n    HRESULT QueryContentLengthFromRange(_Out_ UINT64* pContentLength) override;\n    HRESULT QueryHeaders(_In_opt_z_ PCSTR pszName, std::string& headers) const noexcept override;\n    HRESULT QueryHeadersByType(HttpAgentHeaders type, std::string& headers) noexcept override;\n\nprivate:\n    mutable std::recursive_mutex _requestLock;\n\n    CurlRequests& _curlOps;\n    IHttpAgentEvents& _callback;\n    UINT64 _callbackContext { 0 };\n\n    // Current usage pattern is to create only one request at a time.\n    // Holding a single request context is sufficient.\n    struct RequestContext\n    {\n        CURL* curlHandle;\n        struct curl_slist* requestHeaders;\n\n        unsigned int responseStatusCode;\n        HRESULT hrTranslatedStatusCode;\n        std::unordered_map<std::string, std::string> responseHeaders;\n        bool responseOnHeadersAvailableInvoked;\n        bool responseOnCompleteInvoked;\n\n        ~RequestContext()\n        {\n            curl_slist_free_all(requestHeaders);\n        }\n    };\n\n    RequestContext _requestContext {};\n\nprivate:\n    HRESULT _CreateClient(PCSTR szUrl = nullptr, PCSTR szProxyUrl = nullptr);\n    static HRESULT _ResultFromStatusCode(unsigned int code);\n    void _SetWebProxyFromProxyUrl(_In_opt_ PCSTR szProxyUrl);\n\n    size_t _HeaderCallback(char* pBuffer, size_t size, size_t nItems);\n    size_t _WriteCallback(char* pBuffer, size_t size, size_t nMemb);\n    void _CompleteCallback(int curlResult);\n    void _TrySetStatusCodeAndInvokeOnHeadersAvailable();\n\n    // libcurl callbacks\n    static size_t s_HeaderCallback(char* pBuffer, size_t size, size_t nItems, void* pUserData)\n    {\n        return reinterpret_cast<HttpAgent*>(pUserData)->_HeaderCallback(pBuffer, size, nItems);\n    }\n\n    static size_t s_WriteCallback(char* pBuffer, size_t size, size_t nMemb, void* pUserData)\n    {\n        return reinterpret_cast<HttpAgent*>(pUserData)->_WriteCallback(pBuffer, size, nMemb);\n    }\n\n    // CurlRequests callback\n    static void s_CompleteCallback(int curlResult, void* pUserData)\n    {\n        return reinterpret_cast<HttpAgent*>(pUserData)->_CompleteCallback(curlResult);\n    }\n};\n\n", "comment_ratio": 0.10638297872340426}
{"lang": "c", "code": "// Generated by the protocol buffer compiler.  DO NOT EDIT!\n// source: Qot_RequestHistoryKLQuota.proto\n\n#ifndef PROTOBUF_Qot_5fRequestHistoryKLQuota_2eproto__INCLUDED\n#define PROTOBUF_Qot_5fRequestHistoryKLQuota_2eproto__INCLUDED\n\n#include <string>\n\n#include <google/protobuf/stubs/common.h>\n\n#if GOOGLE_PROTOBUF_VERSION < 3005000\n#error This file was generated by a newer version of protoc which is\n#error incompatible with your Protocol Buffer headers.  Please update\n#error your headers.\n#endif\n#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION\n#error This file was generated by an older version of protoc which is\n#error incompatible with your Protocol Buffer headers.  Please\n#error regenerate this file with a newer version of protoc.\n#endif\n\n#include <google/protobuf/io/coded_stream.h>\n#include <google/protobuf/arena.h>\n#include <google/protobuf/arenastring.h>\n#include <google/protobuf/generated_message_table_driven.h>\n#include <google/protobuf/generated_message_util.h>\n#include <google/protobuf/metadata.h>\n#include <google/protobuf/message.h>\n#include <google/protobuf/repeated_field.h>  // IWYU pragma: export\n#include <google/protobuf/extension_set.h>  // IWYU pragma: export\n#include <google/protobuf/unknown_field_set.h>\n#include \"Common.pb.h\"\n#include \"Qot_Common.pb.h\"\n// @@protoc_insertion_point(includes)\n\nnamespace protobuf_Qot_5fRequestHistoryKLQuota_2eproto {\n// Internal implementation detail -- do not use these members.\nstruct TableStruct {\n  static const ::google::protobuf::internal::ParseTableField entries[];\n  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];\n  static const ::google::protobuf::internal::ParseTable schema[5];\n  static const ::google::protobuf::internal::FieldMetadata field_metadata[];\n  static const ::google::protobuf::internal::SerializationTable serialization_table[];\n  static const ::google::protobuf::uint32 offsets[];\n};\nvoid AddDescriptors();\nvoid InitDefaultsDetailItemImpl();\nvoid InitDefaultsDetailItem();\nvoid InitDefaultsC2SImpl();\nvoid InitDefaultsC2S();\nvoid InitDefaultsS2CImpl();\nvoid InitDefaultsS2C();\nvoid InitDefaultsRequestImpl();\nvoid InitDefaultsRequest();\nvoid InitDefaultsResponseImpl();\nvoid InitDefaultsResponse();\ninline void InitDefaults() {\n  InitDefaultsDetailItem();\n  InitDefaultsC2S();\n  InitDefaultsS2C();\n  InitDefaultsRequest();\n  InitDefaultsResponse();\n}\n}  // namespace protobuf_Qot_5fRequestHistoryKLQuota_2eproto\nnamespace Qot_RequestHistoryKLQuota {\nclass C2S;\nclass C2SDefaultTypeInternal;\nextern C2SDefaultTypeInternal _C2S_default_instance_;\nclass DetailItem;\nclass DetailItemDefaultTypeInternal;\nextern DetailItemDefaultTypeInternal _DetailItem_default_instance_;\nclass Request;\nclass RequestDefaultTypeInternal;\nextern RequestDefaultTypeInternal _Request_default_instance_;\nclass Response;\nclass ResponseDefaultTypeInternal;\nextern ResponseDefaultTypeInternal _Response_default_instance_;\nclass S2C;\nclass S2CDefaultTypeInternal;\nextern S2CDefaultTypeInternal _S2C_default_instance_;\n}  // namespace Qot_RequestHistoryKLQuota\nnamespace Qot_RequestHistoryKLQuota {\n\n// ===================================================================\n\nclass DetailItem : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Qot_RequestHistoryKLQuota.DetailItem) */ {\n public:\n  DetailItem();\n  virtual ~DetailItem();\n\n  DetailItem(const DetailItem& from);\n\n  inline DetailItem& operator=(const DetailItem& from) {\n    CopyFrom(from);\n    return *this;\n  }\n  #if LANG_CXX11\n  DetailItem(DetailItem&& from) noexcept\n    : DetailItem() {\n    *this = ::std::move(from);\n  }\n\n  inline DetailItem& operator=(DetailItem&& from) noexcept {\n    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {\n      if (this != &from) InternalSwap(&from);\n    } else {\n      CopyFrom(from);\n    }\n    return *this;\n  }\n  #endif\n  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {\n    return _internal_metadata_.unknown_fields();\n  }\n  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {\n    return _internal_metadata_.mutable_unknown_fields();\n  }\n\n  static const ::google::protobuf::Descriptor* descriptor();\n  static const DetailItem& default_instance();\n\n  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY\n  static inline const DetailItem* internal_default_instance() {\n    return reinterpret_cast<const DetailItem*>(\n               &_DetailItem_default_instance_);\n  }\n  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =\n    0;\n\n  void Swap(DetailItem* other);\n  friend void swap(DetailItem& a, DetailItem& b) {\n    a.Swap(&b);\n  }\n\n  // implements Message ----------------------------------------------\n\n  inline DetailItem* New() const PROTOBUF_FINAL { return New(NULL); }\n\n  DetailItem* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;\n  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;\n  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;\n  void CopyFrom(const DetailItem& from);\n  void MergeFrom(const DetailItem& from);\n  void Clear() PROTOBUF_FINAL;\n  bool IsInitialized() const PROTOBUF_FINAL;\n\n  size_t ByteSizeLong() const PROTOBUF_FINAL;\n  bool MergePartialFromCodedStream(\n      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;\n  void SerializeWithCachedSizes(\n      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;\n  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(\n      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;\n  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }\n  private:\n  void SharedCtor();\n  void SharedDtor();\n  void SetCachedSize(int size) const PROTOBUF_FINAL;\n  void InternalSwap(DetailItem* other);\n  private:\n  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {\n    return NULL;\n  }\n  inline void* MaybeArenaPtr() const {\n    return NULL;\n  }\n  public:\n\n  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;\n\n  // nested types ----------------------------------------------------\n\n  // accessors -------------------------------------------------------\n\n  // required string requestTime = 2;\n  bool has_requesttime() const;\n  void clear_requesttime();\n  static const int kRequestTimeFieldNumber = 2;\n  const ::std::string& requesttime() const;\n  void set_requesttime(const ::std::string& value);\n  #if LANG_CXX11\n  void set_requesttime(::std::string&& value);\n  #endif\n  void set_requesttime(const char* value);\n  void set_requesttime(const char* value, size_t size);\n  ::std::string* mutable_requesttime();\n  ::std::string* release_requesttime();\n  void set_allocated_requesttime(::std::string* requesttime);\n\n  // required .Qot_Common.Security security = 1;\n  bool has_security() const;\n  void clear_security();\n  static const int kSecurityFieldNumber = 1;\n  const ::Qot_Common::Security& security() const;\n  ::Qot_Common::Security* release_security();\n  ::Qot_Common::Security* mutable_security();\n  void set_allocated_security(::Qot_Common::Security* security);\n\n  // optional int64 requestTimeStamp = 3;\n  bool has_requesttimestamp() const;\n  void clear_requesttimestamp();\n  static const int kRequestTimeStampFieldNumber = 3;\n  ::google::protobuf::int64 requesttimestamp() const;\n  void set_requesttimestamp(::google::protobuf::int64 value);\n\n  // @@protoc_insertion_point(class_scope:Qot_RequestHistoryKLQuota.DetailItem)\n private:\n  void set_has_security();\n  void clear_has_security();\n  void set_has_requesttime();\n  void clear_has_requesttime();\n  void set_has_requesttimestamp();\n  void clear_has_requesttimestamp();\n\n  // helper for ByteSizeLong()\n  size_t RequiredFieldsByteSizeFallback() const;\n\n  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;\n  ::google::protobuf::internal::HasBits<1> _has_bits_;\n  mutable int _cached_size_;\n  ::google::protobuf::internal::ArenaStringPtr requesttime_;\n  ::Qot_Common::Security* security_;\n  ::google::protobuf::int64 requesttimestamp_;\n  friend struct ::protobuf_Qot_5fRequestHistoryKLQuota_2eproto::TableStruct;\n  friend void ::protobuf_Qot_5fRequestHistoryKLQuota_2eproto::InitDefaultsDetailItemImpl();\n};\n// -------------------------------------------------------------------\n\nclass C2S : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Qot_RequestHistoryKLQuota.C2S) */ {\n public:\n  C2S();\n  virtual ~C2S();\n\n  C2S(const C2S& from);\n\n  inline C2S& operator=(const C2S& from) {\n    CopyFrom(from);\n    return *this;\n  }\n  #if LANG_CXX11\n  C2S(C2S&& from) noexcept\n    : C2S() {\n    *this = ::std::move(from);\n  }\n\n  inline C2S& operator=(C2S&& from) noexcept {\n    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {\n      if (this != &from) InternalSwap(&from);\n    } else {\n      CopyFrom(from);\n    }\n    return *this;\n  }\n  #endif\n  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {\n    return _internal_metadata_.unknown_fields();\n  }\n  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {\n    return _internal_metadata_.mutable_unknown_fields();\n  }\n\n  static const ::google::protobuf::Descriptor* descriptor();\n  static const C2S& default_instance();\n\n  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY\n  static inline const C2S* internal_default_instance() {\n    return reinterpret_cast<const C2S*>(\n               &_C2S_default_instance_);\n  }\n  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =\n    1;\n\n  void Swap(C2S* other);\n  friend void swap(C2S& a, C2S& b) {\n    a.Swap(&b);\n  }\n\n  // implements Message ----------------------------------------------\n\n  inline C2S* New() const PROTOBUF_FINAL { return New(NULL); }\n\n  C2S* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;\n  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;\n  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;\n  void CopyFrom(const C2S& from);\n  void MergeFrom(const C2S& from);\n  void Clear() PROTOBUF_FINAL;\n  bool IsInitialized() const PROTOBUF_FINAL;\n\n  size_t ByteSizeLong() const PROTOBUF_FINAL;\n  bool MergePartialFromCodedStream(\n      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;\n  void SerializeWithCachedSizes(\n      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;\n  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(\n      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;\n  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }\n  private:\n  void SharedCtor();\n  void SharedDtor();\n  void SetCachedSize(int size) const PROTOBUF_FINAL;\n  void InternalSwap(C2S* other);\n  private:\n  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {\n    return NULL;\n  }\n  inline void* MaybeArenaPtr() const {\n    return NULL;\n  }\n  public:\n\n  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;\n\n  // nested types ----------------------------------------------------\n\n  // accessors -------------------------------------------------------\n\n  // optional bool bGetDetail = 2;\n  bool has_bgetdetail() const;\n  void clear_bgetdetail();\n  static const int kBGetDetailFieldNumber = 2;\n  bool bgetdetail() const;\n  void set_bgetdetail(bool value);\n\n  // @@protoc_insertion_point(class_scope:Qot_RequestHistoryKLQuota.C2S)\n private:\n  void set_has_bgetdetail();\n  void clear_has_bgetdetail();\n\n  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;\n  ::google::protobuf::internal::HasBits<1> _has_bits_;\n  mutable int _cached_size_;\n  bool bgetdetail_;\n  friend struct ::protobuf_Qot_5fRequestHistoryKLQuota_2eproto::TableStruct;\n  friend void ::protobuf_Qot_5fRequestHistoryKLQuota_2eproto::InitDefaultsC2SImpl();\n};\n// -------------------------------------------------------------------\n\nclass S2C : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Qot_RequestHistoryKLQuota.S2C) */ {\n public:\n  S2C();\n  virtual ~S2C();\n\n  S2C(const S2C& from);\n\n  inline S2C& operator=(const S2C& from) {\n    CopyFrom(from);\n    return *this;\n  }\n  #if LANG_CXX11\n  S2C(S2C&& from) noexcept\n    : S2C() {\n    *this = ::std::move(from);\n  }\n\n  inline S2C& operator=(S2C&& from) noexcept {\n    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {\n      if (this != &from) InternalSwap(&from);\n    } else {\n      CopyFrom(from);\n    }\n    return *this;\n  }\n  #endif\n  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {\n    return _internal_metadata_.unknown_fields();\n  }\n  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {\n    return _internal_metadata_.mutable_unknown_fields();\n  }\n\n  static const ::google::protobuf::Descriptor* descriptor();\n  static const S2C& default_instance();\n\n  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY\n  static inline const S2C* internal_default_instance() {\n    return reinterpret_cast<const S2C*>(\n               &_S2C_default_instance_);\n  }\n  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =\n    2;\n\n  void Swap(S2C* other);\n  friend void swap(S2C& a, S2C& b) {\n    a.Swap(&b);\n  }\n\n  // implements Message ----------------------------------------------\n\n  inline S2C* New() const PROTOBUF_FINAL { return New(NULL); }\n\n  S2C* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;\n  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;\n  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;\n  void CopyFrom(const S2C& from);\n  void MergeFrom(const S2C& from);\n  void Clear() PROTOBUF_FINAL;\n  bool IsInitialized() const PROTOBUF_FINAL;\n\n  size_t ByteSizeLong() const PROTOBUF_FINAL;\n  bool MergePartialFromCodedStream(\n      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;\n  void SerializeWithCachedSizes(\n      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;\n  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(\n      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;\n  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }\n  private:\n  void SharedCtor();\n  void SharedDtor();\n  void SetCachedSize(int size) const PROTOBUF_FINAL;\n  void InternalSwap(S2C* other);\n  private:\n  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {\n    return NULL;\n  }\n  inline void* MaybeArenaPtr() const {\n    return NULL;\n  }\n  public:\n\n  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;\n\n  // nested types ----------------------------------------------------\n\n  // accessors -------------------------------------------------------\n\n  // repeated .Qot_RequestHistoryKLQuota.DetailItem detailList = 3;\n  int detaillist_size() const;\n  void clear_detaillist();\n  static const int kDetailListFieldNumber = 3;\n  const ::Qot_RequestHistoryKLQuota::DetailItem& detaillist(int index) const;\n  ::Qot_RequestHistoryKLQuota::DetailItem* mutable_detaillist(int index);\n  ::Qot_RequestHistoryKLQuota::DetailItem* add_detaillist();\n  ::google::protobuf::RepeatedPtrField< ::Qot_RequestHistoryKLQuota::DetailItem >*\n      mutable_detaillist();\n  const ::google::protobuf::RepeatedPtrField< ::Qot_RequestHistoryKLQuota::DetailItem >&\n      detaillist() const;\n\n  // required int32 usedQuota = 1;\n  bool has_usedquota() const;\n  void clear_usedquota();\n  static const int kUsedQuotaFieldNumber = 1;\n  ::google::protobuf::int32 usedquota() const;\n  void set_usedquota(::google::protobuf::int32 value);\n\n  // required int32 remainQuota = 2;\n  bool has_remainquota() const;\n  void clear_remainquota();\n  static const int kRemainQuotaFieldNumber = 2;\n  ::google::protobuf::int32 remainquota() const;\n  void set_remainquota(::google::protobuf::int32 value);\n\n  // @@protoc_insertion_point(class_scope:Qot_RequestHistoryKLQuota.S2C)\n private:\n  void set_has_usedquota();\n  void clear_has_usedquota();\n  void set_has_remainquota();\n  void clear_has_remainquota();\n\n  // helper for ByteSizeLong()\n  size_t RequiredFieldsByteSizeFallback() const;\n\n  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;\n  ::google::protobuf::internal::HasBits<1> _has_bits_;\n  mutable int _cached_size_;\n  ::google::protobuf::RepeatedPtrField< ::Qot_RequestHistoryKLQuota::DetailItem > detaillist_;\n  ::google::protobuf::int32 usedquota_;\n  ::google::protobuf::int32 remainquota_;\n  friend struct ::protobuf_Qot_5fRequestHistoryKLQuota_2eproto::TableStruct;\n  friend void ::protobuf_Qot_5fRequestHistoryKLQuota_2eproto::InitDefaultsS2CImpl();\n};\n// -------------------------------------------------------------------\n\nclass Request : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Qot_RequestHistoryKLQuota.Request) */ {\n public:\n  Request();\n  virtual ~Request();\n\n  Request(const Request& from);\n\n  inline Request& operator=(const Request& from) {\n    CopyFrom(from);\n    return *this;\n  }\n  #if LANG_CXX11\n  Request(Request&& from) noexcept\n    : Request() {\n    *this = ::std::move(from);\n  }\n\n  inline Request& operator=(Request&& from) noexcept {\n    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {\n      if (this != &from) InternalSwap(&from);\n    } else {\n      CopyFrom(from);\n    }\n    return *this;\n  }\n  #endif\n  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {\n    return _internal_metadata_.unknown_fields();\n  }\n  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {\n    return _internal_metadata_.mutable_unknown_fields();\n  }\n\n  static const ::google::protobuf::Descriptor* descriptor();\n  static const Request& default_instance();\n\n  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY\n  static inline const Request* internal_default_instance() {\n    return reinterpret_cast<const Request*>(\n               &_Request_default_instance_);\n  }\n  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =\n    3;\n\n  void Swap(Request* other);\n  friend void swap(Request& a, Request& b) {\n    a.Swap(&b);\n  }\n\n  // implements Message ----------------------------------------------\n\n  inline Request* New() const PROTOBUF_FINAL { return New(NULL); }\n\n  Request* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;\n  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;\n  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;\n  void CopyFrom(const Request& from);\n  void MergeFrom(const Request& from);\n  void Clear() PROTOBUF_FINAL;\n  bool IsInitialized() const PROTOBUF_FINAL;\n\n  size_t ByteSizeLong() const PROTOBUF_FINAL;\n  bool MergePartialFromCodedStream(\n      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;\n  void SerializeWithCachedSizes(\n      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;\n  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(\n      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;\n  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }\n  private:\n  void SharedCtor();\n  void SharedDtor();\n  void SetCachedSize(int size) const PROTOBUF_FINAL;\n  void InternalSwap(Request* other);\n  private:\n  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {\n    return NULL;\n  }\n  inline void* MaybeArenaPtr() const {\n    return NULL;\n  }\n  public:\n\n  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;\n\n  // nested types ----------------------------------------------------\n\n  // accessors -------------------------------------------------------\n\n  // required .Qot_RequestHistoryKLQuota.C2S c2s = 1;\n  bool has_c2s() const;\n  void clear_c2s();\n  static const int kC2SFieldNumber = 1;\n  const ::Qot_RequestHistoryKLQuota::C2S& c2s() const;\n  ::Qot_RequestHistoryKLQuota::C2S* release_c2s();\n  ::Qot_RequestHistoryKLQuota::C2S* mutable_c2s();\n  void set_allocated_c2s(::Qot_RequestHistoryKLQuota::C2S* c2s);\n\n  // @@protoc_insertion_point(class_scope:Qot_RequestHistoryKLQuota.Request)\n private:\n  void set_has_c2s();\n  void clear_has_c2s();\n\n  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;\n  ::google::protobuf::internal::HasBits<1> _has_bits_;\n  mutable int _cached_size_;\n  ::Qot_RequestHistoryKLQuota::C2S* c2s_;\n  friend struct ::protobuf_Qot_5fRequestHistoryKLQuota_2eproto::TableStruct;\n  friend void ::protobuf_Qot_5fRequestHistoryKLQuota_2eproto::InitDefaultsRequestImpl();\n};\n// -------------------------------------------------------------------\n\nclass Response : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Qot_RequestHistoryKLQuota.Response) */ {\n public:\n  Response();\n  virtual ~Response();\n\n  Response(const Response& from);\n\n  inline Response& operator=(const Response& from) {\n    CopyFrom(from);\n    return *this;\n  }\n  #if LANG_CXX11\n  Response(Response&& from) noexcept\n    : Response() {\n    *this = ::std::move(from);\n  }\n\n  inline Response& operator=(Response&& from) noexcept {\n    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {\n      if (this != &from) InternalSwap(&from);\n    } else {\n      CopyFrom(from);\n    }\n    return *this;\n  }\n  #endif\n  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {\n    return _internal_metadata_.unknown_fields();\n  }\n  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {\n    return _internal_metadata_.mutable_unknown_fields();\n  }\n\n  static const ::google::protobuf::Descriptor* descriptor();\n  static const Response& default_instance();\n\n  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY\n  static inline const Response* internal_default_instance() {\n    return reinterpret_cast<const Response*>(\n               &_Response_default_instance_);\n  }\n  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =\n    4;\n\n  void Swap(Response* other);\n  friend void swap(Response& a, Response& b) {\n    a.Swap(&b);\n  }\n\n  // implements Message ----------------------------------------------\n\n  inline Response* New() const PROTOBUF_FINAL { return New(NULL); }\n\n  Response* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;\n  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;\n  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;\n  void CopyFrom(const Response& from);\n  void MergeFrom(const Response& from);\n  void Clear() PROTOBUF_FINAL;\n  bool IsInitialized() const PROTOBUF_FINAL;\n\n  size_t ByteSizeLong() const PROTOBUF_FINAL;\n  bool MergePartialFromCodedStream(\n      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;\n  void SerializeWithCachedSizes(\n      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;\n  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(\n      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;\n  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }\n  private:\n  void SharedCtor();\n  void SharedDtor();\n  void SetCachedSize(int size) const PROTOBUF_FINAL;\n  void InternalSwap(Response* other);\n  private:\n  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {\n    return NULL;\n  }\n  inline void* MaybeArenaPtr() const {\n    return NULL;\n  }\n  public:\n\n  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;\n\n  // nested types ----------------------------------------------------\n\n  // accessors -------------------------------------------------------\n\n  // optional string retMsg = 2;\n  bool has_retmsg() const;\n  void clear_retmsg();\n  static const int kRetMsgFieldNumber = 2;\n  const ::std::string& retmsg() const;\n  void set_retmsg(const ::std::string& value);\n  #if LANG_CXX11\n  void set_retmsg(::std::string&& value);\n  #endif\n  void set_retmsg(const char* value);\n  void set_retmsg(const char* value, size_t size);\n  ::std::string* mutable_retmsg();\n  ::std::string* release_retmsg();\n  void set_allocated_retmsg(::std::string* retmsg);\n\n  // optional .Qot_RequestHistoryKLQuota.S2C s2c = 4;\n  bool has_s2c() const;\n  void clear_s2c();\n  static const int kS2CFieldNumber = 4;\n  const ::Qot_RequestHistoryKLQuota::S2C& s2c() const;\n  ::Qot_RequestHistoryKLQuota::S2C* release_s2c();\n  ::Qot_RequestHistoryKLQuota::S2C* mutable_s2c();\n  void set_allocated_s2c(::Qot_RequestHistoryKLQuota::S2C* s2c);\n\n  // optional int32 errCode = 3;\n  bool has_errcode() const;\n  void clear_errcode();\n  static const int kErrCodeFieldNumber = 3;\n  ::google::protobuf::int32 errcode() const;\n  void set_errcode(::google::protobuf::int32 value);\n\n  // required int32 retType = 1 [default = -400];\n  bool has_rettype() const;\n  void clear_rettype();\n  static const int kRetTypeFieldNumber = 1;\n  ::google::protobuf::int32 rettype() const;\n  void set_rettype(::google::protobuf::int32 value);\n\n  // @@protoc_insertion_point(class_scope:Qot_RequestHistoryKLQuota.Response)\n private:\n  void set_has_rettype();\n  void clear_has_rettype();\n  void set_has_retmsg();\n  void clear_has_retmsg();\n  void set_has_errcode();\n  void clear_has_errcode();\n  void set_has_s2c();\n  void clear_has_s2c();\n\n  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;\n  ::google::protobuf::internal::HasBits<1> _has_bits_;\n  mutable int _cached_size_;\n  ::google::protobuf::internal::ArenaStringPtr retmsg_;\n  ::Qot_RequestHistoryKLQuota::S2C* s2c_;\n  ::google::protobuf::int32 errcode_;\n  ::google::protobuf::int32 rettype_;\n  friend struct ::protobuf_Qot_5fRequestHistoryKLQuota_2eproto::TableStruct;\n  friend void ::protobuf_Qot_5fRequestHistoryKLQuota_2eproto::InitDefaultsResponseImpl();\n};\n// ===================================================================\n\n\n// ===================================================================\n\n#ifdef __GNUC__\n  #pragma GCC diagnostic push\n  #pragma GCC diagnostic ignored \"-Wstrict-aliasing\"\n#endif  // __GNUC__\n// DetailItem\n\n// required .Qot_Common.Security security = 1;\ninline bool DetailItem::has_security() const {\n  return (_has_bits_[0] & 0x00000002u) != 0;\n}\ninline void DetailItem::set_has_security() {\n  _has_bits_[0] |= 0x00000002u;\n}\ninline void DetailItem::clear_has_security() {\n  _has_bits_[0] &= ~0x00000002u;\n}\ninline const ::Qot_Common::Security& DetailItem::security() const {\n  const ::Qot_Common::Security* p = security_;\n  // @@protoc_insertion_point(field_get:Qot_RequestHistoryKLQuota.DetailItem.security)\n  return p != NULL ? *p : *reinterpret_cast<const ::Qot_Common::Security*>(\n      &::Qot_Common::_Security_default_instance_);\n}\ninline ::Qot_Common::Security* DetailItem::release_security() {\n  // @@protoc_insertion_point(field_release:Qot_RequestHistoryKLQuota.DetailItem.security)\n  clear_has_security();\n  ::Qot_Common::Security* temp = security_;\n  security_ = NULL;\n  return temp;\n}\ninline ::Qot_Common::Security* DetailItem::mutable_security() {\n  set_has_security();\n  if (security_ == NULL) {\n    security_ = new ::Qot_Common::Security;\n  }\n  // @@protoc_insertion_point(field_mutable:Qot_RequestHistoryKLQuota.DetailItem.security)\n  return security_;\n}\ninline void DetailItem::set_allocated_security(::Qot_Common::Security* security) {\n  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();\n  if (message_arena == NULL) {\n    delete reinterpret_cast< ::google::protobuf::MessageLite*>(security_);\n  }\n  if (security) {\n    ::google::protobuf::Arena* submessage_arena = NULL;\n    if (message_arena != submessage_arena) {\n      security = ::google::protobuf::internal::GetOwnedMessage(\n          message_arena, security, submessage_arena);\n    }\n    set_has_security();\n  } else {\n    clear_has_security();\n  }\n  security_ = security;\n  // @@protoc_insertion_point(field_set_allocated:Qot_RequestHistoryKLQuota.DetailItem.security)\n}\n\n// required string requestTime = 2;\ninline bool DetailItem::has_requesttime() const {\n  return (_has_bits_[0] & 0x00000001u) != 0;\n}\ninline void DetailItem::set_has_requesttime() {\n  _has_bits_[0] |= 0x00000001u;\n}\ninline void DetailItem::clear_has_requesttime() {\n  _has_bits_[0] &= ~0x00000001u;\n}\ninline void DetailItem::clear_requesttime() {\n  requesttime_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());\n  clear_has_requesttime();\n}\ninline const ::std::string& DetailItem::requesttime() const {\n  // @@protoc_insertion_point(field_get:Qot_RequestHistoryKLQuota.DetailItem.requestTime)\n  return requesttime_.GetNoArena();\n}\ninline void DetailItem::set_requesttime(const ::std::string& value) {\n  set_has_requesttime();\n  requesttime_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);\n  // @@protoc_insertion_point(field_set:Qot_RequestHistoryKLQuota.DetailItem.requestTime)\n}\n#if LANG_CXX11\ninline void DetailItem::set_requesttime(::std::string&& value) {\n  set_has_requesttime();\n  requesttime_.SetNoArena(\n    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));\n  // @@protoc_insertion_point(field_set_rvalue:Qot_RequestHistoryKLQuota.DetailItem.requestTime)\n}\n#endif\ninline void DetailItem::set_requesttime(const char* value) {\n  GOOGLE_DCHECK(value != NULL);\n  set_has_requesttime();\n  requesttime_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));\n  // @@protoc_insertion_point(field_set_char:Qot_RequestHistoryKLQuota.DetailItem.requestTime)\n}\ninline void DetailItem::set_requesttime(const char* value, size_t size) {\n  set_has_requesttime();\n  requesttime_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),\n      ::std::string(reinterpret_cast<const char*>(value), size));\n  // @@protoc_insertion_point(field_set_pointer:Qot_RequestHistoryKLQuota.DetailItem.requestTime)\n}\ninline ::std::string* DetailItem::mutable_requesttime() {\n  set_has_requesttime();\n  // @@protoc_insertion_point(field_mutable:Qot_RequestHistoryKLQuota.DetailItem.requestTime)\n  return requesttime_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());\n}\ninline ::std::string* DetailItem::release_requesttime() {\n  // @@protoc_insertion_point(field_release:Qot_RequestHistoryKLQuota.DetailItem.requestTime)\n  clear_has_requesttime();\n  return requesttime_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());\n}\ninline void DetailItem::set_allocated_requesttime(::std::string* requesttime) {\n  if (requesttime != NULL) {\n    set_has_requesttime();\n  } else {\n    clear_has_requesttime();\n  }\n  requesttime_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), requesttime);\n  // @@protoc_insertion_point(field_set_allocated:Qot_RequestHistoryKLQuota.DetailItem.requestTime)\n}\n\n// optional int64 requestTimeStamp = 3;\ninline bool DetailItem::has_requesttimestamp() const {\n  return (_has_bits_[0] & 0x00000004u) != 0;\n}\ninline void DetailItem::set_has_requesttimestamp() {\n  _has_bits_[0] |= 0x00000004u;\n}\ninline void DetailItem::clear_has_requesttimestamp() {\n  _has_bits_[0] &= ~0x00000004u;\n}\ninline void DetailItem::clear_requesttimestamp() {\n  requesttimestamp_ = GOOGLE_LONGLONG(0);\n  clear_has_requesttimestamp();\n}\ninline ::google::protobuf::int64 DetailItem::requesttimestamp() const {\n  // @@protoc_insertion_point(field_get:Qot_RequestHistoryKLQuota.DetailItem.requestTimeStamp)\n  return requesttimestamp_;\n}\ninline void DetailItem::set_requesttimestamp(::google::protobuf::int64 value) {\n  set_has_requesttimestamp();\n  requesttimestamp_ = value;\n  // @@protoc_insertion_point(field_set:Qot_RequestHistoryKLQuota.DetailItem.requestTimeStamp)\n}\n\n// -------------------------------------------------------------------\n\n// C2S\n\n// optional bool bGetDetail = 2;\ninline bool C2S::has_bgetdetail() const {\n  return (_has_bits_[0] & 0x00000001u) != 0;\n}\ninline void C2S::set_has_bgetdetail() {\n  _has_bits_[0] |= 0x00000001u;\n}\ninline void C2S::clear_has_bgetdetail() {\n  _has_bits_[0] &= ~0x00000001u;\n}\ninline void C2S::clear_bgetdetail() {\n  bgetdetail_ = false;\n  clear_has_bgetdetail();\n}\ninline bool C2S::bgetdetail() const {\n  // @@protoc_insertion_point(field_get:Qot_RequestHistoryKLQuota.C2S.bGetDetail)\n  return bgetdetail_;\n}\ninline void C2S::set_bgetdetail(bool value) {\n  set_has_bgetdetail();\n  bgetdetail_ = value;\n  // @@protoc_insertion_point(field_set:Qot_RequestHistoryKLQuota.C2S.bGetDetail)\n}\n\n// -------------------------------------------------------------------\n\n// S2C\n\n// required int32 usedQuota = 1;\ninline bool S2C::has_usedquota() const {\n  return (_has_bits_[0] & 0x00000001u) != 0;\n}\ninline void S2C::set_has_usedquota() {\n  _has_bits_[0] |= 0x00000001u;\n}\ninline void S2C::clear_has_usedquota() {\n  _has_bits_[0] &= ~0x00000001u;\n}\ninline void S2C::clear_usedquota() {\n  usedquota_ = 0;\n  clear_has_usedquota();\n}\ninline ::google::protobuf::int32 S2C::usedquota() const {\n  // @@protoc_insertion_point(field_get:Qot_RequestHistoryKLQuota.S2C.usedQuota)\n  return usedquota_;\n}\ninline void S2C::set_usedquota(::google::protobuf::int32 value) {\n  set_has_usedquota();\n  usedquota_ = value;\n  // @@protoc_insertion_point(field_set:Qot_RequestHistoryKLQuota.S2C.usedQuota)\n}\n\n// required int32 remainQuota = 2;\ninline bool S2C::has_remainquota() const {\n  return (_has_bits_[0] & 0x00000002u) != 0;\n}\ninline void S2C::set_has_remainquota() {\n  _has_bits_[0] |= 0x00000002u;\n}\ninline void S2C::clear_has_remainquota() {\n  _has_bits_[0] &= ~0x00000002u;\n}\ninline void S2C::clear_remainquota() {\n  remainquota_ = 0;\n  clear_has_remainquota();\n}\ninline ::google::protobuf::int32 S2C::remainquota() const {\n  // @@protoc_insertion_point(field_get:Qot_RequestHistoryKLQuota.S2C.remainQuota)\n  return remainquota_;\n}\ninline void S2C::set_remainquota(::google::protobuf::int32 value) {\n  set_has_remainquota();\n  remainquota_ = value;\n  // @@protoc_insertion_point(field_set:Qot_RequestHistoryKLQuota.S2C.remainQuota)\n}\n\n// repeated .Qot_RequestHistoryKLQuota.DetailItem detailList = 3;\ninline int S2C::detaillist_size() const {\n  return detaillist_.size();\n}\ninline void S2C::clear_detaillist() {\n  detaillist_.Clear();\n}\ninline const ::Qot_RequestHistoryKLQuota::DetailItem& S2C::detaillist(int index) const {\n  // @@protoc_insertion_point(field_get:Qot_RequestHistoryKLQuota.S2C.detailList)\n  return detaillist_.Get(index);\n}\ninline ::Qot_RequestHistoryKLQuota::DetailItem* S2C::mutable_detaillist(int index) {\n  // @@protoc_insertion_point(field_mutable:Qot_RequestHistoryKLQuota.S2C.detailList)\n  return detaillist_.Mutable(index);\n}\ninline ::Qot_RequestHistoryKLQuota::DetailItem* S2C::add_detaillist() {\n  // @@protoc_insertion_point(field_add:Qot_RequestHistoryKLQuota.S2C.detailList)\n  return detaillist_.Add();\n}\ninline ::google::protobuf::RepeatedPtrField< ::Qot_RequestHistoryKLQuota::DetailItem >*\nS2C::mutable_detaillist() {\n  // @@protoc_insertion_point(field_mutable_list:Qot_RequestHistoryKLQuota.S2C.detailList)\n  return &detaillist_;\n}\ninline const ::google::protobuf::RepeatedPtrField< ::Qot_RequestHistoryKLQuota::DetailItem >&\nS2C::detaillist() const {\n  // @@protoc_insertion_point(field_list:Qot_RequestHistoryKLQuota.S2C.detailList)\n  return detaillist_;\n}\n\n// -------------------------------------------------------------------\n\n// Request\n\n// required .Qot_RequestHistoryKLQuota.C2S c2s = 1;\ninline bool Request::has_c2s() const {\n  return (_has_bits_[0] & 0x00000001u) != 0;\n}\ninline void Request::set_has_c2s() {\n  _has_bits_[0] |= 0x00000001u;\n}\ninline void Request::clear_has_c2s() {\n  _has_bits_[0] &= ~0x00000001u;\n}\ninline void Request::clear_c2s() {\n  if (c2s_ != NULL) c2s_->Clear();\n  clear_has_c2s();\n}\ninline const ::Qot_RequestHistoryKLQuota::C2S& Request::c2s() const {\n  const ::Qot_RequestHistoryKLQuota::C2S* p = c2s_;\n  // @@protoc_insertion_point(field_get:Qot_RequestHistoryKLQuota.Request.c2s)\n  return p != NULL ? *p : *reinterpret_cast<const ::Qot_RequestHistoryKLQuota::C2S*>(\n      &::Qot_RequestHistoryKLQuota::_C2S_default_instance_);\n}\ninline ::Qot_RequestHistoryKLQuota::C2S* Request::release_c2s() {\n  // @@protoc_insertion_point(field_release:Qot_RequestHistoryKLQuota.Request.c2s)\n  clear_has_c2s();\n  ::Qot_RequestHistoryKLQuota::C2S* temp = c2s_;\n  c2s_ = NULL;\n  return temp;\n}\ninline ::Qot_RequestHistoryKLQuota::C2S* Request::mutable_c2s() {\n  set_has_c2s();\n  if (c2s_ == NULL) {\n    c2s_ = new ::Qot_RequestHistoryKLQuota::C2S;\n  }\n  // @@protoc_insertion_point(field_mutable:Qot_RequestHistoryKLQuota.Request.c2s)\n  return c2s_;\n}\ninline void Request::set_allocated_c2s(::Qot_RequestHistoryKLQuota::C2S* c2s) {\n  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();\n  if (message_arena == NULL) {\n    delete c2s_;\n  }\n  if (c2s) {\n    ::google::protobuf::Arena* submessage_arena = NULL;\n    if (message_arena != submessage_arena) {\n      c2s = ::google::protobuf::internal::GetOwnedMessage(\n          message_arena, c2s, submessage_arena);\n    }\n    set_has_c2s();\n  } else {\n    clear_has_c2s();\n  }\n  c2s_ = c2s;\n  // @@protoc_insertion_point(field_set_allocated:Qot_RequestHistoryKLQuota.Request.c2s)\n}\n\n// -------------------------------------------------------------------\n\n// Response\n\n// required int32 retType = 1 [default = -400];\ninline bool Response::has_rettype() const {\n  return (_has_bits_[0] & 0x00000008u) != 0;\n}\ninline void Response::set_has_rettype() {\n  _has_bits_[0] |= 0x00000008u;\n}\ninline void Response::clear_has_rettype() {\n  _has_bits_[0] &= ~0x00000008u;\n}\ninline void Response::clear_rettype() {\n  rettype_ = -400;\n  clear_has_rettype();\n}\ninline ::google::protobuf::int32 Response::rettype() const {\n  // @@protoc_insertion_point(field_get:Qot_RequestHistoryKLQuota.Response.retType)\n  return rettype_;\n}\ninline void Response::set_rettype(::google::protobuf::int32 value) {\n  set_has_rettype();\n  rettype_ = value;\n  // @@protoc_insertion_point(field_set:Qot_RequestHistoryKLQuota.Response.retType)\n}\n\n// optional string retMsg = 2;\ninline bool Response::has_retmsg() const {\n  return (_has_bits_[0] & 0x00000001u) != 0;\n}\ninline void Response::set_has_retmsg() {\n  _has_bits_[0] |= 0x00000001u;\n}\ninline void Response::clear_has_retmsg() {\n  _has_bits_[0] &= ~0x00000001u;\n}\ninline void Response::clear_retmsg() {\n  retmsg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());\n  clear_has_retmsg();\n}\ninline const ::std::string& Response::retmsg() const {\n  // @@protoc_insertion_point(field_get:Qot_RequestHistoryKLQuota.Response.retMsg)\n  return retmsg_.GetNoArena();\n}\ninline void Response::set_retmsg(const ::std::string& value) {\n  set_has_retmsg();\n  retmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);\n  // @@protoc_insertion_point(field_set:Qot_RequestHistoryKLQuota.Response.retMsg)\n}\n#if LANG_CXX11\ninline void Response::set_retmsg(::std::string&& value) {\n  set_has_retmsg();\n  retmsg_.SetNoArena(\n    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));\n  // @@protoc_insertion_point(field_set_rvalue:Qot_RequestHistoryKLQuota.Response.retMsg)\n}\n#endif\ninline void Response::set_retmsg(const char* value) {\n  GOOGLE_DCHECK(value != NULL);\n  set_has_retmsg();\n  retmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));\n  // @@protoc_insertion_point(field_set_char:Qot_RequestHistoryKLQuota.Response.retMsg)\n}\ninline void Response::set_retmsg(const char* value, size_t size) {\n  set_has_retmsg();\n  retmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),\n      ::std::string(reinterpret_cast<const char*>(value), size));\n  // @@protoc_insertion_point(field_set_pointer:Qot_RequestHistoryKLQuota.Response.retMsg)\n}\ninline ::std::string* Response::mutable_retmsg() {\n  set_has_retmsg();\n  // @@protoc_insertion_point(field_mutable:Qot_RequestHistoryKLQuota.Response.retMsg)\n  return retmsg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());\n}\ninline ::std::string* Response::release_retmsg() {\n  // @@protoc_insertion_point(field_release:Qot_RequestHistoryKLQuota.Response.retMsg)\n  clear_has_retmsg();\n  return retmsg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());\n}\ninline void Response::set_allocated_retmsg(::std::string* retmsg) {\n  if (retmsg != NULL) {\n    set_has_retmsg();\n  } else {\n    clear_has_retmsg();\n  }\n  retmsg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), retmsg);\n  // @@protoc_insertion_point(field_set_allocated:Qot_RequestHistoryKLQuota.Response.retMsg)\n}\n\n// optional int32 errCode = 3;\ninline bool Response::has_errcode() const {\n  return (_has_bits_[0] & 0x00000004u) != 0;\n}\ninline void Response::set_has_errcode() {\n  _has_bits_[0] |= 0x00000004u;\n}\ninline void Response::clear_has_errcode() {\n  _has_bits_[0] &= ~0x00000004u;\n}\ninline void Response::clear_errcode() {\n  errcode_ = 0;\n  clear_has_errcode();\n}\ninline ::google::protobuf::int32 Response::errcode() const {\n  // @@protoc_insertion_point(field_get:Qot_RequestHistoryKLQuota.Response.errCode)\n  return errcode_;\n}\ninline void Response::set_errcode(::google::protobuf::int32 value) {\n  set_has_errcode();\n  errcode_ = value;\n  // @@protoc_insertion_point(field_set:Qot_RequestHistoryKLQuota.Response.errCode)\n}\n\n// optional .Qot_RequestHistoryKLQuota.S2C s2c = 4;\ninline bool Response::has_s2c() const {\n  return (_has_bits_[0] & 0x00000002u) != 0;\n}\ninline void Response::set_has_s2c() {\n  _has_bits_[0] |= 0x00000002u;\n}\ninline void Response::clear_has_s2c() {\n  _has_bits_[0] &= ~0x00000002u;\n}\ninline void Response::clear_s2c() {\n  if (s2c_ != NULL) s2c_->Clear();\n  clear_has_s2c();\n}\ninline const ::Qot_RequestHistoryKLQuota::S2C& Response::s2c() const {\n  const ::Qot_RequestHistoryKLQuota::S2C* p = s2c_;\n  // @@protoc_insertion_point(field_get:Qot_RequestHistoryKLQuota.Response.s2c)\n  return p != NULL ? *p : *reinterpret_cast<const ::Qot_RequestHistoryKLQuota::S2C*>(\n      &::Qot_RequestHistoryKLQuota::_S2C_default_instance_);\n}\ninline ::Qot_RequestHistoryKLQuota::S2C* Response::release_s2c() {\n  // @@protoc_insertion_point(field_release:Qot_RequestHistoryKLQuota.Response.s2c)\n  clear_has_s2c();\n  ::Qot_RequestHistoryKLQuota::S2C* temp = s2c_;\n  s2c_ = NULL;\n  return temp;\n}\ninline ::Qot_RequestHistoryKLQuota::S2C* Response::mutable_s2c() {\n  set_has_s2c();\n  if (s2c_ == NULL) {\n    s2c_ = new ::Qot_RequestHistoryKLQuota::S2C;\n  }\n  // @@protoc_insertion_point(field_mutable:Qot_RequestHistoryKLQuota.Response.s2c)\n  return s2c_;\n}\ninline void Response::set_allocated_s2c(::Qot_RequestHistoryKLQuota::S2C* s2c) {\n  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();\n  if (message_arena == NULL) {\n    delete s2c_;\n  }\n  if (s2c) {\n    ::google::protobuf::Arena* submessage_arena = NULL;\n    if (message_arena != submessage_arena) {\n      s2c = ::google::protobuf::internal::GetOwnedMessage(\n          message_arena, s2c, submessage_arena);\n    }\n    set_has_s2c();\n  } else {\n    clear_has_s2c();\n  }\n  s2c_ = s2c;\n  // @@protoc_insertion_point(field_set_allocated:Qot_RequestHistoryKLQuota.Response.s2c)\n}\n\n#ifdef __GNUC__\n  #pragma GCC diagnostic pop\n#endif  // __GNUC__\n// -------------------------------------------------------------------\n\n// -------------------------------------------------------------------\n\n// -------------------------------------------------------------------\n\n// -------------------------------------------------------------------\n\n\n// @@protoc_insertion_point(namespace_scope)\n\n}  // namespace Qot_RequestHistoryKLQuota\n\n// @@protoc_insertion_point(global_scope)\n\n#endif  // PROTOBUF_Qot_5fRequestHistoryKLQuota_2eproto__INCLUDED\n\n", "comment_ratio": 0.10492332526230831}
{"lang": "c", "code": "#ifndef NOVELRT_INTEROP_DEBUGSERVICE_H\n#define NOVELRT_INTEROP_DEBUGSERVICE_H\n\n#include \"NrtTypedefs.h\"\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n    NrtResult Nrt_DebugService_create(NrtUtilitiesEventHandle sceneConstructionEvent,\n                                      NrtRenderingServiceHandle renderingService,\n                                      NrtDebugServiceHandle* outputService);\n    NrtBool Nrt_DebugService_getIsFpsCounterVisible(NrtDebugServiceHandle service);\n    NrtResult Nrt_DebugService_setIsFpsCounterVisible(NrtDebugServiceHandle service, int32_t value);\n    uint32_t Nrt_DebugService_getFramesPerSecond(NrtDebugServiceHandle service);\n    NrtResult Nrt_DebugService_setFramesPerSecond(NrtDebugServiceHandle service, uint32_t value);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // NOVELRT_INTEROP_DEBUGSERVICE_H\n\n", "comment_ratio": 0.1111111111111111}
{"lang": "c", "code": "#ifndef MAINWINDOW_H\n#define MAINWINDOW_H\n\n#include <QMainWindow>\n#include <QGraphicsScene>\n#include \"triangle.h\"\n\nnamespace Ui {\nclass MainWindow;\n}\n\nclass MainWindow : public QMainWindow\n{\n    Q_OBJECT\n\nprivate:\n    Ui::MainWindow *ui;\n    QGraphicsScene *scene;          //\u0441\u0446\u0435\u043d\u0430\n    Triangle *triangle;             //\u0442\u0440\u0438\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\n\npublic:\n    explicit MainWindow(QWidget *parent = 0);\n    ~MainWindow();\n};\n\n#endif // MAINWINDOW_H\n\n", "comment_ratio": 0.1111111111111111}
{"lang": "c", "code": "#include \"common.h\"\n#include \"rpcqspidrv.h\"\n#include \"reg_rcarh3.h\"\n#include \"bit.h\"\n#include \"rpchyperdrv.h\"\n\n\nvoid InitRPC_HyperFlashExtMode(void)\n{\n\tuint32_t product;\n\tuint32_t cut;\n\n\tproduct = *((volatile uint32_t*)PRR) & PRR_PRODUCT_MASK;\n\tcut = *((volatile uint32_t*)PRR) & PRR_CUT_MASK;\n\n\tif ((product ==  PRR_PRODUCT_M3) && (cut < PRR_CUT_30)) {\n\t\t*((volatile uint32_t*)RPC_PHYCNT)     = 0x00070263;\n\t\t*((volatile uint32_t*)RPC_PHYCNT)     = 0x80070263;\n\t} else {\n\t\t*((volatile uint32_t*)RPC_PHYCNT)     = 0x00078263;\n\t\t*((volatile uint32_t*)RPC_PHYCNT)     = 0x80078263;\n\t}\n\t\t*((volatile uint32_t*)RPC_CMNCR)      = 0x01FFF301;\n\t\t*((volatile uint32_t*)RPC_DRCR)       = 0x001F0100;\n\t\t*((volatile uint32_t*)RPC_DRCMR)      = 0x00A00000;\n\t\t*((volatile uint32_t*)RPC_DRENR)      = 0xA222D400;\n\t\t*((volatile uint32_t*)RPC_DRDMCR)     = 0x0000000E;\n\t\t*((volatile uint32_t*)RPC_DRDRENR)    = 0x00005101;\n\t\t*((volatile uint32_t*)RPC_OFFSET1)= 0x21511144;\n\t\t*((volatile uint32_t*)RPC_PHYINT)    = 0x07070002;\n\t\t\t//bit18 RSTEN = 1 : RPC_RESET# pin is enabled\n\t\t\t//bit17 WPEN  = 1 : RPC_WP# pin is enabled\n\t\t\t//bit16 INTEN = 1 : RPC_INT# pin is enabled\n\t\t\t//bit2  RSTVAL= 0 : RPC_RESET# = H\n\t\t\t//bit1  WPVAL = 1 : RPC_WP# = L\n\t\t\t//bit0  INT   = 0 : Interrupt Status\n}\n\n\nvoid InitRPC_HyperFlash(void)\n{\n\tPowerOnRPC();\n\tSetRPC_ClockMode(RPC_CLK_80M);\n\tResetRPC();\n\tSetRPC_SSL_Delay();\n}\n\nuint32_t ReadHyperFlashData(uint32_t addr, uint32_t *readData, uint32_t byteCount)\n{\n\tuint32_t product;\n\tuint32_t cut;\n\n\tproduct = *((volatile uint32_t*)PRR) & PRR_PRODUCT_MASK;\n\tcut = *((volatile uint32_t*)PRR) & PRR_CUT_MASK;\n\n\tif ((product ==  PRR_PRODUCT_M3) && (cut < PRR_CUT_30)) {\n\t\t*((volatile uint32_t*)RPC_PHYCNT)    = 0x00030263;\n\t\t*((volatile uint32_t*)RPC_PHYCNT)    = 0x80030263;\n\t} else {\n\t\t*((volatile uint32_t*)RPC_PHYCNT)    = 0x00038263;\n\t\t*((volatile uint32_t*)RPC_PHYCNT)    = 0x80038263;\n\t\t//bit31  CAL         =  1 : PHY calibration\n\t\t//bit1-0 PHYMEM[1:0] = 11 : HyperFlash\n\t}\n\n\t*((volatile uint32_t*)RPC_CMNCR)      = 0x81FFF301;\n\t\t//bit31  MD       =  1 : Manual mode\n\t\t//bit1-0 BSZ[1:0] = 01 : QSPI Flash x 2 or HyperFlash\n\n\t*((volatile uint32_t*)RPC_SMCMR)      = 0x00800000;\n\t\t//bit23-21 CMD[7:5] = 100 : CA47-45 = 100 => Read/memory space/WrrapedBrst\n\n\t*((volatile uint32_t*)RPC_SMADR)      = (addr>>1);\n\t\t// ByteAddress(8bit) => WordAddress(16bit)\n\n\t*((volatile uint32_t*)RPC_SMOPR)      = 0x00000000;\n\t\t//                           CA15-3(Reserved) = all 0\n\n\t*((volatile uint32_t*)RPC_SMDMCR)     = 0x0000000E;\n\t\t//                           16 cycle dummy wait\n\n\t*((volatile uint32_t*)RPC_SMDRENR)    = 0x00005101;\n\t\t//bit8 ADDRE  = 1 : Address DDR transfer\n\t\t//bit0 SPIDRE = 1 : DATA DDR transfer\n\n\tswitch(byteCount){\n\t\tcase 2:\t\t// 2byte Read\n\t\t\t*((volatile uint32_t*)RPC_SMENR)      = 0xA222D408;\n\t\t\t//bit3-0   SPIDE[3:0] = 1000 : 16bit transfer\n\t\t\tbreak;\n\t\tcase 4:\t\t// 4byte Read\n\t\t\t*((volatile uint32_t*)RPC_SMENR)      = 0xA222D40C;\n\t\t\t//bit3-0   SPIDE[3:0] = 1100 : 32bit transfer\n\t\t\tbreak;\n\t\tcase 8:\t\t// 8byte Read\n\t\t\t*((volatile uint32_t*)RPC_SMENR)      = 0xA222D40F;\n\t\t\t//bit31-30 CDB[1:0]   =   10 : 4bit width command\n\t\t\t//bit25-24 ADB[1:0]   =   10 : 4bit width address\n\t\t\t//bit17-16 SPIDB[1:0] =   10 : 4bit width transfer data\n\t\t\t//bit15    DME        =    1 : dummy cycle enable\n\t\t\t//bit14    CDE        =    1 : Command enable\n\t\t\t//bit12    OCDE       =    1 : Option Command enable\n\t\t\t//bit11-8  ADE[3:0]   = 0100 : ADR[23:0] output (24 Bit Address)\n\t\t\t//bit7-4   OPDE[3:0]  = 0000 : Option data disable\n\t\t\t//bit3-0   SPIDE[3:0] = 1111 : 64bit transfer\n\t\t\tbreak;\n\t}\n\n\t*((volatile uint32_t*)RPC_SMCR)       = 0x00000005;\n\t\t//bit2     SPIRE      = 1 : Data read enable\n\t\t//bit1     SPIWE      = 0 : Data write disable\n\t\t//bit0     SPIE       = 1 : SPI transfer start\n\n\tWaitRpcTxEnd();\n\n\tif(byteCount==8){\n\t\treadData[1] = *((volatile uint32_t*)RPC_SMRDR0);\t//read data[63:32]\n\t}\n\n\treadData[0] = *((volatile uint32_t*)RPC_SMRDR1);\t//read data[31:0]\n\n\treturn(readData[0]);\n}\n\n\nvoid WriteCommandHyperFlash(uint32_t addr, uint32_t command)\n{\n\tuint32_t product;\n\tuint32_t cut;\n\n\tproduct = *((volatile uint32_t*)PRR) & PRR_PRODUCT_MASK;\n\tcut = *((volatile uint32_t*)PRR) & PRR_CUT_MASK;\n\n\tif ((product ==  PRR_PRODUCT_M3) && (cut < PRR_CUT_30)) {\n\t\t*((volatile uint32_t*)RPC_PHYCNT)    = 0x80030263;\n\t} else {\n\t\t*((volatile uint32_t*)RPC_PHYCNT)    = 0x80038263;\n\t\t//bit31  CAL         =  1 : PHY calibration\n\t\t//bit1-0 PHYMEM[1:0] = 11 : HyperFlash\n\t}\n\n\t*((volatile uint32_t*)RPC_CMNCR)      = 0x81FFF301;\n\t\t//bit31  MD       =  1 : Manual mode\n\t\t//bit1-0 BSZ[1:0] = 01 : QSPI Flash x 2 or HyperFlash\n\n\t*((volatile uint32_t*)RPC_SMCMR)      = 0x00000000;\n\t\t//bit23-21 CMD[7:5] = 000 : CA47-45 = 000 => Write/memory space/WrrapedBrst\n\n\t*((volatile uint32_t*)RPC_SMADR)      = addr;\n\t*((volatile uint32_t*)RPC_SMOPR)      = 0x00000000;\n\t\t//                           CA15-3(Reserved) = all 0\n//\t*((volatile uint32_t*)RPC_SMDMCR)     = 0x0000000E;\n\t\t//                           16 cycle dummy wait\n\t*((volatile uint32_t*)RPC_SMDRENR)    = 0x00005101;\n\t\t//bit14-12 HYPE =101:Hyperflash mode\n\t\t//bit8 ADDRE  = 1 : Address DDR transfer\n\t\t//bit0 SPIDRE = 1 : DATA DDR transfer\n\t*((volatile uint32_t*)RPC_SMENR)      = 0xA2225408;\n\t\t//bit31-30 CDB[1:0]   =   10 : 4bit width command\n\t\t//bit25-24 ADB[1:0]   =   10 : 4bit width address\n\t\t//bit17-16 SPIDB[1:0] =   10 : 4bit width transfer data\n\t\t//bit15    DME        =    0 : dummy cycle disable\n\t\t//bit14    CDE        =    1 : Command enable\n\t\t//bit12    OCDE       =    1 : Option Command enable\n\t\t//bit11-8  ADE[3:0]   = 0100 : ADR[23:0] output (24 Bit Address)\n\t\t//bit7-4   OPDE[3:0]  = 0000 : Option data disable\n\t\t//bit3-0   SPIDE[3:0] = 1000 : 16bit transfer\n\n\t*((volatile uint32_t*)RPC_SMWDR0)     = command;\n\t\t//\n\t*((volatile uint32_t*)RPC_SMCR)       = 0x00000003;\n\t\t//bit2     SPIRE      = 0 : Data read disable\n\t\t//bit1     SPIWE      = 1 : Data write enable\n\t\t//bit0     SPIE       = 1 : SPI transfer start\n\n\tWaitRpcTxEnd();\n}\n\nvoid WriteDataHyperFlash(uint32_t addr, uint32_t writeData)\n{\n\tuint32_t product;\n\tuint32_t cut;\n\n\tproduct = *((volatile uint32_t*)PRR) & PRR_PRODUCT_MASK;\n\tcut = *((volatile uint32_t*)PRR) & PRR_CUT_MASK;\n\n\tif ((product ==  PRR_PRODUCT_M3) && (cut < PRR_CUT_30)) {\n\t\t*((volatile uint32_t*)RPC_PHYCNT)    = 0x80030263;\n\t} else {\n\t\t*((volatile uint32_t*)RPC_PHYCNT)    = 0x80038263;\n\t\t//bit31  CAL         =  1 : PHY calibration\n\t\t//bit1-0 PHYMEM[1:0] = 11 : HyperFlash\n\t}\n\n\t*((volatile uint32_t*)RPC_CMNCR)      = 0x81FFF301;\n\t\t//bit31  MD       =  1 : Manual mode\n\t\t//bit1-0 BSZ[1:0] = 01 : QSPI Flash x 2 or HyperFlash\n\n\t*((volatile uint32_t*)RPC_SMCMR)      = 0x00000000;\n\t\t//bit23-21 CMD[7:5] = 000 : CA47-45 = 000 => Write/memory space/WrrapedBrst\n\t*((volatile uint32_t*)RPC_SMADR)      = (addr>>1);\n\t\t// ByteAddress(8bit) => WordAddress(16bit)\n\n\t*((volatile uint32_t*)RPC_SMOPR)      = 0x00000000;\n\t\t//                           CA15-3(Reserved) = all 0\n//\t*((volatile uint32_t*)RPC_SMDMCR)     = 0x0000000E;\n\t\t//                           16 cycle dummy wait\n\t*((volatile uint32_t*)RPC_SMDRENR)    = 0x00005101;\n\t\t//bit8 ADDRE  = 1 : Address DDR transfer\n\t\t//bit0 SPIDRE = 1 : DATA DDR transfer\n\n\t*((volatile uint32_t*)RPC_SMENR)      = 0xA222540C;\n\t\t\t//bit3-0   SPIDE[3:0] = 1100 : 32bit transfer\n\n\t*((volatile uint16_t*)RPC_SMWDR0)     = writeData;\n\n\t*((volatile uint32_t*)RPC_SMCR)       = 0x00000003;\n\t\t//bit2     SPIRE      = 0 : Data read disable\n\t\t//bit1     SPIWE      = 1 : Data write enable\n\t\t//bit0     SPIE       = 1 : SPI transfer start\n\tWaitRpcTxEnd();\n}\n\n\n\n\n\n\n\n\n\nvoid WriteProtectDisable(void)\n{\n\tuint32_t dataL = 0;\n\n\tdataL = *((volatile uint32_t*)RPC_PHYINT);\n\n\tif(dataL & BIT1)\n\t{\t//bit1:  WPVAL(0:RPC_WP#=H(Protect Disable), 1:RPC_WP#=L(Protect Enable))\n\t\tdataL &= ~BIT1;\n\t\t*((volatile uint32_t*)RPC_PHYINT) = dataL;\n\t}\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n//\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//\n//\tfor HyperFlash\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//\n//\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//\n//////////////////////////////////////////////////////////////////////////////////\nuint32_t ReadHyperFlashData8Byte(uint32_t addr, uint32_t *readData)\t//for HyperFlash\n{\n\tuint32_t product;\n\tuint32_t cut;\n\n\tproduct = *((volatile uint32_t*)PRR) & PRR_PRODUCT_MASK;\n\tcut = *((volatile uint32_t*)PRR) & PRR_CUT_MASK;\n\n\tif ((product ==  PRR_PRODUCT_M3) && (cut < PRR_CUT_30)) {\n\t\t*((volatile uint32_t*)RPC_PHYCNT)    = 0x00030263;\n\t\t*((volatile uint32_t*)RPC_PHYCNT)    = 0x80030263;\n\t} else {\n\t\t*((volatile uint32_t*)RPC_PHYCNT)    = 0x00038263;\n\t\t*((volatile uint32_t*)RPC_PHYCNT)    = 0x80038263;\n\t\t//bit31  CAL         =  1 : PHY calibration\n\t\t//bit1-0 PHYMEM[1:0] = 11 : HyperFlash\n\t}\n\t*((volatile uint32_t*)RPC_CMNCR)      = 0x81FFF301;\n\t\t//bit31  MD       =  1 : Manual mode\n\t\t//bit1-0 BSZ[1:0] = 01 : QSPI Flash x 2 or HyperFlash\n\t*((volatile uint32_t*)RPC_SMCMR)      = 0x00800000;\n\t\t//bit23-21 CMD[7:5] = 100 : CA47-45 = 100 => Read/memory space/WrrapedBrst\n\t*((volatile uint32_t*)RPC_SMADR)      = addr/2;\n\t*((volatile uint32_t*)RPC_SMOPR)      = 0x00000000;\n\t\t//                           CA15-3(Reserved) = all 0\n\t*((volatile uint32_t*)RPC_SMDMCR)     = 0x0000000E;\n\t\t//                           16 cycle dummy wait\n\t*((volatile uint32_t*)RPC_SMDRENR)    = 0x00005101;\n\t\t//bit8 ADDRE  = 1 : Address DDR transfer\n\t\t//bit0 SPIDRE = 1 : DATA DDR transfer\n\t*((volatile uint32_t*)RPC_SMENR)      = 0xA222D40F;\n\t\t//bit31-30 CDB[1:0]   =   10 : 4bit width command\n\t\t//bit25-24 ADB[1:0]   =   10 : 4bit width address\n\t\t//bit17-16 SPIDB[1:0] =   10 : 4bit width transfer data\n\t\t//bit15    DME        =    1 : dummy cycle enable\n\t\t//bit14    CDE        =    1 : Command enable\n\t\t//bit12    OCDE       =    1 : Option Command enable\n\t\t//bit11-8  ADE[3:0]   = 0100 : ADR[23:0] output (24 Bit Address)\n\t\t//bit7-4   OPDE[3:0]  = 0000 : Option data disable\n\t\t//bit3-0   SPIDE[3:0] = 1111 : 64bit transfer\n\t*((volatile uint32_t*)RPC_SMCR)       = 0x00000005;\n\t\t//bit2     SPIRE      = 1 : Data read enable\n\t\t//bit1     SPIWE      = 0 : Data write disable\n\t\t//bit0     SPIE       = 1 : SPI transfer start\n\n\tWaitRpcTxEnd();\n\n\treadData[1] = *((volatile uint32_t*)RPC_SMRDR0);\t//read data[63:32]\n\treadData[0] = *((volatile uint32_t*)RPC_SMRDR1);\t//read data[31:0]\n\n\treturn(readData[0]);\n}\n\n\nuint32_t ReadStatusHyperFlash(uint32_t *readData)\t//for HyperFlash\n{\n\tuint32_t addr = 0;\n\tuint32_t command = 0;\n\tuint32_t read_status = 0;\n\tuint32_t status = 0;\n\n\t//First Command\n\taddr = 0x00000555;\n\tcommand = 0x70000000;\n\tWriteCommandHyperFlash(addr, command);\n\n\tread_status = ReadHyperFlashData8Byte(0x0, readData);\t// Status Register read\n\n\tstatus = ((read_status & 0xFF000000) >> 8 ) | ((read_status & 0x00FF0000) << 8 ) | ((read_status & 0x0000FF00) >> 8 ) | ((read_status & 0x000000FF) << 8 );\n\n\tstatus = (status & 0x0000FFFF);\n\n\treturn(status);\n}\n\n\nvoid WriteDataWithBufferHyperFlash(uint32_t addr, uint32_t source_addr)\t//for HyperFlash\n{\n\tuintptr_t i=0;\n\tuint32_t product;\n\tuint32_t cut;\n\n\t*((volatile uint32_t*)RPC_DRCR)       = 0x011F0301;\n\t\t//bit9   RCF         =  1 : Read Cache Clear\n\n\tproduct = *((volatile uint32_t*)PRR) & PRR_PRODUCT_MASK;\n\tcut = *((volatile uint32_t*)PRR) & PRR_CUT_MASK;\n\n\tif ((product ==  PRR_PRODUCT_M3) && (cut < PRR_CUT_30)) {\n\t\t*((volatile uint32_t*)RPC_PHYCNT)    = 0x80030277;\n\t} else {\n\t\t*((volatile uint32_t*)RPC_PHYCNT)    = 0x80038277;\n\t\t//bit31  CAL         =  1 : PHY calibration\n\t\t//bit2   WBUF        =  1 : Write Buffer Enable\n\t\t//bit1-0 PHYMEM[1:0] = 11 : HyperFlash\n\t}\n\n\tfor(i=0;i<256;i=i+0x4)\n\t{\n\t\t(*(volatile uint32_t*)(0xEE208000+i)) = (*(volatile uint32_t*)(source_addr+i));\n\t}\n//\t*((volatile uint32_t*)RPC_PHYCNT)    = 0x80030277;\n\t\t//bit31  CAL         =  1 : PHY calibration\n\t\t//bit2   WBUF        =  1 : Write Buffer Enable\n\t\t//bit1-0 PHYMEM[1:0] = 11 : HyperFlash\n\t*((volatile uint32_t*)RPC_CMNCR)      = 0x81FFF301;\n\t\t//bit31  MD       =  1 : Manual mode\n\t\t//bit1-0 BSZ[1:0] = 01 : QSPI Flash x 2 or HyperFlash\n\t*((volatile uint32_t*)RPC_SMCMR)      = 0x00000000;\n\t\t//bit23-21 CMD[7:5] = 000 : CA47-45 = 000 => Write/memory space/WrrapedBrst\n\t*((volatile uint32_t*)RPC_SMADR)      = addr;\n\t*((volatile uint32_t*)RPC_SMOPR)      = 0x00000000;\n\t\t//                           CA15-3(Reserved) = all 0\n//\t*((volatile uint32_t*)RPC_SMDMCR)     = 0x00000007;\n\t\t//                           16 cycle dummy wait\n\t*((volatile uint32_t*)RPC_SMDRENR)    = 0x00005101;\n\t\t//bit8 ADDRE  = 1 : Address DDR transfer\n\t\t//bit0 SPIDRE = 1 : DATA DDR transfer\n\t*((volatile uint32_t*)RPC_SMENR)      = 0xA222540F;\n\t\t//bit31-30 CDB[1:0]   =   10 : 4bit width command\n\t\t//bit25-24 ADB[1:0]   =   10 : 4bit width address\n\t\t//bit17-16 SPIDB[1:0] =   10 : 4bit width transfer data\n\t\t//bit15    DME        =    0 : dummy cycle disable\n\t\t//bit14    CDE        =    1 : Command enable\n\t\t//bit12    OCDE       =    1 : Option Command enable\n\t\t//bit11-8  ADE[3:0]   = 0100 : ADR[23:0] output (24 Bit Address)\n\t\t//bit7-4   OPDE[3:0]  = 0000 : Option data disable\n\t\t//bit3-0   SPIDE[3:0] = 1111 : 64bit transfer\n\n//\t*((volatile uint32_t*)RPC_SMWDR0)     = writeData;\n\t\t//\n\t*((volatile uint32_t*)RPC_SMCR)       = 0x00000003;\n\t\t//bit2     SPIRE      = 0 : Data read disable\n\t\t//bit1     SPIWE      = 1 : Data write enable\n\t\t//bit0     SPIE       = 1 : SPI transfer start\n\n\tWaitRpcTxEnd();\n\n\tif ((product ==  PRR_PRODUCT_M3) && (cut < PRR_CUT_30)) {\n\t\t*((volatile uint32_t*)RPC_PHYCNT)    = 0x00030273;\n\t} else {\n\t\t*((volatile uint32_t*)RPC_PHYCNT)    = 0x00038273;\n\t\t//bit31  CAL         =  0 : No PHY calibration\n\t\t//bit2   WBUF        =  0 : Write Buffer Disable\n\t\t//bit1-0 PHYMEM[1:0] = 11 : HyperFlash\n\t}\n\t*((volatile uint32_t*)RPC_DRCR)       = 0x011F0301;\n\t\t//bit9   RCF         =  1 : Read Cache Clear\n}\n\n\nvoid WriteBufferOperationHyperFlash(uint32_t writeAddr, uint32_t source_addr)\n{\n\t//Word Program\n\tuint32_t addr = 0;\n\tuint32_t command = 0;\n\n\t//First Command\n\taddr = 0x00000555;\n\tcommand = 0xAA000000;\n\tWriteCommandHyperFlash(addr, command);\n\n\t//Second Command\n\taddr = 0x000002AA;\n\tcommand = 0x55000000;\n\tWriteCommandHyperFlash(addr, command);\n\n\t//Third Command\n\taddr = 0x00000555;\n\tcommand = 0xA0000000;\n\tWriteCommandHyperFlash(addr, command);\n\n\t//Fourth Command\n\taddr = (writeAddr/2);\n\tWriteDataWithBufferHyperFlash(addr, source_addr);\n}\n", "comment_ratio": 0.3223684210526316}
{"lang": "c", "code": "#ifndef ELECTRA_IRC_H\n#define ELECTRA_IRC_H\n\nvoid ThreadIRCSeed(void* parg);\n\nextern int nGotIRCAddresses;\n\n#endif\n\n", "comment_ratio": 0.3076923076923077}
{"lang": "c", "code": "#include <spi.h>\n\n//Inits a SPI peripheral in master mode\n/*\n * We will use SPI master mode which means that MCU controls the SPI clock so\n * the MCU controls the communication(hence MCU is master)\n * The other device is called slave.\n * */\nvoid initSPIMaster(volatile SPI_Type* spi)\n{\n\t//Based on A.17.1 SPI master configuration code example\n\n\t/* (1) Master selection, BR: Fpclk/256\n\t *  CPOL and CPHA at zero (rising first edge) */\n\t/* (2) Slave select output enabled, 8-bit Rx fifo */\n\t/* (3) Enable SPI1 */\n\n\tspi->CR1.bit.MSTR = 1;\n\tspi->CR1.bit.BR = 1;\n\tspi->CR1.reg = 1<<9; /* (1) */\n\n\tspi->CR2.bit.DS = 0x7;\n\tspi->CR2.bit.SSOE = 1;\n\n\tspi->CR1.bit.SPE = 1; /* (3) */\n}\n\n//send a byte to the slave using the SPI\n//based on A.17.3 SPI full duplex communication code example\nvoid sendSPIByte(volatile SPI_Type* spi, unsigned char byte)\n{\n\twhile (!spi->SR.bit.TXE) /* Wait for Tx empty */\n\t{\n\t\t;\n\t}\n\n\t/* Will inititiate 8-bit transmission if TXE */\n\t*(unsigned char *)&(spi->DR.reg) = byte;\n}\n\n", "comment_ratio": 0.1111111111111111}
{"lang": "c", "code": "#ifndef UnionFind_h\n#define UnionFind_h\n\n#include <wtf/Assertions.h>\n\nnamespace WTF {\n\n// A UnionFind class can be used to compute disjoint sets using the\n// disjoint-set forest data structure. Each UnionFind instance is a\n// node in the forest. Typically you use it by using UnionFind as a\n// superclass:\n//\n// class MemberOfSet : public UnionFind<MemberOfSet> { ... }\n//\n// Calling x->find() gives you a MemberOfSet* that represents the\n// disjoint set that x belongs to. Calling x->unify(y) unifies x's\n// set with y's set, and ensures that:\n//\n// x->find() == y->find()\n//\n// and that:\n//\n// a->find() == b->find()\n//\n// for any a, b if prior to the call to x->unify(y), we would have\n// had:\n//\n// a->find() == x\n// b->find() == y\n//\n// This implementation is almost amortized O(1), but could be worse\n// in unlikely pathological cases. It favors having a non-recursive\n// single pass implementation of unify() and find() over ensuring the\n// theoretical O(InverseAckermann[n]) amortized bound, which is much\n// closer to amortized O(1).\n\ntemplate<typename T>\nclass UnionFind {\npublic:\n    UnionFind()\n        : m_parent(0)\n    {\n    }\n    \n    bool isRoot() const\n    {\n        bool result = !m_parent;\n        ASSERT(result == (const_cast<UnionFind<T>*>(this)->find() == this));\n        return result;\n    }\n    \n    T* find()\n    {\n        T* result = static_cast<T*>(this);\n        T* next = result->m_parent;\n        while (next) {\n            result = next;\n            next = result->m_parent;\n        }\n        ASSERT(result);\n        if (result != this)\n            m_parent = result;\n        return result;\n    }\n    \n    void unify(T* other)\n    {\n        T* a = static_cast<T*>(this)->find();\n        T* b = other->find();\n        \n        ASSERT(!a->m_parent);\n        ASSERT(!b->m_parent);\n        \n        if (a == b)\n            return;\n        \n        a->m_parent = b;\n    }\nprivate:\n    T* m_parent;\n};\n\n} // namespace WTF\n\nusing WTF::UnionFind;\n\n#endif // UnionFind_h\n\n", "comment_ratio": 0.26548672566371684}
{"lang": "c", "code": "// \u64cd\u7eb5\n// Created by cc on 2021/5/27.\n//\n\n#ifndef BB_DB_DML_H\n#define BB_DB_DML_H\n#include \"DDL.h\"\n#include \"Type.h\"\n#include \"bb/Ran.h\"\n\nnamespace bb {\n    namespace sql {\n        class DML : public Type {\n        protected:\n            DDL *connect_; //\u8fde\u63a5\n            std::string database_name_; //\u5e93\u540d\u79f0\n            std::string table_name_; //\u8868\u540d\u79f0\n            std::string table_name_next_; //\u4e0b\u4e00\u4e2a_\u8868\u540d\u79f0\n            std::string where_key_ = \"*\";\n            std::array<std::string,2> where_sql_={\"\",\"\"};\n        public:\n            explicit DML(DDL *connect_a);\n\n            //\u5207\u6362\u5e76\u521b\u5efa\u5e93,\u8fde\u63a5\u5e93\u4e0d\u5b58\u5728\u65f6\u521b\u5efa\u5e76\u8fde\u63a5(\u5e93\u540d\u6700\u591a64\u4e2a\u5b57\u7b26)\n            void useDatabase(const std::string &name);\n\n            //\u521b\u5efa\u5e93\uff0c\u5e93\u540d\u6700\u591a64-10\u4e2a\u5b57\u7b26\n            void createDatabase();\n\n            //\u6539\u5e93\u540d\u79f0\n            void updateDatabase(const std::string &old_database, const std::string &new_database);\n\n            //\u4fee\u6539\u5e93\u5bc6\u7801(\u9700\u8981\u6539\u914d\u7f6e\u6587\u4ef6)\n            void setPassword(const std::string &host, const std::string &user, const std::string &password);\n\n            //\u5220\u9664\u5e93\n            void delDatabase(const std::string &database);\n            void delDatabase();\n\n            //\u5207\u6362\u8868\n            virtual void useTable(const std::string &name);\n\n            //\u521b\u5efa\u8868\uff0c\u8868\u540d\u6700\u592764-10\u4e2a\u5b57\u7b26\uff0ccrud.createTable([](auto *data){data->int_(\"a12\")->nullable_()->comment_(\"\u8fd9\u662fa1\");})\n            void createTable(void (*createF)(DML *));\n            void createTable(const std::string &name, void (*createF)(DML *));\n\n            //\u6539\u8868\u540d\u79f0\n            virtual void updateTable(const std::string &new_name);\n\n            //\u5220\u9664\u8868\n            virtual void delTable() const;\n            //\u6e05\u7a7a\u8868\n            virtual void truncate() const;\n\n            //\u8ffd\u52a0\u5217\n            void createCol(void (*createF)(DML *));\n\n            //\u6539\u5217\u540d\u79f0(key)\n            virtual void updateCol(const std::string &old_key, const std::string &new_key) const;\n\n            //\u6539\u5217\u7c7b\u578b(key)\n            void updateType(void (*createF)(DML *));\n\n            //\u5220\u9664\u5217(key)\n            virtual void delCol(const std::string &key) const;\n\n            //\u5220\u9664\u591a\u4e2a\u5217(key)\n            virtual void delCols(const std::vector<std::string> &key_arr) const;\n\n            //\u521b\u5efa\u7d22\u5f15 \u5168\u6587\u7d22\u5f15\u53ea\u652f\u6301 char\u3001varchar\u548ctext\n            void createIndex(const std::string &key, const short &type = 0) const;\n            void createIndex_(const std::vector<std::string> &key_list, const short &type = 0) const;\n\n            //\u5220\u9664\u7d22\u5f15\n            virtual void delIndex(const std::string &key);\n\n            //\u521b\u5efa\u6570\u636e{{\"\u952e1\",\"\u503c1\"},{\"k2\",\"v2\"}}\n            virtual void create(const std::vector<std::array<std::string, 2>> &data);\n            //\u6279\u91cf\u63d2\u5165\u6570\u636e{\"\u952e1\",\"\u952e2\"},{{\"v1\",\"v2\"},{\"k11\",\"v22\"}}\n            virtual void create(const std::vector<std::string> &key,const std::vector<std::vector<std::string>> &value);\n\n            //\u6539\u4e00\u884c(\u7b26\u5408\u6761\u4ef6\u7684\u4e00\u884c\u6570\u636e)\n            void update(const std::vector<std::array<std::string, 2>> &data) const;\n\n            //\u5220\u9664\u884c(\u7b26\u5408\u6761\u4ef6\u7684\u884c,where\u9700\u901a\u8fc7DQL\u6784\u5efa)\n            void del() const;\n\n            //\u5de5\u5382\n            virtual void factory(const int &number);\n        };\n    }\n}\n\n#endif //BB_DB_DML_H\n\n", "comment_ratio": 0.3157894736842105}
{"lang": "c", "code": "#ifndef JHConstants_Font_h\n#define JHConstants_Font_h\n\n#define kFont(fsize, name) [UIFont fontWithName:name size:fsize]\n#define kAppFont(size) [UIFont systemFontOfSize:size]\n#define kAppFontBold(size) [UIFont boldSystemFontOfSize:size]\n\n#define kAdaptFont(fsize, name) [UIFont fontWithName:name size:fsize*kDeviceWidthScaleTo47Inch]\n#define kAppAdaptFont(size) [UIFont systemFontOfSize:size*kDeviceWidthScaleTo47Inch]\n#define kAppAdaptFontBold(size) [UIFont boldSystemFontOfSize:size*kDeviceWidthScaleTo47Inch]\n\n#endif /* JHConstants_Font_h */\n\n", "comment_ratio": 0.3333333333333333}
{"lang": "c", "code": "#ifndef BRAVE_COMMON_CONVERTERS_FILE_PATH_CONVERTER_H_\n#define BRAVE_COMMON_CONVERTERS_FILE_PATH_CONVERTER_H_\n\n#include <string>\n\n#include \"base/files/file_path.h\"\n#include \"brave/common/converters/string16_converter.h\"\n#include \"gin/converter.h\"\n\nnamespace gin {\n\ntemplate<>\nstruct Converter<base::FilePath> {\n  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,\n                                    const base::FilePath& val) {\n    return Converter<base::FilePath::StringType>::ToV8(isolate, val.value());\n  }\n  static bool FromV8(v8::Isolate* isolate,\n                     v8::Local<v8::Value> val,\n                     base::FilePath* out) {\n    if (val->IsNull())\n      return true;\n\n    base::FilePath::StringType path;\n    if (Converter<base::FilePath::StringType>::FromV8(isolate, val, &path)) {\n      *out = base::FilePath(path);\n      return true;\n    } else {\n      return false;\n    }\n  }\n};\n\n}  // namespace gin\n\n#endif  // BRAVE_COMMON_CONVERTERS_FILE_PATH_CONVERTER_H_\n\n", "comment_ratio": 0.12195121951219512}
{"lang": "c", "code": "#ifndef __PDDL__DETAIL__PARSING__PREDICATE_DECLARATION_H\n#define __PDDL__DETAIL__PARSING__PREDICATE_DECLARATION_H\n\n#include <pddl/ASTForward.h>\n#include <pddl/Context.h>\n\nnamespace pddl\n{\nnamespace detail\n{\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\n//\n// PredicateDeclaration\n//\n////////////////////////////////////////////////////////////////////////////////////////////////////\n\nvoid parseAndAddPredicateDeclarations(Context &context, ast::Domain &domain);\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}\n}\n\n#endif\n\n", "comment_ratio": 0.23076923076923078}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n#import <CoreGraphics/CoreGraphics.h>\n#include \"ssd_prior_box.h\"\n#include \"metal_tensor_structures.h\"\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface SSDConfig : NSObject\n\n@property (nonatomic, strong) NSArray<NSString *> *classes;\n@property (nonatomic, assign) char coords;\n@property (nonatomic, assign) pb_size network_size;\n@property (nonatomic, assign) int n_pyramid_layers;\n@property (nonatomic, assign) pb_size *feature_map_sizes;\n@property (nonatomic, assign) float *scales;\n@property (nonatomic, assign) float *variances;\n@property (nonatomic, assign) pb_ratios *aspect_ratios;\n@property (nonatomic, assign) bool two_boxes_for_ar1;\n@property (nonatomic, assign) bool normalize_coords;\n@property (nonatomic, assign) bool clip_boxes;\n@property (nonatomic, assign) float confidence_thresh;\n@property (nonatomic, assign) float iou_thresh;\n@property (nonatomic, assign) pb_vector *steps;\n@property (nonatomic, assign) pb_vector *offsets;\n@property (nonatomic, assign) DataShape *location_shapes;\n@property (nonatomic, assign) DataShape *confidence_shapes;\n\n- (instancetype)initWithDictionary:(NSDictionary *)dictionary;\n\n- (pb_size *)networkSizeRef;\n\n@end\n\nNS_ASSUME_NONNULL_END\n\n", "comment_ratio": 0.16279069767441862}
{"lang": "c", "code": "#ifndef PSYCHE_C_SCOPE_H__\n#define PSYCHE_C_SCOPE_H__\n\n#include \"API.h\"\n#include \"Fwds.h\"\n\n#include \"ScopeKind.h\"\n\n#include <memory>\n#include <cstdint>\n#include <unordered_map>\n#include <vector>\n\nnamespace psy {\nnamespace C {\n\n/**\n * \\brief The Scope class.\n *\n * \\remark 6.2.1\n */\nclass PSY_C_API Scope\n{\n    friend class Binder;\n\npublic:\n    virtual ~Scope();\n\n    /**\n     * The Kind of \\c this Scope.\n     */\n    ScopeKind kind() const;\n\nprivate:\n    Scope(ScopeKind kind);\n\n    void enclose(std::unique_ptr<Scope> scope);\n    void morphFrom_FunctionPrototype_to_Block();\n\n    ScopeKind kind_;\n    std::vector<std::unique_ptr<Scope>> enclosedScopes_;\n};\n\n} // C\n} // psy\n\n#endif\n\n", "comment_ratio": 0.3088235294117647}
{"lang": "c", "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\n#include \"harness.h\"\n#include \"queue.h\"\n\n/*\n * Create empty queue.\n * Return NULL if could not allocate space.\n */\nqueue_t *q_new()\n{\n    queue_t *q = malloc(sizeof(queue_t));\n    if (!q)\n        return NULL;\n    q->head = NULL;\n    q->tail = NULL;\n    q->size = 0;\n    return q;\n}\n\n/* Free all storage used by queue */\nvoid q_free(queue_t *q)\n{\n    if (!q) {\n        return;\n    }\n\n    while (q->head) {\n        list_ele_t* rm_node = q->head;\n        q->head = q->head->next;\n        free(rm_node->value);\n        free(rm_node);\n    }\n    free(q);\n}\n\n/*\n * Attempt to insert element at head of queue.\n * Return true if successful.\n * Return false if q is NULL or could not allocate space.\n * Argument s points to the string to be stored.\n * The function must explicitly allocate space and copy the string into it.\n */\nbool q_insert_head(queue_t *q, char *s)\n{\n    list_ele_t *newh;\n\n    /*\n     * DO NOT do this check after malloc\n     * Memory leak is prone to happen\n     */\n    if (!q) {\n        return false;\n    }\n\n    newh = malloc(sizeof(list_ele_t));\n    if (!newh) {\n        return false;\n    }\n    newh->next = NULL;\n    newh->value = NULL;\n\n    /*\n     * Extra 1 bytes for '\\0'\n     * Is calling strlen(s) bad for performance ??\n     */\n    size_t copy_size = (sizeof(char) * strlen(s)) + (sizeof(char) * 1);\n    newh->value = (char*) malloc(copy_size);\n    if (!newh->value) {\n        /* Failed to construct newh, free it! */\n        free(newh);\n        return false;\n    }\n    memcpy(newh->value, s, copy_size);\n\n    if (!q->head) {\n        q->head = q->tail = newh;\n    } else {\n        newh->next = q->head;\n        q->head = newh;\n    }\n    q->size += 1;\n    return true;\n}\n\n/*\n * Attempt to insert element at tail of queue.\n * Return true if successful.\n * Return false if q is NULL or could not allocate space.\n * Argument s points to the string to be stored.\n * The function must explicitly allocate space and copy the string into it.\n */\nbool q_insert_tail(queue_t *q, char *s)\n{\n    list_ele_t* newt;\n\n    if (!q) {\n        return false;\n    }\n\n    newt = malloc(sizeof(list_ele_t));\n    if (!newt) {\n        return false;\n    }\n    newt->next = NULL;\n    newt->value = NULL;\n\n    /*\n     * Extra 1 bytes for '\\0'\n     * Is calling strlen(s) bad for performance ??\n     */\n    size_t copy_size = (sizeof(char) * strlen(s)) + (sizeof(char) * 1);\n    newt->value = (char*) malloc(copy_size);\n    if (!newt->value) {\n        /* Failed to construct newt, free it! */\n        free(newt);\n        return false;\n    }\n    memcpy(newt->value, s, copy_size);\n\n    if (!q->tail) {\n        q->head = q->tail = newt;\n    } else {\n        q->tail->next = newt;\n        q->tail = newt;\n    }\n    q->size += 1;\n    return true;\n}\n\n/*\n * Attempt to remove element from head of queue.\n * Return true if successful.\n * Return false if queue is NULL or empty.\n * If sp is non-NULL and an element is removed, copy the removed string to *sp\n * (up to a maximum of bufsize-1 characters, plus a null terminator.)\n * The space used by the list element and the string should be freed.\n */\nbool q_remove_head(queue_t *q, char *sp, size_t bufsize)\n{\n    if (!q || !q->head) {\n        return false;\n    }\n\n    list_ele_t* rm_node = q->head;\n    q->head = q->head->next;\n    q->size -= 1;\n    if (!q->head) {\n        q->tail = NULL;\n    }\n\n    size_t copy_size = (sizeof(char) * strlen(rm_node->value)) + (sizeof(char) * 1);\n    if (sp)\n    {\n        memcpy(sp, rm_node->value, copy_size <= bufsize ? copy_size : bufsize);\n        sp[bufsize-1] = '\\0';\n    }\n\n    free(rm_node->value);\n    free(rm_node);\n    return true;\n}\n\n/*\n * Return number of elements in queue.\n * Return 0 if q is NULL or empty\n */\nint q_size(queue_t *q)\n{\n    if (!q)\n        return 0;\n    return q->size;\n}\n\n/*\n * Reverse elements in queue\n * No effect if q is NULL or empty\n * This function should not allocate or free any list elements\n * (e.g., by calling q_insert_head, q_insert_tail, or q_remove_head).\n * It should rearrange the existing ones.\n */\nvoid q_reverse(queue_t *q)\n{\n    if (!q || !q->head) {\n        return;\n    }\n\n    q->tail = q->head;\n    \n    list_ele_t* cur = q->head->next;\n    while (cur) {\n        list_ele_t* prev = q->head;\n        q->head = cur;\n        cur = cur->next;\n        q->head->next = prev;\n    }\n    q->tail->next = NULL;\n}\n\n/*\n * Sort linked list\n * Return the head of linked list\n */\nstatic list_ele_t* q_sort_mergesort(list_ele_t* p1)\n{\n    if (!p1->next)\n        return p1;\n    list_ele_t* stp1 = p1;\n    list_ele_t* stp2 = p1->next;\n    while (stp2 && stp2->next) {\n        stp1 = stp1->next;\n        stp2 = stp2->next->next;\n    }\n    list_ele_t* p2 = stp1->next;\n    stp1->next = NULL;\n\n    p1 = q_sort_mergesort(p1);\n    p2 = q_sort_mergesort(p2);\n\n    /* make *p1 < *p2, i.e., make p1 be the head of list */\n    if (strcmp(p1->value, p2->value) > 0) {\n        list_ele_t* tmp = p1;\n        p1 = p2;\n        p2 = tmp;\n    }\n    list_ele_t* ret_head = p1;\n    list_ele_t* p3 = p1->next;\n\n    /* p1 is the smallest among the three, p2 or p3 is p1's successor */\n    while (p2 && p3) {\n        int res = strcmp(p2->value, p3->value);\n        if (res < 0) {\n            p1->next = p2;\n            p1 = p2;\n            p2 = p2->next;\n        }\n        else {\n            p1->next = p3;\n            p1 = p3;\n            p3 = p3->next;\n        }\n    }\n    p1->next = p2 ? p2 : p3;\n\n    return ret_head;\n}\n\n/*\n * Sort elements of queue in ascending order\n * No effect if q is NULL or empty. In addition, if q has only one\n * element, do nothing.\n */\nvoid q_sort(queue_t *q)\n{\n    if (q_size(q) <= 1)\n        return;\n\n    q->head = q_sort_mergesort(q->head);\n\n    /* O(n) reconstruct q->tail */\n    while (q->tail->next)\n    {\n        q->tail = q->tail->next;\n    }\n}\n\n\n// void merge_sort(list_ele_t **head)\n// {\n//     if (!(*head) || !((*head)->next))\n//         return;\n\n//     list_ele_t *l1 = (*head)->next;  \n//     list_ele_t *l2 = *head;          \n\n//     while (l1 && l1->next) {\n//         l2 = l2->next;\n//         l1 = l1->next->next;\n//     }\n//     l1 = l2->next;\n//     l2->next = NULL;\n//     l2 = *head;\n\n//     merge_sort(&l2);\n//     merge_sort(&l1);\n\n//     *head = NULL;\n//     list_ele_t **tmp = head;\n\n//     while (l1 && l2) {\n//         if (strcmp(l1->value, l2->value) < 0) {  \n//             *tmp = l1;\n//             l1 = l1->next;\n//         } else {\n//             *tmp = l2;\n//             l2 = l2->next;\n//         }\n//         tmp = &((*tmp)->next);\n//     }\n\n//     *tmp = l1 ? l1 : l2;\n// }\n\n// void q_sort(queue_t *q)\n// {\n//     // if q has only one element or q is empty, q->head == q->tail\n//     if (!q || q->head == q->tail) {\n//         return;\n//     }\n\n//     merge_sort(&q->head);\n\n//     while (q->tail->next) {\n//         q->tail = q->tail->next;\n//     }\n// }\n", "comment_ratio": 0.12539184952978055}
{"lang": "c", "code": "#ifndef COMPONENTS_PERFORMANCE_MANAGER_FREEZING_FREEZING_VOTE_AGGREGATOR_H_\n#define COMPONENTS_PERFORMANCE_MANAGER_FREEZING_FREEZING_VOTE_AGGREGATOR_H_\n\n#include \"base/compiler_specific.h\"\n#include \"base/containers/circular_deque.h\"\n#include \"base/containers/flat_map.h\"\n#include \"components/performance_manager/public/freezing/freezing.h\"\n#include \"components/performance_manager/public/graph/graph_registered.h\"\n#include \"components/performance_manager/public/graph/node_data_describer.h\"\n#include \"components/performance_manager/public/voting/voting.h\"\n\nnamespace performance_manager {\n\nclass FreezingVoteDecorator;\nclass PageNode;\n\nnamespace freezing {\n\n// An aggregator for freezing votes. It upstreams an aggregated vote to an\n// upstream channel every time the freezing decision changes for a PageNode. It\n// allows freezing of a given PageNode upon reception of one or several\n// kCanFreeze vote for this node. Any kCannotFreeze vote received will have\n// priority over the kCanFreeze votes and will prevent the PageNode from being\n// frozen.\n//\n// This is a GraphRegistered object, once created this instance can be\n// retrieved via:\n//     graph()->GetRegisteredObjectAs<freezing::FreezingVoteAggregator>();\nclass FreezingVoteAggregator final\n    : public FreezingVoteObserver,\n      public NodeDataDescriberDefaultImpl,\n      public GraphRegisteredImpl<FreezingVoteAggregator> {\n public:\n  FreezingVoteAggregator(const FreezingVoteAggregator& rhs) = delete;\n  FreezingVoteAggregator& operator=(const FreezingVoteAggregator& rhs) = delete;\n  ~FreezingVoteAggregator() override;\n\n  // Issues a voting channel (effectively registered a voter).\n  FreezingVotingChannel GetVotingChannel();\n\n  // Sets the upstream voting channel. Should only be called once.\n  void SetUpstreamVotingChannel(FreezingVotingChannel&& channel);\n\n  // FreezingVoteObserver implementation:\n  void OnVoteSubmitted(FreezingVoterId voter_id,\n                       const PageNode* page_node,\n                       const FreezingVote& vote) override;\n  void OnVoteChanged(FreezingVoterId voter_id,\n                     const PageNode* page_node,\n                     const FreezingVote& new_vote) override;\n  void OnVoteInvalidated(FreezingVoterId voter_id,\n                         const PageNode* page_node) override;\n\n  void RegisterNodeDataDescriber(Graph* graph);\n  void UnregisterNodeDataDescriber(Graph* graph);\n\n  // NodeDataDescriber implementation:\n  base::Value DescribePageNodeData(const PageNode* node) const override;\n\n private:\n  friend class performance_manager::FreezingVoteDecorator;\n  friend class FreezingVoteAggregatorTest;\n  friend class FreezingVoteAggregatorTestAccess;\n\n  // Private constructor, in practice the FreezingVoteDecorator is responsible\n  // for maintaining the lifetime of this object.\n  FreezingVoteAggregator();\n\n  // Contains the freezing votes for a given PageNode.\n  class FreezingVoteData {\n   public:\n    // The consequence that adding, removing or updating a vote has on the\n    // upstreamed vote. The caller is responsible for calling UpstreamVote or\n    // invalidating the vote (by destroying the instance of this class that owns\n    // it).\n    enum class UpstreamVoteImpact {\n      // The upstream vote has changed. UpstreamVote should be called.\n      kUpstreamVoteChanged,\n      // The upstream vote has been removed and should be invalidated.\n      kUpstreamVoteRemoved,\n      // The operation had no impact on the upstreamed vote.\n      kUpstreamVoteUnchanged,\n    };\n\n    FreezingVoteData();\n    FreezingVoteData(FreezingVoteData&&);\n    FreezingVoteData& operator=(FreezingVoteData&&);\n    FreezingVoteData(const FreezingVoteData& rhs) = delete;\n    FreezingVoteData& operator=(const FreezingVoteData& rhs) = delete;\n    ~FreezingVoteData();\n\n    // Adds a new vote.\n    void AddVote(FreezingVoterId voter_id, const FreezingVote& vote);\n\n    // Updates an existing vote.\n    void UpdateVote(FreezingVoterId voter_id, const FreezingVote& new_vote);\n\n    // Removes an existing vote\n    void RemoveVote(FreezingVoterId voter_id);\n\n    // Upstreams the vote for this vote data, using the given voting |channel|.\n    void UpstreamVote(const PageNode* page_node,\n                      FreezingVotingChannel* channel);\n\n    bool IsEmpty() { return votes_.empty(); }\n\n    // Returns the chosen vote. Invalid to call if IsEmpty() is true.\n    const FreezingVote& GetChosenVote();\n\n    // Helper for FreezingVoteAggregator::DescribePageNodeData.\n    void DescribeVotes(base::Value* ret) const;\n\n   private:\n    friend class FreezingVoteAggregatorTestAccess;\n\n    // The current set of votes.\n    using VotesDeque =\n        base::circular_deque<std::pair<FreezingVoterId, FreezingVote>>;\n\n    const VotesDeque& GetVotesForTesting() { return votes_; }\n\n    // Returns the iterator of |voter_id| in |votes_|. |voter_id| is expected\n    // to be in the deque, this is enforced by a DCHECK.\n    VotesDeque::iterator FindVote(FreezingVoterId voter_id);\n\n    void AddVoteToDeque(FreezingVoterId voter_id, const FreezingVote& vote);\n\n    // kCannotFreeze votes are always at the beginning of the deque.\n    VotesDeque votes_;\n  };\n  using VoteDataMap = base::flat_map<const PageNode*, FreezingVoteData>;\n\n  // Looks up the VoteData associated with the provided |page_node|. The data is\n  // expected to already exist (enforced by a DCHECK).\n  VoteDataMap::iterator GetVoteData(const PageNode* page_node);\n\n  // A map that associates a PageNode with a FreezingVoteData structure.\n  VoteDataMap vote_data_map_;\n\n  // The channel for upstreaming our votes.\n  FreezingVotingChannel channel_;\n\n  // Provides FreezingVotingChannels to our input voters.\n  FreezingVotingChannelFactory freezing_voting_channel_factory_{this};\n};\n\n}  // namespace freezing\n}  // namespace performance_manager\n\n#endif  // COMPONENTS_PERFORMANCE_MANAGER_FREEZING_FREEZING_VOTE_AGGREGATOR_H_\n\n", "comment_ratio": 0.2903225806451613}
{"lang": "c", "code": "/*\n* linux/lib/write.c\n*\n* (C) 1991 Linus Torvalds\n*/\n\n#define __LIBRARY__\n#include <unistd.h>\t\t// Linux \u6807\u51c6\u5934\u6587\u4ef6\u3002\u5b9a\u4e49\u4e86\u5404\u79cd\u7b26\u53f7\u5e38\u6570\u548c\u7c7b\u578b\uff0c\u5e76\u7533\u660e\u4e86\u5404\u79cd\u51fd\u6570\u3002\n// \u5982\u5b9a\u4e49\u4e86__LIBRARY__\uff0c\u5219\u8fd8\u5305\u62ec\u7cfb\u7edf\u8c03\u7528\u53f7\u548c\u5185\u5d4c\u6c47\u7f16_syscall0()\u7b49\u3002\n\n//// \u5199\u6587\u4ef6\u7cfb\u7edf\u8c03\u7528\u51fd\u6570\u3002\n// \u8be5\u5b8f\u7ed3\u6784\u5bf9\u5e94\u4e8e\u51fd\u6570\uff1aint write(int fd, const char * buf, off_t count)\n// \u53c2\u6570\uff1afd - \u6587\u4ef6\u63cf\u8ff0\u7b26\uff1bbuf - \u5199\u7f13\u51b2\u533a\u6307\u9488\uff1bcount - \u5199\u5b57\u8282\u6570\u3002\n// \u8fd4\u56de\uff1a\u6210\u529f\u65f6\u8fd4\u56de\u5199\u5165\u7684\u5b57\u8282\u6570(0 \u8868\u793a\u5199\u51650 \u5b57\u8282)\uff1b\u51fa\u9519\u65f6\u5c06\u8fd4\u56de-1\uff0c\u5e76\u4e14\u8bbe\u7f6e\u4e86\u51fa\u9519\u53f7\u3002\n_syscall3 (int, write, int, fd, const char *, buf, off_t, count)\n\n", "comment_ratio": 0.375}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface _30IGListViewController : UIViewController\n\n@end\n\nNS_ASSUME_NONNULL_END\n\n", "comment_ratio": 0.3888888888888889}
{"lang": "c", "code": "#pragma once\n\n#include \"Map/Frame.h\"\n#include \"Map/LocalMap.h\"\n#include \"System/SnakeGlobal.h\"\nnamespace Snake\n{\nclass SnakeORBMatcher\n{\n   public:\n    SnakeORBMatcher();\n\n    // BF Tracking and Loop Closing\n    int SearchByProjectionFrameToKeyframe(Frame& CurrentFrame, const Keyframe& kf, float th,\n                                          FeatureDistance featureError);\n\n    // Fine Tracking\n    int SearchByProjection2(Frame& CurrentFrame, LocalMap<FineTrackingPoint>& lm, const float th, float ratio,\n                            int num_threads);\n\n    // Coarse Tracking\n    int SearchByProjectionFrameFrame2(Frame& CurrentFrame, const LocalMap<CoarseTrackingPoint>& lm, const float th,\n                                      FeatureDistance featureError, int num_threads);\n\n\n   private:\n    static constexpr int TH_HIGH               = 100;\n    static constexpr int TH_MEDIUM             = 75;\n    static constexpr int TH_LOW                = 50;\n    static constexpr int HISTO_LENGTH          = 30;\n    static constexpr float disparity_threshold = 4;\n\n    vector<int> tmp_indices;\n    vector<bool> tmp_flags;\n\n    std::array<std::vector<int>, HISTO_LENGTH> rotHist;\n\n    // OMP variables\n    vector<vector<int>> tmp_indices_omp;\n    vector<std::pair<int, int>> tmp_matches_world_image;\n    //    vector<vector<std::pair<int, int>>> tmp_fuseCandidates;\n    //    SE3 currentPose;\n    //    Vec3 cameraPosition;\n    //    int N;\n    //    int matches;\n};\n\n}  // namespace Snake\n\n", "comment_ratio": 0.17857142857142858}
{"lang": "c", "code": "#include <avr/io.h>\n#include <util/delay.h>\n#include <avr/interrupt.h>\n#include <string.h>\n#include <stdio.h>\n#include \"lcd.h\"\n\nuint8_t FLAG = 0x00;\nuint8_t BUTTON_STATES = 0x00;\n\nISR(PCINT0_vect)\n{\n    if (bit_is_set(PINB, PB1))\n    {\n        BUTTON_STATES &= ~_BV(0);\n    }\n    else\n    {\n        BUTTON_STATES |= _BV(0);\n    }\n\n    if (bit_is_set(PINB, PB0))\n    {\n        BUTTON_STATES &= ~_BV(1);\n    }\n    else\n    {\n        BUTTON_STATES |= _BV(1);\n    }\n}\n\nvoid init_spi_master(void)\n{\n    // Setup SPI IO pins (MOSI and SCK)\n    DDRD |= _BV(PD3) | _BV(PD4);\n\n    // Enable SPI\n    SPCR |=  _BV(SPE) | _BV(MSTR) | _BV(SPR0);\n\n    // Enable alternate SPI (MISO_A, MOSI_A, etc)\n    // Take this out if you are using standard pins!\n    MCUCR |= _BV(SPIPS);\n}\n\nuint8_t spi_message(uint8_t msg)\n{\n    // Set message\n    SPDR = msg;\n\n    // Wait for transmission to finish\n    while(!(SPSR & (1<<SPIF)));\n\n    return SPDR;\n}\n\nint main (void)\n{\n    // Global interrupts\n    sei();\n\n    // Enable LCD\n    lcd_init(LCD_DISP_ON_CURSOR_BLINK);\n\n    // Hello!\n    lcd_puts(\"SPI Example\\nPress Button\");\n\n    // Setup LED IO pins\n    DDRD |= _BV(PD0) | _BV(PD1);\n\n    // Button Interrupts\n    PCICR |= _BV(PCIE0);\n    PCMSK0 |= _BV(PCINT0) | _BV(PCINT1);\n\n    // SPI init\n    init_spi_master();\n\n    uint8_t msg = 0x01;\n\n    // Slave Select\n    DDRC |= _BV(PC1);\n    PORTC &= ~_BV(PC1);\n\n    while(1)\n    {\n        if( bit_is_set(BUTTON_STATES, 0))\n        {\n            uint8_t rec = spi_message(msg);\n            msg++;\n\n            lcd_clrscr();\n            char buffer[16];\n            sprintf(buffer, \"val: %x %x\", msg, rec);\n            lcd_puts(buffer);\n            //_delay_ms(1000);\n\n            BUTTON_STATES &= ~_BV(0);\n        }\n\n        PORTD ^= _BV(PD0);\n        _delay_ms(200);\n    }\n}\n\n", "comment_ratio": 0.13592233009708737}
{"lang": "c", "code": "#ifndef ENTITY_TYPES_H\r\n#define ENTITY_TYPES_H\r\n\r\n#include <iostream>\r\n#include \"Generic/common/Symbol.h\"\r\n#include \"Generic/tokens/SymbolSubstitutionMap.h\"\r\n\r\nnamespace DataPreprocessor {\r\n\r\n\tclass EntityTypes {\r\n\tpublic:\r\n\t\tEntityTypes();\r\n\t\tEntityTypes(const char *file_name, bool useDefault=true);\r\n\r\n\t\tSymbol lookup(Symbol foundType) const;\r\n\r\n\t\t/// Writes a description of the map to the given output stream.\r\n\t\tvoid dump(std::ostream &out, int indent = 0) const;\r\n\r\n\tprivate:\r\n\t\tvoid init(const char *file_name, bool useDefault);\r\n\r\n\t\tSymbolSubstitutionMap *_typeMap;\r\n\r\n\t};\r\n\r\n} // namespace DataPreprocessor\r\n\r\n\r\n#endif\r\n\n", "comment_ratio": 0.11764705882352941}
{"lang": "c", "code": "#ifndef CHROMEOS_SERVICES_BLUETOOTH_CONFIG_FAKE_BLUETOOTH_DEVICE_STATUS_OBSERVER_H_\n#define CHROMEOS_SERVICES_BLUETOOTH_CONFIG_FAKE_BLUETOOTH_DEVICE_STATUS_OBSERVER_H_\n\n#include <vector>\n\n#include \"base/run_loop.h\"\n#include \"chromeos/services/bluetooth_config/public/mojom/cros_bluetooth_config.mojom.h\"\n#include \"mojo/public/cpp/bindings/pending_remote.h\"\n#include \"mojo/public/cpp/bindings/receiver.h\"\n\nnamespace chromeos {\nnamespace bluetooth_config {\n\nclass FakeBluetoothDeviceStatusObserver\n    : public mojom::BluetoothDeviceStatusObserver {\n public:\n  FakeBluetoothDeviceStatusObserver();\n  ~FakeBluetoothDeviceStatusObserver() override;\n\n  // Generates a PendingRemote associated with this object. To disconnect the\n  // associated Mojo pipe, use DisconnectMojoPipe().\n  mojo::PendingRemote<mojom::BluetoothDeviceStatusObserver>\n  GeneratePendingRemote();\n\n  // Disconnects the Mojo pipe associated with a PendingRemote returned by\n  // GeneratePendingRemote().\n  void DisconnectMojoPipe();\n\n  const std::vector<mojom::PairedBluetoothDevicePropertiesPtr>&\n  paired_device_properties_list() const {\n    return paired_device_properties_list_;\n  }\n\n  const std::vector<mojom::PairedBluetoothDevicePropertiesPtr>&\n  connected_device_properties_list() const {\n    return connected_device_properties_list_;\n  }\n\n  const std::vector<mojom::PairedBluetoothDevicePropertiesPtr>&\n  disconnected_device_properties_list() const {\n    return disconnected_device_properties_list_;\n  }\n\n private:\n  // mojom::BluetoothDeviceStatusObserver:\n  void OnDevicePaired(\n      mojom::PairedBluetoothDevicePropertiesPtr device) override;\n  void OnDeviceConnected(\n      mojom::PairedBluetoothDevicePropertiesPtr device) override;\n  void OnDeviceDisconnected(\n      mojom::PairedBluetoothDevicePropertiesPtr device) override;\n\n  std::vector<mojom::PairedBluetoothDevicePropertiesPtr>\n      paired_device_properties_list_;\n  std::vector<mojom::PairedBluetoothDevicePropertiesPtr>\n      connected_device_properties_list_;\n  std::vector<mojom::PairedBluetoothDevicePropertiesPtr>\n      disconnected_device_properties_list_;\n  mojo::Receiver<mojom::BluetoothDeviceStatusObserver> receiver_{this};\n};\n\n}  // namespace bluetooth_config\n}  // namespace chromeos\n\n#endif  // CHROMEOS_SERVICES_BLUETOOTH_CONFIG_FAKE_BLUETOOTH_DEVICE_STATUS_OBSERVER_H_\n\n", "comment_ratio": 0.15714285714285714}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n#import <mach-o/nlist.h>\n\n@class ECVIMachOSection, ECVIMachOBinary;\n\ntypedef NS_ENUM(uint8_t, ECVISymbolGroup) {\n\tECVISymbolGroupNone = 0,\n\tECVISymbolGroupLocal,\n\tECVISymbolGroupExternal,\n\tECVISymbolGroupUndefined,\n};\n\n@interface ECVIMachOSymbol : NSObject\n\n- (instancetype)initWithBinary:(ECVIMachOBinary *)binary symbol:(const struct nlist *)symbol idx:(uint32_t)nsym strings:(const char **)strings error:(NSError **)error;\n- (instancetype)initWithBinary:(ECVIMachOBinary *)binary symbol64:(const struct nlist_64 *)symbol idx:(uint32_t)nsym strings:(const char **)strings error:(NSError **)error;\n\n@property(nonatomic,readonly) ECVIMachOBinary *binary;\n@property(nonatomic,readonly) NSString *rawName;\n@property(nonatomic,readonly) NSString *unmangledName;\n@property(nonatomic,readonly) uint32_t idx;\n@property(nonatomic,readonly) uint64_t address;\n@property(nonatomic,readonly) const void *codeStart;\n@property(nonatomic,readonly) uint8_t type;\n@property(nonatomic,readonly) bool isExternal;\n@property(nonatomic,readonly) bool isPrivateExternal;\n@property(nonatomic,readonly) ECVIMachOSection *section;\n@property(nonatomic,readonly) uint8_t referenceFlags;\n@property(nonatomic,readonly) bool isDynamicallyReferenced;\n@property(nonatomic,readonly) uint8_t libraryOrdinal;\n@property(nonatomic,readonly) bool isWeakDefinition;\n@property(nonatomic,readonly) bool isWeakReference;\n@property(nonatomic,readonly) bool isARMThumb;\n@property(nonatomic,readonly) ECVISymbolGroup group;\n\n@end\n\n", "comment_ratio": 0.15555555555555556}
{"lang": "c", "code": "#ifndef\t\t_BW_SCANNER_STATE_H_\n#define\t\t_BW_SCANNER_STATE_H_\n\n//------------------------------------------------------------------------------\n//\tincludes\n//------------------------------------------------------------------------------\n#ifndef\t\t_BW_SCANNER_STATE_INFO_H_\n#include\t\"scanner_state_info.h\"\n#endif\t//\t_BW_SCANNER_STATE_INFO_H_\n\n//------------------------------------------------------------------------------\n//\tclass definitions\n//------------------------------------------------------------------------------\nclass\tScannerState\n{\n\tpublic:\n\t\tScannerState (void);\n\t\tScannerState (const ScannerState& scannerState);\n\t\tScannerState&\t\toperator = (const ScannerState& scannerState);\nconst\tScannerStateInfo&\toperator [] (uInt index);\n\t\tvoid\t\t\t\tSaveScannerState (ofstream& stream);\n\t\tvoid\t\t\t\tLoadScannerState (ifstream& stream);\n\t\tbool\t\t\t\tSet (uInt2 input, uInt2 nextState, uInt2 storage, uInt2 action);\n\t\tvoid\t\t\t\tSetAll (uInt2 nextState, uInt2 storage, uInt2 action);\n\tpublic:\n\t\tconst enum\n\t\t{\n\t\t\tDEFAULT_STATE = 0,\n\t\t\tINVALID_STATE = 0xffff,\n\t\t\tSTATE_COUNT = 128\n\t\t};\n\tprivate:\n\t\tScannerStateInfo\tmyStateInfo[STATE_COUNT];\n};\n\n//------------------------------------------------------------------------------\n\n#endif\t//\t_BW_SCANNER_STATE_H_\n\n", "comment_ratio": 0.29545454545454547}
{"lang": "c", "code": "#ifndef _JITHOST\n#define _JITHOST\n\nclass JitHost final : public ICorJitHost\n{\npublic:\n    JitHost(JitInstance& jitInstance);\n\n#include \"icorjithostimpl.h\"\n\nprivate:\n    bool convertStringValueToInt(const WCHAR* key, const WCHAR* stringValue, int& result);\n\n    JitInstance& jitInstance;\n};\n\n#endif\n\n", "comment_ratio": 0.17391304347826086}
{"lang": "c", "code": "#import <CoreDAV/CoreDAVItem.h>\n\n@class CoreDAVLeafItem, CoreDAVItem, CoreDAVErrorItem;\n\n@interface CoreDAVPropStatItem : CoreDAVItem {\n\n\tCoreDAVLeafItem* _status;\n\tCoreDAVItem* _prop;\n\tCoreDAVErrorItem* _errorItem;\n\tCoreDAVLeafItem* _responseDescription;\n\n}\n\n@property (nonatomic,retain) CoreDAVLeafItem * status;                           //@synthesize status=_status - In the implementation block\n@property (nonatomic,retain) CoreDAVItem * prop;                                 //@synthesize prop=_prop - In the implementation block\n@property (nonatomic,retain) CoreDAVErrorItem * errorItem;                       //@synthesize errorItem=_errorItem - In the implementation block\n@property (nonatomic,retain) CoreDAVLeafItem * responseDescription;              //@synthesize responseDescription=_responseDescription - In the implementation block\n+(id)copyParseRules;\n-(id)description;\n-(id)init;\n-(CoreDAVLeafItem *)status;\n-(void)setStatus:(CoreDAVLeafItem *)arg1 ;\n-(CoreDAVErrorItem *)errorItem;\n-(CoreDAVLeafItem *)responseDescription;\n-(void)setErrorItem:(CoreDAVErrorItem *)arg1 ;\n-(void)setResponseDescription:(CoreDAVLeafItem *)arg1 ;\n-(CoreDAVItem *)prop;\n-(void)setProp:(CoreDAVItem *)arg1 ;\n@end\n\n\n", "comment_ratio": 0.10256410256410256}
{"lang": "c", "code": "\ufeff#pragma once\n#include <stdint.h>\n#include <assert.h>\n#include <functional>\n#include \"xx_typehelpers.h\"\n\nnamespace xx {\n\n    // \u7c7b\u4f3c\u6570\u7ec4\uff0c\u5f53\u5bf9\u8c61\u4e0d\u65ad\u63d2\u5165\u5220\u9664\u65f6, \u5176\u4e0b\u6807\u5e76\u4e0d\u4f1a\u53d1\u751f\u6539\u53d8. \u6709\u522b\u4e8e\u57fa\u4e8e\u6570\u7ec4\u7684\u4ea4\u6362\u5220\u9664.\n    // \u8be5\u7279\u6027\u901a\u5e38\u7528\u4e8e\u5b9e\u73b0\u5f31\u5f15\u7528\u6307\u9488. \u901a\u8fc7 ItemPool*, version, index \u6765\u5224\u65ad\u5bf9\u8c61\u662f\u5426\u6709\u6548\n    template<typename Value, typename Size_t = int, typename Version_t = int64_t>\n    struct ItemPool {\n        struct Data {\n            Version_t version;\n            Value value;\n            Size_t next;\t// \u5b58\u653e\u4e0b\u4e00\u4e2a free \u7a7a\u95f4\u7684\u4e0b\u6807\n        };\n\n        // [\u6307\u9488, \u7248\u672c\u53f7] \u6570\u7ec4\n        Data* buf = nullptr;\n        // buf \u957f\n        Size_t cap = 0;\n        // \u6570\u636e\u533a\u57df\u957f( \u5e76\u975e\u5143\u7d20\u4e2a\u6570 )\n        Size_t len = 0;\n\n        // \u81ea\u7531\u7a7a\u95f4\u94fe\u8868\u5934\n        Size_t freeHeader = -1;\n        // \u81ea\u7531\u7a7a\u95f4\u94fe\u957f\n        Size_t freeCount = 0;\n\n        // \u81ea\u589e\u5e8f\u53f7. Add \u65f6 ++version \u586b\u5145\n        Version_t version = 0;\n\n        // \u8ba1\u7b97\u5e76\u8fd4\u56de\u5143\u7d20\u4e2a\u6570\n        Size_t Count() {\n            return len - freeCount;\n        }\n\n        ItemPool(Size_t const& cap = 8192)\n                : cap(cap) {\n            assert(cap);\n            buf = (Data*)malloc(cap * sizeof(Data));\n        }\n\n        ~ItemPool() {\n            Clear();\n            free(buf);\n            buf = nullptr;\n        }\n\n        // \u904d\u5386\u6e05\u9664\u5df2\u5b58\u5728\u7684\u5bf9\u8c61\u3002\u53ef\u4f20\u5165\u9884\u5904\u7406\u51fd\u6570\u3002\n        void Clear(std::function<void(Size_t const& idx, Data & data)>&& cb = nullptr) noexcept {\n            if (!len) return;\n            for (Size_t i = 0; i < len; ++i) {\n                if (buf[i].version) {\n                    if (cb) {\n                        cb(i, buf[i]);\n                    }\n                    if constexpr (!IsPod_v<Value>) {\n                        buf[i].value.~Value();\n                    }\n                }\n            }\n            freeHeader = -1;\n            freeCount = 0;\n            len = 0;\n        }\n\n        // \u6dfb\u52a0\u5e76\u8fd4\u56de\u5b58\u653e\u70b9\u4e0b\u6807\uff0c\u53ef\u7528\u4e8e RemoveAt, At\n        template<typename ...Args>\n        Size_t Add(Args&&...args) {\n            auto idx = Alloc();\n            new (&buf[idx].value) Value(std::forward<Args>(args)...);\n            buf[idx].version = ++version;\n            buf[idx].next = -1;\n            return idx;\n        }\n\n        // \u901a\u8fc7\u4e0b\u6807\u79fb\u9664\n        inline void RemoveAt(Size_t const& idx) noexcept {\n            assert(idx < len);\n            assert(buf[idx].next == -1);\n            assert(buf[idx].version);\n            buf[idx].version = 0;\n            if constexpr (!IsPod_v<Value>) {\n                buf[idx].value.~Value();\n            }\n            buf[idx].next = freeHeader;\t\t\t\t\t// \u6307\u5411 \u81ea\u7531\u8282\u70b9\u94fe\u8868\u5934\n            freeHeader = idx;\n            assert(freeHeader >= 0);\n            assert(buf[freeHeader].version == 0);\n            ++freeCount;\n        }\n\n        // \u5b9a\u4f4d\u5230\u5b58\u50a8\u533a\n        Data& At(Size_t const& idx) noexcept {\n            assert(idx < len);\n            return buf[idx];\n        }\n\n        // \u5b9a\u4f4d\u5230 value\n        Value& ValueAt(Size_t const& idx) noexcept {\n            assert(idx < len);\n            return buf[idx].value;\n        }\n\n        // \u5b9a\u4f4d\u5230 version\n        Version_t& VersionAt(Size_t const& idx) noexcept {\n            assert(idx < len);\n            return buf[idx].version;\n        }\n\n    protected:\n        Size_t Alloc() {\n            Size_t idx;\n            // \u5982\u679c \u81ea\u7531\u8282\u70b9\u94fe\u8868 \u4e0d\u7a7a, \u53d6\u4e00\u4e2a\u6765\u5f53\u5bb9\u5668\n            if (freeCount) {\n                assert(freeHeader >= 0);\n                assert(buf[freeHeader].version == 0);\n                idx = freeHeader;\n                freeHeader = buf[idx].next;\n                --freeCount;\n            }\n            else {\n                // \u6240\u6709\u7a7a\u8282\u70b9\u90fd\u7528\u5149\u4e86, \u6269\u5bb9\n                if (len == cap) {\n                    if constexpr (IsPod_v<Value>) {\n                        buf = (Data*)realloc((void*)buf, sizeof(Data) * cap * 2);\n                    }\n                    else {\n                        auto newBuf = (Data*)malloc(sizeof(Data) * cap * 2);\n                        for (int i = 0; i < len; ++i) {\n                            new (&newBuf[i].value) Value((Value&&)buf[i].value);\n                            if constexpr (!IsPod_v<Value>) {\n                                buf[i].value.Value::~Value();\n                            }\n                        }\n                        free(buf);\n                        buf = newBuf;\n                    }\n                }\n                // \u6307\u5411 Resize \u540e\u9762\u7684\u7a7a\u95f4\u8d77\u70b9\n                idx = len;\n                ++len;\n            }\n            return idx;\n        }\n    };\n\n    template<typename Value, typename Size_t, typename Version_t>\n    struct IsPod<ItemPool<Value, Size_t, Version_t>, void> : std::true_type {};\n}\n\n", "comment_ratio": 0.13071895424836602}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n\n@interface EFNewsReplyCommentView : UIView\n\n@property(nonatomic,strong) NSMutableArray        *data;\n\n-(instancetype)init;\n\n\n\n@end\n\n", "comment_ratio": 0.35}
{"lang": "c", "code": "#include \"runtime.h\"\n#include \"defs.h\"\n\n// Linux futex.\n\n#include <unistd.h>\n#include <syscall.h>\n#include <linux/futex.h>\n\nvoid\nruntime_osinit(void)\n{\n\truntime_ncpu = getproccount();\n}\n\nvoid\nruntime_goenvs(void)\n{\n\truntime_goenvs_unix();\n}\n\n", "comment_ratio": 0.16}
{"lang": "c", "code": "//\n//  VideoZoomDelegate.h\n//  react-native-video-zoom-sdk\n//\n//  Created by Phu on 5/11/21.\n//\n\n#import <Foundation/Foundation.h>\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface VideoZoomEventHandler : NSObject<ZoomInstantSDKDelegate>\n\n@end\n\nNS_ASSUME_NONNULL_END\n\n", "comment_ratio": 0.35294117647058826}
{"lang": "c", "code": "#pragma once\n\n#include \"steamtypes.h\"\n\ntypedef uint64 UGCQueryHandle_t;\ntypedef uint64 UGCUpdateHandle_t;\n\n// Different lists of published UGC for a user.\n// If the current logged in user is different than the specified user, then some options may not be allowed.\ntypedef enum {\n\tk_EUserUGCList_Published,\n\tk_EUserUGCList_VotedOn,\n\tk_EUserUGCList_VotedUp,\n\tk_EUserUGCList_VotedDown,\n\tk_EUserUGCList_WillVoteLater,\n\tk_EUserUGCList_Favorited,\n\tk_EUserUGCList_Subscribed,\n\tk_EUserUGCList_UsedOrPlayed,\n\tk_EUserUGCList_Followed,\n} EUserUGCList;\n\n// Matching UGC types for queries\ntypedef enum {\n\tk_EUGCMatchingUGCType_Items = 0, // both mtx items and ready-to-use items\n\tk_EUGCMatchingUGCType_Items_Mtx = 1,\n\tk_EUGCMatchingUGCType_Items_ReadyToUse = 2,\n\tk_EUGCMatchingUGCType_Collections = 3,\n\tk_EUGCMatchingUGCType_Artwork = 4,\n\tk_EUGCMatchingUGCType_Videos = 5,\n\tk_EUGCMatchingUGCType_Screenshots = 6,\n\tk_EUGCMatchingUGCType_AllGuides = 7, // both web guides and integrated guides\n\tk_EUGCMatchingUGCType_WebGuides = 8,\n\tk_EUGCMatchingUGCType_IntegratedGuides = 9,\n\tk_EUGCMatchingUGCType_UsableInGame = 10, // ready-to-use items and integrated guides\n\tk_EUGCMatchingUGCType_ControllerBindings = 11,\n\tk_EUGCMatchingUGCType_GameManagedItems = 12, // game managed items (not managed by users)\n} EUGCMatchingUGCType;\n\n// Sort order for user published UGC lists (defaults to creation order descending)\ntypedef enum {\n\tk_EUserUGCListSortOrder_CreationOrderDesc,\n\tk_EUserUGCListSortOrder_CreationOrderAsc,\n\tk_EUserUGCListSortOrder_TitleAsc,\n\tk_EUserUGCListSortOrder_LastUpdatedDesc,\n\tk_EUserUGCListSortOrder_SubscriptionDateDesc,\n\tk_EUserUGCListSortOrder_VoteScoreDesc,\n\tk_EUserUGCListSortOrder_ForModeration,\n} EUserUGCListSortOrder;\n\n// Combination of sorting and filtering for queries across all UGC\ntypedef enum {\n\tk_EUGCQuery_RankedByVote = 0,\n\tk_EUGCQuery_RankedByPublicationDate = 1,\n\tk_EUGCQuery_AcceptedForGameRankedByAcceptanceDate = 2,\n\tk_EUGCQuery_RankedByTrend = 3,\n\tk_EUGCQuery_FavoritedByFriendsRankedByPublicationDate = 4,\n\tk_EUGCQuery_CreatedByFriendsRankedByPublicationDate = 5,\n\tk_EUGCQuery_RankedByNumTimesReported = 6,\n\tk_EUGCQuery_CreatedByFollowedUsersRankedByPublicationDate = 7,\n\tk_EUGCQuery_NotYetRated = 8,\n\tk_EUGCQuery_RankedByTotalVotesAsc = 9,\n\tk_EUGCQuery_RankedByVotesUp = 10,\n\tk_EUGCQuery_RankedByTextSearch = 11,\n\tk_EUGCQuery_RankedByTotalUniqueSubscriptions = 12,\n} EUGCQuery;\n\nenum {\n\tk_cchPublishedDocumentTitleMax = 128 + 1,\n\tk_cchPublishedDocumentDescriptionMax = 8000,\n\tk_cchPublishedDocumentChangeDescriptionMax = 8000,\n\tk_unEnumeratePublishedFilesMaxResults = 50,\n\tk_cchTagListMax = 1024 + 1,\n\tk_cchFilenameMax = 260,\n\tk_cchPublishedFileURLMax = 256,\n};\n\ntypedef enum {\n\tk_EItemUpdateStatusInvalid = 0,              // The item update handle was invalid, job might be finished, listen too SubmitItemUpdateResult_t\n\tk_EItemUpdateStatusPreparingConfig = 1,      // The item update is processing configuration data\n\tk_EItemUpdateStatusPreparingContent = 2,     // The item update is reading and processing content files\n\tk_EItemUpdateStatusUploadingContent = 3,     // The item update is uploading content changes to Steam\n\tk_EItemUpdateStatusUploadingPreviewFile = 4, // The item update is uploading new preview file image\n\tk_EItemUpdateStatusCommittingChanges = 5     // The item update is committing all changes\n} EItemUpdateStatus;\n\nstatic const uint32 kNumUGCResultsPerPage = 50;\nstatic const uint32 k_cchDeveloperMetadataMax = 5000;\n\n// Details for a single published file/UGC\ntypedef struct {\n\tPublishedFileId_t m_nPublishedFileId;\n\tEResult m_eResult;                                            // The result of the operation.\n\tEWorkshopFileType m_eFileType;                                // Type of the file\n\tAppId_t m_nCreatorAppID;                                      // ID of the app that created this file.\n\tAppId_t m_nConsumerAppID;                                     // ID of the app that will consume this file.\n\tchar m_rgchTitle[k_cchPublishedDocumentTitleMax];             // title of document\n\tchar m_rgchDescription[k_cchPublishedDocumentDescriptionMax]; // description of document\n\tuint64 m_ulSteamIDOwner;                                      // Steam ID of the user who created this content.\n\tuint32 m_rtimeCreated;                                        // time when the published file was created\n\tuint32 m_rtimeUpdated;                                        // time when the published file was last updated\n\tuint32 m_rtimeAddedToUserList;                                // time when the user added the published file to their list (not always applicable)\n\tERemoteStoragePublishedFileVisibility m_eVisibility;          // visibility\n\tbool m_bBanned;                                               // whether the file was banned\n\tbool m_bAcceptedForUse;                                       // developer has specifically flagged this item as accepted in the Workshop\n\tbool m_bTagsTruncated;                                        // whether the list of tags was too long to be returned in the provided buffer\n\tchar m_rgchTags[k_cchTagListMax];                             // comma separated list of all tags associated with this file\n\t// file/url information\n\tUGCHandle_t m_hFile;                      // The handle of the primary file\n\tUGCHandle_t m_hPreviewFile;               // The handle of the preview file\n\tchar m_pchFileName[k_cchFilenameMax];     // The cloud filename of the primary file\n\tint32 m_nFileSize;                        // Size of the primary file\n\tint32 m_nPreviewFileSize;                 // Size of the preview file\n\tchar m_rgchURL[k_cchPublishedFileURLMax]; // URL (for a video or a website)\n\t// voting information\n\tuint32 m_unVotesUp;   // number of votes up\n\tuint32 m_unVotesDown; // number of votes down\n\tfloat m_flScore;      // calculated score\n\t// collection details\n\tuint32 m_unNumChildren;\n} SteamUGCDetails_t;\n\ntypedef enum {\n\tk_EItemStatistic_NumSubscriptions = 0,\n\tk_EItemStatistic_NumFavorites = 1,\n\tk_EItemStatistic_NumFollowers = 2,\n\tk_EItemStatistic_NumUniqueSubscriptions = 3,\n\tk_EItemStatistic_NumUniqueFavorites = 4,\n\tk_EItemStatistic_NumUniqueFollowers = 5,\n\tk_EItemStatistic_NumUniqueWebsiteViews = 6,\n\tk_EItemStatistic_ReportScore = 7,\n} EItemStatistic;\n\ntypedef void ISteamUGC;\n\ntypedef struct CSteamUGC CSteamUGC;\n\nstruct CSteamUGC {\n\tCSteamBase base;\n};\n\nS_CLASSAPI UGCQueryHandle_t S_CLASSCALLTYPE SteamAPI_ISteamUGC_CreateQueryUserUGCRequest(SELF, AccountID_t unAccountID, EUserUGCList eListType, EUGCMatchingUGCType eMatchingUGCType, EUserUGCListSortOrder eSortOrder, AppId_t nCreatorAppID, AppId_t nConsumerAppID, uint32 unPage);\nS_CLASSAPI UGCQueryHandle_t S_CLASSCALLTYPE SteamAPI_ISteamUGC_CreateQueryAllUGCRequest(SELF, EUGCQuery eQueryType, EUGCMatchingUGCType eMatchingeMatchingUGCTypeFileType, AppId_t nCreatorAppID, AppId_t nConsumerAppID, uint32 unPage);\nS_CLASSAPI UGCQueryHandle_t S_CLASSCALLTYPE SteamAPI_ISteamUGC_CreateQueryUGCDetailsRequest(SELF, PublishedFileId_t *pvecPublishedFileID, uint32 unNumPublishedFileIDs);\nS_CLASSAPI SteamAPICall_t S_CLASSCALLTYPE SteamAPI_ISteamUGC_SendQueryUGCRequest(SELF, UGCQueryHandle_t handle);\nS_CLASSAPI bool S_CLASSCALLTYPE SteamAPI_ISteamUGC_GetQueryUGCResult(SELF, UGCQueryHandle_t handle, uint32 index, SteamUGCDetails_t *pDetails);\nS_CLASSAPI bool S_CLASSCALLTYPE SteamAPI_ISteamUGC_GetQueryUGCPreviewURL(SELF, UGCQueryHandle_t handle, uint32 index, char *pchURL, uint32 cchURLSize);\nS_CLASSAPI bool S_CLASSCALLTYPE SteamAPI_ISteamUGC_GetQueryUGCMetadata(SELF, UGCQueryHandle_t handle, uint32 index, char *pchMetadata, uint32 cchMetadatasize);\nS_CLASSAPI bool S_CLASSCALLTYPE SteamAPI_ISteamUGC_GetQueryUGCChildren(SELF, UGCQueryHandle_t handle, uint32 index, PublishedFileId_t *pvecPublishedFileID, uint32 cMaxEntries);\nS_CLASSAPI bool S_CLASSCALLTYPE SteamAPI_ISteamUGC_GetQueryUGCStatistic(SELF, UGCQueryHandle_t handle, uint32 index, EItemStatistic eStatType, uint32 *pStatValue);\nS_CLASSAPI uint32 S_CLASSCALLTYPE SteamAPI_ISteamUGC_GetQueryUGCNumAdditionalPreviews(SELF, UGCQueryHandle_t handle, uint32 index);\nS_CLASSAPI bool S_CLASSCALLTYPE SteamAPI_ISteamUGC_GetQueryUGCAdditionalPreview(SELF, UGCQueryHandle_t handle, uint32 index, uint32 previewIndex, char *pchURLOrVideoID, uint32 cchURLSize, bool *pbIsImage);\nS_CLASSAPI uint32 S_CLASSCALLTYPE SteamAPI_ISteamUGC_GetQueryUGCNumKeyValueTags(SELF, UGCQueryHandle_t handle, uint32 index);\nS_CLASSAPI bool S_CLASSCALLTYPE SteamAPI_ISteamUGC_GetQueryUGCKeyValueTag(SELF, UGCQueryHandle_t handle, uint32 index, uint32 keyValueTagIndex, char *pchKey, uint32 cchKeySize, char *pchValue, uint32 cchValueSize);\nS_CLASSAPI bool S_CLASSCALLTYPE SteamAPI_ISteamUGC_ReleaseQueryUGCRequest(SELF, UGCQueryHandle_t handle);\nS_CLASSAPI bool S_CLASSCALLTYPE SteamAPI_ISteamUGC_AddRequiredTag(SELF, UGCQueryHandle_t handle, const char *pTagName);\nS_CLASSAPI bool S_CLASSCALLTYPE SteamAPI_ISteamUGC_AddExcludedTag(SELF, UGCQueryHandle_t handle, const char *pTagName);\nS_CLASSAPI bool S_CLASSCALLTYPE SteamAPI_ISteamUGC_SetReturnKeyValueTags(SELF, UGCQueryHandle_t handle, bool bReturnKeyValueTags);\nS_CLASSAPI bool S_CLASSCALLTYPE SteamAPI_ISteamUGC_SetReturnLongDescription(SELF, UGCQueryHandle_t handle, bool bReturnLongDescription);\nS_CLASSAPI bool S_CLASSCALLTYPE SteamAPI_ISteamUGC_SetReturnMetadata(SELF, UGCQueryHandle_t handle, bool bReturnMetadata);\nS_CLASSAPI bool S_CLASSCALLTYPE SteamAPI_ISteamUGC_SetReturnChildren(SELF, UGCQueryHandle_t handle, bool bReturnChildren);\nS_CLASSAPI bool S_CLASSCALLTYPE SteamAPI_ISteamUGC_SetReturnAdditionalPreviews(SELF, UGCQueryHandle_t handle, bool bReturnAdditionalPreviews);\nS_CLASSAPI bool S_CLASSCALLTYPE SteamAPI_ISteamUGC_SetReturnTotalOnly(SELF, UGCQueryHandle_t handle, bool bReturnTotalOnly);\nS_CLASSAPI bool S_CLASSCALLTYPE SteamAPI_ISteamUGC_SetLanguage(SELF, UGCQueryHandle_t handle, const char *pchLanguage);\nS_CLASSAPI bool S_CLASSCALLTYPE SteamAPI_ISteamUGC_SetAllowCachedResponse(SELF, UGCQueryHandle_t handle, uint32 unMaxAgeSeconds);\nS_CLASSAPI bool S_CLASSCALLTYPE SteamAPI_ISteamUGC_SetCloudFileNameFilter(SELF, UGCQueryHandle_t handle, uint32 unMaxAgeSeconds);\nS_CLASSAPI bool S_CLASSCALLTYPE SteamAPI_ISteamUGC_SetMatchAnyTag(SELF, UGCQueryHandle_t handle, bool bMatchAnyTag);\nS_CLASSAPI bool S_CLASSCALLTYPE SteamAPI_ISteamUGC_SetSearchText(SELF, UGCQueryHandle_t handle, const char *pSearchText);\nS_CLASSAPI bool S_CLASSCALLTYPE SteamAPI_ISteamUGC_SetRankedByTrendDays(SELF, UGCQueryHandle_t handle, uint32 unDays);\nS_CLASSAPI bool S_CLASSCALLTYPE SteamAPI_ISteamUGC_AddRequiredKeyValueTag(SELF, UGCQueryHandle_t handle, const char *pKey, const char *pValue);\nS_CLASSAPI SteamAPICall_t S_CLASSCALLTYPE SteamAPI_ISteamUGC_RequestUGCDetails(SELF, PublishedFileId_t nPublishedFileID, uint32 unMaxAgeSeconds);\nS_CLASSAPI SteamAPICall_t S_CLASSCALLTYPE SteamAPI_ISteamUGC_CreateItem(SELF, AppId_t nConsumerAppId, EWorkshopFileType eFileType);\nS_CLASSAPI UGCUpdateHandle_t S_CLASSCALLTYPE SteamAPI_ISteamUGC_StartItemUpdate(SELF, AppId_t nConsumerAppId, PublishedFileId_t nPublishedFileID);\nS_CLASSAPI bool S_CLASSCALLTYPE SteamAPI_ISteamUGC_SetItemTitle(SELF, UGCUpdateHandle_t handle, const char *pchTitle);\nS_CLASSAPI bool S_CLASSCALLTYPE SteamAPI_ISteamUGC_SetItemDescription(SELF, UGCUpdateHandle_t handle, const char *pchDescription);\nS_CLASSAPI bool S_CLASSCALLTYPE SteamAPI_ISteamUGC_SetItemUpdateLanguage(SELF, UGCUpdateHandle_t handle, const char *pchLanguage);\nS_CLASSAPI bool S_CLASSCALLTYPE SteamAPI_ISteamUGC_SetItemMetadata(SELF, UGCUpdateHandle_t handle, const char *pchMetaData);\nS_CLASSAPI bool S_CLASSCALLTYPE SteamAPI_ISteamUGC_SetItemVisibility(SELF, UGCUpdateHandle_t handle, ERemoteStoragePublishedFileVisibility eVisibility);\nS_CLASSAPI bool S_CLASSCALLTYPE SteamAPI_ISteamUGC_SetItemTags(SELF, UGCUpdateHandle_t updateHandle, const SteamParamStringArray_t *pTags);\nS_CLASSAPI bool S_CLASSCALLTYPE SteamAPI_ISteamUGC_SetItemContent(SELF, UGCUpdateHandle_t handle, const char *pszContentFolder);\nS_CLASSAPI bool S_CLASSCALLTYPE SteamAPI_ISteamUGC_SetItemPreview(SELF, UGCUpdateHandle_t handle, const char *pszPreviewFile);\nS_CLASSAPI bool S_CLASSCALLTYPE SteamAPI_ISteamUGC_RemoveItemKeyValueTags(SELF, UGCUpdateHandle_t handle, const char *pchKey);\nS_CLASSAPI bool S_CLASSCALLTYPE SteamAPI_ISteamUGC_AddItemKeyValueTag(SELF, UGCUpdateHandle_t handle, const char *pchKey, const char *pchValue);\nS_CLASSAPI SteamAPICall_t S_CLASSCALLTYPE SteamAPI_ISteamUGC_SubmitItemUpdate(SELF, UGCUpdateHandle_t handle, const char *pchChangeNote);\nS_CLASSAPI EItemUpdateStatus S_CLASSCALLTYPE SteamAPI_ISteamUGC_GetItemUpdateProgress(SELF, UGCUpdateHandle_t handle, uint64 *punBytesProcessed, uint64 *punBytesTotal);\nS_CLASSAPI SteamAPICall_t S_CLASSCALLTYPE SteamAPI_ISteamUGC_SetUserItemVote(SELF, PublishedFileId_t nPublishedFileID, bool bVoteUp);\nS_CLASSAPI SteamAPICall_t S_CLASSCALLTYPE SteamAPI_ISteamUGC_GetUserItemVote(SELF, PublishedFileId_t nPublishedFileID);\nS_CLASSAPI SteamAPICall_t S_CLASSCALLTYPE SteamAPI_ISteamUGC_AddItemToFavorites(SELF, AppId_t nAppId, PublishedFileId_t nPublishedFileID);\nS_CLASSAPI SteamAPICall_t S_CLASSCALLTYPE SteamAPI_ISteamUGC_RemoveItemFromFavorites(SELF, AppId_t nAppId, PublishedFileId_t nPublishedFileID);\nS_CLASSAPI SteamAPICall_t S_CLASSCALLTYPE SteamAPI_ISteamUGC_SubscribeItem(SELF, PublishedFileId_t nPublishedFileID);\nS_CLASSAPI SteamAPICall_t S_CLASSCALLTYPE SteamAPI_ISteamUGC_UnsubscribeItem(SELF, PublishedFileId_t nPublishedFileID);\nS_CLASSAPI uint32 S_CLASSCALLTYPE SteamAPI_ISteamUGC_GetNumSubscribedItems(SELF);\nS_CLASSAPI uint32 S_CLASSCALLTYPE SteamAPI_ISteamUGC_GetSubscribedItems(SELF, PublishedFileId_t *pvecPublishedFileID, uint32 cMaxEntries);\nS_CLASSAPI uint32 S_CLASSCALLTYPE SteamAPI_ISteamUGC_GetItemState(SELF, PublishedFileId_t nPublishedFileID);\nS_CLASSAPI bool S_CLASSCALLTYPE SteamAPI_ISteamUGC_GetItemInstallInfo(SELF, PublishedFileId_t nPublishedFileID, uint64 *punSizeOnDisk, char *pchFolder, uint32 cchFolderSize, uint32 *punTimeStamp);\nS_CLASSAPI bool S_CLASSCALLTYPE SteamAPI_ISteamUGC_GetItemDownloadInfo(SELF, PublishedFileId_t nPublishedFileID, uint64 *punBytesDownloaded, uint64 *punBytesTotal);\nS_CLASSAPI bool S_CLASSCALLTYPE SteamAPI_ISteamUGC_DownloadItem(SELF, PublishedFileId_t nPublishedFileID, bool bHighPriority);\nS_CLASSAPI bool S_CLASSCALLTYPE SteamAPI_ISteamUGC_BInitWorkshopForGameServer(SELF, DepotId_t unWorkshopDepotID, const char *pszFolder);\nS_CLASSAPI void S_CLASSCALLTYPE SteamAPI_ISteamUGC_SuspendDownloads(SELF, bool bSuspend);\nS_CLASSAPI void S_CLASSCALLTYPE SteamAPI_ISteamUGC_StartPlaytimeTracking(SELF, bool *pvecPublishedFileId, uint32 unNumPublishedFileIDs);\nS_CLASSAPI void S_CLASSCALLTYPE SteamAPI_ISteamUGC_StopPlaytimeTracking(SELF, bool *pvecPublishedFileId, uint32 unNumPublishedFileIDs);\nS_CLASSAPI void S_CLASSCALLTYPE SteamAPI_ISteamUGC_StopPlaytimeTrackingForAllItems(SELF);\n\n", "comment_ratio": 0.21287128712871287}
{"lang": "c", "code": "#pragma once\n\n\nnamespace Nitrade {\n\t\n\tenum tradeDirection { Long = 1, Short = -1 };\n\tenum exitType { ByStrategy, StopLoss, TakeProfit };\n\n\ttypedef std::tuple<std::string, int> StrategyKey;\n\n#pragma pack(push, 1)\n\tstruct Bar {\n\t\tlong long timestamp{ 0 };\n\t\tfloat bidOpen{ 0 };\n\t\tfloat bidClose{ 0 };\n\t\tfloat bidHigh{ 0 };\n\t\tfloat bidLow{ 0 };\n\t\tfloat askOpen{ 0 };\n\t\tfloat askClose{ 0 };\n\t\tfloat askHigh{ 0 };\n\t\tfloat askLow{ 0 };\n\t\tint volume{ 0 };\n\t};\n\n\tstruct RunningPL {\n\t\tchar assetName[10]{ \"\" };\n\t\tint variantId{ 0 };\n\t\tlong long timestamp{ 0 };\n\t\tdouble realisedProfit{ 0 };\n\t\tdouble unrealisedProfit{ 0 };\n\t};\n\n\tstruct Trade {\n\t\tint tradeId{ 0 };\n\t\tint variantId{ 0 };\n\t\tfloat openLevel{ 0 }; //the price the trade exectuted at\n\t\tfloat closeLevel{ 0 }; //the price the trade closed at\n\t\tfloat commission{ 0 }; //dollars paid in commission\n\t\tfloat spread{ 0 }; //spread in points\n\t\tfloat profit{ 0 }; //trade profit in cents\n\t\tfloat pip{ 0 };\n\t\tfloat pipCost{ 0 };\n\t\tint size{ 0 }; //size in units of minimum amount ie. for forex 0.01 lots would be size 1\n\t\tfloat stopLoss{ 0 };\n\t\tfloat takeProfit{ 0 };\n\t\tfloat stopLevel{ 0 };\n\t\tfloat takeProfitLevel{ 0 };\n\t\tlong long openTime{ 0 }; //time the trade opened\n\t\tlong long closeTime{ 0 }; //time the trade closed\n\t\tchar assetName[10]{ \"\" };\n\t\ttradeDirection direction{ tradeDirection::Long };\n\t\texitType exit{ exitType::ByStrategy };\n\t\tfloat calcPointsProfit() { return ((closeLevel - openLevel) * direction); }\n\t\tfloat calcPipsProfit() { return calcPointsProfit() / pip; }\n\t\tfloat calcProfit() { return (calcPipsProfit() * pipCost - commission) * size; }\n\t};\n\n\n#pragma pack(pop)\n\n}\n\n", "comment_ratio": 0.12903225806451613}
{"lang": "c", "code": "#include \"util.h\" // dprintf\n#include \"ioport.h\" // outb\n#include \"pic.h\" // eoi_pic2\n#include \"biosvar.h\" // struct bios_data_area_s\n#include \"bregs.h\" // struct bregs\n#include \"acpi.h\" // find_resume_vector\n\n// Reset DMA controller\nvoid\ninit_dma(void)\n{\n    // first reset the DMA controllers\n    outb(0, PORT_DMA1_MASTER_CLEAR);\n    outb(0, PORT_DMA2_MASTER_CLEAR);\n\n    // then initialize the DMA controllers\n    outb(0xc0, PORT_DMA2_MODE_REG);\n    outb(0x00, PORT_DMA2_MASK_REG);\n}\n\n// Handler for post calls that look like a resume.\nvoid VISIBLE16\nhandle_resume(u8 status)\n{\n    init_dma();\n\n    debug_serial_setup();\n    dprintf(1, \"In resume (status=%d)\\n\", status);\n\n    switch (status) {\n    case 0xfe:\n        if (CONFIG_S3_RESUME) {\n            // S3 resume request.  Jump to 32bit mode to handle the resume.\n            asm volatile(\n                \"movw %w1, %%ss\\n\"\n                \"movl %0, %%esp\\n\"\n                \"pushl $s3_resume\\n\"\n                \"jmp transition32\\n\"\n                : : \"i\"(BUILD_S3RESUME_STACK_ADDR), \"r\"(0)\n                );\n            break;\n        }\n        // NO BREAK\n    case 0x00:\n    case 0x0d ... 0xfd:\n    case 0xff:\n        // Normal post - now that status has been cleared a reset will\n        // run regular boot code..\n        reset_vector();\n        break;\n\n    case 0x05:\n        // flush keyboard (issue EOI) and jump via 40h:0067h\n        eoi_pic2();\n        // NO BREAK\n    case 0x0a:\n#define BDA_JUMP (((struct bios_data_area_s *)0)->jump)\n        // resume execution by jump via 40h:0067h\n        asm volatile(\n            \"movw %w1, %%ds\\n\"\n            \"ljmpw *%0\\n\"\n            : : \"m\"(BDA_JUMP), \"r\"(SEG_BDA)\n            );\n        break;\n\n    case 0x0b:\n        // resume execution via IRET via 40h:0067h\n        asm volatile(\n            \"movw %w1, %%ds\\n\"\n            \"lssw %0, %%sp\\n\"\n            \"iretw\\n\"\n            : : \"m\"(BDA_JUMP), \"r\"(SEG_BDA)\n            );\n        break;\n\n    case 0x0c:\n        // resume execution via RETF via 40h:0067h\n        asm volatile(\n            \"movw %w1, %%ds\\n\"\n            \"lssw %0, %%sp\\n\"\n            \"lretw\\n\"\n            : : \"m\"(BDA_JUMP), \"r\"(SEG_BDA)\n            );\n        break;\n    }\n\n    panic(\"Unimplemented shutdown status: %02x\\n\", status);\n}\n\nvoid VISIBLE32FLAT\ns3_resume(void)\n{\n    ASSERT32FLAT();\n    if (!CONFIG_S3_RESUME)\n        panic(\"S3 resume support not compiled in.\\n\");\n\n    dprintf(1, \"In 32bit resume\\n\");\n\n    smm_init();\n\n    s3_resume_vga_init();\n\n    make_bios_readonly();\n\n    u32 s3_resume_vector = find_resume_vector();\n\n    // Invoke the resume vector.\n    struct bregs br;\n    memset(&br, 0, sizeof(br));\n    if (s3_resume_vector) {\n        dprintf(1, \"Jump to resume vector (%x)\\n\", s3_resume_vector);\n        br.code = FLATPTR_TO_SEGOFF((void*)s3_resume_vector);\n    } else {\n        dprintf(1, \"No resume vector set!\\n\");\n        // Jump to the post vector to restart with a normal boot.\n        br.code = SEGOFF(SEG_BIOS, (u32)reset_vector - BUILD_BIOS_ADDR);\n    }\n    call16big(&br);\n}\n\n", "comment_ratio": 0.20634920634920634}
{"lang": "c", "code": "#ifndef POINT_H\n#define POINT_H\n\n\n// A 2D Point with an extra feild for counting the 'visits' to that point.\nstruct Point {\n    int x;\n    int y;\n    int visits;\n};\n\n// A contructor for a single point.\nstruct Point pt_new(int x, int y) {\n    struct Point p;\n    p.x = x;\n    p.y = y;\n    p.visits = 0;\n    return p;\n}\n\n// Test for equality between two points.\nint pt_equ(struct Point a, struct Point b) {\n    return a.x == b.x && a.y == b.y;\n}\n\n// 'Visit' a specific point (pass by reference).\nvoid pt_visit(struct Point *p) {\n    p->visits += 1;\n    return;\n}\n\n#endif\n\n", "comment_ratio": 0.12121212121212122}
{"lang": "c", "code": "//\n//  SMLSyntaxError.h\n//  Fragaria\n//\n//  Created by Viktor Lidholt on 4/9/13.\n//\n//\n\n#import <Foundation/Foundation.h>\n\n@interface SMLSyntaxError : NSObject\n{\n    NSString* description;\n    int line;\n    int character;\n    NSString* code;\n    int length;\n}\n\n@property (nonatomic,copy) NSString* description;\n@property (nonatomic,assign) int line;\n@property (nonatomic,assign) int character;\n@property (nonatomic,copy) NSString* code;\n@property (nonatomic,assign) int length;\n\n@end\n\n", "comment_ratio": 0.25925925925925924}
{"lang": "c", "code": "#import \"ProfilePhotoVideoView.h\"\n\n@class UIButton, UILabel;\n\n@interface VideoCellView : ProfilePhotoVideoView\n{\n    UIButton *_actionsButton;\n    UIButton *_authorButton;\n    UILabel *_authorLabel;\n}\n\n@property(retain, nonatomic) UILabel *authorLabel; // @synthesize authorLabel=_authorLabel;\n@property(readonly, nonatomic) UIButton *authorButton; // @synthesize authorButton=_authorButton;\n@property(retain, nonatomic) UIButton *actionsButton; // @synthesize actionsButton=_actionsButton;\n- (void).cxx_destruct;\n- (void)setVideo:(id)arg1;\n- (double)nameLabelX;\n- (double)counterPointSize;\n- (double)namePointSize;\n- (double)bottomPanelHeight;\n- (void)removeActionsButton;\n- (id)initWithFrame:(struct CGRect)arg1;\n\n@end\n\n\n", "comment_ratio": 0.25}
{"lang": "c", "code": "#import \"ExecuteBlock.h\"\n\n@interface OLPauseCondition : NSObject\n\n- (BOOL)isPaused;\n- (BOOL)isTimedOut;\n- (void)cancel;\n- (void)signal;\n- (ExecuteBlock *)wait;\n\n@end\n\n", "comment_ratio": 0.35}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n\ntypedef NS_OPTIONS(NSUInteger, MNSPropertyOptions) {\n    MNSPropertyOptionHidesName               = 1 << 0,\n    MNSPropertyOptionAllowsUserInput         = 1 << 1,\n    MNSPropertyOptionTogglesBoolean          = 1 << 2,\n    MNSPropertyOptionHidesDisclosureForValue = 1 << 3,\n};\n\ntypedef void (^MNSPropertyValueChangedBlock)(id value);\n\n@interface MNSProperty : NSObject\n\n- (instancetype)initWithName:(NSString *)name value:(id)value;\n\n@property (nonatomic) id value;\n@property (nonatomic) MNSPropertyOptions options;\n@property (nonatomic, copy) MNSPropertyValueChangedBlock valueChangedBlock;\n@property (nonatomic, copy, readonly) NSString *name;\n\n@end\n\n", "comment_ratio": 0.23333333333333334}
{"lang": "c", "code": "#ifndef GPU_COMMAND_BUFFER_SERVICE_BUFFER_MANAGER_H_\n#define GPU_COMMAND_BUFFER_SERVICE_BUFFER_MANAGER_H_\n\n#include <map>\n#include \"base/basictypes.h\"\n#include \"base/logging.h\"\n#include \"base/ref_counted.h\"\n#include \"base/scoped_ptr.h\"\n#include \"gpu/command_buffer/service/gl_utils.h\"\n\nnamespace gpu {\nnamespace gles2 {\n\n// This class keeps track of the buffers and their sizes so we can do\n// bounds checking.\n//\n// NOTE: To support shared resources an instance of this class will need to be\n// shared by multiple GLES2Decoders.\nclass BufferManager {\n public:\n  // Info about Buffers currently in the system.\n  class BufferInfo : public base::RefCounted<BufferInfo> {\n   public:\n    typedef scoped_refptr<BufferInfo> Ref;\n\n    explicit BufferInfo(GLuint service_id);\n\n    GLuint service_id() const {\n      return service_id_;\n    }\n\n    GLsizeiptr size() const {\n      return size_;\n    }\n\n    // Sets a range of data for this buffer. Returns false if the offset or size\n    // is out of range.\n    bool SetRange(\n      GLintptr offset, GLsizeiptr size, const GLvoid * data);\n\n    // Gets the maximum value in the buffer for the given range interpreted as\n    // the given type. Returns false if offset and count are out of range.\n    // offset is in bytes.\n    // count is in elements of type.\n    bool GetMaxValueForRange(GLuint offset, GLsizei count, GLenum type,\n                             GLuint* max_value);\n\n    // Returns a pointer to shadowed data.\n    const void* GetRange(GLintptr offset, GLsizeiptr size) const;\n\n    bool IsDeleted() {\n      return service_id_ == 0;\n    }\n\n   private:\n    friend class BufferManager;\n    friend class BufferManagerTest;\n    friend class base::RefCounted<BufferInfo>;\n\n    // Represents a range in a buffer.\n    class Range {\n     public:\n      Range(GLuint offset, GLsizei count, GLenum type)\n          : offset_(offset),\n            count_(count),\n            type_(type) {\n      }\n\n      // A less functor provided for std::map so it can find ranges.\n      struct Less {\n        bool operator() (const Range& lhs, const Range& rhs) const {\n          if (lhs.offset_ != rhs.offset_) {\n            return lhs.offset_ < rhs.offset_;\n          }\n          if (lhs.count_ != rhs.count_) {\n            return lhs.count_ < rhs.count_;\n          }\n          return lhs.type_ < rhs.type_;\n        }\n      };\n\n     private:\n      GLuint offset_;\n      GLsizei count_;\n      GLenum type_;\n    };\n\n    ~BufferInfo();\n\n    GLenum target() const {\n      return target_;\n    }\n\n    void set_target(GLenum target) {\n      DCHECK_EQ(target_, 0u);  // you can only set this once.\n      target_ = target;\n    }\n\n    bool shadowed() const {\n      return shadowed_;\n    }\n\n    void MarkAsDeleted() {\n      service_id_ = 0;\n      shadow_.reset();\n      ClearCache();\n    }\n\n    void SetSize(GLsizeiptr size, bool shadow);\n\n    // Clears any cache of index ranges.\n    void ClearCache();\n\n    // Service side buffer id.\n    GLuint service_id_;\n\n    // The type of buffer. 0 = unset, GL_BUFFER_ARRAY = vertex data,\n    // GL_ELEMENT_BUFFER_ARRAY = index data.\n    // Once set a buffer can not be used for something else.\n    GLenum target_;\n\n    // Size of buffer.\n    GLsizeiptr size_;\n\n    // Whether or not the data is shadowed.\n    bool shadowed_;\n\n    // A copy of the data in the buffer. This data is only kept if the target\n    // is backed_ = true.\n    scoped_array<int8> shadow_;\n\n    // A map of ranges to the highest value in that range of a certain type.\n    typedef std::map<Range, GLuint, Range::Less> RangeToMaxValueMap;\n    RangeToMaxValueMap range_set_;\n  };\n\n  BufferManager();\n  ~BufferManager();\n\n  // Must call before destruction.\n  void Destroy(bool have_context);\n\n  // Creates a BufferInfo for the given buffer.\n  void CreateBufferInfo(GLuint client_id, GLuint service_id);\n\n  // Gets the buffer info for the given buffer.\n  BufferInfo* GetBufferInfo(GLuint client_id);\n\n  // Removes a buffer info for the given buffer.\n  void RemoveBufferInfo(GLuint client_id);\n\n  // Gets a client id for a given service id.\n  bool GetClientId(GLuint service_id, GLuint* client_id) const;\n\n  // Sets the size of a buffer.\n  void SetSize(BufferInfo* info, GLsizeiptr size);\n\n  // Sets the target of a buffer. Returns false if the target can not be set.\n  bool SetTarget(BufferInfo* info, GLenum target);\n\n  void set_allow_buffers_on_multiple_targets(bool allow) {\n    allow_buffers_on_multiple_targets_ = allow;\n  }\n\n private:\n  // Info for each buffer in the system.\n  // TODO(gman): Choose a faster container.\n  typedef std::map<GLuint, BufferInfo::Ref> BufferInfoMap;\n  BufferInfoMap buffer_infos_;\n\n  // Whether or not buffers can be bound to multiple targets.\n  bool allow_buffers_on_multiple_targets_;\n\n  DISALLOW_COPY_AND_ASSIGN(BufferManager);\n};\n\n}  // namespace gles2\n}  // namespace gpu\n\n#endif  // GPU_COMMAND_BUFFER_SERVICE_BUFFER_MANAGER_H_\n\n\n\n", "comment_ratio": 0.22459893048128343}
{"lang": "c", "code": "#include \"tusb_option.h\"\n\n// NXP Trans-Dimension USB IP implement EHCI for host functionality\n\n#if TUSB_OPT_HOST_ENABLED && \\\n    (CFG_TUSB_MCU == OPT_MCU_LPC18XX || CFG_TUSB_MCU == OPT_MCU_LPC43XX || CFG_TUSB_MCU == OPT_MCU_MIMXRT10XX)\n\n#warning \"transdimenion is renamed to chipidea (portable/chipidea/ci_hs) to match other opensource naming convention such as linux. This file will be removed in the future, please update your makefile accordingly\"\n\n//--------------------------------------------------------------------+\n// INCLUDE\n//--------------------------------------------------------------------+\n#if CFG_TUSB_MCU == OPT_MCU_MIMXRT10XX\n  #include \"fsl_device_registers.h\"\n#else\n  // LPCOpen for 18xx & 43xx\n  #include \"chip.h\"\n#endif\n\n#include \"common/tusb_common.h\"\n#include \"common_transdimension.h\"\n#include \"portable/ehci/ehci_api.h\"\n\n//--------------------------------------------------------------------+\n// MACRO CONSTANT TYPEDEF\n//--------------------------------------------------------------------+\n\n// TODO can be merged with dcd_controller_t\ntypedef struct\n{\n  uint32_t regs_base;     // registers base\n  const IRQn_Type irqnum; // IRQ number\n}hcd_controller_t;\n\n#if CFG_TUSB_MCU == OPT_MCU_MIMXRT10XX\n  static const hcd_controller_t _hcd_controller[] =\n  {\n    // RT1010 and RT1020 only has 1 USB controller\n    #if FSL_FEATURE_SOC_USBHS_COUNT == 1\n      { .regs_base = USB_BASE , .irqnum = USB_OTG1_IRQn }\n    #else\n      { .regs_base = USB1_BASE, .irqnum = USB_OTG1_IRQn },\n      { .regs_base = USB2_BASE, .irqnum = USB_OTG2_IRQn }\n    #endif\n  };\n\n#else\n  static const hcd_controller_t _hcd_controller[] =\n  {\n    { .regs_base = LPC_USB0_BASE, .irqnum = USB0_IRQn },\n    { .regs_base = LPC_USB1_BASE, .irqnum = USB1_IRQn }\n  };\n#endif\n\n//--------------------------------------------------------------------+\n// Controller API\n//--------------------------------------------------------------------+\n\nbool hcd_init(uint8_t rhport)\n{\n  hcd_registers_t* hcd_reg = (hcd_registers_t*) _hcd_controller[rhport].regs_base;\n\n  // Reset controller\n  hcd_reg->USBCMD |= USBCMD_RESET;\n  while( hcd_reg->USBCMD & USBCMD_RESET ) {}\n\n  // Set mode to device, must be set immediately after reset\n#if CFG_TUSB_MCU == OPT_MCU_LPC18XX || CFG_TUSB_MCU == OPT_MCU_LPC43XX\n  // LPC18XX/43XX need to set VBUS Power Select to HIGH\n  // RHPORT1 is fullspeed only (need external PHY for Highspeed)\n  hcd_reg->USBMODE = USBMODE_CM_HOST | USBMODE_VBUS_POWER_SELECT;\n  if (rhport == 1) hcd_reg->PORTSC1 |= PORTSC1_FORCE_FULL_SPEED;\n#else\n  hcd_reg->USBMODE = USBMODE_CM_HOST;\n#endif\n\n  // FIXME force full speed, still have issue with Highspeed enumeration\n  hcd_reg->PORTSC1 |= PORTSC1_FORCE_FULL_SPEED;\n\n  return ehci_init(rhport, (uint32_t) &hcd_reg->CAPLENGTH, (uint32_t) &hcd_reg->USBCMD);\n}\n\nvoid hcd_int_enable(uint8_t rhport)\n{\n  NVIC_EnableIRQ(_hcd_controller[rhport].irqnum);\n}\n\nvoid hcd_int_disable(uint8_t rhport)\n{\n  NVIC_DisableIRQ(_hcd_controller[rhport].irqnum);\n}\n\n#endif\n\n", "comment_ratio": 0.16666666666666666}
{"lang": "c", "code": "#pragma once\n\n#include \"RayLib/SurfaceLoaderI.h\"\n#include \"RayLib/SceneNodeI.h\"\n\n#include \"AssimpForward.h\"\n\n#include <string>\n\nclass AssimpMetaSurfaceLoader : public SurfaceLoader\n{\n    public:\n        static constexpr const char* InnerIdJSON    = \"innerIndex\";\n\n    private:\n        Assimp::Importer&                           importer;\n        const aiScene*                              scene;\n        const std::string&                          extension;\n\n        // Inner Ids\n        const UIntList                              innerIds;\n\n    protected:\n    public:\n        // Constructors & Destructor    \n                                    AssimpMetaSurfaceLoader(Assimp::Importer&,                                                         \n                                                            const std::string& scenePath,\n                                                            const std::string& fileExt,\n                                                            const SceneNodeI& node, double time = 0.0);\n                                    AssimpMetaSurfaceLoader(const AssimpMetaSurfaceLoader&) = delete;\n        AssimpMetaSurfaceLoader&    operator=(const AssimpMetaSurfaceLoader&) = delete;\n                                    ~AssimpMetaSurfaceLoader();\n\n        // Interface\n        const char*                 SufaceDataFileExt() const override;\n        // Per Batch Fetch\n        SceneError                  AABB(std::vector<AABB3>&) const override;\n        SceneError                  PrimitiveRanges(std::vector<Vector2ul>&) const override;\n        SceneError                  PrimitiveCounts(std::vector<size_t>&) const override;\n        SceneError                  PrimitiveDataRanges(std::vector<Vector2ul>&) const override;        \n        // Entire Data Fetch\n        SceneError                  GetPrimitiveData(Byte*, PrimitiveDataType primitiveDataType) const override;\n        SceneError                  PrimitiveDataCount(size_t&, PrimitiveDataType primitiveDataType) const override;\n        SceneError                  PrimDataLayout(PrimitiveDataLayout&,\n                                                   PrimitiveDataType primitiveDataType) const override;\n};\n", "comment_ratio": 0.10869565217391304}
{"lang": "c", "code": "#pragma once\n\n// Vulkan includes\n#include <vulkan/vulkan.h>\n\n// STD library includes\n#include <optional>\n#include <vector>\n\nnamespace PsAi::Renderer\n{\n\t\n\tstruct QueueFamilyIndices;\n\n\tstruct HelperFunctions\n\t{\n\t\tstatic QueueFamilyIndices find_queue_families(VkPhysicalDevice physical_device, VkSurfaceKHR surface);\n\t};\n\n\tstruct QueueFamilyIndices\n\t{\n\t\tstd::optional<uint32_t> graphicsFamily;\n\t\tstd::optional<uint32_t> presentFamily;\n\t};\n\n} // PsAi::Renderer namespace\n\n", "comment_ratio": 0.1111111111111111}
{"lang": "c", "code": "#ifndef __TTransportPaletteView__\n#define __TTransportPaletteView__ \n\n\n// Constants\nconst int32 kTransportFontSize = 12;\n\n//\tIncludes\n#include \"TBitmapView.h\"\n\n// Class Declarations\nclass TTransportPaletteView: public TBitmapView\n{\n\tpublic:\n\t\t// Member functions\n\t\tTTransportPaletteView(BRect bounds, BBitmap *bitmap);\n\t\t~TTransportPaletteView();\n\t\t\n\t\tvoid \tDraw(BRect updateRect);\t\t\n\t\tvoid\tMessageReceived(BMessage *message);\n\n\t\tvoid \tPulse();\n\n\t\tTTimeText\t*GetTransportText(){ return fTransportText; }\n\t\t\n\t\t// Member variables\t\n\t\t\n\tprivate:\t\t\t\t\n\t\t// Member functions\n\t\t\n\t\tvoid \tInit();\n\t\t\t\t\n\t\t// Member variables\n\t\tTBitmapButton\t*fStartButton;\t\t\t\t\n\t\tTBitmapButton\t*fRewindButton;\n\t\tTBitmapButton\t*fPlayButton;\n\t\tTBitmapButton\t*fPauseButton;\n\t\tTBitmapButton\t*fFFButton;\t\t\n\t\tTBitmapButton\t*fEndButton;\n\t\tTTimeText\t\t*fTransportText;\n};\t\t\n\n\n// Utility Functions\nBBitmap *GetTransportButton(char *theResource);\n\n#endif\n\n", "comment_ratio": 0.3387096774193548}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n\n//You can use these as convenience and readability instead of passing a number in maxAgeMinutes\ntypedef enum {\n\tFKDUMaxAgeNeverCache\t= 0,\n    FKDUMaxAgeOneMinute\t\t= 1,\n    FKDUMaxAgeFiveMinutes\t= 5,\n\tFKDUMaxAgeOneHour\t\t= 60,\n    FKDUMaxAgeHalfDay\t\t= 720,\n    FKDUMaxAgeOneDay\t\t= 1440,\n    FKDUMaxAgeInfinite\t\t= NSIntegerMax\n} FKDUMaxAge;\n\n@protocol FKDUDiskCache <NSObject>\n\n@required\n\n#pragma mark - Data from the cache\n\n- (NSData *) dataForKey:(NSString *)key maxAgeMinutes:(FKDUMaxAge)maxAgeMinutes;\n\n#pragma mark - Remove item (NSData) from cache\n\n- (void) removeDataForKey:(NSString *)key;\n\n#pragma mark - Store Data in the cache\n\n- (void) storeData:(NSData *)data forKey:(NSString *)key;\n\n@end\n\n", "comment_ratio": 0.2}
{"lang": "c", "code": "//\n//  GJTAppLauncherDelegate+HeadTask.h\n//  GJTApplicationModule\n//\n//  Created by kyson on 2021/3/4.\n//\n\n#import <GJTApplicationModule/GJTApplicationModule.h>\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface GJTAppLauncherDelegate(HeadTask)\n\n@end\n\nNS_ASSUME_NONNULL_END\n\n", "comment_ratio": 0.35294117647058826}
{"lang": "c", "code": "\ufeff#include \"pch-c.h\"\n#ifndef _MSC_VER\n# include <alloca.h>\n#else\n# include <malloc.h>\n#endif\n\n\n#include \"codegen/il2cpp-codegen-metadata.h\"\n\n\n\n\n\n// 0x00000001 System.Void UnityEngine.AudioSettings::InvokeOnAudioConfigurationChanged(System.Boolean)\nextern void AudioSettings_InvokeOnAudioConfigurationChanged_m2CBD1FC39E7AE46E07E777990310D1DC40FB980E (void);\n// 0x00000002 System.Void UnityEngine.AudioSettings/AudioConfigurationChangeHandler::.ctor(System.Object,System.IntPtr)\nextern void AudioConfigurationChangeHandler__ctor_mB63AFBABA4712DF64F06A65CC7CE3C9E8C58080B (void);\n// 0x00000003 System.Void UnityEngine.AudioSettings/AudioConfigurationChangeHandler::Invoke(System.Boolean)\nextern void AudioConfigurationChangeHandler_Invoke_mDC001A19067B6A02B0DE21A4D66FC8D82529F911 (void);\n// 0x00000004 System.IAsyncResult UnityEngine.AudioSettings/AudioConfigurationChangeHandler::BeginInvoke(System.Boolean,System.AsyncCallback,System.Object)\nextern void AudioConfigurationChangeHandler_BeginInvoke_m2F17366BD1D34B7BB9FC60C1EF34EDC074D0003B (void);\n// 0x00000005 System.Void UnityEngine.AudioSettings/AudioConfigurationChangeHandler::EndInvoke(System.IAsyncResult)\nextern void AudioConfigurationChangeHandler_EndInvoke_m78A4BB19DA6FBEACEC4F57A51D8076A337E02F4C (void);\n// 0x00000006 System.Void UnityEngine.AudioClip::InvokePCMReaderCallback_Internal(System.Single[])\nextern void AudioClip_InvokePCMReaderCallback_Internal_m9CB2976CDC2C73A92479F8C11C30B17FAA05751F (void);\n// 0x00000007 System.Void UnityEngine.AudioClip::InvokePCMSetPositionCallback_Internal(System.Int32)\nextern void AudioClip_InvokePCMSetPositionCallback_Internal_m9F3ACF3A244349568C0D0D1D40EE72EF013FB45D (void);\n// 0x00000008 System.Void UnityEngine.AudioClip/PCMReaderCallback::.ctor(System.Object,System.IntPtr)\nextern void PCMReaderCallback__ctor_mCA9CC5271DE0E4083B85759CA74EED1C1CD219F7 (void);\n// 0x00000009 System.Void UnityEngine.AudioClip/PCMReaderCallback::Invoke(System.Single[])\nextern void PCMReaderCallback_Invoke_mE5E7A777A52B9627F9A6A57A140E5C4AAB5A1387 (void);\n// 0x0000000A System.IAsyncResult UnityEngine.AudioClip/PCMReaderCallback::BeginInvoke(System.Single[],System.AsyncCallback,System.Object)\nextern void PCMReaderCallback_BeginInvoke_mA4B5DF478312B7B7A00E13D869DF0AD4E01795A9 (void);\n// 0x0000000B System.Void UnityEngine.AudioClip/PCMReaderCallback::EndInvoke(System.IAsyncResult)\nextern void PCMReaderCallback_EndInvoke_m79DD97AB2919A10EBC91F78331213523EA5494DE (void);\n// 0x0000000C System.Void UnityEngine.AudioClip/PCMSetPositionCallback::.ctor(System.Object,System.IntPtr)\nextern void PCMSetPositionCallback__ctor_m0204C8557D7FB9E95F33168EDFD64182D9342002 (void);\n// 0x0000000D System.Void UnityEngine.AudioClip/PCMSetPositionCallback::Invoke(System.Int32)\nextern void PCMSetPositionCallback_Invoke_m1FBFFA5FC15B57601D6D13F4A574F7CAD2A93B7E (void);\n// 0x0000000E System.IAsyncResult UnityEngine.AudioClip/PCMSetPositionCallback::BeginInvoke(System.Int32,System.AsyncCallback,System.Object)\nextern void PCMSetPositionCallback_BeginInvoke_mF8CA8E07FDAF6B0821D2F1AE8F8545DC0FADC3A3 (void);\n// 0x0000000F System.Void UnityEngine.AudioClip/PCMSetPositionCallback::EndInvoke(System.IAsyncResult)\nextern void PCMSetPositionCallback_EndInvoke_m7096B994374E95A90C84B87625494BE1076B8574 (void);\n// 0x00000010 UnityEngine.Playables.PlayableHandle UnityEngine.Audio.AudioClipPlayable::GetHandle()\nextern void AudioClipPlayable_GetHandle_mBEB846B088961170B6DB961951B511C11B98E0B8_AdjustorThunk (void);\n// 0x00000011 System.Boolean UnityEngine.Audio.AudioClipPlayable::Equals(UnityEngine.Audio.AudioClipPlayable)\nextern void AudioClipPlayable_Equals_m52ECDD49AE6BD8AB4C0AC83C417A0C1B23E3E55E_AdjustorThunk (void);\n// 0x00000012 UnityEngine.Playables.PlayableHandle UnityEngine.Audio.AudioMixerPlayable::GetHandle()\nextern void AudioMixerPlayable_GetHandle_m76EFC486A7639C4842F590F544B60988CF27BB17_AdjustorThunk (void);\n// 0x00000013 System.Boolean UnityEngine.Audio.AudioMixerPlayable::Equals(UnityEngine.Audio.AudioMixerPlayable)\nextern void AudioMixerPlayable_Equals_mB55D2602ACCD196F61AF3D1AE90B81930A9AB7E8_AdjustorThunk (void);\n// 0x00000014 System.Void UnityEngine.Experimental.Audio.AudioSampleProvider::InvokeSampleFramesAvailable(System.Int32)\nextern void AudioSampleProvider_InvokeSampleFramesAvailable_mE6689CFA13C0621F305F389FEEE4D543B71BF236 (void);\n// 0x00000015 System.Void UnityEngine.Experimental.Audio.AudioSampleProvider::InvokeSampleFramesOverflow(System.Int32)\nextern void AudioSampleProvider_InvokeSampleFramesOverflow_m998BEADD2A2B4BEF0906A31108B6DC486411CC78 (void);\n// 0x00000016 System.Void UnityEngine.Experimental.Audio.AudioSampleProvider/SampleFramesHandler::.ctor(System.Object,System.IntPtr)\nextern void SampleFramesHandler__ctor_m389B32B949592BFD1BA53D0C0983CA6B5BA6AAC7 (void);\n// 0x00000017 System.Void UnityEngine.Experimental.Audio.AudioSampleProvider/SampleFramesHandler::Invoke(UnityEngine.Experimental.Audio.AudioSampleProvider,System.UInt32)\nextern void SampleFramesHandler_Invoke_mCB6172CE3EF20C5E12A697A5CE5EEDED9A3B5779 (void);\n// 0x00000018 System.IAsyncResult UnityEngine.Experimental.Audio.AudioSampleProvider/SampleFramesHandler::BeginInvoke(UnityEngine.Experimental.Audio.AudioSampleProvider,System.UInt32,System.AsyncCallback,System.Object)\nextern void SampleFramesHandler_BeginInvoke_m79D52B9AB6F6E72A9A9260F6608F7FA9F6A10ADC (void);\n// 0x00000019 System.Void UnityEngine.Experimental.Audio.AudioSampleProvider/SampleFramesHandler::EndInvoke(System.IAsyncResult)\nextern void SampleFramesHandler_EndInvoke_mC5357233A55B232AC8507FA4A04E06271EDE0309 (void);\nstatic Il2CppMethodPointer s_methodPointers[25] = \n{\n\tAudioSettings_InvokeOnAudioConfigurationChanged_m2CBD1FC39E7AE46E07E777990310D1DC40FB980E,\n\tAudioConfigurationChangeHandler__ctor_mB63AFBABA4712DF64F06A65CC7CE3C9E8C58080B,\n\tAudioConfigurationChangeHandler_Invoke_mDC001A19067B6A02B0DE21A4D66FC8D82529F911,\n\tAudioConfigurationChangeHandler_BeginInvoke_m2F17366BD1D34B7BB9FC60C1EF34EDC074D0003B,\n\tAudioConfigurationChangeHandler_EndInvoke_m78A4BB19DA6FBEACEC4F57A51D8076A337E02F4C,\n\tAudioClip_InvokePCMReaderCallback_Internal_m9CB2976CDC2C73A92479F8C11C30B17FAA05751F,\n\tAudioClip_InvokePCMSetPositionCallback_Internal_m9F3ACF3A244349568C0D0D1D40EE72EF013FB45D,\n\tPCMReaderCallback__ctor_mCA9CC5271DE0E4083B85759CA74EED1C1CD219F7,\n\tPCMReaderCallback_Invoke_mE5E7A777A52B9627F9A6A57A140E5C4AAB5A1387,\n\tPCMReaderCallback_BeginInvoke_mA4B5DF478312B7B7A00E13D869DF0AD4E01795A9,\n\tPCMReaderCallback_EndInvoke_m79DD97AB2919A10EBC91F78331213523EA5494DE,\n\tPCMSetPositionCallback__ctor_m0204C8557D7FB9E95F33168EDFD64182D9342002,\n\tPCMSetPositionCallback_Invoke_m1FBFFA5FC15B57601D6D13F4A574F7CAD2A93B7E,\n\tPCMSetPositionCallback_BeginInvoke_mF8CA8E07FDAF6B0821D2F1AE8F8545DC0FADC3A3,\n\tPCMSetPositionCallback_EndInvoke_m7096B994374E95A90C84B87625494BE1076B8574,\n\tAudioClipPlayable_GetHandle_mBEB846B088961170B6DB961951B511C11B98E0B8_AdjustorThunk,\n\tAudioClipPlayable_Equals_m52ECDD49AE6BD8AB4C0AC83C417A0C1B23E3E55E_AdjustorThunk,\n\tAudioMixerPlayable_GetHandle_m76EFC486A7639C4842F590F544B60988CF27BB17_AdjustorThunk,\n\tAudioMixerPlayable_Equals_mB55D2602ACCD196F61AF3D1AE90B81930A9AB7E8_AdjustorThunk,\n\tAudioSampleProvider_InvokeSampleFramesAvailable_mE6689CFA13C0621F305F389FEEE4D543B71BF236,\n\tAudioSampleProvider_InvokeSampleFramesOverflow_m998BEADD2A2B4BEF0906A31108B6DC486411CC78,\n\tSampleFramesHandler__ctor_m389B32B949592BFD1BA53D0C0983CA6B5BA6AAC7,\n\tSampleFramesHandler_Invoke_mCB6172CE3EF20C5E12A697A5CE5EEDED9A3B5779,\n\tSampleFramesHandler_BeginInvoke_m79D52B9AB6F6E72A9A9260F6608F7FA9F6A10ADC,\n\tSampleFramesHandler_EndInvoke_mC5357233A55B232AC8507FA4A04E06271EDE0309,\n};\nstatic const int32_t s_InvokerIndices[25] = \n{\n\t3900,\n\t1174,\n\t1994,\n\t608,\n\t1966,\n\t1966,\n\t1953,\n\t1174,\n\t1966,\n\t596,\n\t1966,\n\t1174,\n\t1953,\n\t584,\n\t1966,\n\t2316,\n\t1655,\n\t2316,\n\t1656,\n\t1953,\n\t1953,\n\t1174,\n\t1172,\n\t359,\n\t1966,\n};\nextern const CustomAttributesCacheGenerator g_UnityEngine_AudioModule_AttributeGenerators[];\nIL2CPP_EXTERN_C const Il2CppCodeGenModule g_UnityEngine_AudioModule_CodeGenModule;\nconst Il2CppCodeGenModule g_UnityEngine_AudioModule_CodeGenModule = \n{\n\t\"UnityEngine.AudioModule.dll\",\n\t25,\n\ts_methodPointers,\n\ts_InvokerIndices,\n\t0,\n\tNULL,\n\t0,\n\tNULL,\n\t0,\n\tNULL,\n\tNULL,\n\tg_UnityEngine_AudioModule_AttributeGenerators,\n\tNULL, // module initializer,\n\tNULL,\n\tNULL,\n\tNULL,\n};\n\n", "comment_ratio": 0.18309859154929578}
{"lang": "c", "code": "#define _HAL_INIT_C_\n\n#include <rtl8723b_hal.h>\n#include \"rtw_bt_mp.h\"\n#include \"hal_com_h2c.h\"\n#include <hal_com.h>\n\nstatic VOID\n_FWDownloadEnable(\n\tIN\tPADAPTER\t\tpadapter,\n\tIN\tBOOLEAN\t\t\tenable\n\t)\n{\n\tu8\ttmp, count = 0;\n\n\tif(enable)\n\t{\n\t\t// 8051 enable\n\t\ttmp = rtw_read8(padapter, REG_SYS_FUNC_EN+1);\n\t\trtw_write8(padapter, REG_SYS_FUNC_EN+1, tmp|0x04);\n\n\t\ttmp = rtw_read8(padapter, REG_MCUFWDL);\n\t\trtw_write8(padapter, REG_MCUFWDL, tmp|0x01);\n\n\t\tdo{\n\t\t\ttmp = rtw_read8(padapter, REG_MCUFWDL);\n\t\t\tif(tmp & 0x01)\n\t\t\t\tbreak;\n\t\t\trtw_write8(padapter, REG_MCUFWDL, tmp|0x01);\n\t\t\trtw_msleep_os(1);\n\t\t}while(count++<100);\n\t\tif(count > 0)\n\t\t\tDBG_871X(\"%s: !!!!!!!!Write 0x80 Fail!: count = %d\\n\", __func__, count);\n\n\t\t// 8051 reset\n\t\ttmp = rtw_read8(padapter, REG_MCUFWDL+2);\n\t\trtw_write8(padapter, REG_MCUFWDL+2, tmp&0xf7);\n\t}\n\telse\n\t{\n\t\t// MCU firmware download disable.\n\t\ttmp = rtw_read8(padapter, REG_MCUFWDL);\n\t\trtw_write8(padapter, REG_MCUFWDL, tmp&0xfe);\n\t}\n}\n\nstatic int\n_BlockWrite(\n\tIN\t\tPADAPTER\t\tpadapter,\n\tIN\t\tPVOID\t\tbuffer,\n\tIN\t\tu32\t\t\tbuffSize\n\t)\n{\n\tint ret = _SUCCESS;\n\n\tu32\t\t\tblockSize_p1 = 4;\t// (Default) Phase #1 : PCI muse use 4-byte write to download FW\n\tu32\t\t\tblockSize_p2 = 8;\t// Phase #2 : Use 8-byte, if Phase#1 use big size to write FW.\n\tu32\t\t\tblockSize_p3 = 1;\t// Phase #3 : Use 1-byte, the remnant of FW image.\n\tu32\t\t\tblockCount_p1 = 0, blockCount_p2 = 0, blockCount_p3 = 0;\n\tu32\t\t\tremainSize_p1 = 0, remainSize_p2 = 0;\n\tu8\t\t\t*bufferPtr\t= (u8*)buffer;\n\tu32\t\t\ti=0, offset=0;\n#ifdef CONFIG_PCI_HCI\n\tu8\t\t\tremainFW[4] = {0, 0, 0, 0};\n\tu8\t\t\t*p = NULL;\n#endif\n\n#ifdef CONFIG_USB_HCI\n\tblockSize_p1 = 254;\n#endif\n\n//\tprintk(\"====>%s %d\\n\", __func__, __LINE__);\n\n\t//3 Phase #1\n\tblockCount_p1 = buffSize / blockSize_p1;\n\tremainSize_p1 = buffSize % blockSize_p1;\n\n\tif (blockCount_p1) {\n\t\tRT_TRACE(_module_hal_init_c_, _drv_notice_,\n\t\t\t\t(\"_BlockWrite: [P1] buffSize(%d) blockSize_p1(%d) blockCount_p1(%d) remainSize_p1(%d)\\n\",\n\t\t\t\tbuffSize, blockSize_p1, blockCount_p1, remainSize_p1));\n\t}\n\n\tfor (i = 0; i < blockCount_p1; i++)\n\t{\n#ifdef CONFIG_USB_HCI\n\t\tret = rtw_writeN(padapter, (FW_8723B_START_ADDRESS + i * blockSize_p1), blockSize_p1, (bufferPtr + i * blockSize_p1));\n#else\n\t\tret = rtw_write32(padapter, (FW_8723B_START_ADDRESS + i * blockSize_p1), le32_to_cpu(*((u32*)(bufferPtr + i * blockSize_p1))));\n#endif\n\t\tif(ret == _FAIL) {\n\t\t\tprintk(\"====>%s %d i:%d\\n\", __func__, __LINE__, i);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n#ifdef CONFIG_PCI_HCI\n\tp = (u8*)((u32*)(bufferPtr + blockCount_p1 * blockSize_p1));\n\tif (remainSize_p1) {\n\t\tswitch (remainSize_p1) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tremainFW[2]=*(p+2);\n\t\tcase 2: \t\n\t\t\tremainFW[1]=*(p+1);\n\t\tcase 1: \t\n\t\t\tremainFW[0]=*(p);\n\t\t\tret = rtw_write32(padapter, (FW_8723B_START_ADDRESS + blockCount_p1 * blockSize_p1), \n\t\t\t\t le32_to_cpu(*(u32*)remainFW));\t\n\t\t}\n\t\treturn ret;\n\t}\n#endif\n\n\t//3 Phase #2\n\tif (remainSize_p1)\n\t{\n\t\toffset = blockCount_p1 * blockSize_p1;\n\n\t\tblockCount_p2 = remainSize_p1/blockSize_p2;\n\t\tremainSize_p2 = remainSize_p1%blockSize_p2;\n\n\t\tif (blockCount_p2) {\n\t\t\t\tRT_TRACE(_module_hal_init_c_, _drv_notice_,\n\t\t\t\t\t\t(\"_BlockWrite: [P2] buffSize_p2(%d) blockSize_p2(%d) blockCount_p2(%d) remainSize_p2(%d)\\n\",\n\t\t\t\t\t\t(buffSize-offset), blockSize_p2 ,blockCount_p2, remainSize_p2));\n\t\t}\n\n#ifdef CONFIG_USB_HCI\n\t\tfor (i = 0; i < blockCount_p2; i++) {\n\t\t\tret = rtw_writeN(padapter, (FW_8723B_START_ADDRESS + offset + i*blockSize_p2), blockSize_p2, (bufferPtr + offset + i*blockSize_p2));\n\n\t\t\tif(ret == _FAIL)\n\t\t\t\tgoto exit;\n\t\t}\n#endif\n\t}\n\n\t//3 Phase #3\n\tif (remainSize_p2)\n\t{\n\t\toffset = (blockCount_p1 * blockSize_p1) + (blockCount_p2 * blockSize_p2);\n\n\t\tblockCount_p3 = remainSize_p2 / blockSize_p3;\n\n\t\tRT_TRACE(_module_hal_init_c_, _drv_notice_,\n\t\t\t\t(\"_BlockWrite: [P3] buffSize_p3(%d) blockSize_p3(%d) blockCount_p3(%d)\\n\",\n\t\t\t\t(buffSize-offset), blockSize_p3, blockCount_p3));\n\n\t\tfor(i = 0 ; i < blockCount_p3 ; i++){\n\t\t\tret = rtw_write8(padapter, (FW_8723B_START_ADDRESS + offset + i), *(bufferPtr + offset + i));\n\n\t\t\tif(ret == _FAIL) {\n\t\t\t\tprintk(\"====>%s %d i:%d\\n\", __func__, __LINE__, i);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t}\nexit:\n\treturn ret;\n}\n\nstatic int\n_PageWrite(\n\tIN\t\tPADAPTER\tpadapter,\n\tIN\t\tu32\t\t\tpage,\n\tIN\t\tPVOID\t\tbuffer,\n\tIN\t\tu32\t\t\tsize\n\t)\n{\n\tu8 value8;\n\tu8 u8Page = (u8) (page & 0x07) ;\n\n\tvalue8 = (rtw_read8(padapter, REG_MCUFWDL+2) & 0xF8) | u8Page ;\n\trtw_write8(padapter, REG_MCUFWDL+2,value8);\n\n\treturn _BlockWrite(padapter,buffer,size);\n}\n\nstatic VOID\n_FillDummy(\n\tu8*\t\tpFwBuf,\n\tu32*\tpFwLen\n\t)\n{\n\tu32\tFwLen = *pFwLen;\n\tu8\tremain = (u8)(FwLen%4);\n\tremain = (remain==0)?0:(4-remain);\n\n\twhile(remain>0)\n\t{\n\t\tpFwBuf[FwLen] = 0;\n\t\tFwLen++;\n\t\tremain--;\n\t}\n\n\t*pFwLen = FwLen;\n}\n\nstatic int\n_WriteFW(\n\tIN\t\tPADAPTER\t\tpadapter,\n\tIN\t\tPVOID\t\t\tbuffer,\n\tIN\t\tu32\t\t\tsize\n\t)\n{\n\t// Since we need dynamic decide method of dwonload fw, so we call this function to get chip version.\n\tint ret = _SUCCESS;\n\tu32 \tpageNums,remainSize ;\n\tu32 \tpage, offset;\n\tu8\t\t*bufferPtr = (u8*)buffer;\n\n#ifdef CONFIG_PCI_HCI\n\t// 20100120 Joseph: Add for 88CE normal chip.\n\t// Fill in zero to make firmware image to dword alignment.\n\t_FillDummy(bufferPtr, &size);\n#endif\n\n\tpageNums = size / MAX_DLFW_PAGE_SIZE ;\n\t//RT_ASSERT((pageNums <= 4), (\"Page numbers should not greater then 4 \\n\"));\n\tremainSize = size % MAX_DLFW_PAGE_SIZE;\n\n\tfor (page = 0; page < pageNums; page++) {\n\t\toffset = page * MAX_DLFW_PAGE_SIZE;\n\t\tret = _PageWrite(padapter, page, bufferPtr+offset, MAX_DLFW_PAGE_SIZE);\n\n\t\tif(ret == _FAIL) {\n\t\t\tprintk(\"====>%s %d\\n\", __func__, __LINE__);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\tif (remainSize) {\n\t\toffset = pageNums * MAX_DLFW_PAGE_SIZE;\n\t\tpage = pageNums;\n\t\tret = _PageWrite(padapter, page, bufferPtr+offset, remainSize);\n\n\t\tif(ret == _FAIL) {\n\t\t\tprintk(\"====>%s %d\\n\", __func__, __LINE__);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\tRT_TRACE(_module_hal_init_c_, _drv_info_, (\"_WriteFW Done- for Normal chip.\\n\"));\n\nexit:\n\treturn ret;\n}\n\nvoid _8051Reset8723(PADAPTER padapter)\n{\n\tu8 cpu_rst;\n\tu8 io_rst;\n\n\tio_rst = rtw_read8(padapter, REG_RSV_CTRL);\n\trtw_write8(padapter, REG_RSV_CTRL, io_rst&(~BIT1));\n\t// Reset 8051(WLMCU) IO wrapper\n\t// 0x1c[8] = 0\n\t// Suggested by Isaac@SD1 and Gimmy@SD1, coding by Lucas@20130624\n\tio_rst = rtw_read8(padapter, REG_RSV_CTRL+1);\n\tio_rst &= ~BIT(0);\n\trtw_write8(padapter, REG_RSV_CTRL+1, io_rst);\n\n\tcpu_rst = rtw_read8(padapter, REG_SYS_FUNC_EN+1);\n\tcpu_rst &= ~BIT(2);\n\trtw_write8(padapter, REG_SYS_FUNC_EN+1, cpu_rst);\n\n\tio_rst = rtw_read8(padapter, REG_RSV_CTRL);\n\trtw_write8(padapter, REG_RSV_CTRL, io_rst&(~BIT1));\n\t// Enable 8051 IO wrapper\t\n\t// 0x1c[8] = 1\n\tio_rst = rtw_read8(padapter, REG_RSV_CTRL+1);\n\tio_rst |= BIT(0);\n\trtw_write8(padapter, REG_RSV_CTRL+1, io_rst);\n\n\tcpu_rst = rtw_read8(padapter, REG_SYS_FUNC_EN+1);\n\tcpu_rst |= BIT(2);\n\trtw_write8(padapter, REG_SYS_FUNC_EN+1, cpu_rst);\n\n\tDBG_8192C(\"%s: Finish\\n\", __FUNCTION__);\n}\n\nstatic s32 polling_fwdl_chksum(_adapter *adapter, u32 min_cnt, u32 timeout_ms)\n{\n\ts32 ret = _FAIL;\n\tu32 value32;\n\tu32 start = rtw_get_current_time();\n\tu32 cnt = 0;\n\n\t/* polling CheckSum report */\n\tdo {\n\t\tcnt++;\n\t\tvalue32 = rtw_read32(adapter, REG_MCUFWDL);\n\t\tif (value32 & FWDL_ChkSum_rpt || adapter->bSurpriseRemoved || adapter->bDriverStopped)\n\t\t\tbreak;\n\t\trtw_yield_os();\n\t} while (rtw_get_passing_time_ms(start) < timeout_ms || cnt < min_cnt);\n\n\tif (!(value32 & FWDL_ChkSum_rpt)) {\n\t\tgoto exit;\n\t}\n\n\tif (rtw_fwdl_test_trigger_chksum_fail())\n\t\tgoto exit;\n\n\tret = _SUCCESS;\n\nexit:\n\tDBG_871X(\"%s: Checksum report %s! (%u, %dms), REG_MCUFWDL:0x%08x\\n\", __FUNCTION__\n\t, (ret==_SUCCESS)?\"OK\":\"Fail\", cnt, rtw_get_passing_time_ms(start), value32);\n\n\treturn ret;\n}\n\nstatic s32 _FWFreeToGo(_adapter *adapter, u32 min_cnt, u32 timeout_ms)\n{\n\ts32 ret = _FAIL;\n\tu32\tvalue32;\n\tu32 start = rtw_get_current_time();\n\tu32 cnt = 0;\n\n\tvalue32 = rtw_read32(adapter, REG_MCUFWDL);\n\tvalue32 |= MCUFWDL_RDY;\n\tvalue32 &= ~WINTINI_RDY;\n\trtw_write32(adapter, REG_MCUFWDL, value32);\n\n\t_8051Reset8723(adapter);\n\n\t/*  polling for FW ready */\n\tdo {\n\t\tcnt++;\n\t\tvalue32 = rtw_read32(adapter, REG_MCUFWDL);\n\t\tif (value32 & WINTINI_RDY || adapter->bSurpriseRemoved || adapter->bDriverStopped)\n\t\t\tbreak;\n\t\trtw_yield_os();\n\t} while (rtw_get_passing_time_ms(start) < timeout_ms || cnt < min_cnt);\n\n\tif (!(value32 & WINTINI_RDY)) {\n\t\tgoto exit;\n\t}\n\n\tif (rtw_fwdl_test_trigger_wintint_rdy_fail())\n\t\tgoto exit;\n\n\tret = _SUCCESS;\n\nexit:\n\tDBG_871X(\"%s: Polling FW ready %s! (%u, %dms), REG_MCUFWDL:0x%08x\\n\", __FUNCTION__\n\t\t, (ret==_SUCCESS)?\"OK\":\"Fail\", cnt, rtw_get_passing_time_ms(start), value32);\n\n\treturn ret;\n}\n\n#define IS_FW_81xxC(padapter)\t(((GET_HAL_DATA(padapter))->FirmwareSignature & 0xFFF0) == 0x88C0)\n\nvoid rtl8723b_FirmwareSelfReset(PADAPTER padapter)\n{\n\tHAL_DATA_TYPE\t*pHalData = GET_HAL_DATA(padapter);\n\tu8\tu1bTmp;\n\tu8\tDelay = 100;\n\n\tif (!(IS_FW_81xxC(padapter) &&\n\t\t  ((pHalData->FirmwareVersion < 0x21) ||\n\t\t   (pHalData->FirmwareVersion == 0x21 &&\n\t\t    pHalData->FirmwareSubVersion < 0x01)))) // after 88C Fw v33.1\n\t{\n\t\t//0x1cf=0x20. Inform 8051 to reset. 2009.12.25. tynli_test\n\t\trtw_write8(padapter, REG_HMETFR+3, 0x20);\n\n\t\tu1bTmp = rtw_read8(padapter, REG_SYS_FUNC_EN+1);\n\t\twhile (u1bTmp & BIT2)\n\t\t{\n\t\t\tDelay--;\n\t\t\tif(Delay == 0)\n\t\t\t\tbreak;\n\t\t\trtw_udelay_os(50);\n\t\t\tu1bTmp = rtw_read8(padapter, REG_SYS_FUNC_EN+1);\n\t\t}\n\t\tRT_TRACE(_module_hal_init_c_, _drv_notice_, (\"-%s: 8051 reset success (%d)\\n\", __FUNCTION__, Delay));\n\n\t\tif (Delay == 0)\n\t\t{\n\t\t\tRT_TRACE(_module_hal_init_c_, _drv_notice_, (\"%s: Force 8051 reset!!!\\n\", __FUNCTION__));\n\t\t\t//force firmware reset\n\t\t\tu1bTmp = rtw_read8(padapter, REG_SYS_FUNC_EN+1);\n\t\t\trtw_write8(padapter, REG_SYS_FUNC_EN+1, u1bTmp&(~BIT2));\n\t\t}\n\t}\n}\n\n#ifdef CONFIG_FILE_FWIMG\nextern char *rtw_fw_file_path;\nextern char *rtw_fw_wow_file_path;\n#ifdef CONFIG_MP_INCLUDED\nextern char *rtw_fw_mp_bt_file_path;\n#endif // CONFIG_MP_INCLUDED\nu8 FwBuffer[FW_8723B_SIZE];\n#endif // CONFIG_FILE_FWIMG\n\n#ifdef CONFIG_MP_INCLUDED\nint _WriteBTFWtoTxPktBuf8723B(\n\tIN\t\tPADAPTER\t\tAdapter,\n\tIN\t\tPVOID\t\t\tbuffer,\n\tIN\t\tu4Byte\t\t\tFwBufLen,\n\tIN\t\tu1Byte\t\t\ttimes\n\t)\n{\n\tint\t\t\trtStatus = _SUCCESS;\n\t//u4Byte\t\t\t\tvalue32;\n\t//u1Byte\t\t\t\tnumHQ, numLQ, numPubQ;//, txpktbuf_bndy;\n\tHAL_DATA_TYPE\t\t*pHalData = GET_HAL_DATA(Adapter);\n\t//PMGNT_INFO\t\tpMgntInfo = &(Adapter->MgntInfo);\n\tu1Byte\t\t\t\tBcnValidReg;\n\tu1Byte\t\t\t\tcount=0, DLBcnCount=0;\n\tpu1Byte \t\t\tFwbufferPtr = (pu1Byte)buffer;\n\t//PRT_TCB \t\t\tpTcb, ptempTcb;\n\t//PRT_TX_LOCAL_BUFFER pBuf;\n\tBOOLEAN \t\t\tbRecover=_FALSE;\n\tpu1Byte \t\t\tReservedPagePacket = NULL;\n\tpu1Byte \t\t\tpGenBufReservedPagePacket = NULL;\n\tu4Byte\t\t\t\tTotalPktLen,txpktbuf_bndy;\n\t//u1Byte\t\t\t\ttmpReg422;\n\t//u1Byte\t\t\t\tu1bTmp;\n\tu8 \t\t\t*pframe;\n\tstruct xmit_priv\t*pxmitpriv = &(Adapter->xmitpriv);\n\tstruct xmit_frame\t*pmgntframe;\n\tstruct pkt_attrib\t*pattrib;\n\tu8 \t\t\ttxdesc_offset = TXDESC_OFFSET;\n\tu8\t\t\tval8;\n#if (DEV_BUS_TYPE == RT_PCI_INTERFACE)\n\tu8\t\t\tu1bTmp;\n#endif\n\n#if 1//(DEV_BUS_TYPE == RT_PCI_INTERFACE)\n\tTotalPktLen = FwBufLen;\n#else\n\tTotalPktLen = FwBufLen+pHalData->HWDescHeadLength;\n#endif\n\n\tif((TotalPktLen+TXDESC_OFFSET) > MAX_CMDBUF_SZ)\n\t{\n\t\tDBG_871X(\" WARNING %s => Total packet len = %d > MAX_CMDBUF_SZ:%d \\n\"\n\t\t\t,__FUNCTION__,(TotalPktLen+TXDESC_OFFSET),MAX_CMDBUF_SZ);\n\t\treturn _FAIL;\n\t}\n\n\tpGenBufReservedPagePacket = rtw_zmalloc(TotalPktLen);//GetGenTempBuffer (Adapter, TotalPktLen);\n\tif (!pGenBufReservedPagePacket)\n\t\treturn _FAIL;\n\n\tReservedPagePacket = (u1Byte *)pGenBufReservedPagePacket;\n\n\t_rtw_memset(ReservedPagePacket, 0, TotalPktLen);\n\n#if 1//(DEV_BUS_TYPE == RT_PCI_INTERFACE)\n\t_rtw_memcpy(ReservedPagePacket, FwbufferPtr, FwBufLen);\n\n#else\n\tPlatformMoveMemory(ReservedPagePacket+Adapter->HWDescHeadLength , FwbufferPtr, FwBufLen);\n#endif\n\n\t//---------------------------------------------------------\n\t// 1. Pause BCN\n\t//---------------------------------------------------------\n\t//Set REG_CR bit 8. DMA beacon by SW.\n#if (DEV_BUS_TYPE == RT_PCI_INTERFACE)\n\tu1bTmp = PlatformEFIORead1Byte(Adapter, REG_CR+1);\n\tPlatformEFIOWrite1Byte(Adapter,  REG_CR+1, (u1bTmp|BIT0));\n#else\n\t// Remove for temparaily because of the code on v2002 is not sync to MERGE_TMEP for USB/SDIO.\n\t// De not remove this part on MERGE_TEMP. by tynli.\n\t//pHalData->RegCR_1 |= (BIT0);\n\t//PlatformEFIOWrite1Byte(Adapter,  REG_CR+1, pHalData->RegCR_1);\n#endif\n\n\t// Disable Hw protection for a time which revserd for Hw sending beacon.\n\t// Fix download reserved page packet fail that access collision with the protection time.\n\t// 2010.05.11. Added by tynli.\n\tval8 = rtw_read8(Adapter, REG_BCN_CTRL);\n\tval8 &= ~EN_BCN_FUNCTION;\n\tval8 |= DIS_TSF_UDT;\n\trtw_write8(Adapter, REG_BCN_CTRL, val8);\n\n#if 0//(DEV_BUS_TYPE == RT_PCI_INTERFACE)\n\ttmpReg422 = PlatformEFIORead1Byte(Adapter, REG_FWHW_TXQ_CTRL+2);\n\tif( tmpReg422&BIT6)\n\t\tbRecover = TRUE;\n\tPlatformEFIOWrite1Byte(Adapter, REG_FWHW_TXQ_CTRL+2,  tmpReg422&(~BIT6));\n#else\n\t// Set FWHW_TXQ_CTRL 0x422[6]=0 to tell Hw the packet is not a real beacon frame.\n\tif(pHalData->RegFwHwTxQCtrl & BIT(6))\n\t\tbRecover=_TRUE;\n\tPlatformEFIOWrite1Byte(Adapter, REG_FWHW_TXQ_CTRL+2, (pHalData->RegFwHwTxQCtrl&(~BIT(6))));\n\tpHalData->RegFwHwTxQCtrl &= (~ BIT(6));\n#endif\n\n\t//---------------------------------------------------------\n\t// 2. Adjust LLT table to an even boundary.\n\t//---------------------------------------------------------\n#if 0//(DEV_BUS_TYPE == RT_SDIO_INTERFACE)\n\ttxpktbuf_bndy = 10; // rsvd page start address should be an even value. \t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\trtStatus =\tInitLLTTable8723BS(Adapter, txpktbuf_bndy);\n\tif(RT_STATUS_SUCCESS != rtStatus){\n\t\tDBG_8192C(\"_CheckWLANFwPatchBTFwReady_8723B(): Failed to init LLT!\\n\");\n\t\treturn RT_STATUS_FAILURE;\n\t}\n\t\n\t// Init Tx boundary.\n\tPlatformEFIOWrite1Byte(Adapter, REG_DWBCN0_CTRL_8723B+1, (u1Byte)txpktbuf_bndy);\t\n#endif\n\n\n\t//---------------------------------------------------------\n\t// 3. Write Fw to Tx packet buffer by reseverd page.\n\t//---------------------------------------------------------\n\tdo\n\t{\n\t\t// download rsvd page.\n\t\t// Clear beacon valid check bit.\n\t\tBcnValidReg = PlatformEFIORead1Byte(Adapter, REG_TDECTRL+2);\n\t\tPlatformEFIOWrite1Byte(Adapter, REG_TDECTRL+2, BcnValidReg&(~BIT(0)));\n\n\t\t//BT patch is big, we should set 0x209 < 0x40 suggested from Gimmy\n\t\tRT_TRACE(_module_mp_, _drv_info_,(\"0x209:%x\\n\",\n\t\t\t\t\tPlatformEFIORead1Byte(Adapter, REG_TDECTRL+1)));//209 < 0x40\n\n\t\tPlatformEFIOWrite1Byte(Adapter, REG_TDECTRL+1, (0x90-0x20*(times-1)));\n\t\tDBG_871X(\"0x209:0x%x\\n\", PlatformEFIORead1Byte(Adapter, REG_TDECTRL+1));\n\t\tRT_TRACE(_module_mp_, _drv_info_,(\"0x209:%x\\n\",\n\t\t\t\t\tPlatformEFIORead1Byte(Adapter, REG_TDECTRL+1)));\n\n#if 0\n\t\t// Acquice TX spin lock before GetFwBuf and send the packet to prevent system deadlock.\n\t\t// Advertised by Roger. Added by tynli. 2010.02.22.\n\t\tPlatformAcquireSpinLock(Adapter, RT_TX_SPINLOCK);\n\t\tif(MgntGetFWBuffer(Adapter, &pTcb, &pBuf))\n\t\t{\n\t\t\tPlatformMoveMemory(pBuf->Buffer.VirtualAddress, ReservedPagePacket, TotalPktLen);\n\t\t\tCmdSendPacket(Adapter, pTcb, pBuf, TotalPktLen, DESC_PACKET_TYPE_NORMAL, FALSE);\n\t\t}\n\t\telse\n\t\t\tdbgdump(\"SetFwRsvdPagePkt(): MgntGetFWBuffer FAIL!!!!!!!!.\\n\");\n\t\tPlatformReleaseSpinLock(Adapter, RT_TX_SPINLOCK);\n#else\n\t\t/*---------------------------------------------------------\n\t\ttx reserved_page_packet\n\t\t----------------------------------------------------------*/\n\t\t\tif ((pmgntframe = rtw_alloc_cmdxmitframe(pxmitpriv)) == NULL) {\n\t\t\t\t\trtStatus = _FAIL;\n\t\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\t//update attribute\n\t\t\tpattrib = &pmgntframe->attrib;\n\t\t\tupdate_mgntframe_attrib(Adapter, pattrib);\n\n\t\t\tpattrib->qsel = QSLT_BEACON;\n\t\t\tpattrib->pktlen = pattrib->last_txcmdsz = FwBufLen ;\n\n\t\t\t//_rtw_memset(pmgntframe->buf_addr, 0, TotalPktLen+txdesc_size);\n\t\t\t//pmgntframe->buf_addr = ReservedPagePacket ;\n\n\t\t\t_rtw_memcpy( (u8*) (pmgntframe->buf_addr + txdesc_offset), ReservedPagePacket, FwBufLen);\n\t\t\tDBG_871X(\"[%d]===>TotalPktLen + TXDESC_OFFSET TotalPacketLen:%d \\n\", DLBcnCount, (FwBufLen + txdesc_offset));\n\t\t\t\n#ifdef CONFIG_PCI_HCI\n\t\t\tdump_mgntframe(Adapter, pmgntframe);\n#else\n\t\t\tdump_mgntframe_and_wait(Adapter, pmgntframe, 100);\n#endif\n\n#endif\n#if 1\n\t\t// check rsvd page download OK.\n\t\tBcnValidReg = PlatformEFIORead1Byte(Adapter, REG_TDECTRL+2);\n\t\twhile(!(BcnValidReg & BIT(0)) && count <200)\n\t\t{\n\t\t\tcount++;\n\t\t\t//PlatformSleepUs(10);\n\t\t\trtw_msleep_os(1);\n\t\t\tBcnValidReg = PlatformEFIORead1Byte(Adapter, REG_TDECTRL+2);\n\t\t\tRT_TRACE(_module_mp_, _drv_notice_,(\"Poll 0x20A = %x\\n\", BcnValidReg));\n\t\t}\n\t\tDLBcnCount++;\n\t\t//DBG_871X(\"##0x208:%08x,0x210=%08x\\n\",PlatformEFIORead4Byte(Adapter, REG_TDECTRL),PlatformEFIORead4Byte(Adapter, 0x210));\n\n\t\tPlatformEFIOWrite1Byte(Adapter, REG_TDECTRL+2,BcnValidReg);\n\t\t\n\t}while((!(BcnValidReg&BIT(0))) && DLBcnCount<5);\n\n\n#endif\n\tif(DLBcnCount >=5){\n\t\tDBG_871X(\" check rsvd page download OK DLBcnCount =%d  \\n\",DLBcnCount);\n\t\trtStatus = _FAIL;\n\t\tgoto exit;\n\t}\n\n\tif(!(BcnValidReg&BIT(0)))\n\t{\n\t\tDBG_871X(\"_WriteFWtoTxPktBuf(): 1 Download RSVD page failed!\\n\");\n\t\trtStatus = _FAIL;\n\t\tgoto exit;\n\t}\n\n\t//---------------------------------------------------------\n\t// 4. Set Tx boundary to the initial value\n\t//---------------------------------------------------------\n\n\n\t//---------------------------------------------------------\n\t// 5. Reset beacon setting to the initial value.\n\t//\t After _CheckWLANFwPatchBTFwReady().\n\t//---------------------------------------------------------\n\nexit:\n\n\tif(pGenBufReservedPagePacket)\n\t{\n\t\tDBG_871X(\"_WriteBTFWtoTxPktBuf8723B => rtw_mfree pGenBufReservedPagePacket!\\n\");\n\t\trtw_mfree((u8*)pGenBufReservedPagePacket, TotalPktLen);\n\t\t}\n\treturn rtStatus;\n}\n\n\n\n//\n// Description: Determine the contents of H2C BT_FW_PATCH Command sent to FW.\n// 2011.10.20 by tynli\n//\nvoid\nSetFwBTFwPatchCmd(\n\tIN PADAPTER\tAdapter,\n\tIN u16\t\tFwSize\n\t)\n{\n\tu8 u1BTFwPatchParm[H2C_BT_FW_PATCH_LEN]={0};\n\tu8 addr0 = 0;\n\tu8 addr1 = 0xa0;\n\tu8 addr2 = 0x10;\n\tu8 addr3 = 0x80;\n\t\n\tRT_TRACE(_module_mp_, _drv_notice_,(\"SetFwBTFwPatchCmd(): FwSize = %d\\n\", FwSize));\n\n\tSET_8723B_H2CCMD_BT_FW_PATCH_SIZE(u1BTFwPatchParm, FwSize);\n\tSET_8723B_H2CCMD_BT_FW_PATCH_ADDR0(u1BTFwPatchParm, addr0);\n\tSET_8723B_H2CCMD_BT_FW_PATCH_ADDR1(u1BTFwPatchParm, addr1);\n\tSET_8723B_H2CCMD_BT_FW_PATCH_ADDR2(u1BTFwPatchParm, addr2);\n\tSET_8723B_H2CCMD_BT_FW_PATCH_ADDR3(u1BTFwPatchParm, addr3);\n\n\tFillH2CCmd8723B(Adapter, H2C_8723B_BT_FW_PATCH, H2C_BT_FW_PATCH_LEN, u1BTFwPatchParm);\n\n\tRT_TRACE(_module_mp_, _drv_notice_,(\"<----SetFwBTFwPatchCmd(): FwSize = %d \\n\", FwSize));\n}\n\nvoid\nSetFwBTPwrCmd(\n\tIN PADAPTER\tAdapter,\n\tIN u1Byte\tPwrIdx\n\t)\n{\n\tu1Byte\t\tu1BTPwrIdxParm[H2C_FORCE_BT_TXPWR_LEN]={0};\n\n\tRT_TRACE(_module_mp_, _drv_info_,(\"SetFwBTPwrCmd(): idx = %d\\n\", PwrIdx));\n\tSET_8723B_H2CCMD_BT_PWR_IDX(u1BTPwrIdxParm, PwrIdx);\n\n\tRT_TRACE(_module_mp_, _drv_info_,(\"SetFwBTPwrCmd(): %x %x %x\\n\",\n\t\tu1BTPwrIdxParm[0],u1BTPwrIdxParm[1],u1BTPwrIdxParm[2]));\n\n\tFillH2CCmd8723B(Adapter, H2C_8723B_FORCE_BT_TXPWR, H2C_FORCE_BT_TXPWR_LEN, u1BTPwrIdxParm);\n}\n\n//\n// Description: WLAN Fw will write BT Fw to BT XRAM and signal driver.\n//\n// 2011.10.20. by tynli.\n//\nint\n_CheckWLANFwPatchBTFwReady(\n\tIN\tPADAPTER\t\t\tAdapter\n)\n{\n\tHAL_DATA_TYPE\t*pHalData = GET_HAL_DATA(Adapter);\n\tu4Byte\tcount=0;\n\tu1Byte\tu1bTmp;\n\tint ret = _FAIL;\n\n\t//---------------------------------------------------------\n\t// Check if BT FW patch procedure is ready.\n\t//---------------------------------------------------------\n\tdo{\n\t\tu1bTmp = PlatformEFIORead1Byte(Adapter, REG_HMEBOX_DBG_0_8723B);\n\t\tif((u1bTmp&BIT6) || (u1bTmp&BIT7))\n\t\t{\n\t\t\tret = _SUCCESS;\n\t\t\tbreak;\n\t\t}\n\n\t\tcount++;\n\t\tRT_TRACE(_module_mp_, _drv_info_,(\"0x88=%x, wait for 50 ms (%d) times.\\n\",\n\t\t\t\t\tu1bTmp, count));\n\t\trtw_msleep_os(50); // 50ms\n\t}while(!((u1bTmp&BIT6) || (u1bTmp&BIT7)) && count < 50);\n\n\tRT_TRACE(_module_mp_, _drv_notice_,(\"_CheckWLANFwPatchBTFwReady():\"\n\t\t\t\t\" Polling ready bit 0x88[7] for %d times.\\n\", count));\n\n\tif(count >= 50)\n\t{\n\t\tRT_TRACE(_module_mp_, _drv_notice_,(\"_CheckWLANFwPatchBTFwReady():\"\n\t\t\t\t\" Polling ready bit 0x88[7] FAIL!!\\n\"));\n\t}\n\n\t//---------------------------------------------------------\n\t// Reset beacon setting to the initial value.\n\t//---------------------------------------------------------\n#if 0//(DEV_BUS_TYPE == RT_PCI_INTERFACE)\n\tif(LLT_table_init(Adapter, FALSE, 0) == RT_STATUS_FAILURE)\n\t{\n\t\tdbgdump(\"Init self define for BT Fw patch LLT table fail.\\n\");\n\t\t//return RT_STATUS_FAILURE;\n\t}\n#endif\n\tu1bTmp = rtw_read8(Adapter, REG_BCN_CTRL);\n\tu1bTmp |= EN_BCN_FUNCTION;\n\tu1bTmp &= ~DIS_TSF_UDT;\n\trtw_write8(Adapter, REG_BCN_CTRL, u1bTmp);\n\n\t// To make sure that if there exists an adapter which would like to send beacon.\n\t// If exists, the origianl value of 0x422[6] will be 1, we should check this to\n\t// prevent from setting 0x422[6] to 0 after download reserved page, or it will cause\n\t// the beacon cannot be sent by HW.\n\t// 2010.06.23. Added by tynli.\n#if 0//(DEV_BUS_TYPE == RT_PCI_INTERFACE)\n\tu1bTmp = PlatformEFIORead1Byte(Adapter, REG_FWHW_TXQ_CTRL+2);\n\tPlatformEFIOWrite1Byte(Adapter, REG_FWHW_TXQ_CTRL+2, (u1bTmp|BIT6));\n#else\n\tPlatformEFIOWrite1Byte(Adapter, REG_FWHW_TXQ_CTRL+2, (pHalData->RegFwHwTxQCtrl|BIT(6)));\n\tpHalData->RegFwHwTxQCtrl |= BIT(6);\n#endif\n\n\t// Clear CR[8] or beacon packet will not be send to TxBuf anymore.\n\tu1bTmp = PlatformEFIORead1Byte(Adapter, REG_CR_8723B+1);\n\tPlatformEFIOWrite1Byte(Adapter, REG_CR_8723B+1, (u1bTmp&(~BIT0)));\n\n\treturn ret;\n}\n\nint ReservedPage_Compare(PADAPTER Adapter,PRT_MP_FIRMWARE pFirmware,u32 BTPatchSize)\n{\n\tu8 temp,ret,lastBTsz;\n\tu32 u1bTmp=0,address_start=0,count=0,i=0;\n\tu8\t*myBTFwBuffer = NULL;\n\n\tmyBTFwBuffer = rtw_zmalloc(BTPatchSize);\n\tif (myBTFwBuffer == NULL)\n\t{\n\t\tDBG_871X(\"%s can't be executed due to the failed malloc.\\n\", __FUNCTION__);\n\t\tAdapter->mppriv.bTxBufCkFail=_TRUE;\n\t\treturn _FALSE;\n\t}\n\t\n\ttemp=rtw_read8(Adapter,0x209);\n\t\n\taddress_start=(temp*128)/8;\n\t\n\trtw_write32(Adapter,0x140,0x00000000);\n\trtw_write32(Adapter,0x144,0x00000000);\n\trtw_write32(Adapter,0x148,0x00000000);\n\n\trtw_write8(Adapter,0x106,0x69);\n\t\n\tfor(i=0;i<(BTPatchSize/8);i++)\n\t{\n\t\trtw_write32(Adapter,0x140,address_start+5+i) ;\t\t  \n\t\t\t\n\t\t//polling until reg 0x140[23]=1;\n\t\tdo{\n\t\t\tu1bTmp = rtw_read32(Adapter, 0x140);\n\t\t\tif(u1bTmp&BIT(23))\n\t\t\t{\n\t\t\t\tret = _SUCCESS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tDBG_871X(\"0x140=%x, wait for 10 ms (%d) times.\\n\",u1bTmp, count);\n\t\t\trtw_msleep_os(10); // 10ms\n\t\t}while(!(u1bTmp&BIT(23)) && count < 50);\n\t\t\n\t\t\tmyBTFwBuffer[i*8+0]=rtw_read8(Adapter, 0x144);\n\t\t\tmyBTFwBuffer[i*8+1]=rtw_read8(Adapter, 0x145);\n\t\t\tmyBTFwBuffer[i*8+2]=rtw_read8(Adapter, 0x146); \n\t\t\tmyBTFwBuffer[i*8+3]=rtw_read8(Adapter, 0x147);\n\t\t\tmyBTFwBuffer[i*8+4]=rtw_read8(Adapter, 0x148);\n\t\t\tmyBTFwBuffer[i*8+5]=rtw_read8(Adapter, 0x149);\n\t\t\tmyBTFwBuffer[i*8+6]=rtw_read8(Adapter, 0x14a);\n\t\t\tmyBTFwBuffer[i*8+7]=rtw_read8(Adapter, 0x14b);\n\t}\n\t\n\trtw_write32(Adapter,0x140,address_start+5+BTPatchSize/8) ;\t\t\t  \n\n\tlastBTsz=BTPatchSize%8;\n\t\n\t//polling until reg 0x140[23]=1;\n\tu1bTmp=0;\n\tcount=0;\n\tdo{\n\t\t\tu1bTmp = rtw_read32(Adapter, 0x140);\n\t\t\tif(u1bTmp&BIT(23))\n\t\t\t{\n\t\t\t\tret = _SUCCESS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tDBG_871X(\"0x140=%x, wait for 10 ms (%d) times.\\n\",u1bTmp, count);\n\t\t\trtw_msleep_os(10); // 10ms\n\t}while(!(u1bTmp&BIT(23)) && count < 50);\n\n\tfor(i=0;i<lastBTsz;i++)\n\t{\n\t\tmyBTFwBuffer[(BTPatchSize/8)*8+i] = rtw_read8(Adapter, (0x144+i));\n\n\t}\n\n\tfor(i=0;i<BTPatchSize;i++)\n\t{\n\t\tif(myBTFwBuffer[i]!= pFirmware->szFwBuffer[i])\n\t\t{\n\t\t\tDBG_871X(\" In direct myBTFwBuffer[%d]=%x , pFirmware->szFwBuffer=%x\\n\",i, myBTFwBuffer[i],pFirmware->szFwBuffer[i]);\n\t\t\tAdapter->mppriv.bTxBufCkFail=_TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (myBTFwBuffer != NULL)\n\t{\n\t\trtw_mfree(myBTFwBuffer, BTPatchSize);\n\t}\n\n\treturn _TRUE;\n}\n\n/* As the size of bt firmware is more than 16k which is too big for some platforms, we divide it\n * into four parts to transfer. The last parameter of _WriteBTFWtoTxPktBuf8723B is used to indicate\n * the location of every part. We call the first 4096 byte of bt firmware as part 1, the second 4096\n * part as part 2, the third 4096 part as part 3, the remain as part 4. First we transform the part\n * 4 and set the register 0x209 to 0x90, then the 32 bytes description are added to the head of part\n * 4, and those bytes are putted at the location 0x90. Second we transform the part 3 and set the \n * register 0x209 to 0x70. The 32 bytes description and part 3(4196 bytes) are putted at the location\n * 0x70. It can contain 4196 bytes between 0x70 and 0x90. So the last 32 bytes os part 3 will cover the\n * 32 bytes description of part4. Using this method, we can put the whole bt firmware to 0x30 and only\n * has 32 bytes descrption at the head of part 1.    \n*/\ns32 FirmwareDownloadBT(PADAPTER padapter, PRT_MP_FIRMWARE pFirmware)\n{\n\ts32 rtStatus;\n\tu8 *pBTFirmwareBuf;\n\tu32 BTFirmwareLen;\n\tu8 download_time;\n\ts8 i;\n\n\n\trtStatus = _SUCCESS;\n\tpBTFirmwareBuf = NULL;\n\tBTFirmwareLen = 0;\n\n\t//\n\t// Patch BT Fw. Download BT RAM code to Tx packet buffer.\n\t//\n\tif (padapter->bBTFWReady) {\n\t\tDBG_8192C(\"%s: BT Firmware is ready!!\\n\", __FUNCTION__);\n\t\treturn _FAIL;\n\t}\n\n#ifdef CONFIG_FILE_FWIMG\n\tif (rtw_is_file_readable(rtw_fw_mp_bt_file_path) == _TRUE)\n\t{\n\t\tDBG_8192C(\"%s: accquire MP BT FW from file:%s\\n\", __FUNCTION__, rtw_fw_mp_bt_file_path);\n\n\t\trtStatus = rtw_retrive_from_file(rtw_fw_mp_bt_file_path, FwBuffer, FW_8723B_SIZE);\n\t\tBTFirmwareLen = rtStatus>=0?rtStatus:0;\n\t\tpBTFirmwareBuf = FwBuffer;\n\t}\n\telse\n#endif // CONFIG_FILE_FWIMG\n\t{\n#ifdef CONFIG_EMBEDDED_FWIMG\n\t\tDBG_8192C(\"%s: Download MP BT FW from header\\n\", __FUNCTION__);\n\n\t\tpBTFirmwareBuf = (u8*)Rtl8723BFwBTImgArray;\n\t\tBTFirmwareLen = Rtl8723BFwBTImgArrayLength;\n\t\tpFirmware->szFwBuffer = pBTFirmwareBuf;\n\t\tpFirmware->ulFwLength = BTFirmwareLen;\n#endif // CONFIG_EMBEDDED_FWIMG\n\t}\n\n\tDBG_8192C(\"%s: MP BT Firmware size=%d\\n\", __FUNCTION__, BTFirmwareLen);\n\n\t// for h2c cam here should be set to  true\n\tpadapter->bFWReady = _TRUE;\n\n\tdownload_time = (BTFirmwareLen + 4095) / 4096;\n\tDBG_8192C(\"%s: download_time is %d\\n\", __FUNCTION__, download_time);\n\n\t// Download BT patch Fw.\n\tfor (i = (download_time-1); i >= 0; i--)\n\t{\n\t\tif (i == (download_time - 1))\n\t\t{\n\t\t\trtStatus = _WriteBTFWtoTxPktBuf8723B(padapter, pBTFirmwareBuf+(4096*i), (BTFirmwareLen-(4096*i)), 1);\n\t\t\tDBG_8192C(\"%s: start %d, len %d, time 1\\n\", __FUNCTION__, 4096*i, BTFirmwareLen-(4096*i));\n\t\t}\n\t\telse\n\t\t{\n\t\t\trtStatus = _WriteBTFWtoTxPktBuf8723B(padapter, pBTFirmwareBuf+(4096*i), 4096, (download_time-i));\n\t\t\tDBG_8192C(\"%s: start %d, len 4096, time %d\\n\", __FUNCTION__, 4096*i, download_time-i);\n\t\t}\n\n\t\tif (rtStatus != _SUCCESS)\n\t\t{\n\t\t\tDBG_8192C(\"%s: BT Firmware download to Tx packet buffer fail!\\n\", __FUNCTION__);\n\t\t\tpadapter->bBTFWReady = _FALSE;\n\t\t\treturn rtStatus;\n\t\t}\n\t}\n\n\tReservedPage_Compare(padapter,pFirmware,BTFirmwareLen);\n\n\tpadapter->bBTFWReady = _TRUE;\n\tSetFwBTFwPatchCmd(padapter, (u16)BTFirmwareLen);\n\trtStatus = _CheckWLANFwPatchBTFwReady(padapter);\n\n\tDBG_8192C(\"<===%s: return %s!\\n\", __FUNCTION__, rtStatus==_SUCCESS?\"SUCCESS\":\"FAIL\");\n\treturn rtStatus;\n}\n#endif // CONFIG_MP_INCLUDED\n\n//\n//\tDescription:\n//\t\tDownload 8192C firmware code.\n//\n//\ns32 rtl8723b_FirmwareDownload(PADAPTER padapter, BOOLEAN  bUsedWoWLANFw)\n{\n\ts32\trtStatus = _SUCCESS;\n\tu8 write_fw = 0;\n\tu32 fwdl_start_time;\n\tPHAL_DATA_TYPE\tpHalData = GET_HAL_DATA(padapter);\n\ts8 \t\t\tR8723BFwImageFileName[] ={RTL8723B_FW_IMG};\n\tu8\t\t\t*FwImage;\n\tu32\t\t\tFwImageLen;\n\tu8\t\t\t*pFwImageFileName;\n#ifdef CONFIG_WOWLAN\n\tu8\t\t\t*FwImageWoWLAN;\n\tu32\t\t\tFwImageWoWLANLen;\n#endif\t\n\tu8\t\t\t*pucMappedFile = NULL;\n\tPRT_FIRMWARE_8723B\tpFirmware = NULL;\n\tPRT_FIRMWARE_8723B\tpBTFirmware = NULL;\n\tPRT_8723B_FIRMWARE_HDR\t\tpFwHdr = NULL;\n\tu8\t\t\t*pFirmwareBuf;\n\tu32\t\t\tFirmwareLen;\n#ifdef CONFIG_FILE_FWIMG\n\tu8 *fwfilepath;\n#endif // CONFIG_FILE_FWIMG\n\tstruct dvobj_priv *psdpriv = padapter->dvobj;\n\tstruct debug_priv *pdbgpriv = &psdpriv->drv_dbg;\n\tstruct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(padapter);\n\n\tRT_TRACE(_module_hal_init_c_, _drv_info_, (\"+%s\\n\", __FUNCTION__));\n#ifdef CONFIG_WOWLAN\n\tRT_TRACE(_module_hal_init_c_, _drv_notice_, (\"+%s, bUsedWoWLANFw:%d\\n\", __FUNCTION__,bUsedWoWLANFw));\n#endif\n\tpFirmware = (PRT_FIRMWARE_8723B)rtw_zmalloc(sizeof(RT_FIRMWARE_8723B));\n\n\tif(!pFirmware)\n\t{\n\t\trtStatus = _FAIL;\n\t\tgoto exit;\n\t}\n\n\t{\n\t\t\tu8 tmp_ps=0, tmp_rf=0;\n\t\t\ttmp_ps=rtw_read8(padapter,0xa3);\n\t\t\ttmp_ps&=0xf8;\n\t\t\ttmp_ps|=0x02;\n\t\t\t//1. write 0xA3[:2:0] = 3b'010\n\t\t\trtw_write8(padapter, 0xa3, tmp_ps);\n\t\t\t//2. read power_state = 0xA0[1:0]\n\t\t\ttmp_ps=rtw_read8(padapter,0xa0);\n\t\t\ttmp_ps&=0x03;\n\t\t\tif(tmp_ps != 0x01)\n\t\t\t{\n\t\t\t\tDBG_871X(FUNC_ADPT_FMT\" tmp_ps=%x \\n\",FUNC_ADPT_ARG(padapter), tmp_ps);\n\t\t\t\tpdbgpriv->dbg_downloadfw_pwr_state_cnt++;\n\t\t\t}\n\t}\n\n\trtw_btcoex_PreLoadFirmware(padapter);\n\t\n#ifdef CONFIG_FILE_FWIMG\n#ifdef CONFIG_WOWLAN\n\tif (bUsedWoWLANFw)\n\t{\n\t\tfwfilepath = rtw_fw_wow_file_path;\n\t}\n\telse\n#endif // CONFIG_WOWLAN\n\t{\n\t\tfwfilepath = rtw_fw_file_path;\n\t}\n#endif // CONFIG_FILE_FWIMG\n\n#ifdef CONFIG_FILE_FWIMG\n\tif (rtw_is_file_readable(fwfilepath) == _TRUE)\n\t{\n\t\tDBG_8192C(\"%s accquire FW from file:%s\\n\", __FUNCTION__, fwfilepath);\n\t\tpFirmware->eFWSource = FW_SOURCE_IMG_FILE;\n\t}\n\telse\n#endif // CONFIG_FILE_FWIMG\n\t{\n#ifdef CONFIG_EMBEDDED_FWIMG\n\t\tpFirmware->eFWSource = FW_SOURCE_HEADER_FILE;\n#else // !CONFIG_EMBEDDED_FWIMG\n\t\tpFirmware->eFWSource = FW_SOURCE_IMG_FILE; // We should decided by Reg.\n#endif // !CONFIG_EMBEDDED_FWIMG\n\t}\n\n\tswitch(pFirmware->eFWSource)\n\t{\n\t\tcase FW_SOURCE_IMG_FILE:\n#ifdef CONFIG_FILE_FWIMG\n\t\t\trtStatus = rtw_retrive_from_file(fwfilepath, FwBuffer, FW_8723B_SIZE);\n\t\t\tpFirmware->ulFwLength = rtStatus>=0?rtStatus:0;\n\t\t\tpFirmware->szFwBuffer = FwBuffer;\n#endif // CONFIG_FILE_FWIMG\n\t\t\tbreak;\n\n\t\tcase FW_SOURCE_HEADER_FILE:\n#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)\n\t\tif (bUsedWoWLANFw) {\n\t\t\tif (!pwrpriv->wowlan_ap_mode) {\n\t\t\t\tODM_ConfigFWWithHeaderFile(&pHalData->odmpriv,\n\t\t\t\t\t\tCONFIG_FW_WoWLAN,\n\t\t\t\t\t\t(u8*)&pFirmware->szFwBuffer,\n\t\t\t\t\t\t&pFirmware->ulFwLength);\n\n\t\t\t\tDBG_8192C(\" ===> %s fw: %s, size: %d\\n\",\n\t\t\t\t\t\t__FUNCTION__, \"WoWLAN\",\n\t\t\t\t\t\tpFirmware->ulFwLength);\n\t\t\t} else {\n\t\t\t\tODM_ConfigFWWithHeaderFile(&pHalData->odmpriv,\n\t\t\t\t\t\tCONFIG_FW_AP_WoWLAN,\n\t\t\t\t\t\t(u8*)&pFirmware->szFwBuffer,\n\t\t\t\t\t\t&pFirmware->ulFwLength);\n\n\t\t\t\tDBG_8192C(\" ===> %s fw: %s, size: %d\\n\",\n\t\t\t\t\t\t__FUNCTION__, \"AP_WoWLAN\",\n\t\t\t\t\t\tpFirmware->ulFwLength);\n\t\t\t}\n\t\t} else\n#endif // CONFIG_WOWLAN\n\t\t\t{\n\t\t\t\tif(padapter->registrypriv.mp_mode ==0)\n\t\t\t\t{\n\t \t\t\t\tODM_ConfigFWWithHeaderFile(&pHalData->odmpriv, CONFIG_FW_NIC,\n\t\t\t\t\t\t(u8*)&pFirmware->szFwBuffer, &pFirmware->ulFwLength);\n\t\t \t\t\tDBG_8192C(\"%s fw: %s, size: %d\\n\", __FUNCTION__, \"FW_NIC\", pFirmware->ulFwLength);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tODM_ConfigFWWithHeaderFile(&pHalData->odmpriv, CONFIG_FW_MP,\n\t\t\t\t\t\t(u8*)&pFirmware->szFwBuffer, &pFirmware->ulFwLength);\n\t\t \t\t\tDBG_8192C(\"%s fw: %s, size: %d\\n\", __FUNCTION__, \"FW_MP\", pFirmware->ulFwLength);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n\n\tif (pFirmware->ulFwLength > FW_8723B_SIZE) {\n\t\trtStatus = _FAIL;\n\t\tDBG_871X_LEVEL(_drv_emerg_, \"Firmware size:%u exceed %u\\n\", pFirmware->ulFwLength, FW_8723B_SIZE);\n\t\tgoto exit;\n\t}\n\n\tpFirmwareBuf = pFirmware->szFwBuffer;\n\tFirmwareLen = pFirmware->ulFwLength;\n\n\t// To Check Fw header. Added by tynli. 2009.12.04.\n\tpFwHdr = (PRT_8723B_FIRMWARE_HDR)pFirmwareBuf;\n\n\tpHalData->FirmwareVersion =  le16_to_cpu(pFwHdr->Version);\n\tpHalData->FirmwareSubVersion = le16_to_cpu(pFwHdr->Subversion);\n\tpHalData->FirmwareSignature = le16_to_cpu(pFwHdr->Signature);\n\n\tDBG_871X(\"%s: fw_ver=%x fw_subver=%04x sig=0x%x, Month=%02x, Date=%02x, Hour=%02x, Minute=%02x\\n\",\n\t\t  __FUNCTION__, pHalData->FirmwareVersion, pHalData->FirmwareSubVersion, pHalData->FirmwareSignature\n\t\t  ,pFwHdr->Month,pFwHdr->Date,pFwHdr->Hour,pFwHdr->Minute);\n\n\tif (IS_FW_HEADER_EXIST_8723B(pFwHdr))\n\t{\n\t\tDBG_871X(\"%s(): Shift for fw header!\\n\", __func__);\n\t\t// Shift 32 bytes for FW header\n\t\tpFirmwareBuf = pFirmwareBuf + 32;\n\t\tFirmwareLen = FirmwareLen - 32;\n\t}\n\n\t// Suggested by Filen. If 8051 is running in RAM code, driver should inform Fw to reset by itself,\n\t// or it will cause download Fw fail. 2010.02.01. by tynli.\n\tif (rtw_read8(padapter, REG_MCUFWDL) & RAM_DL_SEL) //8051 RAM code\n\t{\n\t\trtw_write8(padapter, REG_MCUFWDL, 0x00);\n\t\trtl8723b_FirmwareSelfReset(padapter);\n\t}\n\n\t_FWDownloadEnable(padapter, _TRUE);\n\tfwdl_start_time = rtw_get_current_time();\n\twhile(!padapter->bDriverStopped && !padapter->bSurpriseRemoved\n\t\t\t&& (write_fw++ < 3 || rtw_get_passing_time_ms(fwdl_start_time) < 500))\n\t{\n\t\t/* reset FWDL chksum */\n\t\trtw_write8(padapter, REG_MCUFWDL, rtw_read8(padapter, REG_MCUFWDL)|FWDL_ChkSum_rpt);\n\n\t\trtStatus = _WriteFW(padapter, pFirmwareBuf, FirmwareLen);\n\t\tif (rtStatus != _SUCCESS)\n\t\t\tcontinue;\n\n\t\trtStatus = polling_fwdl_chksum(padapter, 5, 50);\n\t\tif (rtStatus == _SUCCESS)\n\t\t\tbreak;\n\t}\n\t_FWDownloadEnable(padapter, _FALSE);\n\tif(_SUCCESS != rtStatus)\n\t\tgoto fwdl_stat;\n\n\trtStatus = _FWFreeToGo(padapter, 10, 200);\n\tif (_SUCCESS != rtStatus)\n\t\tgoto fwdl_stat;\n\n#ifdef CONFIG_MP_INCLUDED//BT_MP\n\tif (padapter->registrypriv.mp_mode == 1)\n\t{\n\t\t//rtw_write8(padapter, 0x81, rtw_read8(padapter, 0x81)|BIT0);\n\t\tDBG_871X(\"rtl8723b_FirmwareDownload go to FirmwareDownloadBT !\\n\");\n\t\tpBTFirmware = (PRT_FIRMWARE_8723B)rtw_zmalloc(sizeof(RT_FIRMWARE_8723B));\n\t\tif(!pBTFirmware)\n\t\t{\n\t\t\trtStatus = _FAIL;\n\t\t\tgoto exit;\n\t\t}\n\t\tFirmwareDownloadBT(padapter, (PRT_MP_FIRMWARE)pBTFirmware);\n\t}\n#endif\n\nfwdl_stat:\n\tDBG_871X(\"FWDL %s. write_fw:%u, %dms\\n\"\n\t\t, (rtStatus == _SUCCESS)?\"success\":\"fail\"\n\t\t, write_fw\n\t\t, rtw_get_passing_time_ms(fwdl_start_time)\n\t);\n\nexit:\n\tif (pFirmware)\n\t\trtw_mfree((u8*)pFirmware, sizeof(RT_FIRMWARE_8723B));\n\tif (pBTFirmware)\n\t\trtw_mfree((u8*)pBTFirmware, sizeof(RT_FIRMWARE_8723B));\n\tDBG_871X(\" <=== rtl8723b_FirmwareDownload()\\n\");\n\treturn rtStatus;\n}\n\nvoid rtl8723b_InitializeFirmwareVars(PADAPTER padapter)\n{\n\tPHAL_DATA_TYPE pHalData = GET_HAL_DATA(padapter);\n\n\t// Init Fw LPS related.\n\tadapter_to_pwrctl(padapter)->bFwCurrentInPSMode = _FALSE;\n\n\t//Init H2C cmd.\n\trtw_write8(padapter, REG_HMETFR, 0x0f);\n\t\n\t// Init H2C counter. by tynli. 2009.12.09.\n\tpHalData->LastHMEBoxNum = 0;\n//\tpHalData->H2CQueueHead = 0;\n//\tpHalData->H2CQueueTail = 0;\n//\tpHalData->H2CStopInsertQueue = _FALSE;\n}\n\n#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)\n//===========================================\n\n//\n// Description: Prepare some information to Fw for WoWLAN.\n//\t\t\t\t\t(1) Download wowlan Fw.\n//\t\t\t\t\t(2) Download RSVD page packets.\n//\t\t\t\t\t(3) Enable AP offload if needed.\n//\n// 2011.04.12 by tynli.\n//\nVOID\nSetFwRelatedForWoWLAN8723b(\n\t\tIN\t\tPADAPTER\t\t\tpadapter,\n\t\tIN\t\tu8\t\t\t\t\tbHostIsGoingtoSleep\n)\n{\n\t\tint\t\t\t\tstatus=_FAIL;\n\t\tHAL_DATA_TYPE\t*pHalData = GET_HAL_DATA(padapter);\n\t\tu8\t\t\t\tbRecover = _FALSE;\n\t//\n\t// 1. Before WoWLAN we need to re-download WoWLAN Fw.\n\t//\n\tstatus = rtl8723b_FirmwareDownload(padapter, bHostIsGoingtoSleep);\n\tif(status != _SUCCESS) {\n\t\tDBG_871X(\"SetFwRelatedForWoWLAN8723b(): Re-Download Firmware failed!!\\n\");\n\t\treturn;\n\t} else {\n\t\tDBG_871X(\"SetFwRelatedForWoWLAN8723b(): Re-Download Firmware Success !!\\n\");\n\t}\n\t//\n\t// 2. Re-Init the variables about Fw related setting.\n\t//\n\trtl8723b_InitializeFirmwareVars(padapter);\n}\n#endif //CONFIG_WOWLAN\n\n//===========================================================\n//\t\t\t\tEfuse related code\n//===========================================================\nstatic u8\nhal_EfuseSwitchToBank(\n\tPADAPTER\tpadapter,\n\tu8\t\t\tbank,\n\tu8\t\t\tbPseudoTest)\n{\n\tu8 bRet = _FALSE;\n\tu32 value32 = 0;\n#ifdef HAL_EFUSE_MEMORY\n\tPHAL_DATA_TYPE pHalData = GET_HAL_DATA(padapter);\n\tPEFUSE_HAL pEfuseHal = &pHalData->EfuseHal;\n#endif\n\n\n\tDBG_8192C(\"%s: Efuse switch bank to %d\\n\", __FUNCTION__, bank);\n\tif (bPseudoTest)\n\t{\n#ifdef HAL_EFUSE_MEMORY\n\t\tpEfuseHal->fakeEfuseBank = bank;\n#else\n\t\tfakeEfuseBank = bank;\n#endif\n\t\tbRet = _TRUE;\n\t}\n\telse\n\t{\n\t\tvalue32 = rtw_read32(padapter, EFUSE_TEST);\n\t\tbRet = _TRUE;\n\t\tswitch (bank)\n\t\t{\n\t\t\tcase 0:\n\t\t\t\tvalue32 = (value32 & ~EFUSE_SEL_MASK) | EFUSE_SEL(EFUSE_WIFI_SEL_0);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tvalue32 = (value32 & ~EFUSE_SEL_MASK) | EFUSE_SEL(EFUSE_BT_SEL_0);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tvalue32 = (value32 & ~EFUSE_SEL_MASK) | EFUSE_SEL(EFUSE_BT_SEL_1);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tvalue32 = (value32 & ~EFUSE_SEL_MASK) | EFUSE_SEL(EFUSE_BT_SEL_2);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tvalue32 = (value32 & ~EFUSE_SEL_MASK) | EFUSE_SEL(EFUSE_WIFI_SEL_0);\n\t\t\t\tbRet = _FALSE;\n\t\t\t\tbreak;\n\t\t}\n\t\trtw_write32(padapter, EFUSE_TEST, value32);\n\t}\n\n\treturn bRet;\n}\n\nstatic void\nHal_GetEfuseDefinition(\n\tPADAPTER\tpadapter,\n\tu8\t\t\tefuseType,\n\tu8\t\t\ttype,\n\tvoid\t\t*pOut,\n\tu8\t\t\tbPseudoTest)\n{\n\tswitch (type)\n\t{\n\t\tcase TYPE_EFUSE_MAX_SECTION:\n\t\t\t{\n\t\t\t\tu8 *pMax_section;\n\t\t\t\tpMax_section = (u8*)pOut;\n\n\t\t\t\tif (efuseType == EFUSE_WIFI)\n\t\t\t\t\t*pMax_section = EFUSE_MAX_SECTION_8723B;\n\t\t\t\telse\n\t\t\t\t\t*pMax_section = EFUSE_BT_MAX_SECTION;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TYPE_EFUSE_REAL_CONTENT_LEN:\n\t\t\t{\n\t\t\t\tu16 *pu2Tmp;\n\t\t\t\tpu2Tmp = (u16*)pOut;\n\n\t\t\t\tif (efuseType == EFUSE_WIFI)\n\t\t\t\t\t*pu2Tmp = EFUSE_REAL_CONTENT_LEN_8723B;\n\t\t\t\telse\n\t\t\t\t\t*pu2Tmp = EFUSE_BT_REAL_CONTENT_LEN;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TYPE_AVAILABLE_EFUSE_BYTES_BANK:\n\t\t\t{\n\t\t\t\tu16\t*pu2Tmp;\n\t\t\t\tpu2Tmp = (u16*)pOut;\n\n\t\t\t\tif (efuseType == EFUSE_WIFI)\n\t\t\t\t\t*pu2Tmp = (EFUSE_REAL_CONTENT_LEN_8723B-EFUSE_OOB_PROTECT_BYTES);\n\t\t\t\telse\n\t\t\t\t\t*pu2Tmp = (EFUSE_BT_REAL_BANK_CONTENT_LEN-EFUSE_PROTECT_BYTES_BANK);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TYPE_AVAILABLE_EFUSE_BYTES_TOTAL:\n\t\t\t{\n\t\t\t\tu16 *pu2Tmp;\n\t\t\t\tpu2Tmp = (u16*)pOut;\n\n\t\t\t\tif (efuseType == EFUSE_WIFI)\n\t\t\t\t\t*pu2Tmp = (EFUSE_REAL_CONTENT_LEN_8723B-EFUSE_OOB_PROTECT_BYTES);\n\t\t\t\telse\n\t\t\t\t\t*pu2Tmp = (EFUSE_BT_REAL_CONTENT_LEN-(EFUSE_PROTECT_BYTES_BANK*3));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TYPE_EFUSE_MAP_LEN:\n\t\t\t{\n\t\t\t\tu16 *pu2Tmp;\n\t\t\t\tpu2Tmp = (u16*)pOut;\n\n\t\t\t\tif (efuseType == EFUSE_WIFI)\n\t\t\t\t\t*pu2Tmp = EFUSE_MAX_MAP_LEN;\n\t\t\t\telse\n\t\t\t\t\t*pu2Tmp = EFUSE_BT_MAP_LEN;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TYPE_EFUSE_PROTECT_BYTES_BANK:\n\t\t\t{\n\t\t\t\tu8 *pu1Tmp;\n\t\t\t\tpu1Tmp = (u8*)pOut;\n\n\t\t\t\tif (efuseType == EFUSE_WIFI)\n\t\t\t\t\t*pu1Tmp = EFUSE_OOB_PROTECT_BYTES;\n\t\t\t\telse\n\t\t\t\t\t*pu1Tmp = EFUSE_PROTECT_BYTES_BANK;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TYPE_EFUSE_CONTENT_LEN_BANK:\n\t\t\t{\n\t\t\t\tu16 *pu2Tmp;\n\t\t\t\tpu2Tmp = (u16*)pOut;\n\n\t\t\t\tif (efuseType == EFUSE_WIFI)\n\t\t\t\t\t*pu2Tmp = EFUSE_REAL_CONTENT_LEN_8723B;\n\t\t\t\telse\n\t\t\t\t\t*pu2Tmp = EFUSE_BT_REAL_BANK_CONTENT_LEN;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t{\n\t\t\t\tu8 *pu1Tmp;\n\t\t\t\tpu1Tmp = (u8*)pOut;\n\t\t\t\t*pu1Tmp = 0;\n\t\t\t}\n\t\t\tbreak;\n\t}\n}\n\n#define VOLTAGE_V25\t\t0x03\n#define LDOE25_SHIFT\t28\n\n//=================================================================\n//\tThe following is for compile ok\n//\tThat should be merged with the original in the future\n//=================================================================\n#define EFUSE_ACCESS_ON_8723\t\t\t0x69\t// For RTL8723 only.\n#define EFUSE_ACCESS_OFF_8723\t\t\t0x00\t// For RTL8723 only.\n#define REG_EFUSE_ACCESS_8723\t\t\t0x00CF\t// Efuse access protection for RTL8723\n\n//=================================================================\nstatic void Hal_BT_EfusePowerSwitch(\n\tPADAPTER\tpadapter,\n\tu8\t\t\tbWrite,\n\tu8\t\t\tPwrState)\n{\n\tu8 tempval;\n\tif (PwrState == _TRUE)\n\t{\n\t\t// enable BT power cut\n\t\t// 0x6A[14] = 1\n\t\ttempval = rtw_read8(padapter, 0x6B);\n\t\ttempval |= BIT(6);\n\t\trtw_write8(padapter, 0x6B, tempval);\n\t\t\n\t\t// Attention!! Between 0x6A[14] and 0x6A[15] setting need 100us delay\n\t\t// So don't wirte 0x6A[14]=1 and 0x6A[15]=0 together!\n\t\trtw_usleep_os(100);\n\t\t// disable BT output isolation\n\t\t// 0x6A[15] = 0\n\t\ttempval = rtw_read8(padapter, 0x6B);\n\t\ttempval &= ~BIT(7);\n\t\trtw_write8(padapter, 0x6B, tempval);\n\t}\n\telse\n\t{\n\t\t// enable BT output isolation\n\t\t// 0x6A[15] = 1\n\t\ttempval = rtw_read8(padapter, 0x6B);\n\t\ttempval |= BIT(7);\n\t\trtw_write8(padapter, 0x6B, tempval);\n\n\t\t// Attention!! Between 0x6A[14] and 0x6A[15] setting need 100us delay\n\t\t// So don't wirte 0x6A[14]=1 and 0x6A[15]=0 together!\n\n\t\t// disable BT power cut\n\t\t// 0x6A[14] = 1\n\t\ttempval = rtw_read8(padapter, 0x6B);\n\t\ttempval &= ~BIT(6);\n\t\trtw_write8(padapter, 0x6B, tempval);\n\t}\n\n}\nstatic void\nHal_EfusePowerSwitch(\n\tPADAPTER\tpadapter,\n\tu8\t\t\tbWrite,\n\tu8\t\t\tPwrState)\n{\n\tu8\ttempval;\n\tu16\ttmpV16;\n\n\n\tif (PwrState == _TRUE)\n\t{\n#ifdef CONFIG_SDIO_HCI\n\t\t// To avoid cannot access efuse regsiters after disable/enable several times during DTM test. \n\t\t// Suggested by SD1 IsaacHsu. 2013.07.08, added by tynli. \n\t\ttempval = rtw_read8(padapter, SDIO_LOCAL_BASE|SDIO_REG_HSUS_CTRL);\n\t\tif (tempval & BIT(0)) // SDIO local register is suspend\n\t\t{\n\t\t\tu8 count = 0;\n\n\n\t\t\ttempval &= ~BIT(0);\n\t\t\trtw_write8(padapter, SDIO_LOCAL_BASE|SDIO_REG_HSUS_CTRL, tempval);\n\n\t\t\t// check 0x86[1:0]=10'2h, wait power state to leave suspend\n \t\t\tdo {\n\t\t\t\ttempval = rtw_read8(padapter, SDIO_LOCAL_BASE|SDIO_REG_HSUS_CTRL);\n\t\t\t\ttempval &= 0x3;\n\t\t\t\tif (tempval == 0x02)\n\t\t\t\t\tbreak;\n\n\t\t\t\tcount++;\n\t\t\t\tif (count >= 100)\n\t\t\t\t\tbreak;\n\n\t\t\t\trtw_mdelay_os(10);\n\t\t\t} while (1);\n\n\t\t\tif (count >= 100)\n\t\t\t{\n\t\t\t\tDBG_8192C(FUNC_ADPT_FMT \": Leave SDIO local register suspend fail! Local 0x86=%#X\\n\",\n\t\t\t\t\tFUNC_ADPT_ARG(padapter), tempval);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDBG_8192C(FUNC_ADPT_FMT \": Leave SDIO local register suspend OK! Local 0x86=%#X\\n\",\n\t\t\t\t\tFUNC_ADPT_ARG(padapter), tempval);\n\t\t}\n\t\t}\n#endif // CONFIG_SDIO_HCI\n\n\t\trtw_write8(padapter, REG_EFUSE_ACCESS_8723, EFUSE_ACCESS_ON_8723);\t\n\n\t\t// Reset: 0x0000h[28], default valid\n\t\ttmpV16 =  rtw_read16(padapter, REG_SYS_FUNC_EN);\n\t\tif (!(tmpV16 & FEN_ELDR)) {\n\t\t\ttmpV16 |= FEN_ELDR ;\n\t\t\trtw_write16(padapter, REG_SYS_FUNC_EN, tmpV16);\n\t\t}\n\n\t\t// Clock: Gated(0x0008h[5]) 8M(0x0008h[1]) clock from ANA, default valid\n\t\ttmpV16 = rtw_read16(padapter, REG_SYS_CLKR);\n\t\tif ((!(tmpV16 & LOADER_CLK_EN))  || (!(tmpV16 & ANA8M))) {\n\t\t\ttmpV16 |= (LOADER_CLK_EN | ANA8M) ;\n\t\t\trtw_write16(padapter, REG_SYS_CLKR, tmpV16);\n\t\t}\n\n\t\tif (bWrite == _TRUE)\n\t\t{\n\t\t\t// Enable LDO 2.5V before read/write action\n\t\t\ttempval = rtw_read8(padapter, EFUSE_TEST+3);\n\t\t\ttempval &= 0x0F;\n\t\t\ttempval |= (VOLTAGE_V25 << 4);\n\t\t\trtw_write8(padapter, EFUSE_TEST+3, (tempval | 0x80));\n\n\t\t\t//rtw_write8(padapter, REG_EFUSE_ACCESS, EFUSE_ACCESS_ON);\n\t\t}\n\t}\n\telse\n\t{\n\t\trtw_write8(padapter, REG_EFUSE_ACCESS, EFUSE_ACCESS_OFF);\n\n\t\tif (bWrite == _TRUE) {\n\t\t\t// Disable LDO 2.5V after read/write action\n\t\t\ttempval = rtw_read8(padapter, EFUSE_TEST+3);\n\t\t\trtw_write8(padapter, EFUSE_TEST+3, (tempval & 0x7F));\n\t\t}\n\n\t}\n}\n\nstatic void\nhal_ReadEFuse_WiFi(\n\tPADAPTER\tpadapter,\n\tu16\t\t\t_offset,\n\tu16\t\t\t_size_byte,\n\tu8\t\t\t*pbuf,\n\tu8\t\t\tbPseudoTest)\n{\n#ifdef HAL_EFUSE_MEMORY\n\tPHAL_DATA_TYPE\tpHalData = GET_HAL_DATA(padapter);\n\tPEFUSE_HAL\t\tpEfuseHal = &pHalData->EfuseHal;\n#endif\n\tu8\t*efuseTbl = NULL;\n\tu16\teFuse_Addr=0;\n\tu8\toffset, wden;\n\tu8\tefuseHeader, efuseExtHdr, efuseData;\n\tu16\ti, total, used;\n\tu8\tefuse_usage = 0;\n\n\t//DBG_871X(\"YJ: ====>%s():_offset=%d _size_byte=%d bPseudoTest=%d\\n\", __func__, _offset, _size_byte, bPseudoTest);\n\t//\n\t// Do NOT excess total size of EFuse table. Added by Roger, 2008.11.10.\n\t//\n\tif ((_offset+_size_byte) > EFUSE_MAX_MAP_LEN)\n\t{\n\t\tDBG_8192C(\"%s: Invalid offset(%#x) with read bytes(%#x)!!\\n\", __FUNCTION__, _offset, _size_byte);\n\t\treturn;\n\t}\n\n\tefuseTbl = (u8*)rtw_malloc(EFUSE_MAX_MAP_LEN);\n\tif (efuseTbl == NULL)\n\t{\n\t\tDBG_8192C(\"%s: alloc efuseTbl fail!\\n\", __FUNCTION__);\n\t\treturn;\n\t}\n\t// 0xff will be efuse default value instead of 0x00.\n\t_rtw_memset(efuseTbl, 0xFF, EFUSE_MAX_MAP_LEN);\n\n\n#ifdef CONFIG_DEBUG\nif(0)\n{\n\tfor(i=0; i<256; i++)\n\t\t//ReadEFuseByte(padapter, i, &efuseTbl[i], _FALSE);\n\t\tefuse_OneByteRead(padapter, i, &efuseTbl[i], _FALSE);\n\tDBG_871X(\"Efuse Content:\\n\");\n\tfor(i=0; i<256; i++)\n\t{\n\t\tif (i % 16 == 0)\n\t\t\tprintk(\"\\n\");\n\t\tprintk(\"%02X \", efuseTbl[i]);\n\t}\n\tprintk(\"\\n\");\n}\n#endif\n\n\n\t// switch bank back to bank 0 for later BT and wifi use.\n\thal_EfuseSwitchToBank(padapter, 0, bPseudoTest);\n\n\twhile (AVAILABLE_EFUSE_ADDR(eFuse_Addr))\n\t{\n\t\t//ReadEFuseByte(padapter, eFuse_Addr++, &efuseHeader, bPseudoTest);\n\t\tefuse_OneByteRead(padapter, eFuse_Addr++, &efuseHeader, bPseudoTest);\n\t\tif (efuseHeader == 0xFF)\n\t\t{\n\t\t\tDBG_8192C(\"%s: data end at address=%#x\\n\", __FUNCTION__, eFuse_Addr-1);\n\t\t\tbreak;\n\t\t}\n\t\t//DBG_8192C(\"%s: efuse[0x%X]=0x%02X\\n\", __FUNCTION__, eFuse_Addr-1, efuseHeader);\n\n\t\t// Check PG header for section num.\n\t\tif (EXT_HEADER(efuseHeader))\t\t//extended header\n\t\t{\n\t\t\toffset = GET_HDR_OFFSET_2_0(efuseHeader);\n\t\t\t//DBG_8192C(\"%s: extended header offset=0x%X\\n\", __FUNCTION__, offset);\n\n\t\t\t//ReadEFuseByte(padapter, eFuse_Addr++, &efuseExtHdr, bPseudoTest);\n\t\t\tefuse_OneByteRead(padapter, eFuse_Addr++, &efuseExtHdr, bPseudoTest);\n\t\t\t//DBG_8192C(\"%s: efuse[0x%X]=0x%02X\\n\", __FUNCTION__, eFuse_Addr-1, efuseExtHdr);\n\t\t\tif (ALL_WORDS_DISABLED(efuseExtHdr))\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toffset |= ((efuseExtHdr & 0xF0) >> 1);\n\t\t\twden = (efuseExtHdr & 0x0F);\n\t\t}\n\t\telse\n\t\t{\n\t\t\toffset = ((efuseHeader >> 4) & 0x0f);\n\t\t\twden = (efuseHeader & 0x0f);\n\t\t}\n\t\t//DBG_8192C(\"%s: Offset=%d Worden=0x%X\\n\", __FUNCTION__, offset, wden);\n\n\t\tif (offset < EFUSE_MAX_SECTION_8723B)\n\t\t{\n\t\t\tu16 addr;\n\t\t\t// Get word enable value from PG header\n//\t\t\tDBG_8192C(\"%s: Offset=%d Worden=0x%X\\n\", __FUNCTION__, offset, wden);\n\n\t\t\taddr = offset * PGPKT_DATA_SIZE;\n\t\t\tfor (i=0; i<EFUSE_MAX_WORD_UNIT; i++)\n\t\t\t{\n\t\t\t\t// Check word enable condition in the section\n\t\t\t\tif (!(wden & (0x01<<i)))\n\t\t\t\t{\n\t\t\t\t\tefuseData = 0;\n\t\t\t\t\t//ReadEFuseByte(padapter, eFuse_Addr++, &efuseData, bPseudoTest);\n\t\t\t\t\tefuse_OneByteRead(padapter, eFuse_Addr++, &efuseData, bPseudoTest);\n//\t\t\t\t\tDBG_8192C(\"%s: efuse[%#X]=0x%02X\\n\", __FUNCTION__, eFuse_Addr-1, efuseData);\n\t\t\t\t\tefuseTbl[addr] = efuseData;\n\n\t\t\t\t\tefuseData = 0;\n\t\t\t\t\t//ReadEFuseByte(padapter, eFuse_Addr++, &efuseData, bPseudoTest);\n\t\t\t\t\tefuse_OneByteRead(padapter, eFuse_Addr++, &efuseData, bPseudoTest);\n//\t\t\t\t\tDBG_8192C(\"%s: efuse[%#X]=0x%02X\\n\", __FUNCTION__, eFuse_Addr-1, efuseData);\n\t\t\t\t\tefuseTbl[addr+1] = efuseData;\n\t\t\t\t}\n\t\t\t\taddr += 2;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDBG_8192C(KERN_ERR \"%s: offset(%d) is illegal!!\\n\", __FUNCTION__, offset);\n\t\t\teFuse_Addr += Efuse_CalculateWordCnts(wden)*2;\n\t\t}\n\t}\n\n\t// Copy from Efuse map to output pointer memory!!!\n\tfor (i=0; i<_size_byte; i++)\n\t\tpbuf[i] = efuseTbl[_offset+i];\n\n#ifdef CONFIG_DEBUG\nif(1)\n{\n\tDBG_871X(\"Efuse Realmap:\\n\");\n\tfor(i=0; i<_size_byte; i++)\n\t{\n\t\tif (i % 16 == 0)\n\t\t\tprintk(\"\\n\");\n\t\tprintk(\"%02X \", pbuf[i]);\n\t}\n\tprintk(\"\\n\");\n}\n#endif\n\t// Calculate Efuse utilization\n\ttotal = 0;\n\tEFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, &total, bPseudoTest);\n\tused = eFuse_Addr - 1;\n\tif (total)\n\t\tefuse_usage = (u8)((used*100)/total);\n\telse\n\t\tefuse_usage = 100;\n\tif (bPseudoTest)\n\t{\n#ifdef HAL_EFUSE_MEMORY\n\t\tpEfuseHal->fakeEfuseUsedBytes = used;\n#else\n\t\tfakeEfuseUsedBytes = used;\n#endif\n\t}\n\telse\n\t{\n\t\trtw_hal_set_hwreg(padapter, HW_VAR_EFUSE_BYTES, (u8*)&used);\n\t\trtw_hal_set_hwreg(padapter, HW_VAR_EFUSE_USAGE, (u8*)&efuse_usage);\n\t}\n\n\tif (efuseTbl)\n\t\trtw_mfree(efuseTbl, EFUSE_MAX_MAP_LEN);\n}\n\nstatic VOID\nhal_ReadEFuse_BT(\n\tPADAPTER\tpadapter,\n\tu16\t\t\t_offset,\n\tu16\t\t\t_size_byte,\n\tu8\t\t\t*pbuf,\n\tu8\t\t\tbPseudoTest\n\t)\n{\n#ifdef HAL_EFUSE_MEMORY\n\tPHAL_DATA_TYPE\tpHalData = GET_HAL_DATA(padapter);\n\tPEFUSE_HAL\t\tpEfuseHal = &pHalData->EfuseHal;\n#endif\n\tu8\t*efuseTbl;\n\tu8\tbank;\n\tu16\teFuse_Addr;\n\tu8\tefuseHeader, efuseExtHdr, efuseData;\n\tu8\toffset, wden;\n\tu16\ti, total, used;\n\tu8\tefuse_usage;\n\n\n\t//\n\t// Do NOT excess total size of EFuse table. Added by Roger, 2008.11.10.\n\t//\n\tif ((_offset+_size_byte) > EFUSE_BT_MAP_LEN)\n\t{\n\t\tDBG_8192C(\"%s: Invalid offset(%#x) with read bytes(%#x)!!\\n\", __FUNCTION__, _offset, _size_byte);\n\t\treturn;\n\t}\n\n\tefuseTbl = rtw_malloc(EFUSE_BT_MAP_LEN);\n\tif (efuseTbl == NULL) {\n\t\tDBG_8192C(\"%s: efuseTbl malloc fail!\\n\", __FUNCTION__);\n\t\treturn;\n\t}\n\t// 0xff will be efuse default value instead of 0x00.\n\t_rtw_memset(efuseTbl, 0xFF, EFUSE_BT_MAP_LEN);\n\n\ttotal = 0;\n\tEFUSE_GetEfuseDefinition(padapter, EFUSE_BT, TYPE_AVAILABLE_EFUSE_BYTES_BANK, &total, bPseudoTest);\n\n\tfor (bank=1; bank<3; bank++) // 8723b Max bake 0~2\n\t{\n\t\tif (hal_EfuseSwitchToBank(padapter, bank, bPseudoTest) == _FALSE)\n\t\t{\n\t\t\tDBG_8192C(\"%s: hal_EfuseSwitchToBank Fail!!\\n\", __FUNCTION__);\n\t\t\tgoto exit;\n\t\t}\n\n\t\teFuse_Addr = 0;\n\n\t\twhile (AVAILABLE_EFUSE_ADDR(eFuse_Addr))\n\t\t{\n\t\t\t//ReadEFuseByte(padapter, eFuse_Addr++, &efuseHeader, bPseudoTest);\n\t\t\tefuse_OneByteRead(padapter, eFuse_Addr++, &efuseHeader, bPseudoTest);\n\t\t\tif (efuseHeader == 0xFF) break;\n\t\t\tDBG_8192C(\"%s: efuse[%#X]=0x%02x (header)\\n\", __FUNCTION__, (((bank-1)*EFUSE_REAL_CONTENT_LEN_8723B)+eFuse_Addr-1), efuseHeader);\n\n\t\t\t// Check PG header for section num.\n\t\t\tif (EXT_HEADER(efuseHeader))\t\t//extended header\n\t\t\t{\n\t\t\t\toffset = GET_HDR_OFFSET_2_0(efuseHeader);\n\t\t\t\tDBG_8192C(\"%s: extended header offset_2_0=0x%X\\n\", __FUNCTION__, offset);\n\n\t\t\t\t//ReadEFuseByte(padapter, eFuse_Addr++, &efuseExtHdr, bPseudoTest);\n\t\t\t\tefuse_OneByteRead(padapter, eFuse_Addr++, &efuseExtHdr, bPseudoTest);\n\t\t\t\tDBG_8192C(\"%s: efuse[%#X]=0x%02x (ext header)\\n\", __FUNCTION__, (((bank-1)*EFUSE_REAL_CONTENT_LEN_8723B)+eFuse_Addr-1), efuseExtHdr);\n\t\t\t\tif (ALL_WORDS_DISABLED(efuseExtHdr))\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\toffset |= ((efuseExtHdr & 0xF0) >> 1);\n\t\t\t\twden = (efuseExtHdr & 0x0F);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\toffset = ((efuseHeader >> 4) & 0x0f);\n\t\t\t\twden = (efuseHeader & 0x0f);\n\t\t\t}\n\n\t\t\tif (offset < EFUSE_BT_MAX_SECTION)\n\t\t\t{\n\t\t\t\tu16 addr;\n\n\t\t\t\t// Get word enable value from PG header\n\t\t\t\tDBG_8192C(\"%s: Offset=%d Worden=%#X\\n\", __FUNCTION__, offset, wden);\n\n\t\t\t\taddr = offset * PGPKT_DATA_SIZE;\n\t\t\t\tfor (i=0; i<EFUSE_MAX_WORD_UNIT; i++)\n\t\t\t\t{\n\t\t\t\t\t// Check word enable condition in the section\n\t\t\t\t\tif (!(wden & (0x01<<i)))\n\t\t\t\t\t{\n\t\t\t\t\t\tefuseData = 0;\n\t\t\t\t\t\t//ReadEFuseByte(padapter, eFuse_Addr++, &efuseData, bPseudoTest);\n\t\t\t\t\t\tefuse_OneByteRead(padapter, eFuse_Addr++, &efuseData, bPseudoTest);\n\t\t\t\t\t\tDBG_8192C(\"%s: efuse[%#X]=0x%02X\\n\", __FUNCTION__, eFuse_Addr-1, efuseData);\n\t\t\t\t\t\tefuseTbl[addr] = efuseData;\n\n\t\t\t\t\t\tefuseData = 0;\n\t\t\t\t\t\t//ReadEFuseByte(padapter, eFuse_Addr++, &efuseData, bPseudoTest);\n\t\t\t\t\t\tefuse_OneByteRead(padapter, eFuse_Addr++, &efuseData, bPseudoTest);\n\t\t\t\t\t\tDBG_8192C(\"%s: efuse[%#X]=0x%02X\\n\", __FUNCTION__, eFuse_Addr-1, efuseData);\n\t\t\t\t\t\tefuseTbl[addr+1] = efuseData;\n\t\t\t\t\t}\n\t\t\t\t\taddr += 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDBG_8192C(\"%s: offset(%d) is illegal!!\\n\", __FUNCTION__, offset);\n\t\t\t\teFuse_Addr += Efuse_CalculateWordCnts(wden)*2;\n\t\t\t}\n\t\t}\n\n\t\tif ((eFuse_Addr-1) < total)\n\t\t{\n\t\t\tDBG_8192C(\"%s: bank(%d) data end at %#x\\n\", __FUNCTION__, bank, eFuse_Addr-1);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// switch bank back to bank 0 for later BT and wifi use.\n\thal_EfuseSwitchToBank(padapter, 0, bPseudoTest);\n\n\t// Copy from Efuse map to output pointer memory!!!\n\tfor (i=0; i<_size_byte; i++)\n\t\tpbuf[i] = efuseTbl[_offset+i];\n\n\t//\n\t// Calculate Efuse utilization.\n\t//\n\tEFUSE_GetEfuseDefinition(padapter, EFUSE_BT, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, &total, bPseudoTest);\n\tused = (EFUSE_BT_REAL_BANK_CONTENT_LEN*(bank-1)) + eFuse_Addr - 1;\n\tDBG_8192C(\"%s: bank(%d) data end at %#x ,used =%d\\n\", __FUNCTION__, bank, eFuse_Addr-1,used);\n\tif (total)\n\t\tefuse_usage = (u8)((used*100)/total);\n\telse\n\t\tefuse_usage = 100;\n\tif (bPseudoTest)\n\t{\n#ifdef HAL_EFUSE_MEMORY\n\t\tpEfuseHal->fakeBTEfuseUsedBytes = used;\n#else\n\t\tfakeBTEfuseUsedBytes = used;\n#endif\n\t}\n\telse\n\t{\n\t\trtw_hal_set_hwreg(padapter, HW_VAR_EFUSE_BT_BYTES, (u8*)&used);\n\t\trtw_hal_set_hwreg(padapter, HW_VAR_EFUSE_BT_USAGE, (u8*)&efuse_usage);\n\t}\n\nexit:\n\tif (efuseTbl)\n\t\trtw_mfree(efuseTbl, EFUSE_BT_MAP_LEN);\n}\n\nstatic void\nHal_ReadEFuse(\n\tPADAPTER\tpadapter,\n\tu8\t\t\tefuseType,\n\tu16\t\t\t_offset,\n\tu16\t\t\t_size_byte,\n\tu8\t\t\t*pbuf,\n\tu8\t\t\tbPseudoTest)\n{\n\tif (efuseType == EFUSE_WIFI)\n\t\thal_ReadEFuse_WiFi(padapter, _offset, _size_byte, pbuf, bPseudoTest);\n\telse\n\t\thal_ReadEFuse_BT(padapter, _offset, _size_byte, pbuf, bPseudoTest);\n}\n\nstatic u16\nhal_EfuseGetCurrentSize_WiFi(\n\tPADAPTER\tpadapter,\n\tu8\t\t\tbPseudoTest)\n{\n#ifdef HAL_EFUSE_MEMORY\n\tPHAL_DATA_TYPE\tpHalData = GET_HAL_DATA(padapter);\n\tPEFUSE_HAL\t\tpEfuseHal = &pHalData->EfuseHal;\n#endif\n\tu16\tefuse_addr=0;\n\tu16 start_addr = 0; // for debug\n\tu8\thoffset=0, hworden=0;\n\tu8\tefuse_data, word_cnts=0;\n\tu32 count = 0; // for debug\n\n\n\tif (bPseudoTest)\n\t{\n#ifdef HAL_EFUSE_MEMORY\n\t\tefuse_addr = (u16)pEfuseHal->fakeEfuseUsedBytes;\n#else\n\t\tefuse_addr = (u16)fakeEfuseUsedBytes;\n#endif\n\t}\n\telse\n\t{\n\t\trtw_hal_get_hwreg(padapter, HW_VAR_EFUSE_BYTES, (u8*)&efuse_addr);\n\t}\n\tstart_addr = efuse_addr;\n\tDBG_8192C(\"%s: start_efuse_addr=0x%X\\n\", __FUNCTION__, efuse_addr);\n\n\t// switch bank back to bank 0 for later BT and wifi use.\n\thal_EfuseSwitchToBank(padapter, 0, bPseudoTest);\n\n#if 0 // for debug test\n\tefuse_OneByteRead(padapter, 0x1FF, &efuse_data, bPseudoTest);\n\tDBG_8192C(FUNC_ADPT_FMT \": efuse raw 0x1FF=0x%02X\\n\",\n\t\tFUNC_ADPT_ARG(padapter), efuse_data);\n\tefuse_data = 0xFF;\n#endif // for debug test\n\n\tcount = 0;\n\twhile (AVAILABLE_EFUSE_ADDR(efuse_addr))\n\t{\n#if 1\n\t\tif (efuse_OneByteRead(padapter, efuse_addr, &efuse_data, bPseudoTest) == _FALSE)\n\t\t{\n\t\t\tDBG_8192C(KERN_ERR \"%s: efuse_OneByteRead Fail! addr=0x%X !!\\n\", __FUNCTION__, efuse_addr);\n\t\t\tgoto error;\n\t\t}\n#else\n\t\tReadEFuseByte(padapter, efuse_addr, &efuse_data, bPseudoTest);\n#endif\n\n\t\tif (efuse_data == 0xFF) break;\n\n\t\tif ((start_addr != 0) && (efuse_addr == start_addr))\n\t\t{\n\t\t\tcount++;\n\t\t\tDBG_8192C(FUNC_ADPT_FMT \": [WARNING] efuse raw 0x%X=0x%02X not 0xFF!!(%d times)\\n\",\n\t\t\t\tFUNC_ADPT_ARG(padapter), efuse_addr, efuse_data, count);\n\n\t\t\tefuse_data = 0xFF;\n\t\t\tif (count < 4)\n\t\t\t{\n\t\t\t\t// try again!\n\n\t\t\t\tif (count > 2)\n\t\t\t\t{\n\t\t\t\t\t// try again form address 0\n\t\t\t\t\tefuse_addr = 0;\n\t\t\t\t\tstart_addr = 0;\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (EXT_HEADER(efuse_data))\n\t\t{\n\t\t\thoffset = GET_HDR_OFFSET_2_0(efuse_data);\n\t\t\tefuse_addr++;\n\t\t\tefuse_OneByteRead(padapter, efuse_addr, &efuse_data, bPseudoTest);\n\t\t\tif (ALL_WORDS_DISABLED(efuse_data))\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\thoffset |= ((efuse_data & 0xF0) >> 1);\n\t\t\thworden = efuse_data & 0x0F;\n\t\t}\n\t\telse\n\t\t{\n\t\t\thoffset = (efuse_data>>4) & 0x0F;\n\t\t\thworden = efuse_data & 0x0F;\n\t\t}\n\n\t\tword_cnts = Efuse_CalculateWordCnts(hworden);\n\t\tefuse_addr += (word_cnts*2)+1;\n\t}\n\n\tif (bPseudoTest)\n\t{\n#ifdef HAL_EFUSE_MEMORY\n\t\tpEfuseHal->fakeEfuseUsedBytes = efuse_addr;\n#else\n\t\tfakeEfuseUsedBytes = efuse_addr;\n#endif\n\t}\n\telse\n\t{\n\t\trtw_hal_set_hwreg(padapter, HW_VAR_EFUSE_BYTES, (u8*)&efuse_addr);\n\t}\n\t\n\tgoto exit;\n\nerror:\n\t// report max size to prevent wirte efuse\n\tEFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, &efuse_addr, bPseudoTest);\n\nexit:\n\tDBG_8192C(\"%s: CurrentSize=%d\\n\", __FUNCTION__, efuse_addr);\n\n\treturn efuse_addr;\n}\n\nstatic u16\nhal_EfuseGetCurrentSize_BT(\n\tPADAPTER\tpadapter,\n\tu8\t\t\tbPseudoTest)\n{\n#ifdef HAL_EFUSE_MEMORY\n\tPHAL_DATA_TYPE\tpHalData = GET_HAL_DATA(padapter);\n\tPEFUSE_HAL\t\tpEfuseHal = &pHalData->EfuseHal;\n#endif\n\tu16 btusedbytes;\n\tu16\tefuse_addr;\n\tu8\tbank, startBank;\n\tu8\thoffset=0, hworden=0;\n\tu8\tefuse_data, word_cnts=0;\n\tu16\tretU2=0;\n\tu8 bContinual = _TRUE;\n\n\n\tif (bPseudoTest)\n\t{\n#ifdef HAL_EFUSE_MEMORY\n\t\tbtusedbytes = pEfuseHal->fakeBTEfuseUsedBytes;\n#else\n\t\tbtusedbytes = fakeBTEfuseUsedBytes;\n#endif\n\t}\n\telse\n\t{\n\t\tbtusedbytes = 0;\n\t\trtw_hal_get_hwreg(padapter, HW_VAR_EFUSE_BT_BYTES, (u8*)&btusedbytes);\n\t}\n\tefuse_addr = (u16)((btusedbytes%EFUSE_BT_REAL_BANK_CONTENT_LEN));\n\tstartBank = (u8)(1+(btusedbytes/EFUSE_BT_REAL_BANK_CONTENT_LEN));\n\n\tDBG_8192C(\"%s: start from bank=%d addr=0x%X\\n\", __FUNCTION__, startBank, efuse_addr);\n\n\tEFUSE_GetEfuseDefinition(padapter, EFUSE_BT, TYPE_AVAILABLE_EFUSE_BYTES_BANK, &retU2, bPseudoTest);\n\n\tfor (bank=startBank; bank<3; bank++)\n\t{\n\t\tif (hal_EfuseSwitchToBank(padapter, bank, bPseudoTest) == _FALSE)\n\t\t{\n\t\t\tDBG_8192C(KERN_ERR \"%s: switch bank(%d) Fail!!\\n\", __FUNCTION__, bank);\n\t\t\t//bank = EFUSE_MAX_BANK;\n\t\t\tbreak;\n\t\t}\n\n\t\t// only when bank is switched we have to reset the efuse_addr.\n\t\tif (bank != startBank)\n\t\t\tefuse_addr = 0;\n#if 1\n\n\t\twhile (AVAILABLE_EFUSE_ADDR(efuse_addr))\n\t\t{\n\t\t\tif (efuse_OneByteRead(padapter, efuse_addr, &efuse_data, bPseudoTest) == _FALSE)\n\t\t\t{\n\t\t\t\tDBG_8192C(KERN_ERR \"%s: efuse_OneByteRead Fail! addr=0x%X !!\\n\", __FUNCTION__, efuse_addr);\n\t\t\t\t//bank = EFUSE_MAX_BANK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tDBG_8192C(\"%s: efuse_OneByteRead ! addr=0x%X !efuse_data=0x%X! bank =%d\\n\", __FUNCTION__, efuse_addr,efuse_data,bank);\n\n\t\t\tif (efuse_data == 0xFF) break;\n\n\t\t\tif (EXT_HEADER(efuse_data))\n\t\t\t{\n\t\t\t\thoffset = GET_HDR_OFFSET_2_0(efuse_data);\n\t\t\t\tefuse_addr++;\n\t\t\t\tefuse_OneByteRead(padapter, efuse_addr, &efuse_data, bPseudoTest);\n\t\t\t\tDBG_8192C(\"%s: efuse_OneByteRead EXT_HEADER ! addr=0x%X !efuse_data=0x%X! bank =%d\\n\", __FUNCTION__, efuse_addr,efuse_data,bank);\n\t\t\t\n\t\t\t\tif (ALL_WORDS_DISABLED(efuse_data))\n\t\t\t\t{\n\t\t\t\t\tefuse_addr++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n//\t\t\t\thoffset = ((hoffset & 0xE0) >> 5) | ((efuse_data & 0xF0) >> 1);\n\t\t\t\thoffset |= ((efuse_data & 0xF0) >> 1);\n\t\t\t\thworden = efuse_data & 0x0F;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\thoffset = (efuse_data>>4) & 0x0F;\n\t\t\t\thworden =  efuse_data & 0x0F;\n\t\t\t}\n\n\t\t\tDBG_8192C(FUNC_ADPT_FMT\": Offset=%d Worden=%#X\\n\",\n\t\t\t\tFUNC_ADPT_ARG(padapter), hoffset, hworden);\n\n\t\t\tword_cnts = Efuse_CalculateWordCnts(hworden);\n\t\t\t//read next header\n\t\t\tefuse_addr += (word_cnts*2)+1;\n\t\t}\n#else\t\n\twhile (\tbContinual && \n\t\t\tefuse_OneByteRead(padapter, efuse_addr ,&efuse_data, bPseudoTest) && \n\t\t\tAVAILABLE_EFUSE_ADDR(efuse_addr))\n\t\t{\t\n\t\t\tif(efuse_data!=0xFF)\n\t\t\t{\n\t\t\t\tif((efuse_data&0x1F) == 0x0F)\t\t//extended header\n\t\t\t\t{\n\t\t\t\t\thoffset = efuse_data;\n\t\t\t\t\tefuse_addr++;\n\t\t\t\t\tefuse_OneByteRead(padapter, efuse_addr ,&efuse_data, bPseudoTest);\n\t\t\t\t\tif((efuse_data & 0x0F) == 0x0F)\n\t\t\t\t\t{\n\t\t\t\t\t\tefuse_addr++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\thoffset = ((hoffset & 0xE0) >> 5) | ((efuse_data & 0xF0) >> 1);\n\t\t\t\t\t\thworden = efuse_data & 0x0F;\n\t\t\t\t\t}\n\t\t\t\t}\t\t\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\thoffset = (efuse_data>>4) & 0x0F;\n\t\t\t\t\thworden =  efuse_data & 0x0F;\t\t\t\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tword_cnts = Efuse_CalculateWordCnts(hworden);\n\t\t\t\t//read next header\t\t\t\t\t\t\t\n\t\t\t\tefuse_addr = efuse_addr + (word_cnts*2)+1;\t\t\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbContinual = _FALSE ;\t\t\t\n\t\t\t}\n\t\t}\n#endif\t\t\t\n\t\n\n\t\t// Check if we need to check next bank efuse\n\t\tif (efuse_addr < retU2)\n\t\t{\n\t\t\tbreak;// don't need to check next bank.\n\t\t}\n\t}\n#if 0\n\tretU2 = ((bank-1)*EFUSE_BT_REAL_BANK_CONTENT_LEN) + efuse_addr;\n\tif (bPseudoTest)\n\t{\n#ifdef HAL_EFUSE_MEMORY\n\t\tpEfuseHal->fakeBTEfuseUsedBytes = retU2;\n#else\n\t\tfakeBTEfuseUsedBytes = retU2;\n#endif\n\t}\n\telse\n\t{\n\t\trtw_hal_set_hwreg(padapter, HW_VAR_EFUSE_BT_BYTES, (u8*)&retU2);\n\t}\n#else\n\tretU2 = ((bank-1)*EFUSE_BT_REAL_BANK_CONTENT_LEN)+efuse_addr;\n\tif(bPseudoTest)\n\t{\n\t\tpEfuseHal->fakeBTEfuseUsedBytes = retU2;\n\t\t//RT_DISP(FEEPROM, EFUSE_PG, (\"Hal_EfuseGetCurrentSize_BT92C(), already use %u bytes\\n\", pEfuseHal->fakeBTEfuseUsedBytes));\n\t}\n\telse\n\t{\n\t\tpEfuseHal->BTEfuseUsedBytes = retU2;\n\t\t//RT_DISP(FEEPROM, EFUSE_PG, (\"Hal_EfuseGetCurrentSize_BT92C(), already use %u bytes\\n\", pEfuseHal->BTEfuseUsedBytes));\n\t}\n#endif\n\n\tDBG_8192C(\"%s: CurrentSize=%d\\n\", __FUNCTION__, retU2);\n\treturn retU2;\n}\n\nstatic u16\nHal_EfuseGetCurrentSize(\n\tPADAPTER\tpAdapter,\n\tu8\t\t\tefuseType,\n\tu8\t\t\tbPseudoTest)\n{\n\tu16\tret = 0;\n\n\tif (efuseType == EFUSE_WIFI)\n\t\tret = hal_EfuseGetCurrentSize_WiFi(pAdapter, bPseudoTest);\n\telse\n\t\tret = hal_EfuseGetCurrentSize_BT(pAdapter, bPseudoTest);\n\n\treturn ret;\n}\n\nstatic u8\nHal_EfuseWordEnableDataWrite(\n\tPADAPTER\tpadapter,\n\tu16\t\t\tefuse_addr,\n\tu8\t\t\tword_en,\n\tu8\t\t\t*data,\n\tu8\t\t\tbPseudoTest)\n{\n\tu16\ttmpaddr = 0;\n\tu16\tstart_addr = efuse_addr;\n\tu8\tbadworden = 0x0F;\n\tu8\ttmpdata[PGPKT_DATA_SIZE];\n\n\n//\tDBG_8192C(\"%s: efuse_addr=%#x word_en=%#x\\n\", __FUNCTION__, efuse_addr, word_en);\n\t_rtw_memset(tmpdata, 0xFF, PGPKT_DATA_SIZE);\n\n\tif (!(word_en & BIT(0)))\n\t{\n\t\ttmpaddr = start_addr;\n\t\tefuse_OneByteWrite(padapter, start_addr++, data[0], bPseudoTest);\n\t\tefuse_OneByteWrite(padapter, start_addr++, data[1], bPseudoTest);\n\n\t\tefuse_OneByteRead(padapter, tmpaddr, &tmpdata[0], bPseudoTest);\n\t\tefuse_OneByteRead(padapter, tmpaddr+1, &tmpdata[1], bPseudoTest);\n\t\tif ((data[0]!=tmpdata[0]) || (data[1]!=tmpdata[1])) {\n\t\t\tbadworden &= (~BIT(0));\n\t\t}\n\t}\n\tif (!(word_en & BIT(1)))\n\t{\n\t\ttmpaddr = start_addr;\n\t\tefuse_OneByteWrite(padapter, start_addr++, data[2], bPseudoTest);\n\t\tefuse_OneByteWrite(padapter, start_addr++, data[3], bPseudoTest);\n\n\t\tefuse_OneByteRead(padapter, tmpaddr, &tmpdata[2], bPseudoTest);\n\t\tefuse_OneByteRead(padapter, tmpaddr+1, &tmpdata[3], bPseudoTest);\n\t\tif ((data[2]!=tmpdata[2]) || (data[3]!=tmpdata[3])) {\n\t\t\tbadworden &= (~BIT(1));\n\t\t}\n\t}\n\tif (!(word_en & BIT(2)))\n\t{\n\t\ttmpaddr = start_addr;\n\t\tefuse_OneByteWrite(padapter, start_addr++, data[4], bPseudoTest);\n\t\tefuse_OneByteWrite(padapter, start_addr++, data[5], bPseudoTest);\n\n\t\tefuse_OneByteRead(padapter, tmpaddr, &tmpdata[4], bPseudoTest);\n\t\tefuse_OneByteRead(padapter, tmpaddr+1, &tmpdata[5], bPseudoTest);\n\t\tif ((data[4]!=tmpdata[4]) || (data[5]!=tmpdata[5])) {\n\t\t\tbadworden &= (~BIT(2));\n\t\t}\n\t}\n\tif (!(word_en & BIT(3)))\n\t{\n\t\ttmpaddr = start_addr;\n\t\tefuse_OneByteWrite(padapter, start_addr++, data[6], bPseudoTest);\n\t\tefuse_OneByteWrite(padapter, start_addr++, data[7], bPseudoTest);\n\n\t\tefuse_OneByteRead(padapter, tmpaddr, &tmpdata[6], bPseudoTest);\n\t\tefuse_OneByteRead(padapter, tmpaddr+1, &tmpdata[7], bPseudoTest);\n\t\tif ((data[6]!=tmpdata[6]) || (data[7]!=tmpdata[7])) {\n\t\t\tbadworden &= (~BIT(3));\n\t\t}\n\t}\n\n\treturn badworden;\n}\n\nstatic s32\nHal_EfusePgPacketRead(\n\tPADAPTER\tpadapter,\n\tu8\t\t\toffset,\n\tu8\t\t\t*data,\n\tu8\t\t\tbPseudoTest)\n{\n\tu8\tbDataEmpty = _TRUE;\n\tu8\tefuse_data, word_cnts=0;\n\tu16\tefuse_addr=0;\n\tu8\thoffset=0, hworden=0;\n\tu8\ti;\n\tu8\tmax_section = 0;\n\ts32\tret;\n\n\n\tif (data == NULL)\n\t\treturn _FALSE;\n\n\tEFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_EFUSE_MAX_SECTION, &max_section, bPseudoTest);\n\tif (offset > max_section)\n\t{\n\t\tDBG_8192C(\"%s: Packet offset(%d) is illegal(>%d)!\\n\", __FUNCTION__, offset, max_section);\n\t\treturn _FALSE;\n\t}\n\n\t_rtw_memset(data, 0xFF, PGPKT_DATA_SIZE);\n\tret = _TRUE;\n\n\t//\n\t// <Roger_TODO> Efuse has been pre-programmed dummy 5Bytes at the end of Efuse by CP.\n\t// Skip dummy parts to prevent unexpected data read from Efuse.\n\t// By pass right now. 2009.02.19.\n\t//\n\twhile (AVAILABLE_EFUSE_ADDR(efuse_addr))\n\t{\n\t\tif (efuse_OneByteRead(padapter, efuse_addr++, &efuse_data, bPseudoTest) == _FALSE)\n\t\t{\n\t\t\tret = _FALSE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (efuse_data == 0xFF) break;\n\n\t\tif (EXT_HEADER(efuse_data))\n\t\t{\n\t\t\thoffset = GET_HDR_OFFSET_2_0(efuse_data);\n\t\t\tefuse_OneByteRead(padapter, efuse_addr++, &efuse_data, bPseudoTest);\n\t\t\tif (ALL_WORDS_DISABLED(efuse_data))\n\t\t\t{\n\t\t\t\tDBG_8192C(\"%s: Error!! All words disabled!\\n\", __FUNCTION__);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\thoffset |= ((efuse_data & 0xF0) >> 1);\n\t\t\thworden = efuse_data & 0x0F;\n\t\t}\n\t\telse\n\t\t{\n\t\t\thoffset = (efuse_data>>4) & 0x0F;\n\t\t\thworden =  efuse_data & 0x0F;\n\t\t}\n\n\t\tif (hoffset == offset)\n\t\t{\n\t\t\tfor (i=0; i<EFUSE_MAX_WORD_UNIT; i++)\n\t\t\t{\n\t\t\t\t// Check word enable condition in the section\n\t\t\t\tif (!(hworden & (0x01<<i)))\n\t\t\t\t{\n\t\t\t\t\t//ReadEFuseByte(padapter, efuse_addr++, &efuse_data, bPseudoTest);\n\t\t\t\t\tefuse_OneByteRead(padapter, efuse_addr++, &efuse_data, bPseudoTest);\n//\t\t\t\t\tDBG_8192C(\"%s: efuse[%#X]=0x%02X\\n\", __FUNCTION__, efuse_addr+tmpidx, efuse_data);\n\t\t\t\t\tdata[i*2] = efuse_data;\n\n\t\t\t\t\t//ReadEFuseByte(padapter, efuse_addr++, &efuse_data, bPseudoTest);\n\t\t\t\t\tefuse_OneByteRead(padapter, efuse_addr++, &efuse_data, bPseudoTest);\n//\t\t\t\t\tDBG_8192C(\"%s: efuse[%#X]=0x%02X\\n\", __FUNCTION__, efuse_addr+tmpidx, efuse_data);\n\t\t\t\t\tdata[(i*2)+1] = efuse_data;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tword_cnts = Efuse_CalculateWordCnts(hworden);\n\t\t\tefuse_addr += word_cnts*2;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic u8\nhal_EfusePgCheckAvailableAddr(\n\tPADAPTER\tpAdapter,\n\tu8\t\t\tefuseType,\n\tu8\t\tbPseudoTest)\n{\n\tu16\tmax_available=0;\n\tu16 current_size;\n\n\n\tEFUSE_GetEfuseDefinition(pAdapter, efuseType, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, &max_available, bPseudoTest);\n//\tDBG_8192C(\"%s: max_available=%d\\n\", __FUNCTION__, max_available);\n\n\tcurrent_size = Efuse_GetCurrentSize(pAdapter, efuseType, bPseudoTest);\n\tif (current_size >= max_available)\n\t{\n\t\tDBG_8192C(\"%s: Error!! current_size(%d)>max_available(%d)\\n\", __FUNCTION__, current_size, max_available);\n\t\treturn _FALSE;\n\t}\n\treturn _TRUE;\n}\n\nstatic void\nhal_EfuseConstructPGPkt(\n\tu8 \t\t\t\toffset,\n\tu8\t\t\t\tword_en,\n\tu8\t\t\t\t*pData,\n\tPPGPKT_STRUCT\tpTargetPkt)\n{\n\t_rtw_memset(pTargetPkt->data, 0xFF, PGPKT_DATA_SIZE);\n\tpTargetPkt->offset = offset;\n\tpTargetPkt->word_en = word_en;\n\tefuse_WordEnableDataRead(word_en, pData, pTargetPkt->data);\n\tpTargetPkt->word_cnts = Efuse_CalculateWordCnts(pTargetPkt->word_en);\n}\n\n#if 0\nstatic u8\nwordEnMatched(\n\tPPGPKT_STRUCT\tpTargetPkt,\n\tPPGPKT_STRUCT\tpCurPkt,\n\tu8\t\t\t\t*pWden)\n{\n\tu8\tmatch_word_en = 0x0F;\t// default all words are disabled\n\tu8\ti;\n\n\t// check if the same words are enabled both target and current PG packet\n\tif (((pTargetPkt->word_en & BIT(0)) == 0) &&\n\t\t((pCurPkt->word_en & BIT(0)) == 0))\n\t{\n\t\tmatch_word_en &= ~BIT(0);\t\t\t\t// enable word 0\n\t}\n\tif (((pTargetPkt->word_en & BIT(1)) == 0) &&\n\t\t((pCurPkt->word_en & BIT(1)) == 0))\n\t{\n\t\tmatch_word_en &= ~BIT(1);\t\t\t\t// enable word 1\n\t}\n\tif (((pTargetPkt->word_en & BIT(2)) == 0) &&\n\t\t((pCurPkt->word_en & BIT(2)) == 0))\n\t{\n\t\tmatch_word_en &= ~BIT(2);\t\t\t\t// enable word 2\n\t}\n\tif (((pTargetPkt->word_en & BIT(3)) == 0) &&\n\t\t((pCurPkt->word_en & BIT(3)) == 0))\n\t{\n\t\tmatch_word_en &= ~BIT(3);\t\t\t\t// enable word 3\n\t}\n\n\t*pWden = match_word_en;\n\n\tif (match_word_en != 0xf)\n\t\treturn _TRUE;\n\telse\n\t\treturn _FALSE;\n}\n\nstatic u8\nhal_EfuseCheckIfDatafollowed(\n\tPADAPTER\t\tpAdapter,\n\tu8\t\t\t\tword_cnts,\n\tu16\t\t\t\tstartAddr,\n\tu8\t\t\t\tbPseudoTest)\n{\n\tu8 bRet=_FALSE;\n\tu8 i, efuse_data;\n\n\tfor (i=0; i<(word_cnts*2); i++)\n\t{\n\t\tif (efuse_OneByteRead(pAdapter, (startAddr+i) ,&efuse_data, bPseudoTest) == _FALSE)\n\t\t{\n\t\t\tDBG_8192C(\"%s: efuse_OneByteRead FAIL!!\\n\", __FUNCTION__);\n\t\t\tbRet = _TRUE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (efuse_data != 0xFF)\n\t\t{\n\t\t\tbRet = _TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn bRet;\n}\n#endif\n\nstatic u8\nhal_EfusePartialWriteCheck(\n\tPADAPTER\t\tpadapter,\n\tu8\t\t\t\tefuseType,\n\tu16\t\t\t\t*pAddr,\n\tPPGPKT_STRUCT\tpTargetPkt,\n\tu8\t\t\t\tbPseudoTest)\n{\n\tPHAL_DATA_TYPE\tpHalData = GET_HAL_DATA(padapter);\n\tPEFUSE_HAL\t\tpEfuseHal = &pHalData->EfuseHal;\n\tu8\tbRet=_FALSE;\n\tu16\tstartAddr=0, efuse_max_available_len=0, efuse_max=0;\n\tu8\tefuse_data=0;\n#if 0\n\tu8\ti, cur_header=0;\n\tu8\tnew_wden=0, matched_wden=0, badworden=0;\n\tPGPKT_STRUCT\tcurPkt;\n#endif\n\n\n\tEFUSE_GetEfuseDefinition(padapter, efuseType, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, &efuse_max_available_len, bPseudoTest);\n\tEFUSE_GetEfuseDefinition(padapter, efuseType, TYPE_EFUSE_CONTENT_LEN_BANK, &efuse_max, bPseudoTest);\n\n\tif (efuseType == EFUSE_WIFI)\n\t{\n\t\tif (bPseudoTest)\n\t\t{\n#ifdef HAL_EFUSE_MEMORY\n\t\t\tstartAddr = (u16)pEfuseHal->fakeEfuseUsedBytes;\n#else\n\t\t\tstartAddr = (u16)fakeEfuseUsedBytes;\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t\trtw_hal_get_hwreg(padapter, HW_VAR_EFUSE_BYTES, (u8*)&startAddr);\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (bPseudoTest)\n\t\t{\n#ifdef HAL_EFUSE_MEMORY\n\t\t\tstartAddr = (u16)pEfuseHal->fakeBTEfuseUsedBytes;\n#else\n\t\t\tstartAddr = (u16)fakeBTEfuseUsedBytes;\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t\trtw_hal_get_hwreg(padapter, HW_VAR_EFUSE_BT_BYTES, (u8*)&startAddr);\n\t\t}\n\t}\n\tstartAddr %= efuse_max;\n\tDBG_8192C(\"%s: startAddr=%#X\\n\", __FUNCTION__, startAddr);\n\n\twhile (1)\n\t{\n\t\tif (startAddr >= efuse_max_available_len)\n\t\t{\n\t\t\tbRet = _FALSE;\n\t\t\tDBG_8192C(\"%s: startAddr(%d) >= efuse_max_available_len(%d)\\n\",\n\t\t\t\t__FUNCTION__, startAddr, efuse_max_available_len);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (efuse_OneByteRead(padapter, startAddr, &efuse_data, bPseudoTest) && (efuse_data!=0xFF))\n\t\t{\n#if 1\n\t\t\tbRet = _FALSE;\n\t\t\tDBG_8192C(\"%s: Something Wrong! last bytes(%#X=0x%02X) is not 0xFF\\n\",\n\t\t\t\t__FUNCTION__, startAddr, efuse_data);\n\t\t\tbreak;\n#else\n\t\t\tif (EXT_HEADER(efuse_data))\n\t\t\t{\n\t\t\t\tcur_header = efuse_data;\n\t\t\t\tstartAddr++;\n\t\t\t\tefuse_OneByteRead(padapter, startAddr, &efuse_data, bPseudoTest);\n\t\t\t\tif (ALL_WORDS_DISABLED(efuse_data))\n\t\t\t\t{\n\t\t\t\t\tDBG_8192C(\"%s: Error condition, all words disabled!\", __FUNCTION__);\n\t\t\t\t\tbRet = _FALSE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcurPkt.offset = ((cur_header & 0xE0) >> 5) | ((efuse_data & 0xF0) >> 1);\n\t\t\t\t\tcurPkt.word_en = efuse_data & 0x0F;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcur_header  =  efuse_data;\n\t\t\t\tcurPkt.offset = (cur_header>>4) & 0x0F;\n\t\t\t\tcurPkt.word_en = cur_header & 0x0F;\n\t\t\t}\n\n\t\t\tcurPkt.word_cnts = Efuse_CalculateWordCnts(curPkt.word_en);\n\t\t\t// if same header is found but no data followed\n\t\t\t// write some part of data followed by the header.\n\t\t\tif ((curPkt.offset == pTargetPkt->offset) &&\n\t\t\t\t(hal_EfuseCheckIfDatafollowed(padapter, curPkt.word_cnts, startAddr+1, bPseudoTest) == _FALSE) &&\n\t\t\t\twordEnMatched(pTargetPkt, &curPkt, &matched_wden) == _TRUE)\n\t\t\t{\n\t\t\t\tDBG_8192C(\"%s: Need to partial write data by the previous wrote header\\n\", __FUNCTION__);\n\t\t\t\t// Here to write partial data\n\t\t\t\tbadworden = Efuse_WordEnableDataWrite(padapter, startAddr+1, matched_wden, pTargetPkt->data, bPseudoTest);\n\t\t\t\tif (badworden != 0x0F)\n\t\t\t\t{\n\t\t\t\t\tu32\tPgWriteSuccess=0;\n\t\t\t\t\t// if write fail on some words, write these bad words again\n\t\t\t\t\tif (efuseType == EFUSE_WIFI)\n\t\t\t\t\t\tPgWriteSuccess = Efuse_PgPacketWrite(padapter, pTargetPkt->offset, badworden, pTargetPkt->data, bPseudoTest);\n\t\t\t\t\telse\n\t\t\t\t\t\tPgWriteSuccess = Efuse_PgPacketWrite_BT(padapter, pTargetPkt->offset, badworden, pTargetPkt->data, bPseudoTest);\n\n\t\t\t\t\tif (!PgWriteSuccess)\n\t\t\t\t\t{\n\t\t\t\t\t\tbRet = _FALSE;\t// write fail, return\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// partial write ok, update the target packet for later use\n\t\t\t\tfor (i=0; i<4; i++)\n\t\t\t\t{\n\t\t\t\t\tif ((matched_wden & (0x1<<i)) == 0)\t// this word has been written\n\t\t\t\t\t{\n\t\t\t\t\t\tpTargetPkt->word_en |= (0x1<<i);\t// disable the word\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpTargetPkt->word_cnts = Efuse_CalculateWordCnts(pTargetPkt->word_en);\n\t\t\t}\n\t\t\t// read from next header\n\t\t\tstartAddr = startAddr + (curPkt.word_cnts*2) + 1;\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// not used header, 0xff\n\t\t\t*pAddr = startAddr;\n//\t\t\tDBG_8192C(\"%s: Started from unused header offset=%d\\n\", __FUNCTION__, startAddr));\n\t\t\tbRet = _TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn bRet;\n}\n\nstatic u8\nhal_EfusePgPacketWrite1ByteHeader(\n\tPADAPTER\t\tpAdapter,\n\tu8\t\t\t\tefuseType,\n\tu16\t\t\t\t*pAddr,\n\tPPGPKT_STRUCT\tpTargetPkt,\n\tu8\t\t\t\tbPseudoTest)\n{\n\tu8\tbRet=_FALSE;\n\tu8\tpg_header=0, tmp_header=0;\n\tu16\tefuse_addr=*pAddr;\n\tu8\trepeatcnt=0;\n\n\n//\tDBG_8192C(\"%s\\n\", __FUNCTION__);\n\tpg_header = ((pTargetPkt->offset << 4) & 0xf0) | pTargetPkt->word_en;\n\n\tdo {\n\t\tefuse_OneByteWrite(pAdapter, efuse_addr, pg_header, bPseudoTest);\n\t\tefuse_OneByteRead(pAdapter, efuse_addr, &tmp_header, bPseudoTest);\n\t\tif (tmp_header != 0xFF) break;\n\t\tif (repeatcnt++ > EFUSE_REPEAT_THRESHOLD_)\n\t\t{\n\t\t\tDBG_8192C(\"%s: Repeat over limit for pg_header!!\\n\", __FUNCTION__);\n\t\t\treturn _FALSE;\n\t\t}\n\t} while (1);\n\n\tif (tmp_header != pg_header)\n\t{\n\t\tDBG_8192C(KERN_ERR \"%s: PG Header Fail!!(pg=0x%02X read=0x%02X)\\n\", __FUNCTION__, pg_header, tmp_header);\n\t\treturn _FALSE;\n\t}\n\n\t*pAddr = efuse_addr;\n\n\treturn _TRUE;\n}\n\nstatic u8\nhal_EfusePgPacketWrite2ByteHeader(\n\tPADAPTER\t\tpadapter,\n\tu8\t\t\t\tefuseType,\n\tu16\t\t\t\t*pAddr,\n\tPPGPKT_STRUCT\tpTargetPkt,\n\tu8\t\t\t\tbPseudoTest)\n{\n\tu16\tefuse_addr, efuse_max_available_len=0;\n\tu8\tpg_header=0, tmp_header=0;\n\tu8\trepeatcnt=0;\n\n\n//\tDBG_8192C(\"%s\\n\", __FUNCTION__);\n\tEFUSE_GetEfuseDefinition(padapter, efuseType, TYPE_AVAILABLE_EFUSE_BYTES_BANK, &efuse_max_available_len, bPseudoTest);\n\n\tefuse_addr = *pAddr;\n\tif (efuse_addr >= efuse_max_available_len)\n\t{\n\t\tDBG_8192C(\"%s: addr(%d) over avaliable(%d)!!\\n\", __FUNCTION__, efuse_addr, efuse_max_available_len);\n\t\treturn _FALSE;\n\t}\n\n\tpg_header = ((pTargetPkt->offset & 0x07) << 5) | 0x0F;\n//\tDBG_8192C(\"%s: pg_header=0x%x\\n\", __FUNCTION__, pg_header);\n\n\tdo {\n\t\tefuse_OneByteWrite(padapter, efuse_addr, pg_header, bPseudoTest);\n\t\tefuse_OneByteRead(padapter, efuse_addr, &tmp_header, bPseudoTest);\n\t\tif (tmp_header != 0xFF) break;\n\t\tif (repeatcnt++ > EFUSE_REPEAT_THRESHOLD_)\n\t\t{\n\t\t\tDBG_8192C(\"%s: Repeat over limit for pg_header!!\\n\", __FUNCTION__);\n\t\t\treturn _FALSE;\n\t\t}\n\t} while (1);\n\n\tif (tmp_header != pg_header)\n\t{\n\t\tDBG_8192C(KERN_ERR \"%s: PG Header Fail!!(pg=0x%02X read=0x%02X)\\n\", __FUNCTION__, pg_header, tmp_header);\n\t\treturn _FALSE;\n\t}\n\n\t// to write ext_header\n\tefuse_addr++;\n\tpg_header = ((pTargetPkt->offset & 0x78) << 1) | pTargetPkt->word_en;\n\n\tdo {\n\t\tefuse_OneByteWrite(padapter, efuse_addr, pg_header, bPseudoTest);\n\t\tefuse_OneByteRead(padapter, efuse_addr, &tmp_header, bPseudoTest);\n\t\tif (tmp_header != 0xFF) break;\n\t\tif (repeatcnt++ > EFUSE_REPEAT_THRESHOLD_)\n\t\t{\n\t\t\tDBG_8192C(\"%s: Repeat over limit for ext_header!!\\n\", __FUNCTION__);\n\t\t\treturn _FALSE;\n\t\t}\n\t} while (1);\n\n\tif (tmp_header != pg_header)\t//offset PG fail\n\t{\n\t\tDBG_8192C(KERN_ERR \"%s: PG EXT Header Fail!!(pg=0x%02X read=0x%02X)\\n\", __FUNCTION__, pg_header, tmp_header);\n\t\treturn _FALSE;\n\t}\n\n\t*pAddr = efuse_addr;\n\n\treturn _TRUE;\n}\n\nstatic u8\nhal_EfusePgPacketWriteHeader(\n\tPADAPTER\t\tpadapter,\n\tu8\t\t\t\tefuseType,\n\tu16\t\t\t\t*pAddr,\n\tPPGPKT_STRUCT\tpTargetPkt,\n\tu8\t\t\t\tbPseudoTest)\n{\n\tu8 bRet=_FALSE;\n\n\tif (pTargetPkt->offset >= EFUSE_MAX_SECTION_BASE)\n\t{\n\t\tbRet = hal_EfusePgPacketWrite2ByteHeader(padapter, efuseType, pAddr, pTargetPkt, bPseudoTest);\n\t}\n\telse\n\t{\n\t\tbRet = hal_EfusePgPacketWrite1ByteHeader(padapter, efuseType, pAddr, pTargetPkt, bPseudoTest);\n\t}\n\n\treturn bRet;\n}\n\nstatic u8\nhal_EfusePgPacketWriteData(\n\tPADAPTER\t\tpAdapter,\n\tu8\t\t\t\tefuseType,\n\tu16\t\t\t\t*pAddr,\n\tPPGPKT_STRUCT\tpTargetPkt,\n\tu8\t\t\t\tbPseudoTest)\n{\n\tu16\tefuse_addr;\n\tu8\tbadworden;\n\n\n\tefuse_addr = *pAddr;\n\tbadworden = Efuse_WordEnableDataWrite(pAdapter, efuse_addr+1, pTargetPkt->word_en, pTargetPkt->data, bPseudoTest);\n\tif (badworden != 0x0F)\n\t{\n\t\tDBG_8192C(\"%s: Fail!!\\n\", __FUNCTION__);\n\t\treturn _FALSE;\n\t}\n\n//\tDBG_8192C(\"%s: ok\\n\", __FUNCTION__);\n\treturn _TRUE;\n}\n\nstatic s32\nHal_EfusePgPacketWrite(\n\tPADAPTER\tpadapter,\n\tu8 \t\t\toffset,\n\tu8\t\t\tword_en,\n\tu8\t\t\t*pData,\n\tu8\t\t\tbPseudoTest)\n{\n\tPGPKT_STRUCT targetPkt;\n\tu16 startAddr=0;\n\tu8 efuseType=EFUSE_WIFI;\n\n\tif (!hal_EfusePgCheckAvailableAddr(padapter, efuseType, bPseudoTest))\n\t\treturn _FALSE;\n\n\thal_EfuseConstructPGPkt(offset, word_en, pData, &targetPkt);\n\n\tif (!hal_EfusePartialWriteCheck(padapter, efuseType, &startAddr, &targetPkt, bPseudoTest))\n\t\treturn _FALSE;\n\n\tif (!hal_EfusePgPacketWriteHeader(padapter, efuseType, &startAddr, &targetPkt, bPseudoTest))\n\t\treturn _FALSE;\n\n\tif (!hal_EfusePgPacketWriteData(padapter, efuseType, &startAddr, &targetPkt, bPseudoTest))\n\t\treturn _FALSE;\n\n\treturn _TRUE;\n}\n\nstatic u8\nHal_EfusePgPacketWrite_BT(\n\tPADAPTER\tpAdapter,\n\tu8 \t\t\toffset,\n\tu8\t\t\tword_en,\n\tu8\t\t\t*pData,\n\tu8\t\t\tbPseudoTest)\n{\n\tPGPKT_STRUCT targetPkt;\n\tu16 startAddr=0;\n\tu8 efuseType=EFUSE_BT;\n\n\tif(!hal_EfusePgCheckAvailableAddr(pAdapter, efuseType, bPseudoTest))\n\t\treturn _FALSE;\n\n\thal_EfuseConstructPGPkt(offset, word_en, pData, &targetPkt);\n\n\tif(!hal_EfusePartialWriteCheck(pAdapter, efuseType, &startAddr, &targetPkt, bPseudoTest))\n\t\treturn _FALSE;\n\n\tif(!hal_EfusePgPacketWriteHeader(pAdapter, efuseType, &startAddr, &targetPkt, bPseudoTest))\n\t\treturn _FALSE;\n\n\tif(!hal_EfusePgPacketWriteData(pAdapter, efuseType, &startAddr, &targetPkt, bPseudoTest))\n\t\treturn _FALSE;\n\n\treturn _TRUE;\n}\n\n\nstatic void read_chip_version_8723b(PADAPTER padapter)\n{\n\tu32\t\t\t\tvalue32;\t\n\tHAL_DATA_TYPE\t*pHalData;\n\tpHalData = GET_HAL_DATA(padapter);\n\n\tvalue32 = rtw_read32(padapter, REG_SYS_CFG);\n\tpHalData->VersionID.ICType = CHIP_8723B;\n\tpHalData->VersionID.ChipType = ((value32 & RTL_ID) ? TEST_CHIP : NORMAL_CHIP);\n\tpHalData->VersionID.RFType = RF_TYPE_1T1R ;\n\tpHalData->VersionID.VendorType = ((value32 & VENDOR_ID) ? CHIP_VENDOR_UMC : CHIP_VENDOR_TSMC);\n\tpHalData->VersionID.CUTVersion = (value32 & CHIP_VER_RTL_MASK)>>CHIP_VER_RTL_SHIFT; // IC version (CUT)\n\n\t// For regulator mode. by tynli. 2011.01.14\n\tpHalData->RegulatorMode = ((value32 & SPS_SEL) ? RT_LDO_REGULATOR : RT_SWITCHING_REGULATOR);\n\n\tvalue32 = rtw_read32(padapter, REG_GPIO_OUTSTS);\n\tpHalData->VersionID.ROMVer = ((value32 & RF_RL_ID) >> 20);\t// ROM code version.\n\n\t// For multi-function consideration. Added by Roger, 2010.10.06.\n\tpHalData->MultiFunc = RT_MULTI_FUNC_NONE;\n\tvalue32 = rtw_read32(padapter, REG_MULTI_FUNC_CTRL);\n\tpHalData->MultiFunc |= ((value32 & WL_FUNC_EN) ? RT_MULTI_FUNC_WIFI : 0);\n\tpHalData->MultiFunc |= ((value32 & BT_FUNC_EN) ? RT_MULTI_FUNC_BT : 0);\n\tpHalData->MultiFunc |= ((value32 & GPS_FUNC_EN) ? RT_MULTI_FUNC_GPS : 0);\n\tpHalData->PolarityCtl = ((value32 & WL_HWPDN_SL) ? RT_POLARITY_HIGH_ACT : RT_POLARITY_LOW_ACT);\n\n\trtw_hal_config_rftype(padapter);\n\n/*\t// mark for chage to use efuse\n\tif( IS_B_CUT(pHalData->VersionID) || IS_C_CUT(pHalData->VersionID))\n\t{\n\t\tMSG_8192C(\" IS_B/C_CUT SWR up 1 level !!!!!!!!!!!!!!!!!\\n\");\n\t\tPHY_SetMacReg(padapter, 0x14, BIT23|BIT22|BIT21|BIT20, 0x5); //MAC reg 0x14[23:20] = 4b'0101 (SWR 1.220V)\n\t}else if ( IS_D_CUT(pHalData->VersionID))\n\t{\n\t\tMSG_8192C(\" IS_D_CUT SKIP SWR !!!!!!!!!!!!!!!!!\\n\");\n\t}\n*/\n\n#if 1\n\tdump_chip_info(pHalData->VersionID);\n#endif\n\n}\n\n\nvoid rtl8723b_InitBeaconParameters(PADAPTER padapter)\n{\n\tPHAL_DATA_TYPE pHalData = GET_HAL_DATA(padapter);\n\tu16 val16;\n\tu8 val8;\n\n\n\tval8 = DIS_TSF_UDT;\n\tval16 = val8 | (val8 << 8); // port0 and port1\n#ifdef CONFIG_BT_COEXIST\n\t// Enable prot0 beacon function for PSTDMA\n\tval16 |= EN_BCN_FUNCTION;\n#endif\n\trtw_write16(padapter, REG_BCN_CTRL, val16);\n\n\t// TODO: Remove these magic number\n\trtw_write16(padapter, REG_TBTT_PROHIBIT, 0x6404);// ms\n\t// Firmware will control REG_DRVERLYINT when power saving is enable,\n\t// so don't set this register on STA mode.\n\tif (check_fwstate(&padapter->mlmepriv, WIFI_STATION_STATE) == _FALSE)\n\t\trtw_write8(padapter, REG_DRVERLYINT, DRIVER_EARLY_INT_TIME_8723B); // 5ms\n\trtw_write8(padapter, REG_BCNDMATIM, BCN_DMA_ATIME_INT_TIME_8723B); // 2ms\n\n\t// Suggested by designer timchen. Change beacon AIFS to the largest number\n\t// beacause test chip does not contension before sending beacon. by tynli. 2009.11.03\n\trtw_write16(padapter, REG_BCNTCFG, 0x660F);\n\t\n\tpHalData->RegBcnCtrlVal = rtw_read8(padapter, REG_BCN_CTRL);\n\tpHalData->RegTxPause = rtw_read8(padapter, REG_TXPAUSE); \n\tpHalData->RegFwHwTxQCtrl = rtw_read8(padapter, REG_FWHW_TXQ_CTRL+2);\n\tpHalData->RegReg542 = rtw_read8(padapter, REG_TBTT_PROHIBIT+2);\n\tpHalData->RegCR_1 = rtw_read8(padapter, REG_CR+1);\n}\n\nvoid rtl8723b_InitBeaconMaxError(PADAPTER padapter, u8 InfraMode)\n{\n#ifdef CONFIG_ADHOC_WORKAROUND_SETTING\n\trtw_write8(padapter, REG_BCN_MAX_ERR, 0xFF);\n#else\n\t//rtw_write8(Adapter, REG_BCN_MAX_ERR, (InfraMode ? 0xFF : 0x10));\n#endif\n}\n\nvoid\t_InitBurstPktLen_8723BS(PADAPTER Adapter)\n{\n\tHAL_DATA_TYPE\t\t*pHalData = GET_HAL_DATA(Adapter);\n\n\trtw_write8(Adapter, 0x4c7,rtw_read8(Adapter, 0x4c7)|BIT(7)); //enable single pkt ampdu\n\trtw_write8(Adapter, REG_RX_PKT_LIMIT_8723B, 0x18);\t\t//for VHT packet length 11K\n\trtw_write8(Adapter, REG_MAX_AGGR_NUM_8723B, 0x1F);\n\trtw_write8(Adapter, REG_PIFS_8723B, 0x00);\n\trtw_write8(Adapter, REG_FWHW_TXQ_CTRL_8723B, rtw_read8(Adapter, REG_FWHW_TXQ_CTRL)&(~BIT(7)));\n\tif(pHalData->AMPDUBurstMode)\n\t{\n\t\trtw_write8(Adapter,REG_AMPDU_BURST_MODE_8723B,  0x5F);\n\t}\n\trtw_write8(Adapter, REG_AMPDU_MAX_TIME_8723B, 0x70);\n\n\t// ARFB table 9 for 11ac 5G 2SS\n\trtw_write32(Adapter, REG_ARFR0_8723B, 0x00000010);\n\tif(IS_NORMAL_CHIP(pHalData->VersionID))\n\t\trtw_write32(Adapter, REG_ARFR0_8723B+4, 0xfffff000);\n\telse\n\t\trtw_write32(Adapter, REG_ARFR0_8723B+4, 0x3e0ff000);\n\n\t// ARFB table 10 for 11ac 5G 1SS\n\trtw_write32(Adapter, REG_ARFR1_8723B, 0x00000010);\n\trtw_write32(Adapter, REG_ARFR1_8723B+4, 0x003ff000);\n}\n\nstatic void ResumeTxBeacon(PADAPTER padapter)\n{\n\tPHAL_DATA_TYPE pHalData = GET_HAL_DATA(padapter);\n\n\n\t// 2010.03.01. Marked by tynli. No need to call workitem beacause we record the value\n\t// which should be read from register to a global variable.\n\n\tRT_TRACE(_module_hci_hal_init_c_, _drv_info_, (\"+ResumeTxBeacon\\n\"));\n\n\tpHalData->RegFwHwTxQCtrl |= BIT(6);\n\trtw_write8(padapter, REG_FWHW_TXQ_CTRL+2, pHalData->RegFwHwTxQCtrl);\n\trtw_write8(padapter, REG_TBTT_PROHIBIT+1, 0xff);\n\tpHalData->RegReg542 |= BIT(0);\n\trtw_write8(padapter, REG_TBTT_PROHIBIT+2, pHalData->RegReg542);\n}\n\nstatic void StopTxBeacon(PADAPTER padapter)\n{\n\tPHAL_DATA_TYPE pHalData = GET_HAL_DATA(padapter);\n\n\n\t// 2010.03.01. Marked by tynli. No need to call workitem beacause we record the value\n\t// which should be read from register to a global variable.\n\n\tRT_TRACE(_module_hci_hal_init_c_, _drv_info_, (\"+StopTxBeacon\\n\"));\n\n\tpHalData->RegFwHwTxQCtrl &= ~BIT(6);\n\trtw_write8(padapter, REG_FWHW_TXQ_CTRL+2, pHalData->RegFwHwTxQCtrl);\n\trtw_write8(padapter, REG_TBTT_PROHIBIT+1, 0x64);\n\tpHalData->RegReg542 &= ~BIT(0);\n\trtw_write8(padapter, REG_TBTT_PROHIBIT+2, pHalData->RegReg542);\n\n\tCheckFwRsvdPageContent(padapter);  // 2010.06.23. Added by tynli.\n}\n\nstatic void _BeaconFunctionEnable(PADAPTER padapter, u8 Enable, u8 Linked)\n{\n\trtw_write8(padapter, REG_BCN_CTRL, DIS_TSF_UDT | EN_BCN_FUNCTION | DIS_BCNQ_SUB);\n\trtw_write8(padapter, REG_RD_CTRL+1, 0x6F);\n}\n\nstatic void rtl8723b_SetBeaconRelatedRegisters(PADAPTER padapter)\n{\n\tu8 val8;\n\tu32 value32;\n\tPHAL_DATA_TYPE pHalData = GET_HAL_DATA(padapter);\n\tstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;\n\tu32 bcn_ctrl_reg;\n\n\t//reset TSF, enable update TSF, correcting TSF On Beacon\n\n\t//REG_BCN_INTERVAL\n\t//REG_BCNDMATIM\n\t//REG_ATIMWND\n\t//REG_TBTT_PROHIBIT\n\t//REG_DRVERLYINT\n\t//REG_BCN_MAX_ERR\n\t//REG_BCNTCFG //(0x510)\n\t//REG_DUAL_TSF_RST\n\t//REG_BCN_CTRL //(0x550)\n\n\n\tbcn_ctrl_reg = REG_BCN_CTRL;\n#ifdef CONFIG_CONCURRENT_MODE\n\tif (padapter->iface_type == IFACE_PORT1)\n\t\tbcn_ctrl_reg = REG_BCN_CTRL_1;\n#endif\n\n\t//\n\t// ATIM window\n\t//\n\trtw_write16(padapter, REG_ATIMWND, 2);\n\n\t//\n\t// Beacon interval (in unit of TU).\n\t//\n\trtw_write16(padapter, REG_BCN_INTERVAL, pmlmeinfo->bcn_interval);\n\n\trtl8723b_InitBeaconParameters(padapter);\n\n\trtw_write8(padapter, REG_SLOT, 0x09);\n\n\t//\n\t// Reset TSF Timer to zero, added by Roger. 2008.06.24\n\t//\n\tvalue32 = rtw_read32(padapter, REG_TCR);\n\tvalue32 &= ~TSFRST;\n\trtw_write32(padapter, REG_TCR, value32);\n\n\tvalue32 |= TSFRST;\n\trtw_write32(padapter, REG_TCR, value32);\n\n\t// NOTE: Fix test chip's bug (about contention windows's randomness)\n\tif (check_fwstate(&padapter->mlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE|WIFI_AP_STATE) == _TRUE)\n\t{\n\t\trtw_write8(padapter, REG_RXTSF_OFFSET_CCK, 0x50);\n\t\trtw_write8(padapter, REG_RXTSF_OFFSET_OFDM, 0x50);\n\t}\n\n\t_BeaconFunctionEnable(padapter, _TRUE, _TRUE);\n\n\tResumeTxBeacon(padapter);\n\tval8 = rtw_read8(padapter, bcn_ctrl_reg);\n\tval8 |= DIS_BCNQ_SUB;\n\trtw_write8(padapter, bcn_ctrl_reg, val8);\n}\n\nvoid rtl8723b_GetHalODMVar(\n\tPADAPTER\t\t\t\tAdapter,\n\tHAL_ODM_VARIABLE\t\teVariable,\n\tPVOID\t\t\t\t\tpValue1,\n\tPVOID\t\t\t\t\tpValue2)\n{\n\tHAL_DATA_TYPE\t*pHalData = GET_HAL_DATA(Adapter);\n\tPDM_ODM_T podmpriv = &pHalData->odmpriv;\n\tswitch(eVariable){\n\t\tdefault:\n\t\t\tGetHalODMVar(Adapter,eVariable,pValue1,pValue2);\n\t\t\tbreak;\n\t}\n}\n\nvoid rtl8723b_SetHalODMVar(\n\tPADAPTER\t\t\t\tAdapter,\n\tHAL_ODM_VARIABLE\t\teVariable,\n\tPVOID\t\t\t\t\tpValue1,\n\tBOOLEAN\t\t\t\t\tbSet)\n{\n\tHAL_DATA_TYPE\t*pHalData = GET_HAL_DATA(Adapter);\n\tPDM_ODM_T podmpriv = &pHalData->odmpriv;\n\tswitch(eVariable){\t\t\n\t\tdefault:\n\t\t\tSetHalODMVar(Adapter,eVariable,pValue1,bSet);\n\t\t\tbreak;\n\t}\n}\nvoid hal_notch_filter_8723b(_adapter *adapter, bool enable)\n{\n\tif (enable) {\n\t\tDBG_871X(\"Enable notch filter\\n\");\n\t\trtw_write8(adapter, rOFDM0_RxDSP+1, rtw_read8(adapter, rOFDM0_RxDSP+1) | BIT1);\n\t} else {\n\t\tDBG_871X(\"Disable notch filter\\n\");\n\t\trtw_write8(adapter, rOFDM0_RxDSP+1, rtw_read8(adapter, rOFDM0_RxDSP+1) & ~BIT1);\n\t}\n}\n\nu8 rtl8723b_MRateIdxToARFRId(PADAPTER padapter, u8 rate_idx)\n{\n\tu8 ret = 0;\n\tRT_RF_TYPE_DEF_E rftype = (RT_RF_TYPE_DEF_E)GET_RF_TYPE(padapter);\n\tswitch(rate_idx){\n\n\tcase RATR_INX_WIRELESS_NGB:\n\t\tif(rftype == RF_1T1R)\n\t\t\tret = 1;\n\t\telse \n\t\t\tret = 0;\n\t\tbreak;\n\n\tcase RATR_INX_WIRELESS_N:\n\tcase RATR_INX_WIRELESS_NG:\n\t\tif(rftype == RF_1T1R)\n\t\t\tret = 5;\n\t\telse\n\t\t\tret = 4;\n\t\tbreak;\n\n\tcase RATR_INX_WIRELESS_NB:\n\t\tif(rftype == RF_1T1R)\n\t\t\tret = 3;\n\t\telse \n\t\t\tret = 2;\n\t\tbreak;\n\n\tcase RATR_INX_WIRELESS_GB:\n\t\tret = 6;\n\t\tbreak;\n\n\tcase RATR_INX_WIRELESS_G:\n\t\tret = 7;\n\t\tbreak;\t\n\n\tcase RATR_INX_WIRELESS_B:\n\t\tret = 8;\n\t\tbreak;\n\n\tcase RATR_INX_WIRELESS_MC:\n\t\tif(padapter->mlmeextpriv.cur_wireless_mode & WIRELESS_11BG_24N)\n\t\t\tret = 6;\n\t\telse\n\t\t\tret = 7;\n\t\tbreak;\n\tcase RATR_INX_WIRELESS_AC_N:\n\t\tif(rftype == RF_1T1R)// || padapter->MgntInfo.VHTHighestOperaRate <= MGN_VHT1SS_MCS9)\n\t\t\tret = 10;\n\t\telse\n\t\t\tret = 9;\n\t\tbreak;\n\n\tdefault:\n\t\tret = 0;\n\t\tbreak;\n\t}\t\n\n\treturn ret;\n}\n\nvoid UpdateHalRAMask8723B(PADAPTER padapter, u32 mac_id, u8 rssi_level)\n{\n\tu32\tmask,rate_bitmap;\n\tu8\tshortGIrate = _FALSE;\n\tstruct sta_info\t*psta;\n\tHAL_DATA_TYPE\t*pHalData = GET_HAL_DATA(padapter);\n\tstruct mlme_ext_priv\t*pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info\t*pmlmeinfo = &(pmlmeext->mlmext_info);\n\n\tDBG_871X(\"%s(): mac_id=%d rssi_level=%d\\n\", __func__, mac_id, rssi_level);\n\n\tif (mac_id >= NUM_STA) //CAM_SIZE\n\t{\n\t\treturn;\n\t}\n\n\tpsta = pmlmeinfo->FW_sta_info[mac_id].psta;\n\tif(psta == NULL)\n\t{\n\t\treturn;\n\t}\n\n\tshortGIrate = query_ra_short_GI(psta);\n\n\tmask = psta->ra_mask;\n\n\trate_bitmap = 0xffffffff;\t\t\t\t\t\n\trate_bitmap = ODM_Get_Rate_Bitmap(&pHalData->odmpriv,mac_id,mask,rssi_level);\n\tDBG_871X(\"%s => mac_id:%d, networkType:0x%02x, mask:0x%08x\\n\\t ==> rssi_level:%d, rate_bitmap:0x%08x\\n\",\n\t\t\t__FUNCTION__,mac_id,psta->wireless_mode,mask,rssi_level,rate_bitmap);\n\n\tmask &= rate_bitmap;\n\n#ifdef CONFIG_BT_COEXIST\n\trate_bitmap = rtw_btcoex_GetRaMask(padapter);\n\tmask &= ~rate_bitmap;\n#endif // CONFIG_BT_COEXIST\n\n#ifdef CONFIG_CMCC_TEST\n#ifdef CONFIG_BT_COEXIST\n\tif(pmlmeext->cur_wireless_mode & WIRELESS_11G) {\n\t\tif (mac_id == 0) {\n\t\t\tDBG_871X(\"CMCC_BT update raid entry, mask=0x%x\\n\", mask);\n\t\t\t//mask &=0xffffffc0; //disable CCK & <12M OFDM rate for 11G mode for CMCC\n\t\t\tmask &=0xffffff00; //disable CCK & <24M OFDM rate for 11G mode for CMCC\n\t\t\tDBG_871X(\"CMCC_BT update raid entry, mask=0x%x\\n\", mask);\n\t\t}\n\t}\n#endif\n#endif\n\n\tif(pHalData->fw_ractrl == _TRUE)\n\t{\n\t\trtl8723b_set_FwMacIdConfig_cmd(padapter, mac_id, psta->raid, psta->bw_mode, shortGIrate, mask);\n\t}\n\n\t//set correct initial date rate for each mac_id\n\tpHalData->INIDATA_RATE[mac_id] = psta->init_rate;\n\tDBG_871X(\"%s(): mac_id=%d raid=0x%x bw=%d mask=0x%x init_rate=0x%x\\n\", __func__, mac_id, psta->raid, psta->bw_mode, mask, psta->init_rate);\n}\n\n#if defined(CONFIG_USB_HCI) || defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)\nvoid rtl8723b_cal_txdesc_chksum(struct tx_desc *ptxdesc)\n{\n\tu16\t*usPtr = (u16*)ptxdesc;\n\tu32 count;\n\tu32 index;\n\tu16 checksum = 0;\n\n\n\t// Clear first\n\tptxdesc->txdw7 &= cpu_to_le32(0xffff0000);\n\n\t// checksume is always calculated by first 32 bytes,\n\t// and it doesn't depend on TX DESC length.\n\t// Thomas,Lucas@SD4,20130515\n\tcount = 16;\n\n\tfor (index = 0; index < count; index++) {\n\t\tchecksum ^= le16_to_cpu(*(usPtr + index));\n\t}\n\n\tptxdesc->txdw7 |= cpu_to_le32(checksum & 0x0000ffff);\n}\n#endif\n\n\n//\n// Description: In normal chip, we should send some packet to Hw which will be used by Fw\n//\t\t\tin FW LPS mode. The function is to fill the Tx descriptor of this packets, then\n//\t\t\tFw can tell Hw to send these packet derectly.\n// Added by tynli. 2009.10.15.\n//\n//type1:pspoll, type2:null\nvoid rtl8723b_fill_fake_txdesc(\n\tPADAPTER\tpadapter,\n\tu8*\t\t\tpDesc,\n\tu32\t\t\tBufferLen,\n\tu8\t\t\tIsPsPoll,\n\tu8\t\t\tIsBTQosNull,\n\tu8\t\t\tbDataFrame)\n{\n\t// Clear all status\n\t_rtw_memset(pDesc, 0, TXDESC_SIZE);\n\n\tSET_TX_DESC_FIRST_SEG_8723B(pDesc, 1); //bFirstSeg;\n\tSET_TX_DESC_LAST_SEG_8723B(pDesc, 1); //bLastSeg;\n\n\tSET_TX_DESC_OFFSET_8723B(pDesc, 0x28); // Offset = 32\n\n\tSET_TX_DESC_PKT_SIZE_8723B(pDesc, BufferLen); // Buffer size + command header\n\tSET_TX_DESC_QUEUE_SEL_8723B(pDesc, QSLT_MGNT); // Fixed queue of Mgnt queue\n\n\t// Set NAVUSEHDR to prevent Ps-poll AId filed to be changed to error vlaue by Hw.\n\tif (_TRUE == IsPsPoll)\n\t{\n\t\tSET_TX_DESC_NAV_USE_HDR_8723B(pDesc, 1);\n\t}\n\telse\n\t{\n\t\tSET_TX_DESC_HWSEQ_EN_8723B(pDesc, 1); // Hw set sequence number\n\t\tSET_TX_DESC_HWSEQ_SEL_8723B(pDesc, 0);\n\t}\n\n\tif (_TRUE ==IsBTQosNull)\n\t{\n\t\tSET_TX_DESC_BT_INT_8723B(pDesc, 1);\n\t}\n\n\tSET_TX_DESC_USE_RATE_8723B(pDesc, 1); // use data rate which is set by Sw\n\tSET_TX_DESC_OWN_8723B((pu1Byte)pDesc, 1);\n\n\tSET_TX_DESC_TX_RATE_8723B(pDesc, DESC8723B_RATE1M);\n\n\t//\n\t// Encrypt the data frame if under security mode excepct null data. Suggested by CCW.\n\t//\n\tif (_TRUE ==bDataFrame)\n\t{\n\t\tu32 EncAlg;\n\n\t\tEncAlg = padapter->securitypriv.dot11PrivacyAlgrthm;\n\t\tswitch (EncAlg)\n\t\t{\n\t\t\tcase _NO_PRIVACY_:\n\t\t\t\tSET_TX_DESC_SEC_TYPE_8723B(pDesc, 0x0); \n\t\t\t\tbreak;\n\t\t\tcase _WEP40_:\n\t\t\tcase _WEP104_:\n\t\t\tcase _TKIP_:\n\t\t\t\tSET_TX_DESC_SEC_TYPE_8723B(pDesc, 0x1); \n\t\t\t\tbreak;\n\t\t\tcase _SMS4_:\n\t\t\t\tSET_TX_DESC_SEC_TYPE_8723B(pDesc, 0x2); \n\t\t\t\tbreak;\n\t\t\tcase _AES_:\n\t\t\t\tSET_TX_DESC_SEC_TYPE_8723B(pDesc, 0x3);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tSET_TX_DESC_SEC_TYPE_8723B(pDesc, 0x0); \n\t\t\t\tbreak;\t \n\t\t}\n\t}\n\n#if defined(CONFIG_USB_HCI) || defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)\n\t// USB interface drop packet if the checksum of descriptor isn't correct.\n\t// Using this checksum can let hardware recovery from packet bulk out error (e.g. Cancel URC, Bulk out error.).\n\trtl8723b_cal_txdesc_chksum((struct tx_desc*)pDesc);\n#endif\n}\n\nvoid rtl8723b_set_hal_ops(struct hal_ops *pHalFunc)\n{\n\tpHalFunc->dm_init = &rtl8723b_init_dm_priv;\n\tpHalFunc->dm_deinit = &rtl8723b_deinit_dm_priv;\n\n\tpHalFunc->read_chip_version = read_chip_version_8723b;\n\n\tpHalFunc->UpdateRAMaskHandler = &UpdateHalRAMask8723B;\n\n\tpHalFunc->set_bwmode_handler = &PHY_SetBWMode8723B;\n\tpHalFunc->set_channel_handler = &PHY_SwChnl8723B;\n\tpHalFunc->set_chnl_bw_handler = &PHY_SetSwChnlBWMode8723B;\n\n\tpHalFunc->set_tx_power_level_handler = &PHY_SetTxPowerLevel8723B;\n\tpHalFunc->get_tx_power_level_handler = &PHY_GetTxPowerLevel8723B;\n\n\tpHalFunc->hal_dm_watchdog = &rtl8723b_HalDmWatchDog;\n#ifdef CONFIG_LPS_LCLK_WD_TIMER\n\tpHalFunc->hal_dm_watchdog_in_lps = &rtl8723b_HalDmWatchDog_in_LPS;\n#endif\n\n#ifdef CONFIG_C2H_PACKET_EN\n\tpHalFunc->SetHwRegHandlerWithBuf = &SetHwRegWithBuf8723B;\n#endif // CONFIG_C2H_PACKET_EN\n\t\n\tpHalFunc->SetBeaconRelatedRegistersHandler = &rtl8723b_SetBeaconRelatedRegisters;\n\n\tpHalFunc->Add_RateATid = &rtl8723b_Add_RateATid;\n\n\tpHalFunc->run_thread= &rtl8723b_start_thread;\n\tpHalFunc->cancel_thread= &rtl8723b_stop_thread;\n\n\tpHalFunc->read_bbreg = &PHY_QueryBBReg_8723B;\n\tpHalFunc->write_bbreg = &PHY_SetBBReg_8723B;\n\tpHalFunc->read_rfreg = &PHY_QueryRFReg_8723B;\n\tpHalFunc->write_rfreg = &PHY_SetRFReg_8723B;\n\n\t// Efuse related function\n\tpHalFunc->BTEfusePowerSwitch = &Hal_BT_EfusePowerSwitch;\n\tpHalFunc->EfusePowerSwitch = &Hal_EfusePowerSwitch;\n\tpHalFunc->ReadEFuse = &Hal_ReadEFuse;\n\tpHalFunc->EFUSEGetEfuseDefinition = &Hal_GetEfuseDefinition;\n\tpHalFunc->EfuseGetCurrentSize = &Hal_EfuseGetCurrentSize;\n\tpHalFunc->Efuse_PgPacketRead = &Hal_EfusePgPacketRead;\n\tpHalFunc->Efuse_PgPacketWrite = &Hal_EfusePgPacketWrite;\n\tpHalFunc->Efuse_WordEnableDataWrite = &Hal_EfuseWordEnableDataWrite;\n\tpHalFunc->Efuse_PgPacketWrite_BT = &Hal_EfusePgPacketWrite_BT;\n\n#ifdef DBG_CONFIG_ERROR_DETECT\n\tpHalFunc->sreset_init_value = &sreset_init_value;\n\tpHalFunc->sreset_reset_value = &sreset_reset_value;\n\tpHalFunc->silentreset = &sreset_reset;\n\tpHalFunc->sreset_xmit_status_check = &rtl8723b_sreset_xmit_status_check;\n\tpHalFunc->sreset_linked_status_check  = &rtl8723b_sreset_linked_status_check;\n\tpHalFunc->sreset_get_wifi_status  = &sreset_get_wifi_status;\n\tpHalFunc->sreset_inprogress= &sreset_inprogress;\n#endif\n\tpHalFunc->GetHalODMVarHandler = &rtl8723b_GetHalODMVar;\n\tpHalFunc->SetHalODMVarHandler = &rtl8723b_SetHalODMVar;\n\n#ifdef CONFIG_XMIT_THREAD_MODE\n\tpHalFunc->xmit_thread_handler = &hal_xmit_handler;\n#endif\n\tpHalFunc->hal_notch_filter = &hal_notch_filter_8723b;\n\n\tpHalFunc->c2h_handler = c2h_handler_8723b;\n\tpHalFunc->c2h_id_filter_ccx = c2h_id_filter_ccx_8723b;\n\n\tpHalFunc->fill_h2c_cmd = &FillH2CCmd8723B;\n\tpHalFunc->fill_fake_txdesc = &rtl8723b_fill_fake_txdesc;\n#ifdef CONFIG_WOWLAN\n\tpHalFunc->hal_set_wowlan_fw = &SetFwRelatedForWoWLAN8723b;\n#endif\n\tpHalFunc->hal_get_tx_buff_rsvd_page_num = &GetTxBufferRsvdPageNum8723B;\n}\n\nvoid rtl8723b_InitAntenna_Selection(PADAPTER padapter)\n{\n\tPHAL_DATA_TYPE pHalData;\n\tu8 val;\n\n\n\tpHalData = GET_HAL_DATA(padapter);\n\n\tval = rtw_read8(padapter, REG_LEDCFG2);\n\t// Let 8051 take control antenna settting\n\tval |= BIT(7); // DPDT_SEL_EN, 0x4C[23]\n\trtw_write8(padapter, REG_LEDCFG2, val);\n}\n\nvoid rtl8723b_CheckAntenna_Selection(PADAPTER padapter)\n{\n\tPHAL_DATA_TYPE pHalData;\n\tu8 val;\n\n\n\tpHalData = GET_HAL_DATA(padapter);\n\n\tval = rtw_read8(padapter, REG_LEDCFG2);\n\t// Let 8051 take control antenna settting\n\tif(!(val &BIT(7))){\n\t\tval |= BIT(7); // DPDT_SEL_EN, 0x4C[23]\n\t\trtw_write8(padapter, REG_LEDCFG2, val);\n\t}\n}\nvoid rtl8723b_DeinitAntenna_Selection(PADAPTER padapter)\n{\n\tPHAL_DATA_TYPE pHalData;\n\tu8 val;\n\n\n\tpHalData = GET_HAL_DATA(padapter);\n\tval = rtw_read8(padapter, REG_LEDCFG2);\n\t// Let 8051 take control antenna settting\n\tval &= ~BIT(7); // DPDT_SEL_EN, clear 0x4C[23]\n\trtw_write8(padapter, REG_LEDCFG2, val);\n\n}\n\nvoid rtl8723b_init_default_value(PADAPTER padapter)\n{\n\tPHAL_DATA_TYPE pHalData; \n\tu8 i;\n\tpHalData = GET_HAL_DATA(padapter);\n\n\tpadapter->registrypriv.wireless_mode = WIRELESS_11BG_24N;\n\n\t// init default value\n\tpHalData->fw_ractrl = _FALSE;\n\tif (!adapter_to_pwrctl(padapter)->bkeepfwalive)\n\t\tpHalData->LastHMEBoxNum = 0;\n\n\t/* hal capability values */\n\tpHalData->macid_num = MACID_NUM_8723B;\n\tpHalData->cam_entry_num = CAM_ENTRY_NUM_8723B;\n\n\t//init phydm default value\n\tpHalData->bIQKInitialized = _FALSE;\n\tpHalData->odmpriv.RFCalibrateInfo.TM_Trigger = 0;//for IQK\n\tpHalData->odmpriv.RFCalibrateInfo.ThermalValue_HP_index = 0;\n\tfor(i = 0; i < HP_THERMAL_NUM; i++)\n\t\tpHalData->odmpriv.RFCalibrateInfo.ThermalValue_HP[i] = 0;\n\n\t// init Efuse variables\n\tpHalData->EfuseUsedBytes = 0;\n\tpHalData->EfuseUsedPercentage = 0;\n#ifdef HAL_EFUSE_MEMORY\n\tpHalData->EfuseHal.fakeEfuseBank = 0;\n\tpHalData->EfuseHal.fakeEfuseUsedBytes = 0;\n\t_rtw_memset(pHalData->EfuseHal.fakeEfuseContent, 0xFF, EFUSE_MAX_HW_SIZE);\n\t_rtw_memset(pHalData->EfuseHal.fakeEfuseInitMap, 0xFF, EFUSE_MAX_MAP_LEN);\n\t_rtw_memset(pHalData->EfuseHal.fakeEfuseModifiedMap, 0xFF, EFUSE_MAX_MAP_LEN);\n\tpHalData->EfuseHal.BTEfuseUsedBytes = 0;\n\tpHalData->EfuseHal.BTEfuseUsedPercentage = 0;\n\t_rtw_memset(pHalData->EfuseHal.BTEfuseContent, 0xFF, EFUSE_MAX_BT_BANK*EFUSE_MAX_HW_SIZE);\n\t_rtw_memset(pHalData->EfuseHal.BTEfuseInitMap, 0xFF, EFUSE_BT_MAX_MAP_LEN);\n\t_rtw_memset(pHalData->EfuseHal.BTEfuseModifiedMap, 0xFF, EFUSE_BT_MAX_MAP_LEN);\n\tpHalData->EfuseHal.fakeBTEfuseUsedBytes = 0;\n\t_rtw_memset(pHalData->EfuseHal.fakeBTEfuseContent, 0xFF, EFUSE_MAX_BT_BANK*EFUSE_MAX_HW_SIZE);\n\t_rtw_memset(pHalData->EfuseHal.fakeBTEfuseInitMap, 0xFF, EFUSE_BT_MAX_MAP_LEN);\n\t_rtw_memset(pHalData->EfuseHal.fakeBTEfuseModifiedMap, 0xFF, EFUSE_BT_MAX_MAP_LEN);\n#endif\n}\n\nu8 GetEEPROMSize8723B(PADAPTER padapter)\n{\n\tu8 size = 0;\n\tu32\tcr;\n\n\tcr = rtw_read16(padapter, REG_9346CR);\n\t// 6: EEPROM used is 93C46, 4: boot from E-Fuse.\n\tsize = (cr & BOOT_FROM_EEPROM) ? 6 : 4;\n\n\tMSG_8192C(\"EEPROM type is %s\\n\", size==4 ? \"E-FUSE\" : \"93C46\");\n\n\treturn size;\n}\n\n//-------------------------------------------------------------------------\n//\n// LLT R/W/Init function\n//\n//-------------------------------------------------------------------------\ns32 rtl8723b_InitLLTTable(PADAPTER padapter)\n{\n\tu32 start, passing_time;\n\tu32 val32;\n\ts32 ret;\n\n\n\tret = _FAIL;\n\n\tval32 = rtw_read32(padapter, REG_AUTO_LLT);\n\tval32 |= BIT_AUTO_INIT_LLT;\n\trtw_write32(padapter, REG_AUTO_LLT, val32);\n\n\tstart = rtw_get_current_time();\n\n\tdo {\n\t\tval32 = rtw_read32(padapter, REG_AUTO_LLT);\n\t\tif (!(val32 & BIT_AUTO_INIT_LLT))\n\t\t{\n\t\t\tret = _SUCCESS;\n\t\t\tbreak;\n\t\t}\n\n\t\tpassing_time = rtw_get_passing_time_ms(start);\n\t\tif (passing_time > 1000)\n\t\t{\n\t\t\tDBG_8192C(\"%s: FAIL!! REG_AUTO_LLT(0x%X)=%08x\\n\",\n\t\t\t\t__FUNCTION__, REG_AUTO_LLT, val32);\n\t\t\tbreak;\n\t\t}\n\n\t\trtw_usleep_os(2);\n\t} while(1);\n\n\treturn ret;\n}\n\n#if defined(CONFIG_USB_HCI) || defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)\nvoid _DisableGPIO(PADAPTER\tpadapter)\n{\n/***************************************\nj. GPIO_PIN_CTRL 0x44[31:0]=0x000\t\t//\nk.Value = GPIO_PIN_CTRL[7:0]\nl. GPIO_PIN_CTRL 0x44[31:0] = 0x00FF0000 | (value <<8); //write external PIN level\nm. GPIO_MUXCFG 0x42 [15:0] = 0x0780\nn. LEDCFG 0x4C[15:0] = 0x8080\n***************************************/\n\tu8\tvalue8;\n\tu16\tvalue16;\n\tu32\tvalue32;\n\tu32\tu4bTmp;\n\n\n\t//1. Disable GPIO[7:0]\n\trtw_write16(padapter, REG_GPIO_PIN_CTRL+2, 0x0000);\n\tvalue32 = rtw_read32(padapter, REG_GPIO_PIN_CTRL) & 0xFFFF00FF;\n\tu4bTmp = value32 & 0x000000FF;\n\tvalue32 |= ((u4bTmp<<8) | 0x00FF0000);\n\trtw_write32(padapter, REG_GPIO_PIN_CTRL, value32);\n\n\t\n\t//2. Disable GPIO[10:8]\n\trtw_write8(padapter, REG_MAC_PINMUX_CFG, 0x00);\n\tvalue16 = rtw_read16(padapter, REG_GPIO_IO_SEL) & 0xFF0F;\n\tvalue8 = (u8) (value16&0x000F);\n\tvalue16 |= ((value8<<4) | 0x0780);\n\trtw_write16(padapter, REG_GPIO_IO_SEL, value16);\n\t\n\n\t//3. Disable LED0 & 1\n\trtw_write16(padapter, REG_LEDCFG0, 0x8080);\n\t\n//\tRT_TRACE(COMP_INIT, DBG_LOUD, (\"======> Disable GPIO and LED.\\n\"));\n} //end of _DisableGPIO()\n\nvoid _DisableRFAFEAndResetBB8723B(PADAPTER padapter)\n{\n/**************************************\na.\tTXPAUSE 0x522[7:0] = 0xFF             //Pause MAC TX queue\nb.\tRF path 0 offset 0x00 = 0x00            // disable RF\nc. \tAPSD_CTRL 0x600[7:0] = 0x40\nd.\tSYS_FUNC_EN 0x02[7:0] = 0x16\t\t//reset BB state machine\ne.\tSYS_FUNC_EN 0x02[7:0] = 0x14\t\t//reset BB state machine\n***************************************/\n    \tu8 eRFPath = 0, value8 = 0;\n\n\trtw_write8(padapter, REG_TXPAUSE, 0xFF);\n\n\tPHY_SetRFReg(padapter, (RF_PATH)eRFPath, 0x0, bMaskByte0, 0x0);\n\n\tvalue8 |= APSDOFF;\n\trtw_write8(padapter, REG_APSD_CTRL, value8);//0x40\n\n\t// Set BB reset at first\n\tvalue8 = 0 ;\n\tvalue8 |= (FEN_USBD | FEN_USBA | FEN_BB_GLB_RSTn);\n\trtw_write8(padapter, REG_SYS_FUNC_EN, value8 );//0x16\n\n\t// Set global reset.\n\tvalue8 &= ~FEN_BB_GLB_RSTn;\n\trtw_write8(padapter, REG_SYS_FUNC_EN, value8); //0x14\n\n\t// 2010/08/12 MH We need to set BB/GLBAL reset to save power for SS mode.\n\n//\tRT_TRACE(COMP_INIT, DBG_LOUD, (\"======> RF off and reset BB.\\n\"));\n}\n\nvoid _DisableRFAFEAndResetBB(PADAPTER padapter)\n{\n\t_DisableRFAFEAndResetBB8723B(padapter);\n}\n\nvoid _ResetDigitalProcedure1_8723B(PADAPTER padapter, BOOLEAN bWithoutHWSM)\n{\n\tHAL_DATA_TYPE\t*pHalData = GET_HAL_DATA(padapter);\n\n\tif (IS_FW_81xxC(padapter) && (pHalData->FirmwareVersion <= 0x20))\n\t{\n\t\t#if 0\n/*****************************\n\t\tf.\tSYS_FUNC_EN 0x03[7:0]=0x54\t\t// reset MAC register, DCORE\n\t\tg.\tMCUFWDL 0x80[7:0]=0\t\t\t\t// reset MCU ready status\n******************************/\n\tu32\tvalue32 = 0;\n\t\trtw_write8(padapter, REG_SYS_FUNC_EN+1, 0x54);\n\t\trtw_write8(padapter, REG_MCUFWDL, 0);\n\t\t#else\n\t\t/*****************************\n\t\tf.\tMCUFWDL 0x80[7:0]=0\t\t\t\t// reset MCU ready status\n\t\tg.\tSYS_FUNC_EN 0x02[10]= 0\t\t\t// reset MCU register, (8051 reset)\n\t\th.\tSYS_FUNC_EN 0x02[15-12]= 5\t\t// reset MAC register, DCORE\n\t\ti.     SYS_FUNC_EN 0x02[10]= 1\t\t\t// enable MCU register, (8051 enable)\n\t\t******************************/\n\t\t\tu16 valu16 = 0;\n\t\t\trtw_write8(padapter, REG_MCUFWDL, 0);\n\n\t\t\tvalu16 = rtw_read16(padapter, REG_SYS_FUNC_EN);\n\t\t\trtw_write16(padapter, REG_SYS_FUNC_EN, (valu16 & (~FEN_CPUEN)));//reset MCU ,8051\n\n\t\t\tvalu16 = rtw_read16(padapter, REG_SYS_FUNC_EN)&0x0FFF;\n\t\t\trtw_write16(padapter, REG_SYS_FUNC_EN, (valu16 |(FEN_HWPDN|FEN_ELDR)));//reset MAC\n\n\t\t\tvalu16 = rtw_read16(padapter, REG_SYS_FUNC_EN);\n\t\t\trtw_write16(padapter, REG_SYS_FUNC_EN, (valu16 | FEN_CPUEN));//enable MCU ,8051\n\t\t#endif\n\t}\n\telse\n\t{\n\t\tu8 retry_cnts = 0;\n\n\t\t// 2010/08/12 MH For USB SS, we can not stop 8051 when we are trying to\n\t\t// enter IPS/HW&SW radio off. For S3/S4/S5/Disable, we can stop 8051 because\n\t\t// we will init FW when power on again.\n\t\t//if(!pDevice->RegUsbSS)\n\t\t{\t// If we want to SS mode, we can not reset 8051.\n\t\t\tif(rtw_read8(padapter, REG_MCUFWDL) & BIT1)\n\t\t\t{ //IF fw in RAM code, do reset\n\n\n\t\t\t\tif(padapter->bFWReady)\n\t\t\t\t{\n\t\t\t\t\t// 2010/08/25 MH Accordign to RD alfred's suggestion, we need to disable other\n\t\t\t\t\t// HRCV INT to influence 8051 reset.\n\t\t\t\t\trtw_write8(padapter, REG_FWIMR, 0x20);\n\t\t\t\t\t// 2011/02/15 MH According to Alex's suggestion, close mask to prevent incorrect FW write operation.\n\t\t\t\t\trtw_write8(padapter, REG_FTIMR, 0x00);\n\t\t\t\t\trtw_write8(padapter, REG_FSIMR, 0x00);\n\n\t\t\t\t\trtw_write8(padapter, REG_HMETFR+3, 0x20);//8051 reset by self\n\n\t\t\t\t\twhile( (retry_cnts++ <100) && (FEN_CPUEN &rtw_read16(padapter, REG_SYS_FUNC_EN)))\n\t\t\t\t\t{\n\t\t\t\t\t\trtw_udelay_os(50);//us\n\t\t\t\t\t\t// 2010/08/25 For test only We keep on reset 5051 to prevent fail.\n\t\t\t\t\t\t//rtw_write8(padapter, REG_HMETFR+3, 0x20);//8051 reset by self\n\t\t\t\t\t}\n//\t\t\t\t\tRT_ASSERT((retry_cnts < 100), (\"8051 reset failed!\\n\"));\n\n\t\t\t\t\tif (retry_cnts >= 100)\n\t\t\t\t\t{\n\t\t\t\t\t\t// if 8051 reset fail we trigger GPIO 0 for LA\n\t\t\t\t\t\t//rtw_write32(\tpadapter,\n\t\t\t\t\t\t//\t\t\t\t\t\tREG_GPIO_PIN_CTRL,\n\t\t\t\t\t\t//\t\t\t\t\t\t0x00010100);\n\t\t\t\t\t\t// 2010/08/31 MH According to Filen's info, if 8051 reset fail, reset MAC directly.\n\t\t\t\t\t\trtw_write8(padapter, REG_SYS_FUNC_EN+1, 0x50);\t//Reset MAC and Enable 8051\n\t\t\t\t\t\trtw_mdelay_os(10);\n\t\t\t\t\t}\n//\t\t\t\t\telse\n//\t\t\t\t\tRT_TRACE(COMP_INIT, DBG_LOUD, (\"=====> 8051 reset success (%d) .\\n\",retry_cnts));\n\t\t\t\t}\n\t\t\t}\n//\t\t\telse\n//\t\t\t{\n//\t\t\t\tRT_TRACE(COMP_INIT, DBG_LOUD, (\"=====> 8051 in ROM.\\n\"));\n//\t\t\t}\n\t\t\trtw_write8(padapter, REG_SYS_FUNC_EN+1, 0x54);\t//Reset MAC and Enable 8051\n\t\t\trtw_write8(padapter, REG_MCUFWDL, 0);\n\t\t}\n\t}\n\n\t//if(pDevice->RegUsbSS)\n\t\t//bWithoutHWSM = TRUE;\t// Sugest by Filen and Issau.\n\n\tif(bWithoutHWSM)\n\t{\n\t\t//HAL_DATA_TYPE\t\t*pHalData\t= GET_HAL_DATA(padapter);\n\t/*****************************\n\t\tWithout HW auto state machine\n\tg.\tSYS_CLKR 0x08[15:0] = 0x30A3\t\t\t//disable MAC clock\n\th.\tAFE_PLL_CTRL 0x28[7:0] = 0x80\t\t\t//disable AFE PLL\n\ti.\tAFE_XTAL_CTRL 0x24[15:0] = 0x880F\t\t//gated AFE DIG_CLOCK\n\tj.\tSYS_ISO_CTRL 0x00[7:0] = 0xF9\t\t\t// isolated digital to PON\n\t******************************/\n\t\t//rtw_write16(padapter, REG_SYS_CLKR, 0x30A3);\n\t\t//if(!pDevice->RegUsbSS)\n\t\t// 2011/01/26 MH SD4 Scott suggest to fix UNC-B cut bug.\n\t\trtw_write16(padapter, REG_SYS_CLKR, 0x70A3);  //modify to 0x70A3 by Scott.\n\t\trtw_write8(padapter, REG_AFE_PLL_CTRL, 0x80);\n\t\trtw_write16(padapter, REG_AFE_XTAL_CTRL, 0x880F);\n\t\t//if(!pDevice->RegUsbSS)\n\t\t\trtw_write8(padapter, REG_SYS_ISO_CTRL, 0xF9);\n\t}\n\telse\n\t{\n\t\t// Disable all RF/BB power\n\t\trtw_write8(padapter, REG_RF_CTRL, 0x00);\n\t}\n//\tRT_TRACE(COMP_INIT, DBG_LOUD, (\"======> Reset Digital.\\n\"));\n\n}\n\nvoid _ResetDigitalProcedure1(PADAPTER padapter, BOOLEAN bWithoutHWSM)\n{\n\t_ResetDigitalProcedure1_8723B(padapter, bWithoutHWSM);\n}\n\nvoid _ResetDigitalProcedure2(PADAPTER padapter)\n{\n\t//HAL_DATA_TYPE\t\t*pHalData\t= GET_HAL_DATA(padapter);\n/*****************************\nk.\tSYS_FUNC_EN 0x03[7:0] = 0x44\t\t\t// disable ELDR runction\nl.\tSYS_CLKR 0x08[15:0] = 0x3083\t\t\t// disable ELDR clock\nm.\tSYS_ISO_CTRL 0x01[7:0] = 0x83\t\t\t// isolated ELDR to PON\n******************************/\n\t//rtw_write8(padapter, REG_SYS_FUNC_EN+1, 0x44); //marked by Scott.\n\t// 2011/01/26 MH SD4 Scott suggest to fix UNC-B cut bug.\n\trtw_write16(padapter, REG_SYS_CLKR, 0x70a3); //modify to 0x70a3 by Scott.\n\trtw_write8(padapter, REG_SYS_ISO_CTRL+1, 0x82); //modify to 0x82 by Scott.\n}\n\nvoid _DisableAnalog(PADAPTER padapter, BOOLEAN bWithoutHWSM)\n{\n\tHAL_DATA_TYPE\t*pHalData\t= GET_HAL_DATA(padapter);\n\tu16 value16 = 0;\n\tu8 value8 = 0;\n\n\n\tif (bWithoutHWSM)\n\t{\n\t\t/*****************************\n\t\tn.\tLDOA15_CTRL 0x20[7:0] = 0x04\t\t// disable A15 power\n\t\to.\tLDOV12D_CTRL 0x21[7:0] = 0x54\t\t// disable digital core power\n\t\tr.\tWhen driver call disable, the ASIC will turn off remaining clock automatically\n\t\t******************************/\n\n\t\trtw_write8(padapter, REG_LDOA15_CTRL, 0x04);\n\t\t//rtw_write8(padapter, REG_LDOV12D_CTRL, 0x54);\n\n\t\tvalue8 = rtw_read8(padapter, REG_LDOV12D_CTRL);\n\t\tvalue8 &= (~LDV12_EN);\n\t\trtw_write8(padapter, REG_LDOV12D_CTRL, value8);\n//\t\tRT_TRACE(COMP_INIT, DBG_LOUD, (\" REG_LDOV12D_CTRL Reg0x21:0x%02x.\\n\",value8));\n\t}\n\n\t/*****************************\n\th.\tSPS0_CTRL 0x11[7:0] = 0x23\t\t\t//enter PFM mode\n\ti.\tAPS_FSMCO 0x04[15:0] = 0x4802\t\t// set USB suspend\n\t******************************/\n\tvalue8 = 0x23;\n\n\trtw_write8(padapter, REG_SPS0_CTRL, value8);\n\n\tif(bWithoutHWSM)\n\t{\n\t\t//value16 |= (APDM_HOST | /*AFSM_HSUS |*/PFM_ALDN);\n\t\t// 2010/08/31 According to Filen description, we need to use HW to shut down 8051 automatically.\n\t\t// Becasue suspend operatione need the asistance of 8051 to wait for 3ms.\n\t\tvalue16 |= (APDM_HOST | AFSM_HSUS | PFM_ALDN);\n\t}\n\telse\n\t{\n\t\tvalue16 |= (APDM_HOST | AFSM_HSUS | PFM_ALDN);\n\t}\n\n\trtw_write16(padapter, REG_APS_FSMCO, value16);//0x4802\n\n\trtw_write8(padapter, REG_RSV_CTRL, 0x0e);\n\n#if 0\n\t//tynli_test for suspend mode.\n\tif(!bWithoutHWSM){\n\t\trtw_write8(padapter, 0xfe10, 0x19);\n\t}\n#endif\n\n//\tRT_TRACE(COMP_INIT, DBG_LOUD, (\"======> Disable Analog Reg0x04:0x%04x.\\n\",value16));\n}\n\n// HW Auto state machine\ns32 CardDisableHWSM(PADAPTER padapter, u8 resetMCU)\n{\n\tint rtStatus = _SUCCESS;\n\n\n\tif (padapter->bSurpriseRemoved){\n\t\treturn rtStatus;\n\t}\n\t//==== RF Off Sequence ====\n\t_DisableRFAFEAndResetBB(padapter);\n\n\t//  ==== Reset digital sequence   ======\n\t_ResetDigitalProcedure1(padapter, _FALSE);\n\n\t//  ==== Pull GPIO PIN to balance level and LED control ======\n\t_DisableGPIO(padapter);\n\n\t//  ==== Disable analog sequence ===\n\t_DisableAnalog(padapter, _FALSE);\n\n\tRT_TRACE(_module_hci_hal_init_c_, _drv_info_, (\"======> Card disable finished.\\n\"));\n\n\treturn rtStatus;\n}\n\n// without HW Auto state machine\ns32 CardDisableWithoutHWSM(PADAPTER padapter)\n{\n\ts32 rtStatus = _SUCCESS;\n\n\n\t//RT_TRACE(COMP_INIT, DBG_LOUD, (\"======> Card Disable Without HWSM .\\n\"));\n\tif (padapter->bSurpriseRemoved) {\n\t\treturn rtStatus;\n\t}\n\n\t//==== RF Off Sequence ====\n\t_DisableRFAFEAndResetBB(padapter);\n\n\t//  ==== Reset digital sequence   ======\n\t_ResetDigitalProcedure1(padapter, _TRUE);\n\n\t//  ==== Pull GPIO PIN to balance level and LED control ======\n\t_DisableGPIO(padapter);\n\n\t//  ==== Reset digital sequence   ======\n\t_ResetDigitalProcedure2(padapter);\n\n\t//  ==== Disable analog sequence ===\n\t_DisableAnalog(padapter, _TRUE);\n\n\t//RT_TRACE(COMP_INIT, DBG_LOUD, (\"<====== Card Disable Without HWSM .\\n\"));\n\treturn rtStatus;\n}\n#endif // CONFIG_USB_HCI || CONFIG_SDIO_HCI || CONFIG_GSPI_HCI\n\nBOOLEAN \nHal_GetChnlGroup8723B(\n\tIN\tu8 Channel,\n\tOUT u8 *pGroup\n\t)\n{\n\tBOOLEAN bIn24G=TRUE;\n\n\tif(Channel <= 14)\n\t{\n\t\tbIn24G=TRUE;\n\n\t\tif      (1  <= Channel && Channel <= 2 )   *pGroup = 0;\n\t\telse if (3  <= Channel && Channel <= 5 )   *pGroup = 1;\n\t\telse if (6  <= Channel && Channel <= 8 )   *pGroup = 2;\n\t\telse if (9  <= Channel && Channel <= 11)   *pGroup = 3;\n\t\telse if (12 <= Channel && Channel <= 14)   *pGroup = 4;\n\t\telse\n\t\t{\n\t\t\tRT_TRACE(_module_hci_hal_init_c_, _drv_notice_,(\"==>Hal_GetChnlGroup8723B in 2.4 G, but Channel %d in Group not found \\n\", Channel));\n\t\t}\n\t}\n\telse\n\t{\n\t\tbIn24G=FALSE;\n\n\t\tif      (36   <= Channel && Channel <=  42)   *pGroup = 0;\n\t\telse if (44   <= Channel && Channel <=  48)   *pGroup = 1;\n\t\telse if (50   <= Channel && Channel <=  58)   *pGroup = 2;\n\t\telse if (60   <= Channel && Channel <=  64)   *pGroup = 3;\n\t\telse if (100  <= Channel && Channel <= 106)   *pGroup = 4;\n\t\telse if (108  <= Channel && Channel <= 114)   *pGroup = 5;\n\t\telse if (116  <= Channel && Channel <= 122)   *pGroup = 6;\n\t\telse if (124  <= Channel && Channel <= 130)   *pGroup = 7;\n\t\telse if (132  <= Channel && Channel <= 138)   *pGroup = 8;\n\t\telse if (140  <= Channel && Channel <= 144)   *pGroup = 9;\n\t\telse if (149  <= Channel && Channel <= 155)   *pGroup = 10;\n\t\telse if (157  <= Channel && Channel <= 161)   *pGroup = 11;\n\t\telse if (165  <= Channel && Channel <= 171)   *pGroup = 12;\n\t\telse if (173  <= Channel && Channel <= 177)   *pGroup = 13;\n\t\telse\n\t\t{\n\t\t\tRT_TRACE(_module_hci_hal_init_c_, _drv_notice_,(\"==>Hal_GetChnlGroup8723B in 5G, but Channel %d in Group not found \\n\",Channel));\n\t\t}\n\n\t}\n\tRT_TRACE(_module_hci_hal_init_c_, _drv_info_, (\"<==Hal_GetChnlGroup8723B,  (%s) Channel = %d, Group =%d,\\n\", \n                                  (bIn24G) ? \"2.4G\" : \"5G\", Channel, *pGroup));\n\treturn bIn24G;\n}\n\nvoid\nHal_InitPGData(\n\tPADAPTER\tpadapter,\n\tu8\t\t\t*PROMContent)\n{\n\n\tHAL_DATA_TYPE\t*pHalData = GET_HAL_DATA(padapter);\n\tu32\t\t\ti;\n\tu16\t\t\tvalue16;\n\n\tif(_FALSE == pHalData->bautoload_fail_flag)\n\t{ // autoload OK.\n//\t\tif (IS_BOOT_FROM_EEPROM(padapter))\n\t\tif (_TRUE == pHalData->EepromOrEfuse)\n\t\t{\n\t\t\t// Read all Content from EEPROM or EFUSE.\n\t\t\tfor(i = 0; i < HWSET_MAX_SIZE_8723B; i += 2)\n\t\t\t{\n//\t\t\t\tvalue16 = EF2Byte(ReadEEprom(pAdapter, (u2Byte) (i>>1)));\n//\t\t\t\t*((u16*)(&PROMContent[i])) = value16;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Read EFUSE real map to shadow.\n\t\t\tEFUSE_ShadowMapUpdate(padapter, EFUSE_WIFI, _FALSE);\n\t\t\t_rtw_memcpy((void*)PROMContent, (void*)pHalData->efuse_eeprom_data, HWSET_MAX_SIZE_8723B);\n\t\t}\n\t}\n\telse\n\t{//autoload fail\n\t\tRT_TRACE(_module_hci_hal_init_c_, _drv_notice_, (\"AutoLoad Fail reported from CR9346!!\\n\"));\n//\t\tpHalData->AutoloadFailFlag = _TRUE;\n\t\t//update to default value 0xFF\n\t\tif (_FALSE == pHalData->EepromOrEfuse)\n\t\t\tEFUSE_ShadowMapUpdate(padapter, EFUSE_WIFI, _FALSE);\n\t\t_rtw_memcpy((void*)PROMContent, (void*)pHalData->efuse_eeprom_data, HWSET_MAX_SIZE_8723B);\n\t}\n}\n\nvoid\nHal_EfuseParseIDCode(\n\tIN\tPADAPTER\tpadapter,\n\tIN\tu8\t\t\t*hwinfo\n\t)\n{\n\tHAL_DATA_TYPE\t*pHalData = GET_HAL_DATA(padapter);\n\tu16\t\t\tEEPROMId;\n\n\n\t// Checl 0x8129 again for making sure autoload status!!\n\tEEPROMId = le16_to_cpu(*((u16*)hwinfo));\n\tif (EEPROMId != RTL_EEPROM_ID)\n\t{\n\t\tDBG_8192C(\"EEPROM ID(%#x) is invalid!!\\n\", EEPROMId);\n\t\tpHalData->bautoload_fail_flag = _TRUE;\n\t}\n\telse\n\t{\n\t\tpHalData->bautoload_fail_flag = _FALSE;\n\t}\n\n\tRT_TRACE(_module_hal_init_c_, _drv_notice_, (\"EEPROM ID=0x%04x\\n\", EEPROMId));\n}\n\nstatic void\nHal_EEValueCheck(\n\tIN\t\tu8\t\tEEType,\n\tIN\t\tPVOID\t\tpInValue,\n\tOUT\t\tPVOID\t\tpOutValue\n\t)\n{\n\tswitch(EEType)\n\t{\n\t\tcase EETYPE_TX_PWR:\n\t\t\t{\n\t\t\t\tu8\t*pIn, *pOut;\n\t\t\t\tpIn = (u8*)pInValue;\n\t\t\t\tpOut = (u8*)pOutValue;\n\t\t\t\tif(*pIn <= 63)\n\t\t\t\t{\n\t\t\t\t\t*pOut = *pIn;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tRT_TRACE(_module_hci_hal_init_c_, _drv_err_, (\"EETYPE_TX_PWR, value=%d is invalid, set to default=0x%x\\n\",\n\t\t\t\t\t\t*pIn, EEPROM_Default_TxPowerLevel));\n\t\t\t\t\t*pOut = EEPROM_Default_TxPowerLevel;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n}\n\nstatic u8\nHal_GetChnlGroup(\n\tIN\tu8 chnl\n\t)\n{\n\tu8\tgroup=0;\n\n\tif (chnl < 3)\t\t\t// Cjanel 1-3\n\t\tgroup = 0;\n\telse if (chnl < 9)\t\t// Channel 4-9\n\t\tgroup = 1;\n\telse\t\t\t\t\t// Channel 10-14\n\t\tgroup = 2;\n\n\treturn group;\n}\n\nvoid \nHal_ReadPowerValueFromPROM_8723B(\n\tIN\tPADAPTER \t\tAdapter,\n\tIN\tPTxPowerInfo24G\tpwrInfo24G,\n\tIN\tu8 \t\t\t\t* PROMContent,\n\tIN\tBOOLEAN\t\t\tAutoLoadFail\n\t)\n{\n\tHAL_DATA_TYPE\t*pHalData = GET_HAL_DATA(Adapter);\n\tu4Byte rfPath, eeAddr=EEPROM_TX_PWR_INX_8723B, group,TxCount=0;\n\n\t_rtw_memset(pwrInfo24G, 0, sizeof(TxPowerInfo24G));\t\n\n\tif(0xFF == PROMContent[eeAddr+1])  \n\t\tAutoLoadFail = TRUE;\n\t\n\tif(AutoLoadFail)\n\t{\t\n\t\tDBG_871X(\"%s(): Use Default value!\\n\", __func__);\n\t\tfor(rfPath = 0 ; rfPath < MAX_RF_PATH ; rfPath++)\n\t\t{\n\t\t\t//2.4G default value\n\t\t\tfor(group = 0 ; group < MAX_CHNL_GROUP_24G; group++)\n\t\t\t{\n\t\t\t\tpwrInfo24G->IndexCCK_Base[rfPath][group] =\tEEPROM_DEFAULT_24G_INDEX;\n\t\t\t\tpwrInfo24G->IndexBW40_Base[rfPath][group] =\tEEPROM_DEFAULT_24G_INDEX;\n\t\t\t}\n\t\t\tfor(TxCount=0;TxCount<MAX_TX_COUNT;TxCount++)\n\t\t\t{\n\t\t\t\tif(TxCount==0)\n\t\t\t\t{\n\t\t\t\t\tpwrInfo24G->BW20_Diff[rfPath][0] =\tEEPROM_DEFAULT_24G_HT20_DIFF;\n\t\t\t\t\tpwrInfo24G->OFDM_Diff[rfPath][0] =\tEEPROM_DEFAULT_24G_OFDM_DIFF;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpwrInfo24G->BW20_Diff[rfPath][TxCount] =\tEEPROM_DEFAULT_DIFF;\n\t\t\t\t\tpwrInfo24G->BW40_Diff[rfPath][TxCount] =\tEEPROM_DEFAULT_DIFF;\n\t\t\t\t\tpwrInfo24G->CCK_Diff[rfPath][TxCount] =\tEEPROM_DEFAULT_DIFF;\n\t\t\t\t\tpwrInfo24G->OFDM_Diff[rfPath][TxCount] =\tEEPROM_DEFAULT_DIFF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn;\n\t}\t\n\n\tpHalData->bTXPowerDataReadFromEEPORM = TRUE;\t\t//YJ,move,120316\n\t\n\tfor(rfPath = 0 ; rfPath < MAX_RF_PATH ; rfPath++)\n\t{\n\t\t//2 2.4G default value\n\t\tfor(group = 0 ; group < MAX_CHNL_GROUP_24G; group++)\n\t\t{\n\t\t\tpwrInfo24G->IndexCCK_Base[rfPath][group] =\tPROMContent[eeAddr++];\n\t\t\tif(pwrInfo24G->IndexCCK_Base[rfPath][group] == 0xFF)\n\t\t\t{\n\t\t\t\tpwrInfo24G->IndexCCK_Base[rfPath][group] = EEPROM_DEFAULT_24G_INDEX;\n\t\t\t}\n\t\t}\n\t\tfor(group = 0 ; group < MAX_CHNL_GROUP_24G-1; group++)\n\t\t{\n\t\t\tpwrInfo24G->IndexBW40_Base[rfPath][group] =\tPROMContent[eeAddr++];\n\t\t\tif(pwrInfo24G->IndexBW40_Base[rfPath][group] == 0xFF)\n\t\t\t\tpwrInfo24G->IndexBW40_Base[rfPath][group] =\tEEPROM_DEFAULT_24G_INDEX;\n\t\t}\t\t\t\n\t\tfor(TxCount=0;TxCount<MAX_TX_COUNT;TxCount++)\n\t\t{\n\t\t\tif(TxCount==0)\n\t\t\t{\n\t\t\t\tpwrInfo24G->BW40_Diff[rfPath][TxCount] = 0;\n\t\t\t\tpwrInfo24G->BW20_Diff[rfPath][TxCount] = (PROMContent[eeAddr]&0xf0)>>4;\n\t\t\t\tif (pwrInfo24G->BW20_Diff[rfPath][TxCount] & BIT3)\t\t/*4bit sign number to 8 bit sign number*/\n\t\t\t\t\tpwrInfo24G->BW20_Diff[rfPath][TxCount] |= 0xF0;\n\n\t\t\t\tpwrInfo24G->OFDM_Diff[rfPath][TxCount] = (PROMContent[eeAddr]&0x0f);\n\t\t\t\tif (pwrInfo24G->OFDM_Diff[rfPath][TxCount] & BIT3)\t\t/*4bit sign number to 8 bit sign number*/\n\t\t\t\t\tpwrInfo24G->OFDM_Diff[rfPath][TxCount] |= 0xF0;\n\n\t\t\t\tpwrInfo24G->CCK_Diff[rfPath][TxCount] = 0;\n\t\t\t\teeAddr++;\n\t\t\t} else{\n\t\t\t\tpwrInfo24G->BW40_Diff[rfPath][TxCount] =\t(PROMContent[eeAddr]&0xf0)>>4;\n\t\t\t\tif (pwrInfo24G->BW40_Diff[rfPath][TxCount] & BIT3)\t\t/*4bit sign number to 8 bit sign number*/\n\t\t\t\t\tpwrInfo24G->BW40_Diff[rfPath][TxCount] |= 0xF0;\n\n\t\t\t\tpwrInfo24G->BW20_Diff[rfPath][TxCount] =\t(PROMContent[eeAddr]&0x0f);\n\t\t\t\tif (pwrInfo24G->BW20_Diff[rfPath][TxCount] & BIT3)\t\t/*4bit sign number to 8 bit sign number*/\n\t\t\t\t\tpwrInfo24G->BW20_Diff[rfPath][TxCount] |= 0xF0;\n\n\t\t\t\teeAddr++;\n\n\t\t\t\tpwrInfo24G->OFDM_Diff[rfPath][TxCount] =\t(PROMContent[eeAddr]&0xf0)>>4;\n\t\t\t\tif (pwrInfo24G->OFDM_Diff[rfPath][TxCount] & BIT3)\t\t/*4bit sign number to 8 bit sign number*/\n\t\t\t\t\tpwrInfo24G->OFDM_Diff[rfPath][TxCount] |= 0xF0;\n\n\n\t\t\t\tpwrInfo24G->CCK_Diff[rfPath][TxCount] =\t(PROMContent[eeAddr]&0x0f);\n\t\t\t\tif (pwrInfo24G->CCK_Diff[rfPath][TxCount] & BIT3)\t\t/*4bit sign number to 8 bit sign number*/\n\t\t\t\t\tpwrInfo24G->CCK_Diff[rfPath][TxCount] |= 0xF0;\n\n\t\t\t\teeAddr++;\n\t\t\t}\n\t\t}\n\n\t\t/* Ignore the unnecessary 5G parameters parsing, but still consider the efuse address offset */\n\t\t#define\tTX_PWR_DIFF_OFFSET_5G\t10\n\t\teeAddr += (MAX_CHNL_GROUP_5G + TX_PWR_DIFF_OFFSET_5G);\n\t}\n}\n\n\nvoid\nHal_EfuseParseTxPowerInfo_8723B(\n\tIN\tPADAPTER \t\tpadapter,\n\tIN\tu8*\t\t\tPROMContent,\n\tIN\tBOOLEAN\t\t\tAutoLoadFail\n\t)\n{\n\tHAL_DATA_TYPE\t*pHalData = GET_HAL_DATA(padapter);\n\tTxPowerInfo24G\tpwrInfo24G;\n\tu8\t\t\trfPath, ch, group, TxCount=1;\n\n//\tRT_TRACE(_module_hci_hal_init_c_, _drv_notice_, (\"%s(): AutoLoadFail = %d\\n\", __func__, AutoLoadFail));\n\tHal_ReadPowerValueFromPROM_8723B(padapter, &pwrInfo24G, PROMContent, AutoLoadFail);\n\tfor(rfPath = 0 ; rfPath < MAX_RF_PATH ; rfPath++)\n\t{\n\t\tfor(ch = 0 ; ch < CHANNEL_MAX_NUMBER; ch++)\n\t\t{\n\t\t\tHal_GetChnlGroup8723B(ch+1, &group);\n\t\t\t\n\t\t\tif(ch == 14-1) \n\t\t\t{\n\t\t\t\tpHalData->Index24G_CCK_Base[rfPath][ch] = pwrInfo24G.IndexCCK_Base[rfPath][5];\n\t\t\t\tpHalData->Index24G_BW40_Base[rfPath][ch] = pwrInfo24G.IndexBW40_Base[rfPath][group];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpHalData->Index24G_CCK_Base[rfPath][ch] = pwrInfo24G.IndexCCK_Base[rfPath][group];\n\t\t\t\tpHalData->Index24G_BW40_Base[rfPath][ch] = pwrInfo24G.IndexBW40_Base[rfPath][group];\n\t\t\t}\n#ifdef CONFIG_DEBUG\n\t\t\tRT_TRACE(_module_hci_hal_init_c_, _drv_info_, (\"======= Path %d, ChannelIndex %d, Group %d=======\\n\",rfPath,ch, group));\t\t\t\n\t\t\tRT_TRACE(_module_hci_hal_init_c_, _drv_info_, (\"Index24G_CCK_Base[%d][%d] = 0x%x\\n\",rfPath,ch ,pHalData->Index24G_CCK_Base[rfPath][ch]));\n\t\t\tRT_TRACE(_module_hci_hal_init_c_, _drv_info_, (\"Index24G_BW40_Base[%d][%d] = 0x%x\\n\",rfPath,ch,pHalData->Index24G_BW40_Base[rfPath][ch]));\t\t\t\n#endif\t\t\t\t\t\t\t\n\t\t}\n\t\t\n\t\tfor(TxCount=0;TxCount<MAX_TX_COUNT;TxCount++)\n\t\t{\n\t\t\tpHalData->CCK_24G_Diff[rfPath][TxCount]=pwrInfo24G.CCK_Diff[rfPath][TxCount];\n\t\t\tpHalData->OFDM_24G_Diff[rfPath][TxCount]=pwrInfo24G.OFDM_Diff[rfPath][TxCount];\n\t\t\tpHalData->BW20_24G_Diff[rfPath][TxCount]=pwrInfo24G.BW20_Diff[rfPath][TxCount];\n\t\t\tpHalData->BW40_24G_Diff[rfPath][TxCount]=pwrInfo24G.BW40_Diff[rfPath][TxCount];\n\t\t\t\n#ifdef CONFIG_DEBUG\n\t\t\tRT_TRACE(_module_hci_hal_init_c_, _drv_info_, (\"--------------------------------------- 2.4G ---------------------------------------\\n\"));\n\t\t\tRT_TRACE(_module_hci_hal_init_c_, _drv_info_, (\"CCK_24G_Diff[%d][%d]= %d\\n\",rfPath,TxCount,pHalData->CCK_24G_Diff[rfPath][TxCount]));\n\t\t\tRT_TRACE(_module_hci_hal_init_c_, _drv_info_, (\"OFDM_24G_Diff[%d][%d]= %d\\n\",rfPath,TxCount,pHalData->OFDM_24G_Diff[rfPath][TxCount]));\n\t\t\tRT_TRACE(_module_hci_hal_init_c_, _drv_info_, (\"BW20_24G_Diff[%d][%d]= %d\\n\",rfPath,TxCount,pHalData->BW20_24G_Diff[rfPath][TxCount]));\n\t\t\tRT_TRACE(_module_hci_hal_init_c_, _drv_info_, (\"BW40_24G_Diff[%d][%d]= %d\\n\",rfPath,TxCount,pHalData->BW40_24G_Diff[rfPath][TxCount]));\n#endif\t\t\t\t\t\t\t\n\t\t}\n\t}\n\n\t// 2010/10/19 MH Add Regulator recognize for CU.\n\tif(!AutoLoadFail)\n\t{\n\t\tpHalData->EEPROMRegulatory = (PROMContent[EEPROM_RF_BOARD_OPTION_8723B]&0x7);\t//bit0~2\n\t\tif(PROMContent[EEPROM_RF_BOARD_OPTION_8723B] == 0xFF)\n\t\t\tpHalData->EEPROMRegulatory = (EEPROM_DEFAULT_BOARD_OPTION&0x7);\t//bit0~2\n\t}\n\telse\n\t{\n\t\tpHalData->EEPROMRegulatory = 0;\n\t}\n\tRT_TRACE(_module_hci_hal_init_c_, _drv_notice_, (\"EEPROMRegulatory = 0x%x\\n\", pHalData->EEPROMRegulatory));\n}\n\nVOID\nHal_EfuseParseBoardType_8723B(\n\tIN\tPADAPTER\tAdapter,\t\n\tIN\tu8*\t\t\tPROMContent,\n\tIN\tBOOLEAN\t\tAutoloadFail\n\t)\n{\n\n\n\tHAL_DATA_TYPE\t*pHalData = GET_HAL_DATA(Adapter);\n\n\tif(!AutoloadFail)\n\t{\n\t\tpHalData->InterfaceSel = (PROMContent[EEPROM_RF_BOARD_OPTION_8723B]&0xE0)>>5;\n\t\tif(PROMContent[EEPROM_RF_BOARD_OPTION_8723B] == 0xFF)\n\t\t\tpHalData->InterfaceSel = (EEPROM_DEFAULT_BOARD_OPTION&0xE0)>>5;\n\t}\n\telse\n\t{\n\t\tpHalData->InterfaceSel = 0;\n\t}\n\tRT_TRACE(_module_hci_hal_init_c_, _drv_notice_, (\"Board Type: 0x%2x\\n\", pHalData->InterfaceSel));\n\n}\n\nVOID\nHal_EfuseParseBTCoexistInfo_8723B(\n\tIN PADAPTER\t\t\tpadapter,\n\tIN u8*\t\t\thwinfo,\n\tIN BOOLEAN\t\t\tAutoLoadFail\n\t)\n{\n\tPHAL_DATA_TYPE\tpHalData = GET_HAL_DATA(padapter);\n\tu8\t\t\ttempval;\n\tu32\t\t\ttmpu4;\n\n//\tRT_TRACE(_module_hci_hal_init_c_, _drv_notice_, (\"%s(): AutoLoadFail = %d\\n\", __func__, AutoLoadFail));\n\tif (!AutoLoadFail)\n\t{\n\t\ttmpu4 = rtw_read32(padapter, REG_MULTI_FUNC_CTRL);\n\t\tif (tmpu4 & BT_FUNC_EN)\n\t\t\tpHalData->EEPROMBluetoothCoexist = _TRUE;\n\t\telse\n\t\t\tpHalData->EEPROMBluetoothCoexist = _FALSE;\n\n\t\tpHalData->EEPROMBluetoothType = BT_RTL8723B;\n\n\t\ttempval = hwinfo[EEPROM_RF_BT_SETTING_8723B];\n\t\tif(tempval !=0xFF){\n\t\t\tpHalData->EEPROMBluetoothAntNum = tempval & BIT(0);\n\t\t\t#ifdef CONFIG_USB_HCI\n\t\t\t//if(padapter->interface_type == RTW_USB)\n\t\t\tpHalData->ant_path =ODM_RF_PATH_B;//s0\n\t\t\t#else //SDIO or PCIE\n\t\t\t// EFUSE_0xC3[6] == 0, S1(Main)-ODM_RF_PATH_A;\n\t\t\t// EFUSE_0xC3[6] == 1, S0(Aux)-ODM_RF_PATH_B\n\t\t\tpHalData->ant_path = (tempval & BIT(6))?ODM_RF_PATH_B:ODM_RF_PATH_A;\n\t\t\t#endif\n\t\t}\n\t\telse{\n\t\t\tpHalData->EEPROMBluetoothAntNum = Ant_x1;\n\t\t\t#ifdef CONFIG_USB_HCI\n\t\t\tpHalData->ant_path = ODM_RF_PATH_B;//s0\n\t\t\t#else\n\t\t\tpHalData->ant_path = ODM_RF_PATH_A;\n\t\t\t#endif\t\t\t\n\t\t}\n\t}\n\telse\n\t{\n\t\tpHalData->EEPROMBluetoothCoexist = _FALSE;\n\t\tpHalData->EEPROMBluetoothType = BT_RTL8723B;\n\t\tpHalData->EEPROMBluetoothAntNum = Ant_x1;\n\t\t#ifdef CONFIG_USB_HCI\n\t\tpHalData->ant_path = ODM_RF_PATH_B;//s0\n\t\t#else\n\t\tpHalData->ant_path = ODM_RF_PATH_A;\n\t\t#endif\n\t}\n\n#ifdef CONFIG_FOR_RTL8723BS_VQ0\n\tpHalData->ant_path = ODM_RF_PATH_B;//s0\n#endif\n\n#ifdef CONFIG_BT_COEXIST\n\tif (padapter->registrypriv.ant_num > 0) {\n\t\tDBG_8192C(\"%s: Apply driver defined antenna number(%d) to replace origin(%d)\\n\",\n\t\t\t__FUNCTION__,\n\t\t\tpadapter->registrypriv.ant_num,\n\t\t\tpHalData->EEPROMBluetoothAntNum==Ant_x2?2:1);\n\n\t\tswitch (padapter->registrypriv.ant_num) {\n\t\tcase 1:\n\t\t\tpHalData->EEPROMBluetoothAntNum = Ant_x1;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tpHalData->EEPROMBluetoothAntNum = Ant_x2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDBG_8192C(\"%s: Discard invalid driver defined antenna number(%d)!\\n\",\n\t\t\t\t__FUNCTION__, padapter->registrypriv.ant_num);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trtw_btcoex_SetBTCoexist(padapter, pHalData->EEPROMBluetoothCoexist);\n\trtw_btcoex_SetChipType(padapter, pHalData->EEPROMBluetoothType);\n\trtw_btcoex_SetPGAntNum(padapter, pHalData->EEPROMBluetoothAntNum==Ant_x2?2:1); \n\tif (pHalData->EEPROMBluetoothAntNum == Ant_x1)\n\t{\n\t\trtw_btcoex_SetSingleAntPath(padapter, pHalData->ant_path);\n\t}\n#endif // CONFIG_BT_COEXIST\n\n\tDBG_8192C(\"%s: %s BT-coex, ant_num=%d\\n\",\n\t\t__FUNCTION__,\n\t\tpHalData->EEPROMBluetoothCoexist==_TRUE?\"Enable\":\"Disable\",\n\t\tpHalData->EEPROMBluetoothAntNum==Ant_x2?2:1);\n}\n\nVOID\nHal_EfuseParseEEPROMVer_8723B(\n\tIN\tPADAPTER\t\tpadapter,\n\tIN\tu8*\t\t\thwinfo,\n\tIN\tBOOLEAN\t\t\tAutoLoadFail\n\t)\n{\n\tHAL_DATA_TYPE\t*pHalData = GET_HAL_DATA(padapter);\n\n//\tRT_TRACE(_module_hci_hal_init_c_, _drv_notice_, (\"%s(): AutoLoadFail = %d\\n\", __func__, AutoLoadFail));\n\tif(!AutoLoadFail)\n\t\tpHalData->EEPROMVersion = hwinfo[EEPROM_VERSION_8723B];\n\telse\n\t\tpHalData->EEPROMVersion = 1;\n\tRT_TRACE(_module_hci_hal_init_c_, _drv_notice_, (\"Hal_EfuseParseEEPROMVer(), EEVer = %d\\n\",\n\t\tpHalData->EEPROMVersion));\n}\n\n\n\nVOID\nHal_EfuseParsePackageType_8723B(\n\tIN\tPADAPTER\t\tpAdapter,\n\tIN\tu8*\t\t\t\thwinfo,\n\tIN\tBOOLEAN \tAutoLoadFail\n\t) \n{\n\tHAL_DATA_TYPE\t*pHalData = GET_HAL_DATA(pAdapter);\n\tu1Byte\t\t\tpackage;\n\tu8 efuseContent;\n\t\n\tEfuse_PowerSwitch(pAdapter, _FALSE, _TRUE);\n\tefuse_OneByteRead(pAdapter, 0x1FB, &efuseContent, FALSE);\n\tDBG_871X(\"%s phy efuse read 0x1FB =%x \\n\",__func__,efuseContent);\n\tEfuse_PowerSwitch(pAdapter, _FALSE, _FALSE);\n\t\n\tpackage = efuseContent & 0x7;\n\tswitch (package) \n\t{\n\t\tcase 0x4:\n\t\t\tpHalData->PackageType = PACKAGE_TFBGA79;\n\t\t\tbreak;\n\t\tcase 0x5:\n\t\t\tpHalData->PackageType = PACKAGE_TFBGA90;\n\t\t\tbreak;\n\t\tcase 0x6:\n\t\t\tpHalData->PackageType = PACKAGE_QFN68;\n\t\t\tbreak;\n\t\tcase 0x7:\n\t\t\tpHalData->PackageType = PACKAGE_TFBGA80;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpHalData->PackageType = PACKAGE_DEFAULT;\n\t\t\tbreak;\n\t}\n\n\tDBG_871X(\"PackageType = 0x%X\\n\", pHalData->PackageType);\n\n#ifdef CONFIG_SDIO_HCI\n\t/* RTL8703AS: 0x1FB[5:4] 2b'10 */\n\t/* RTL8723BS: 0x1FB[5:4] 2b'11 */\n\tif ((efuseContent & 0x30) == 0x20) {\n\t\tpAdapter->registrypriv.bw_mode &= 0xF0;\n\t\tDBG_871X(\"This is the case of 8703AS\\n\");\n\t}\n#endif\t\n}\n\n\nVOID\nHal_EfuseParseVoltage_8723B(\n\tIN\tPADAPTER\t\tpAdapter,\n\tIN\tu8* \t\t\thwinfo,\n\tIN\tBOOLEAN \tAutoLoadFail\n\t) \n{\n\tHAL_DATA_TYPE\t*pHalData = GET_HAL_DATA(pAdapter);\n\t\n\t//_rtw_memcpy(pHalData->adjuseVoltageVal, &hwinfo[EEPROM_Voltage_ADDR_8723B], 1);\n\tDBG_871X(\"%s hwinfo[EEPROM_Voltage_ADDR_8723B] =%02x \\n\",__func__, hwinfo[EEPROM_Voltage_ADDR_8723B]);\n\tpHalData->adjuseVoltageVal = (hwinfo[EEPROM_Voltage_ADDR_8723B] & 0xf0) >> 4 ;\n\tDBG_871X(\"%s pHalData->adjuseVoltageVal =%x \\n\",__func__,pHalData->adjuseVoltageVal);\n}\n\nVOID\nHal_EfuseParseChnlPlan_8723B(\n\tIN\tPADAPTER\t\tpadapter,\n\tIN\tu8*\t\t\thwinfo,\n\tIN\tBOOLEAN\t\t\tAutoLoadFail\n\t)\n{\n\tpadapter->mlmepriv.ChannelPlan = hal_com_config_channel_plan(\n\t\tpadapter\n\t\t, hwinfo?hwinfo[EEPROM_ChannelPlan_8723B]:0xFF\n\t\t, padapter->registrypriv.channel_plan\n\t\t, RT_CHANNEL_DOMAIN_WORLD_NULL\n\t\t, AutoLoadFail\n\t);\n\n\tRT_TRACE(_module_hci_hal_init_c_, _drv_notice_, (\"EEPROM ChannelPlan=0x%02x\\n\", padapter->mlmepriv.ChannelPlan));\n}\n\nVOID\nHal_EfuseParseCustomerID_8723B(\n\tIN\tPADAPTER\t\tpadapter,\n\tIN\tu8*\t\t\thwinfo,\n\tIN\tBOOLEAN\t\t\tAutoLoadFail\n\t)\n{\n\tHAL_DATA_TYPE\t*pHalData = GET_HAL_DATA(padapter);\n\n//\tRT_TRACE(_module_hci_hal_init_c_, _drv_notice_, (\"%s(): AutoLoadFail = %d\\n\", __func__, AutoLoadFail));\n\tif (!AutoLoadFail)\n\t{\n\t\tpHalData->EEPROMCustomerID = hwinfo[EEPROM_CustomID_8723B];\n\t}\n\telse\n\t{\n\t\tpHalData->EEPROMCustomerID = 0;\n\t}\n\tRT_TRACE(_module_hci_hal_init_c_, _drv_notice_, (\"EEPROM Customer ID: 0x%2x\\n\", pHalData->EEPROMCustomerID));\n}\n\nVOID\nHal_EfuseParseAntennaDiversity_8723B(\n\tIN\tPADAPTER\t\tpAdapter,\n\tIN\tu8\t\t\t\t* hwinfo,\n\tIN\tBOOLEAN\t\t\tAutoLoadFail\n\t)\n{\n#ifdef CONFIG_ANTENNA_DIVERSITY\n\tPHAL_DATA_TYPE\t\tpHalData = GET_HAL_DATA(pAdapter);\n\tstruct registry_priv\t*registry_par = &pAdapter->registrypriv;\n\n\tif (pHalData->EEPROMBluetoothAntNum == Ant_x1){\n\t\tpHalData->AntDivCfg = 0;\n\t}\n\telse{\n\t\tif(registry_par->antdiv_cfg == 2)// 0:OFF , 1:ON, 2:By EFUSE\n\t\t\tpHalData->AntDivCfg = 1;\n\t\telse\n\t\t\tpHalData->AntDivCfg = registry_par->antdiv_cfg;\n\t}\n\n\t// If TRxAntDivType is AUTO in advanced setting, use EFUSE value instead.\n\tif(registry_par->antdiv_type == 0) {\n\t\tpHalData->TRxAntDivType = hwinfo[EEPROM_RFE_OPTION_8723B];\n\t\tif (pHalData->TRxAntDivType == 0xFF)\n\t\t\tpHalData->TRxAntDivType = S0S1_SW_ANTDIV;//GetRegAntDivType(pAdapter);\n\t\telse if (pHalData->TRxAntDivType == 0x10)\n\t\t\tpHalData->TRxAntDivType = S0S1_SW_ANTDIV; //intrnal switch S0S1\n\t\telse if (pHalData->TRxAntDivType == 0x11)\n\t\t\tpHalData->TRxAntDivType = S0S1_SW_ANTDIV; //intrnal switch S0S1\n\t\telse\n\t\t\tDBG_8192C(\"%s: efuse[0x%x]=0x%02x is unknown type\\n\",\n\t\t\t\t__FUNCTION__, EEPROM_RFE_OPTION_8723B, pHalData->TRxAntDivType);\n\t}\n\telse{\n\t\tpHalData->TRxAntDivType = registry_par->antdiv_type ;//GetRegAntDivType(pAdapter);\n\t}\n\n\tDBG_8192C(\"%s: AntDivCfg=%d, AntDivType=%d\\n\",\n\t\t__FUNCTION__, pHalData->AntDivCfg, pHalData->TRxAntDivType);\n#endif\n}\n\nVOID\nHal_EfuseParseXtal_8723B(\n\tIN\tPADAPTER\t\tpAdapter,\n\tIN\tu8\t\t\t* hwinfo,\n\tIN\tBOOLEAN\t\tAutoLoadFail\n\t)\n{\n\tHAL_DATA_TYPE\t*pHalData = GET_HAL_DATA(pAdapter);\n\n//\tRT_TRACE(_module_hci_hal_init_c_, _drv_notice_, (\"%s(): AutoLoadFail = %d\\n\", __func__, AutoLoadFail));\n\tif(!AutoLoadFail)\n\t{\n\t\tpHalData->CrystalCap = hwinfo[EEPROM_XTAL_8723B];\n\t\tif(pHalData->CrystalCap == 0xFF)\n\t\t\tpHalData->CrystalCap = EEPROM_Default_CrystalCap_8723B;\t   //what value should 8812 set?\n\t}\n\telse\n\t{\n\t\tpHalData->CrystalCap = EEPROM_Default_CrystalCap_8723B;\n\t}\n\tRT_TRACE(_module_hci_hal_init_c_, _drv_notice_, (\"EEPROM CrystalCap: 0x%2x\\n\", pHalData->CrystalCap));\n}\n\n\nvoid\nHal_EfuseParseThermalMeter_8723B(\n\tPADAPTER\tpadapter,\n\tu8\t\t\t*PROMContent,\n\tu8\t\t\tAutoLoadFail\n\t)\n{\n\tPHAL_DATA_TYPE\tpHalData = GET_HAL_DATA(padapter);\n\n//\tRT_TRACE(_module_hci_hal_init_c_, _drv_notice_, (\"%s(): AutoLoadFail = %d\\n\", __func__, AutoLoadFail));\n\t//\n\t// ThermalMeter from EEPROM\n\t//\n\tif (_FALSE == AutoLoadFail)\n\t\tpHalData->EEPROMThermalMeter = PROMContent[EEPROM_THERMAL_METER_8723B];\n\telse\n\t\tpHalData->EEPROMThermalMeter = EEPROM_Default_ThermalMeter_8723B;\n\n\tif ((pHalData->EEPROMThermalMeter == 0xff) || (_TRUE == AutoLoadFail))\n\t{\n\t\tpHalData->odmpriv.RFCalibrateInfo.bAPKThermalMeterIgnore = _TRUE;\n\t\tpHalData->EEPROMThermalMeter = EEPROM_Default_ThermalMeter_8723B;\n\t}\n\n\tRT_TRACE(_module_hci_hal_init_c_, _drv_notice_, (\"EEPROM ThermalMeter=0x%x\\n\", pHalData->EEPROMThermalMeter));\n}\n\n\n#ifdef CONFIG_RF_GAIN_OFFSET\nvoid Hal_ReadRFGainOffset(\n\tIN\t\tPADAPTER\t\tAdapter,\n\tIN\t\tu8* \t\t\tPROMContent,\n\tIN\t\tBOOLEAN \t\tAutoloadFail)\n{\n\tHAL_DATA_TYPE\t*pHalData = GET_HAL_DATA(Adapter);\n\t//\n\t// BB_RF Gain Offset from EEPROM\n\t//\n\n\tif(!AutoloadFail ){\n\t\tpHalData->EEPROMRFGainOffset =PROMContent[EEPROM_RF_GAIN_OFFSET];\n\t\tDBG_871X(\"AutoloadFail =%x,\\n\", AutoloadFail);\n\t\tpHalData->EEPROMRFGainVal=EFUSE_Read1Byte(Adapter, EEPROM_RF_GAIN_VAL);\n\t\tDBG_871X(\"pHalData->EEPROMRFGainVal=%x\\n\", pHalData->EEPROMRFGainVal);\n\t}\n\telse{\n\t\tpHalData->EEPROMRFGainOffset = 0;\n\t\tpHalData->EEPROMRFGainVal=0xFF;\n\t\tDBG_871X(\"else AutoloadFail =%x,\\n\", AutoloadFail);\n\t}\n\tDBG_871X(\"EEPRORFGainOffset = 0x%02x\\n\", pHalData->EEPROMRFGainOffset);\n}\n#endif //CONFIG_RF_GAIN_OFFSET\n\nu8 \nBWMapping_8723B(\n\tIN\tPADAPTER\t\tAdapter,\n\tIN\tstruct pkt_attrib\t*pattrib\n)\n{\n\tu8\tBWSettingOfDesc = 0;\n\tPHAL_DATA_TYPE\tpHalData = GET_HAL_DATA(Adapter);\n\n\t//DBG_871X(\"BWMapping pHalData->CurrentChannelBW %d, pattrib->bwmode %d \\n\",pHalData->CurrentChannelBW,pattrib->bwmode);\n\n\tif(pHalData->CurrentChannelBW== CHANNEL_WIDTH_80)\n\t{\n\t\tif(pattrib->bwmode == CHANNEL_WIDTH_80)\n\t\t\tBWSettingOfDesc= 2;\n\t\telse if(pattrib->bwmode == CHANNEL_WIDTH_40)\n\t\t\tBWSettingOfDesc = 1;\n\t\telse\n\t\t\tBWSettingOfDesc = 0;\n\t}\n\telse if(pHalData->CurrentChannelBW== CHANNEL_WIDTH_40)\n\t{\n\t\tif((pattrib->bwmode == CHANNEL_WIDTH_40) || (pattrib->bwmode == CHANNEL_WIDTH_80))\n\t\t\tBWSettingOfDesc = 1;\n\t\telse\n\t\t\tBWSettingOfDesc = 0;\n\t}\n\telse\n\t\tBWSettingOfDesc = 0;\n\n\t//if(pTcb->bBTTxPacket)\n\t//\tBWSettingOfDesc = 0;\n\n\treturn BWSettingOfDesc;\n}\n\nu8\tSCMapping_8723B(PADAPTER Adapter, struct pkt_attrib *pattrib)\n{\n\tu8\tSCSettingOfDesc = 0;\n\tPHAL_DATA_TYPE\tpHalData = GET_HAL_DATA(Adapter);\n\n\t//DBG_871X(\"SCMapping: pHalData->CurrentChannelBW %d, pHalData->nCur80MhzPrimeSC %d, pHalData->nCur40MhzPrimeSC %d \\n\",pHalData->CurrentChannelBW,pHalData->nCur80MhzPrimeSC,pHalData->nCur40MhzPrimeSC);\n\t\n\tif(pHalData->CurrentChannelBW == CHANNEL_WIDTH_80)\n\t{\n\t\tif(pattrib->bwmode == CHANNEL_WIDTH_80)\n\t\t{\n\t\t\tSCSettingOfDesc = VHT_DATA_SC_DONOT_CARE;\n\t\t}\n\t\telse if(pattrib->bwmode == CHANNEL_WIDTH_40)\n\t\t{\n\t\t\tif(pHalData->nCur80MhzPrimeSC == HAL_PRIME_CHNL_OFFSET_LOWER)\n\t\t\t\tSCSettingOfDesc = VHT_DATA_SC_40_LOWER_OF_80MHZ;\n\t\t\telse if(pHalData->nCur80MhzPrimeSC == HAL_PRIME_CHNL_OFFSET_UPPER)\n\t\t\t\tSCSettingOfDesc = VHT_DATA_SC_40_UPPER_OF_80MHZ;\n\t\t\telse\n\t\t\t\tDBG_871X(\"SCMapping: Not Correct Primary40MHz Setting \\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif((pHalData->nCur40MhzPrimeSC == HAL_PRIME_CHNL_OFFSET_LOWER) && (pHalData->nCur80MhzPrimeSC == HAL_PRIME_CHNL_OFFSET_LOWER))\n\t\t\t\tSCSettingOfDesc = VHT_DATA_SC_20_LOWEST_OF_80MHZ;\n\t\t\telse if((pHalData->nCur40MhzPrimeSC == HAL_PRIME_CHNL_OFFSET_UPPER) && (pHalData->nCur80MhzPrimeSC == HAL_PRIME_CHNL_OFFSET_LOWER))\n\t\t\t\tSCSettingOfDesc = VHT_DATA_SC_20_LOWER_OF_80MHZ;\n\t\t\telse if((pHalData->nCur40MhzPrimeSC == HAL_PRIME_CHNL_OFFSET_LOWER) && (pHalData->nCur80MhzPrimeSC == HAL_PRIME_CHNL_OFFSET_UPPER))\n\t\t\t\tSCSettingOfDesc = VHT_DATA_SC_20_UPPER_OF_80MHZ;\n\t\t\telse if((pHalData->nCur40MhzPrimeSC == HAL_PRIME_CHNL_OFFSET_UPPER) && (pHalData->nCur80MhzPrimeSC == HAL_PRIME_CHNL_OFFSET_UPPER))\n\t\t\t\tSCSettingOfDesc = VHT_DATA_SC_20_UPPERST_OF_80MHZ;\n\t\t\telse\n\t\t\t\tDBG_871X(\"SCMapping: Not Correct Primary40MHz Setting \\n\");\n\t\t}\n\t}\n\telse if(pHalData->CurrentChannelBW== CHANNEL_WIDTH_40)\n\t{\n\t\t//DBG_871X(\"SCMapping: HT Case: pHalData->CurrentChannelBW %d, pHalData->nCur40MhzPrimeSC %d \\n\",pHalData->CurrentChannelBW,pHalData->nCur40MhzPrimeSC);\n\n\t\tif(pattrib->bwmode == CHANNEL_WIDTH_40)\n\t\t{\n\t\t\tSCSettingOfDesc = VHT_DATA_SC_DONOT_CARE;\n\t\t}\n\t\telse if(pattrib->bwmode == CHANNEL_WIDTH_20)\n\t\t{\n\t\t\tif(pHalData->nCur40MhzPrimeSC == HAL_PRIME_CHNL_OFFSET_UPPER)\n\t\t\t{\n\t\t\t\tSCSettingOfDesc = VHT_DATA_SC_20_UPPER_OF_80MHZ;\n\t\t\t}\n\t\t\telse if(pHalData->nCur40MhzPrimeSC == HAL_PRIME_CHNL_OFFSET_LOWER)\n\t\t\t{\n\t\t\t\tSCSettingOfDesc = VHT_DATA_SC_20_LOWER_OF_80MHZ;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSCSettingOfDesc = VHT_DATA_SC_DONOT_CARE;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tSCSettingOfDesc = VHT_DATA_SC_DONOT_CARE;\n\t}\n\n\treturn SCSettingOfDesc;\n}\n\n\nstatic u8 fill_txdesc_sectype(struct pkt_attrib *pattrib)\n{\n\tu8 sectype = 0;\n\tif ((pattrib->encrypt > 0) && !pattrib->bswenc)\n\t{\n\t\tswitch (pattrib->encrypt)\n\t\t{\n\t\t\t// SEC_TYPE\n\t\t\tcase _WEP40_:\n\t\t\tcase _WEP104_:\n\t\t\tcase _TKIP_:\n\t\t\tcase _TKIP_WTMIC_:\n\t\t\t\tsectype = 1;\n\t\t\t\tbreak;\n\n#ifdef CONFIG_WAPI_SUPPORT\n\t\t\tcase _SMS4_:\n\t\t\t\tsectype = 2;\n\t\t\t\tbreak;\n#endif\n\t\t\tcase _AES_:\n\t\t\t\tsectype = 3;\n\t\t\t\tbreak;\n\n\t\t\tcase _NO_PRIVACY_:\n\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn sectype;\n}\n\nstatic void fill_txdesc_vcs_8723b(PADAPTER padapter, struct pkt_attrib *pattrib, u8 *ptxdesc)\n{\n\t//DBG_8192C(\"cvs_mode=%d\\n\", pattrib->vcs_mode);\n\n\tif (pattrib->vcs_mode) {\n\t\tswitch (pattrib->vcs_mode) {\n\t\tcase RTS_CTS:\n\t\t\tSET_TX_DESC_RTS_ENABLE_8723B(ptxdesc, 1);\n\t\t\tSET_TX_DESC_HW_RTS_ENABLE_8723B(ptxdesc, 1);\n\t\t\tbreak;\n\n\t\tcase CTS_TO_SELF:\n\t\t\tSET_TX_DESC_CTS2SELF_8723B(ptxdesc, 1);\n\t\t\tbreak;\n\n\t\tcase NONE_VCS:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tSET_TX_DESC_RTS_RATE_8723B(ptxdesc, 8); // RTS Rate=24M\n\t\tSET_TX_DESC_RTS_RATE_FB_LIMIT_8723B(ptxdesc, 0xF);\n\n\t\tif (padapter->mlmeextpriv.mlmext_info.preamble_mode == PREAMBLE_SHORT) {\n\t\t\tSET_TX_DESC_RTS_SHORT_8723B(ptxdesc, 1);\n\t\t}\n\n\t\t// Set RTS BW\n\t\tif (pattrib->ht_en) {\n\t\t\tSET_TX_DESC_RTS_SC_8723B(ptxdesc, SCMapping_8723B(padapter, pattrib));\n\t\t}\n\t}\n}\n\nstatic void fill_txdesc_phy_8723b(PADAPTER padapter, struct pkt_attrib *pattrib, u8 *ptxdesc)\n{\n\t//DBG_8192C(\"bwmode=%d, ch_off=%d\\n\", pattrib->bwmode, pattrib->ch_offset);\n\n\tif (pattrib->ht_en) {\n\t\tSET_TX_DESC_DATA_BW_8723B(ptxdesc, BWMapping_8723B(padapter, pattrib));\n\t\tSET_TX_DESC_DATA_SC_8723B(ptxdesc, SCMapping_8723B(padapter, pattrib));\n\t}\n}\n\nstatic void rtl8723b_fill_default_txdesc(\n\tstruct xmit_frame *pxmitframe,\n\tu8 *pbuf)\n{\n\tPADAPTER padapter;\n\tHAL_DATA_TYPE *pHalData; \n\tstruct mlme_ext_priv *pmlmeext;\n\tstruct mlme_ext_info *pmlmeinfo;\n\tstruct pkt_attrib *pattrib;\n\ts32 bmcst;\n\n\t_rtw_memset(pbuf, 0, TXDESC_SIZE);\n\n\tpadapter = pxmitframe->padapter;\n\tpHalData = GET_HAL_DATA(padapter); \n\tpmlmeext = &padapter->mlmeextpriv;\n\tpmlmeinfo = &(pmlmeext->mlmext_info);\n\n\tpattrib = &pxmitframe->attrib;\n\tbmcst = IS_MCAST(pattrib->ra);\n\n\tif (pxmitframe->frame_tag == DATA_FRAMETAG)\n\t{\n\t\tu8 drv_userate = 0;\n\n\t\tSET_TX_DESC_MACID_8723B(pbuf, pattrib->mac_id);\n\t\tSET_TX_DESC_RATE_ID_8723B(pbuf, pattrib->raid);\n\t\tSET_TX_DESC_QUEUE_SEL_8723B(pbuf, pattrib->qsel);\n\t\tSET_TX_DESC_SEQ_8723B(pbuf, pattrib->seqnum);\n\n\t\tSET_TX_DESC_SEC_TYPE_8723B(pbuf, fill_txdesc_sectype(pattrib));\n\t\tfill_txdesc_vcs_8723b(padapter, pattrib, pbuf);\n\n\t\tif(pattrib->icmp_pkt ==1 && padapter->registrypriv.wifi_spec==1)\n\t\t\tdrv_userate = 1;\n\n\t\tif ((pattrib->ether_type != 0x888e) &&\n\t\t\t(pattrib->ether_type != 0x0806) &&\n\t\t\t(pattrib->ether_type != 0x88B4) &&\n\t\t\t(pattrib->dhcp_pkt != 1) &&\n\t\t\t(drv_userate != 1)\n#ifdef CONFIG_AUTO_AP_MODE\n\t\t    && (pattrib->pctrl != _TRUE)\n#endif\n\t\t\t)\n\t\t{\n\t\t\t// Non EAP & ARP & DHCP type data packet\n\n\t\t\tif (pattrib->ampdu_en == _TRUE) {\n\t\t\t\tSET_TX_DESC_AGG_ENABLE_8723B(pbuf, 1);\n\t\t\t\tSET_TX_DESC_MAX_AGG_NUM_8723B(pbuf, 0x1F);\n\t\t\t\tSET_TX_DESC_AMPDU_DENSITY_8723B(pbuf, pattrib->ampdu_spacing);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSET_TX_DESC_AGG_BREAK_8723B(pbuf, 1);\n\t\t\t}\n\n\t\t\tfill_txdesc_phy_8723b(padapter, pattrib, pbuf);\n\n\t\t\tSET_TX_DESC_DATA_RATE_FB_LIMIT_8723B(pbuf, 0x1F);\n\n\t\t\tif (pHalData->fw_ractrl == _FALSE) {\n\t\t\t\tSET_TX_DESC_USE_RATE_8723B(pbuf, 1);\n\n\t\t\t\tif (pHalData->INIDATA_RATE[pattrib->mac_id] & BIT(7)) {\n\t\t\t\t\tSET_TX_DESC_DATA_SHORT_8723B(pbuf, 1);\n\t\t\t\t}\n\n\t\t\t\tSET_TX_DESC_TX_RATE_8723B(pbuf, pHalData->INIDATA_RATE[pattrib->mac_id] & 0x7F);\n\t\t\t}\n\n\t\t\t// modify data rate by iwpriv\n\t\t\tif (padapter->fix_rate != 0xFF) {\n\t\t\t\tSET_TX_DESC_USE_RATE_8723B(pbuf, 1);\n\t\t\t\tif (padapter->fix_rate & BIT(7)) {\n\t\t\t\t\tSET_TX_DESC_DATA_SHORT_8723B(pbuf, 1);\n\t\t\t\t}\n\t\t\t\tSET_TX_DESC_TX_RATE_8723B(pbuf, padapter->fix_rate & 0x7F);\n\t\t\t\tif (!padapter->data_fb) {\n\t\t\t\t\tSET_TX_DESC_DISABLE_FB_8723B(pbuf, 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (pattrib->ldpc) {\n\t\t\t\tSET_TX_DESC_DATA_LDPC_8723B(pbuf, 1);\n\t\t\t}\n\n\t\t\tif (pattrib->stbc) {\n\t\t\t\tSET_TX_DESC_DATA_STBC_8723B(pbuf, 1);\n\t\t\t}\n\n#ifdef CONFIG_CMCC_TEST\n\t\t\tSET_TX_DESC_DATA_SHORT_8723B(pbuf, 1); /* use cck short premble */\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// EAP data packet and ARP packet.\n\t\t\t// Use the 1M data rate to send the EAP/ARP packet.\n\t\t\t// This will maybe make the handshake smooth.\n\n\t\t\tSET_TX_DESC_AGG_BREAK_8723B(pbuf, 1);\n\t\t\tSET_TX_DESC_USE_RATE_8723B(pbuf, 1);\n\t\t\tif (pmlmeinfo->preamble_mode == PREAMBLE_SHORT) {\n\t\t\t\tSET_TX_DESC_DATA_SHORT_8723B(pbuf, 1);\n\t\t\t}\n\t\t\tSET_TX_DESC_TX_RATE_8723B(pbuf, MRateToHwRate(pmlmeext->tx_rate));\n\n\t\t\tDBG_8192C(FUNC_ADPT_FMT \": SP Packet(0x%04X) rate=0x%x\\n\",\n\t\t\t\tFUNC_ADPT_ARG(padapter), pattrib->ether_type, MRateToHwRate(pmlmeext->tx_rate));\n\t\t}\n\n#if defined(CONFIG_USB_TX_AGGREGATION) || defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)\n\t\tSET_TX_DESC_USB_TXAGG_NUM_8723B(pbuf, pxmitframe->agg_num);\n#endif\n\n#ifdef CONFIG_TDLS\n#ifdef CONFIG_XMIT_ACK\n\t\t/* CCX-TXRPT ack for xmit mgmt frames. */\n\t\tif (pxmitframe->ack_report) {\n\t\t\t#ifdef DBG_CCX\n\t\t\tDBG_8192C(\"%s set spe_rpt\\n\", __func__);\n\t\t\t#endif\n\t\t\tSET_TX_DESC_SPE_RPT_8723B(pbuf, 1);\n\t\t\tSET_TX_DESC_SW_DEFINE_8723B(pbuf, (u8)(GET_PRIMARY_ADAPTER(padapter)->xmitpriv.seq_no));\n\t\t}\n#endif /* CONFIG_XMIT_ACK */\n#endif\n\t}\n\telse if (pxmitframe->frame_tag == MGNT_FRAMETAG)\n\t{\n//\t\tRT_TRACE(_module_hal_xmit_c_, _drv_notice_, (\"%s: MGNT_FRAMETAG\\n\", __FUNCTION__));\n\n\t\tSET_TX_DESC_MACID_8723B(pbuf, pattrib->mac_id);\n\t\tSET_TX_DESC_QUEUE_SEL_8723B(pbuf, pattrib->qsel);\n\t\tSET_TX_DESC_RATE_ID_8723B(pbuf, pattrib->raid);\n\t\tSET_TX_DESC_SEQ_8723B(pbuf, pattrib->seqnum);\n\t\tSET_TX_DESC_USE_RATE_8723B(pbuf, 1);\n\n\t\tSET_TX_DESC_MBSSID_8723B(pbuf, pattrib->mbssid & 0xF);\n\n\t\tSET_TX_DESC_RETRY_LIMIT_ENABLE_8723B(pbuf, 1);\n\t\tif (pattrib->retry_ctrl == _TRUE) {\n\t\t\tSET_TX_DESC_DATA_RETRY_LIMIT_8723B(pbuf, 6);\n\t\t} else {\n\t\t\tSET_TX_DESC_DATA_RETRY_LIMIT_8723B(pbuf, 12);\n\t\t}\n\n#ifdef CONFIG_INTEL_PROXIM\n\t\tif((padapter->proximity.proxim_on==_TRUE)&&(pattrib->intel_proxim==_TRUE)){\n\t\t\tDBG_871X(\"\\n %s pattrib->rate=%d\\n\",__FUNCTION__,pattrib->rate);\n\t\t\tSET_TX_DESC_TX_RATE_8723B(pbuf, pattrib->rate);\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t\tSET_TX_DESC_TX_RATE_8723B(pbuf, MRateToHwRate(pmlmeext->tx_rate));\n\t\t}\n\n#ifdef CONFIG_XMIT_ACK\n\t\t// CCX-TXRPT ack for xmit mgmt frames.\n\t\tif (pxmitframe->ack_report) {\n\t\t\t#ifdef DBG_CCX\n\t\t\tDBG_8192C(\"%s set spe_rpt\\n\", __FUNCTION__);\n\t\t\t#endif\n\t\t\tSET_TX_DESC_SPE_RPT_8723B(pbuf, 1);\n\t\t\tSET_TX_DESC_SW_DEFINE_8723B(pbuf, (u8)(GET_PRIMARY_ADAPTER(padapter)->xmitpriv.seq_no));\n\t\t}\n#endif // CONFIG_XMIT_ACK\n\t}\n\telse if (pxmitframe->frame_tag == TXAGG_FRAMETAG)\n\t{\n\t\tRT_TRACE(_module_hal_xmit_c_, _drv_warning_, (\"%s: TXAGG_FRAMETAG\\n\", __FUNCTION__));\n\t}\n#ifdef CONFIG_MP_INCLUDED\n\telse if (pxmitframe->frame_tag == MP_FRAMETAG)\n\t{\n\t\tRT_TRACE(_module_hal_xmit_c_, _drv_notice_, (\"%s: MP_FRAMETAG\\n\", __FUNCTION__));\n\t\tfill_txdesc_for_mp(padapter, pbuf);\n\t}\n#endif\n\telse\n\t{\n\t\tRT_TRACE(_module_hal_xmit_c_, _drv_warning_, (\"%s: frame_tag=0x%x\\n\", __FUNCTION__, pxmitframe->frame_tag));\n\n\t\tSET_TX_DESC_MACID_8723B(pbuf, pattrib->mac_id);\n\t\tSET_TX_DESC_RATE_ID_8723B(pbuf, pattrib->raid);\n\t\tSET_TX_DESC_QUEUE_SEL_8723B(pbuf, pattrib->qsel);\n\t\tSET_TX_DESC_SEQ_8723B(pbuf, pattrib->seqnum);\n\t\tSET_TX_DESC_USE_RATE_8723B(pbuf, 1);\n\t\tSET_TX_DESC_TX_RATE_8723B(pbuf, MRateToHwRate(pmlmeext->tx_rate));\n\t}\n\n\tSET_TX_DESC_PKT_SIZE_8723B(pbuf, pattrib->last_txcmdsz);\n\n\t{\n\t\tu8 pkt_offset, offset;\n\n\t\tpkt_offset = 0;\n\t\toffset = TXDESC_SIZE;\n#ifdef CONFIG_USB_HCI\n\t\tpkt_offset = pxmitframe->pkt_offset;\n\t\toffset += (pxmitframe->pkt_offset >> 3);\n#endif // CONFIG_USB_HCI\n\n#ifdef CONFIG_TX_EARLY_MODE\n\t\tif (pxmitframe->frame_tag == DATA_FRAMETAG) {\n\t\t\tpkt_offset = 1;\n\t\t\toffset += EARLY_MODE_INFO_SIZE;\n\t\t}\n#endif // CONFIG_TX_EARLY_MODE\n\n\t\tSET_TX_DESC_PKT_OFFSET_8723B(pbuf, pkt_offset);\n\t\tSET_TX_DESC_OFFSET_8723B(pbuf, offset);\n\t}\n\n\tif (bmcst) {\n\t\tSET_TX_DESC_BMC_8723B(pbuf, 1);\n\t}\n\n\t// 2009.11.05. tynli_test. Suggested by SD4 Filen for FW LPS.\n\t// (1) The sequence number of each non-Qos frame / broadcast / multicast /\n\t// mgnt frame should be controled by Hw because Fw will also send null data\n\t// which we cannot control when Fw LPS enable.\n\t// --> default enable non-Qos data sequense number. 2010.06.23. by tynli.\n\t// (2) Enable HW SEQ control for beacon packet, because we use Hw beacon.\n\t// (3) Use HW Qos SEQ to control the seq num of Ext port non-Qos packets.\n\t// 2010.06.23. Added by tynli.\n\tif (!pattrib->qos_en) {\n\t\tSET_TX_DESC_HWSEQ_EN_8723B(pbuf, 1);\n\t}\n}\n\n/*\n *\tDescription:\n *\n *\tParameters:\n *\t\tpxmitframe\txmitframe\n *\t\tpbuf\t\twhere to fill tx desc\n */\nvoid rtl8723b_update_txdesc(struct xmit_frame *pxmitframe, u8 *pbuf)\n{\n\tPADAPTER padapter = pxmitframe->padapter;\n\trtl8723b_fill_default_txdesc(pxmitframe, pbuf);\n\n#ifdef CONFIG_ANTENNA_DIVERSITY\n\tODM_SetTxAntByTxInfo(&GET_HAL_DATA(padapter)->odmpriv, pbuf, pxmitframe->attrib.mac_id);\n#endif // CONFIG_ANTENNA_DIVERSITY\n\n#if defined(CONFIG_USB_HCI) || defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)\n\trtl8723b_cal_txdesc_chksum((struct tx_desc*)pbuf);\n#endif\n}\n\n#ifdef CONFIG_TSF_RESET_OFFLOAD\nint reset_tsf(PADAPTER Adapter, u8 reset_port )\n{\n\tu8 reset_cnt_before = 0, reset_cnt_after = 0, loop_cnt = 0;\n\tu32 reg_reset_tsf_cnt = (IFACE_PORT0==reset_port) ?\n\t\t\t\tREG_FW_RESET_TSF_CNT_0:REG_FW_RESET_TSF_CNT_1;\n\n\trtw_scan_abort(Adapter->pbuddy_adapter);\t/*\tsite survey will cause reset_tsf fail\t*/\n\treset_cnt_after = reset_cnt_before = rtw_read8(Adapter,reg_reset_tsf_cnt);\n\trtl8723b_reset_tsf(Adapter, reset_port);\n\n\twhile ((reset_cnt_after == reset_cnt_before ) && (loop_cnt < 10)) {\n\t\trtw_msleep_os(100);\n\t\tloop_cnt++;\n\t\treset_cnt_after = rtw_read8(Adapter, reg_reset_tsf_cnt);\n\t}\n\n\treturn(loop_cnt >= 10) ? _FAIL : _TRUE;\n}\n#endif // CONFIG_TSF_RESET_OFFLOAD\n\nstatic void hw_var_set_monitor(PADAPTER Adapter, u8 variable, u8 *val)\n{\n\tu32\tvalue_rcr, rcr_bits;\n\tu16\tvalue_rxfltmap2;\n\tHAL_DATA_TYPE *pHalData = GET_HAL_DATA(Adapter);\n\tstruct mlme_priv *pmlmepriv = &(Adapter->mlmepriv);\n\n\tif (*((u8 *)val) == _HW_STATE_MONITOR_) {\n\n\t\t/* Leave IPS */\n\t\trtw_pm_set_ips(Adapter, IPS_NONE);\n\t\tLeaveAllPowerSaveMode(Adapter);\n\n\t\t/* Receive all type */\n\t\trcr_bits = RCR_AAP | RCR_APM | RCR_AM | RCR_AB | RCR_APWRMGT | RCR_ADF | RCR_ACF | RCR_AMF | RCR_APP_PHYST_RXFF;\n\n\t\t/* Append FCS */\n\t\trcr_bits |= RCR_APPFCS;\n\n\t\t#if 0\n\t\t/* \n\t\t   CRC and ICV packet will drop in recvbuf2recvframe()\n\t\t   We no turn on it.\n\t\t */\n\t\trcr_bits |= (RCR_ACRC32 | RCR_AICV);\n\t\t#endif\n\n\t\t/* Receive all data frames */\n\t\tvalue_rxfltmap2 = 0xFFFF;\n\n\t\tvalue_rcr = rcr_bits;\n\t\trtw_write32(Adapter, REG_RCR, value_rcr);\n\n\t\trtw_write16(Adapter, REG_RXFLTMAP2, value_rxfltmap2);\n\n\t\t#if 0\n\t\t/* tx pause */\n\t\trtw_write8(padapter, REG_TXPAUSE, 0xFF);\n\t\t#endif\n\t} else {\n\t\t/* do nothing */\n\t}\n\n}\n\nstatic void hw_var_set_opmode(PADAPTER padapter, u8 variable, u8* val)\n{\n\tu8 val8;\n\tu8 mode = *((u8 *)val);\n\n\tHAL_DATA_TYPE\t\t\t*pHalData = GET_HAL_DATA(padapter);\n\n\t/* reset RCR */\n\trtw_write32(padapter, REG_RCR, pHalData->ReceiveConfig);\n\n\tif (mode == _HW_STATE_MONITOR_) {\n\t\t/* set net_type */\n\t\tSet_MSR(padapter, _HW_STATE_NOLINK_);\n\n\t\thw_var_set_monitor(padapter, variable, val);\n\t\treturn;\n\t}\n\n#ifdef CONFIG_CONCURRENT_MODE\n\tif (padapter->iface_type == IFACE_PORT1)\n\t{\n\t\t// disable Port1 TSF update\n\t\tval8 = rtw_read8(padapter, REG_BCN_CTRL_1);\n\t\tval8 |= DIS_TSF_UDT;\n\t\trtw_write8(padapter, REG_BCN_CTRL_1, val8);\n\t\t\n\t\tSet_MSR(padapter, mode);\n\t\t\n\t\tDBG_871X(\"#### %s()-%d iface_type(%d) mode=%d ####\\n\",\n\t\t\t__FUNCTION__, __LINE__, padapter->iface_type, mode);\n\n\t\tif ((mode == _HW_STATE_STATION_) || (mode == _HW_STATE_NOLINK_))\n\t\t{\n\t\t\tif (!check_buddy_mlmeinfo_state(padapter, WIFI_FW_AP_STATE))\n\t\t\t{\n\t\t\t\tStopTxBeacon(padapter);\n#ifdef CONFIG_PCI_HCI\n\t\t\t\tUpdateInterruptMask8723BE(padapter, 0, 0, RT_BCN_INT_MASKS, 0);\n#else // !CONFIG_PCI_HCI\n#ifdef CONFIG_INTERRUPT_BASED_TXBCN\t\n\n#ifdef CONFIG_INTERRUPT_BASED_TXBCN_EARLY_INT\t\n\t\t\t\trtw_write8(padapter, REG_DRVERLYINT, 0x05);//restore early int time to 5ms\n\t\t\t\tUpdateInterruptMask8723BU(padapter, _TRUE, 0, IMR_BCNDMAINT0_8723B);\n#endif // CONFIG_INTERRUPT_BASED_TXBCN_EARLY_INT\n\n#ifdef CONFIG_INTERRUPT_BASED_TXBCN_BCN_OK_ERR\n\t\t\t\tUpdateInterruptMask8723BU(padapter, _TRUE ,0, (IMR_TXBCN0ERR_8723B|IMR_TXBCN0OK_8723B));\n#endif // CONFIG_INTERRUPT_BASED_TXBCN_BCN_OK_ERR\n\n#endif // CONFIG_INTERRUPT_BASED_TXBCN\n#endif // !CONFIG_PCI_HCI\n\t\t\t}\n\n\t\t\t// disable atim wnd and disable beacon function\n\t\t\trtw_write8(padapter, REG_BCN_CTRL_1, DIS_TSF_UDT|DIS_ATIM);\n\t\t}\n\t\telse if ((mode == _HW_STATE_ADHOC_) /*|| (mode == _HW_STATE_AP_)*/)\n\t\t{\n\t\t\tResumeTxBeacon(padapter);\n\t\t\trtw_write8(padapter, REG_BCN_CTRL_1, DIS_TSF_UDT|EN_BCN_FUNCTION|DIS_BCNQ_SUB);\n\t\t}\n\t\telse if (mode == _HW_STATE_AP_)\n\t\t{\n#ifdef CONFIG_PCI_HCI\n\t\t\tUpdateInterruptMask8723BE(padapter, RT_BCN_INT_MASKS, 0, 0, 0);\n#else // !CONFIG_PCI_HCI\n#ifdef CONFIG_INTERRUPT_BASED_TXBCN\n\n#ifdef  CONFIG_INTERRUPT_BASED_TXBCN_EARLY_INT\n\t\t\tUpdateInterruptMask8723BU(padapter, _TRUE, IMR_BCNDMAINT0_8723B, 0);\n#endif // CONFIG_INTERRUPT_BASED_TXBCN_EARLY_INT\n\n#ifdef CONFIG_INTERRUPT_BASED_TXBCN_BCN_OK_ERR\t\n\t\t\tUpdateInterruptMask8723BU(padapter, _TRUE, (IMR_TXBCN0ERR_8723B|IMR_TXBCN0OK_8723B), 0);\n#endif // CONFIG_INTERRUPT_BASED_TXBCN_BCN_OK_ERR\n\n#endif // CONFIG_INTERRUPT_BASED_TXBCN\n#endif // !CONFIG_PCI_HCI\n\n\t\t\tResumeTxBeacon(padapter);\n\n\t\t\trtw_write8(padapter, REG_BCN_CTRL_1, DIS_TSF_UDT|DIS_BCNQ_SUB);\n\n\t\t\t// Set RCR\n\t\t\t//rtw_write32(padapter, REG_RCR, 0x70002a8e);//CBSSID_DATA must set to 0\n\t\t\t//rtw_write32(padapter, REG_RCR, 0x7000228e);//CBSSID_DATA must set to 0\n\t\t\trtw_write32(padapter, REG_RCR, 0x7000208e);//CBSSID_DATA must set to 0,reject ICV_ERR packet\n\t\t\t// enable to rx data frame\t\t\t\t\n\t\t\trtw_write16(padapter, REG_RXFLTMAP2, 0xFFFF);\n\t\t\t// enable to rx ps-poll\n\t\t\trtw_write16(padapter, REG_RXFLTMAP1, 0x0400);\n\n\t\t\t// Beacon Control related register for first time \n\t\t\trtw_write8(padapter, REG_BCNDMATIM, 0x02); // 2ms\t\t\n\n\t\t\t//rtw_write8(padapter, REG_BCN_MAX_ERR, 0xFF);\n\t\t\trtw_write8(padapter, REG_ATIMWND_1, 0x0a); // 10ms for port1\n\t\t\trtw_write16(padapter, REG_BCNTCFG, 0x00);\n\t\t\trtw_write16(padapter, REG_TBTT_PROHIBIT, 0xff04);\n\t\t\trtw_write16(padapter, REG_TSFTR_SYN_OFFSET, 0x7fff);// +32767 (~32ms)\n\t\n\t\t\t// reset TSF2\t\n\t\t\trtw_write8(padapter, REG_DUAL_TSF_RST, BIT(1));\n\n\t\t\t// enable BCN1 Function for if2\n\t\t\t// don't enable update TSF1 for if2 (due to TSF update when beacon/probe rsp are received)\n\t\t\trtw_write8(padapter, REG_BCN_CTRL_1, (DIS_TSF_UDT|EN_BCN_FUNCTION | EN_TXBCN_RPT|DIS_BCNQ_SUB));\n\n\t\t\t//SW_BCN_SEL - Port1\n\t\t\t//rtw_write8(Adapter, REG_DWBCN1_CTRL_8192E+2, rtw_read8(Adapter, REG_DWBCN1_CTRL_8192E+2)|BIT4);\n\t\t\trtw_hal_set_hwreg(padapter, HW_VAR_DL_BCN_SEL, NULL);\n\t\t\t\n\t\t\t// select BCN on port 1\n\t\t\trtw_write8(padapter, REG_CCK_CHECK_8723B,\n\t\t\t\t(rtw_read8(padapter, REG_CCK_CHECK_8723B)|BIT_BCN_PORT_SEL));\n\t\t\t\n\t\t\tif (check_buddy_fwstate(padapter, WIFI_FW_NULL_STATE))\n\t\t\t{\n\t\t\t\tval8 = rtw_read8(padapter, REG_BCN_CTRL);\n\t\t\t\tval8 &= ~EN_BCN_FUNCTION;\n\t\t\t\trtw_write8(padapter, REG_BCN_CTRL, val8);\n\t\t\t}\n\n\t\t\t//BCN1 TSF will sync to BCN0 TSF with offset(0x518) if if1_sta linked\n\t\t\t//rtw_write8(padapter, REG_BCN_CTRL_1, rtw_read8(padapter, REG_BCN_CTRL_1)|BIT(5));\n\t\t\t//rtw_write8(padapter, REG_DUAL_TSF_RST, BIT(3));\n\t\t\t\t\t\n\t\t\t//dis BCN0 ATIM  WND if if1 is station\n\t\t\trtw_write8(padapter, REG_BCN_CTRL, rtw_read8(padapter, REG_BCN_CTRL)|DIS_ATIM);\n\n#ifdef CONFIG_TSF_RESET_OFFLOAD\n\t\t\t// Reset TSF for STA+AP concurrent mode\n\t\t\tif (check_buddy_fwstate(padapter, (WIFI_STATION_STATE|WIFI_ASOC_STATE)))\n\t\t\t{\n\t\t\t\tif (reset_tsf(padapter, IFACE_PORT1) == _FALSE)\n\t\t\t\t\tDBG_871X(\"ERROR! %s()-%d: Reset port1 TSF fail\\n\",\n\t\t\t\t\t\t__FUNCTION__, __LINE__);\n\t\t\t}\n#endif // CONFIG_TSF_RESET_OFFLOAD\n\t\t}\n\t}\n\telse //else for port0\n#endif // CONFIG_CONCURRENT_MODE\n\t{\n\t\t// disable Port0 TSF update\n\t\tval8 = rtw_read8(padapter, REG_BCN_CTRL);\n\t\tval8 |= DIS_TSF_UDT;\n\t\trtw_write8(padapter, REG_BCN_CTRL, val8);\n\n\t\t// set net_type\n\t\tSet_MSR(padapter, mode);\n\t\tDBG_871X(\"#### %s() -%d iface_type(0) mode = %d ####\\n\", __FUNCTION__, __LINE__, mode);\n\n\t\tif ((mode == _HW_STATE_STATION_) || (mode == _HW_STATE_NOLINK_))\n\t\t{\n#ifdef CONFIG_CONCURRENT_MODE\n\t\t\tif (!check_buddy_mlmeinfo_state(padapter, WIFI_FW_AP_STATE))\t\t\n#endif // CONFIG_CONCURRENT_MODE\n\t\t\t{\n\t\t\t\tStopTxBeacon(padapter);\n#ifdef CONFIG_PCI_HCI\n\t\t\t\tUpdateInterruptMask8723BE(padapter, 0, 0, RT_BCN_INT_MASKS, 0);\n#else // !CONFIG_PCI_HCI\n#ifdef CONFIG_INTERRUPT_BASED_TXBCN\n#ifdef CONFIG_INTERRUPT_BASED_TXBCN_EARLY_INT\n\t\t\t\trtw_write8(padapter, REG_DRVERLYINT, 0x05); // restore early int time to 5ms\n\t\t\t\tUpdateInterruptMask8812AU(padapter, _TRUE, 0, IMR_BCNDMAINT0_8723B);\n#endif // CONFIG_INTERRUPT_BASED_TXBCN_EARLY_INT\n\n#ifdef CONFIG_INTERRUPT_BASED_TXBCN_BCN_OK_ERR\n\t\t\t\tUpdateInterruptMask8812AU(padapter,_TRUE ,0, (IMR_TXBCN0ERR_8723B|IMR_TXBCN0OK_8723B));\n#endif // CONFIG_INTERRUPT_BASED_TXBCN_BCN_OK_ERR\n\n#endif // CONFIG_INTERRUPT_BASED_TXBCN\n#endif // !CONFIG_PCI_HCI\n\t\t\t}\n\n\t\t\t// disable atim wnd\n\t\t\trtw_write8(padapter, REG_BCN_CTRL, DIS_TSF_UDT|EN_BCN_FUNCTION|DIS_ATIM);\n\t\t\t//rtw_write8(padapter,REG_BCN_CTRL, 0x18);\n\t\t}\n\t\telse if ((mode == _HW_STATE_ADHOC_) /*|| (mode == _HW_STATE_AP_)*/)\n\t\t{\n\t\t\tResumeTxBeacon(padapter);\n\t\t\trtw_write8(padapter, REG_BCN_CTRL, DIS_TSF_UDT|EN_BCN_FUNCTION|DIS_BCNQ_SUB);\n\t\t}\n\t\telse if (mode == _HW_STATE_AP_)\n\t\t{\n#ifdef CONFIG_PCI_HCI\n\t\t\tUpdateInterruptMask8723BE( padapter, RT_BCN_INT_MASKS, 0, 0, 0);\n#else // !CONFIG_PCI_HCI\n#ifdef CONFIG_INTERRUPT_BASED_TXBCN\n#ifdef CONFIG_INTERRUPT_BASED_TXBCN_EARLY_INT\n\t\t\tUpdateInterruptMask8723BU(padapter, _TRUE ,IMR_BCNDMAINT0_8723B, 0);\n#endif // CONFIG_INTERRUPT_BASED_TXBCN_EARLY_INT\n\n#ifdef CONFIG_INTERRUPT_BASED_TXBCN_BCN_OK_ERR\n\t\t\tUpdateInterruptMask8723BU(padapter,_TRUE ,(IMR_TXBCN0ERR_8723B|IMR_TXBCN0OK_8723B), 0);\n#endif // CONFIG_INTERRUPT_BASED_TXBCN_BCN_OK_ERR\n\n#endif // CONFIG_INTERRUPT_BASED_TXBCN\n#endif\n\n\t\t\tResumeTxBeacon(padapter);\n\n\t\t\trtw_write8(padapter, REG_BCN_CTRL, DIS_TSF_UDT|DIS_BCNQ_SUB);\n\n\t\t\t//Set RCR\n\t\t\t//rtw_write32(padapter, REG_RCR, 0x70002a8e);//CBSSID_DATA must set to 0\n\t\t\t//rtw_write32(padapter, REG_RCR, 0x7000228e);//CBSSID_DATA must set to 0\n\t\t\trtw_write32(padapter, REG_RCR, 0x7000208e);//CBSSID_DATA must set to 0,reject ICV_ERR packet\n\t\t\t//enable to rx data frame\n\t\t\trtw_write16(padapter, REG_RXFLTMAP2, 0xFFFF);\n\t\t\t//enable to rx ps-poll\n\t\t\trtw_write16(padapter, REG_RXFLTMAP1, 0x0400);\n\n\t\t\t//Beacon Control related register for first time\n\t\t\trtw_write8(padapter, REG_BCNDMATIM, 0x02); // 2ms\t\t\t\n\t\t\t\n\t\t\t//rtw_write8(padapter, REG_BCN_MAX_ERR, 0xFF);\n\t\t\trtw_write8(padapter, REG_ATIMWND, 0x0a); // 10ms\n\t\t\trtw_write16(padapter, REG_BCNTCFG, 0x00);\n\t\t\trtw_write16(padapter, REG_TBTT_PROHIBIT, 0xff04);\n\t\t\trtw_write16(padapter, REG_TSFTR_SYN_OFFSET, 0x7fff);// +32767 (~32ms)\n\n\t\t\t//reset TSF\n\t\t\trtw_write8(padapter, REG_DUAL_TSF_RST, BIT(0));\n\t\n\t\t\t//enable BCN0 Function for if1\n\t\t\t//don't enable update TSF0 for if1 (due to TSF update when beacon/probe rsp are received)\n\t\t\trtw_write8(padapter, REG_BCN_CTRL, (DIS_TSF_UDT|EN_BCN_FUNCTION|EN_TXBCN_RPT|DIS_BCNQ_SUB));\n\t\t\n\t\t\t//SW_BCN_SEL - Port0\n\t\t\t//rtw_write8(Adapter, REG_DWBCN1_CTRL_8192E+2, rtw_read8(Adapter, REG_DWBCN1_CTRL_8192E+2) & ~BIT4);\n\t\t\trtw_hal_set_hwreg(padapter, HW_VAR_DL_BCN_SEL, NULL);\n\t\t\t\n\t\t\t// select BCN on port 0\n\t\t\trtw_write8(padapter, REG_CCK_CHECK_8723B,\n\t\t\t\t(rtw_read8(padapter, REG_CCK_CHECK_8723B)& ~BIT_BCN_PORT_SEL));\t\t\t\t\n\n#ifdef CONFIG_CONCURRENT_MODE\n\t\t\tif (check_buddy_fwstate(padapter, WIFI_FW_NULL_STATE))\n\t\t\t{\n\t\t\t\tval8 = rtw_read8(padapter, REG_BCN_CTRL_1);\n\t\t\t\tval8 &= ~EN_BCN_FUNCTION;\n\t\t\t\trtw_write8(padapter, REG_BCN_CTRL_1, val8);\n\t\t\t}\n#endif // CONFIG_CONCURRENT_MODE\n\n\t\t\t// dis BCN1 ATIM  WND if if2 is station\n\t\t\tval8 = rtw_read8(padapter, REG_BCN_CTRL_1);\n\t\t\tval8 |= DIS_ATIM;\n\t\t\trtw_write8(padapter, REG_BCN_CTRL_1, val8);\n#ifdef CONFIG_TSF_RESET_OFFLOAD\n\t\t\t// Reset TSF for STA+AP concurrent mode\n\t\t\tif (check_buddy_fwstate(padapter, (WIFI_STATION_STATE|WIFI_ASOC_STATE)))\n\t\t\t{\n\t\t\t\tif (reset_tsf(padapter, IFACE_PORT0) == _FALSE)\n\t\t\t\t\tDBG_871X(\"ERROR! %s()-%d: Reset port0 TSF fail\\n\",\n\t\t\t\t\t\t__FUNCTION__, __LINE__);\n\t\t\t}\n#endif\t// CONFIG_TSF_RESET_OFFLOAD\n\t\t}\n\t}\n}\n\nstatic void hw_var_set_macaddr(PADAPTER padapter, u8 variable, u8 *val)\n{\n\tu8 idx = 0;\n\tu32 reg_macid;\n\n#ifdef CONFIG_CONCURRENT_MODE\n\tif (padapter->iface_type == IFACE_PORT1)\n\t{\n\t\treg_macid = REG_MACID1;\n\t}\n\telse\n#endif\n\t{\n\t\treg_macid = REG_MACID;\n\t}\n\n\tfor (idx = 0 ; idx < 6; idx++)\n\t{\n\t\trtw_write8(GET_PRIMARY_ADAPTER(padapter), (reg_macid+idx), val[idx]);\n\t}\n}\n\nstatic void hw_var_set_bssid(PADAPTER padapter, u8 variable, u8 *val)\n{\n\tu8\tidx = 0;\n\tu32 reg_bssid;\n\n#ifdef CONFIG_CONCURRENT_MODE\n\tif (padapter->iface_type == IFACE_PORT1)\n\t{\n\t\treg_bssid = REG_BSSID1;\n\t}\n\telse\n#endif\n\t{\n\t\treg_bssid = REG_BSSID;\n\t}\n\n\tfor (idx = 0 ; idx < 6; idx++)\n\t{\n\t\trtw_write8(padapter, (reg_bssid+idx), val[idx]);\n\t}\n}\n\nstatic void hw_var_set_bcn_func(PADAPTER padapter, u8 variable, u8 *val)\n{\n\tu32 bcn_ctrl_reg;\n\n#ifdef CONFIG_CONCURRENT_MODE\n\tif (padapter->iface_type == IFACE_PORT1)\n\t{\n\t\tbcn_ctrl_reg = REG_BCN_CTRL_1;\n\t}\n\telse\n#endif\n\t{\n\t\tbcn_ctrl_reg = REG_BCN_CTRL;\n\t}\n\n\tif (*(u8*)val)\n\t{\n\t\trtw_write8(padapter, bcn_ctrl_reg, (EN_BCN_FUNCTION | EN_TXBCN_RPT));\n\t}\n\telse\n\t{\n\t\tu8 val8;\n\t\tval8 = rtw_read8(padapter, bcn_ctrl_reg);\n\t\tval8 &= ~(EN_BCN_FUNCTION | EN_TXBCN_RPT);\n#ifdef CONFIG_BT_COEXIST\n\t\t// Always enable port0 beacon function for PSTDMA\n\t\tif (REG_BCN_CTRL == bcn_ctrl_reg)\n\t\t\tval8 |= EN_BCN_FUNCTION;\n#endif\n\t\trtw_write8(padapter, bcn_ctrl_reg, val8);\n\t}\n}\n\nstatic void hw_var_set_correct_tsf(PADAPTER padapter, u8 variable, u8* val)\n{\n\tu8 val8;\n\tu64\ttsf;\n\tstruct mlme_ext_priv *pmlmeext;\n\tstruct mlme_ext_info *pmlmeinfo;\n\n\n\tpmlmeext = &padapter->mlmeextpriv;\n\tpmlmeinfo = &pmlmeext->mlmext_info;\n\t\n\ttsf = pmlmeext->TSFValue - rtw_modular64(pmlmeext->TSFValue, (pmlmeinfo->bcn_interval*1024)) -1024; //us\n\n\tif (((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) ||\n\t\t((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))\n\t{\n\t\tStopTxBeacon(padapter);\n\t}\n\n#ifdef CONFIG_CONCURRENT_MODE\n\tif (padapter->iface_type == IFACE_PORT1)\n\t{\n\t\t// disable related TSF function\n\t\tval8 = rtw_read8(padapter, REG_BCN_CTRL_1);\n\t\tval8 &= ~EN_BCN_FUNCTION;\n\t\trtw_write8(padapter, REG_BCN_CTRL_1, val8);\n\n\t\trtw_write32(padapter, REG_TSFTR1, tsf);\n\t\trtw_write32(padapter, REG_TSFTR1+4, tsf>>32);\n\n\n\t\t// enable related TSF function\n\t\tval8 = rtw_read8(padapter, REG_BCN_CTRL_1);\n\t\tval8 |= EN_BCN_FUNCTION;\n\t\trtw_write8(padapter, REG_BCN_CTRL_1, val8);\n\n\t\t// Update buddy port's TSF if it is SoftAP for beacon TX issue!\n\t\tif ((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE\n\t\t\t&& check_buddy_fwstate(padapter, WIFI_AP_STATE)\n\t\t\t)\n\t\t{\n\t\t\t// disable related TSF function\n\t\t\tval8 = rtw_read8(padapter, REG_BCN_CTRL);\n\t\t\tval8 &= ~EN_BCN_FUNCTION;\n\t\t\trtw_write8(padapter, REG_BCN_CTRL, val8);\n\n\t\t\trtw_write32(padapter, REG_TSFTR, tsf);\n\t\t\trtw_write32(padapter, REG_TSFTR+4, tsf>>32);\n\n\t\t\t// enable related TSF function\n\t\t\tval8 = rtw_read8(padapter, REG_BCN_CTRL);\n\t\t\tval8 |= EN_BCN_FUNCTION;\n\t\t\trtw_write8(padapter, REG_BCN_CTRL, val8);\n#ifdef CONFIG_TSF_RESET_OFFLOAD\n\t\t\t// Update buddy port's TSF(TBTT) if it is SoftAP for beacon TX issue!\n\t\t\tif (reset_tsf(padapter, IFACE_PORT0) == _FALSE)\n\t\t\t\tDBG_871X(\"ERROR! %s()-%d: Reset port0 TSF fail\\n\",\n\t\t\t\t\t__FUNCTION__, __LINE__);\n\n#endif // CONFIG_TSF_RESET_OFFLOAD\n\t\t}\n\t}\n\telse\n#endif // CONFIG_CONCURRENT_MODE\n\t{\n\t\t// disable related TSF function\n\t\tval8 = rtw_read8(padapter, REG_BCN_CTRL);\n\t\tval8 &= ~EN_BCN_FUNCTION;\n\t\trtw_write8(padapter, REG_BCN_CTRL, val8);\n\n\t\trtw_write32(padapter, REG_TSFTR, tsf);\n\t\trtw_write32(padapter, REG_TSFTR+4, tsf>>32);\n\n\t\t// enable related TSF function\n\t\tval8 = rtw_read8(padapter, REG_BCN_CTRL);\n\t\tval8 |= EN_BCN_FUNCTION;\n\t\trtw_write8(padapter, REG_BCN_CTRL, val8);\n\n#ifdef CONFIG_CONCURRENT_MODE\n\t\t// Update buddy port's TSF if it is SoftAP for beacon TX issue!\n\t\tif ((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE\n\t\t\t&& check_buddy_fwstate(padapter, WIFI_AP_STATE))\n\t\t{\n\t\t\t// disable related TSF function\n\t\t\tval8 = rtw_read8(padapter, REG_BCN_CTRL_1);\n\t\t\tval8 &= ~EN_BCN_FUNCTION;\n\t\t\trtw_write8(padapter, REG_BCN_CTRL_1, val8);\n\n\t\t\trtw_write32(padapter, REG_TSFTR1, tsf);\n\t\t\trtw_write32(padapter, REG_TSFTR1+4, tsf>>32);\n\n\t\t\t// enable related TSF function\n\t\t\tval8 = rtw_read8(padapter, REG_BCN_CTRL_1);\n\t\t\tval8 |= EN_BCN_FUNCTION;\n\t\t\trtw_write8(padapter, REG_BCN_CTRL_1, val8);\n\n#ifdef CONFIG_TSF_RESET_OFFLOAD\n\t\t\t// Update buddy port's TSF if it is SoftAP for beacon TX issue!\n\t\t\tif (reset_tsf(padapter, IFACE_PORT1) == _FALSE)\n\t\t\t{\n\t\t\t\tDBG_871X(\"ERROR! %s()-%d: Reset port1 TSF fail\\n\",\n\t\t\t\t\t__FUNCTION__, __LINE__);\n\t\t\t}\n#endif // CONFIG_TSF_RESET_OFFLOAD\n\t\t}\n#endif // CONFIG_CONCURRENT_MODE\n\t}\n\n\tif (((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE)\n\t\t|| ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))\n\t{\n\t\tResumeTxBeacon(padapter);\n\t}\n}\n\nstatic void hw_var_set_mlme_disconnect(PADAPTER padapter, u8 variable, u8 *val)\n{\n\tu8 val8;\n\n#ifdef CONFIG_CONCURRENT_MODE\n\tif (check_buddy_mlmeinfo_state(padapter, _HW_STATE_NOLINK_))\n#endif\n\t{\n\t\t// Set RCR to not to receive data frame when NO LINK state\n\t\t//rtw_write32(padapter, REG_RCR, rtw_read32(padapter, REG_RCR) & ~RCR_ADF);\n\t\t// reject all data frames\n\t\trtw_write16(padapter, REG_RXFLTMAP2, 0);\n\t}\n\n#ifdef CONFIG_CONCURRENT_MODE\n\tif (padapter->iface_type == IFACE_PORT1)\n\t{\n\t\t// reset TSF1\n\t\trtw_write8(padapter, REG_DUAL_TSF_RST, BIT(1));\n\n\t\t// disable update TSF1\n\t\tval8 = rtw_read8(padapter, REG_BCN_CTRL_1);\n\t\tval8 |= DIS_TSF_UDT;\n\t\trtw_write8(padapter, REG_BCN_CTRL_1, val8);\n\t\t\n\t\t// disable Port1's beacon function\n\t\tval8 = rtw_read8(padapter, REG_BCN_CTRL_1);\n\t\tval8 &= ~EN_BCN_FUNCTION;\n\t\trtw_write8(padapter, REG_BCN_CTRL_1, val8);\n\t}\n\telse\n#endif\n\t{\n\t\t// reset TSF\n\t\trtw_write8(padapter, REG_DUAL_TSF_RST, BIT(0));\n\n\t\t// disable update TSF\n\t\tval8 = rtw_read8(padapter, REG_BCN_CTRL);\n\t\tval8 |= DIS_TSF_UDT;\n\t\trtw_write8(padapter, REG_BCN_CTRL, val8);\n\t}\n}\n\nstatic void hw_var_set_mlme_sitesurvey(PADAPTER padapter, u8 variable, u8* val)\n{\n\tu32\tvalue_rcr, rcr_clear_bit, reg_bcn_ctl;\n\tu16\tvalue_rxfltmap2;\n\tu8 val8;\n\tPHAL_DATA_TYPE pHalData;\n\tstruct mlme_priv *pmlmepriv;\n\n\n\tpHalData = GET_HAL_DATA(padapter);\n\tpmlmepriv = &padapter->mlmepriv;\n\n#ifdef CONFIG_CONCURRENT_MODE\n\tif (padapter->iface_type == IFACE_PORT1)\n\t\treg_bcn_ctl = REG_BCN_CTRL_1;\n\telse\n#endif\n\t\treg_bcn_ctl = REG_BCN_CTRL;\n\n#ifdef CONFIG_FIND_BEST_CHANNEL\n\trcr_clear_bit = (RCR_CBSSID_BCN | RCR_CBSSID_DATA);\n\n\t/* Receive all data frames */\n\tvalue_rxfltmap2 = 0xFFFF;\n#else // CONFIG_FIND_BEST_CHANNEL\n\n\trcr_clear_bit = RCR_CBSSID_BCN;\n\n\t// config RCR to receive different BSSID & not to receive data frame\n\tvalue_rxfltmap2 = 0;\n\n#endif // CONFIG_FIND_BEST_CHANNEL\n\n\tif ((check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)\n#ifdef CONFIG_CONCURRENT_MODE\n\t\t|| (check_buddy_fwstate(padapter, WIFI_AP_STATE) == _TRUE)\n#endif\n\t\t)\n\t{\n\t\trcr_clear_bit = RCR_CBSSID_BCN;\n\t}\n#ifdef CONFIG_TDLS\n\t// TDLS will clear RCR_CBSSID_DATA bit for connection.\n\telse if (padapter->tdlsinfo.link_established == _TRUE)\n\t{\n\t\trcr_clear_bit = RCR_CBSSID_BCN;\n\t}\n#endif // CONFIG_TDLS\n\n\tvalue_rcr = rtw_read32(padapter, REG_RCR);\n\n\tif (*((u8*)val))\n\t{\n\t\t// under sitesurvey\n\t\tvalue_rcr &= ~(rcr_clear_bit);\n\t\trtw_write32(padapter, REG_RCR, value_rcr);\n\n\t\trtw_write16(padapter, REG_RXFLTMAP2, value_rxfltmap2);\n\n\t\tif (check_fwstate(pmlmepriv, WIFI_STATION_STATE | WIFI_ADHOC_STATE | WIFI_ADHOC_MASTER_STATE))\n\t\t{\n\t\t\t// disable update TSF\n\t\t\tval8 = rtw_read8(padapter, reg_bcn_ctl);\n\t\t\tval8 |= DIS_TSF_UDT;\n\t\t\trtw_write8(padapter, reg_bcn_ctl, val8);\n\t\t}\n\n\t\t// Save orignal RRSR setting.\n\t\tpHalData->RegRRSR = rtw_read16(padapter, REG_RRSR);\n\n#ifdef CONFIG_CONCURRENT_MODE\n\t\tif (check_buddy_mlmeinfo_state(padapter, WIFI_FW_AP_STATE) &&\n\t\t\tcheck_buddy_fwstate(padapter, _FW_LINKED))\n\t\t{\n\t\t\tStopTxBeacon(padapter);\n\t\t}\n#endif\n\t}\n\telse\n\t{\n\t\t// sitesurvey done\n\t\tif (check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE))\n#ifdef CONFIG_CONCURRENT_MODE\n\t\t\t|| check_buddy_fwstate(padapter, (_FW_LINKED|WIFI_AP_STATE))\n#endif\n\t\t\t)\n\t\t{\n\t\t\t// enable to rx data frame\n\t\t\trtw_write16(padapter, REG_RXFLTMAP2, 0xFFFF);\n\t\t}\n\n\t\tif (check_fwstate(pmlmepriv, WIFI_STATION_STATE | WIFI_ADHOC_STATE | WIFI_ADHOC_MASTER_STATE))\n\t\t{\n\t\t\t// enable update TSF\n\t\t\tval8 = rtw_read8(padapter, reg_bcn_ctl);\n\t\t\tval8 &= ~DIS_TSF_UDT;\n\t\t\trtw_write8(padapter, reg_bcn_ctl, val8);\n\t\t}\n\n\t\tvalue_rcr |= rcr_clear_bit;\n\t\trtw_write32(padapter, REG_RCR, value_rcr);\n\n\t\t// Restore orignal RRSR setting.\n\t\trtw_write16(padapter, REG_RRSR, pHalData->RegRRSR);\n\n#ifdef CONFIG_CONCURRENT_MODE\n\t\tif (check_buddy_mlmeinfo_state(padapter, WIFI_FW_AP_STATE) &&\n\t\t\tcheck_buddy_fwstate(padapter, _FW_LINKED))\n\t\t{\n\t\t\tResumeTxBeacon(padapter);\n\t\t}\n#endif\n\t}\n}\n\nstatic void hw_var_set_mlme_join(PADAPTER padapter, u8 variable, u8 *val)\n{\n\tu8 val8;\n\tu16 val16;\n\tu32 val32;\n\tu8 RetryLimit;\n\tu8 type;\n\tPHAL_DATA_TYPE pHalData;\n\tstruct mlme_priv *pmlmepriv;\n\n\tRetryLimit = 0x30;\n\ttype = *(u8*)val;\n\tpHalData = GET_HAL_DATA(padapter);\n\tpmlmepriv = &padapter->mlmepriv;\n\n#ifdef CONFIG_CONCURRENT_MODE\n\tif (type == 0)\n\t{\n\t\t// prepare to join\n\t\tif (check_buddy_mlmeinfo_state(padapter, WIFI_FW_AP_STATE) &&\n\t\t\tcheck_buddy_fwstate(padapter, _FW_LINKED))\n\t\t{\n\t\t\tStopTxBeacon(padapter);\n\t\t}\n\n\t\t// enable to rx data frame.Accept all data frame\n\t\trtw_write16(padapter, REG_RXFLTMAP2, 0xFFFF);\n\n\t\tif (check_buddy_mlmeinfo_state(padapter, WIFI_FW_AP_STATE))\n\t\t{\n\t\t\tval32 = rtw_read32(padapter, REG_RCR);\n\t\t\tval32 |= RCR_CBSSID_BCN;\n\t\t\trtw_write32(padapter, REG_RCR, val32);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tval32 = rtw_read32(padapter, REG_RCR);\n\t\t\tval32 |= RCR_CBSSID_DATA | RCR_CBSSID_BCN;\n\t\t\trtw_write32(padapter, REG_RCR, val32);\n\t\t}\n\n\t\tif (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _TRUE)\n\t\t{\n\t\t\tRetryLimit = (pHalData->CustomerID == RT_CID_CCX) ? 7 : 48;\n\t\t}\n\t\telse // Ad-hoc Mode\n\t\t{\n\t\t\tRetryLimit = 0x7;\n\t\t}\n\t}\n\telse if (type == 1)\n\t{\n\t\t// joinbss_event call back when join res < 0\n\t\tif (check_buddy_mlmeinfo_state(padapter, _HW_STATE_NOLINK_))\n\t\t\trtw_write16(padapter, REG_RXFLTMAP2, 0x00);\n\n\t\tif (check_buddy_mlmeinfo_state(padapter, WIFI_FW_AP_STATE) &&\n\t\t\tcheck_buddy_fwstate(padapter, _FW_LINKED))\n\t\t{\n\t\t\tResumeTxBeacon(padapter);\n\n\t\t\t// reset TSF 1/2 after ResumeTxBeacon\n\t\t\trtw_write8(padapter, REG_DUAL_TSF_RST, BIT(1)|BIT(0));\n\t\t}\n\t}\n\telse if (type == 2)\n\t{\n\t\t// sta add event call back\n\n\t\t// enable update TSF\n\t\tif (padapter->iface_type == IFACE_PORT1)\n\t\t{\n\t\t\tval8 = rtw_read8(padapter, REG_BCN_CTRL_1);\n\t\t\tval8 &= ~DIS_TSF_UDT;\n\t\t\trtw_write8(padapter, REG_BCN_CTRL_1, val8);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tval8 = rtw_read8(padapter, REG_BCN_CTRL);\n\t\t\tval8 &= ~DIS_TSF_UDT;\n\t\t\trtw_write8(padapter, REG_BCN_CTRL, val8);\n\t\t}\n\n\t\tif (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE))\n\t\t{\n\t\t\trtw_write8(padapter, 0x542 ,0x02);\n\t\t\tRetryLimit = 0x7;\n\t\t}\n\n\t\tif (check_buddy_mlmeinfo_state(padapter, WIFI_FW_AP_STATE) &&\n\t\t\tcheck_buddy_fwstate(padapter, _FW_LINKED))\n\t\t{\n\t\t\tResumeTxBeacon(padapter);\n\n\t\t\t// reset TSF 1/2 after ResumeTxBeacon\n\t\t\trtw_write8(padapter, REG_DUAL_TSF_RST, BIT(1)|BIT(0));\n\t\t}\n\t}\n\n\tval16 = (RetryLimit << RETRY_LIMIT_SHORT_SHIFT) | (RetryLimit << RETRY_LIMIT_LONG_SHIFT);\n\trtw_write16(padapter, REG_RL, val16);\n#else // !CONFIG_CONCURRENT_MODE\n\tif (type == 0) // prepare to join\n\t{\n\t\t//enable to rx data frame.Accept all data frame\n\t\t//rtw_write32(padapter, REG_RCR, rtw_read32(padapter, REG_RCR)|RCR_ADF);\n\t\trtw_write16(padapter, REG_RXFLTMAP2, 0xFFFF);\n\n\t\tval32 = rtw_read32(padapter, REG_RCR);\n\t\tif (padapter->in_cta_test)\n\t\t\tval32 &= ~(RCR_CBSSID_DATA | RCR_CBSSID_BCN);//| RCR_ADF\n\t\telse\n\t\t\tval32 |= RCR_CBSSID_DATA|RCR_CBSSID_BCN;\n\t\trtw_write32(padapter, REG_RCR, val32);\n\n\t\tif (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _TRUE)\n\t\t{\n\t\t\tRetryLimit = (pHalData->CustomerID == RT_CID_CCX) ? 7 : 48;\n\t\t}\n\t\telse // Ad-hoc Mode\n\t\t{\n\t\t\tRetryLimit = 0x7;\n\t\t}\n\t}\n\telse if (type == 1) //joinbss_event call back when join res < 0\n\t{\n\t\trtw_write16(padapter, REG_RXFLTMAP2, 0x00);\n\t}\n\telse if (type == 2) //sta add event call back\n\t{\n\t\t//enable update TSF\n\t\tval8 = rtw_read8(padapter, REG_BCN_CTRL);\n\t\tval8 &= ~DIS_TSF_UDT;\n\t\trtw_write8(padapter, REG_BCN_CTRL, val8);\n\n\t\tif (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE))\n\t\t{\n\t\t\tRetryLimit = 0x7;\n\t\t}\n\t}\n\n\tval16 = (RetryLimit << RETRY_LIMIT_SHORT_SHIFT) | (RetryLimit << RETRY_LIMIT_LONG_SHIFT);\n\trtw_write16(padapter, REG_RL, val16);\n#endif // !CONFIG_CONCURRENT_MODE\n}\n\nvoid CCX_FwC2HTxRpt_8723b(PADAPTER padapter, u8 *pdata, u8 len)\n{\n\tu8 seq_no;\n\t\n#define\tGET_8723B_C2H_TX_RPT_LIFE_TIME_OVER(_Header)\tLE_BITS_TO_1BYTE((_Header + 0), 6, 1)\n#define\tGET_8723B_C2H_TX_RPT_RETRY_OVER(_Header)\tLE_BITS_TO_1BYTE((_Header + 0), 7, 1)\n\n\t//DBG_871X(\"%s, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x\\n\", __func__, \n\t//\t\t*pdata, *(pdata+1), *(pdata+2), *(pdata+3), *(pdata+4), *(pdata+5), *(pdata+6), *(pdata+7));\n\n\tseq_no = *(pdata+6);\n\n#ifdef CONFIG_XMIT_ACK\n\tif (GET_8723B_C2H_TX_RPT_RETRY_OVER(pdata) | GET_8723B_C2H_TX_RPT_LIFE_TIME_OVER(pdata)) {\n\t\trtw_ack_tx_done(&padapter->xmitpriv, RTW_SCTX_DONE_CCX_PKT_FAIL);\n\t}\n/*\t\n\telse if(seq_no != padapter->xmitpriv.seq_no) {\n\t\tDBG_871X(\"tx_seq_no=%d, rpt_seq_no=%d\\n\", padapter->xmitpriv.seq_no, seq_no);\n\t\trtw_ack_tx_done(&padapter->xmitpriv, RTW_SCTX_DONE_CCX_PKT_FAIL);\n\t} \n*/\t\n\telse {\n\t\trtw_ack_tx_done(&padapter->xmitpriv, RTW_SCTX_DONE_SUCCESS);\n\t}\n#endif\n}\n\ns32 c2h_id_filter_ccx_8723b(u8 *buf)\n{\n\tstruct c2h_evt_hdr_88xx *c2h_evt = (struct c2h_evt_hdr_88xx *)buf;\n\ts32 ret = _FALSE;\n\tif (c2h_evt->id == C2H_CCX_TX_RPT)\n\t\tret = _TRUE;\n\t\n\treturn ret;\n}\n\n\ns32 c2h_handler_8723b(PADAPTER padapter, u8 *buf)\n{\n\tstruct c2h_evt_hdr_88xx *pC2hEvent = (struct c2h_evt_hdr_88xx *)buf;\n\tPHAL_DATA_TYPE\tpHalData=GET_HAL_DATA(padapter);\n\tstruct mlme_ext_priv\t*pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info\t*pmlmeinfo = &(pmlmeext->mlmext_info);\n\ts32 ret = _SUCCESS;\n\tu8 index = 0;\n\n\tif (pC2hEvent == NULL) {\n\t\tDBG_8192C(\"%s(): pC2hEventis NULL\\n\",__FUNCTION__);\n\t\tret = _FAIL;\n\t\tgoto exit;\n\t}\n\n\tswitch (pC2hEvent->id)\n\t{\n\t\tcase C2H_AP_RPT_RSP:\n\t\t\t{\n//YJ,TODO,130407\n#if 0\n\t\t\t\tu4Byte c2h_ap_keeplink = _TRUE;\n\t\t\t\tif (c2hBuf[2] == 0 && c2hBuf[3] == 0)\n\t\t\t\t\tc2h_ap_keeplink = _FALSE;\n\t\t\t\telse\n\t\t\t\t\tc2h_ap_keeplink = _TRUE;\n\n\t\t\t\tif (_TRUE == pmlmeext->try_ap_c2h_wait) {\n\t\t\t\t\tif (_FALSE == c2h_ap_keeplink) {\n\t\t\t\t\t\tpmlmeext->try_ap_c2h_wait = _FALSE;\n\t\t\t\t\t\tRT_TRACE(_module_hal_init_c_, _drv_err_,(\"fw tell us link is off\\n\"));\n\t\t\t\t\t\treceive_disconnect(padapter, pmlmeinfo->network.MacAddress , 65535);\n\t\t\t\t\t} else  {\n\t\t\t\t\t\tRT_TRACE(_module_hal_init_c_, _drv_err_,(\"fw tell us link is on\\n\"));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tRT_TRACE(_module_hal_init_c_, _drv_err_,(\"we don't need this C2H\\n\"));\n\t\t\t\t}\n\t\t\t\tpmlmeext->check_ap_processing = _FALSE;\n#endif\t\t\t\t\n\t\t\t}\n\t\t\tbreak;\n\t\tcase C2H_DBG:\n\t\t\t{\n\t\t\t\tRT_TRACE(_module_hal_init_c_, _drv_info_, (\"c2h_handler_8723b: %s\\n\", pC2hEvent->payload));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase C2H_CCX_TX_RPT:\n//\t\t\tCCX_FwC2HTxRpt(padapter, QueueID, pC2hEvent->payload);\n\t\t\tbreak;\n\n#ifdef CONFIG_BT_COEXIST\n#ifdef CONFIG_PCI_HCI\n\t\tcase C2H_BT_RSSI:\n//\t\t\tfwc2h_ODM(padapter, tmpBuf, &C2hEvent);\n\t\t\t//BT_FwC2hBtRssi(padapter, pC2hEvent->payload);\n\t\t\tbreak;\n#endif\n#endif\n\n\t\tcase C2H_EXT_RA_RPT:\n//\t\t\tC2HExtRaRptHandler(padapter, pC2hEvent->payload, C2hEvent.CmdLen);\n\t\t\tbreak;\n\n\t\tcase C2H_HW_INFO_EXCH:\n\t\t\tRT_TRACE(_module_hal_init_c_, _drv_info_, (\"[BT], C2H_HW_INFO_EXCH\\n\"));\n\t\t\tfor (index = 0; index < pC2hEvent->plen; index++)\n\t\t\t{\n\t\t\t\tRT_TRACE(_module_hal_init_c_, _drv_info_, (\"[BT], tmpBuf[%d]=0x%x\\n\", index, pC2hEvent->payload[index]));\n\t\t\t}\n\t\t\tbreak;\n\n#ifdef CONFIG_BT_COEXIST\n\t\tcase C2H_8723B_BT_INFO:\n\t\t\trtw_btcoex_BtInfoNotify(padapter, pC2hEvent->plen, pC2hEvent->payload);\n\t\t\tbreak;\n#endif\n\n#ifdef CONFIG_MP_INCLUDED\n\t\tcase C2H_8723B_BT_MP_INFO:\n\t\t\tDBG_8192C(\" %s, C2H_8723B_BT_MP_INFO pC2hEvent->plen=%d\\n\",__func__,pC2hEvent->plen);\n\t\t\tMPTBT_FwC2hBtMpCtrl(padapter, pC2hEvent->payload, pC2hEvent->plen);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\t// Clear event to notify FW we have read the command.\n\t// Note:\n\t//\tIf this field isn't clear, the FW won't update the next command message.\n//\trtw_write8(padapter, REG_C2HEVT_CLEAR, C2H_EVT_HOST_CLOSE);\nexit:\n\treturn ret;\n}\n\nstatic void process_c2h_event(PADAPTER padapter, PC2H_EVT_HDR pC2hEvent, u8 *c2hBuf)\n{\n\tu8\t\t\t\tindex = 0;\n\tPHAL_DATA_TYPE\tpHalData=GET_HAL_DATA(padapter);\n\tstruct mlme_ext_priv\t*pmlmeext = &padapter->mlmeextpriv;\n\tstruct mlme_ext_info\t*pmlmeinfo = &(pmlmeext->mlmext_info);\n\n\tif (c2hBuf == NULL) {\n\t\tDBG_8192C(\"%s c2hbuff is NULL\\n\",__FUNCTION__);\n\t\treturn;\n\t}\n\n\tswitch (pC2hEvent->CmdID)\n\t{\n\t\tcase C2H_AP_RPT_RSP:\n\t\t\t#if 0\n\t\t\t{\n\t\t\t\n\t\t\t\tu4Byte c2h_ap_keeplink = _TRUE;\n\t\t\t\tif (c2hBuf[2] == 0 && c2hBuf[3] == 0)\n\t\t\t\t\tc2h_ap_keeplink = _FALSE;\n\t\t\t\telse\n\t\t\t\t\tc2h_ap_keeplink = _TRUE;\n\n\t\t\t\tif (_TRUE == pmlmeext->try_ap_c2h_wait) {\n\t\t\t\t\tif (_FALSE == c2h_ap_keeplink) {\n\t\t\t\t\t\tpmlmeext->try_ap_c2h_wait = _FALSE;\n\t\t\t\t\t\tRT_TRACE(_module_hal_init_c_, _drv_err_,(\"fw tell us link is off\\n\"));\n\t\t\t\t\t\treceive_disconnect(padapter, pmlmeinfo->network.MacAddress , 65535);\n\t\t\t\t\t} else\t{\n\t\t\t\t\t\tRT_TRACE(_module_hal_init_c_, _drv_err_,(\"fw tell us link is on\\n\"));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tRT_TRACE(_module_hal_init_c_, _drv_err_,(\"we don't need this C2H\\n\"));\n\t\t\t\t}\n\t\t\t\tpmlmeext->check_ap_processing = _FALSE;\n\t\t\t}\n\t\t\t#endif\n\t\t\tbreak;\n\t\tcase C2H_DBG:\n\t\t\t{\n\t\t\t\tRT_TRACE(_module_hal_init_c_, _drv_info_, (\"C2HCommandHandler: %s\\n\", c2hBuf));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase C2H_CCX_TX_RPT:\n\t\t\tCCX_FwC2HTxRpt_8723b(padapter, c2hBuf, pC2hEvent->CmdLen);\n\t\t\tbreak;\n\n#ifdef CONFIG_BT_COEXIST\n#ifdef CONFIG_PCI_HCI\n\t\tcase C2H_BT_RSSI:\n//\t\t\tfwc2h_ODM(padapter, tmpBuf, &C2hEvent);\n\t\t\t//BT_FwC2hBtRssi(padapter, c2hBuf);\n\t\t\tbreak;\n#endif\n#endif\n\n\t\tcase C2H_EXT_RA_RPT:\n//\t\t\tC2HExtRaRptHandler(padapter, tmpBuf, C2hEvent.CmdLen);\n\t\t\tbreak;\n\n\t\tcase C2H_HW_INFO_EXCH:\n\t\t\tRT_TRACE(_module_hal_init_c_, _drv_info_, (\"[BT], C2H_HW_INFO_EXCH\\n\"));\n\t\t\tfor (index = 0; index < pC2hEvent->CmdLen; index++)\n\t\t\t{\n\t\t\t\tRT_TRACE(_module_hal_init_c_, _drv_info_, (\"[BT], tmpBuf[%d]=0x%x\\n\", index, c2hBuf[index]));\n\t\t\t}\n\t\t\tbreak;\n\n#ifdef CONFIG_BT_COEXIST\n\t\tcase C2H_8723B_BT_INFO:\n\t\t\trtw_btcoex_BtInfoNotify(padapter, pC2hEvent->CmdLen, c2hBuf);\n\t\t\tbreak;\n#endif\n\n#ifdef CONFIG_MP_INCLUDED\n\t\tcase C2H_8723B_BT_MP_INFO:\n\t\t\tMPTBT_FwC2hBtMpCtrl(padapter, c2hBuf, pC2hEvent->CmdLen);\n\t\t\tbreak;\n#endif\n\n#ifdef CONFIG_FW_C2H_DEBUG\n\t\tcase C2H_8723B_FW_DEBUG:\n\t\t\tDebug_FwC2H(padapter, c2hBuf, pC2hEvent->CmdLen);\n\t\t\tbreak;\n#endif // CONFIG_FW_C2H_DEBUG\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n#ifndef CONFIG_C2H_PACKET_EN\n\t// Clear event to notify FW we have read the command.\n\t// Note:\n\t//\tIf this field isn't clear, the FW won't update the next command message.\n\trtw_write8(padapter, REG_C2HEVT_CLEAR, C2H_EVT_HOST_CLOSE);\n#endif\n}\n\n#ifdef CONFIG_C2H_PACKET_EN\n\nstatic void C2HPacketHandler_8723B(PADAPTER padapter, u8 *pbuffer, u16 length)\n{\n\tC2H_EVT_HDR \tC2hEvent;\n\tu8 *tmpBuf=NULL;\n#ifdef CONFIG_WOWLAN\n\tstruct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(padapter);\n\t\n\tif(pwrpriv->wowlan_mode == _TRUE)\n\t{\n\t\tDBG_871X(\"%s(): return because wowolan_mode==TRUE! CMDID=%d\\n\", __func__, pbuffer[0]);\n\t\treturn;\n\t}\n#endif\n\tC2hEvent.CmdID = pbuffer[0];\n\tC2hEvent.CmdSeq = pbuffer[1];\n\tC2hEvent.CmdLen = length - 2;\n\ttmpBuf = pbuffer + 2;\n\n\t//DBG_871X(\"%s C2hEvent.CmdID:%x C2hEvent.CmdLen:%x C2hEvent.CmdSeq:%x\\n\",\n\t//\t\t__func__, C2hEvent.CmdID, C2hEvent.CmdLen, C2hEvent.CmdSeq);\n\tRT_PRINT_DATA(_module_hal_init_c_, _drv_notice_, \"C2HPacketHandler_8723B(): Command Content:\\n\", tmpBuf, C2hEvent.CmdLen);\n\t\n\tprocess_c2h_event(padapter, &C2hEvent, tmpBuf);\n\t//c2h_handler_8723b(padapter,&C2hEvent);\n\treturn;\n}\n\nvoid rtl8723b_c2h_packet_handler(PADAPTER padapter, u8 *pbuf, u16 length)\n{\n\tC2H_EVT_HDR C2hEvent;\n\tu8 *pdata;\n\n\n\tif (length == 0)\n\t\treturn;\n\n\tC2hEvent.CmdID = pbuf[0];\n\tC2hEvent.CmdSeq = pbuf[1];\n\tC2hEvent.CmdLen = length - 2;\n\tpdata = pbuf + 2;\n\n\tDBG_8192C(\"%s: C2H, ID=%d seq=%d len=%d\\n\",\n\t\t__FUNCTION__, C2hEvent.CmdID, C2hEvent.CmdSeq, C2hEvent.CmdLen);\n\n\tswitch (C2hEvent.CmdID) {\n\tcase C2H_CCX_TX_RPT:\n#ifdef CONFIG_FW_C2H_DEBUG\n\tcase C2H_8723B_FW_DEBUG:\n#endif // CONFIG_FW_C2H_DEBUG\n\t\tprocess_c2h_event(padapter, &C2hEvent, pdata);\n\t\tbreak;\n\n\tdefault:\n\t\tpdata = rtw_zmalloc(length);\n\t\tif (pdata == NULL)\n\t\t\tbreak;\n\t\t_rtw_memcpy(pdata, pbuf, length);\n\t\tif (rtw_c2h_packet_wk_cmd(padapter, pdata, length) == _FAIL)\n\t\t\trtw_mfree(pdata, length);\n\t\tbreak;\n\t}\n}\n\n#else // !CONFIG_C2H_PACKET_EN\n//\n//C2H event format:\n// Field\t TRIGGER\t\tCONTENT    CMD_SEQ\tCMD_LEN \t CMD_ID\n// BITS  [127:120]\t[119:16]\t  [15:8]\t\t  [7:4] \t   [3:0]\n//2009.10.08. by tynli.\nstatic void C2HCommandHandler(PADAPTER padapter)\n{\n\tC2H_EVT_HDR \tC2hEvent;\n#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)\n\n\tu8\t\t\t\t*tmpBuf = NULL;\n\tu8\t\t\t\tindex = 0;\n\tu8\t\t\t\tbCmdMsgReady = _FALSE;\n\tu8\t\t\t\tU1bTmp = 0;\n//\tu8\t\t\t\tQueueID = 0;\n\n\t_rtw_memset(&C2hEvent, 0, sizeof(C2H_EVT_HDR));\n\n\tC2hEvent.CmdID = rtw_read8(padapter, REG_C2HEVT_CMD_ID_8723B);\n\tC2hEvent.CmdLen = rtw_read8(padapter, REG_C2HEVT_CMD_LEN_8723B);\n\tC2hEvent.CmdSeq = rtw_read8(padapter, REG_C2HEVT_CMD_ID_8723B + 1);\n\n\tRT_PRINT_DATA(_module_hal_init_c_, _drv_info_, \"C2HCommandHandler(): \",\n\t\t&C2hEvent , sizeof(C2hEvent));\n\n\tU1bTmp = rtw_read8(padapter, REG_C2HEVT_CLEAR);\n\tDBG_871X(\"%s C2hEvent.CmdID:%x C2hEvent.CmdLen:%x C2hEvent.CmdSeq:%x\\n\",\n\t\t\t__func__, C2hEvent.CmdID, C2hEvent.CmdLen, C2hEvent.CmdSeq);\n\n\tif (U1bTmp == C2H_EVT_HOST_CLOSE)\n\t{\n\t\t// Not ready.\n\t\treturn;\n\t}\n\telse if (U1bTmp == C2H_EVT_FW_CLOSE)\n\t{\n\t\tbCmdMsgReady = _TRUE;\n\t}\n\telse\n\t{\n\t\t// Not a valid value, reset the clear event.\n\t\tgoto exit;\n\t}\n\n\tif(C2hEvent.CmdLen == 0)\n\t\tgoto exit;\n\ttmpBuf = rtw_zmalloc(C2hEvent.CmdLen);\n\tif (tmpBuf == NULL)\n\t\tgoto exit;\n\n\t// Read the content\n\tfor (index = 0; index < C2hEvent.CmdLen; index++)\n\t{\n\t\ttmpBuf[index] = rtw_read8(padapter, REG_C2HEVT_CMD_ID_8723B + 2 + index);\n\t}\n\n\tRT_PRINT_DATA(_module_hal_init_c_, _drv_notice_, \"C2HCommandHandler(): Command Content:\\n\", tmpBuf, C2hEvent.CmdLen);\n\n\t//process_c2h_event(padapter,&C2hEvent, tmpBuf);\n\tc2h_handler_8723b(padapter,&C2hEvent);\n\tif (tmpBuf)\n\t\trtw_mfree(tmpBuf, C2hEvent.CmdLen);\n#endif // CONFIG_SDIO_HCI || CONFIG_GSPI_HCI\n\n#ifdef CONFIG_USB_HCI\n\tHAL_DATA_TYPE\t*pHalData=GET_HAL_DATA(padapter);\n\n\t_rtw_memset(&C2hEvent, 0, sizeof(C2H_EVT_HDR));\n\tC2hEvent.CmdID = pHalData->C2hArray[USB_C2H_CMDID_OFFSET] & 0xF;\n\tC2hEvent.CmdLen = (pHalData->C2hArray[USB_C2H_CMDID_OFFSET] & 0xF0) >> 4;\n\tC2hEvent.CmdSeq =pHalData->C2hArray[USB_C2H_SEQ_OFFSET];\n\tc2h_handler_8723b(padapter,(u8 *)&C2hEvent);\n\t//process_c2h_event(padapter,&C2hEvent,&pHalData->C2hArray[USB_C2H_EVENT_OFFSET]);\n#endif // CONFIG_USB_HCI\n\n\t//REG_C2HEVT_CLEAR have done in process_c2h_event\n\treturn;\nexit:\n\trtw_write8(padapter, REG_C2HEVT_CLEAR, C2H_EVT_HOST_CLOSE);\n\treturn;\n}\n\n#endif // !CONFIG_C2H_PACKET_EN\n\nvoid SetHwReg8723B(PADAPTER padapter, u8 variable, u8 *val)\n{\n\tPHAL_DATA_TYPE\tpHalData = GET_HAL_DATA(padapter);\n\tu8 val8;\n\tu16 val16;\n\tu32 val32;\n\n_func_enter_;\n\n\tswitch (variable)\n\t{\n\t\tcase HW_VAR_MEDIA_STATUS:\n\t\t\tval8 = rtw_read8(padapter, MSR) & 0x0c;\n\t\t\tval8 |= *val;\n\t\t\trtw_write8(padapter, MSR, val8);\n\t\t\tbreak;\n\n\t\tcase HW_VAR_MEDIA_STATUS1:\n\t\t\tval8 = rtw_read8(padapter, MSR) & 0x03;\n\t\t\tval8 |= *val << 2;\n\t\t\trtw_write8(padapter, MSR, val8);\n\t\t\tbreak;\n\n\t\tcase HW_VAR_SET_OPMODE:\n\t\t\thw_var_set_opmode(padapter, variable, val);\n\t\t\tbreak;\n\n\t\tcase HW_VAR_MAC_ADDR:\n\t\t\thw_var_set_macaddr(padapter, variable, val);\n\t\t\tbreak;\n\n\t\tcase HW_VAR_BSSID:\n\t\t\thw_var_set_bssid(padapter, variable, val);\n\t\t\tbreak;\n\n\t\tcase HW_VAR_BASIC_RATE:\n\t\t{\n\t\t\tstruct mlme_ext_info *mlmext_info = &padapter->mlmeextpriv.mlmext_info;\n\t\t\tu16 input_b = 0, masked = 0, ioted = 0, BrateCfg = 0;\n\t\t\tu16 rrsr_2g_force_mask = (RRSR_11M|RRSR_5_5M|RRSR_1M);\n\t\t\tu16 rrsr_2g_allow_mask = (RRSR_24M|RRSR_12M|RRSR_6M|RRSR_CCK_RATES);\n\n\t\t\tHalSetBrateCfg(padapter, val, &BrateCfg);\n\t\t\tinput_b = BrateCfg;\n\n\t\t\t/* apply force and allow mask */\n\t\t\tBrateCfg |= rrsr_2g_force_mask;\n\t\t\tBrateCfg &= rrsr_2g_allow_mask;\n\t\t\tmasked = BrateCfg;\n\n\t\t\t#ifdef CONFIG_CMCC_TEST\n\t\t\tBrateCfg |= (RRSR_11M|RRSR_5_5M|RRSR_1M); /* use 11M to send ACK */\n\t\t\tBrateCfg |= (RRSR_24M|RRSR_18M|RRSR_12M); //CMCC_OFDM_ACK 12/18/24M\n\t\t\t#endif\n\n\t\t\t/* IOT consideration */\n\t\t\tif (mlmext_info->assoc_AP_vendor == HT_IOT_PEER_CISCO) {\n\t\t\t\t/* if peer is cisco and didn't use ofdm rate, we enable 6M ack */\n\t\t\t\tif((BrateCfg & (RRSR_24M|RRSR_12M|RRSR_6M)) == 0)\n\t\t\t\t\tBrateCfg |= RRSR_6M;\n\t\t\t}\n\t\t\tioted = BrateCfg;\n\n\t\t\tpHalData->BasicRateSet = BrateCfg;\n\n\t\t\tDBG_8192C(\"HW_VAR_BASIC_RATE: %#x -> %#x -> %#x\\n\", input_b, masked, ioted);\n\n\t\t\t// Set RRSR rate table.\n\t\t\trtw_write16(padapter, REG_RRSR, BrateCfg);\n\t\t\trtw_write8(padapter, REG_RRSR+2, rtw_read8(padapter, REG_RRSR+2)&0xf0);\n\t\t}\n\t\t\tbreak;\n\n\t\tcase HW_VAR_TXPAUSE:\n\t\t\trtw_write8(padapter, REG_TXPAUSE, *val);\n\t\t\tbreak;\n\n\t\tcase HW_VAR_BCN_FUNC:\n\t\t\thw_var_set_bcn_func(padapter, variable, val);\n\t\t\tbreak;\n\n\t\tcase HW_VAR_CORRECT_TSF:\n\t\t\thw_var_set_correct_tsf(padapter, variable, val);\n\t\t\tbreak;\n\n\t\tcase HW_VAR_CHECK_BSSID:\n\t\t\t{\n\t\t\t\tu32 val32;\n\t\t\t\tval32 = rtw_read32(padapter, REG_RCR);\n\t\t\t\tif (*val)\n\t\t\t\t\tval32 |= RCR_CBSSID_DATA|RCR_CBSSID_BCN;\n\t\t\t\telse\n\t\t\t\t\tval32 &= ~(RCR_CBSSID_DATA|RCR_CBSSID_BCN);\n\t\t\t\trtw_write32(padapter, REG_RCR, val32);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase HW_VAR_MLME_DISCONNECT:\n\t\t\thw_var_set_mlme_disconnect(padapter, variable, val);\n\t\t\tbreak;\n\n\t\tcase HW_VAR_MLME_SITESURVEY:\n\t\t\thw_var_set_mlme_sitesurvey(padapter, variable,  val);\n\n#ifdef CONFIG_BT_COEXIST\n\t\t\trtw_btcoex_ScanNotify(padapter, *val?_TRUE:_FALSE);\n#endif // CONFIG_BT_COEXIST\n\t\t\tbreak;\n\n\t\tcase HW_VAR_MLME_JOIN:\n\t\t\thw_var_set_mlme_join(padapter, variable, val);\n\n#ifdef CONFIG_BT_COEXIST\n\t\t\tswitch (*val)\n\t\t\t{\n\t\t\t\tcase 0:\n\t\t\t\t\t// prepare to join\n\t\t\t\t\trtw_btcoex_ConnectNotify(padapter, _TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\t// joinbss_event callback when join res < 0\n\t\t\t\t\trtw_btcoex_ConnectNotify(padapter, _FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\t// sta add event callback\n//\t\t\t\t\trtw_btcoex_MediaStatusNotify(padapter, RT_MEDIA_CONNECT);\n\t\t\t\t\tbreak;\n\t\t\t}\n#endif // CONFIG_BT_COEXIST\n\t\t\tbreak;\n\n\t\tcase HW_VAR_ON_RCR_AM:\n\t\t\tval32 = rtw_read32(padapter, REG_RCR);\n\t\t\tval32 |= RCR_AM;\n\t\t\trtw_write32(padapter, REG_RCR, val32);\n\t\t\tDBG_8192C(\"%s, %d, RCR= %x\\n\", __FUNCTION__, __LINE__, rtw_read32(padapter, REG_RCR));\n\t\t\tbreak;\n\n\t\tcase HW_VAR_OFF_RCR_AM:\n\t\t\tval32 = rtw_read32(padapter, REG_RCR);\n\t\t\tval32 &= ~RCR_AM;\n\t\t\trtw_write32(padapter, REG_RCR, val32);\n\t\t\tDBG_8192C(\"%s, %d, RCR= %x\\n\", __FUNCTION__, __LINE__, rtw_read32(padapter, REG_RCR));\n\t\t\tbreak;\n\n\t\tcase HW_VAR_BEACON_INTERVAL:\n\t\t\trtw_write16(padapter, REG_BCN_INTERVAL, *((u16*)val));\n\t\t\tbreak;\n\n\t\tcase HW_VAR_SLOT_TIME:\n\t\t\trtw_write8(padapter, REG_SLOT, *val);\n\t\t\tbreak;\n\n\t\tcase HW_VAR_RESP_SIFS:\n#if 0\n\t\t\t// SIFS for OFDM Data ACK\n\t\t\trtw_write8(padapter, REG_SIFS_CTX+1, val[0]);\n\t\t\t// SIFS for OFDM consecutive tx like CTS data!\n\t\t\trtw_write8(padapter, REG_SIFS_TRX+1, val[1]);\n\n\t\t\trtw_write8(padapter, REG_SPEC_SIFS+1, val[0]);\n\t\t\trtw_write8(padapter, REG_MAC_SPEC_SIFS+1, val[0]);\n\n\t\t\t// 20100719 Joseph: Revise SIFS setting due to Hardware register definition change.\n\t\t\trtw_write8(padapter, REG_R2T_SIFS+1, val[0]);\n\t\t\trtw_write8(padapter, REG_T2T_SIFS+1, val[0]);\n\n#else\n\t\t\t//SIFS_Timer = 0x0a0a0808;\n\t\t\t//RESP_SIFS for CCK\n\t\t\trtw_write8(padapter, REG_RESP_SIFS_CCK, val[0]); // SIFS_T2T_CCK (0x08)\n\t\t\trtw_write8(padapter, REG_RESP_SIFS_CCK+1, val[1]); //SIFS_R2T_CCK(0x08)\n\t\t\t//RESP_SIFS for OFDM\n\t\t\trtw_write8(padapter, REG_RESP_SIFS_OFDM, val[2]); //SIFS_T2T_OFDM (0x0a)\n\t\t\trtw_write8(padapter, REG_RESP_SIFS_OFDM+1, val[3]); //SIFS_R2T_OFDM(0x0a)\n#endif\n\t\t\tbreak;\n\n\t\tcase HW_VAR_ACK_PREAMBLE:\n\t\t\t{\n\t\t\t\tu8 regTmp;\n\t\t\t\tu8 bShortPreamble = *val;\n\n\t\t\t\t// Joseph marked out for Netgear 3500 TKIP channel 7 issue.(Temporarily)\n\t\t\t\t//regTmp = (pHalData->nCur40MhzPrimeSC)<<5;\n\t\t\t\tregTmp = 0;\n\t\t\t\tif (bShortPreamble) regTmp |= 0x80;\n\t\t\t\trtw_write8(padapter, REG_RRSR+2, regTmp);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase HW_VAR_CAM_EMPTY_ENTRY:\n\t\t\t{\n\t\t\t\tu8\tucIndex = *val;\n\t\t\t\tu8\ti;\n\t\t\t\tu32\tulCommand = 0;\n\t\t\t\tu32\tulContent = 0;\n\t\t\t\tu32\tulEncAlgo = CAM_AES;\n\n\t\t\t\tfor (i=0; i<CAM_CONTENT_COUNT; i++)\n\t\t\t\t{\n\t\t\t\t\t// filled id in CAM config 2 byte\n\t\t\t\t\tif (i == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tulContent |= (ucIndex & 0x03) | ((u16)(ulEncAlgo)<<2);\n\t\t\t\t\t\t//ulContent |= CAM_VALID;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tulContent = 0;\n\t\t\t\t\t}\n\t\t\t\t\t// polling bit, and No Write enable, and address\n\t\t\t\t\tulCommand = CAM_CONTENT_COUNT*ucIndex+i;\n\t\t\t\t\tulCommand = ulCommand | CAM_POLLINIG | CAM_WRITE;\n\t\t\t\t\t// write content 0 is equall to mark invalid\n\t\t\t\t\trtw_write32(padapter, WCAMI, ulContent);  //delay_ms(40);\n\t\t\t\t\t//RT_TRACE(COMP_SEC, DBG_LOUD, (\"CAM_empty_entry(): WRITE A4: %lx \\n\",ulContent));\n\t\t\t\t\trtw_write32(padapter, RWCAM, ulCommand);  //delay_ms(40);\n\t\t\t\t\t//RT_TRACE(COMP_SEC, DBG_LOUD, (\"CAM_empty_entry(): WRITE A0: %lx \\n\",ulCommand));\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase HW_VAR_CAM_INVALID_ALL:\n\t\t\trtw_write32(padapter, RWCAM, BIT(31)|BIT(30));\n\t\t\tbreak;\n\n\t\tcase HW_VAR_CAM_WRITE:\n\t\t\t{\n\t\t\t\tu32 cmd;\n\t\t\t\tu32 *cam_val = (u32*)val;\n\n\t\t\t\trtw_write32(padapter, WCAMI, cam_val[0]);\n\n\t\t\t\tcmd = CAM_POLLINIG | CAM_WRITE | cam_val[1];\n\t\t\t\trtw_write32(padapter, RWCAM, cmd);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase HW_VAR_AC_PARAM_VO:\n\t\t\trtw_write32(padapter, REG_EDCA_VO_PARAM, *((u32*)val));\n\t\t\tbreak;\n\n\t\tcase HW_VAR_AC_PARAM_VI:\n\t\t\trtw_write32(padapter, REG_EDCA_VI_PARAM, *((u32*)val));\n\t\t\tbreak;\n\n\t\tcase HW_VAR_AC_PARAM_BE:\n\t\t\tpHalData->AcParam_BE = ((u32*)(val))[0];\n\t\t\trtw_write32(padapter, REG_EDCA_BE_PARAM, *((u32*)val));\n\t\t\tbreak;\n\n\t\tcase HW_VAR_AC_PARAM_BK:\n\t\t\trtw_write32(padapter, REG_EDCA_BK_PARAM, *((u32*)val));\n\t\t\tbreak;\n\n\t\tcase HW_VAR_ACM_CTRL:\n\t\t\t{\n\t\t\t\tu8 ctrl = *((u8*)val);\n\t\t\t\tu8 hwctrl = 0;\n\n\t\t\t\tif (ctrl != 0)\n\t\t\t\t{\n\t\t\t\t\thwctrl |= AcmHw_HwEn;\n\n\t\t\t\t\tif (ctrl & BIT(1)) // BE\n\t\t\t\t\t\thwctrl |= AcmHw_BeqEn;\n\n\t\t\t\t\tif (ctrl & BIT(2)) // VI\n\t\t\t\t\t\thwctrl |= AcmHw_ViqEn;\n\n\t\t\t\t\tif (ctrl & BIT(3)) // VO\n\t\t\t\t\t\thwctrl |= AcmHw_VoqEn;\n\t\t\t\t}\n\n\t\t\t\tDBG_8192C(\"[HW_VAR_ACM_CTRL] Write 0x%02X\\n\", hwctrl);\n\t\t\t\trtw_write8(padapter, REG_ACMHWCTRL, hwctrl);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase HW_VAR_AMPDU_FACTOR:\n\t\t\t{\n\t\t\t\tu32\tAMPDULen =  (*((u8 *)val));\n\n\t\t\t\tif(AMPDULen < HT_AGG_SIZE_32K)\n\t\t\t\t\tAMPDULen = (0x2000 << (*((u8 *)val))) -1;\n\t\t\t\telse\n\t\t\t\t\tAMPDULen = 0x7fff;\n\n\t\t\t\trtw_write32(padapter, REG_AMPDU_MAX_LENGTH_8723B, AMPDULen);\n\t\t\t}\n\t\t\tbreak;\n\n#if 0\n\t\tcase HW_VAR_RXDMA_AGG_PG_TH:\n\t\t\trtw_write8(padapter, REG_RXDMA_AGG_PG_TH, *val);\n\t\t\tbreak;\n#endif\n\n\t\tcase HW_VAR_H2C_FW_PWRMODE:\n\t\t\t{\n\t\t\t\tu8 psmode = *val;\n\n\t\t\t\t// Forece leave RF low power mode for 1T1R to prevent conficting setting in Fw power\n\t\t\t\t// saving sequence. 2010.06.07. Added by tynli. Suggested by SD3 yschang.\n\t\t\t\tif (psmode != PS_MODE_ACTIVE)\n\t\t\t\t{\n\t\t\t\t\tODM_RF_Saving(&pHalData->odmpriv, _TRUE);\n\t\t\t\t}\n\n\t\t\t\t//if (psmode != PS_MODE_ACTIVE)\t{\n\t\t\t\t//\trtl8723b_set_lowpwr_lps_cmd(padapter, _TRUE);\n\t\t\t\t//} else {\n\t\t\t\t//\trtl8723b_set_lowpwr_lps_cmd(padapter, _FALSE);\n\t\t\t\t//}\n\t\t\t\trtl8723b_set_FwPwrMode_cmd(padapter, psmode);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase HW_VAR_H2C_PS_TUNE_PARAM:\n\t\t\trtl8723b_set_FwPsTuneParam_cmd(padapter);\n\t\t\tbreak;\n\t\t\t\n\t\tcase HW_VAR_H2C_FW_JOINBSSRPT:\n\t\t\trtl8723b_set_FwJoinBssRpt_cmd(padapter, *val);\n\t\t\tbreak;\n\n#ifdef CONFIG_P2P\n\t\tcase HW_VAR_H2C_FW_P2P_PS_OFFLOAD:\n\t\t\trtl8723b_set_p2p_ps_offload_cmd(padapter, *val);\n\t\t\tbreak;\n#endif //CONFIG_P2P\n#ifdef CONFIG_TDLS\n\t\tcase HW_VAR_TDLS_WRCR:\n\t\t\trtw_write32(padapter, REG_RCR, rtw_read32(padapter, REG_RCR)&(~RCR_CBSSID_DATA ));\n\t\t\tbreak;\n\t\tcase HW_VAR_TDLS_RS_RCR:\n\t\t\trtw_write32(padapter, REG_RCR, rtw_read32(padapter, REG_RCR)|(RCR_CBSSID_DATA));\n\t\t\tbreak;\n#endif //CONFIG_TDLS\n#ifdef CONFIG_SW_ANTENNA_DIVERSITY\n\t\tcase HW_VAR_ANTENNA_DIVERSITY_LINK:\n\t\t\t//SwAntDivRestAfterLink8192C(padapter);\n\t\t\tODM_SwAntDivRestAfterLink(&pHalData->odmpriv);\n\t\t\tbreak;\n\n\t\tcase HW_VAR_ANTENNA_DIVERSITY_SELECT:\n\t\t\t{\n\t\t\t\tu8 Optimum_antenna = *val;\n\n\t\t\t\t//DBG_8192C(\"==> HW_VAR_ANTENNA_DIVERSITY_SELECT , Ant_(%s)\\n\",(Optimum_antenna==2)?\"A\":\"B\");\n\n\t\t\t\t//PHY_SetBBReg(padapter, rFPGA0_XA_RFInterfaceOE, 0x300, Optimum_antenna);\n\t\t\t\tODM_SetAntenna(&pHalData->odmpriv, Optimum_antenna);\n\t\t\t}\n\t\t\tbreak;\n#endif\n\n\t\tcase HW_VAR_EFUSE_USAGE:\n\t\t\tpHalData->EfuseUsedPercentage = *val;\n\t\t\tbreak;\n\n\t\tcase HW_VAR_EFUSE_BYTES:\n\t\t\tpHalData->EfuseUsedBytes = *((u16*)val);\n\t\t\tbreak;\n\n\t\tcase HW_VAR_EFUSE_BT_USAGE:\n#ifdef HAL_EFUSE_MEMORY\n\t\t\tpHalData->EfuseHal.BTEfuseUsedPercentage = *val;\n#endif\n\t\t\tbreak;\n\n\t\tcase HW_VAR_EFUSE_BT_BYTES:\n#ifdef HAL_EFUSE_MEMORY\n\t\t\tpHalData->EfuseHal.BTEfuseUsedBytes = *((u16*)val);\n#else\n\t\t\tBTEfuseUsedBytes = *((u16*)val);\n#endif\n\t\t\tbreak;\n\n\t\tcase HW_VAR_FIFO_CLEARN_UP:\n\t\t\t{\n\t\t\t\t#define RW_RELEASE_EN\t\tBIT(18)\n\t\t\t\t#define RXDMA_IDLE\t\t\tBIT(17)\n\n\t\t\t\tstruct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(padapter);\n\t\t\t\tu8 trycnt = 100;\n\n\t\t\t\t// pause tx\n\t\t\t\trtw_write8(padapter, REG_TXPAUSE, 0xff);\n\n\t\t\t\t// keep sn\n\t\t\t\tpadapter->xmitpriv.nqos_ssn = rtw_read16(padapter, REG_NQOS_SEQ);\n\n\t\t\t\tif (pwrpriv->bkeepfwalive != _TRUE)\n\t\t\t\t{\n\t\t\t\t\t/* RX DMA stop */\n\t\t\t\t\tval32 = rtw_read32(padapter, REG_RXPKT_NUM);\n\t\t\t\t\tval32 |= RW_RELEASE_EN;\n\t\t\t\t\trtw_write32(padapter, REG_RXPKT_NUM, val32);\n\t\t\t\t\tdo {\n\t\t\t\t\t\tval32 = rtw_read32(padapter, REG_RXPKT_NUM);\n\t\t\t\t\t\tval32 &= RXDMA_IDLE;\n\t\t\t\t\t\tif (val32)\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tDBG_871X(\"%s: [HW_VAR_FIFO_CLEARN_UP] val=%x times:%d\\n\", __FUNCTION__, val32, trycnt);\n\t\t\t\t\t} while (--trycnt);\n\t\t\t\t\tif (trycnt == 0) {\n\t\t\t\t\t\tDBG_8192C(\"[HW_VAR_FIFO_CLEARN_UP] Stop RX DMA failed......\\n\");\n\t\t\t\t\t}\n\n\t\t\t\t\t// RQPN Load 0\n\t\t\t\t\trtw_write16(padapter, REG_RQPN_NPQ, 0);\n\t\t\t\t\trtw_write32(padapter, REG_RQPN, 0x80000000);\n\t\t\t\t\trtw_mdelay_os(2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n#ifdef CONFIG_CONCURRENT_MODE\n\t\tcase HW_VAR_CHECK_TXBUF:\n\t\t\t{\n\t\t\t\tu32 i;\n\t\t\t\tu8 RetryLimit = 0x01;\n\t\t\t\tu32 reg_200, reg_204;\n\n\t\t\t\tval16 = RetryLimit << RETRY_LIMIT_SHORT_SHIFT | RetryLimit << RETRY_LIMIT_LONG_SHIFT;\n\t\t\t\trtw_write16(padapter, REG_RL, val16);\n\n\t\t\t\tfor (i=0; i<200; i++) // polling 200x10=2000 msec  \n\t\t\t\t{\n\t\t\t\t\treg_200 = rtw_read32(padapter, 0x200);\n\t\t\t\t\treg_204 = rtw_read32(padapter, 0x204);\n\t\t\t\t\tif (reg_200 != reg_204)\n\t\t\t\t\t{\n\t\t\t\t\t\t//DBG_871X(\"packet in tx packet buffer - 0x204=%x, 0x200=%x (%d)\\n\", rtw_read32(padapter, 0x204), rtw_read32(padapter, 0x200), i);\n\t\t\t\t\t\trtw_msleep_os(10);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tDBG_871X(\"[HW_VAR_CHECK_TXBUF] no packet in tx packet buffer (%d)\\n\", i);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (reg_200 != reg_204)\n\t\t\t\t\tDBG_871X(\"packets in tx buffer - 0x204=%x, 0x200=%x\\n\", reg_204, reg_200);\n\t\t\t\t\n\t\t\t\tRetryLimit = 0x30;\n\t\t\t\tval16 = RetryLimit << RETRY_LIMIT_SHORT_SHIFT | RetryLimit << RETRY_LIMIT_LONG_SHIFT;\n\t\t\t\trtw_write16(padapter, REG_RL, val16);\n\t\t\t}\n\t\t\tbreak;\n#endif // CONFIG_CONCURRENT_MODE\n\n\t\tcase HW_VAR_APFM_ON_MAC:\n\t\t\tpHalData->bMacPwrCtrlOn = *val;\n#ifdef PLATFORM_LINUX\n\t\t\tDBG_8192C(\"%s: bMacPwrCtrlOn=%d\\n\", __func__, pHalData->bMacPwrCtrlOn);\n#endif\n\t\t\tbreak;\n\n\t\tcase HW_VAR_NAV_UPPER:\n\t\t\t{\n\t\t\t\tu32 usNavUpper = *((u32*)val);\n\n\t\t\t\tif (usNavUpper > HAL_NAV_UPPER_UNIT_8723B * 0xFF)\n\t\t\t\t{\n\t\t\t\t\tRT_TRACE(_module_hal_init_c_, _drv_notice_, (\"The setting value (0x%08X us) of NAV_UPPER is larger than (%d * 0xFF)!!!\\n\", usNavUpper, HAL_NAV_UPPER_UNIT_8723B));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// The value of ((usNavUpper + HAL_NAV_UPPER_UNIT_8723B - 1) / HAL_NAV_UPPER_UNIT_8723B)\n\t\t\t\t// is getting the upper integer.\n\t\t\t\tusNavUpper = (usNavUpper + HAL_NAV_UPPER_UNIT_8723B - 1) / HAL_NAV_UPPER_UNIT_8723B;\n\t\t\t\trtw_write8(padapter, REG_NAV_UPPER, (u8)usNavUpper);\n\t\t\t}\n\t\t\tbreak;\n\n#ifndef CONFIG_C2H_PACKET_EN\n\t\tcase HW_VAR_C2H_HANDLE:\n\t\t\tC2HCommandHandler(padapter);\n\t\t\tbreak;\n#endif\n\n\t\tcase HW_VAR_H2C_MEDIA_STATUS_RPT:\n\t\t\t{\n\t\t\t\tu16\tmstatus_rpt = (*(u16 *)val);\n\t\t\t\tu8\tmstatus, macId;\n\n\t\t\t\tmstatus = (u8) (mstatus_rpt & 0xFF);\n\t\t\t\tmacId = (u8)(mstatus_rpt >> 8)  ;\n\t\t\t\trtl8723b_set_FwMediaStatusRpt_cmd(padapter , mstatus, macId);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase HW_VAR_BCN_VALID:\n#ifdef CONFIG_CONCURRENT_MODE\n\t\t\tif (padapter->iface_type == IFACE_PORT1)\n\t\t\t{\n\t\t\t\tval8 = rtw_read8(padapter,  REG_DWBCN1_CTRL_8723B+2);\n\t\t\t\tval8 |= BIT(0);\n\t\t\t\trtw_write8(padapter, REG_DWBCN1_CTRL_8723B+2, val8); \n\t\t\t}\n\t\t\telse\n#endif // CONFIG_CONCURRENT_MODE\n\t\t\t{\n\t\t\t\t// BCN_VALID, BIT16 of REG_TDECTRL = BIT0 of REG_TDECTRL+2, write 1 to clear, Clear by sw\n\t\t\t\tval8 = rtw_read8(padapter, REG_TDECTRL+2);\n\t\t\t\tval8 |= BIT(0);\n\t\t\t\trtw_write8(padapter, REG_TDECTRL+2, val8);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase HW_VAR_DL_BCN_SEL:\n#ifdef CONFIG_CONCURRENT_MODE\n\t\t\tif (padapter->iface_type == IFACE_PORT1)\n\t\t\t{\n\t\t\t\t// SW_BCN_SEL - Port1\n\t\t\t\tval8 = rtw_read8(padapter, REG_DWBCN1_CTRL_8723B+2);\n\t\t\t\tval8 |= BIT(4);\n\t\t\t\trtw_write8(padapter, REG_DWBCN1_CTRL_8723B+2, val8);\n\t\t\t}\n\t\t\telse\n#endif // CONFIG_CONCURRENT_MODE\n\t\t\t{\n\t\t\t\t// SW_BCN_SEL - Port0\n\t\t\t\tval8 = rtw_read8(padapter, REG_DWBCN1_CTRL_8723B+2);\n\t\t\t\tval8 &= ~BIT(4);\n\t\t\t\trtw_write8(padapter, REG_DWBCN1_CTRL_8723B+2, val8);\t\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase HW_VAR_DO_IQK:\n\t\t\tpHalData->bNeedIQK = _TRUE;\n\t\t\tbreak;\n\n\t\tcase HW_VAR_DL_RSVD_PAGE:\n#ifdef CONFIG_BT_COEXIST\n\t\t\tif (check_fwstate(&padapter->mlmepriv, WIFI_AP_STATE) == _TRUE)\n\t\t\t{\n\t\t\t\trtl8723b_download_BTCoex_AP_mode_rsvd_page(padapter);\n\t\t\t}\n\t\t\telse\n#endif // CONFIG_BT_COEXIST\n\t\t\t{\n\t\t\t\trtl8723b_download_rsvd_page(padapter, RT_MEDIA_CONNECT);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase HW_VAR_MACID_SLEEP:\n\t\t{\n\t\t\tu32 reg_macid_sleep;\n\t\t\tu8 bit_shift;\n\t\t\tu8 id = *(u8*)val;\n\n\t\t\tif (id < 32) {\n\t\t\t\treg_macid_sleep = REG_MACID_SLEEP;\n\t\t\t\tbit_shift = id;\n\t\t\t} else if (id < 64) {\n\t\t\t\treg_macid_sleep = REG_MACID_SLEEP_1;\n\t\t\t\tbit_shift = id-32;\n\t\t\t} else if (id < 96) {\n\t\t\t\treg_macid_sleep = REG_MACID_SLEEP_2;\n\t\t\t\tbit_shift = id-64;\n\t\t\t} else if (id < 128) {\n\t\t\t\treg_macid_sleep = REG_MACID_SLEEP_3;\n\t\t\t\tbit_shift = id-96;\n\t\t\t} else {\n\t\t\t\trtw_warn_on(1);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tval32 = rtw_read32(padapter, reg_macid_sleep);\n\t\t\tDBG_8192C(FUNC_ADPT_FMT \": [HW_VAR_MACID_SLEEP] macid=%d, org reg_0x%03x=0x%08X\\n\",\n\t\t\t\tFUNC_ADPT_ARG(padapter), id, reg_macid_sleep, val32);\n\n\t\t\tif (val32 & BIT(bit_shift))\n\t\t\t\tbreak;\n\n\t\t\tval32 |= BIT(bit_shift);\n\t\t\trtw_write32(padapter, reg_macid_sleep, val32);\n\t\t}\n\t\t\tbreak;\n\n\t\tcase HW_VAR_MACID_WAKEUP:\n\t\t{\n\t\t\tu32 reg_macid_sleep;\n\t\t\tu8 bit_shift;\n\t\t\tu8 id = *(u8*)val;\n\n\t\t\tif (id < 32) {\n\t\t\t\treg_macid_sleep = REG_MACID_SLEEP;\n\t\t\t\tbit_shift = id;\n\t\t\t} else if (id < 64) {\n\t\t\t\treg_macid_sleep = REG_MACID_SLEEP_1;\n\t\t\t\tbit_shift = id-32;\n\t\t\t} else if (id < 96) {\n\t\t\t\treg_macid_sleep = REG_MACID_SLEEP_2;\n\t\t\t\tbit_shift = id-64;\n\t\t\t} else if (id < 128) {\n\t\t\t\treg_macid_sleep = REG_MACID_SLEEP_3;\n\t\t\t\tbit_shift = id-96;\n\t\t\t} else {\n\t\t\t\trtw_warn_on(1);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tval32 = rtw_read32(padapter, reg_macid_sleep);\n\t\t\tDBG_8192C(FUNC_ADPT_FMT \": [HW_VAR_MACID_WAKEUP] macid=%d, org reg_0x%03x=0x%08X\\n\",\n\t\t\t\tFUNC_ADPT_ARG(padapter), id, reg_macid_sleep, val32);\n\n\t\t\tif (!(val32 & BIT(bit_shift)))\n\t\t\t\tbreak;\n\n\t\t\tval32 &= ~BIT(bit_shift);\n\t\t\trtw_write32(padapter, reg_macid_sleep, val32);\n\t\t}\n\t\t\tbreak;\n#ifdef CONFIG_GPIO_WAKEUP\n\t\tcase HW_SET_GPIO_WL_CTRL:\n\t\t{\n\t\t\tu8 enable = *val;\n\t\t\tu8 value = rtw_read8(padapter, 0x4e);\n\t\t\tif (enable && (value & BIT(6))) {\n\t\t\t\tvalue &= ~BIT(6);\n\t\t\t\trtw_write8(padapter, 0x4e, value);\n\t\t\t} else if (enable == _FALSE){\n\t\t\t\tvalue |= BIT(6);\n\t\t\t\trtw_write8(padapter, 0x4e, value);\n\t\t\t}\n\t\t\tDBG_871X(\"%s: set WL control, 0x4E=0x%02X\\n\",\n\t\t\t\t\t__func__, rtw_read8(padapter, 0x4e));\n\t\t}\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tSetHwReg(padapter, variable, val);\n\t\t\tbreak;\n\t}\n\n_func_exit_;\n}\n\nstruct qinfo_8723b {\n\tu32 head:8;\n\tu32 pkt_num:7;\n\tu32 tail:8;\n\tu32 ac:2;\n\tu32 macid:7;\n};\n\nstruct bcn_qinfo_8723b {\n\tu16 head:8;\n\tu16 pkt_num:8;\n};\n\nvoid dump_qinfo_8723b(void *sel, struct qinfo_8723b *info, const char *tag)\n{\n\t//if (info->pkt_num)\n\tDBG_871X_SEL_NL(sel, \"%shead:0x%02x, tail:0x%02x, pkt_num:%u, macid:%u, ac:%u\\n\"\n\t\t, tag ? tag : \"\", info->head, info->tail, info->pkt_num, info->macid, info->ac\n\t);\n}\n\nvoid dump_bcn_qinfo_8723b(void *sel, struct bcn_qinfo_8723b *info, const char *tag)\n{\n\t//if (info->pkt_num)\n\tDBG_871X_SEL_NL(sel, \"%shead:0x%02x, pkt_num:%u\\n\"\n\t\t, tag ? tag : \"\", info->head, info->pkt_num\n\t);\n}\n\nvoid dump_mac_qinfo_8723b(void *sel, _adapter *adapter)\n{\n\tu32 q0_info;\n\tu32 q1_info;\n\tu32 q2_info;\n\tu32 q3_info;\n\tu32 q4_info;\n\tu32 q5_info;\n\tu32 q6_info;\n\tu32 q7_info;\n\tu32 mg_q_info;\n\tu32 hi_q_info;\n\tu16 bcn_q_info;\n\n\tq0_info = rtw_read32(adapter, REG_Q0_INFO);\n\tq1_info = rtw_read32(adapter, REG_Q1_INFO);\n\tq2_info = rtw_read32(adapter, REG_Q2_INFO);\n\tq3_info = rtw_read32(adapter, REG_Q3_INFO);\n\tq4_info = rtw_read32(adapter, REG_Q4_INFO);\n\tq5_info = rtw_read32(adapter, REG_Q5_INFO);\n\tq6_info = rtw_read32(adapter, REG_Q6_INFO);\n\tq7_info = rtw_read32(adapter, REG_Q7_INFO);\n\tmg_q_info = rtw_read32(adapter, REG_MGQ_INFO);\n\thi_q_info = rtw_read32(adapter, REG_HGQ_INFO);\n\tbcn_q_info = rtw_read16(adapter, REG_BCNQ_INFO);\n\n\tdump_qinfo_8723b(sel, (struct qinfo_8723b *)&q0_info, \"Q0 \");\n\tdump_qinfo_8723b(sel, (struct qinfo_8723b *)&q1_info, \"Q1 \");\n\tdump_qinfo_8723b(sel, (struct qinfo_8723b *)&q2_info, \"Q2 \");\n\tdump_qinfo_8723b(sel, (struct qinfo_8723b *)&q3_info, \"Q3 \");\n\tdump_qinfo_8723b(sel, (struct qinfo_8723b *)&q4_info, \"Q4 \");\n\tdump_qinfo_8723b(sel, (struct qinfo_8723b *)&q5_info, \"Q5 \");\n\tdump_qinfo_8723b(sel, (struct qinfo_8723b *)&q6_info, \"Q6 \");\n\tdump_qinfo_8723b(sel, (struct qinfo_8723b *)&q7_info, \"Q7 \");\n\tdump_qinfo_8723b(sel, (struct qinfo_8723b *)&mg_q_info, \"MG \");\n\tdump_qinfo_8723b(sel, (struct qinfo_8723b *)&hi_q_info, \"HI \");\n\tdump_bcn_qinfo_8723b(sel, (struct bcn_qinfo_8723b *)&bcn_q_info, \"BCN \");\n}\n\nvoid GetHwReg8723B(PADAPTER padapter, u8 variable, u8 *val)\n{\n\tPHAL_DATA_TYPE pHalData = GET_HAL_DATA(padapter);\n\tu8 val8;\n\tu16 val16;\n\tu32 val32;\n\n\n\tswitch (variable)\n\t{\n\t\tcase HW_VAR_TXPAUSE:\n\t\t\t*val = rtw_read8(padapter, REG_TXPAUSE);\n\t\t\tbreak;\n\n\t\tcase HW_VAR_BCN_VALID:\n#ifdef CONFIG_CONCURRENT_MODE\n\t\t\tif (padapter->iface_type == IFACE_PORT1)\n\t\t\t{\n\t\t\t\tval8 = rtw_read8(padapter, REG_DWBCN1_CTRL_8723B+2);\n\t\t\t\t*val = (BIT(0) & val8) ? _TRUE:_FALSE;\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\t{\n\t\t\t\t// BCN_VALID, BIT16 of REG_TDECTRL = BIT0 of REG_TDECTRL+2\n\t\t\t\tval8 = rtw_read8(padapter, REG_TDECTRL+2);\n\t\t\t\t*val = (BIT(0) & val8) ? _TRUE:_FALSE;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase HW_VAR_FWLPS_RF_ON:\n\t\t\t{\n\t\t\t\t// When we halt NIC, we should check if FW LPS is leave.\n\t\t\t\tu32 valRCR;\n\n\t\t\t\tif ((padapter->bSurpriseRemoved == _TRUE) ||\n\t\t\t\t\t(adapter_to_pwrctl(padapter)->rf_pwrstate == rf_off))\n\t\t\t\t{\n\t\t\t\t\t// If it is in HW/SW Radio OFF or IPS state, we do not check Fw LPS Leave,\n\t\t\t\t\t// because Fw is unload.\n\t\t\t\t\t*val = _TRUE;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvalRCR = rtw_read32(padapter, REG_RCR);\n\t\t\t\t\tvalRCR &= 0x00070000;\n\t\t\t\t\tif(valRCR)\n\t\t\t\t\t\t*val = _FALSE;\n\t\t\t\t\telse\n\t\t\t\t\t\t*val = _TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n#ifdef CONFIG_ANTENNA_DIVERSITY\n\t\tcase HW_VAR_CURRENT_ANTENNA:\n\t\t\t*val = pHalData->CurAntenna;\n\t\t\tbreak;\n#endif\n\n\t\tcase HW_VAR_EFUSE_USAGE:\n\t\t\t*val = pHalData->EfuseUsedPercentage;\n\t\t\tbreak;\n\n\t\tcase HW_VAR_EFUSE_BYTES:\n\t\t\t*((u16*)val) = pHalData->EfuseUsedBytes;\n\t\t\tbreak;\n\n\t\tcase HW_VAR_EFUSE_BT_USAGE:\n#ifdef HAL_EFUSE_MEMORY\n\t\t\t*val = pHalData->EfuseHal.BTEfuseUsedPercentage;\n#endif\n\t\t\tbreak;\n\n\t\tcase HW_VAR_EFUSE_BT_BYTES:\n#ifdef HAL_EFUSE_MEMORY\n\t\t\t*((u16*)val) = pHalData->EfuseHal.BTEfuseUsedBytes;\n#else\n\t\t\t*((u16*)val) = BTEfuseUsedBytes;\n#endif\n\t\t\tbreak;\n\n\t\tcase HW_VAR_APFM_ON_MAC:\n\t\t\t*val = pHalData->bMacPwrCtrlOn;\n\t\t\tbreak;\n\t\tcase HW_VAR_CHK_HI_QUEUE_EMPTY:\n\t\t\tval16 = rtw_read16(padapter, REG_TXPKT_EMPTY);\n\t\t\t*val = (val16 & BIT(10)) ? _TRUE:_FALSE;\n\t\t\tbreak;\n#ifdef CONFIG_WOWLAN\n\t\tcase HW_VAR_RPWM_TOG:\n\t\t\t*val = rtw_read8(padapter, SDIO_LOCAL_BASE|SDIO_REG_HRPWM1) & BIT7;\n\t\t\tbreak;\n\t\tcase HW_VAR_WAKEUP_REASON:\n\t\t\t*val = rtw_read8(padapter, REG_WOWLAN_WAKE_REASON);\n\t\t\tif(*val == 0xEA)\n\t\t\t\t*val = 0;\n\t\t\tbreak;\n\t\tcase HW_VAR_SYS_CLKR:\n\t\t\t*val = rtw_read8(padapter, REG_SYS_CLKR);\n\t\t\tbreak;\n#endif\n\t\tcase HW_VAR_DUMP_MAC_QUEUE_INFO:\n\t\t\tdump_mac_qinfo_8723b(val, padapter);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tGetHwReg(padapter, variable, val);\n\t\t\tbreak;\n\t}\n}\n\n/*\n *\tDescription:\n *\t\tChange default setting of specified variable.\n */\nu8 SetHalDefVar8723B(PADAPTER padapter, HAL_DEF_VARIABLE variable, void *pval)\n{\n\tPHAL_DATA_TYPE pHalData;\n\tu8 bResult;\n\n\n\tpHalData = GET_HAL_DATA(padapter);\n\tbResult = _SUCCESS;\n\n\tswitch (variable)\n\t{\n\t\tdefault:\n\t\t\tbResult = SetHalDefVar(padapter, variable, pval);\n\t\t\tbreak;\n\t}\n\n\treturn bResult;\n}\n\n#ifdef CONFIG_C2H_PACKET_EN\nvoid SetHwRegWithBuf8723B(PADAPTER padapter, u8 variable, u8 *pbuf, int len)\n{\n\tPHAL_DATA_TYPE pHalData;\n\n_func_enter_;\n\n\tpHalData = GET_HAL_DATA(padapter);\n\n\tswitch (variable) {\n\tcase HW_VAR_C2H_HANDLE:\n\t\tC2HPacketHandler_8723B(padapter, pbuf, len);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n_func_exit_;\n}\n#endif // CONFIG_C2H_PACKET_EN\n\n/*\n *\tDescription: \n *\t\tQuery setting of specified variable.\n */\nu8 GetHalDefVar8723B(PADAPTER padapter, HAL_DEF_VARIABLE variable, void *pval)\n{\n\tPHAL_DATA_TYPE pHalData;\n\tu8 bResult;\n\n\n\tpHalData = GET_HAL_DATA(padapter);\n\tbResult = _SUCCESS;\n\n\tswitch (variable)\n\t{\n\t\tcase HAL_DEF_MAX_RECVBUF_SZ:\n\t\t\t*((u32*)pval) = MAX_RECVBUF_SZ;\n\t\t\tbreak;\n\n\t\tcase HAL_DEF_RX_PACKET_OFFSET:\n\t\t\t*((u32*)pval) = RXDESC_SIZE + DRVINFO_SZ*8;\n\t\t\tbreak;\n\n\t\tcase HW_VAR_MAX_RX_AMPDU_FACTOR:\n\t\t\t// Stanley@BB.SD3 suggests 16K can get stable performance\n\t\t\t// The experiment was done on SDIO interface\n\t\t\t// coding by Lucas@20130730\n\t\t\t*(HT_CAP_AMPDU_FACTOR*)pval = MAX_AMPDU_FACTOR_16K;\n\t\t\tbreak;\n\t\tcase HAL_DEF_TX_LDPC:\n\t\tcase HAL_DEF_RX_LDPC:\n\t\t\t*((u8 *)pval) = _FALSE;\n\t\t\tbreak;\n\t\tcase HAL_DEF_TX_STBC:\n\t\t\t*((u8 *)pval) = 0;\n\t\t\tbreak;\n\t\tcase HAL_DEF_RX_STBC:\n\t\t\t*((u8 *)pval) = 1;\n\t\t\tbreak;\n\t\tcase HAL_DEF_EXPLICIT_BEAMFORMER:\n\t\tcase HAL_DEF_EXPLICIT_BEAMFORMEE:\n\t\t\t*((u8 *)pval) = _FALSE;\n\t\t\tbreak;\n\n\t\tcase HW_DEF_RA_INFO_DUMP:\n\t\t\t{\n\t\t\t\tu8 mac_id = *(u8*)pval;\n\t\t\t\tu32 cmd;\n\t\t\t\tu32 ra_info1, ra_info2;\n\t\t\t\tu32 rate_mask1, rate_mask2;\n\t\t\t\tu8 curr_tx_rate,curr_tx_sgi,hight_rate,lowest_rate;\t\t\t\n\t\t\t\t\n\t\t\t\tDBG_8192C(\"============ RA status check  Mac_id:%d ===================\\n\", mac_id);\n\n\t\t\t\tcmd = 0x40000100 | mac_id;\n\t\t\t\trtw_write32(padapter, REG_HMEBOX_DBG_2_8723B, cmd);\n\t\t\t\trtw_msleep_os(10);\n\t\t\t\tra_info1 = rtw_read32(padapter, 0x2F0);\n\t\t\t\tcurr_tx_rate = ra_info1&0x7F;\n\t\t\t\tcurr_tx_sgi = (ra_info1>>7)&0x01;\n\t\t\t\tDBG_8192C(\"[ ra_info1:0x%08x ] =>cur_tx_rate= %s,cur_sgi:%d, PWRSTS = 0x%02x  \\n\",\n\t\t\t\t\tra_info1,\t\t\t\t\t\t\n\t\t\t\t\tHDATA_RATE(curr_tx_rate),\n\t\t\t\t\tcurr_tx_sgi,\n\t\t\t\t\t(ra_info1>>8)  & 0x07);\n\n\t\t\t\tcmd = 0x40000400 | mac_id;\n\t\t\t\trtw_write32(padapter, REG_HMEBOX_DBG_2_8723B,cmd);\n\t\t\t\trtw_msleep_os(10);\n\t\t\t\tra_info1 = rtw_read32(padapter, 0x2F0);\n\t\t\t\tra_info2 = rtw_read32(padapter, 0x2F4);\n\t\t\t\trate_mask1 = rtw_read32(padapter, 0x2F8);\n\t\t\t\trate_mask2 = rtw_read32(padapter, 0x2FC);\n\t\t\t\thight_rate = ra_info2&0xFF;\n\t\t\t\tlowest_rate = (ra_info2>>8)  & 0xFF;\n\t\t\t\t\t\n\t\t\t\tDBG_8192C(\"[ ra_info1:0x%08x ] =>RSSI=%d, BW_setting=0x%02x, DISRA=0x%02x, VHT_EN=0x%02x\\n\",\n\t\t\t\t\tra_info1,\n\t\t\t\t\tra_info1&0xFF,\n\t\t\t\t\t(ra_info1>>8)  & 0xFF,\n\t\t\t\t\t(ra_info1>>16) & 0xFF,\n\t\t\t\t\t(ra_info1>>24) & 0xFF);\n\t\t\t\t\t\n\t\t\t\tDBG_8192C(\"[ ra_info2:0x%08x ] =>hight_rate=%s, lowest_rate=%s, SGI=0x%02x, RateID=%d\\n\",\n\t\t\t\t\tra_info2,\n\t\t\t\t\tHDATA_RATE(hight_rate),\n\t\t\t\t\tHDATA_RATE(lowest_rate),\n\t\t\t\t\t(ra_info2>>16) & 0xFF,\n\t\t\t\t\t(ra_info2>>24) & 0xFF);\n\n\t\t\t\tDBG_8192C(\"rate_mask2=0x%08x, rate_mask1=0x%08x\\n\", rate_mask2, rate_mask1);\n\t\t\t\t\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase HAL_DEF_TX_PAGE_BOUNDARY:\n\t\t\tif (!padapter->registrypriv.wifi_spec)\n\t\t\t{\n\t\t\t\t*(u8*)pval = TX_PAGE_BOUNDARY_8723B;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t*(u8*)pval = WMM_NORMAL_TX_PAGE_BOUNDARY_8723B;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase HAL_DEF_MACID_SLEEP:\n\t\t\t*(u8*)pval = _TRUE; // support macid sleep\n\t\t\tbreak;\n\t\tcase HAL_DEF_TX_PAGE_SIZE:\n\t\t\t *(( u32*)pval) = PAGE_SIZE_128;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbResult = GetHalDefVar(padapter, variable, pval);\n\t\t\tbreak;\n\t}\n\n\treturn bResult;\n}\n\n#ifdef CONFIG_WOWLAN\nvoid Hal_DetectWoWMode(PADAPTER pAdapter)\n{\n\tadapter_to_pwrctl(pAdapter)->bSupportRemoteWakeup = _TRUE;\n\tDBG_871X(\"%s\\n\", __func__);\n}\n#endif //CONFIG_WOWLAN\n\nvoid rtl8723b_start_thread(_adapter *padapter)\n{\n#if (defined CONFIG_SDIO_HCI) || (defined CONFIG_GSPI_HCI)\n#ifndef CONFIG_SDIO_TX_TASKLET\n\tstruct xmit_priv *xmitpriv = &padapter->xmitpriv;\n\n\txmitpriv->SdioXmitThread = kthread_run(rtl8723bs_xmit_thread, padapter, \"RTWHALXT\");\n\tif (IS_ERR(xmitpriv->SdioXmitThread))\n\t{\n\t\tRT_TRACE(_module_hal_xmit_c_, _drv_err_, (\"%s: start rtl8723bs_xmit_thread FAIL!!\\n\", __FUNCTION__));\n\t}\n#endif\n#endif\n}\n\nvoid rtl8723b_stop_thread(_adapter *padapter)\n{\n#if (defined CONFIG_SDIO_HCI) || (defined CONFIG_GSPI_HCI)\n#ifndef CONFIG_SDIO_TX_TASKLET\n\tstruct xmit_priv *xmitpriv = &padapter->xmitpriv;\n\n\t// stop xmit_buf_thread\n\tif (xmitpriv->SdioXmitThread ) {\n\t\t_rtw_up_sema(&xmitpriv->SdioXmitSema);\n\t\t_rtw_down_sema(&xmitpriv->SdioXmitTerminateSema);\n\t\txmitpriv->SdioXmitThread = 0;\n\t}\n#endif\n#endif\n}\n\n#if defined(CONFIG_CHECK_BT_HANG) && defined(CONFIG_BT_COEXIST)\nextern void check_bt_status_work(void *data);\nvoid rtl8723bs_init_checkbthang_workqueue(_adapter * adapter)\n{\n#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))\n\tadapter->priv_checkbt_wq = alloc_workqueue(\"sdio_wq\", 0, 0);\n#else\n\tadapter->priv_checkbt_wq = create_workqueue(\"sdio_wq\");\n#endif\n\tINIT_DELAYED_WORK(&adapter->checkbt_work, (void*)check_bt_status_work);\n}\n\nvoid rtl8723bs_free_checkbthang_workqueue(_adapter * adapter)\n{\n\tif (adapter->priv_checkbt_wq) {\n\t\tcancel_delayed_work_sync(&adapter->checkbt_work);\n\t\tflush_workqueue(adapter->priv_checkbt_wq);\n\t\tdestroy_workqueue(adapter->priv_checkbt_wq);\n\t\tadapter->priv_checkbt_wq = NULL;\n\t} \n}\n\nvoid rtl8723bs_cancle_checkbthang_workqueue(_adapter * adapter)\n{\n\tif (adapter->priv_checkbt_wq) {\n\t\tcancel_delayed_work_sync(&adapter->checkbt_work);\n\t}\n}\n\nvoid rtl8723bs_hal_check_bt_hang(_adapter * adapter)\n{\n\tif (adapter->priv_checkbt_wq)\n\t\tqueue_delayed_work(adapter->priv_checkbt_wq, &(adapter->checkbt_work), 0);\n}\n#endif\n\n\n\n\n", "comment_ratio": 0.1094391244870041}
{"lang": "c", "code": "#ifndef CRYINCLUDE_CRYCOMMON_ILOCALIZATIONMANAGER_H\n#define CRYINCLUDE_CRYCOMMON_ILOCALIZATIONMANAGER_H\n#pragma once\n\n#include \"LocalizationManagerBus.h\"\n//#include <platform.h> // Needed for LARGE_INTEGER (for consoles).\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Forward declarations\n////////////////////////////////////////////////////////////////////////////////////////////////\n\nclass XmlNodeRef;\n\n//////////////////////////////////////////////////////////////////////////\n// Localized strings manager interface.\n//////////////////////////////////////////////////////////////////////////\n\n// Localization Info structure\nstruct SLocalizedInfoGame\n{\n    SLocalizedInfoGame ()\n        : szCharacterName(nullptr)\n        , bUseSubtitle(false)\n    {\n    }\n\n    const char* szCharacterName;\n    AZStd::string sUtf8TranslatedText;\n\n    bool bUseSubtitle;\n};\n\nstruct SLocalizedAdvancesSoundEntry\n{\n    AZStd::string sName;\n    float       fValue;\n};\n\n// Localization Sound Info structure, containing sound related parameters.\nstruct SLocalizedSoundInfoGame\n    : public SLocalizedInfoGame\n{\n    SLocalizedSoundInfoGame()\n        : sSoundEvent(nullptr)\n        , fVolume(0.f)\n        , fRadioRatio (0.f)\n        , bIsDirectRadio(false)\n        , bIsIntercepted(false)\n        , nNumSoundMoods(0)\n        , pSoundMoods (nullptr)\n        , nNumEventParameters(0)\n        , pEventParameters(nullptr)\n    {\n    }\n\n    const char* sSoundEvent;\n    float fVolume;\n    float fRadioRatio;\n    bool    bIsDirectRadio;\n    bool    bIsIntercepted;\n\n    // SoundMoods.\n    size_t         nNumSoundMoods;\n    SLocalizedAdvancesSoundEntry* pSoundMoods;\n\n    // EventParameters.\n    size_t         nNumEventParameters;\n    SLocalizedAdvancesSoundEntry* pEventParameters;\n};\n\n// Localization Sound Info structure, containing sound related parameters.\nstruct SLocalizedInfoEditor\n    : public SLocalizedInfoGame\n{\n    SLocalizedInfoEditor()\n        : sKey(nullptr)\n        , sOriginalCharacterName(nullptr)\n        , sOriginalActorLine(nullptr)\n        , sUtf8TranslatedActorLine(nullptr)\n        , nRow(0)\n    {\n    }\n\n    const char* sKey;\n    const char* sOriginalCharacterName;\n    const char* sOriginalActorLine;\n    const char* sUtf8TranslatedActorLine;\n    unsigned int nRow;\n};\n\n// Summary:\n//      Interface to the Localization Manager.\nstruct ILocalizationManager\n    : public LocalizationManagerRequestBus::Handler\n{\n    //Platform independent language IDs. These are used to map the platform specific language codes to localization pakfiles\n    //Please ensure that each entry in this enum has a corresponding entry in the PLATFORM_INDEPENDENT_LANGUAGE_NAMES array which is defined in LocalizedStringManager.cpp currently.\n    enum EPlatformIndependentLanguageID\n    {\n        ePILID_English_US,\n        ePILID_English_GB,\n        ePILID_German_DE,\n        ePILID_Russian_RU,\n        ePILID_Polish_PL,\n        ePILID_Turkish_TR,\n        ePILID_Spanish_ES,\n        ePILID_Spanish_MX,\n        ePILID_French_FR,\n        ePILID_French_CA,\n        ePILID_Italian_IT,\n        ePILID_Portugese_PT,\n        ePILID_Portugese_BR,\n        ePILID_Japanese_JP,\n        ePILID_Korean_KR,\n        ePILID_Chinese_T,\n        ePILID_Chinese_S,\n        ePILID_Dutch_NL,\n        ePILID_Finnish_FI,\n        ePILID_Swedish_SE,\n        ePILID_Czech_CZ,\n        ePILID_Norwegian_NO,\n        ePILID_Arabic_SA,\n        ePILID_Danish_DK,\n        ePILID_MAX_OR_INVALID,   //Not a language, denotes the maximum number of languages or an unknown language\n    };\n\n    using TLocalizationBitfield = uint32;\n\n    // <interfuscator:shuffle>\n    virtual ~ILocalizationManager()= default;\n    virtual const char* LangNameFromPILID(const ILocalizationManager::EPlatformIndependentLanguageID id) = 0;\n    virtual ILocalizationManager::EPlatformIndependentLanguageID PILIDFromLangName(AZStd::string langName) = 0;\n    virtual ILocalizationManager::EPlatformIndependentLanguageID GetSystemLanguage() { return ILocalizationManager::EPlatformIndependentLanguageID::ePILID_English_US; }\n    virtual ILocalizationManager::TLocalizationBitfield MaskSystemLanguagesFromSupportedLocalizations(const ILocalizationManager::TLocalizationBitfield systemLanguages) = 0;\n    virtual ILocalizationManager::TLocalizationBitfield IsLanguageSupported(const ILocalizationManager::EPlatformIndependentLanguageID id) = 0;\n    bool SetLanguage([[maybe_unused]] const char* sLanguage) override { return false; }\n    const char* GetLanguage() override { return nullptr; }\n\n    int GetLocalizationFormat() const override { return -1; }\n    AZStd::string GetLocalizedSubtitleFilePath([[maybe_unused]] const AZStd::string& localVideoPath, [[maybe_unused]] const AZStd::string& subtitleFileExtension) const override { return \"\"; }\n    AZStd::string GetLocalizedLocXMLFilePath([[maybe_unused]] const AZStd::string& localXmlPath) const override { return \"\"; }\n    // load the descriptor file with tag information\n    virtual bool InitLocalizationData(const char* sFileName, bool bReload = false) = 0;\n    // request to load loca data by tag. Actual loading will happen during next level load begin event.\n    virtual bool RequestLoadLocalizationDataByTag(const char* sTag) = 0;\n    // direct load of loca data by tag\n    virtual bool LoadLocalizationDataByTag(const char* sTag, bool bReload = false) = 0;\n    virtual bool ReleaseLocalizationDataByTag(const char* sTag) = 0;\n\n    virtual bool LoadAllLocalizationData(bool bReload = false) = 0;\n    bool LoadExcelXmlSpreadsheet([[maybe_unused]] const char* sFileName, [[maybe_unused]] bool bReload = false) override { return false; }\n    void ReloadData() override {};\n\n    // Summary:\n    //   Free localization data.\n    virtual void FreeData() = 0;\n\n    // Summary:\n    //   Translate a string into the currently selected language.\n    // Description:\n    //   Processes the input string and translates all labels contained into the currently selected language.\n    // Parameters:\n    //   sString             - String to be translated.\n    //   outLocalizedString  - Translated version of the string.\n    //   bEnglish            - if true, translates the string into the always present English language.\n    // Returns:\n    //   true if localization was successful, false otherwise\n    bool LocalizeString_ch([[maybe_unused]] const char* sString, [[maybe_unused]] AZStd::string& outLocalizedString, [[maybe_unused]] bool bEnglish = false) override { return false; }\n\n    // Summary:\n    //   Same as LocalizeString( const char* sString, AZStd::string& outLocalizedString, bool bEnglish=false )\n    //   but at the moment this is faster.\n    bool LocalizeString_s([[maybe_unused]] const AZStd::string& sString, [[maybe_unused]] AZStd::string& outLocalizedString, [[maybe_unused]] bool bEnglish = false) override { return false; }\n\n    // Summary:\n    void LocalizeAndSubstituteInternal([[maybe_unused]] AZStd::string& locString, [[maybe_unused]] const AZStd::vector<AZStd::string>& keys, [[maybe_unused]] const AZStd::vector<AZStd::string>& values) override {}\n    //   Return the localized version corresponding to a label.\n    // Description:\n    //   A label has to start with '@' sign.\n    // Parameters:\n    //   sLabel              - Label to be translated, must start with '@' sign.\n    //   outLocalizedString  - Localized version of the label.\n    //   bEnglish            - if true, returns the always present English version of the label.\n    // Returns:\n    //   True if localization was successful, false otherwise.\n    bool LocalizeLabel([[maybe_unused]] const char* sLabel, [[maybe_unused]] AZStd::string& outLocalizedString, [[maybe_unused]] bool bEnglish = false) override { return false; }\n    virtual bool IsLocalizedInfoFound([[maybe_unused]] const char* sKey) { return false; }\n\n    // Summary:\n    //   Get localization info structure corresponding to a key (key=label without the '@' sign).\n    // Parameters:\n    //   sKey    - Key to be looked up. Key = Label without '@' sign.\n    //   outGameInfo - Reference to localization info structure to be filled in.\n    //  Returns:\n    //    True if info for key was found, false otherwise.\n    virtual bool GetLocalizedInfoByKey(const char* sKey, SLocalizedInfoGame& outGameInfo) = 0;\n\n    // Summary:\n    //   Get the sound localization info structure corresponding to a key.\n    // Parameters:\n    //   sKey         - Key to be looked up. Key = Label without '@' sign.\n    //   outSoundInfo - reference to sound info structure to be filled in\n    //                                  pSoundMoods requires nNumSoundMoods-times allocated memory\n    //                                  on return nNumSoundMoods will hold how many SoundsMood entries are needed\n    //                                  pEventParameters requires nNumEventParameters-times allocated memory\n    //                                  on return nNumEventParameters will hold how many EventParameter entries are needed\n    //                                  Passing 0 in the Num fields will make the query ignore checking for allocated memory\n    // Returns:\n    //   True if successful, false otherwise (key not found, or not enough memory provided to write additional info).\n    virtual bool GetLocalizedInfoByKey(const char* sKey, SLocalizedSoundInfoGame* pOutSoundInfo) = 0;\n\n    // Summary:\n    //   Return number of localization entries.\n    int  GetLocalizedStringCount() override { return -1; }\n\n    // Summary:\n    //   Get the localization info structure at index nIndex.\n    // Parameters:\n    //   nIndex  - Index.\n    //   outEditorInfo - Reference to localization info structure to be filled in.\n    // Returns:\n    //   True if successful, false otherwise (out of bounds).\n    virtual bool GetLocalizedInfoByIndex(int nIndex, SLocalizedInfoEditor& outEditorInfo) = 0;\n\n    // Summary:\n    //   Get the localization info structure at index nIndex.\n    // Parameters:\n    //   nIndex  - Index.\n    //   outGameInfo - Reference to localization info structure to be filled in.\n    // Returns:\n    //   True if successful, false otherwise (out of bounds).\n    virtual bool GetLocalizedInfoByIndex(int nIndex, SLocalizedInfoGame& outGameInfo) = 0;\n\n    // Summary:\n    //   Get the english localization info structure corresponding to a key.\n    // Parameters:\n    //   sKey         - Key to be looked up. Key = Label without '@' sign.\n    //   sLocalizedString - Corresponding english language string.\n    // Returns:\n    //   True if successful, false otherwise (key not found).\n    bool GetEnglishString([[maybe_unused]] const char* sKey, [[maybe_unused]] AZStd::string& sLocalizedString) override { return false; }\n\n    // Summary:\n    //   Get Subtitle for Key or Label .\n    // Parameters:\n    //   sKeyOrLabel    - Key or Label to be used for subtitle lookup. Key = Label without '@' sign.\n    //   outSubtitle    - Subtitle (untouched if Key/Label not found).\n    //   bForceSubtitle - If true, get subtitle (sLocalized or sEnglish) even if not specified in Data file.\n    // Returns:\n    //   True if subtitle found (and outSubtitle filled in), false otherwise.\n    bool GetSubtitle([[maybe_unused]] const char* sKeyOrLabel, [[maybe_unused]] AZStd::string& outSubtitle, [[maybe_unused]] bool bForceSubtitle = false) override { return false; }\n\n    // Description:\n    //      These methods format outString depending on sString with ordered arguments\n    //      FormatStringMessage(outString, \"This is %2 and this is %1\", \"second\", \"first\");\n    // Arguments:\n    //      outString - This is first and this is second.\n    void FormatStringMessage_List([[maybe_unused]] AZStd::string& outString, [[maybe_unused]] const AZStd::string& sString, [[maybe_unused]] const char** sParams, [[maybe_unused]] int nParams) override {}\n    void FormatStringMessage([[maybe_unused]] AZStd::string& outString, [[maybe_unused]] const AZStd::string& sString, [[maybe_unused]] const char* param1, [[maybe_unused]] const char* param2 = nullptr, [[maybe_unused]] const char* param3 = nullptr, [[maybe_unused]] const char* param4 = nullptr) override {}\n\n    void LocalizeTime([[maybe_unused]] time_t t, [[maybe_unused]] bool bMakeLocalTime, [[maybe_unused]] bool bShowSeconds, [[maybe_unused]] AZStd::string& outTimeString) override {}\n    void LocalizeDate([[maybe_unused]] time_t t, [[maybe_unused]] bool bMakeLocalTime, [[maybe_unused]] bool bShort, [[maybe_unused]] bool bIncludeWeekday, [[maybe_unused]] AZStd::string& outDateString) override {}\n    void LocalizeDuration([[maybe_unused]] int seconds, [[maybe_unused]] AZStd::string& outDurationString) override {}\n    void LocalizeNumber([[maybe_unused]] int number, [[maybe_unused]] AZStd::string& outNumberString) override {}\n    void LocalizeNumber_Decimal([[maybe_unused]] float number, [[maybe_unused]] int decimals, [[maybe_unused]] AZStd::string& outNumberString) override {}\n\n    // Summary:\n    //   Returns true if the project has localization configured for use, false otherwise.\n    bool ProjectUsesLocalization() const override { return false; }\n    // </interfuscator:shuffle>\n\n    static ILINE TLocalizationBitfield LocalizationBitfieldFromPILID(EPlatformIndependentLanguageID pilid)\n    {\n        assert(pilid >= 0 && pilid < ePILID_MAX_OR_INVALID);\n        return (1 << pilid);\n    }\n};\n\n// Summary:\n//      Simple bus that notifies listeners that the language (g_language) has changed.\n\n\n\n\n#endif // CRYINCLUDE_CRYCOMMON_ILOCALIZATIONMANAGER_H\n\n", "comment_ratio": 0.36271186440677966}
{"lang": "c", "code": "#ifndef _WX_COLOUR_H_\n#define _WX_COLOUR_H_\n\n#include \"wx/object.h\"\n#include \"wx/string.h\"\n\n// Colour\nclass WXDLLEXPORT wxColour: public wxColourBase\n{\npublic:\n    // constructors\n    // ------------\n\n    // default\n    wxColour() { Init(); }\n    DEFINE_STD_WXCOLOUR_CONSTRUCTORS\n\n    // copy ctors and assignment operators\n    wxColour( const wxColour& col );\n    wxColour( const wxColour* col );\n    wxColour& operator = ( const wxColour& col );\n\n    // dtor\n    virtual ~wxColour();\n\n    // accessors\n    bool Ok() const { return IsOk(); }\n    bool IsOk() const {return m_isInit; }\n\n    unsigned char Red() const { return m_red; }\n    unsigned char Green() const { return m_green; }\n    unsigned char Blue() const { return m_blue; }\n\n    // comparison\n    bool operator == (const wxColour& colour) const\n    {\n        return (m_isInit == colour.m_isInit\n                && m_red == colour.m_red\n                && m_green == colour.m_green\n                && m_blue == colour.m_blue);\n    }\n    bool operator != (const wxColour& colour) const { return !(*this == colour); }\n\n    const WXCOLORREF& GetPixel() const { return m_pixel; };\n\nprotected:\n\n    // Helper function\n    void Init();\n\n    void InitWith( unsigned char red, unsigned char green, unsigned char blue );\n\nprivate:\n    bool          m_isInit;\n    unsigned char m_red;\n    unsigned char m_blue;\n    unsigned char m_green;\n\npublic:\n    WXCOLORREF m_pixel ;\n    void Set( const WXCOLORREF* color ) ;\n\nprivate:\n    DECLARE_DYNAMIC_CLASS(wxColour)\n};\n\n#endif\n  // _WX_COLOUR_H_\n\n", "comment_ratio": 0.25}
{"lang": "c", "code": "// Dongzhuo Li 05/13/2018\n#ifndef SRC_REC_H__\n#define SRC_REC_H__\n\n#include <vector>\n#include \"Parameter.h\"\n#include \"utilities.h\"\n\nclass Src_Rec {\n private:\n  bool if_res_;\n  bool if_win_;\n\n public:\n  std::vector<int> vec_z_src;\n  std::vector<int> vec_x_src;\n  std::vector<int> vec_nrec;\n  std::vector<int *> d_vec_z_rec;\n  std::vector<int *> d_vec_x_rec;\n  std::vector<float *> d_vec_win_start;  // device side window\n  std::vector<float *> d_vec_win_end;    // device side window\n  std::vector<float *> d_vec_weights;    // weights for traces\n  std::vector<float> vec_srcweights;     // weights for sources\n  std::vector<float *> vec_source;\n  std::vector<float *> d_vec_source;\n  std::vector<float *> vec_data;\n  //   std::vector<float *> d_vec_data;\n  std::vector<float *> vec_data_obs;\n  //   std::vector<float *> d_vec_data_obs;\n  std::vector<float *> vec_res;  // host side data residual\n  //   std::vector<float *> d_vec_res;  // device side data residual\n  // ratio between x and z normal stress component\n  std::vector<double> vec_src_rxz;\n  std::vector<double *> vec_rec_rxz;\n  cuFloatComplex *d_coef;\n  int nShots;\n\n  Src_Rec();\n  Src_Rec(Parameter &para, std::string survey_fname);\n  Src_Rec(Parameter &para, std::string survey_fname, const float *stf,\n          int nShots, const int *shot_ids);\n  Src_Rec(const Src_Rec&) = delete;\n  Src_Rec& operator=(const Src_Rec&) = delete;\n  ~Src_Rec();\n};\n\n#endif\n", "comment_ratio": 0.2127659574468085}
{"lang": "c", "code": "#ifndef __VM_TS_DCL_GPIO_H__\r\n#define __VM_TS_DCL_GPIO_H__\r\n\r\n\r\n\r\n/******************************************************************\r\n* DESCRIPTION\r\n*   This enum defines the device for gpio module,used in vm_ts_dcl_open as a \r\nparameter.\r\n*   To control GPIOs, you should use DCL(Driver Common Layer) APIs. \r\n* EXAMPLE\r\n* <code>\r\n*   #include \"vmtsdcl.h\"\r\n*   VM_TS_DCL_HANDLE gpio_handle;\t\t\t\t\t // Declare a VM_TS_DCL_HANDLE variable. \r\n*   gpio_handle = vm_ts_dcl_open(VM_TS_DCL_GPIO,55);      // Call vm_ts_dcl_open to get a handle. 55 means gpio55\r\n* </code>\r\n*******************************************************************/\r\n\r\ntypedef enum\r\n{\r\n\tVM_TS_GPIO_GROUP_START = VM_TS_DCL_GPIO_GROUP_START,\r\n\tVM_TS_DCL_GPIO,              /*This is for control normal gpio function. */\r\n}VM_TS_DCL_GPIO_DEV;\r\n\r\n\r\n\r\n/******************************************************************\r\n* DESCRIPTION\r\n*   This enum  define the control command for GPIO  module,used in vm_ts_dcl_control as parameter.\r\n*   With different commands, user could control the different function of the GPIOs.\r\n*   To control GPIOs, you should use DCL(Driver Common Layer) APIs. \r\n* EXAMPLE\r\n* <code>\r\n*   #include \"vmtsdcl.h\"\r\n*   VM_TS_DCL_HANDLE gpio_handle;\t\t\t // Declare a VM_TS_DCL_HANDLE variable. \r\n*   VM_TS_DCL_GPIO_CTRL_READ_T gpio_input_data;\t\t //Declare a variable for read IO. \r\n*   VM_TS_DCL_GPIO_CTRL_SET_PUPD_R0_R1_T pupd_r0r1_data; //Declare a VM_TS_DCL_GPIO_CTRL_SET_PUPD_R0_R1_T variable.\r\n*   gpio_handle = vm_ts_dcl_open(VM_TS_DCL_GPIO,55); // First, we call vm_ts_dcl_open to get a handle. 55 means gpio55\r\n*   vm_ts_dcl_control(gpio_handle,VM_TS_DCL_GPIO_CMD_SET_MODE_3,NULL); //  we call vm_ts_dcl_control to set gpio55 as mode3. \r\n*   vm_ts_dcl_control(gpio_handle,VM_TS_DCL_GPIO_CMD_READ,(void *)&gpio_input_data); // We call vm_ts_dcl_control to read gpio55 . \r\n*   vm_ts_dcl_control(gpio_handle,VM_TS_DCL_GPIO_CMD_WRITE_HIGH,0); // we call vm_ts_dcl_control to write gpio55 . \r\n*   pupd_r0r1_data.fgSetPupd = 1; // More details, please refer to the GPIO datasheet. \r\n*   pupd_r0r1_data.fgSetR0 = 1; // More details, please refer to the GPIO datasheet. \r\n*   pupd_r0r1_data.fgSetR1 = 0; // More details, please refer to the GPIO datasheet. \r\n*   vm_ts_dcl_control(gpio_handle,VM_TS_DCL_GPIO_CMD_SET_PUPD_R0_R1,(void *)&pupd_r0r1_data); //we call vm_ts_dcl_control to set pupd of gpio55 . \r\n*   vm_ts_dcl_close(gpio_handle); // Finally, we call vm_ts_dcl_close \r\n* </code>\r\n*******************************************************************/\r\ntypedef enum\r\n{\r\n   VM_TS_DCL_GPIO_CMD_READ, \t\t\t \t/*read data from GPIO Pin*/\r\n   VM_TS_DCL_GPIO_CMD_WRITE_LOW,   \t\t   /*write low to GPIO pin*/\r\n   VM_TS_DCL_GPIO_CMD_WRITE_HIGH,\t\t\t/*write high to GPIO Pin*/\r\n   VM_TS_DCL_GPIO_CMD_SET_MODE_0, \t\t    /*set GPIO mode as mode 0*/\r\n   VM_TS_DCL_GPIO_CMD_SET_MODE_1,\t\t\t/*set GPIO mode as mode 1*/\r\n   VM_TS_DCL_GPIO_CMD_SET_MODE_2,\t\t\t/*set GPIO mode as mode 2*/\r\n   VM_TS_DCL_GPIO_CMD_SET_MODE_3,\t\t\t/*set GPIO mode as mode 3*/\r\n   VM_TS_DCL_GPIO_CMD_SET_MODE_4,\t\t\t/*set GPIO mode as mode 4 ,only for chip support 4-bit mode*/\r\n   VM_TS_DCL_GPIO_CMD_SET_MODE_5,\t\t\t/*set GPIO mode as mode 5*,only for chip support 4-bit mode*/\r\n   VM_TS_DCL_GPIO_CMD_SET_MODE_6,\t\t\t/*set GPIO mode as mode 6*,only for chip support 4-bit mode*/\r\n   VM_TS_DCL_GPIO_CMD_SET_MODE_7,\t\t    /*set GPIO mode as mode 7*,only for chip support 4-bit mode*/\r\n   VM_TS_DCL_GPIO_CMD_SET_MODE_8,\t\t    /*set GPIO mode as mode 8*,only for chip support 4-bit mode*/\r\n   VM_TS_DCL_GPIO_CMD_SET_MODE_9,\t\t\t/*set GPIO mode as mode 9*,only for chip support 4-bit mode*/\r\n   VM_TS_DCL_GPIO_CMD_SET_MODE_10,\t\t\t/*set GPIO mode as mode 10*,only for chip support 4-bit mode*/\r\n   VM_TS_DCL_GPIO_CMD_SET_DIR_OUT, \t\t    /*set GPIO direction as output*/\r\n   VM_TS_DCL_GPIO_CMD_SET_DIR_IN,\t \t\t/*set GPIO direction as input*/\r\n   VM_TS_DCL_GPIO_CMD_ENABLE_PULL, \t\t    /*enable GPIO pull-up/pull-down seting */\r\n   VM_TS_DCL_GPIO_CMD_DISABLE_PULL,\t\t   /*disable GPIO pull-up/pull-down seting*/\r\n   VM_TS_DCL_GPIO_CMD_SET_PULL_HIGH,       /*set GPIO as pull-up*/\r\n   VM_TS_DCL_GPIO_CMD_SET_PULL_LOW,        /*set GPIO as pull-down*/\r\n}VM_TS_DCL_GPIO_CTRL_CMD_T;\r\n\r\n/******************************************************************\r\n* DESCRIPTION\r\n*   This struct is for VM_TS_DCL_GPIO_CMD_READ control command,used in vm_ts_dcl_control as parameter.\r\n*   You can find the sample code in the description of VM_TS_DCL_GPIO_CTRL_CMD_T.\r\n*******************************************************************/\r\ntypedef struct\r\n{\r\n   VMUINT8   u1IOData; /* The returned value. 0 means the GPIO pin input level is low. 1 means level is high*/\r\n} VM_TS_DCL_GPIO_CTRL_READ_T;\r\n\r\n\r\n\r\n\r\n\r\n#endif \r\n\r\n\r\n\n", "comment_ratio": 0.15555555555555556}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n\n#define GM_EXPORT __attribute__((visibility(\"default\")))\n\n/*!\n * <pre>\n * Based on \"AppleSingle/AppleDouble Formats for Foreign Files Developer's Note\"\n *\n * Notes:\n * DoubleEntryFileDatesInfo\n *    File creation, modification, backup, and access times as number of seconds\n *    before or after 12:00 AM Jan 1 2000 GMT as SInt32.\n *  DoubleEntryFinderInfo\n *    16 bytes of FinderInfo followed by 16 bytes of extended FinderInfo.\n *    New FinderInfo should be zero'd out. For a directory, when the Finder\n *    encounters an entry with the init'd bit cleared, it will initialize the\n *    frView field of the to a value indicating how the contents of the\n *    directory should be shown. Recommend to set frView to value of 256.\n *  DoubleEntryMacFileInfo\n *    This is a 32 bit flag that stores locked (bit 0) and protected (bit 1).\n * </pre>\n */\ntypedef enum {\n\tDoubleEntryInvalid = 0,\n\tDoubleEntryDataFork = 1,\n\tDoubleEntryResourceFork = 2,\n\tDoubleEntryRealName = 3,\n\tDoubleEntryComment = 4,\n\tDoubleEntryBlackAndWhiteIcon = 5,\n\tDoubleEntryColorIcon = 6,\n\tDoubleEntryFileDatesInfo = 8,  // See notes\n\tDoubleEntryFinderInfo = 9,     // See notes\n\tDoubleEntryMacFileInfo = 10,   // See notes\n\tDoubleEntryProDosFileInfo = 11,\n\tDoubleEntryMSDosFileinfo = 12,\n\tDoubleEntryShortName = 13,\n\tDoubleEntryAFPFileInfo = 14,\n\tDoubleEntryDirectoryID = 15,\n} GMAppleDoubleEntryID;\n\n/*!\n * @class\n * @discussion This class represents a single entry in an AppleDouble file.\n */\nGM_EXPORT @interface GMAppleDoubleEntry : NSObject {\n@private\n\tGMAppleDoubleEntryID entryID_;\n\tNSData *data_;  // Format depends on entryID_\n}\n/*!\n * @abstract Initializes an AppleDouble entry with ID and data.\n * @param entryID A valid entry identifier\n * @param data Raw data for the entry\n */\n- (id) initWithEntryID:(GMAppleDoubleEntryID)entryID data:(NSData *)data;\n\n/*! @abstract The entry ID */\n- (GMAppleDoubleEntryID) entryID;\n\n/*! @abstract The entry data */\n- (NSData *) data;\n@end\n\n/*!\n * @class\n * @discussion This class can be used to construct raw AppleDouble data.\n */\nGM_EXPORT @interface GMAppleDouble : NSObject {\n@private\n\tNSMutableArray *entries_;\n}\n\n/*! @abstract An autoreleased empty GMAppleDouble file */\n+ (GMAppleDouble *) appleDouble;\n\n/*!\n * @abstract An autoreleased GMAppleDouble file.\n * @discussion The GMAppleDouble is pre-filled with entries from the raw\n * AppleDouble file data.\n * @param data Raw AppleDouble file data.\n */\n+ (GMAppleDouble *) appleDoubleWithData:(NSData *)data;\n\n/*!\n * @abstract Adds an entry to the AppleDouble file.\n * @param entry The entry to add\n */\n- (void) addEntry:(GMAppleDoubleEntry *)entry;\n\n/*!\n * @abstract Adds an entry to the AppleDouble file with ID and data.\n * @param entryID The ID of the entry to add\n * @param data The raw data for the entry to add (retained)\n */\n- (void) addEntryWithID:(GMAppleDoubleEntryID)entryID data:(NSData *)data;\n\n/*!\n * @abstract Adds entries based on the provided raw AppleDouble file data.\n * @discussion This will attempt to parse the given data as an AppleDouble file\n * and add all entries found.\n * @param data Raw AppleDouble file data\n * @result YES if the provided data was parsed correctly.\n */\n- (BOOL) addEntriesFromAppleDoubleData:(NSData *)data;\n\n/*!\n * @abstract The set of GMAppleDoubleEntry present in this GMAppleDouble.\n * @result An array of GMAppleDoubleEntry.\n */\n- (NSArray *) entries;\n\n/*!\n * @abstract Constructs raw data for the AppleDouble file.\n * @result The raw data for an AppleDouble file represented by this GMAppleDouble.\n */\n- (NSData *) data;\n\n@end\n\n#undef GM_EXPORT\n", "comment_ratio": 0.24096385542168675}
{"lang": "c", "code": "#pragma once\n\nnamespace cryptonote\n{\n  struct bs_delegate_info;\n\n  double get_delegate_rank(const bs_delegate_info& info);\n}\n\n", "comment_ratio": 0.23076923076923078}
{"lang": "c", "code": "#pragma once\n\n#include \"redner.h\"\n#include \"vector.h\"\n#include \"intersection.h\"\n#include \"buffer.h\"\n#include \"ptr.h\"\n\nstruct Shape {\n    Shape() {}\n    Shape(ptr<float> vertices,\n          ptr<int> indices,\n          ptr<float> uvs,\n          ptr<float> normals,\n          int num_vertices,\n          int num_triangles,\n          int material_id,\n          int light_id) :\n        vertices(vertices.get()),\n        indices(indices.get()),\n        uvs(uvs.get()),\n        normals(normals.get()),\n        num_vertices(num_vertices),\n        num_triangles(num_triangles),\n        material_id(material_id),\n        light_id(light_id) {}\n\n    inline bool has_uvs() const {\n        return uvs != nullptr;\n    }\n\n    inline bool has_normals() const {\n        return normals != nullptr;\n    }\n\n    float *vertices;\n    int *indices;\n    float *uvs;\n    float *normals;\n    int num_vertices;\n    int num_triangles;\n    int material_id;\n    int light_id;\n};\n\nstruct DShape {\n    DShape() {}\n    DShape(ptr<float> vertices,\n           ptr<float> uvs,\n           ptr<float> normals)\n        : vertices(vertices.get()),\n          uvs(uvs.get()),\n          normals(normals.get()) {}\n\n    float *vertices;\n    float *uvs;\n    float *normals;\n};\n\nstruct DVertex {\n    DEVICE DVertex(int shape_id = -1, int vertex_id = -1,\n        const Vector3 &d_v = Vector3{0, 0, 0},\n        const Vector2 &d_uv = Vector2{0, 0},\n        const Vector3 &d_n = Vector3{0, 0, 0})\n        : shape_id(shape_id), vertex_id(vertex_id), d_v(d_v), d_uv(d_uv), d_n(d_n) {}\n\n    int shape_id, vertex_id;\n    Vector3 d_v;\n    Vector2 d_uv;\n    Vector3 d_n;\n\n    DEVICE inline bool operator<(const DVertex &other) const {\n        if (shape_id != other.shape_id) {\n            return shape_id < other.shape_id;\n        } else {\n            return vertex_id < other.vertex_id;\n        }\n    }\n\n    DEVICE inline bool operator==(const DVertex &other) const {\n        return shape_id == other.shape_id && vertex_id == other.vertex_id;\n    }\n\n    DEVICE inline DVertex operator+(const DVertex &other) const {\n        return DVertex{shape_id, vertex_id,\n                       d_v + other.d_v,\n                       d_uv + other.d_uv,\n                       d_n + other.d_n};\n    }\n};\n\nDEVICE\ninline Vector3f get_vertex(const Shape &shape, int index) {\n    return Vector3f{shape.vertices[3 * index + 0],\n                    shape.vertices[3 * index + 1],\n                    shape.vertices[3 * index + 2]};\n}\n\nDEVICE\ninline Vector3i get_indices(const Shape &shape, int index) {\n    return Vector3i{shape.indices[3 * index + 0],\n                    shape.indices[3 * index + 1],\n                    shape.indices[3 * index + 2]};\n}\n\nDEVICE\ninline bool has_uvs(const Shape &shape) {\n    return shape.uvs != nullptr;\n}\n\nDEVICE\ninline Vector2f get_uv(const Shape &shape, int index) {\n    return Vector2f{shape.uvs[2 * index + 0],\n                    shape.uvs[2 * index + 1]};\n}\n\nDEVICE\ninline void accumulate_uv(DShape &d_shape, int index, const Vector2 &d) {\n    d_shape.uvs[2 * index + 0] += d[0];\n    d_shape.uvs[2 * index + 1] += d[1];\n}\n\nDEVICE\ninline bool has_shading_normals(const Shape &shape) {\n    return shape.normals != nullptr;\n}\n\nDEVICE\ninline Vector3f get_shading_normal(const Shape &shape, int index) {\n    return Vector3f{shape.normals[3 * index + 0],\n                    shape.normals[3 * index + 1],\n                    shape.normals[3 * index + 2]};\n}\n\nDEVICE\ninline Vector3 get_normal(const Shape &shape, int tri_index) {\n    auto indices = get_indices(shape, tri_index);\n    auto v0 = Vector3{get_vertex(shape, indices[0])};\n    auto v1 = Vector3{get_vertex(shape, indices[1])};\n    auto v2 = Vector3{get_vertex(shape, indices[2])};\n    auto e1 = v1 - v0;\n    auto e2 = v2 - v0;\n    return normalize(cross(e1, e2));\n}\n\nDEVICE\ninline void accumulate_shading_normal(DShape &d_shape, int index, const Vector3 &d) {\n    d_shape.normals[3 * index + 0] += d[0];\n    d_shape.normals[3 * index + 1] += d[1];\n    d_shape.normals[3 * index + 2] += d[2];\n}\n\nDEVICE\ninline Real get_area(const Shape &shape, int index) {\n    auto ind = get_indices(shape, index);\n    auto v0 = Vector3{get_vertex(shape, ind[0])};\n    auto v1 = Vector3{get_vertex(shape, ind[1])};\n    auto v2 = Vector3{get_vertex(shape, ind[2])};\n    return 0.5f * length(cross(v1 - v0, v2 - v0));\n}\n\nDEVICE\ninline void d_get_area(const Shape &shape, int index,\n                       const Real d_area, DVertex *d_vertices) {\n    auto ind = get_indices(shape, index);\n    auto v0 = Vector3{get_vertex(shape, ind[0])};\n    auto v1 = Vector3{get_vertex(shape, ind[1])};\n    auto v2 = Vector3{get_vertex(shape, ind[2])};\n    auto dir = cross(v1 - v0, v2 - v0);\n    // auto area = 0.5f * length(dir);\n    auto d_len = d_area * 0.5f;\n    auto d_dir = d_length(dir, d_len);\n    auto d_e1 = Vector3{0, 0, 0};\n    auto d_e2 = Vector3{0, 0, 0};\n    d_cross(v1 - v0, v2 - v0, d_dir, d_e1, d_e2);\n    d_vertices[0].d_v -= (d_e1 + d_e2);\n    d_vertices[1].d_v += d_e1;\n    d_vertices[2].d_v += d_e2;\n}\n\nDEVICE\ninline SurfacePoint sample_shape(const Shape &shape, int index, const Vector2 &sample) {\n    auto ind = get_indices(shape, index);\n    auto v0 = Vector3{get_vertex(shape, ind[0])};\n    auto v1 = Vector3{get_vertex(shape, ind[1])};\n    auto v2 = Vector3{get_vertex(shape, ind[2])};\n    auto a = sqrt(sample[0]);\n    auto b1 = 1.f - a;\n    auto b2 = a * sample[1];\n    auto e1 = v1 - v0;\n    auto e2 = v2 - v0;\n    auto n = cross(e1, e2);\n    auto normalized_n = normalize(n);\n    return SurfacePoint{\n        v0 + e1 * b1 + e2 * b2,\n        normalized_n,\n        Frame(normalized_n), // TODO: phong interpolate this\n        sample, // TODO: give true light source uv\n        Vector2{0, 0}, // TODO: inherit derivatives from previous path vertex\n        Vector2{0, 0}}; \n}\n\nDEVICE\ninline void d_sample_shape(const Shape &shape, int index, const Vector2 &sample,\n                           const SurfacePoint &d_point, DVertex *d_vertices) {\n    auto ind = get_indices(shape, index);\n    auto v0 = Vector3{get_vertex(shape, ind[0])};\n    auto v1 = Vector3{get_vertex(shape, ind[1])};\n    auto v2 = Vector3{get_vertex(shape, ind[2])};\n    auto a = sqrt(sample[0]);\n    auto b1 = 1.f - a;\n    auto b2 = a * sample[1];\n    auto e1 = v1 - v0;\n    auto e2 = v2 - v0;\n    auto n = cross(e1, e2);\n    auto normalized_n = normalize(n);\n    // point = SurfacePoint{\n    //     v0 + e1 * b1 + e2 * b2,\n    //     normalized_n,\n    //     Frame(normalized_n),\n    //     sample,\n    //     Vector2{0, 0},\n    //     Vector2{0, 0}};\n    // No need to propagate to b1 b2\n    auto d_v0 = d_point.position;\n    auto d_e1 = d_point.position * b1;\n    auto d_e2 = d_point.position * b2;\n    auto d_normalized_n = d_point.geom_normal;\n    d_normalized_n += d_point.shading_frame[2];\n    d_coordinate_system(\n        normalized_n, d_point.shading_frame[0], d_point.shading_frame[1], d_normalized_n);\n    // auto normalized_n = normalize(n);\n    auto d_n = d_normalize(n, d_normalized_n);\n    // n = cross(e1, e2)\n    d_cross(e1, e2, d_n, d_e1, d_e2);\n    // e1 = v1 - v0\n    auto d_v1 = d_e1;\n    d_v0 -= d_e1;\n    // e2 = v2 - v0\n    auto d_v2 = d_e2;\n    d_v0 -= d_e2;\n    d_vertices[0].d_v += d_v0;\n    d_vertices[1].d_v += d_v1;\n    d_vertices[2].d_v += d_v2;\n}\n\n// Derivatives of projection of a point to barycentric coordinate\n// http://gamedev.stackexchange.com/questions/23743/whats-the-most-efficient-way-to-find-barycentric-coordinates\nDEVICE\ninline\nvoid barycentric(const Vector3 &p0,\n                 const Vector3 &p1,\n                 const Vector3 &p2,\n                 Vector3 &d_b0_d_p,\n                 Vector3 &d_b1_d_p) {\n    auto e1 = p1 - p0;\n    auto e2 = p2 - p0;\n    // auto e0 = p - p0;\n    auto e0_dp = Vector3{1, 1, 1};\n    auto d11 = dot(e1, e1);\n    auto d12 = dot(e1, e2);\n    auto d22 = dot(e2, e2);\n    // auto d01 = dot(e0, e1);\n    auto d01_dp = e0_dp * e1;\n    // auto d02 = dot(e0, e2);\n    auto d02_dp = e0_dp * e2;\n    auto inv_denom = Real(1) / (d11 * d22 - d12 * d12);\n    // auto b0 = (d22 * d01 - d12 * d02) * inv_denom;\n    // auto b1 = (d11 * d02 - d12 * d01) * inv_denom;\n    d_b0_d_p = (d22 * d01_dp - d12 * d02_dp) * inv_denom;\n    d_b1_d_p = (d11 * d02_dp - d12 * d01_dp) * inv_denom;\n}\n\nDEVICE\ninline\nvoid d_barycentric(const Vector3 &p0,\n                   const Vector3 &p1,\n                   const Vector3 &p2,\n                   const Vector3 &d_d_b0_d_p,\n                   const Vector3 &d_d_b1_d_p,\n                   Vector3 &d_p0,\n                   Vector3 &d_p1,\n                   Vector3 &d_p2) {\n    auto e1 = p1 - p0;\n    auto e2 = p2 - p0;\n    // auto e0 = p - p0;\n    auto e0_dp = Vector3{1, 1, 1};\n    auto d11 = dot(e1, e1);\n    auto d12 = dot(e1, e2);\n    auto d22 = dot(e2, e2);\n    // auto d01 = dot(e0, e1);\n    auto d01_dp = dot(e0_dp, e1);\n    // auto d02 = dot(e0, e2);\n    auto d02_dp = dot(e0_dp, e2);\n    auto inv_denom = Real(1) / (d11 * d22 - d12 * d12);\n    // auto b0 = (d22 * d01 - d12 * d02) * inv_denom;\n    // auto b1 = (d11 * d02 - d12 * d01) * inv_denom;\n\n    // Backprop\n    // d_b0_d_p = (d22 * d01_dp - d12 * d02_dp) * inv_denom\n    auto d_d22 = d_d_b0_d_p * d01_dp * inv_denom;\n    auto d_d01_dp = d_d_b0_d_p * d22 * inv_denom;\n    auto d_d12 = -d_d_b0_d_p * d02_dp * inv_denom;\n    auto d_d02_dp = -d_d_b0_d_p * d12 * inv_denom;\n    auto d_inv_denom = d_d_b0_d_p * (d22 * d01_dp - d12 * d02_dp);\n    // d_b1_d_p = (d11 * d02_dp - d12 * d01_dp) * inv_denom\n    auto d_d11 = d_d_b1_d_p * d02_dp * inv_denom;\n    d_d02_dp += d_d_b1_d_p * d11 * inv_denom;\n    d_d12 += (-d_d_b1_d_p * d01_dp * inv_denom);\n    d_d01_dp += (-d_d_b1_d_p * d12 * inv_denom);\n    d_inv_denom += d_d_b1_d_p * (d11 * d02_dp - d12 * d01_dp);\n    // inv_denom = 1 / (d11 * d22 - d12 * d12)\n    d_d11 += d_inv_denom * (-square(inv_denom) * d22);\n    d_d22 += d_inv_denom * (-square(inv_denom) * d11);\n    d_d12 += d_inv_denom * (2 * square(inv_denom) * d12);\n    // ignore d_e0_dp\n    // d02_dp = dot(e0_dp, e2)\n    auto d_e2 = d_d02_dp * e0_dp;\n    // d01_dp = dot(e0_dp, e1)\n    auto d_e1 = d_d01_dp * e0_dp;\n    // d11 = dot(e1, e1)\n    d_e1 += 2 * d_d11 * e1;\n    // d12 = dot(e1, e2)\n    d_e1 += d_d12 * e2;\n    d_e2 += d_d12 * e1;\n    // d22 = dot(e2, e2)\n    d_e2 += 2 * d_d22 * e2;\n    // e1 = p1 - p0\n    d_p1 += d_e1;\n    d_p0 -= d_e1;\n    // e2 = p2 - p0\n    d_p2 += d_e2;\n    d_p0 -= d_e2;\n}\n\nDEVICE\ninline SurfacePoint intersect_shape(const Shape &shape,\n                                    int index,\n                                    const Ray &ray,\n                                    const RayDifferential &ray_differential,\n                                    RayDifferential &new_ray_differential) {\n    auto ind = get_indices(shape, index);\n    auto v0 = Vector3{get_vertex(shape, ind[0])};\n    auto v1 = Vector3{get_vertex(shape, ind[1])};\n    auto v2 = Vector3{get_vertex(shape, ind[2])};\n    Vector2 uvs0, uvs1, uvs2;\n    if (has_uvs(shape)) {\n        uvs0 = get_uv(shape, ind[0]);\n        uvs1 = get_uv(shape, ind[1]);\n        uvs2 = get_uv(shape, ind[2]);\n    } else {\n        uvs0 = Vector2{0.f, 0.f};\n        uvs1 = Vector2{1.f, 0.f};\n        uvs2 = Vector2{1.f, 1.f};\n    }\n    auto u_dxy = Vector2{0, 0};\n    auto v_dxy = Vector2{0, 0};\n    auto t_dxy = Vector2{0, 0};\n    auto uvt = intersect(v0, v1, v2, ray, ray_differential, u_dxy, v_dxy, t_dxy);\n    auto u = uvt[0];\n    auto v = uvt[1];\n    auto w = 1.f - (u + v);\n    auto t = uvt[2];\n    auto uv = w * uvs0 + u * uvs1 + v * uvs2;\n    auto hit_pos = ray.org + ray.dir * t;\n    auto geom_normal = normalize(cross(v1 - v0, v2 - v0));\n\n    // Surface derivative for ray differentials\n    auto du_dxy = (- u_dxy - v_dxy) * uvs0[0] + u_dxy * uvs1[0] + v_dxy * uvs2[0];\n    auto dv_dxy = (- u_dxy - v_dxy) * uvs0[1] + u_dxy * uvs1[1] + v_dxy * uvs2[1];\n    auto dpdx = ray_differential.org_dx + ray.dir * t_dxy.x + ray_differential.dir_dx * t;\n    auto dpdy = ray_differential.org_dy + ray.dir * t_dxy.y + ray_differential.dir_dy * t;\n    auto shading_normal = geom_normal;\n    auto dn_dx = Vector3{0, 0, 0};\n    auto dn_dy = Vector3{0, 0, 0};\n    if (has_shading_normals(shape)) {\n        auto n0 = get_shading_normal(shape, ind[0]);\n        auto n1 = get_shading_normal(shape, ind[1]);\n        auto n2 = get_shading_normal(shape, ind[2]);\n\n        auto nn = w * n0 + u * n1 + v * n2;\n\n        // Compute dndx & dndy\n        auto dnn_dx = (- u_dxy.x - v_dxy.x) * n0 + u_dxy.x * n1 + v_dxy.x * n2;\n        auto dnn_dy = (- u_dxy.y - v_dxy.y) * n0 + u_dxy.y * n1 + v_dxy.y * n2;\n        // normalization derivatives\n        auto nn_len_sq = dot(nn, nn);\n        auto nn_len = sqrt(nn_len_sq);\n        dn_dx = (nn_len_sq * dnn_dx - dot(nn, dnn_dx) * nn) / (nn_len_sq * nn_len);\n        dn_dy = (nn_len_sq * dnn_dy - dot(nn, dnn_dy) * nn) / (nn_len_sq * nn_len);\n\n        // Shading normal computation\n        shading_normal = normalize(nn);\n        // Flip geometric normal to the same side of shading normal\n        if (dot(geom_normal, shading_normal) < 0.f) {\n            geom_normal = -geom_normal;\n        }\n    }\n    // Update ray differential\n    new_ray_differential.org_dx = dpdx;\n    new_ray_differential.org_dy = dpdy;\n    new_ray_differential.dir_dx = ray_differential.dir_dx;\n    new_ray_differential.dir_dy = ray_differential.dir_dy;\n    return SurfacePoint{hit_pos, geom_normal, Frame(shading_normal), uv,\n        du_dxy, dv_dxy, dn_dx, dn_dy};\n}\n\nDEVICE\ninline void d_intersect_shape(\n        const Shape &shape,\n        int index,\n        const Ray &ray,\n        const RayDifferential &ray_differential,\n        const SurfacePoint &d_point,\n        const RayDifferential &d_new_ray_differential,\n        DRay &d_ray,\n        RayDifferential &d_ray_differential,\n        DVertex *d_vertices) {\n    auto ind = get_indices(shape, index);\n    auto v0 = Vector3{get_vertex(shape, ind[0])};\n    auto v1 = Vector3{get_vertex(shape, ind[1])};\n    auto v2 = Vector3{get_vertex(shape, ind[2])};\n    Vector2 uvs0, uvs1, uvs2;\n    if (has_uvs(shape)) {\n        uvs0 = get_uv(shape, ind[0]);\n        uvs1 = get_uv(shape, ind[1]);\n        uvs2 = get_uv(shape, ind[2]);\n    } else {\n        uvs0 = Vector2{0.f, 0.f};\n        uvs1 = Vector2{1.f, 0.f};\n        uvs2 = Vector2{1.f, 1.f};\n    }\n    auto u_dxy = Vector2{0, 0};\n    auto v_dxy = Vector2{0, 0};\n    auto t_dxy = Vector2{0, 0};\n    auto uvt = intersect(v0, v1, v2, ray, ray_differential, u_dxy, v_dxy, t_dxy);\n    auto u = uvt[0];\n    auto v = uvt[1];\n    auto w = 1.f - (u + v);\n    auto t = uvt[2];\n    // uv = w * uvs0 + u * uvs1 + v * uvs2\n    // hit_pos = ray.org + ray.dir * t\n    auto unnormalized_geom_normal = cross(v1 - v0, v2 - v0);\n    auto geom_normal = normalize(unnormalized_geom_normal);\n\n    // Surface derivative for ray differentials\n    // du_dxy = (- u_dxy - v_dxy) * uvs0[0] + u_dxy * uvs1[0] + v_dxy * uvs2[0]\n    // dv_dxy = (- u_dxy - v_dxy) * uvs0[1] + u_dxy * uvs1[1] + v_dxy * uvs2[1]\n    // dpdx = ray_differential.org_dx + ray.dir * t_dxy.x + ray_differential.dir_dx * t\n    // dpdy = ray_differential.org_dy + ray.dir * t_dxy.y + ray_differential.dir_dy * t\n\n    auto shading_normal = geom_normal;\n    auto geom_normal_flipped = false;\n    auto dn_dx = Vector3{0, 0, 0};\n    auto dn_dy = Vector3{0, 0, 0};\n    if (has_shading_normals(shape)) {\n        auto n0 = get_shading_normal(shape, ind[0]);\n        auto n1 = get_shading_normal(shape, ind[1]);\n        auto n2 = get_shading_normal(shape, ind[2]);\n        auto nn = w * n0 + u * n1 + v * n2;\n\n        // Compute dndx & dndy\n        auto dnn_dx = (- u_dxy.x - v_dxy.x) * n0 + u_dxy.x * n1 + v_dxy.x * n2;\n        auto dnn_dy = (- u_dxy.y - v_dxy.y) * n0 + u_dxy.y * n1 + v_dxy.y * n2;\n        // normalization derivatives\n        auto nn_len_sq = dot(nn, nn);\n        auto nn_len = sqrt(nn_len_sq);\n        dn_dx = (nn_len_sq * dnn_dx - dot(nn, dnn_dx) * nn) / (nn_len_sq * nn_len);\n        dn_dy = (nn_len_sq * dnn_dy - dot(nn, dnn_dy) * nn) / (nn_len_sq * nn_len);\n\n        // Shading normal computation\n        shading_normal = normalize(nn);\n        // Flip geometric normal to the same side of shading normal\n        if (dot(geom_normal, shading_normal) < 0.f) {\n            geom_normal = -geom_normal;\n            geom_normal_flipped = true;\n        }\n    }\n    // point = SurfacePoint{hit_pos, geom_normal, Frame(shading_normal), uv,\n    //     du_dxy, dv_dxy, dn_dx, dn_dy}\n\n    // Backprop\n    auto d_geom_normal = d_point.geom_normal;\n    // new_ray_differential.org_dx = dpdx;\n    // new_ray_differential.org_dy = dpdy;\n    // new_ray_differential.dir_dx = dir_dx;\n    // new_ray_differential.dir_dy = dir_dy;\n    auto d_dpdx = d_new_ray_differential.org_dx;\n    auto d_dpdy = d_new_ray_differential.org_dy;\n    d_ray_differential.dir_dx += d_new_ray_differential.dir_dx;\n    d_ray_differential.dir_dy += d_new_ray_differential.dir_dy;\n    auto d_u = Real(0), d_v = Real(0), d_w = Real(0);\n    auto d_u_dxy = Vector2{0, 0};\n    auto d_v_dxy = Vector2{0, 0};\n    if (has_shading_normals(shape)) {\n        if (geom_normal_flipped) {\n            d_geom_normal = -d_geom_normal;\n        }\n        auto n0 = get_shading_normal(shape, ind[0]);\n        auto n1 = get_shading_normal(shape, ind[1]);\n        auto n2 = get_shading_normal(shape, ind[2]);\n        auto d_shading_normal = d_point.shading_frame[2];\n        // differentiate through frame construction\n        d_coordinate_system(shading_normal, d_point.shading_frame[0], d_point.shading_frame[1],\n                            d_shading_normal);\n\n        auto nn = w * n0 + u * n1 + v * n2;\n\n        auto dnn_dx = (- u_dxy.x - v_dxy.x) * n0 + u_dxy.x * n1 + v_dxy.x * n2;\n        auto dnn_dy = (- u_dxy.y - v_dxy.y) * n0 + u_dxy.y * n1 + v_dxy.y * n2;\n        // normalization derivatives\n        auto nn_len_sq = dot(nn, nn);\n        auto nn_len = sqrt(nn_len_sq);\n        // dn_dx = (nn_len_sq * dnn_dx - dot(nn, dnn_dx) * nn) / (nn_len_sq * nn_len)\n        // dn_dy = (nn_len_sq * dnn_dy - dot(nn, dnn_dy) * nn) / (nn_len_sq * nn_len)\n\n        // shading_normal = normalize(nn)\n        auto d_nn = d_normalize(nn, d_shading_normal);\n\n        // dn_dx = (nn_len_sq * dnn_dx - dot(nn, dnn_dx) * nn) / nn_denom\n        // dn_dy = (nn_len_sq * dnn_dy - dot(nn, dnn_dy) * nn) / nn_denom\n        auto nn_denom = (nn_len_sq * nn_len);\n        auto d_dn_dx = d_point.dn_dx;\n        auto d_dn_dy = d_point.dn_dy;\n        auto d_nn_len_sq = (d_dn_dx * dnn_dx + d_dn_dy * dnn_dy) / nn_denom;\n        auto d_dnn_dx = d_dn_dx * nn_len_sq / nn_denom;\n        auto d_dnn_dy = d_dn_dy * nn_len_sq / nn_denom;\n        auto d_dot_nn_dnn_dx = sum(d_dn_dx * nn) / nn_denom;\n        auto d_dot_nn_dnn_dy = sum(d_dn_dy * nn) / nn_denom;\n        d_nn += (d_dn_dx * dot(nn, dnn_dx) + d_dn_dy * dot(nn, dnn_dy)) / nn_denom;\n        auto d_nn_denom = (d_dn_dx * (-dn_dx) + d_dn_dy * (-dn_dy)) / nn_denom;\n        // dot(nn, dnn_dx) & dot(nn, dnn_dy)\n        d_nn += d_dot_nn_dnn_dx * dnn_dx + d_dot_nn_dnn_dy * dnn_dy;\n        d_dnn_dx += d_dot_nn_dnn_dx * nn;\n        d_dnn_dy += d_dot_nn_dnn_dy * nn;\n\n        // nn_denom = pow(nn_len_sq, Real(3.0/2.0))\n        d_nn_len_sq += d_nn_denom * nn_len * Real(3.0 / 2.0);\n        // nn_len_sq = dot(nn, nn)\n        d_nn += 2 * d_nn_len_sq * nn;\n\n        // dnn_dx = (- u_dxy.x - v_dxy.x) * n0 + u_dxy.x * n1 + v_dxy.x * n2\n        // dnn_dy = (- u_dxy.y - v_dxy.y) * n0 + u_dxy.y * n1 + v_dxy.y * n2\n        d_u_dxy.x += sum(d_dnn_dx * (n1 - n0));\n        d_u_dxy.y += sum(d_dnn_dy * (n1 - n0));\n        d_v_dxy.x += sum(d_dnn_dx * (n2 - n0));\n        d_v_dxy.y += sum(d_dnn_dy * (n2 - n0));\n        auto d_n0 = d_dnn_dx * (- u_dxy.x - v_dxy.x) +\n                    d_dnn_dy * (- u_dxy.y - v_dxy.y);\n        auto d_n1 = d_dnn_dx * u_dxy.x + d_dnn_dy * u_dxy.y;\n        auto d_n2 = d_dnn_dx * v_dxy.x + d_dnn_dy * v_dxy.y;\n\n        // nn = w * n0 + u * n1 + v * n2\n        d_w += sum(d_nn * n0);\n        d_u += sum(d_nn * n1);\n        d_v += sum(d_nn * n2);\n        d_n0 += d_nn * w;\n        d_n1 += d_nn * u;\n        d_n2 += d_nn * v;\n        d_vertices[0].d_n += d_n0;\n        d_vertices[1].d_n += d_n1;\n        d_vertices[2].d_n += d_n2;\n    } else {\n        d_geom_normal += d_point.shading_frame[2];\n        d_coordinate_system(shading_normal, d_point.shading_frame[0], d_point.shading_frame[1],\n                            d_geom_normal);\n    }\n\n    // dpdx = ray_differential.org_dx + ray.dir * t_dxy.x + ray_differential.dir_dx * t\n    // dpdy = ray_differential.org_dy + ray.dir * t_dxy.y + ray_differential.dir_dy * t\n    auto d_t_dxy = Vector2{0, 0};\n    d_ray_differential.org_dx += d_dpdx;\n    d_ray.dir += d_dpdx * t_dxy.x;\n    d_t_dxy.x += sum(d_dpdx * ray.dir);\n    d_ray_differential.dir_dx += d_dpdx * t;\n    auto d_t = sum(d_dpdx * ray_differential.dir_dx);\n    d_ray_differential.org_dy += d_dpdy;\n    d_ray.dir += d_dpdy * t_dxy.y;\n    d_t_dxy.y += sum(d_dpdy * ray.dir);\n    d_ray_differential.dir_dy += d_dpdy * t;\n    d_t += sum(d_dpdy * ray_differential.dir_dy);\n\n    // du_dxy = (- u_dxy - v_dxy) * uvs0[0] + u_dxy * uvs1[0] + v_dxy * uvs2[0]\n    // dv_dxy = (- u_dxy - v_dxy) * uvs0[1] + u_dxy * uvs1[1] + v_dxy * uvs2[1]\n    auto d_uvs0 = Vector2{0, 0};\n    auto d_uvs1 = Vector2{0, 0};\n    auto d_uvs2 = Vector2{0, 0};\n    auto d_du_dxy = d_point.du_dxy;\n    auto d_dv_dxy = d_point.dv_dxy;\n    d_u_dxy += d_du_dxy * (uvs1[0] - uvs0[0]) + d_dv_dxy * (uvs1[1] - uvs0[1]);\n    d_v_dxy += d_du_dxy * (uvs2[0] - uvs0[0]) + d_dv_dxy * (uvs2[1] - uvs0[1]);\n    d_uvs0[0] += sum(d_du_dxy * (- u_dxy - v_dxy));\n    d_uvs0[1] += sum(d_dv_dxy * (- u_dxy - v_dxy));\n    d_uvs1[0] += sum(d_du_dxy * u_dxy);\n    d_uvs1[1] += sum(d_dv_dxy * u_dxy);\n    d_uvs2[0] += sum(d_du_dxy * v_dxy);\n    d_uvs2[1] += sum(d_dv_dxy * v_dxy);\n\n    // geom_normal = normalize(unnormalized_geom_normal)\n    auto d_unnormalized_geom_normal = d_normalize(unnormalized_geom_normal, d_geom_normal);\n    // unnormalized_geom_normal = cross(v1 - v0, v2 - v0)\n    auto d_v1_v0 = Vector3{0, 0, 0};\n    auto d_v2_v0 = Vector3{0, 0, 0};\n    d_cross(v1 - v0, v2 - v0, d_unnormalized_geom_normal, d_v1_v0, d_v2_v0);\n    auto d_v0 = (- d_v1_v0 - d_v2_v0);\n    auto d_v1 = d_v1_v0;\n    auto d_v2 = d_v2_v0;\n    // hit_pos = ray.org + ray.dir * t\n    auto d_hit_pos = d_point.position;\n    d_ray.org += d_hit_pos;\n    d_ray.dir += d_hit_pos * t;\n    d_t += sum(d_hit_pos * ray.dir);\n    // uv = w * uvs0 + u * uvs1 + v * uvs2\n    auto d_uv = d_point.uv;\n    d_w += sum(d_uv * uvs0);\n    d_u += sum(d_uv * uvs1);\n    d_v += sum(d_uv * uvs2);\n    d_uvs0 += d_uv * w;\n    d_uvs1 += d_uv * u;\n    d_uvs2 += d_uv * v;\n    // auto t = uvt[2];\n    auto d_uvt = Vector3{0, 0, 0};\n    d_uvt[2] += d_t;\n    // w = 1.f - (u + v)\n    d_u -= d_w;\n    d_v -= d_w;\n    // u = uvt[0]\n    // v = uvt[1]\n    d_uvt[0] += d_u;\n    d_uvt[1] += d_v;\n    // uvt = intersect(v0, v1, v2, ray, ray_differential, u_dxy, v_dxy, t_dxy)\n    d_intersect(v0, v1, v2, ray, ray_differential,\n        d_uvt, d_u_dxy, d_v_dxy, d_t_dxy, d_v0, d_v1, d_v2, d_ray, d_ray_differential);\n    if (has_uvs(shape)) {\n        d_vertices[0].d_uv += d_uvs0;\n        d_vertices[1].d_uv += d_uvs1;\n        d_vertices[2].d_uv += d_uvs2;\n    }\n    d_vertices[0].d_v += d_v0;\n    d_vertices[1].d_v += d_v1;\n    d_vertices[2].d_v += d_v2;\n}\n\nvoid accumulate_vertex(const BufferView<DVertex> &d_vertices,\n                       BufferView<DShape> shapes,\n                       bool use_gpu);\n\nvoid test_d_intersect();\nvoid test_d_sample_shape();\n\n", "comment_ratio": 0.13846153846153847}
{"lang": "c", "code": "#ifndef DEF_EBON_HOLD_H\n#define DEF_EBON_HOLD_H\n\nenum\n{\n    TYPE_BATTLE                         = 0,\n    TYPE_GOTHIK_YELL                    = 1,\n    TYPE_DO_ACTION                      = 2,\n    // also 3 worldstates, above 3500\n\n    DATA_ACTION_ENABLE_TRAPS            = 0,\n    DATA_ACTION_MOVE                    = 1,\n    DATA_ACTION_DESPAWN                 = 2,\n\n    // npcs\n    // death knights\n    NPC_HIGHLORD_DARION_MOGRAINE        = 29173,\n    NPC_KOLTIRA_DEATHWEAVER             = 29199,\n    NPC_ORBAZ_BLOODBANE                 = 29204,\n    NPC_THASSARIAN                      = 29200,\n\n    // scourge warriors - summond during the event\n    NPC_FLESH_BEHEMOTH                  = 29190,\n    NPC_RAMPAGING_ABOMINATION           = 29186,\n    NPC_VOLATILE_GHOUL                  = 29219,\n    NPC_WARRIOR_OF_THE_FROZEN_WASTES    = 29206,\n\n    // argent dawn commanders\n    NPC_HIGHLORD_TIRION_FORDRING        = 29175,\n    NPC_KORFAX_CHAMPION_OF_THE_LIGHT    = 29176,\n    NPC_LORD_MAXWELL_TYROSUS            = 29178,\n    NPC_COMMANDER_ELIGOR_DAWNBRINGER    = 29177,\n    NPC_LEONID_BARTHALOMEW_THE_REVERED  = 29179,\n    NPC_DUKE_NICHOLAS_ZVERENHOFF        = 29180,\n    NPC_RIMBLAT_EARTHSHATTER            = 29182,\n    NPC_RAYNE                           = 29181,\n\n    // argent warriors\n    NPC_DEFENDER_OF_THE_LIGHT           = 29174,\n\n    // cinematic\n    NPC_THE_LICH_KING                   = 29183,\n    NPC_HIGHLORD_ALEXANDROS_MOGRAINE    = 29227,\n    NPC_DARION_MOGRAINE                 = 29228,\n\n    // object\n    GO_LIGHT_OF_DAWN                    = 191330,\n    GO_HOLY_LIGHTNING_1                 = 191301,\n    GO_HOLY_LIGHTNING_2                 = 191302,\n\n    // spells\n    SPELL_CHAPTER_IV                    = 53405,            // phase aura\n\n    // variables\n    MAX_LIGHT_CHAMPIONS                 = 7,                // the number of the light champions\n    MAX_WARRIORS_SUMMONED_PER_TURN      = 5,                // summoned warriors (light and death) per turn\n    MAX_LIGHT_GUARDS                    = 4,                // guards summond for the outro\n\n    // event variables\n    MAX_BATTLE_INTRO_TIMER              = 5,\n    MAX_FORCES_LIGHT                    = 300,\n    MAX_FORCES_SCOURGE                  = 10000,\n\n    // world states\n    // basically world states should be shown to all players with phase mask = 128 as stated in DBC\n    // because we don't have the possibility to do that we'll just iterate through the players and set the phase mask manually based on the battle status\n    WORLD_STATE_FORCES_SHOW             = 3592,             // show the remaining units\n    WORLD_STATE_FORCES_SCOURGE          = 3591,\n    WORLD_STATE_FORCES_LIGHT            = 3590,\n    WORLD_STATE_BATTLE_TIMER_SHOW       = 3603,             // countdown timer\n    WORLD_STATE_BATTLE_TIMER_TIME       = 3604,\n    WORLD_STATE_BATTLE_BEGIN            = 3605,             // battle has begun\n};\n\nstruct sSpawnLocation\n{\n    float m_fX, m_fY, m_fZ, m_fO;\n    uint32 m_uiEntry;\n};\n\n// light champions\nstatic sSpawnLocation aLightArmySpawnLoc[MAX_LIGHT_CHAMPIONS] =\n{\n    {2285.80f, -5308.82f, 87.04f, 1.67f, NPC_KORFAX_CHAMPION_OF_THE_LIGHT},\n    {2276.96f, -5309.36f, 86.66f, 1.61f, NPC_LORD_MAXWELL_TYROSUS},\n    {2279.82f, -5322.61f, 88.95f, 1.54f, NPC_LEONID_BARTHALOMEW_THE_REVERED},\n    {2287.96f, -5313.96f, 88.27f, 1.63f, NPC_DUKE_NICHOLAS_ZVERENHOFF},\n    {2276.84f, -5313.78f, 87.62f, 1.61f, NPC_COMMANDER_ELIGOR_DAWNBRINGER},\n    {2275.80f, -5322.51f, 88.62f, 1.68f, NPC_RAYNE},\n    {2282.47f, -5319.84f, 88.83f, 1.74f, NPC_RIMBLAT_EARTHSHATTER}\n};\n\n// Tirion is spawned at the edge of the battle and runs toward the chapel\n// When he reach the chapel he cast some powerfull light spell and the battle ends\nstatic sSpawnLocation aEventLocations[] =\n{\n    {2165.711f, -5266.124f, 95.50f, 0.13f, 0},       // 0 Tirion spawn location\n    {2281.390f, -5299.98f,  85.07f, 1.61f, 0},       // 1 Tirion move location\n    {2289.259f, -5280.350f, 82.11f, 0.0f,  0},       // 2 Koltira chapel loc\n    {2273.289f, -5273.675f, 81.70f, 0.0f,  0},       // 3 Thassarian chapel loc\n    {2280.159f, -5263.561f, 81.15f, 4.70f, 0},       // 4 Alexandros summon location\n    {2279.927f, -5265.84f,  81.39f, 0.0f,  0},       // 5 Alexandros move loc\n    {2280.538f, -5280.103f, 82.41f, 1.60f, 0},       // 6 Young Darion spawn\n    {2279.895f, -5269.334f, 81.73f, 0.0f,  0},       // 7 Young Darion move\n    {2280.304f, -5257.205f, 80.09f, 4.62f, 0},       // 8 Lich King spawn\n    {2281.523f, -5261.058f, 80.87f, 0.0f,  0},       // 9 Lich King move\n    {2273.071f, -5293.428f, 83.06f, 0.0f,  0},       // 10 Tirion final point\n};\n\n#endif\n\n", "comment_ratio": 0.3130434782608696}
{"lang": "c", "code": "#include \"../../../nvdla_cmod/csc/NV_NVDLA_csc.h\"\n#include \"../../../nvdla_cmod/include/log.h\"\n#define __STDC_FORMAT_MACROS\n#include <inttypes.h>\n\nUSING_SCSIM_NAMESPACE(cmod)\nUSING_SCSIM_NAMESPACE(clib)\n\ninline void\nNV_NVDLA_csc::csb2csc_req_b_transport (int ID, NV_MSDEC_csb2xx_16m_secure_be_lvl_t* payload, sc_time& delay) {\n    uint32_t addr;\n    uint32_t data;\n    uint8_t write;\n    uint8_t nposted;\n    uint8_t error_id=0;\n    bool    register_access_result;\n    if (true == is_there_ongoing_csb2csc_response_) {\n#pragma CTC SKIP\n        FAIL((\"NVDLA NV_NVDLA_csc::csb2csc_b_transport: there is onging CSB response.\"));\n#pragma CTC ENDSKIP\n    } else {\n        is_there_ongoing_csb2csc_response_ = true;\n    }\n    // Extract CSB request information from payload\n    if (NULL != payload) {\n        addr = payload->pd.csb2xx_16m_secure_be_lvl.addr;\n        data = payload->pd.csb2xx_16m_secure_be_lvl.wdat;\n        write = payload->pd.csb2xx_16m_secure_be_lvl.write;\n        nposted = payload->pd.csb2xx_16m_secure_be_lvl.nposted;\n    } else {\n#pragma CTC SKIP\n        FAIL((\"NVDLA NV_NVDLA_csc::csb2csc_b_transport: payload pointer shall not be NULL\"));\n#pragma CTC ENDSKIP\n    }\n    // Accessing registers\n    register_access_result = CscAccessRegister (addr, data, 0!=write);\n    if (false == register_access_result) {\n        error_id = 1;\n    }\n    // Read and nposted write need to send response data\n    if ( (0==write) || (0!=nposted) ) {\n        // Read     or  is non-posted\n        CscSendCsbResponse(write, data, error_id);\n    }\n    is_there_ongoing_csb2csc_response_ = false;\n}\n\ninline void\nNV_NVDLA_csc::CscSendCsbResponse(uint8_t type, uint32_t data, uint8_t error_id) {\n    nvdla_xx2csb_resp_t payload;\n    if (0==type) {\n        // Read return data\n        payload.pd.xx2csb_rd_erpt.error   = error_id;\n        payload.pd.xx2csb_rd_erpt.rdat    = data;\n\t\tpayload.tag =  XX2CSB_RESP_TAG_READ;\n    } else {\n        // Write return data\n        payload.pd.xx2csb_wr_erpt.error   = error_id;\n        payload.pd.xx2csb_wr_erpt.rdat    = 0;\n\t\tpayload.tag =  XX2CSB_RESP_TAG_WRITE;\n    }\n    NV_NVDLA_csc_base::csc2csb_resp_b_transport(&payload, b_transport_delay_);\n}\n\n", "comment_ratio": 0.1891891891891892}
{"lang": "c", "code": "#include \"DFT32.h\"\n\n#ifndef CCEMBEDDED\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\nstatic float * goutbins;\n#endif\n\nuint16_t embeddedbins32[FIXBINS]; \n\n//NOTES to self:\n//\n// Let's say we want to try this on an AVR.\n//  24 bins, 5 octaves = 120 bins.\n// 20 MHz clock / 4.8k sps = 4096 IPS = 34 clocks per bin = :(\n//  We can do two at the same time, this frees us up some \n\nstatic uint8_t Sdonefirstrun;\n\n//A table of precomputed sin() values.  Ranging -1500 to +1500\n//If we increase this, it may cause overflows elsewhere in code.\nconst int16_t Ssinonlytable[256] = {\n             0,    36,    73,   110,   147,   183,   220,   256,\n           292,   328,   364,   400,   435,   470,   505,   539,\n           574,   607,   641,   674,   707,   739,   771,   802,\n           833,   863,   893,   922,   951,   979,  1007,  1034,\n          1060,  1086,  1111,  1135,  1159,  1182,  1204,  1226,\n          1247,  1267,  1286,  1305,  1322,  1339,  1355,  1371,\n          1385,  1399,  1412,  1424,  1435,  1445,  1455,  1463,\n          1471,  1477,  1483,  1488,  1492,  1495,  1498,  1499,\n          1500,  1499,  1498,  1495,  1492,  1488,  1483,  1477,\n          1471,  1463,  1455,  1445,  1435,  1424,  1412,  1399,\n          1385,  1371,  1356,  1339,  1322,  1305,  1286,  1267,\n          1247,  1226,  1204,  1182,  1159,  1135,  1111,  1086,\n          1060,  1034,  1007,   979,   951,   922,   893,   863,\n           833,   802,   771,   739,   707,   674,   641,   607,\n           574,   539,   505,   470,   435,   400,   364,   328,\n           292,   256,   220,   183,   147,   110,    73,    36,\n             0,   -36,   -73,  -110,  -146,  -183,  -219,  -256,\n          -292,  -328,  -364,  -399,  -435,  -470,  -505,  -539,\n          -573,  -607,  -641,  -674,  -706,  -739,  -771,  -802,\n          -833,  -863,  -893,  -922,  -951,  -979, -1007, -1034,\n         -1060, -1086, -1111, -1135, -1159, -1182, -1204, -1226,\n         -1247, -1267, -1286, -1305, -1322, -1339, -1355, -1371,\n         -1385, -1399, -1412, -1424, -1435, -1445, -1454, -1463,\n         -1471, -1477, -1483, -1488, -1492, -1495, -1498, -1499,\n         -1500, -1499, -1498, -1495, -1492, -1488, -1483, -1477,\n         -1471, -1463, -1455, -1445, -1435, -1424, -1412, -1399,\n         -1385, -1371, -1356, -1339, -1322, -1305, -1286, -1267,\n         -1247, -1226, -1204, -1182, -1159, -1135, -1111, -1086,\n         -1060, -1034, -1007,  -979,  -951,  -923,  -893,  -863,\n          -833,  -802,  -771,  -739,  -707,  -674,  -641,  -608,\n          -574,  -540,  -505,  -470,  -435,  -400,  -364,  -328,\n          -292,  -256,  -220,  -183,  -147,  -110,   -73,   -37,};\n\n\n/** The above table was created using the following code:\n#include <math.h>\n#include <stdio.h>\n#include <stdint.h>\n\nint16_t Ssintable[256]; //Actually, just [sin].\n\nint main()\n{\n\tint i;\n\tfor( i = 0; i < 256; i++ )\n\t{\n\t\tSsintable[i] = (int16_t)((sinf( i / 256.0 * 6.283 ) * 1500.0));\n\t}\n\n\tprintf( \"const int16_t Ssinonlytable[256] = {\" );\n\tfor( i = 0; i < 256; i++ )\n\t{\n\t\tif( !(i & 0x7 ) )\n\t\t{\n\t\t\tprintf( \"\\n\\t\" );\n\t\t}\n\t\tprintf( \"%6d,\" ,Ssintable[i] );\n\t}\n\tprintf( \"};\\n\" );\n} */\n\n\n\nuint16_t Sdatspace32A[FIXBINS*2];  //(advances,places)\nint32_t Sdatspace32B[FIXBINS*2];  //(isses,icses)\n\n//This is updated every time the DFT hits the octavecount, or 1/32 updates.\nint32_t Sdatspace32BOut[FIXBINS*2];  //(isses,icses)\n\n//Sdo_this_octave is a scheduling state for the running SIN/COS states for\n//each bin.  We have to execute the highest octave every time, however, we can\n//get away with updating the next octave down every-other-time, then the next\n//one down yet, every-other-time from that one.  That way, no matter how many\n//octaves we have, we only need to update FIXBPERO*2 DFT bins.\nstatic uint8_t Sdo_this_octave[BINCYCLE];\n\nstatic int32_t Saccum_octavebins[OCTAVES];\nstatic uint8_t Swhichoctaveplace;\n\n//\nuint16_t embeddedbins[FIXBINS]; \n\n//From: http://stackoverflow.com/questions/1100090/looking-for-an-efficient-integer-square-root-algorithm-for-arm-thumb2\n/**\n * \\brief    Fast Square root algorithm, with rounding\n *\n * This does arithmetic rounding of the result. That is, if the real answer\n * would have a fractional part of 0.5 or greater, the result is rounded up to\n * the next integer.\n *      - SquareRootRounded(2) --> 1\n *      - SquareRootRounded(3) --> 2\n *      - SquareRootRounded(4) --> 2\n *      - SquareRootRounded(6) --> 2\n *      - SquareRootRounded(7) --> 3\n *      - SquareRootRounded(8) --> 3\n *      - SquareRootRounded(9) --> 3\n *\n * \\param[in] a_nInput - unsigned integer for which to find the square root\n *\n * \\return Integer square root of the input value.\n */\nstatic uint16_t SquareRootRounded(uint32_t a_nInput)\n{\n    uint32_t op  = a_nInput;\n    uint32_t res = 0;\n    uint32_t one = 1uL << 30; // The second-to-top bit is set: use 1u << 14 for uint16_t type; use 1uL<<30 for uint32_t type\n\n\n    // \"one\" starts at the highest power of four <= than the argument.\n    while (one > op)\n    {\n        one >>= 2;\n    }\n\n    while (one != 0)\n    {\n        if (op >= res + one)\n        {\n            op = op - (res + one);\n            res = res +  2 * one;\n        }\n        res >>= 1;\n        one >>= 2;\n    }\n\n    /* Do arithmetic rounding to nearest integer */\n    if (op > res)\n    {\n        res++;\n    }\n\n    return res;\n}\n\nvoid UpdateOutputBins32()\n{\n\tint i;\n\tint32_t * ipt = &Sdatspace32BOut[0];\n\tfor( i = 0; i < FIXBINS; i++ )\n\t{\n\t\tint16_t isps = *(ipt++)>>16;\n\t\tint16_t ispc = *(ipt++)>>16;\n\n\t\tint octave = i / FIXBPERO;\n\n\t\t//If we are running DFT32 on regular ColorChord, then we will need to\n\t\t//also update goutbins[]... But if we're on embedded systems, we only\n\t\t//update embeddedbins32.\n#ifndef CCEMBEDDED\n\t\tuint32_t mux = ( (isps) * (isps)) + ((ispc) * (ispc));\n\t\tgoutbins[i] = sqrtf( (float)mux );\n\t\t//reasonable (but arbitrary amplification)\n\t\tgoutbins[i] /= (78<<DFTIIR)*(1<<octave); \n#endif\n\n\t\tuint32_t rmux = ( (isps) * (isps)) + ((ispc) * (ispc));\n\n\t\t//bump up all outputs here, so when we nerf it by bit shifting by\n\t\t//ctave we don't lose a lot of detail.\n\t\trmux = SquareRootRounded( rmux ) << 1; \n\n\t\tembeddedbins32[i] = rmux >> octave;\n\t}\n}\n\nstatic void HandleInt( int16_t sample )\n{\n\tint i;\n\n\tuint8_t oct = Sdo_this_octave[Swhichoctaveplace];\n\tSwhichoctaveplace ++;\n\tSwhichoctaveplace &= BINCYCLE-1;\n\n\tif( oct > 128 )\n\t{\n\t\t//Special: This is when we can update everything.\n\t\t//This gets run one out of every 1/(1<<OCTAVES) times.\n\t\t//It handles updating part of the DFT.\n\t\tint32_t * bins = &Sdatspace32B[0];\n\t\tint32_t * binsOut = &Sdatspace32BOut[0];\n\n\t\tfor( i = 0; i < FIXBINS; i++ )\n\t\t{\n\t\t\t//First for the SIN then the COS.\n\t\t\tint32_t val = *(bins);\n\t\t\t*(binsOut++) = val;\n\t\t\t*(bins++) -= val>>DFTIIR;\n\n\t\t\tval = *(bins);\n\t\t\t*(binsOut++) = val;\n\t\t\t*(bins++) -= val>>DFTIIR;\n\t\t}\n\t\treturn;\n\t}\n\telse if(oct < OCTAVES)\n\t{\n\t\tfor( i = 0; i < OCTAVES;i++ )\n\t\t{\n\t\t\tSaccum_octavebins[i] += sample;\n\t\t}\n\n\t\tuint16_t * dsA = &Sdatspace32A[oct*FIXBPERO*2];\n\t\tint32_t * dsB = &Sdatspace32B[oct*FIXBPERO*2];\n\n\t\tsample = Saccum_octavebins[oct]>>(OCTAVES-oct);\n\t\tSaccum_octavebins[oct] = 0;\n\n\t\tfor( i = 0; i < FIXBPERO; i++ )\n\t\t{\n\t\t\tuint16_t adv = *(dsA++);\n\t\t\tuint8_t localipl = *(dsA) >> 8;\n\t\t\t*(dsA++) += adv;\n\n\t\t\t*(dsB++) += (Ssinonlytable[localipl] * sample);\n\t\t\t//Get the cosine (1/4 wavelength out-of-phase with sin)\n\t\t\tlocalipl += 64;\n\t\t\t*(dsB++) += (Ssinonlytable[localipl] * sample);\n\t\t}\n\t}\n}\n\nint SetupDFTProgressive32()\n{\n\tint i;\n\tint j;\n\n\tSdonefirstrun = 1;\n\n\tfor( i = 0; i < BINCYCLE; i++ )\n\t{\n\t\t// Sdo_this_octave = \n\t\t// 4 3 4 2 4 3 4 ...\n\t\t//search for \"first\" zero\n\n\t\tfor( j = 0; j <= OCTAVES; j++ )\n\t\t{\n\t\t\tif( ((1<<j) & i) == 0 ) break;\n\t\t}\n\t\tif( j > OCTAVES )\n\t\t{\n#ifndef CCEMBEDDED\n\t\t\tfprintf( stderr, \"Error: algorithm fault.\\n\" );\n\t\t\texit( -1 );\n#endif\n\t\t\treturn -1;\n\t\t}\n\t\tSdo_this_octave[i] = OCTAVES-j-1;\n\t}\n\treturn 0;\n}\n\n\n\nvoid UpdateBins32( const uint16_t * frequencies )\n{\n\tint i;\t\n\tfor( i = 0; i < FIXBINS; i++ )\n\t{\n\t\tuint16_t freq = frequencies[i%FIXBPERO];\n\t\tSdatspace32A[i*2] = freq;// / oneoveroctave;\n\t}\n}\n\nvoid PushSample32( int16_t dat )\n{\n\tHandleInt( dat );\n\tHandleInt( dat );\n}\n\n\n#ifndef CCEMBEDDED\n\n//void UpdateBinsForDFT32( const float * frequencies )\n//{\n//\tint i;\n//\tfor( i = 0; i < FIXBINS; i++ )\n//\t{\n//\t\tfloat freq = frequencies[(i%FIXBPERO) + (FIXBPERO*(OCTAVES-1))];\n//\t\tSdatspace32A[i*2] = (65536.0/freq);// / oneoveroctave;\n//\t}\n//}\n\n#endif\n\n\n#ifndef CCEMBEDDED\n\n//void DoDFTProgressive32( float * outbins, float * frequencies, int bins, const float * databuffer, int place_in_data_buffer, int size_of_data_buffer, float q, float speedup )\n//{\n//\tstatic float backupbins[FIXBINS];\n//\tint i;\n//\tstatic int last_place;\n//\n//\tmemset( outbins, 0, bins * sizeof( float ) );\n//\tgoutbins = outbins;\n//\n//\tmemcpy( outbins, backupbins, FIXBINS*4 );\n//\n//\tif( FIXBINS != bins )\n//\t{\n//\t\tfprintf( stderr, \"Error: Bins was reconfigured.  skippy requires a constant number of bins (%d != %d).\\n\", FIXBINS, bins );\n//\t\treturn;\n//\t}\n//\n//\tif( !Sdonefirstrun )\n//\t{\n//\t\tSetupDFTProgressive32();\n//\t\tSdonefirstrun = 1;\n//\t}\n//\n//\tUpdateBinsForDFT32( frequencies );\n//\n//\tfor( i = last_place; i != place_in_data_buffer; i = (i+1)%size_of_data_buffer )\n//\t{\n//\t\tint16_t ifr1 = (int16_t)( ((databuffer[i]) ) * 4095 );\n//\t\tHandleInt( ifr1 );\n//\t\tHandleInt( ifr1 );\n//\t}\n//\n//\tUpdateOutputBins32();\n//\n//\tlast_place = place_in_data_buffer;\n//\n//\tmemcpy( backupbins, outbins, FIXBINS*4 );\n//}\n\n#endif\n\n\n\n\n\n", "comment_ratio": 0.23743016759776536}
{"lang": "c", "code": "//\n//  AppDelegate.h\n//  Framework-1\n//\n//  Created by Alan on 2021/7/4.\n//\n\n#import <UIKit/UIKit.h>\n\n@interface AppDelegate : UIResponder <UIApplicationDelegate>\n\n@property (strong, nonatomic) UIWindow * window;\n\n@end\n\n\n", "comment_ratio": 0.375}
{"lang": "c", "code": "//\n//  TerrainEditMode.h\n//  SCMap\n//\n//  Created by Zach Zahos on 2016-01-23.\n//\n//\n\n#pragma once\n\n#include \"EditMode.h\"\n\n#include <QString>\n\nclass TerrainEditMode : public EditMode {\npublic:\n\tTerrainEditMode()\n\t\t: EditMode() {}\n\t\n\tQString name()\n\t\t{ return \"Terrain\"; }\n\t\n\tvoid update(Map *map, QPainter &painter, QRect rect);\n\tvoid click(Map *map, QPoint point);\n};\n\n", "comment_ratio": 0.2692307692307692}
{"lang": "c", "code": "#include <core.h>\n#include <libc/stdlib.h>\n#include <libc/string.h>\n#include <kernel/mem/pmap.h>\n#include \"kmem.h\"\n\n// Pointer to the BIOS-generated memory map.\nstatic pmap_t *map         = (pmap_t *)KMEM_TABLE_BIOS;\nstatic bool    initialized = false;\n\n/// Add a memory region to the end of the memory map.\nstatic void\nadd_region(uint64_t addr, uint64_t size, enum pmemtype type)\n{\n    pmapregion_t *r = map->region + map->count;\n    r->addr  = addr;\n    r->size  = size;\n    r->type  = (int32_t)type;\n    r->flags = 0;\n\n    ++map->count;\n}\n\n/// Compare two memory region records and return a sorting integer.\nstatic int\ncmp_region(const void *a, const void *b)\n{\n    const pmapregion_t *r1 = (const pmapregion_t *)a;\n    const pmapregion_t *r2 = (const pmapregion_t *)b;\n    if (r1->addr > r2->addr)\n        return +1;\n    if (r1->addr < r2->addr)\n        return -1;\n    if (r1->size > r2->size)\n        return +1;\n    if (r1->size < r2->size)\n        return -1;\n    return 0;\n}\n\n/// Remove a region from the memory map and shift all subsequent regions\n/// down by one.\nstatic inline void\ncollapse(pmapregion_t *r, pmapregion_t *term)\n{\n    if (r + 1 < term)\n        memmove(r, r + 1, (term - r) * sizeof(pmapregion_t));\n    --map->count;\n}\n\n/// Insert a new, uninitialized memory region record after an existing record\n/// in the memory map.\nstatic inline void\ninsertafter(pmapregion_t *r, pmapregion_t *term)\n{\n    if (r + 1 < term)\n        memmove(r + 2, r + 1, (term - (r + 1)) * sizeof(pmapregion_t));\n    ++map->count;\n}\n\n/// Re-sort all unsorted region records starting from the requested record.\nstatic void\nresort(pmapregion_t *r, pmapregion_t *term)\n{\n    while (r + 1 < term) {\n        if (cmp_region(r, r + 1) < 0)\n            break;\n        pmapregion_t tmp = r[0];\n        r[0] = r[1];\n        r[1] = tmp;\n        r++;\n    }\n}\n\n/// Find all overlapping memory regions in the memory map and collapse or\n/// reorganize them.\nstatic void\ncollapse_overlaps()\n{\n    pmapregion_t *curr = map->region;\n    pmapregion_t *term = map->region + map->count;\n\n    while (curr + 1 < term) {\n\n        // Collapse empty entries.\n        if (curr->size == 0) {\n            collapse(curr, term--);\n            continue;\n        }\n\n        pmapregion_t *next = curr + 1;\n\n        uint64_t cl = curr->addr;\n        uint64_t cr = curr->addr + curr->size;\n        uint64_t nl = next->addr;\n        uint64_t nr = next->addr + next->size;\n\n        // No overlap? Then go to the next region.\n        if (min(cr, nr) <= max(cl, nl)) {\n            curr++;\n            continue;\n        }\n\n        // Handle the 5 alignment cases:\n        //   xxx    xxx    xxxx   xxx    xxxxx\n        //   yyy    yyyy    yyy    yyy    yyy\n        // The remaining cases are impossible due to sorting.\n\n        if (cl == nl) {\n            if (cr == nr) {\n                if (next->type > curr->type) {\n                    // 111  ->  222\n                    // 222\n                    collapse(curr, term--);\n                }\n                else {\n                    // 222  ->  222\n                    // 111\n                    collapse(next, term--);\n                }\n            }\n            else { /* if cr != nr */\n                if (next->type > curr->type) {\n                    // 111  ->  2222\n                    // 2222\n                    collapse(curr, term--);\n                }\n                else {\n                    // 222  ->  222\n                    // 1111 ->     1\n                    next->size = nr - cr;\n                    next->addr = cr;\n                    resort(next, term);\n                }\n            }\n        }\n\n        else { /* if cl != nl */\n            if (cr == nr) {\n                if (next->type > curr->type) {\n                    // 1111  ->  1\n                    //  222  ->   222\n                    curr->size = nl - cl;\n                }\n                else {\n                    // 2222  ->  2222\n                    //  111\n                    collapse(next, term--);\n                }\n            }\n            else if (cr < nr) {\n                if (next->type > curr->type) {\n                    // 1111  ->  1\n                    //  2222 ->   2222\n                    curr->size = nl - cl;\n                }\n                else {\n                    // 2222  ->  2222\n                    //  1111 ->      1\n                    next->size = nr - cr;\n                    next->addr = cr;\n                    resort(next, term);\n                }\n            }\n            else { /* if cr > nr */\n                if (next->type > curr->type) {\n                    // 11111  -> 1\n                    //  222   ->  222\n                    //        ->     1\n                    curr->size = nl - cl;\n                    insertafter(next, term++);\n                    next[1].addr  = nr;\n                    next[1].size  = cr - nr;\n                    next[1].type  = curr->type;\n                    next[1].flags = curr->flags;\n                    resort(next + 1, term);\n                }\n                else {\n                    // 22222  ->  22222\n                    //  111\n                    collapse(next, term--);\n                }\n            }\n        }\n\n    }\n}\n\n/// Find missing memory regions in the map, and fill them with entries of\n/// the requested type.\nstatic void\nfill_gaps(int32_t type)\n{\n    pmapregion_t *curr = map->region;\n    pmapregion_t *term = map->region + map->count;\n\n    while (curr + 1 < term) {\n        pmapregion_t *next = curr + 1;\n\n        uint64_t cr = curr->addr + curr->size;\n        uint64_t nl = next->addr;\n\n        if (cr == nl) {\n            curr++;\n            continue;\n        }\n\n        // Try to expand one of the neighboring entries if one of them has the\n        // same type as the fill type.\n        if (curr->type == type) {\n            curr->size += nl - cr;\n        }\n        else if (next->type == type) {\n            next->size += nl - cr;\n            next->addr  = cr;\n        }\n\n        // Neither neighboring region has the fill type, so insert a new\n        // region record.\n        else {\n            insertafter(curr, term++);\n            next->addr  = cr;\n            next->size  = nl - cr;\n            next->type  = type;\n            next->flags = 0;\n        }\n    }\n}\n\n/// Find adjacent memory entries of the same type and merge them.\nstatic void\nconsolidate_neighbors()\n{\n    pmapregion_t *curr = map->region;\n    pmapregion_t *term = map->region + map->count;\n\n    while (curr + 1 < term) {\n        pmapregion_t *next = curr + 1;\n        if (curr->type == next->type) {\n            curr->size += next->size;\n            collapse(next, term--);\n        }\n        else {\n            curr++;\n        }\n    }\n}\n\nstatic void\nupdate_last_usable()\n{\n    map->last_usable = 0;\n    for (int i = map->count - 1; i >= 0; i--) {\n        const pmapregion_t *r = &map->region[i];\n        if (r->type == PMEMTYPE_USABLE) {\n            map->last_usable = r->addr + r->size;\n            break;\n        }\n    }\n}\n\nstatic void\nnormalize()\n{\n    // Sort the memory map by address.\n    qsort(map->region, map->count, sizeof(pmapregion_t),\n          cmp_region);\n\n    // Remove overlapping regions, fill gaps between regions with \"reserved\"\n    // memory, squash adjacent regions of the same type, and calculate the end\n    // of the last usable memory region.\n    collapse_overlaps();\n    fill_gaps(PMEMTYPE_RESERVED);\n    consolidate_neighbors();\n    update_last_usable();\n}\n\nvoid\npmap_init()\n{\n    // During the boot process, the physical memory map at KMEM_TABLE_BIOS has\n    // been updated to include memory regions reported by the BIOS. This\n    // function cleans up the BIOS memory map (sorts it, removes overlaps,\n    // etc.) and adds a few additional memory regions.\n\n    // Mark VGA video memory as uncached.\n    add_region(KMEM_VIDEO, KMEM_VIDEO_SIZE, PMEMTYPE_UNCACHED);\n\n    // Reserve memory for the kernel and its global data structures.\n    add_region(0, KMEM_KERNEL_IMAGE_END, PMEMTYPE_RESERVED);\n\n    // Mark the first page of memory as unmapped so deferencing a null pointer\n    // always faults.\n    add_region(0, 0x1000, PMEMTYPE_UNMAPPED);\n\n    // Fix up the memory map.\n    normalize();\n\n    initialized = true;\n}\n\nconst pmap_t *\npmap()\n{\n    return map;\n}\n\nvoid\npmap_add(uint64_t addr, uint64_t size, enum pmemtype type)\n{\n    add_region(addr, size, type);\n\n    if (initialized)\n        normalize();\n}\n\n", "comment_ratio": 0.20972644376899696}
{"lang": "c", "code": "#ifndef SharedBuffer_h\r\n#define SharedBuffer_h\r\n\r\n#include \"PlatformString.h\"\r\n#include <wtf/Forward.h>\r\n#include <wtf/OwnPtr.h>\r\n#include <wtf/RefCounted.h>\r\n#include <wtf/Vector.h>\r\n\r\n#if PLATFORM(CF)\r\n#include <wtf/RetainPtr.h>\r\n#endif\r\n\r\n#if PLATFORM(MAC)\r\n#ifdef __OBJC__\r\n@class NSData;\r\n#else\r\nclass NSData;\r\n#endif\r\n\r\n#endif\r\n\r\nnamespace WebCore {\r\n    \r\nclass PurgeableBuffer;\r\n\r\nclass SharedBuffer : public RefCounted<SharedBuffer> {\r\npublic:\r\n    static PassRefPtr<SharedBuffer> create() { return adoptRef(new SharedBuffer); }\r\n    static PassRefPtr<SharedBuffer> create(const char* c, int i) { return adoptRef(new SharedBuffer(c, i)); }\r\n    static PassRefPtr<SharedBuffer> create(const unsigned char* c, int i) { return adoptRef(new SharedBuffer(c, i)); }\r\n\r\n    static PassRefPtr<SharedBuffer> createWithContentsOfFile(const String& filePath);\r\n\r\n    static PassRefPtr<SharedBuffer> adoptVector(Vector<char>& vector);\r\n    \r\n    // The buffer must be in non-purgeable state before adopted to a SharedBuffer. \r\n    // It will stay that way until released.\r\n    static PassRefPtr<SharedBuffer> adoptPurgeableBuffer(PurgeableBuffer* buffer);\r\n    \r\n    ~SharedBuffer();\r\n    \r\n#if PLATFORM(MAC)\r\n    NSData *createNSData();\r\n    static PassRefPtr<SharedBuffer> wrapNSData(NSData *data);\r\n#endif\r\n#if PLATFORM(CF)\r\n    CFDataRef createCFData();\r\n    static PassRefPtr<SharedBuffer> wrapCFData(CFDataRef);\r\n#endif\r\n\r\n    // Calling this function will force internal segmented buffers\r\n    // to be merged into a flat buffer. Use getSomeData() whenever possible\r\n    // for better performance.\r\n    const char* data() const;\r\n\r\n    unsigned size() const;\r\n\r\n    // Calling this function will force internal segmented buffers\r\n    // to be merged into a flat buffer. Use getSomeData() whenever possible\r\n    // for better performance.\r\n    const Vector<char>& buffer() const;\r\n\r\n    bool isEmpty() const { return !size(); }\r\n\r\n    void append(const char*, unsigned);\r\n    void clear();\r\n    const char* platformData() const;\r\n    unsigned platformDataSize() const;\r\n\r\n    PassRefPtr<SharedBuffer> copy() const;\r\n    \r\n    bool hasPurgeableBuffer() const { return m_purgeableBuffer.get(); }\r\n\r\n    // Ensure this buffer has no other clients before calling this.\r\n    PurgeableBuffer* releasePurgeableBuffer();\r\n\r\n    // Return the number of consecutive bytes after \"position\". \"data\"\r\n    // points to the first byte.\r\n    // Return 0 when no more data left.\r\n    // When extracting all data with getSomeData(), the caller should\r\n    // repeat calling it until it returns 0.\r\n    // Usage:\r\n    //      const char* segment;\r\n    //      unsigned pos = 0;\r\n    //      while (unsigned length = sharedBuffer->getSomeData(segment, pos)) {\r\n    //          // Use the data. for example: decoder->decode(segment, length);\r\n    //          pos += length;\r\n    //      }\r\n    unsigned getSomeData(const char*& data, unsigned position = 0) const;\r\n\r\nprivate:\r\n    SharedBuffer();\r\n    SharedBuffer(const char*, int);\r\n    SharedBuffer(const unsigned char*, int);\r\n    \r\n    void clearPlatformData();\r\n    void maybeTransferPlatformData();\r\n    bool hasPlatformData() const;\r\n    \r\n    unsigned m_size;\r\n    mutable Vector<char> m_buffer;\r\n    mutable Vector<char*> m_segments;\r\n    OwnPtr<PurgeableBuffer> m_purgeableBuffer;\r\n#if PLATFORM(CF)\r\n    SharedBuffer(CFDataRef);\r\n    RetainPtr<CFDataRef> m_cfData;\r\n#endif\r\n};\r\n    \r\n}\r\n\r\n#endif // SharedBuffer_h\r\n\n", "comment_ratio": 0.15827338129496402}
{"lang": "c", "code": "#pragma once\n\n#include <cstdint>\n#include <mutex>\n#include <vector>\n\n#include \"data.h\"\n\nnamespace n2 {\n\nclass HnswNode {\npublic:\n    explicit HnswNode(int id, const Data* data, int level, size_t max_m, size_t max_m0);\n    void CopyHigherLevelLinksToOptIndex(char* mem_offset, uint64_t memory_per_node_higher_level) const;\n    void CopyDataAndLevel0LinksToOptIndex(char* mem_offset, int higher_level_offset) const;\n\n    inline int GetId() const { return id_; }\n    inline int GetLevel() const { return level_; }\n    inline size_t GetMaxM() const { return max_m_; }\n    inline size_t GetMaxM0() const { return max_m0_; }\n    \n    inline const float* GetData() const { return data_->GetRawData(); }\n    \n    inline std::vector<HnswNode*>& GetFriends(int level) { return friends_at_layer_[level]; }\n    inline void SetFriends(int level, std::vector<HnswNode*>& new_friends) {\n        friends_at_layer_[level].swap(new_friends);\n    }\n    inline std::mutex& GetAccessGuard() { return access_guard_; }\n\nprivate:\n    void CopyLinksToOptIndex(char* mem_offset, int level) const;\n\nprivate:\n    int id_;\n    const Data* data_;\n    int level_;\n    size_t max_m_;\n    size_t max_m0_;\n\n    std::vector<std::vector<HnswNode*>> friends_at_layer_;\n    std::mutex access_guard_;\n};\n\n} // namespace n2\n\n", "comment_ratio": 0.23728813559322035}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n\nNS_ASSUME_NONNULL_BEGIN\n/**\n * \u5546\u57ce\u5206\u7c7b\n */\n@interface LLCategoryViewController : UIViewController\n\n@end\n\nNS_ASSUME_NONNULL_END\n\n", "comment_ratio": 0.35}
{"lang": "c", "code": "#ifndef GRAPHBLAS_DEMOS_H\n#define GRAPHBLAS_DEMOS_H\n#include <stdbool.h>\n#include \"GraphBLAS.h\"\n// #include \"simple_rand.h\"\n// #include \"simple_timer.h\"\n// #include \"usercomplex.h\"\n\n\n\n//------------------------------------------------------------------------------\n// manage compiler warnings\n//------------------------------------------------------------------------------\n\n#if defined __INTEL_COMPILER\n#pragma warning (disable: 58 167 144 177 181 186 188 589 593 869 981 1418 1419 1572 1599 2259 2282 2557 2547 3280 )\n#elif defined __GNUC__\n\n#pragma GCC diagnostic ignored \"-Wunknown-pragmas\"\n//#pragma GCC diagnostic ignored \"-Wunknown-warning-option\"\n#pragma GCC diagnostic ignored \"-Wformat-truncation=\"\n#pragma GCC diagnostic ignored \"-Wunused-variable\"\n#pragma GCC diagnostic ignored \"-Wunused-result\"\n#pragma GCC diagnostic ignored \"-Wint-in-bool-context\"\n#pragma GCC diagnostic ignored \"-Wunused-parameter\"\n// #pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wtype-limits\"\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n\n// enable these warnings as errors\n#pragma GCC diagnostic error \"-Wmisleading-indentation\"\n#pragma GCC diagnostic error \"-Wswitch-default\"\n#endif\n\n\n#undef MIN\n#undef MAX\n#define MIN(a,b) (((a) < (b)) ? (a) : (b))\n#define MAX(a,b) (((a) > (b)) ? (a) : (b))\n\nGrB_Info read_matrix        // read a double-precision matrix\n(\n    GrB_Matrix *A,          // handle of matrix to create\n    FILE *f,                // file to read the tuples from\n    bool make_symmetric,    // if true, return A as symmetric\n    bool no_self_edges,     // if true, then remove self edges from A\n    bool one_based,         // if true, input matrix is 1-based\n    bool boolean,           // if true, input is GrB_BOOL, otherwise GrB_FP64\n    bool printstuff         // if true, print status to stdout\n) ;\n\n\nextern int32_t level ;\n#pragma omp threadprivate(level)\n\n// multiplicative scaling factor for ipagerank, ZSCALE = 2^30\n#define ZSCALE ((uint64_t) 1073741824)\n\n//------------------------------------------------------------------------------\n// CHECK: expr must be true; if not, return an error condition\n//------------------------------------------------------------------------------\n\n// the #include'ing file must define the FREE_ALL macro\n\n#define CHECK(expr,info)                                                \\\n{                                                                       \\\n    if (! (expr))                                                       \\\n    {                                                                   \\\n        /* free the result and all workspace, and return NULL */        \\\n        FREE_ALL ;                                                      \\\n        printf (\"Failure: line %d file %s\\n\", __LINE__, __FILE__) ;     \\\n        return (info) ;                                                 \\\n    }                                                                   \\\n}\n\n//------------------------------------------------------------------------------\n// OK: call a GraphBLAS method and check the result\n//------------------------------------------------------------------------------\n\n// OK(method) is a macro that calls a GraphBLAS method and checks the status;\n// if a failure occurs, it handles the error via the CHECK macro above, and\n// returns the error status to the caller.\n\n#define OK(method)                                                      \\\n{                                                                       \\\n    info = method ;                                                     \\\n    if (info != GrB_SUCCESS)                                            \\\n    {                                                                   \\\n        printf (\"GraphBLAS error:\\n%s\\n\", GrB_error ( )) ;              \\\n        CHECK (false, info) ;                                           \\\n    }                                                                   \\\n}\n\n#endif\n\n\n//------------------------------------------------------------------------------\n// GraphBLAS/Demo/Source/read_matrix.c: read a matrix from stdin\n//------------------------------------------------------------------------------\n\n// SuiteSparse:GraphBLAS, Timothy A. Davis, (c) 2017-2018, All Rights Reserved.\n// http://suitesparse.com   See GraphBLAS/Doc/License.txt for license.\n\n//------------------------------------------------------------------------------\n\n// Reads a matrix from stdin.  For sample inputs, see the Matrix/* files.\n// Each line has the form:\n//\n//      i j x\n//\n// where i and j are the row and column indices, and x is the value.\n// The matrix is read in double precision.\n\n// free all workspace; this used by the OK(...) macro if an error occurs\n#define FREE_ALL                    \\\n    if (I  != NULL) free (I) ;      \\\n    if (J  != NULL) free (J) ;      \\\n    if (X  != NULL) free (X) ;      \\\n    if (I2 != NULL) free (I2) ;     \\\n    if (J2 != NULL) free (J2) ;     \\\n    if (X2 != NULL) free (X2) ;     \\\n    GrB_free (&scale2_op) ;         \\\n    GrB_free (&dt2) ;               \\\n    GrB_free (&dt1) ;               \\\n    GrB_free (&A) ;                 \\\n    GrB_free (&B) ;                 \\\n    GrB_free (&C) ;\n\n\n//------------------------------------------------------------------------------\n// unary operator to divide by 2\n//------------------------------------------------------------------------------\n\nvoid scale2 (double *z, const double *x)\n{\n    (*z) = (*x) / 2.0 ;\n}\n\n//------------------------------------------------------------------------------\n// read a matrix from a file\n//------------------------------------------------------------------------------\n\nGrB_Info read_matrix        // read a double-precision or boolean matrix\n(\n    GrB_Matrix *A_output,   // handle of matrix to create\n    FILE *f,                // file to read the tuples from\n    bool make_symmetric,    // if true, return A as symmetric\n    bool no_self_edges,     // if true, then remove self edges from A\n    bool one_based,         // if true, input matrix is 1-based\n    bool boolean,           // if true, input is GrB_BOOL, otherwise GrB_FP64\n    bool pr                 // if true, print status to stdout\n)\n{\n\n    int64_t len = 256 ;\n    int64_t ntuples = 0 ;\n    double x ;\n    GrB_Index nvals ;\n\n    //--------------------------------------------------------------------------\n    // set all pointers to NULL so that FREE_ALL can free everything safely\n    //--------------------------------------------------------------------------\n\n    GrB_Matrix C = NULL, A = NULL, B = NULL ;\n    GrB_Descriptor dt1 = NULL, dt2 = NULL ;\n    GrB_UnaryOp scale2_op = NULL ;\n\n    //--------------------------------------------------------------------------\n    // allocate initial space for tuples\n    //--------------------------------------------------------------------------\n\n    size_t xsize = ((boolean) ? sizeof (bool) : sizeof (double)) ;\n    GrB_Index *I = malloc (len * sizeof (int64_t)), *I2 = NULL ;\n    GrB_Index *J = malloc (len * sizeof (int64_t)), *J2 = NULL ;\n    void *X = malloc (len * xsize) ;\n    bool *Xbool ;\n    double *Xdouble ;\n    void *X2 = NULL ;\n    if (I == NULL || J == NULL || X == NULL)\n    {\n        // out of memory\n        if (pr) printf (\"out of memory for initial tuples\\n\") ;\n        FREE_ALL ;\n        return (GrB_OUT_OF_MEMORY) ;\n    }\n\n    Xbool   = (bool   *) X ;\n    Xdouble = (double *) X ;\n\n    //--------------------------------------------------------------------------\n    // read in the tuples from stdin, one per line\n    //--------------------------------------------------------------------------\n\n    // format warnings vary with compilers, so read in as double\n    double i2, j2 ;\n    while (fscanf (f, \"%lg %lg %lg\\n\", &i2, &j2, &x) != EOF)\n    {\n        int64_t i = (int64_t) i2 ;\n        int64_t j = (int64_t) j2 ;\n        if (ntuples >= len)\n        {\n            I2 = realloc (I, 2 * len * sizeof (int64_t)) ;\n            J2 = realloc (J, 2 * len * sizeof (int64_t)) ;\n            X2 = realloc (X, 2 * len * xsize) ;\n            if (I2 == NULL || J2 == NULL || X2 == NULL)\n            {\n                if (pr) printf (\"out of memory for tuples\\n\") ;\n                FREE_ALL ;\n                return (GrB_OUT_OF_MEMORY) ;\n            }\n            I = I2 ; I2 = NULL ;\n            J = J2 ; J2 = NULL ;\n            X = X2 ; X2 = NULL ;\n            len = len * 2 ;\n            Xbool   = (bool   *) X ;\n            Xdouble = (double *) X ;\n        }\n        if (one_based)\n        {\n            i-- ;\n            j-- ;\n        }\n        I [ntuples] = i ;\n        J [ntuples] = j ;\n        if (boolean)\n        {\n            Xbool [ntuples] = (x != 0) ;\n        }\n        else\n        {\n            Xdouble [ntuples] = x ;\n        }\n        ntuples++ ;\n    }\n\n    //--------------------------------------------------------------------------\n    // find the dimensions\n    //--------------------------------------------------------------------------\n\n    if (pr) printf (\"ntuples: %.16g\\n\", (double) ntuples) ;\n    int64_t nrows = 0 ;\n    int64_t ncols = 0 ;\n    for (int64_t k = 0 ; k < ntuples ; k++)\n    {\n        nrows = MAX (nrows, I [k]) ;\n        ncols = MAX (ncols, J [k]) ;\n    }\n    nrows++ ;\n    ncols++ ;\n\n    if (pr) printf (\"nrows %.16g ncols %.16g\\n\",\n        (double) nrows, (double) ncols) ;\n\n    //--------------------------------------------------------------------------\n    // prune self edges\n    //--------------------------------------------------------------------------\n\n    // but not if creating the augmented system aka a bipartite graph\n    double tic [2], t1 ;\n    if (no_self_edges && ! (make_symmetric && nrows != ncols))\n    {\n        int64_t ntuples2 = 0 ;\n        for (int64_t k = 0 ; k < ntuples ; k++)\n        {\n            if (I [k] != J [k])\n            {\n                // keep this off-diagonal edge\n                I [ntuples2] = I [k] ;\n                J [ntuples2] = J [k] ;\n                if (boolean)\n                {\n                    Xbool [ntuples2] = Xbool [k] ;\n                }\n                else\n                {\n                    Xdouble [ntuples2] = Xdouble [k] ;\n                }\n                ntuples2++ ;\n            }\n        }\n        ntuples = ntuples2 ;\n    }\n\n    //--------------------------------------------------------------------------\n    // build the matrix, summing up duplicates, and then free the tuples\n    //--------------------------------------------------------------------------\n\n    GrB_Type xtype ;\n    GrB_BinaryOp xop, xop2 ;\n    if (boolean)\n    {\n        xtype = GrB_BOOL ;\n        xop   = GrB_LOR ;\n        xop2  = GrB_FIRST_BOOL ;\n    }\n    else\n    {\n        xtype = GrB_FP64 ;\n        xop   = GrB_PLUS_FP64 ;\n        xop2  = GrB_FIRST_FP64 ;\n    }\n\n    GrB_Info info ;\n    OK (GrB_Matrix_new (&C, xtype, nrows, ncols)) ;\n\n    if (boolean)\n    {\n        OK (GrB_Matrix_build (C, I, J, Xbool, ntuples, xop)) ;\n    }\n    else\n    {\n        OK (GrB_Matrix_build (C, I, J, Xdouble, ntuples, xop)) ;\n    }\n\n    free (I) ; I = NULL ;\n    free (J) ; J = NULL ;\n    free (X) ; X = NULL ;\n\n    //--------------------------------------------------------------------------\n    // construct the descriptors\n    //--------------------------------------------------------------------------\n\n    // descriptor dt2: transpose the 2nd input\n    OK (GrB_Descriptor_new (&dt2)) ;\n    OK (GrB_Descriptor_set (dt2, GrB_INP1, GrB_TRAN)) ;\n\n    // descriptor dt1: transpose the 1st input\n    OK (GrB_Descriptor_new (&dt1)) ;\n    OK (GrB_Descriptor_set (dt1, GrB_INP0, GrB_TRAN)) ;\n\n    //--------------------------------------------------------------------------\n    // create the output matrix\n    //--------------------------------------------------------------------------\n\n    if (make_symmetric)\n    {\n\n        //----------------------------------------------------------------------\n        // ensure the matrix is symmetric\n        //----------------------------------------------------------------------\n\n        if (pr) printf (\"make symmetric\\n\") ;\n        if (nrows == ncols)\n        {\n\n            //------------------------------------------------------------------\n            // A = (C+C')/2\n            //------------------------------------------------------------------\n\n            if (pr) printf (\"A = (C+C')/2\\n\") ;\n            double tic [2], t ;\n            OK (GrB_Matrix_new (&A, xtype, nrows, nrows)) ;\n            OK (GrB_eWiseAdd (A, NULL, NULL, xop, C, C, dt2)) ;\n            OK (GrB_free (&C)) ;\n\n            if (boolean)\n            {\n                *A_output = A ;\n                A = NULL ;\n            }\n            else\n            {\n                OK (GrB_Matrix_new (&C, xtype, nrows, nrows)) ;\n                OK (GrB_UnaryOp_new (&scale2_op, scale2, xtype, xtype)) ;\n                OK (GrB_apply (C, NULL, NULL, scale2_op, A, NULL)) ;\n                OK (GrB_free (&A)) ;\n                OK (GrB_free (&scale2_op)) ;\n                *A_output = C ;\n                C = NULL ;\n            }\n\n        }\n        else\n        {\n\n            //------------------------------------------------------------------\n            // A = [0 C ; C' 0], a bipartite graph\n            //------------------------------------------------------------------\n\n            // no self edges will exist\n            if (pr) printf (\"A = [0 C ; C' 0], a bipartite graph\\n\") ;\n\n            double tic [2], t ;\n\n            int64_t n = nrows + ncols ;\n            OK (GrB_Matrix_new (&A, xtype, n, n)) ;\n\n            GrB_Index I_range [3], J_range [3] ;\n\n            I_range [GxB_BEGIN] = 0 ;\n            I_range [GxB_END  ] = nrows-1 ;\n\n            J_range [GxB_BEGIN] = nrows ;\n            J_range [GxB_END  ] = ncols+nrows-1 ;\n\n            // A (nrows:n-1, 0:nrows-1) += C'\n            OK (GrB_assign (A, NULL, xop2, // or NULL,\n                C, J_range, GxB_RANGE, I_range, GxB_RANGE, dt1)) ;\n\n            // A (0:nrows-1, nrows:n-1) += C\n            OK (GrB_assign (A, NULL, xop2, // or NULL,\n                C, I_range, GxB_RANGE, J_range, GxB_RANGE, NULL)) ;\n\n            // force completion; if this statement does not appear, the\n            // timing will not account for the final build, which would be\n            // postponed until A is used by the caller in another GraphBLAS\n            // operation.\n            GrB_Matrix_nvals (&nvals, A) ;\n\n            *A_output = A ;\n            // set A to NULL so the FREE_ALL macro does not free *A_output\n            A = NULL ;\n\n        }\n    }\n    else\n    {\n\n        //----------------------------------------------------------------------\n        // return the matrix as-is\n        //----------------------------------------------------------------------\n\n        if (pr) printf (\"leave A as-is\\n\") ;\n        *A_output = C ;\n        // set C to NULL so the FREE_ALL macro does not free *A_output\n        C = NULL ;\n    }\n\n    //--------------------------------------------------------------------------\n    // success: free everything except the result, and return it to the caller\n    //--------------------------------------------------------------------------\n\n    FREE_ALL ;\n    if (pr) printf (\"\\nMatrix from file:\\n\") ;\n    GxB_print (*A_output, pr ? GxB_SHORT : GxB_SILENT) ;\n    return (GrB_SUCCESS) ;\n}\n\n\n", "comment_ratio": 0.26339285714285715}
{"lang": "c", "code": "#ifndef NINJACLOWN_BOT_INTERFACE_BOT_H\n#define NINJACLOWN_BOT_INTERFACE_BOT_H\n\n#ifdef OS_WINDOWS\n#\tdefine NINJACLOWN_DLLEXPORT __declspec(dllexport)\n#\tdefine NINJACLOWN_CALLCONV  __cdecl\n#else\n#\tdefine NINJACLOWN_DLLEXPORT\n#\tdefine NINJACLOWN_CALLCONV __attribute((sysv_abi))\n#endif\n\n#ifdef __cplusplus\n#\tinclude <cstddef>\nnamespace ninja_api {\nextern \"C\" {\n#else\n#\tinclude <stddef.h>\n#endif\n\nenum nnj_log_level {\n\tLL_TRACE    = 0,\n\tLL_DEBUG    = 1,\n\tLL_INFO     = 2,\n\tLL_WARN     = 3,\n\tLL_ERROR    = 4,\n\tLL_CRITICAL = 5,\n};\n\nenum nnj_cell_kind {\n\tCT_UNKNOWN = 0,\n\tCT_CHASM   = 1,\n\tCT_GROUND  = 2,\n\tCT_WALL    = 3,\n};\n\nenum nnj_interaction_kind {\n\tIK_NO_INTERACTION = 0, // not an interactive cell\n\tIK_LIGHT_MANUAL   = 1, // character or thrown item can interact\n\tIK_HEAVY_MANUAL   = 2, // only a character can interact\n\tIK_LIGHT_MIDAIR   = 3, // character or thrown item in the cell cause interaction\n\tIK_HEAVY_MIDAIR   = 4, // only character in the cell cause interaction\n\tIK_WALK_ON_GROUND = 5, // only non-floating character in the cell cause interaction\n};\n\nstruct nnj_cell {\n\tenum nnj_cell_kind kind;\n\tenum nnj_interaction_kind interaction;\n};\n\nstruct nnj_cell_pos {\n\tsize_t column;\n\tsize_t line;\n};\n\nenum nnj_entity_kind {\n\tEK_NOT_AN_ENTITY = 0, // unused entity slot\n\tEK_HARMLESS      = 1, // entity is harmless\n\tEK_PATROL        = 2, // patrolling entity\n\tEK_AGGRESSIVE    = 3, // rush to the player\n\tEK_PROJECTILE    = 4, // follow some trajectory\n\tEK_DLL           = 5, // controlled by dll\n};\n\nstruct nnj_properties {\n\tfloat move_speed;\n\tfloat rotation_speed;\n\tfloat attack_range;\n\tfloat activate_range;\n\tfloat attack_delay;\n\tfloat throw_delay;\n};\n\nenum nnj_entity_state {\n\tES_READY = 0, // entity is ready for any action\n\tES_BUSY  = 1, // entity is busy and cannot perform any other action\n};\n\nstruct nnj_entity {\n\tenum nnj_entity_kind kind;\n\tenum nnj_entity_state state;\n\tstruct nnj_properties properties;\n\tfloat x, y;\n\tfloat angle;\n\tsize_t handle;\n};\n\nenum nnj_decision_kind {\n\tDK_NONE          = 0,\n\tDK_MOVEMENT      = 1,\n\tDK_ACTIVATE      = 2,\n\tDK_ATTACK        = 3,\n\tDK_THROW         = 4,\n};\n\nstruct nnj_movement_request {\n\tfloat rotation; // radians\n\tfloat forward_diff;\n\tfloat lateral_diff;\n};\n\nstruct nnj_activate_request {\n\tsize_t column;\n\tsize_t line;\n};\n\nstruct nnj_attack_request {\n\tsize_t target_handle;\n};\n\nstruct nnj_throw_request {\n\tvoid *unused;\n};\n\nstruct nnj_decision {\n\tenum nnj_decision_kind kind;\n\tunion {\n\t\tstruct nnj_movement_request movement_req;\n\t\tstruct nnj_activate_request activate_req;\n\t\tstruct nnj_attack_request attack_req;\n\t\tstruct nnj_throw_request throw_req;\n\t};\n};\n\nstruct nnj_decision_commit {\n\tsize_t target_handle;\n\tstruct nnj_decision decision;\n};\n\nstruct nnj_api {\n\tvoid *ninja_descriptor;\n\n\tvoid(NINJACLOWN_CALLCONV *log)(enum nnj_log_level level, const char *text);\n\n\tsize_t(NINJACLOWN_CALLCONV *map_width)(void *ninja_data);\n\tsize_t(NINJACLOWN_CALLCONV *map_height)(void *ninja_data);\n\tstruct nnj_cell_pos(NINJACLOWN_CALLCONV *target_position)(void *ninja_data);\n\tvoid(NINJACLOWN_CALLCONV *map_scan)(void *ninja_data, struct nnj_cell *map_view);\n\tsize_t(NINJACLOWN_CALLCONV *map_update)(void *ninja_data, struct nnj_cell *map_view, struct nnj_cell_pos *changed_cells,\n\t                                        size_t changed_size);\n\n\tsize_t(NINJACLOWN_CALLCONV *max_entities)();\n\tvoid(NINJACLOWN_CALLCONV *entities_scan)(void *ninja_data, struct nnj_entity *entities);\n\tsize_t(NINJACLOWN_CALLCONV *entities_update)(void *ninja_data, struct nnj_entity *entities);\n\n\tvoid(NINJACLOWN_CALLCONV *commit_decisions)(void *ninja_data, struct nnj_decision_commit const *commits, size_t num_commits);\n};\n\n#ifdef __cplusplus\n} // extern \"C\"\n} // namespace ninja_api\n#endif\n\n#endif //NINJACLOWN_BOT_INTERFACE_BOT_H\n\n", "comment_ratio": 0.11688311688311688}
{"lang": "c", "code": "#ifndef SIMDJSON_ARM64_H\n#define SIMDJSON_ARM64_H\n\n#include \"simdjson/implementation-base.h\"\n\n#if SIMDJSON_IMPLEMENTATION_ARM64\n\nnamespace simdjson {\n/**\n * Implementation for NEON (ARMv8).\n */\nnamespace arm64 {\n} // namespace arm64\n} // namespace simdjson\n\n#include \"simdjson/arm64/implementation.h\"\n\n#include \"simdjson/arm64/begin.h\"\n\n// Declarations\n#include \"simdjson/generic/dom_parser_implementation.h\"\n#include \"simdjson/arm64/intrinsics.h\"\n#include \"simdjson/arm64/bitmanipulation.h\"\n#include \"simdjson/arm64/bitmask.h\"\n#include \"simdjson/arm64/simd.h\"\n#include \"simdjson/generic/jsoncharutils.h\"\n#include \"simdjson/generic/atomparsing.h\"\n#include \"simdjson/arm64/stringparsing.h\"\n#include \"simdjson/arm64/numberparsing.h\"\n#include \"simdjson/arm64/end.h\"\n\n#endif // SIMDJSON_IMPLEMENTATION_ARM64\n\n#endif // SIMDJSON_ARM64_H\n\n", "comment_ratio": 0.14285714285714285}
{"lang": "c", "code": "/**\n * @brief Example C-based BPF sanity rogram that prints out the parameters\n * passed to it\n */\n#include <analog_sdk.h>\n\nextern uint64_t entrypoint(const uint8_t *input) {\n  SolAccountInfo ka[1];\n  SolParameters params = (SolParameters) { .ka = ka };\n\n  anlog_log(__FILE__);\n\n  if (!anlog_deserialize(input, &params, ANLOG_ARRAY_SIZE(ka))) {\n    return ERROR_INVALID_ARGUMENT;\n  }\n\n  // Log the provided input parameters.  In the case of  the no-op\n  // program, no account keys or input data are expected but real\n  // programs will have specific requirements so they can do their work.\n  anlog_log_params(&params);\n\n  anlog_log_compute_units();\n  return SUCCESS;\n}\n\n", "comment_ratio": 0.12}
{"lang": "c", "code": "//\n// Created by kchen on 12/5/17.\n//\n\n#ifndef SPLUNK_HEC_CLIENT_CPP_THREAD_POOL_H\n#define SPLUNK_HEC_CLIENT_CPP_THREAD_POOL_H\n\n#include \"blocking_queue.h\"\n#include \"timeout_exception.h\"\n\n#include <thread>\n#include <vector>\n#include <atomic>\n#include <chrono>\n#include <future>\n#include <functional>\n\nnamespace concurrentcpp {\n\nclass ThreadPool {\npublic:\n    // param size: number of threads\n    // param timeout: submit timeout\n    explicit ThreadPool(std::size_t size = std::max(std::thread::hardware_concurrency(), 2u),\n                        const std::chrono::milliseconds& timeout = std::chrono::milliseconds{1000})\n            : tasks_(2 * size), timeout_(timeout), stop_(false) {\n        for (std::size_t i = 0; i < size; i++) {\n            workers_.emplace_back(std::thread(std::bind(&ThreadPool::_wait_for_tasks, this)));\n        }\n    }\n\n    ~ThreadPool() {\n        stop_ = true;\n        for (auto& th: workers_) {\n            th.join();\n        }\n    }\n\n    // Submit a task to thread pool, return std::future<result_type> if successfully submitting the task\n    // Throws timeout_error when TimeoutException\n    template<typename F, typename... Args>\n    auto submit(F&& f, Args&&... args) -> std::future<typename std::result_of<F(Args...)>::type> {\n        using return_type = typename std::result_of<F(Args...)>::type;\n        auto task = std::make_shared<std::packaged_task<return_type()>>(\n                std::bind(std::forward<F>(f), std::forward<Args>(args)...)\n        );\n\n        std::future<return_type> res = task->get_future();\n        bool success = tasks_.put([task](){(*task)();}, timeout_);\n        if (!success) {\n            throw TimeoutException(\"timed out when submitting task\");\n        }\n        return res;\n    };\n\n    ThreadPool(const ThreadPool&) = delete;\n    ThreadPool& operator=(const ThreadPool&) = delete;\n    ThreadPool(ThreadPool&&) = delete;\n    ThreadPool& operator=(ThreadPool&&) = delete;\n\nprivate:\n    void _wait_for_tasks() {\n        // make sure tasks_.get() doesn't block\n        auto timeout(timeout_);\n        if (timeout.count() == 0) {\n            timeout = std::chrono::milliseconds{1000};\n        }\n\n        while (!stop_.load()) {\n            std::function<void()> task;\n            bool got_task = tasks_.get(task, timeout);\n            if (got_task && task) {\n                task();\n            }\n        }\n    }\n\nprivate:\n    std::chrono::milliseconds timeout_;\n    std::vector<std::thread> workers_;\n    BlockingQueue<std::function<void()>> tasks_;\n    std::atomic_bool stop_;\n};\n\n} // namespace concurrentcpp\n\n#endif //SPLUNK_HEC_CLIENT_CPP_THREAD_POOL_H\n\n", "comment_ratio": 0.11363636363636363}
{"lang": "c", "code": "#ifndef __hash_map_str_ptr_H_\n#define __hash_map_str_ptr_H_\n\n#include \"hash_map.h\"\n#include \"stdlib.h\"\n\n//  \u5b9a\u4e49 key\nstruct hash_map_str_key {\n    uint32_t hash;\n    char* key;\n};\nstruct hash_map_str_key* hash_map_str_key_ref(struct hash_map_str_key* key, char* str);\n\n//  \u5b9a\u4e49\u4e00\u4e2a\u5b9e\u4f53\nstruct hash_map_str_int_entry {\n    struct hash_node node;\n    struct hash_map_str_key key;\n    int val;\n};\n\nstruct hash_map_str_int_entry* hash_map_str_int_entry_new(char* key, int val);\nvoid hash_map_str_int_entry_del(struct hash_map_str_int_entry* entry);\n\nstruct hash_trait* hash_map_str_int_trait_init(struct hash_trait* trait);\n\n#endif  //__hash_map_str_ptr_H_\n\n", "comment_ratio": 0.1111111111111111}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n\n#define VVWeakSelf      __weak typeof(self) weakSelf = self;\n#define VVStrongSelf    __strong typeof(weakSelf) self = weakSelf;\n\n#define VVFONT(_SIZE_)    [UIFont systemFontOfSize:_SIZE_]\n#define VVBFONT(_SIZE_)   [UIFont boldSystemFontOfSize:_SIZE_]\n#define VVMFONT(_SIZE_)   [UIFont systemFontOfSize:_SIZE_ weight:UIFontWeightMedium]\n#define VVIMAGE(_IMAGE_)  [UIImage imageNamed:_IMAGE_]\n\n#define VVSIZE(_W_,_H_)                 CGSizeMake(_W_, _H_)\n#define VVPOINT(_X_,_Y_)                CGPointMake(_X_, _Y_)\n#define VVBOUNDS(_X_,_Y_,_W_,_H_)       CGRectMake(0, 0, _W_, _H_)\n#define VVRECT(_X_,_Y_,_W_,_H_)         CGRectMake(_X_, _Y_, _W_, _H_)\n#define VVRANGE(_location_,_length_)    NSMakeRange(_location_,_length_)\n\n#define VVScreenW       [UIScreen mainScreen].bounds.size.width\n#define VVScreenH       [UIScreen mainScreen].bounds.size.height\n\n#define VVIs_iphone     (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPhone)\n#define VVIs_iPhoneX    ((VVScreenW >=375.0f && VVScreenH >=812.0f) || (VVScreenW >=812.0f && VVScreenH >=375.0f))&& VVIs_iphone\n\n#define VVStatusH       (CGFloat)(VVIs_iPhoneX?(44.0):(20.0))\n#define VVNavH          (CGFloat)(VVIs_iPhoneX?(88.0):(64.0))\n#define VVTabBarH       (CGFloat)(VVIs_iPhoneX?(49.0 + 34.0):(49.0))\n#define VVTopSafeH      (CGFloat)(VVIs_iPhoneX?(44.0):(0))\n#define VVBottomSafeH   (CGFloat)(VVIs_iPhoneX?(34.0):(0))\n\n#ifdef DEBUG  //\u8c03\u8bd5\u9636\u6bb5\n#define NSLog(...)  NSLog(__VA_ARGS__)\n#else //\u53d1\u5e03\u9636\u6bb5\n#define NSLog(...)\n#endif\n\n", "comment_ratio": 0.21428571428571427}
{"lang": "c", "code": "/**\n @@create by \u5218\u667a\u63f4 2016-11-28\n \n @\u7b80\u4e66\u5730\u5740:    http://www.jianshu.com/users/0714484ea84f/latest_articles\n @Github\u5730\u5740: https://github.com/lyoniOS\n @return MXWechatPayHandler\uff08\u5fae\u4fe1\u8c03\u7528\u5de5\u5177\u7c7b\uff09\n */\n\n#import <Foundation/Foundation.h>\n\n@interface MXWechatPayHandler : NSObject\n\n+ (void)payWithOrder:(NSString *)order amount:(float)amount completation:(void(^)(BOOL resp))comp;\n\n+ (void)payWithOrder:(NSString *)order amount:(float)amount title:(NSString *)title completation:(void(^)(BOOL resp))comp;\n\n@end\n\n", "comment_ratio": 0.1111111111111111}
{"lang": "c", "code": "// ReferenceCount.h: interface for the CReferenceCount class.\r\n//\r\n//////////////////////////////////////////////////////////////////////\r\n\r\n#if !defined(AFX_REFERENCECOUNT_H__166A16CD_E846_4257_8567_89D91AFA66F0__INCLUDED_)\r\n#define AFX_REFERENCECOUNT_H__166A16CD_E846_4257_8567_89D91AFA66F0__INCLUDED_\r\n#pragma once\r\n\r\nclass ENGINE_API CReferenceCount  \r\n{\r\n\tu32\t\tdwReference;\r\npublic:\r\n\tIC void\t\tref_inc\t\t()\t{ dwReference++; }\r\n\tIC void\t\tref_release\t()\t{ dwReference--; if (0==dwReference) delete this; }\r\n\r\n\tCReferenceCount() : dwReference(1) {};\r\n\tvirtual ~CReferenceCount() {\r\n\t\tR_ASSERT(0==dwReference);\r\n\t}\r\n};\r\n\r\n#endif // !defined(AFX_REFERENCECOUNT_H__166A16CD_E846_4257_8567_89D91AFA66F0__INCLUDED_)\r\n\n", "comment_ratio": 0.17391304347826086}
{"lang": "c", "code": "@import Foundation;\n\n@interface LabQLiteConstants : NSObject\n\n+ (NSArray *)SQLITE_LOW_LVL_MSGS_ARRAY;\n\n@end\n\ntypedef NSString SQLite3LogicalOperator;\nextern NSString * const SQLite3LogicalOperatorAND;   \nextern NSString * const SQLite3LogicalOperatorOR;    \nextern NSString * const SQLite3LogicalOperatorNOT;\n\ntypedef NSString SQLite3BinaryOperator;\nextern NSString * const SQLite3BinaryOperatorEquals;     \nextern NSString * const SQLite3BinaryOperatorNotEquals;  \nextern NSString * const SQLite3BinaryOperatorLike;       \n\n\n\nextern NSString * const SQLITE3_LOW_LEVEL_ERROR_DOMAIN;\n/**\n @discussion Codes can be found in the low level src in sqlite3.h.\n The following is merely a way to objective-c-afy these codes so\n that they have an error domain and an appropriate error message NSString.\n \n More specific messages will be printed to the console\n by sqlite3.c print calls.\n */\n\n//  corresponding extern NSString * const message     corresponding code\n//  -------------------------------                   ---------------------\nextern NSString * const SQLITE_0_NO_ERROR;             //  corresponds to code  0\nextern NSString * const SQLITE_1_ERROR_Message;        //  corresponds to code  1\nextern NSString * const SQLITE_2_INTERNAL_Message;     //  corresponds to code  2\nextern NSString * const SQLITE_3_PERM_Message;        //  corresponds to code  3\nextern NSString * const SQLITE_4_ABORT_Message;        //  corresponds to code  4\nextern NSString * const SQLITE_5_BUSY_Message;         //  corresponds to code  5\nextern NSString * const SQLITE_6_LOCKED_Message;       //  corresponds to code  6\nextern NSString * const SQLITE_7_NOMEM_Message;        //  corresponds to code  7\nextern NSString * const SQLITE_8_READONLY_Message;     //  corresponds to code  8\nextern NSString * const SQLITE_9_INTERRUPT_Message;    //  corresponds to code  9\nextern NSString * const SQLITE_10_IOERR_Message;       //  corresponds to code 10\nextern NSString * const SQLITE_11_CORRUPT_Message;     //  corresponds to code 11\nextern NSString * const SQLITE_12_NOTFOUND_Message;    //  corresponds to code 12\nextern NSString * const SQLITE_13_FULL_Message;        //  corresponds to code 13\nextern NSString * const SQLITE_14_CANTOPEN_Message;    //  corresponds to code 14\nextern NSString * const SQLITE_15_PROTOCOL_Message;    //  corresponds to code 15\nextern NSString * const SQLITE_16_EMPTY_Message;       //  corresponds to code 16\nextern NSString * const SQLITE_17_SCHEMA_Message;      //  corresponds to code 17\nextern NSString * const SQLITE_18_TOOBIG_Message;      //  corresponds to code 18\nextern NSString * const SQLITE_19_CONSTRAINT_Message;  //  corresponds to code 19\nextern NSString * const SQLITE_20_MISMATCH_Message;    //  corresponds to code 20\nextern NSString * const SQLITE_21_MISUSE_Message;      //  corresponds to code 21\nextern NSString * const SQLITE_22_NOLFS_Message;       //  corresponds to code 22\nextern NSString * const SQLITE_23_AUTH_Message;        //  corresponds to code 23\nextern NSString * const SQLITE_24_FORMAT_Message;      //  corresponds to code 24\nextern NSString * const SQLITE_25_RANGE_Message;       //  corresponds to code 25\nextern NSString * const SQLITE_26_NOTADB_Message;      //  corresponds to code 26\n\n// Processing Messages\nextern NSString * const SQLITE_27_ROW_Message;         //  corresponds to code 27\nextern NSString * const SQLITE_28_DONE_Message;        //  corresponds to code 28\n\nextern NSString * const SQLITE_LOW_LVL_MSGS_ARRAY;\n\nextern NSString * const kOpennedDatabaseSuccessfully;\nextern NSString * const kClosedDatabaseSuccessfully;\nextern NSString * const kFailedToOpenDatabase;\nextern NSString * const kFailedToCloseDatabase;\nextern NSString * const kConstraintFailed;\n\n\nextern int const LABQLITE_WRAPPER_SELECT_LIMIT_NONE;\n\n\n", "comment_ratio": 0.3173076923076923}
{"lang": "c", "code": "// Generated by gmmproc 2.48.0 -- DO NOT MODIFY!\n#ifndef _PANGOMM_ATTRITER_P_H\n#define _PANGOMM_ATTRITER_P_H\n\n\n#endif /* _PANGOMM_ATTRITER_P_H */\n\n\n", "comment_ratio": 0.125}
{"lang": "c", "code": "@class NSString;\n\n@protocol WCDBRestoreProtocol\n- (Class)classFromTableName:(NSString *)arg1;\n\n@optional\n- (void)onRepairProgressUpdate:(float)arg1;\n@end\n\n\n", "comment_ratio": 0.3125}
{"lang": "c", "code": "#ifndef vtkm_worklet_contourtree_augmented_process_contourtree_h\n#define vtkm_worklet_contourtree_augmented_process_contourtree_h\n\n// global includes\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n// local includes\n#include <vtkm/worklet/contourtree_augmented/PrintVectors.h>\n#include <vtkm/worklet/contourtree_augmented/Types.h>\n\n//VTKM includes\n#include <vtkm/Pair.h>\n#include <vtkm/Types.h>\n#include <vtkm/cont/Algorithm.h>\n#include <vtkm/cont/ArrayCopy.h>\n#include <vtkm/cont/ArrayHandleConstant.h>\n#include <vtkm/worklet/contourtree_augmented/ArrayTransforms.h>\n#include <vtkm/worklet/contourtree_augmented/ContourTree.h>\n#include <vtkm/worklet/contourtree_augmented/PrintVectors.h>\n#include <vtkm/worklet/contourtree_augmented/processcontourtree/Branch.h>\n#include <vtkm/worklet/contourtree_augmented/processcontourtree/SuperArcVolumetricComparator.h>\n#include <vtkm/worklet/contourtree_augmented/processcontourtree/SuperNodeBranchComparator.h>\n\n#include <vtkm/cont/Invoker.h>\n#include <vtkm/worklet/contourtree_augmented/processcontourtree/ComputeBestUpDown.h>\n#include <vtkm/worklet/contourtree_augmented/processcontourtree/ComputeEulerTourFirstNext.h>\n#include <vtkm/worklet/contourtree_augmented/processcontourtree/ComputeEulerTourList.h>\n#include <vtkm/worklet/contourtree_augmented/processcontourtree/ComputeMinMaxValues.h>\n\n#include <vtkm/worklet/contourtree_augmented/EulerTour.h>\n\n\n\nnamespace process_contourtree_inc_ns =\n  vtkm::worklet::contourtree_augmented::process_contourtree_inc;\n\nnamespace vtkm\n{\nnamespace worklet\n{\nnamespace contourtree_augmented\n{\n\n// TODO Many of the post processing routines still need to be parallelized\n// Class with routines for post processing the contour tree\nclass ProcessContourTree\n{ // class ProcessContourTree\npublic:\n  // initialises contour tree arrays - rest is done by another class\n  ProcessContourTree()\n  { // ProcessContourTree()\n  } // ProcessContourTree()\n\n  // collect the sorted arcs\n  void static CollectSortedArcs(const ContourTree& contourTree,\n                                const IdArrayType& sortOrder,\n                                EdgePairArray& sortedArcs)\n  { // CollectSortedArcs\n    // create an array for sorting the arcs\n    std::vector<EdgePair> arcSorter;\n\n    // fill it up\n    auto arcsPortal = contourTree.arcs.GetPortalConstControl();\n    auto sortOrderPortal = sortOrder.GetPortalConstControl();\n\n    for (vtkm::Id node = 0; node < contourTree.arcs.GetNumberOfValues(); node++)\n    { // per node\n      // retrieve ID of target supernode\n      vtkm::Id arcTo = arcsPortal.Get(node);\n\n      // if this is true, it is the last pruned vertex & is omitted\n      if (noSuchElement(arcTo))\n        continue;\n\n      // otherwise, strip out the flags\n      arcTo = maskedIndex(arcTo);\n\n      // now convert to mesh IDs from sort IDs\n      // otherwise, we need to convert the IDs to regular mesh IDs\n      vtkm::Id regularID = sortOrderPortal.Get(node);\n\n      // retrieve the regular ID for it\n      vtkm::Id regularTo = sortOrderPortal.Get(arcTo);\n\n      // how we print depends on which end has lower ID\n      if (regularID < regularTo)\n        arcSorter.push_back(EdgePair(regularID, regularTo));\n      else\n        arcSorter.push_back(EdgePair(regularTo, regularID));\n    } // per vertex\n\n    // now sort it\n    // Setting saddlePeak reference to the make_ArrayHandle directly does not work\n    EdgePairArray tempArray = vtkm::cont::make_ArrayHandle(arcSorter);\n    vtkm::cont::Algorithm::Sort(tempArray, SaddlePeakSort());\n    vtkm::cont::ArrayCopy(tempArray, sortedArcs);\n  } // CollectSortedArcs\n\n  // collect the sorted superarcs\n  void static CollectSortedSuperarcs(const ContourTree& contourTree,\n                                     const IdArrayType& sortOrder,\n                                     EdgePairArray& saddlePeak)\n  { // CollectSortedSuperarcs()\n    // create an array for sorting the arcs\n    std::vector<EdgePair> superarcSorter;\n\n    // fill it up\n    auto supernodesPortal = contourTree.supernodes.GetPortalConstControl();\n    auto superarcsPortal = contourTree.superarcs.GetPortalConstControl();\n    auto sortOrderPortal = sortOrder.GetPortalConstControl();\n\n    for (vtkm::Id supernode = 0; supernode < contourTree.supernodes.GetNumberOfValues();\n         supernode++)\n    { // per supernode\n      // sort ID of the supernode\n      vtkm::Id sortID = supernodesPortal.Get(supernode);\n\n      // retrieve ID of target supernode\n      vtkm::Id superTo = superarcsPortal.Get(supernode);\n\n      // if this is true, it is the last pruned vertex & is omitted\n      if (noSuchElement(superTo))\n        continue;\n\n      // otherwise, strip out the flags\n      superTo = maskedIndex(superTo);\n\n      // otherwise, we need to convert the IDs to regular mesh IDs\n      vtkm::Id regularID = sortOrderPortal.Get(maskedIndex(sortID));\n\n      // retrieve the regular ID for it\n      vtkm::Id regularTo = sortOrderPortal.Get(maskedIndex(supernodesPortal.Get(superTo)));\n\n      // how we print depends on which end has lower ID\n      if (regularID < regularTo)\n      { // from is lower\n        // extra test to catch duplicate edge\n        if (superarcsPortal.Get(superTo) != supernode)\n        {\n          superarcSorter.push_back(EdgePair(regularID, regularTo));\n        }\n      } // from is lower\n      else\n      {\n        superarcSorter.push_back(EdgePair(regularTo, regularID));\n      }\n    } // per vertex\n\n    // Setting saddlePeak reference to the make_ArrayHandle directly does not work\n    EdgePairArray tempArray = vtkm::cont::make_ArrayHandle(superarcSorter);\n\n    // now sort it\n    vtkm::cont::Algorithm::Sort(tempArray, SaddlePeakSort());\n    vtkm::cont::ArrayCopy(tempArray, saddlePeak);\n  } // CollectSortedSuperarcs()\n\n  // routine to compute the volume for each hyperarc and superarc\n  void static ComputeVolumeWeights(const ContourTree& contourTree,\n                                   const vtkm::Id nIterations,\n                                   IdArrayType& superarcIntrinsicWeight,\n                                   IdArrayType& superarcDependentWeight,\n                                   IdArrayType& supernodeTransferWeight,\n                                   IdArrayType& hyperarcDependentWeight)\n  { // ContourTreeMaker::ComputeWeights()\n    // start by storing the first sorted vertex ID for each superarc\n    IdArrayType firstVertexForSuperparent;\n    firstVertexForSuperparent.Allocate(contourTree.superarcs.GetNumberOfValues());\n    superarcIntrinsicWeight.Allocate(contourTree.superarcs.GetNumberOfValues());\n    auto superarcIntrinsicWeightPortal = superarcIntrinsicWeight.GetPortalControl();\n    auto firstVertexForSuperparentPortal = firstVertexForSuperparent.GetPortalControl();\n    auto superparentsPortal = contourTree.superparents.GetPortalConstControl();\n    auto hyperparentsPortal = contourTree.hyperparents.GetPortalConstControl();\n    auto hypernodesPortal = contourTree.hypernodes.GetPortalConstControl();\n    auto hyperarcsPortal = contourTree.hyperarcs.GetPortalConstControl();\n    // auto superarcsPortal = contourTree.superarcs.GetPortalConstControl();\n    auto nodesPortal = contourTree.nodes.GetPortalConstControl();\n    auto whenTransferredPortal = contourTree.whenTransferred.GetPortalConstControl();\n    for (vtkm::Id sortedNode = 0; sortedNode < contourTree.arcs.GetNumberOfValues(); sortedNode++)\n    { // per node in sorted order\n      vtkm::Id sortID = nodesPortal.Get(sortedNode);\n      vtkm::Id superparent = superparentsPortal.Get(sortID);\n      if (sortedNode == 0)\n        firstVertexForSuperparentPortal.Set(superparent, sortedNode);\n      else if (superparent != superparentsPortal.Get(nodesPortal.Get(sortedNode - 1)))\n        firstVertexForSuperparentPortal.Set(superparent, sortedNode);\n    } // per node in sorted order\n    // now we use that to compute the intrinsic weights\n    for (vtkm::Id superarc = 0; superarc < contourTree.superarcs.GetNumberOfValues(); superarc++)\n      if (superarc == contourTree.superarcs.GetNumberOfValues() - 1)\n        superarcIntrinsicWeightPortal.Set(superarc,\n                                          contourTree.arcs.GetNumberOfValues() -\n                                            firstVertexForSuperparentPortal.Get(superarc));\n      else\n        superarcIntrinsicWeightPortal.Set(superarc,\n                                          firstVertexForSuperparentPortal.Get(superarc + 1) -\n                                            firstVertexForSuperparentPortal.Get(superarc));\n\n    // now initialise the arrays for transfer & dependent weights\n    vtkm::cont::ArrayCopy(\n      vtkm::cont::ArrayHandleConstant<vtkm::Id>(0, contourTree.superarcs.GetNumberOfValues()),\n      superarcDependentWeight);\n    vtkm::cont::ArrayCopy(\n      vtkm::cont::ArrayHandleConstant<vtkm::Id>(0, contourTree.supernodes.GetNumberOfValues()),\n      supernodeTransferWeight);\n    vtkm::cont::ArrayCopy(\n      vtkm::cont::ArrayHandleConstant<vtkm::Id>(0, contourTree.hyperarcs.GetNumberOfValues()),\n      hyperarcDependentWeight);\n\n    // set up the array which tracks which supernodes to deal with on which iteration\n    IdArrayType firstSupernodePerIteration;\n    vtkm::cont::ArrayCopy(vtkm::cont::ArrayHandleConstant<vtkm::Id>(0, nIterations + 1),\n                          firstSupernodePerIteration);\n    auto firstSupernodePerIterationPortal = firstSupernodePerIteration.GetPortalControl();\n    for (vtkm::Id supernode = 0; supernode < contourTree.supernodes.GetNumberOfValues();\n         supernode++)\n    { // per supernode\n      vtkm::Id when = maskedIndex(whenTransferredPortal.Get(supernode));\n      if (supernode == 0)\n      { // zeroth supernode\n        firstSupernodePerIterationPortal.Set(when, supernode);\n      } // zeroth supernode\n      else if (when != maskedIndex(whenTransferredPortal.Get(supernode - 1)))\n      { // non-matching supernode\n        firstSupernodePerIterationPortal.Set(when, supernode);\n      } // non-matching supernode\n    }   // per supernode\n    for (vtkm::Id iteration = 1; iteration < nIterations; ++iteration)\n      if (firstSupernodePerIterationPortal.Get(iteration) == 0)\n        firstSupernodePerIterationPortal.Set(iteration,\n                                             firstSupernodePerIterationPortal.Get(iteration + 1));\n\n    // set the sentinel at the end of the array\n    firstSupernodePerIterationPortal.Set(nIterations, contourTree.supernodes.GetNumberOfValues());\n\n    // now use that array to construct a similar array for hypernodes\n    IdArrayType firstHypernodePerIteration;\n    firstHypernodePerIteration.Allocate(nIterations + 1);\n    auto firstHypernodePerIterationPortal = firstHypernodePerIteration.GetPortalControl();\n    auto supernodeTransferWeightPortal = supernodeTransferWeight.GetPortalControl();\n    auto superarcDependentWeightPortal = superarcDependentWeight.GetPortalControl();\n    auto hyperarcDependentWeightPortal = hyperarcDependentWeight.GetPortalControl();\n    for (vtkm::Id iteration = 0; iteration < nIterations; iteration++)\n      firstHypernodePerIterationPortal.Set(\n        iteration, hyperparentsPortal.Get(firstSupernodePerIterationPortal.Get(iteration)));\n    firstHypernodePerIterationPortal.Set(nIterations, contourTree.hypernodes.GetNumberOfValues());\n\n    // now iterate, propagating weights inwards\n    for (vtkm::Id iteration = 0; iteration < nIterations; iteration++)\n    { // per iteration\n      // pull the array bounds into register\n      vtkm::Id firstSupernode = firstSupernodePerIterationPortal.Get(iteration);\n      vtkm::Id lastSupernode = firstSupernodePerIterationPortal.Get(iteration + 1);\n      vtkm::Id firstHypernode = firstHypernodePerIterationPortal.Get(iteration);\n      vtkm::Id lastHypernode = firstHypernodePerIterationPortal.Get(iteration + 1);\n\n      // Recall that the superarcs are sorted by (iteration, hyperarc), & that all superarcs for a given hyperarc are processed\n      // in the same iteration.  Assume therefore that:\n      //      i. we now have the intrinsic weight assigned for each superarc, and\n      // ii. we also have the transfer weight assigned for each supernode.\n      //\n      // Suppose we have a sequence of superarcs\n      //                      s11 s12 s13 s14 s21 s22 s23 s31\n      // with transfer weights at their origins and intrinsic weights along them\n      //      sArc                     s11 s12 s13 s14 s21 s22 s23 s31\n      //      transfer wt               0   1   2   1   2   3   1   0\n      //      intrinsic wt              1   2   1   5   2   6   1   1\n      //\n      //  now, if we do a prefix sum on each of these and add the two sums together, we get:\n      //      sArc                     s11 s12 s13 s14 s21 s22 s23 s31\n      //      hyperparent sNode ID     s11 s11 s11 s11 s21 s21 s21 s31\n      //      transfer weight           0   1   2   1   2   3   1   0\n      //      intrinsic weight          1   2   1   5   2   6   1   1\n      //      sum(xfer + intrinsic)     1   3   3   6   4   9   2   1\n      //  prefix sum (xfer + int)       1   4   7  13  14  26  28  29\n\n      // so, step 1: add xfer + int & store in dependent weight\n      for (vtkm::Id supernode = firstSupernode; supernode < lastSupernode; supernode++)\n      {\n        superarcDependentWeightPortal.Set(supernode,\n                                          supernodeTransferWeightPortal.Get(supernode) +\n                                            superarcIntrinsicWeightPortal.Get(supernode));\n      }\n\n      // step 2: perform prefix sum on the dependent weight range\n      for (vtkm::Id supernode = firstSupernode + 1; supernode < lastSupernode; supernode++)\n        superarcDependentWeightPortal.Set(supernode,\n                                          superarcDependentWeightPortal.Get(supernode) +\n                                            superarcDependentWeightPortal.Get(supernode - 1));\n\n      // step 3: subtract out the dependent weight of the prefix to the entire hyperarc. This will be a transfer, but for now, it's easier\n      // to show it in serial. NB: Loops backwards so that computation uses the correct value\n      // As a bonus, note that we test > firstsupernode, not >=.  This is because we've got unsigned integers, & otherwise it will not terminate\n      // But the first is always correct anyway (same reason as the short-cut termination on hyperparent), so we're fine\n      for (vtkm::Id supernode = lastSupernode - 1; supernode > firstSupernode; supernode--)\n      { // per supernode\n        // retrieve the hyperparent & convert to a supernode ID\n        vtkm::Id hyperparent = hyperparentsPortal.Get(supernode);\n        vtkm::Id hyperparentSuperID = hypernodesPortal.Get(hyperparent);\n\n        // if the hyperparent is the first in the sequence, dependent weight is already correct\n        if (hyperparent == firstHypernode)\n          continue;\n\n        // otherwise, subtract out the dependent weight *immediately* before the hyperparent's supernode\n        superarcDependentWeightPortal.Set(\n          supernode,\n          superarcDependentWeightPortal.Get(supernode) -\n            superarcDependentWeightPortal.Get(hyperparentSuperID - 1));\n      } // per supernode\n\n      // step 4: transfer the dependent weight to the hyperarc's target supernode\n      for (vtkm::Id hypernode = firstHypernode; hypernode < lastHypernode; hypernode++)\n      { // per hypernode\n        // last superarc for the hyperarc\n        vtkm::Id lastSuperarc;\n        // special case for the last hyperarc\n        if (hypernode == contourTree.hypernodes.GetNumberOfValues() - 1)\n          // take the last superarc in the array\n          lastSuperarc = contourTree.supernodes.GetNumberOfValues() - 1;\n        else\n          // otherwise, take the next hypernode's ID and subtract 1\n          lastSuperarc = hypernodesPortal.Get(hypernode + 1) - 1;\n\n        // now, given the last superarc for the hyperarc, transfer the dependent weight\n        hyperarcDependentWeightPortal.Set(hypernode,\n                                          superarcDependentWeightPortal.Get(lastSuperarc));\n\n        // note that in parallel, this will have to be split out as a sort & partial sum in another array\n        vtkm::Id hyperarcTarget = maskedIndex(hyperarcsPortal.Get(hypernode));\n        supernodeTransferWeightPortal.Set(hyperarcTarget,\n                                          supernodeTransferWeightPortal.Get(hyperarcTarget) +\n                                            hyperarcDependentWeightPortal.Get(hypernode));\n      } // per hypernode\n    }   // per iteration\n  }     // ContourTreeMaker::ComputeWeights()\n\n  // routine to compute the branch decomposition by volume\n  void static ComputeVolumeBranchDecomposition(const ContourTree& contourTree,\n                                               const IdArrayType& superarcDependentWeight,\n                                               const IdArrayType& superarcIntrinsicWeight,\n                                               IdArrayType& whichBranch,\n                                               IdArrayType& branchMinimum,\n                                               IdArrayType& branchMaximum,\n                                               IdArrayType& branchSaddle,\n                                               IdArrayType& branchParent)\n  { // ComputeVolumeBranchDecomposition()\n    auto superarcsPortal = contourTree.superarcs.GetPortalConstControl();\n    auto superarcDependentWeightPortal = superarcDependentWeight.GetPortalConstControl();\n    auto superarcIntrinsicWeightPortal = superarcIntrinsicWeight.GetPortalConstControl();\n\n    // cache the number of non-root supernodes & superarcs\n    vtkm::Id nSupernodes = contourTree.supernodes.GetNumberOfValues();\n    vtkm::Id nSuperarcs = nSupernodes - 1;\n\n    // STAGE I:  Find the upward and downwards weight for each superarc, and set up arrays\n    IdArrayType upWeight;\n    upWeight.Allocate(nSuperarcs);\n    auto upWeightPortal = upWeight.GetPortalControl();\n    IdArrayType downWeight;\n    downWeight.Allocate(nSuperarcs);\n    auto downWeightPortal = downWeight.GetPortalControl();\n    IdArrayType bestUpward;\n    auto noSuchElementArray =\n      vtkm::cont::ArrayHandleConstant<vtkm::Id>((vtkm::Id)NO_SUCH_ELEMENT, nSupernodes);\n    vtkm::cont::ArrayCopy(noSuchElementArray, bestUpward);\n    IdArrayType bestDownward;\n    vtkm::cont::ArrayCopy(noSuchElementArray, bestDownward);\n    vtkm::cont::ArrayCopy(noSuchElementArray, whichBranch);\n    auto bestUpwardPortal = bestUpward.GetPortalControl();\n    auto bestDownwardPortal = bestDownward.GetPortalControl();\n\n    // STAGE II: Pick the best (largest volume) edge upwards and downwards\n    // II A. Pick the best upwards weight by sorting on lower vertex then processing by segments\n    // II A 1.  Sort the superarcs by lower vertex\n    // II A 2.  Per segment, best superarc writes to the best upwards array\n    vtkm::cont::ArrayHandle<EdgePair> superarcList;\n    vtkm::cont::ArrayCopy(vtkm::cont::ArrayHandleConstant<EdgePair>(EdgePair(-1, -1), nSuperarcs),\n                          superarcList);\n    auto superarcListPortal = superarcList.GetPortalControl();\n    vtkm::Id totalVolume = contourTree.nodes.GetNumberOfValues();\n#ifdef DEBUG_PRINT\n    std::cout << \"Total Volume: \" << totalVolume << std::endl;\n#endif\n    // NB: Last element in array is guaranteed to be root superarc to infinity,\n    // so we can easily skip it by not indexing to the full size\n    for (vtkm::Id superarc = 0; superarc < nSuperarcs; superarc++)\n    { // per superarc\n      if (isAscending(superarcsPortal.Get(superarc)))\n      { // ascending superarc\n        superarcListPortal.Set(superarc,\n                               EdgePair(superarc, maskedIndex(superarcsPortal.Get(superarc))));\n        upWeightPortal.Set(superarc, superarcDependentWeightPortal.Get(superarc));\n        // at the inner end, dependent weight is the total in the subtree.  Then there are vertices along the edge itself (intrinsic weight), including the supernode at the outer end\n        // So, to get the \"dependent\" weight in the other direction, we start with totalVolume - dependent, then subtract (intrinsic - 1)\n        downWeightPortal.Set(superarc,\n                             (totalVolume - superarcDependentWeightPortal.Get(superarc)) +\n                               (superarcIntrinsicWeightPortal.Get(superarc) - 1));\n      } // ascending superarc\n      else\n      { // descending superarc\n        superarcListPortal.Set(superarc,\n                               EdgePair(maskedIndex(superarcsPortal.Get(superarc)), superarc));\n        downWeightPortal.Set(superarc, superarcDependentWeightPortal.Get(superarc));\n        // at the inner end, dependent weight is the total in the subtree.  Then there are vertices along the edge itself (intrinsic weight), including the supernode at the outer end\n        // So, to get the \"dependent\" weight in the other direction, we start with totalVolume - dependent, then subtract (intrinsic - 1)\n        upWeightPortal.Set(superarc,\n                           (totalVolume - superarcDependentWeightPortal.Get(superarc)) +\n                             (superarcIntrinsicWeightPortal.Get(superarc) - 1));\n      } // descending superarc\n    }   // per superarc\n\n#ifdef DEBUG_PRINT\n    std::cout << \"II A. Weights Computed\" << std::endl;\n    printHeader(upWeight.GetNumberOfValues());\n    //printIndices(\"Intrinsic Weight\", superarcIntrinsicWeight);\n    //printIndices(\"Dependent Weight\", superarcDependentWeight);\n    printIndices(\"Upwards Weight\", upWeight);\n    printIndices(\"Downwards Weight\", downWeight);\n    std::cout << std::endl;\n#endif\n\n    // II B. Pick the best downwards weight by sorting on upper vertex then processing by segments\n    // II B 1.      Sort the superarcs by upper vertex\n    IdArrayType superarcSorter;\n    superarcSorter.Allocate(nSuperarcs);\n    auto superarcSorterPortal = superarcSorter.GetPortalControl();\n    for (vtkm::Id superarc = 0; superarc < nSuperarcs; superarc++)\n      superarcSorterPortal.Set(superarc, superarc);\n\n    vtkm::cont::Algorithm::Sort(\n      superarcSorter,\n      process_contourtree_inc_ns::SuperArcVolumetricComparator(upWeight, superarcList, false));\n\n    // II B 2.  Per segment, best superarc writes to the best upward array\n    for (vtkm::Id superarc = 0; superarc < nSuperarcs; superarc++)\n    { // per superarc\n      vtkm::Id superarcID = superarcSorterPortal.Get(superarc);\n      const EdgePair& edge = superarcListPortal.Get(superarcID);\n      // if it's the last one\n      if (superarc == nSuperarcs - 1)\n        bestDownwardPortal.Set(edge.second, edge.first);\n      else\n      { // not the last one\n        const EdgePair& nextEdge = superarcListPortal.Get(superarcSorterPortal.Get(superarc + 1));\n        // if the next edge belongs to another, we're the highest\n        if (nextEdge.second != edge.second)\n          bestDownwardPortal.Set(edge.second, edge.first);\n      } // not the last one\n    }   // per superarc\n\n    // II B 3.  Repeat for lower vertex\n    vtkm::cont::Algorithm::Sort(\n      superarcSorter,\n      process_contourtree_inc_ns::SuperArcVolumetricComparator(downWeight, superarcList, true));\n\n    // II B 2.  Per segment, best superarc writes to the best upward array\n    for (vtkm::Id superarc = 0; superarc < nSuperarcs; superarc++)\n    { // per superarc\n      vtkm::Id superarcID = superarcSorterPortal.Get(superarc);\n      const EdgePair& edge = superarcListPortal.Get(superarcID);\n      // if it's the last one\n      if (superarc == nSuperarcs - 1)\n        bestUpwardPortal.Set(edge.first, edge.second);\n      else\n      { // not the last one\n        const EdgePair& nextEdge = superarcListPortal.Get(superarcSorterPortal.Get(superarc + 1));\n        // if the next edge belongs to another, we're the highest\n        if (nextEdge.first != edge.first)\n          bestUpwardPortal.Set(edge.first, edge.second);\n      } // not the last one\n    }   // per superarc\n\n#ifdef DEBUG_PRINT\n    std::cout << \"II. Best Edges Selected\" << std::endl;\n    printHeader(bestUpward.GetNumberOfValues());\n    printIndices(\"Best Upwards\", bestUpward);\n    printIndices(\"Best Downwards\", bestDownward);\n    std::cout << std::endl;\n#endif\n\n    ProcessContourTree::ComputeBranchData(contourTree,\n                                          whichBranch,\n                                          branchMinimum,\n                                          branchMaximum,\n                                          branchSaddle,\n                                          branchParent,\n                                          bestUpward,\n                                          bestDownward);\n  }\n\n  // routine to compute the branch decomposition by volume\n  void static ComputeBranchData(const ContourTree& contourTree,\n                                IdArrayType& whichBranch,\n                                IdArrayType& branchMinimum,\n                                IdArrayType& branchMaximum,\n                                IdArrayType& branchSaddle,\n                                IdArrayType& branchParent,\n                                IdArrayType& bestUpward,\n                                IdArrayType& bestDownward)\n  { // ComputeBranchData()\n\n    // Set up constants\n    vtkm::Id nSupernodes = contourTree.supernodes.GetNumberOfValues();\n    auto noSuchElementArray =\n      vtkm::cont::ArrayHandleConstant<vtkm::Id>((vtkm::Id)NO_SUCH_ELEMENT, nSupernodes);\n    vtkm::cont::ArrayCopy(noSuchElementArray, whichBranch);\n\n    // Set up portals\n    auto bestUpwardPortal = bestUpward.GetPortalControl();\n    auto bestDownwardPortal = bestDownward.GetPortalControl();\n    auto whichBranchPortal = whichBranch.GetPortalControl();\n\n    // STAGE III: For each vertex, identify which neighbours are on same branch\n    // Let v = BestUp(u). Then if u = BestDown(v), copy BestUp(u) to whichBranch(u)\n    // Otherwise, let whichBranch(u) = BestUp(u) | TERMINAL to mark the end of the side branch\n    // NB 1: Leaves already have the flag set, but it's redundant so its safe\n    // NB 2: We don't need to do it downwards because it's symmetric\n    for (vtkm::Id supernode = 0; supernode != nSupernodes; supernode++)\n    { // per supernode\n      vtkm::Id bestUp = bestUpwardPortal.Get(supernode);\n      if (noSuchElement(bestUp))\n        // flag it as an upper leaf\n        whichBranchPortal.Set(supernode, TERMINAL_ELEMENT | supernode);\n      else if (bestDownwardPortal.Get(bestUp) == supernode)\n        whichBranchPortal.Set(supernode, bestUp);\n      else\n        whichBranchPortal.Set(supernode, TERMINAL_ELEMENT | supernode);\n    } // per supernode\n\n#ifdef DEBUG_PRINT\n    std::cout << \"III. Branch Neighbours Identified\" << std::endl;\n    printHeader(whichBranch.GetNumberOfValues());\n    printIndices(\"Which Branch\", whichBranch);\n    std::cout << std::endl;\n#endif\n\n    // STAGE IV: Use pointer-doubling on whichBranch to propagate branches\n    // Compute the number of log steps required in this pass\n    vtkm::Id nLogSteps = 1;\n    for (vtkm::Id shifter = nSupernodes; shifter != 0; shifter >>= 1)\n      nLogSteps++;\n\n    // use pointer-doubling to build the branches\n    for (vtkm::Id iteration = 0; iteration < nLogSteps; iteration++)\n    { // per iteration\n      // loop through the vertices, updating the chaining array\n      for (vtkm::Id supernode = 0; supernode < nSupernodes; supernode++)\n        if (!isTerminalElement(whichBranchPortal.Get(supernode)))\n          whichBranchPortal.Set(supernode, whichBranchPortal.Get(whichBranchPortal.Get(supernode)));\n    } // per iteration\n\n#ifdef DEBUG_PRINT\n    std::cout << \"IV. Branch Chains Propagated\" << std::endl;\n    printHeader(whichBranch.GetNumberOfValues());\n    printIndices(\"Which Branch\", whichBranch);\n    std::cout << std::endl;\n#endif\n\n    // STAGE V:  Create an array of branches. To do this, first we need a temporary array storing\n    // which existing leaf corresponds to which branch.  It is possible to estimate the correct number\n    // by counting leaves, but for parallel, we'll need a compression anyway\n    // V A.  Set up the ID lookup for branches\n    vtkm::Id nBranches = 0;\n    IdArrayType chainToBranch;\n    vtkm::cont::ArrayCopy(noSuchElementArray, chainToBranch);\n    auto chainToBranchPortal = chainToBranch.GetPortalControl();\n    for (vtkm::Id supernode = 0; supernode < nSupernodes; supernode++)\n    {\n      // test whether the supernode points to itself to find the top ends\n      if (maskedIndex(whichBranchPortal.Get(supernode)) == supernode)\n      {\n        chainToBranchPortal.Set(supernode, nBranches++);\n      }\n    }\n\n    // V B.  Create the arrays for the branches\n    auto noSuchElementArrayNBranches =\n      vtkm::cont::ArrayHandleConstant<vtkm::Id>((vtkm::Id)NO_SUCH_ELEMENT, nBranches);\n    vtkm::cont::ArrayCopy(noSuchElementArrayNBranches, branchMinimum);\n    vtkm::cont::ArrayCopy(noSuchElementArrayNBranches, branchMaximum);\n    vtkm::cont::ArrayCopy(noSuchElementArrayNBranches, branchSaddle);\n    vtkm::cont::ArrayCopy(noSuchElementArrayNBranches, branchParent);\n    auto branchMinimumPortal = branchMinimum.GetPortalControl();\n    auto branchMaximumPortal = branchMaximum.GetPortalControl();\n    auto branchSaddlePortal = branchSaddle.GetPortalControl();\n    auto branchParentPortal = branchParent.GetPortalControl();\n\n#ifdef DEBUG_PRINT\n    std::cout << \"V. Branch Arrays Created\" << std::endl;\n    printHeader(chainToBranch.GetNumberOfValues());\n    printIndices(\"Chain To Branch\", chainToBranch);\n    printHeader(nBranches);\n    printIndices(\"Branch Minimum\", branchMinimum);\n    printIndices(\"Branch Maximum\", branchMaximum);\n    printIndices(\"Branch Saddle\", branchSaddle);\n    printIndices(\"Branch Parent\", branchParent);\n#endif\n    // STAGE VI:  Sort all supernodes by [whichBranch, regular index] to get the sequence along the branch\n    // Assign the upper end of the branch as an ID (for now).\n    // VI A.  Create the sorting array, then sort\n    IdArrayType supernodeSorter;\n    supernodeSorter.Allocate(nSupernodes);\n    auto supernodeSorterPortal = supernodeSorter.GetPortalControl();\n    for (vtkm::Id supernode = 0; supernode < nSupernodes; supernode++)\n    {\n      supernodeSorterPortal.Set(supernode, supernode);\n    }\n\n    vtkm::cont::Algorithm::Sort(\n      supernodeSorter,\n      process_contourtree_inc_ns::SuperNodeBranchComparator(whichBranch, contourTree.supernodes));\n    IdArrayType permutedBranches;\n    permutedBranches.Allocate(nSupernodes);\n    permuteArray<vtkm::Id>(whichBranch, supernodeSorter, permutedBranches);\n\n    IdArrayType permutedRegularID;\n    permutedRegularID.Allocate(nSupernodes);\n    permuteArray<vtkm::Id>(contourTree.supernodes, supernodeSorter, permutedRegularID);\n\n#ifdef DEBUG_PRINT\n    std::cout << \"VI A. Sorted into Branches\" << std::endl;\n    printHeader(nSupernodes);\n    printIndices(\"Supernode IDs\", supernodeSorter);\n    printIndices(\"Branch\", permutedBranches);\n    printIndices(\"Regular ID\", permutedRegularID);\n#endif\n\n    // VI B. And reset the whichBranch to use the new branch IDs\n    for (vtkm::Id supernode = 0; supernode < nSupernodes; supernode++)\n    {\n      whichBranchPortal.Set(supernode,\n                            chainToBranchPortal.Get(maskedIndex(whichBranchPortal.Get(supernode))));\n    }\n\n    // VI C.  For each segment, the highest element sets up the upper end, the lowest element sets the low end\n    for (vtkm::Id supernode = 0; supernode < nSupernodes; supernode++)\n    { // per supernode\n      // retrieve supernode & branch IDs\n      vtkm::Id supernodeID = supernodeSorterPortal.Get(supernode);\n      vtkm::Id branchID = whichBranchPortal.Get(supernodeID);\n      // save the branch ID as the owner\n      // use LHE of segment to set branch minimum\n      if (supernode == 0)\n      { // sn = 0\n        branchMinimumPortal.Set(branchID, supernodeID);\n      } // sn = 0\n      else if (branchID != whichBranchPortal.Get(supernodeSorterPortal.Get(supernode - 1)))\n      { // LHE\n        branchMinimumPortal.Set(branchID, supernodeID);\n      } // LHE\n      // use RHE of segment to set branch maximum\n      if (supernode == nSupernodes - 1)\n      { // sn = max\n        branchMaximumPortal.Set(branchID, supernodeID);\n      } // sn = max\n      else if (branchID != whichBranchPortal.Get(supernodeSorterPortal.Get(supernode + 1)))\n      { // RHE\n        branchMaximumPortal.Set(branchID, supernodeID);\n      } // RHE\n    }   // per supernode\n\n#ifdef DEBUG_PRINT\n    std::cout << \"VI. Branches Set\" << std::endl;\n    printHeader(nBranches);\n    printIndices(\"Branch Maximum\", branchMaximum);\n    printIndices(\"Branch Minimum\", branchMinimum);\n    printIndices(\"Branch Saddle\", branchSaddle);\n    printIndices(\"Branch Parent\", branchParent);\n#endif\n\n    // STAGE VII: For each branch, set its parent (initially) to NO_SUCH_ELEMENT\n    // Then test upper & lower ends of each branch (in their segments) to see whether they are leaves\n    // At most one is a leaf. In the case of the master branch, both are\n    // So, non-leaf ends set the parent branch to the branch owned by the BestUp/BestDown corresponding\n    // while leaf ends do nothing. At the end of this, the master branch still has -1 as the parent,\n    // while all other branches have their parents correctly set\n    // BTW: This is inefficient, and we need to compress down the list of branches\n    for (vtkm::Id branchID = 0; branchID < nBranches; branchID++)\n    { // per branch\n      vtkm::Id branchMax = branchMaximumPortal.Get(branchID);\n      // check whether the maximum is NOT a leaf\n      if (!noSuchElement(bestUpwardPortal.Get(branchMax)))\n      { // points to a saddle\n        branchSaddlePortal.Set(branchID, maskedIndex(bestUpwardPortal.Get(branchMax)));\n        // if not, then the bestUp points to a saddle vertex at which we join the parent\n        branchParentPortal.Set(branchID, whichBranchPortal.Get(bestUpwardPortal.Get(branchMax)));\n      } // points to a saddle\n      // now do the same with the branch minimum\n      vtkm::Id branchMin = branchMinimumPortal.Get(branchID);\n      // test whether NOT a lower leaf\n      if (!noSuchElement(bestDownwardPortal.Get(branchMin)))\n      { // points to a saddle\n        branchSaddlePortal.Set(branchID, maskedIndex(bestDownwardPortal.Get(branchMin)));\n        // if not, then the bestUp points to a saddle vertex at which we join the parent\n        branchParentPortal.Set(branchID, whichBranchPortal.Get(bestDownwardPortal.Get(branchMin)));\n      } // points to a saddle\n    }   // per branch\n\n#ifdef DEBUG_PRINT\n    std::cout << \"VII. Branches Constructed\" << std::endl;\n    printHeader(nBranches);\n    printIndices(\"Branch Maximum\", branchMaximum);\n    printIndices(\"Branch Minimum\", branchMinimum);\n    printIndices(\"Branch Saddle\", branchSaddle);\n    printIndices(\"Branch Parent\", branchParent);\n#endif\n\n  } // ComputeBranchData()\n\n  // Create branch decomposition from contour tree\n  template <typename T, typename StorageType>\n  static process_contourtree_inc_ns::Branch<T>* ComputeBranchDecomposition(\n    const IdArrayType& contourTreeSuperparents,\n    const IdArrayType& contourTreeSupernodes,\n    const IdArrayType& whichBranch,\n    const IdArrayType& branchMinimum,\n    const IdArrayType& branchMaximum,\n    const IdArrayType& branchSaddle,\n    const IdArrayType& branchParent,\n    const IdArrayType& sortOrder,\n    const vtkm::cont::ArrayHandle<T, StorageType>& dataField,\n    bool dataFieldIsSorted)\n  {\n    return process_contourtree_inc_ns::Branch<T>::ComputeBranchDecomposition(\n      contourTreeSuperparents,\n      contourTreeSupernodes,\n      whichBranch,\n      branchMinimum,\n      branchMaximum,\n      branchSaddle,\n      branchParent,\n      sortOrder,\n      dataField,\n      dataFieldIsSorted);\n  }\n\n  void static findMinMaxParallel(const IdArrayType supernodes,\n                                 const cont::ArrayHandle<Vec<Id, 2>> tourEdges,\n                                 const bool isMin,\n                                 IdArrayType minMaxIndex,\n                                 IdArrayType parents)\n  {\n    //\n    // Set up some useful portals\n    //\n    auto parentsPortal = parents.GetPortalControl();\n    auto tourEdgesPortal = tourEdges.GetPortalConstControl();\n\n    //\n    // Set initial values\n    //\n    Id root = tourEdgesPortal.Get(0)[0];\n    parentsPortal.Set(root, root);\n\n    //\n    // Find what the first and last occurence of a vertex is in the euler tour.\n    //\n    cont::ArrayHandle<vtkm::Pair<Id, Id>> firstLastVertex;\n    firstLastVertex.Allocate(supernodes.GetNumberOfValues());\n    for (int i = 0; i < firstLastVertex.GetNumberOfValues(); i++)\n    {\n      firstLastVertex.GetPortalControl().Set(\n        i, { (vtkm::Id)NO_SUCH_ELEMENT, (vtkm::Id)NO_SUCH_ELEMENT });\n    }\n\n    auto firstLastVertexPortal = firstLastVertex.GetPortalControl();\n\n    for (int i = 0; i < tourEdges.GetNumberOfValues(); i++)\n    {\n      // Forward Edge\n      if (firstLastVertexPortal.Get(tourEdgesPortal.Get(i)[1]).first == NO_SUCH_ELEMENT)\n      {\n        //printf(\"The parent of %d is %d.\\n\", tourEdges[i][1], tourEdges[i][0]);\n        parentsPortal.Set(tourEdgesPortal.Get(i)[1], tourEdgesPortal.Get(i)[0]);\n\n        //firstLastVertex[tourEdges.Get(i)[1]].first = i;\n\n        firstLastVertexPortal.Set(\n          tourEdgesPortal.Get(i)[1],\n          { i, firstLastVertexPortal.Get(tourEdgesPortal.Get(i)[1]).second });\n      }\n\n      //firstLastVertex[tourEdges.Get(i)[0]].second = i;\n      firstLastVertexPortal.Set(tourEdgesPortal.Get(i)[1],\n                                { firstLastVertexPortal.Get(tourEdgesPortal.Get(i)[1]).first, i });\n    }\n\n    firstLastVertexPortal.Set(root, { 0, supernodes.GetNumberOfValues() - 1 });\n\n    //\n    // For every vertex look at the subrray between the first and last occurence and find the min/max values in it\n    //\n    vtkm::worklet::contourtree_augmented::process_contourtree_inc::ComputeMinMaxValues\n      computeMinMax(isMin);\n\n    vtkm::cont::Invoker Invoke;\n    Invoke(computeMinMax, supernodes, firstLastVertex, tourEdges, minMaxIndex);\n  }\n\n  void static findMinMax(const IdArrayType::PortalConstControl supernodes,\n                         const cont::ArrayHandle<Vec<Id, 2>>::PortalConstControl tourEdges,\n                         const bool isMin,\n                         IdArrayType::PortalControl minMaxIndex,\n                         IdArrayType::PortalControl parents)\n  {\n    Id root = tourEdges.Get(0)[0];\n\n    struct VertexData\n    {\n      long long distance;\n      unsigned long index;\n    };\n\n    std::vector<VertexData> vertexData(static_cast<unsigned long>(supernodes.GetNumberOfValues()),\n                                       { -1, 0 });\n    for (unsigned long i = 0; i < vertexData.size(); i++)\n    {\n      vertexData[i].index = i;\n    }\n\n    parents.Set(root, root);\n    vertexData[static_cast<unsigned long>(root)].distance = 0;\n\n    for (int i = 0; i < tourEdges.GetNumberOfValues(); i++)\n    {\n      const Vec<Id, 2> e = tourEdges.Get(i);\n      if (-1 == vertexData[static_cast<unsigned long>(e[1])].distance)\n      {\n        parents.Set(e[1], e[0]);\n        vertexData[static_cast<unsigned long>(e[1])].distance =\n          vertexData[static_cast<unsigned long>(e[0])].distance + 1;\n      }\n    }\n\n    std::sort(vertexData.begin(), vertexData.end(), [](const VertexData& a, const VertexData& b) {\n      return a.distance > b.distance;\n    });\n\n    for (int i = 0; i < minMaxIndex.GetNumberOfValues(); i++)\n    {\n      minMaxIndex.Set(i, i);\n    }\n\n    for (unsigned int i = 0; i < vertexData.size(); i++)\n    {\n      Id vertex = static_cast<Id>(vertexData[i].index);\n      Id parent = parents.Get(vertex);\n\n      Id vertexValue = maskedIndex(supernodes.Get(minMaxIndex.Get(vertex)));\n      Id parentValue = maskedIndex(supernodes.Get(minMaxIndex.Get(parent)));\n\n      if ((true == isMin && vertexValue < parentValue) ||\n          (false == isMin && vertexValue > parentValue))\n      {\n        minMaxIndex.Set(parent, minMaxIndex.Get(vertex));\n      }\n    }\n  }\n\n  // routine to compute the branch decomposition by volume\n  void static ComputeHeightBranchDecomposition(const ContourTree& contourTree,\n                                               const cont::ArrayHandle<Float64> fieldValues,\n                                               const IdArrayType& ctSortOrder,\n                                               const bool useParallelMinMaxSearch,\n                                               IdArrayType& whichBranch,\n                                               IdArrayType& branchMinimum,\n                                               IdArrayType& branchMaximum,\n                                               IdArrayType& branchSaddle,\n                                               IdArrayType& branchParent)\n  { // ComputeHeightBranchDecomposition()\n\n    // Cache the number of non-root supernodes & superarcs\n    vtkm::Id nSupernodes = contourTree.supernodes.GetNumberOfValues();\n    auto noSuchElementArray =\n      vtkm::cont::ArrayHandleConstant<vtkm::Id>((vtkm::Id)NO_SUCH_ELEMENT, nSupernodes);\n\n    // STAGE I:  Find the upward and downwards weight for each superarc, and set up arrays\n    IdArrayType bestUpward;\n    IdArrayType bestDownward;\n    vtkm::cont::ArrayCopy(noSuchElementArray, bestUpward);\n    vtkm::cont::ArrayCopy(noSuchElementArray, bestDownward);\n\n    //\n    // Compute Euler Tours\n    //\n    cont::ArrayHandle<Vec<Id, 2>> minTourEdges, maxTourEdges;\n\n    minTourEdges.Allocate(2 * (nSupernodes - 1));\n    maxTourEdges.Allocate(2 * (nSupernodes - 1));\n\n    // Compute the Euler Tour\n    vtkm::worklet::contourtree_augmented::EulerTour tour;\n    tour.computeEulerTour(contourTree.superarcs.GetPortalConstControl());\n\n    // Reroot the Euler Tour at the global min\n    tour.getTourAtRoot(maskedIndex(contourTree.superparents.GetPortalConstControl().Get(0)),\n                       minTourEdges.GetPortalControl());\n\n    // Reroot the Euler Tour at the global max\n    tour.getTourAtRoot(maskedIndex(contourTree.superparents.GetPortalConstControl().Get(\n                         contourTree.nodes.GetNumberOfValues() - 1)),\n                       maxTourEdges.GetPortalControl());\n\n    //\n    // Compute Min/Max per subtree\n    //\n    IdArrayType minValues, minParents, maxValues, maxParents;\n    vtkm::cont::ArrayCopy(noSuchElementArray, minValues);\n    vtkm::cont::ArrayCopy(noSuchElementArray, minParents);\n    vtkm::cont::ArrayCopy(noSuchElementArray, maxValues);\n    vtkm::cont::ArrayCopy(noSuchElementArray, maxParents);\n\n    // Finding the min/max for every subtree can either be done in parallel or serial\n    // The parallel implementation is not work efficient and will not work well on a single/few cores\n    // This is why I have left the option to do a BFS style search in serial instead of doing an a prefix min/max for every subtree in the euler tour\n    if (false == useParallelMinMaxSearch)\n    {\n      ProcessContourTree::findMinMax(contourTree.supernodes.GetPortalConstControl(),\n                                     minTourEdges.GetPortalConstControl(),\n                                     true,\n                                     minValues.GetPortalControl(),\n                                     minParents.GetPortalControl());\n\n      ProcessContourTree::findMinMax(contourTree.supernodes.GetPortalConstControl(),\n                                     maxTourEdges.GetPortalConstControl(),\n                                     false,\n                                     maxValues.GetPortalControl(),\n                                     maxParents.GetPortalControl());\n    }\n    else\n    {\n      ProcessContourTree::findMinMaxParallel(\n        contourTree.supernodes, minTourEdges, true, minValues, minParents);\n\n      ProcessContourTree::findMinMaxParallel(\n        contourTree.supernodes, maxTourEdges, false, maxValues, maxParents);\n    }\n\n    //\n    // Compute bestUp and bestDown\n    //\n    vtkm::worklet::contourtree_augmented::process_contourtree_inc::ComputeBestUpDown\n      bestUpDownWorklet;\n\n    vtkm::cont::Invoker Invoke;\n    Invoke(bestUpDownWorklet,\n           tour.first,\n           contourTree.nodes,\n           contourTree.supernodes,\n           minValues,\n           minParents,\n           maxValues,\n           maxParents,\n           ctSortOrder,\n           tour.edges,\n           fieldValues,\n           bestUpward,  // output\n           bestDownward // output\n           );\n\n    ProcessContourTree::ComputeBranchData(contourTree,\n                                          whichBranch,\n                                          branchMinimum,\n                                          branchMaximum,\n                                          branchSaddle,\n                                          branchParent,\n                                          bestUpward,\n                                          bestDownward);\n\n  } // ComputeHeightBranchDecomposition()\n\n}; // class ProcessContourTree\n} // namespace contourtree_augmented\n} // worklet\n} // vtkm\n\n#endif\n\n", "comment_ratio": 0.2904162633107454}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n\n@interface AppDelegate : UIResponder <UIApplicationDelegate>\n\n@property (strong, nonatomic) UIWindow *window;\n\n\n@end\n\n\n", "comment_ratio": 0.3888888888888889}
{"lang": "c", "code": "//\n// Created by jiakai lian on 20/02/2016.\n//\n\n#import \"JKLOrderedDictionaryDataSource.h\"\n\n\n@interface JKLOrderedDictionaryDataSource (UICollectionViewDataSource) <UICollectionViewDataSource>\n@end\n", "comment_ratio": 0.3333333333333333}
{"lang": "c", "code": "package com.android.server.backup;\n\nusing Elastos::Droid::App::Job::IJobInfo;\nusing Elastos::Droid::App::Job::IJobParameters;\nusing Elastos::Droid::App::Job::IJobScheduler;\nusing Elastos::Droid::App::Job::IJobService;\nusing Elastos::Droid::Content::IComponentName;\nusing Elastos::Droid::Content::IContext;\n\npublic class FullBackupJob extends JobService {\n    private static const String TAG = \"FullBackupJob\";\n    private static const Boolean DEBUG = TRUE;\n\n    private static ComponentName sIdleService =\n            new ComponentName(\"android\", FullBackupJob.class->GetName());\n\n    private static const Int32 JOB_ID = 0x5038;\n\n    JobParameters mParams;\n\n    public static void Schedule(Context ctx, Int64 minDelay) {\n        JobScheduler js = (JobScheduler) ctx->GetSystemService(Context.JOB_SCHEDULER_SERVICE);\n        JobInfo.Builder builder = new JobInfo->Builder(JOB_ID, sIdleService)\n                .SetRequiresDeviceIdle(TRUE)\n                .SetRequiredNetworkType(JobInfo.NETWORK_TYPE_UNMETERED)\n                .SetRequiresCharging(TRUE);\n        if (minDelay > 0) {\n            builder->SetMinimumLatency(minDelay);\n        }\n        js->Schedule(builder->Build());\n    }\n\n    // callback from the Backup Manager Service: it's finished its work for this pass\n    CARAPI FinishBackupPass() {\n        if (mParams != NULL) {\n            JobFinished(mParams, FALSE);\n            mParams = NULL;\n        }\n    }\n\n    // ----- scheduled job interface -----\n\n    //@Override\n    public Boolean OnStartJob(JobParameters params) {\n        mParams = params;\n        BackupManagerService service = BackupManagerService->GetInstance();\n        return service->BeginFullBackup(this);\n    }\n\n    //@Override\n    public Boolean OnStopJob(JobParameters params) {\n        if (mParams != NULL) {\n            mParams = NULL;\n            BackupManagerService service = BackupManagerService->GetInstance();\n            service->EndFullBackup();\n        }\n        return FALSE;\n    }\n\n}\n\n", "comment_ratio": 0.21505376344086022}
{"lang": "c", "code": "#pragma once \n//------------------------------------------------------------------------------\n/**\n    @class Posix::PosixThreadBarrier\n    \n    Block until all thread have arrived at the barrier.\n    \n    (C) 2013-2018 Individual contributors, see AUTHORS file\n*/\n#include \"core/types.h\"\n#include \"threading/criticalsection.h\"\n#include <semaphore.h>\n\n//------------------------------------------------------------------------------\nnamespace Posix\n{\nclass PosixThreadBarrier\n{\npublic:\n    /// constructor\n    PosixThreadBarrier();\n    /// destructor\n    ~PosixThreadBarrier();\n    /// setup the object with the number of threads\n    void Setup(SizeT numThreads);\n    /// return true if the object has been setup\n    bool IsValid() const;\n    /// enter thread barrier, return false if not all threads have arrived yet\n    bool Arrive();\n    /// call after Arrive() returns false to wait for other threads\n    void Wait();\n    /// call after Arrive() returns true to resume all threads\n    void SignalContinue();\n\nprivate:\n    Threading::CriticalSection critSect;\n    long numThreads;\n    volatile long outstandingThreads;\n    sem_t* semaphore;\n    bool isValid;\n};\n\n//------------------------------------------------------------------------------\n/**\n*/\nPosixThreadBarrier::PosixThreadBarrier() :\n    numThreads(0),\n    outstandingThreads(0),\n    isValid(false)\n{\n    this->semaphore = new sem_t;\n    sem_init(this->semaphore, 0, 0);\n}\n\n//------------------------------------------------------------------------------\n/**\n*/\nPosixThreadBarrier::~PosixThreadBarrier()\n{\n    sem_destroy(this->semaphore);\n    delete this->semaphore;\n    this->semaphore = 0;\n}\n\n//------------------------------------------------------------------------------\n/**\n*/\nvoid \nPosixThreadBarrier::Setup(SizeT numThreads)\n{\n    n_assert(!this->IsValid());\n    this->numThreads = numThreads;\n    this->outstandingThreads = numThreads;\n    this->isValid = true;\n}\n\n//------------------------------------------------------------------------------\n/**\n*/\nbool \nPosixThreadBarrier::IsValid() const\n{\n    return this->isValid;\n}\n\n//------------------------------------------------------------------------------\n/**\n*/\nbool \nPosixThreadBarrier::Arrive()\n{\n    this->critSect.Enter();\n    n_assert(this->outstandingThreads > 0);\n    this->outstandingThreads--;\n    return (0 == this->outstandingThreads);\n}\n\n//------------------------------------------------------------------------------\n/**\n*/\nvoid \nPosixThreadBarrier::Wait()\n{\n    this->critSect.Leave();\n    int timeout = 2000;\n    while (timeout > 0)\n    {\n        if (0 == sem_trywait(this->semaphore))\n        {\n            return;\n        }\n        usleep(1000);\n        timeout -= 1;\n    }\n}\n\n//------------------------------------------------------------------------------\n/**\n*/\nvoid \nPosixThreadBarrier::SignalContinue()\n{\n    this->outstandingThreads = this->numThreads;\n    sem_post(this->semaphore);\n    this->critSect.Leave();\n}\n\n\n} // namespace PosiX\n\n", "comment_ratio": 0.13076923076923078}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n\n@interface CubeWhiteBoardFile : NSObject\n\n/** \u6587\u4ef6ID */\n@property (nonatomic, assign) long fileId;\n\n/** \u8d26\u53f7 */\n@property (nonatomic, strong) NSString *acount;\n\n/** \u539f\u59cb\u6587\u4ef6\u540d */\n@property (nonatomic, strong) NSString *originFileName;\n\n/** \u6587\u4ef6\u522b\u540d */\n@property (nonatomic, strong) NSString *aliasFileName;\n\n/** \u6587\u4ef6\u957f\u5ea6 */\n@property (nonatomic, assign) long length;\n\n/** \u6587\u4ef6 */\n@property (nonatomic, strong) NSData *data;\n\n/** \u6587\u4ef6\u5206\u4eab\u5730\u5740 */\n@property (nonatomic, strong) NSArray *urls;\n\n@end\n\n", "comment_ratio": 0.2}
{"lang": "c", "code": "#ifndef GD_SHAPE_HELPER_H\n#define GD_SHAPE_HELPER_H\n\n#include <PR/ultratypes.h>\n\n#include \"gd_types.h\"\n\n// data\nextern struct ObjGroup *gMarioFaceGrp;\nextern struct ObjShape *D_801A82E4;\nextern struct ObjShape *gShapeRedSpark;\nextern struct ObjShape *gShapeSilverSpark;\nextern struct ObjShape *gShapeRedStar;\nextern struct ObjShape *gShapeSilverStar;\n\n// functions\nvoid calc_face_normal(struct ObjFace *face);\nstruct ObjVertex *gd_make_vertex(f32 x, f32 y, f32 z);\nvoid add_3_vtx_to_face(struct ObjFace *face, struct ObjVertex *vtx1, struct ObjVertex *vtx2, struct ObjVertex *vtx3);\nstruct ObjShape *make_shape(s32 flag, const char *name);\nvoid scale_verts_in_shape(struct ObjShape *shape, f32 x, f32 y, f32 z);\nstruct ObjNet *make_netfromshape(struct ObjShape *shape);\nvoid animate_mario_head_gameover(struct ObjAnimator *self);\nvoid animate_mario_head_normal(struct ObjAnimator *self);\ns32 load_mario_head(void (*aniFn)(struct ObjAnimator *));\nvoid load_shapes2(void);\n\n// see bad_declarations.h\n#ifndef GD_USE_BAD_DECLARATIONS\nstruct ObjFace* make_face_with_colour(f32 r, f32 g, f32 b);\n#endif\n\n#endif // GD_SHAPE_HELPER_H\n\n", "comment_ratio": 0.11764705882352941}
{"lang": "c", "code": "#include \"sedona.h\"\n\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n\n#define PORT_NAME_FORMAT \"/dev/ttymxc%d\"\n#define HANDLE_ARRAY_LEN 128\n\n//#define DUMP_SERIAL_DATA 1\n\ntypedef struct _SerialData {\n  char name[32];\n  int hFile;\n} SerialData;\n\nint setupPort(int fd, int baudRate, int dataBits, int stopBits, int parity);\n\nint writeBytes(SerialData *pData, uint8_t *pu8Buf, int32_t nbytes);\nint readBytes(SerialData *pData, uint8_t *pu8Buf, int32_t nbytes);\n\nvoid printBytes(char *msgp, unsigned length);\n\nSerialData *pSd[HANDLE_ARRAY_LEN];\n\nCell errCell = {-2};\n\n// Set the serial parameters for the port.  If any params are bad, do\n//  nothing and return -1, otherwise return 0.\n//  int SerialPort doInit(int port, int baud, int datab, int stopb, int par, int\n//  rts)\nCell serial_SerialPort_doInit(SedonaVM *vm, Cell *params) {\n  SerialData *pData;\n  int32_t portNum = params[1].ival;\n  int32_t baudRate = params[2].ival;\n  int32_t dataBits = params[3].ival;\n  int32_t stopBits = params[4].ival;\n  int32_t parity = params[5].ival;\n  int32_t rtsLevel = params[6].ival;\n\n  //\n  // Initialize physical port here\n  //\n  if (portNum < 0 || portNum >= HANDLE_ARRAY_LEN) {\n    printf(\"Invalid port %d\\n\", portNum);\n    return negOneCell;\n  }\n\n  pData = (SerialData *)malloc(sizeof(SerialData));\n  memset(pData, 0, sizeof(SerialData));\n\n  sprintf(pData->name, PORT_NAME_FORMAT, portNum);\n  pData->hFile = open(pData->name, O_RDWR | O_NONBLOCK | O_NOCTTY | O_NDELAY);\n  if (pData->hFile == -1) {\n    printf(\"Error: Cannot open serial port %s, err=%d\\n\", pData->name, errno);\n    return negOneCell;\n  }\n\n  pSd[portNum] = pData;\n\n  setupPort(pData->hFile, baudRate, dataBits, stopBits, parity);\n\n  // Return zero if nothing went wrong\n  return zeroCell;\n}\n\n// Shut down the serial port.  Return 0 if successful.\n// int SerialPort.doClose(int port)\nCell serial_SerialPort_doClose(SedonaVM *vm, Cell *params) {\n  int32_t portNum = params[1].ival;\n  SerialData *pData = pSd[portNum];\n  //\n  // Shut down physical port here\n  //\n  printf(\"SerialPort.doClose %s on platform 'unix'.\\n\", pData->name);\n\n  close(pData->hFile);\n  free(pData);\n  pSd[portNum] = NULL;\n  return zeroCell;\n}\n\n// Read one byte from port.  Return byte value, or -1 if no byte was\n// available.  (non-blocking)\n// int  SerialPort.doRead(int port)\nCell serial_SerialPort_doRead(SedonaVM *vm, Cell *params) {\n  uint8_t ch;\n  int32_t bytesRead;\n  Cell ret;\n  int32_t portNum = params[1].ival;\n\n  bytesRead = readBytes(pSd[portNum], &ch, 1);\n\n  if (bytesRead < 0)\n    return errCell;\n\n  if (bytesRead != 1)\n    return negOneCell;\n\n  ret.ival = ch;\n  return ret;\n}\n\n// Write one byte to port.  Return -1 if any error, or 0 if successful.\n// int  SerialPort.doWrite(int port, int c)\nCell serial_SerialPort_doWrite(SedonaVM *vm, Cell *params) {\n  int32_t portNum = params[1].ival;\n  uint8_t ch = (uint8_t)params[2].ival;\n  int32_t bytesWritten;\n\n  bytesWritten = writeBytes(pSd[portNum], &ch, 1);\n  if (bytesWritten != 1)\n    return negOneCell;\n\n  return zeroCell;\n}\n\n// Read up to n bytes from port into array y.  Return number of bytes\n// read, or -1 if an error occurred.  (non-blocking)\n// int  SerialPort.doReadBytes(int port, byte[] y, int off, int len)\nCell serial_SerialPort_doReadBytes(SedonaVM *vm, Cell *params) {\n  Cell ret;\n  int32_t portNum = params[1].ival;\n  uint8_t *pu8Buf = params[2].aval;\n  int32_t off = params[3].ival;\n  int32_t nbytes = params[4].ival;\n\n  int32_t bytesRead;\n\n  pu8Buf = pu8Buf + off;\n\n  bytesRead = readBytes(pSd[portNum], pu8Buf, nbytes);\n#ifdef DUMP_SERIAL_DATA\n  if (bytesRead > 0) {\n    printf(\"Rx[%d]:\\t\", bytesRead);\n    printBytes(pu8Buf, bytesRead);\n  }\n#endif\n\n  ret.ival = bytesRead;\n  return ret;\n}\n\n// Write up to n bytes to port from array y.  Return number of bytes\n// written, or -1 if an error occurred.\n// int  SerialPort.doWriteBytes(int port, byte[] y, int off, int len)\nCell serial_SerialPort_doWriteBytes(SedonaVM *vm, Cell *params) {\n  Cell ret;\n  int32_t portNum = params[1].ival;\n  uint8_t *pu8Buf = params[2].aval;\n  int32_t off = params[3].ival;\n  int32_t nbytes = params[4].ival;\n\n  int32_t bytesWritten;\n\n  pu8Buf = pu8Buf + off;\n\n  bytesWritten = writeBytes(pSd[portNum], pu8Buf, nbytes);\n#ifdef DUMP_SERIAL_DATA\n  if (bytesWritten > 0) {\n    printf(\"Tx[%d]:\\t\", bytesWritten);\n    printBytes(pu8Buf, nbytes);\n  }\n#endif\n\n  if (bytesWritten == -1)\n    return negOneCell;\n\n  ret.ival = bytesWritten;\n  return ret;\n}\n\n// return number of bytes read\nint readBytes(SerialData *pData, uint8_t *pu8Buf, int32_t nbytes) {\n  int32_t bytesRead;\n\n  bytesRead = read(pData->hFile, pu8Buf, nbytes);\n  if (bytesRead == -1 && errno == EAGAIN)\n    bytesRead = 0;\n\n  return bytesRead;\n}\n\n// return number of bytes written -\nint writeBytes(SerialData *pData, uint8_t *pu8Buf, int32_t nbytes) {\n  int32_t bytesWritten;\n\n  bytesWritten = write(pData->hFile, pu8Buf, nbytes);\n\n  return bytesWritten;\n}\n\nvoid printBytes(char *msgp, unsigned length) {\n  unsigned i;\n\n  for (i = 0; i < length; i++) {\n    printf(\"%2.2X \", msgp[i] & 0x0ff);\n  }\n  printf(\"\\n\");\n}\n\n", "comment_ratio": 0.13432835820895522}
{"lang": "c", "code": "#pragma once\n\n#include <SDL2/SDL_keyboard.h>\n#include <SDL2/SDL_mouse.h>\n#include <SDL2/SDL_events.h>\n#include \"InputLibraryDefine.h\"\n#include <memory/Alloc.h>\n\n#define g_Input Input::GetInstance()\n\nenum INPUT_API MOUSE_BUTTON\n{\n\tMOUSE_BUTTON_LEFT\t= SDL_BUTTON_LEFT,\n\tMOUSE_BUTTON_MIDDLE\t= SDL_BUTTON_MIDDLE,\n\tMOUSE_BUTTON_RIGHT\t= SDL_BUTTON_RIGHT,\n\tMOUSE_BUTTON_4\t\t= SDL_BUTTON_X1,\n\tMOUSE_BUTTON_5\t\t= SDL_BUTTON_X2,\n};\n\nclass Input\n{\npublic:\n\tstatic INPUT_API Input*\t\tGetInstance\t\t\t( );\n\n\tINPUT_API\t\t\t\t\t~Input\t\t\t\t( );\n\n\tINPUT_API void \t\t\t\tInitialize\t\t\t( );\n\tINPUT_API void \t\t\t\tUpdate\t\t\t\t( );\n\n\tINPUT_API void \t\t\t\tHandleEvent\t\t\t( SDL_Event& event );\n\n\t\t\t\t\t\t\t\t// Returns true if keyboard key was released previous frame and pressed this frame.\n\tINPUT_API bool \t\t\t\tKeyUpDown\t\t\t( SDL_Scancode key, bool ignorePause = false ) const;\n\t\t\t\t\t\t\t\t// Returns true if keyboard key was pressed previous frame and released this frame.\n\tINPUT_API bool \t\t\t\tKeyDownUp\t\t\t( SDL_Scancode key, bool ignorePause = false ) const;\n\t\t\t\t\t\t\t\t// Returns true if keyboard key is pressed this frame.\n\tINPUT_API bool \t\t\t\tKeyDown\t\t\t\t( SDL_Scancode key, bool ignorePause = false ) const;\n\t\t\t\t\t\t\t\t// Returns true if keyboard key is released this frame.\n\tINPUT_API bool \t\t\t\tKeyUp\t\t\t\t( SDL_Scancode key, bool ignorePause = false ) const;\n\n\t\t\t\t\t\t\t\t// Returns true if mouse key was released previous frame and pressed this frame. Use MOUSE_KEY enum for input.\n\tINPUT_API bool \t\t\t\tMouseUpDown\t\t\t( unsigned int button, bool ignoreConsume = false );\n\t\t\t\t\t\t\t\t// Returns true if mouse key was pressed previous frame and released this frame. Use MOUSE_KEY enum for input.\n\tINPUT_API bool \t\t\t\tMouseDownUp\t\t\t( unsigned int button, bool ignoreConsume = false );\n\t\t\t\t\t\t\t\t// Returns true if mouse key is pressed this frame. Use MOUSE_KEY enum for input.\n\tINPUT_API bool \t\t\t\tMouseDown\t\t\t( unsigned int button );\n\t\t\t\t\t\t\t\t// Returns true if mouse key is released this frame. Use MOUSE_KEY enum for input.\n\tINPUT_API bool \t\t\t\tMouseUp\t\t\t\t( unsigned int button );\n\t\n\tINPUT_API void\t\t\t\tConsumeMouseButtons( );\n\tINPUT_API void\t\t\t\tConsumeKeys( );\n\t//void\t\t\t\t\t\tConsumeMouseDown( unsigned int button );\n\n\t\t\t\t\t\t\t\t// Change in mouse position along x-axis from previous frame to this frame.\n\tINPUT_API int \t\t\t\tGetMouseDeltaX\t\t( ) const;\n\t\t\t\t\t\t\t\t// Change in mouse position along y-axis from previous frame to this frame.\n\tINPUT_API int \t\t\t\tGetMouseDeltaY\t\t( ) const;\n\tINPUT_API int \t\t\t\tGetMousePosX\t\t( ) const;\n\tINPUT_API int \t\t\t\tGetMousePosY\t\t( ) const;\n\tINPUT_API int \t\t\t\tGetScrollX\t\t\t( bool ignorePause = false ) const;\n\tINPUT_API int \t\t\t\tGetScrollY\t\t\t( bool ignorePause = false ) const;\n\tINPUT_API bool\t\t\t\tGetMouseInsideWindow( ) const;\n\t\n\tINPUT_API void\t\t\t\tPauseKeyInput\t\t( );\n\tINPUT_API void\t\t\t\tUnPauseKeyInput\t\t( );\n\tINPUT_API bool\t\t\t\tIsPaused\t\t\t( ) const;\n\n\tINPUT_API const rVector<SDL_Scancode>& GetPressStack() const;\n\tINPUT_API rVector<SDL_Scancode>& GetEditablePressStack();\n\tINPUT_API const rVector<SDL_Scancode>& GetReleaseStack() const;\n\tINPUT_API rVector<SDL_Scancode>& GetEditableReleaseStack();\n\nprivate:\n\tconst Uint8* \t\tm_CurrentKeys \t\t= nullptr;\n\tUint8* \t\t\t\tm_PrevKeys \t\t\t= nullptr;\n\n\tint \t\t\t\tm_KeyArrayLength\t= 0;\n\tint \t\t\t\tm_MouseDeltaX\t\t= 0;\n\tint \t\t\t\tm_MouseDeltaY\t\t= 0;\n\tint \t\t\t\tm_MousePosX\t\t\t= 0;\n\tint \t\t\t\tm_MousePosY\t\t\t= 0;\n\tUint32\t\t\t\tm_CurrentMouseMask\t= 0;\n\tUint32\t\t\t\tm_PrevMouseMask\t\t= 0;\n\tint \t\t\t\tm_ScrollY \t\t\t= 0;\n\tint \t\t\t\tm_ScrollX \t\t\t= 0;\n\tbool\t\t\t\tm_MouseInsideWindow\t= true;\n\t\n\tbool\t\t\t\tm_Paused = false;\n\t\n\tbool\t\t\t\tm_ConsumedMouse = false;\n\tbool\t\t\t\tm_ConsumedKeys = false;\n\n\trVector<SDL_Scancode> m_PressStack;\n\trVector<SDL_Scancode> m_ReleaseStack;\n};\n\n", "comment_ratio": 0.11}
{"lang": "c", "code": "//\n// Created by alex on 27/05/16.\n//\n\n#ifndef METAML_BASE_H\n#define METAML_BASE_H\n\nnamespace metaMl{\n    namespace modules{\n        class AbstractModule{\n\n        };\n    }\n}\n#endif //METAML_BASE_H\n\n", "comment_ratio": 0.25}
{"lang": "c", "code": "//===== Hercules Plugin ======================================\n//= getinventorylistidx\n//===== By: ==================================================\n//= Idea by Myriad aka. EyesOfAHawk aka. [Wolfie] .... aka ... how many name does he has ?\n//= 4144 for the inventory index idea -> https://github.com/HerculesWS/Hercules/pull/2355#issuecomment-456516090\n//= Fixed by AnnieRuru\n//===== Current Version: =====================================\n//= 1.0\n//===== Compatible With: ===================================== \n//= Hercules 2019-03-01\n//===== Description: =========================================\n//= introduce getinventorylistidx, specifically meant for delitemidx and equipidx\n//===== Topic ================================================\n//= http://herc.ws/board/topic/16604-retrieve-inventory-index-getinventorylistidx-delitemidx-equipidx/\n//===== Additional Comments: =================================  \n//= 2 reasons why this is made plugin and not merge in Github\n//=   1. members might confuse which one to use, getinventorylist() or getinventorylistidx() ??\n//=   2. as Myriad stated, our inventory index can be empty, -> https://github.com/HerculesWS/Hercules/pull/2394#issuecomment-468517166\n//=      perhaps maybe after `sd->inventory` has been VECTORize, then this might have more chance getting accepted\n//============================================================\n\n#include \"common/hercules.h\"\n#include \"map/pc.h\"\n#include \"map/script.h\"\n#include \"common/HPMDataCheck.h\"\n\nHPExport struct hplugin_info pinfo = {\n\t\"getinventorylistidx\",\n\tSERVER_TYPE_MAP,\n\t\"1.0\",\n\tHPM_VERSION,\n};\n\nBUILDIN(getinventorylistidx) {\n\tstruct map_session_data *sd = script->rid2sd(st);\n\n\tif (sd == NULL)\n\t\treturn true;\n\n\tchar card_var[SCRIPT_VARNAME_LENGTH];\n\tint i, j;\n\t// Clear previous data\n\tscript->cleararray_pc(sd, \"@inventorylistidx_id\", (void*)0);\n\tscript->cleararray_pc(sd, \"@inventorylistidx_amount\", (void*)0);\n\tscript->cleararray_pc(sd, \"@inventorylistidx_equip\", (void*)0);\n\tscript->cleararray_pc(sd, \"@inventorylistidx_refine\", (void*)0);\n\tscript->cleararray_pc(sd, \"@inventorylistidx_identify\", (void*)0);\n\tscript->cleararray_pc(sd, \"@inventorylistidx_attribute\", (void*)0);\n\tfor (j = 0; j < MAX_SLOTS; j++) {\n\t\tsprintf(card_var, \"@inventorylistidx_card%d\", j + 1);\n\t\tscript->cleararray_pc(sd, card_var, (void*)0);\n\t}\n\tfor (j = 0; j < MAX_ITEM_OPTIONS; j++) {\n\t\tsprintf(card_var, \"@inventorylistidx_opt_id%d\", j + 1);\n\t\tscript->cleararray_pc(sd, card_var, (void*)0);\n\t\tsprintf(card_var, \"@inventorylistidx_opt_val%d\", j + 1);\n\t\tscript->cleararray_pc(sd, card_var, (void*)0);\n\t\tsprintf(card_var, \"@inventorylistidx_opt_param%d\", j + 1);\n\t\tscript->cleararray_pc(sd, card_var, (void*)0);\n\t}\n\tscript->cleararray_pc(sd, \"@inventorylistidx_expire\", (void*)0);\n\tscript->cleararray_pc(sd, \"@inventorylistidx_bound\", (void*)0);\n\tscript->cleararray_pc(sd, \"@inventorylistidx_canequip\", (void*)0);\n\t\n\tfor (i = 0; i < sd->status.inventorySize; i++) {\n\t\tif (sd->status.inventory[i].nameid > 0 && sd->status.inventory[i].amount > 0) {\n\t\t\tpc->setreg(sd, reference_uid(script->add_variable(\"@inventorylistidx_id\"), i), sd->status.inventory[i].nameid);\n\t\t\tpc->setreg(sd, reference_uid(script->add_variable(\"@inventorylistidx_amount\"), i), sd->status.inventory[i].amount);\n\t\t\tif(sd->status.inventory[i].equip)\n\t\t\t\tpc->setreg(sd, reference_uid(script->add_variable(\"@inventorylistidx_equip\"), i), pc->equippoint(sd,i));\n\t\t\telse\n\t\t\t\tpc->setreg(sd, reference_uid(script->add_variable(\"@inventorylistidx_equip\"), i), 0);\n\t\t\tpc->setreg(sd, reference_uid(script->add_variable(\"@inventorylistidx_refine\"), i), sd->status.inventory[i].refine);\n\t\t\tpc->setreg(sd, reference_uid(script->add_variable(\"@inventorylistidx_identify\"), i), sd->status.inventory[i].identify);\n\t\t\tpc->setreg(sd, reference_uid(script->add_variable(\"@inventorylistidx_attribute\"), i), sd->status.inventory[i].attribute);\n\t\t\tfor (j = 0; j < MAX_SLOTS; j++) {\n\t\t\t\tsprintf(card_var, \"@inventorylistidx_card%d\", j+1);\n\t\t\t\tpc->setreg(sd, reference_uid(script->add_variable(card_var), i), sd->status.inventory[i].card[j]);\n\t\t\t}\n\t\t\tfor (j = 0; j < MAX_ITEM_OPTIONS; j++) {\n\t\t\t\tsprintf(card_var, \"@inventorylistidx_opt_id%d\", j + 1);\n\t\t\t\tpc->setreg(sd, reference_uid(script->add_variable(card_var), i), sd->status.inventory[i].option[j].index);\n\t\t\t\tsprintf(card_var, \"@inventorylistidx_opt_val%d\", j + 1);\n\t\t\t\tpc->setreg(sd, reference_uid(script->add_variable(card_var), i), sd->status.inventory[i].option[j].value);\n\t\t\t\tsprintf(card_var, \"@inventorylistidx_opt_param%d\", j + 1);\n\t\t\t\tpc->setreg(sd, reference_uid(script->add_variable(card_var), i), sd->status.inventory[i].option[j].param);\n\t\t\t}\n\t\t\tpc->setreg(sd, reference_uid(script->add_variable(\"@inventorylistidx_expire\"), i), sd->status.inventory[i].expire_time);\n\t\t\tpc->setreg(sd, reference_uid(script->add_variable(\"@inventorylistidx_bound\"), i), sd->status.inventory[i].bound);\n\t\t\tpc->setreg(sd, reference_uid(script->add_variable(\"@inventorylistidx_canequip\"), i), pc->isequip(sd, i));\n\t\t}\n\t}\n\treturn true;\n}\n\nBUILDIN(delitemidx) {\n\tstruct map_session_data *sd;\n\n\tif (script_hasdata(st, 4)) {\n\t\tif ((sd = script->id2sd(st, script_getnum(st, 4))) == NULL) {\n\t\t\tst->state = END;\n\t\t\treturn true;\n\t\t}\n\t} else {\n\t\tif ((sd = script->rid2sd(st)) == NULL)\n\t\t\treturn true;\n\t}\n\n\tint i = script_getnum(st, 2);\n\tif (i < 0 || i >= sd->status.inventorySize) {\n\t\tShowError(\"buildin_delitemidx: Index (%d) should be from 0-%d.\\n\", i, sd->status.inventorySize - 1);\n\t\tst->state = END;\n\t\treturn false;\n\t}\n\n\tint amount = 0;\n\tif (script_hasdata(st, 3)) {\n\t\tif ((amount = script_getnum(st, 3)) > sd->status.inventory[i].amount)\n\t\t\tamount = sd->status.inventory[i].amount;\n\t} else {\n\t\tamount = sd->status.inventory[i].amount;\n\t}\n\n\tif (amount > 0)\n\t\tscript->buildin_delitem_delete(sd, i, &amount, true);\n\n\treturn true;\n}\n\nBUILDIN(equipidx) {\n\tstruct map_session_data *sd = script->rid2sd(st);\n\n\tif (sd == NULL)\n\t\treturn true;\n\n\tint i = script_getnum(st, 2);\n\tif (i < 0 || i >= sd->status.inventorySize) {\n\t\tShowError(\"buildin_equipidx: Index (%d) should be from 0-%d.\\n\", i, sd->status.inventorySize - 1);\n\t\treturn false;\n\t}\n\n\tif (sd->status.inventory[i].equip != 0) // item already equipped, run silently\n\t\treturn true;\n\n\tint nameid = sd->status.inventory[i].nameid;\n\tstruct item_data *idata = itemdb->exists(nameid);\n\tif (idata == NULL) {\n\t\tShowError(\"buildin_equipidx: Invalid Item ID (%d).\\n\", nameid);\n\t\treturn false;\n\t}\n\n\tif (pc->equipitem(sd, i, idata->equip) == 0) {\n\t\tShowWarning(\"buildin_equipidx: Item ID (%d) at index (%d) cannot be equipped.\\n\", nameid, i);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nHPExport void plugin_init (void) {\n\taddScriptCommand( \"getinventorylistidx\", \"\", getinventorylistidx );\n\taddScriptCommand( \"delitemidx\", \"i??\", delitemidx );\n\taddScriptCommand( \"equipidx\", \"i\", equipidx );\n}\n\n", "comment_ratio": 0.13333333333333333}
{"lang": "c", "code": "#ifndef CORE_OPTICAL_FLOW_PROCESSOR_H_\n#define CORE_OPTICAL_FLOW_PROCESSOR_H_\n\n#include <memory>\n#include <utility>\n#include <vector>\n\n#include \"opencv2/core/core.hpp\"\n\nnamespace cv {\n\nclass Mat;\n\n}  // namespace cv\n\nnamespace core {\n\nclass OpticalFlowProcessor {\n public:\n  static std::unique_ptr<OpticalFlowProcessor>\n  Create();\n  virtual ~OpticalFlowProcessor() {}\n\n  virtual std::vector<std::pair<cv::Point2d, cv::Point2d>> Process(\n      const cv::Mat& first,\n      const cv::Mat& second) const = 0;\n\n  static bool RegisterPreferences();\n};\n\n}  // namespace core\n\n#endif  // CORE_OPTICAL_FLOW_PROCESSOR_H_\n\n", "comment_ratio": 0.1794871794871795}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n#import <NYTPhotoViewer/NYTPhoto.h>\n\n@interface PhotoViewer : NSObject <NYTPhoto>\n\n@property (nonatomic) UIImage *image;\n@property (nonatomic) NSData *imageData;\n@property (nonatomic) UIImage *placeholderImage;\n@property (nonatomic) NSAttributedString *attributedCaptionTitle;\n@property (nonatomic) NSAttributedString *attributedCaptionSummary;\n@property (nonatomic) NSAttributedString *attributedCaptionCredit;\n\n\n@end\n\n", "comment_ratio": 0.30434782608695654}
{"lang": "c", "code": "// RUN: %clang_profgen -o %t -O3 %s\n// RUN: %run %t 1 2>&1 | FileCheck %s\n\n// override the version variable with a bogus version:\nunsigned long long __llvm_profile_raw_version = 10000;\nint main(int argc, const char *argv[]) {\n  if (argc < 2)\n    return 1;\n  return 0;\n}\n// CHECK: LLVM Profile Error: Runtime and instrumentation version mismatch\n\n", "comment_ratio": 0.3333333333333333}
{"lang": "c", "code": "#ifndef AST_H\n#define AST_H\n\n// AST view into a BSR tree\n\n#endif\n", "comment_ratio": 0.16666666666666666}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n\n@interface AppDelegate : UIResponder <UIApplicationDelegate>\n\n@property (strong, nonatomic) UIWindow *window;\n\n\n@end\n\n\n", "comment_ratio": 0.3888888888888889}
{"lang": "c", "code": "#pragma once\n\n#include <algorithm>  // std::min\n#include <cstdlib>\n\n#include \"parallel_skip_list/concurrent_array_allocator.h\"\n#include \"parlay/random.h\"\n#include \"utilities/cas.h\"\n\nnamespace parallel_skip_list {\n\n// This is the base implementation of a phase-concurrent skip list supporting\n// splits and joins.\n//\n// We want to be able to have derived classes that add their own data members to\n// each element of the skip list. To do this, we use the curiously recurring\n// template pattern (CRTP). By passing in the derived class through a template,\n// the skip list can hold pointers to the instances of derived class. A minimal\n// instantiation is given in the class \"parallel_skip_list::Element\".\ntemplate <typename Derived>\nclass ElementBase {\n public:\n  // Running this concurrently may lead to poor randomness in the height\n  // distribution of skip list elements.\n  ElementBase();\n  // Uses random_int as a seed to generate a random height for the element.\n  explicit ElementBase(size_t random_int);\n\n  virtual ~ElementBase();\n  ElementBase(const ElementBase&) = delete;\n  ElementBase(ElementBase&&) = delete;\n  ElementBase& operator=(const ElementBase&) = delete;\n  ElementBase& operator=(ElementBase&&) = delete;\n\n  Derived* GetPreviousElement() const;\n  Derived* GetNextElement() const;\n\n  // Returns a representative element from the list the element lives in. Two\n  // elements have the same representative element if and only if they reside in\n  // the same list.\n  //\n  // A representative element is only valid until the next `Join` or `Split`\n  // call.\n  Derived* FindRepresentative() const;\n\n  // Concatenates the list that `left` lives in to the list that `right` lives\n  // in. `left` must be the last element in its list. `right` must be the first\n  // element in its list. `left` and `right` are allowed to be in the same list,\n  // in which case joining them creates a cyclic list.\n  //\n  // May run concurrently with other `Join` calls so long as each `left` is\n  // unique and each `right` is unique.\n  static void Join(Derived* left, Derived* right);\n\n  // Split the list right after this element (so this element will be the last\n  // element in its list). Returns what was the successor to the element (the\n  // first element on the right-hand side of the split). (If `Split` is called\n  // multiple times concurrently on the same element, only one of the executions\n  // will \"succeed\", and the others will return a null pointer.)\n  //\n  // May run concurrently with other `Split` calls.\n  Derived* Split();\n\n  // Returns the height of the element.\n  size_t GetHeight() const;\n\n protected:\n  struct Neighbors {\n    Derived* prev;\n    Derived* next;\n  };\n\n  bool CASNext(int level, Derived* old_next, Derived* new_next);\n  bool CASPrev(int level, Derived* old_prev, Derived* new_prev);\n  // When called on element `v`, searches left starting from and including `v`\n  // for the first element at the next level up.\n  Derived* FindLeftParent(int level) const;\n  // When called on element `v`, searches right starting from and including `v`\n  // for the first element at the next level up.\n  Derived* FindRightParent(int level) const;\n\n  static concurrent_array_allocator::Allocator<Neighbors> neighbor_allocator_;\n  static parlay::random default_randomness_;\n\n  // neighbors_[i] holds neighbors at level i, where level 0 is the lowest level\n  // and is the level at which the list contains all elements\n  Neighbors* neighbors_;\n  int8_t height_;\n};\n\n// Basic phase-concurrent skip list. See interface of `ElementBase<T>`.\nclass Element : public ElementBase<Element> {\n public:\n  // Inherits constructors.\n  using ElementBase<Element>::ElementBase;\n\n private:\n  friend class ElementBase<Element>;\n};\n\n///////////////////////////////////////////////////////////////////////////////\n//                           Implementation below.                           //\n///////////////////////////////////////////////////////////////////////////////\n// using elektra::CAS;\nnamespace _internal {\n\nconstexpr int kMaxHeight{concurrent_array_allocator::kMaxArrayLength};\n\nint GenerateHeight(size_t random_int) {\n  int h{1};\n  // Geometric(1/2) distribution.\n  // Note: could also consider Geometric(3/4) (so 1/4 of elements go up to next\n  // level) by reading two bits at once\n  while (random_int & 1) {\n    random_int >>= 1;\n    h++;\n  }\n  return std::min(h, kMaxHeight);\n}\n\n}  // namespace _internal\n\ntemplate <typename Derived>\nconcurrent_array_allocator::Allocator<typename ElementBase<Derived>::Neighbors>\n    ElementBase<Derived>::neighbor_allocator_{};\n\ntemplate <typename Derived>\nparlay::random ElementBase<Derived>::default_randomness_{};\n\ntemplate <typename Derived>\nsize_t ElementBase<Derived>::GetHeight() const {\n  return height_;\n}\n\ntemplate <typename Derived>\nElementBase<Derived>::ElementBase() {\n  size_t random_int{default_randomness_.rand()};\n  default_randomness_ = default_randomness_.next();  // race if run concurrently\n  height_ = _internal::GenerateHeight(random_int);\n  neighbors_ = neighbor_allocator_.Allocate(height_);\n  for (int i = 0; i < height_; i++) {\n    neighbors_[i].prev = neighbors_[i].next = nullptr;\n  }\n}\n\ntemplate <typename Derived>\nElementBase<Derived>::ElementBase(size_t random_int) {\n  height_ = _internal::GenerateHeight(random_int);\n  neighbors_ = neighbor_allocator_.Allocate(height_);\n  for (int i = 0; i < height_; i++) {\n    neighbors_[i].prev = neighbors_[i].next = nullptr;\n  }\n}\n\ntemplate <typename Derived>\nElementBase<Derived>::~ElementBase() {\n  neighbor_allocator_.Free(neighbors_, height_);\n}\n\ntemplate <typename Derived>\nbool ElementBase<Derived>::CASNext(int level, Derived* old_next,\n                                   Derived* new_next) {\n  return CAS(&neighbors_[level].next, old_next, new_next);\n}\n\ntemplate <typename Derived>\nbool ElementBase<Derived>::CASPrev(int level, Derived* old_prev,\n                                   Derived* new_prev) {\n  return CAS(&neighbors_[level].prev, old_prev, new_prev);\n}\n\ntemplate <typename Derived>\nDerived* ElementBase<Derived>::GetPreviousElement() const {\n  return neighbors_[0].prev;\n}\n\ntemplate <typename Derived>\nDerived* ElementBase<Derived>::GetNextElement() const {\n  return neighbors_[0].next;\n}\n\ntemplate <typename Derived>\nDerived* ElementBase<Derived>::FindLeftParent(int level) const {\n  const Derived* current_element{static_cast<const Derived*>(this)};\n  const Derived* start_element{current_element};\n  do {\n    if (current_element->height_ > level + 1) {\n      return const_cast<Derived*>(current_element);\n    }\n    current_element = current_element->neighbors_[level].prev;\n  } while (current_element != nullptr && current_element != start_element);\n  return nullptr;\n}\n\ntemplate <typename Derived>\nDerived* ElementBase<Derived>::FindRightParent(int level) const {\n  const Derived* current_element{static_cast<const Derived*>(this)};\n  const Derived* start_element{current_element};\n  do {\n    if (current_element->height_ > level + 1) {\n      return const_cast<Derived*>(current_element);\n    }\n    current_element = current_element->neighbors_[level].next;\n  } while (current_element != nullptr && current_element != start_element);\n  return nullptr;\n}\n\ntemplate <typename Derived>\nDerived* ElementBase<Derived>::FindRepresentative() const {\n  // If the list is cyclic, return element on highest level, breaking ties in\n  // favor of the lowest address.\n  // If the list is not cyclic, then return the head element on the highest\n  // level.\n\n  const Derived* current_element{static_cast<const Derived*>(this)};\n  const Derived* seen_element{nullptr};\n  int current_level{current_element->height_ - 1};\n\n  // walk up while moving forward\n  while (current_element->neighbors_[current_level].next != nullptr &&\n         seen_element != current_element) {\n    if (seen_element == nullptr || current_element < seen_element) {\n      seen_element = current_element;\n    }\n    current_element = current_element->neighbors_[current_level].next;\n    const int top_level{current_element->height_ - 1};\n    if (current_level < top_level) {\n      current_level = top_level;\n      seen_element = nullptr;\n    }\n  }\n\n  if (seen_element == current_element) {  // list is a cycle\n    return const_cast<Derived*>(seen_element);\n  } else {\n    // walk up while moving backward\n    while (current_element->neighbors_[current_level].prev != nullptr) {\n      current_element = current_element->neighbors_[current_level].prev;\n      current_level = current_element->height_ - 1;\n    }\n    return const_cast<Derived*>(current_element);\n  }\n}\n\ntemplate <typename Derived>\nvoid ElementBase<Derived>::Join(Derived* left, Derived* right) {\n  int level{0};\n  while (left != nullptr && right != nullptr) {\n    if (left->neighbors_[level].next == nullptr &&\n        left->CASNext(level, nullptr, right)) {\n      // This CAS prevents read-write reordering of these `prev` pointers that\n      // might cause concurrent `Join`s to collectively fail to find a link to\n      // be added at a higher level.\n      right->CASPrev(level, nullptr, left);\n      left = left->FindLeftParent(level);\n      right = right->FindRightParent(level);\n      level++;\n    } else {\n      return;\n    }\n  }\n}\n\ntemplate <typename Derived>\nDerived* ElementBase<Derived>::Split() {\n  // It's tempting to set `successor = GetNextElement()` here, but we need to\n  // wait for the CAS in case multiple `Split` calls are made on the same\n  // element.\n  Derived* successor{nullptr};\n  Derived* current_element{static_cast<Derived*>(this)};\n  int level{0};\n  while (current_element != nullptr) {\n    Derived* next{current_element->neighbors_[level].next};\n    if (next != nullptr && current_element->CASNext(level, next, nullptr)) {\n      if (level == 0) {\n        successor = next;\n      }\n      // Here there's an issue with read-write reordering like in `Join`, but\n      // it's benign.  The read-write reorder in `Join` is an issue because it\n      // means we might not find a path up to the next level when we should be\n      // able to. On the other hand, this reordering might cause us to find a\n      // path up to the next level when the path has already been cut. This\n      // might cause a small amount of extra work, but it's not a correctness\n      // issue.\n      next->neighbors_[level].prev = nullptr;\n      current_element = current_element->FindLeftParent(level);\n      level++;\n    } else {\n      break;\n    }\n  }\n  return successor;\n}\n\n}  // namespace parallel_skip_list\n\n", "comment_ratio": 0.23986486486486486}
{"lang": "c", "code": "#pragma once\n#ifndef GMS_PIPELINE_H\n#define GMS_PIPELINE_H\n\n#include <tuple>\n#include <vector>\n#include <string>\n#include <sstream>\n\n#include <gms/third_party/gapbs/timer.h>\n#include <gms/third_party/gapbs/command_line.h>\n\n#include \"printer.h\"\n\n\nnamespace GMS {\n\n/**\n * @brief Pipeline to run bench. Takes a collection of functions, calls them in order and reports timings.\n * \n * The output of the functions are chained. Functions must return a tuple (an empty tuple if no output) that\n * will be used as input for the next function in the chain. Each function-execution is timed and reported at the end\n * by the printer. Outputs of the functions are not reported.\n * \n * If your time measurements are extremely sensitive or your memory requirements are very tight, it might be better\n * to use a custom benchmarking function.\n *  \n * @tparam Functions \n */\nclass Pipeline\n{\nprivate:\n\n    std::vector<std::string> _printInfos;\n\n    template<unsigned int N, unsigned int I, typename Pipeline>\n    struct PipeIt\n    {\n        template<typename Functions>\n        static void Pipe(Pipeline *pl, Functions functions)\n        {\n            auto func = std::get<I>(functions);\n            pl->LocalTimer.Start();\n            (pl->*func)();\n            //decltype(auto) result = std::apply(func, params);\n            pl->LocalTimer.Stop();\n            pl->LocalPrinter << pl->LocalTimer.Seconds();\n            PipeIt<N-1,I+1,Pipeline>::Pipe(pl, functions);\n        }\n\n        // static void Pipe(Pipeline_t& pl)\n        // {\n        //     auto func = std::get<I>(pl._pipeline);\n        //     pl.LocalTimer.Start();\n        //     func();\n        //     pl.LocalTimer.Stop();\n        //     pl.LocalPrinter << pl.LocalTimer.Seconds();\n        //     PipeIt<N-1,I+1,Pipeline_t>::Pipe(pl);\n        // }\n    };\n\n    template<unsigned int I, typename Pipeline>\n    struct PipeIt<0, I, Pipeline>\n    {\n        template<typename Functions>\n        static void Pipe(Pipeline *pl, Functions functions)\n        {}\n\n        // static void Pipe(Pipeline_t  &pl)\n        // {}\n    };\n\n    template<typename Info, typename...PrintInfos>\n    void BufferInfo(Info info, PrintInfos...printInfos)\n    {\n        std::stringstream ss;\n        ss << info;\n        _printInfos.push_back(ss.str());\n        BufferInfo(printInfos...);\n    }\n\n    void BufferInfo()\n    {}\n\npublic:\n    /**\n     * @brief Simple timer instance. Relies on std::high_resolution_clock.\n     *\n     */\n    Timer LocalTimer;\n\n    /**\n     * @brief Printer instance for output. See 'Printer' for possible configuration.\n     *\n     */\n    Printer LocalPrinter;\n\n    // constexpr Pipeline(PrintInfos... printInfos)\n    // : _printInfos(std::tuple<PrintInfos...>(printInfos...)),\n    //   LocalTimer(Timer()), LocalPrinter(Printer())\n    // {}\n    Pipeline() {}\n\n\n    /**\n     * @brief Run the pipeline with initial arguments params and additional output with printInfos\n     *\n     * @tparam Param_t\n     * @tparam PrintInfos\n     * @param cli Holds parameters for the run.\n     * @param params Arguments to the first function in the pipeline. Must be a std::tuple (which will get unpacked)\n     * @param printInfos Additional information. Must be writable to a stringstream.\n     */\n    // template<typename Param_t, typename...PrintInfos>\n    // void RunWithParams(BenchCLApp &cli, Param_t params, PrintInfos...printInfos)\n    // {\n    //     for(int i = 0; i < cli.num_trials(); i++)\n    //     {\n    //         PipeIt<std::tuple_size<std::tuple<Functions...>>::value, 0, Pipeline<Functions...>>::Pipe(*this, params);\n    //         LocalPrinter.Enqueue(printInfos...);\n    //         std::cout << LocalPrinter << std::endl;\n    //     }\n    // }\n\n    template<typename...PrintInfos>\n    void SetPrintInfo(PrintInfos...printInfos)\n    {\n        _printInfos.clear();\n        BufferInfo(printInfos...);\n    }\n\n    template<typename DerivedType, typename...Functions>\n    void Run(BenchCLApp &cli, Functions...functions)\n    {\n        std::tuple<Functions...> tfuncs(functions...);\n        for(int i = 0; i < cli.num_trials(); i++)\n        {\n            DerivedType *derived = static_cast<DerivedType*>(this);\n            PipeIt<std::tuple_size<std::tuple<Functions...>>::value, 0, DerivedType>::Pipe(derived, tfuncs);\n            for( std::string info : _printInfos)\n            {\n                LocalPrinter << info;\n            }\n            std::cout << LocalPrinter << std::endl;\n        }\n    }\n\n    template<typename DerivedType, typename...Functions>\n    void Run(const CLI::Args &args, Functions...functions)\n    {\n        std::tuple<Functions...> tfuncs(functions...);\n        for(int i = 0; i < args.num_trials; i++)\n        {\n            DerivedType *derived = static_cast<DerivedType*>(this);\n            PipeIt<std::tuple_size<std::tuple<Functions...>>::value, 0, DerivedType>::Pipe(derived, tfuncs);\n            for( std::string info : _printInfos)\n            {\n                LocalPrinter << info;\n            }\n            std::cout << LocalPrinter << std::endl;\n        }\n    }\n};\n\n} // namespace GMS\n\n#endif\n", "comment_ratio": 0.16167664670658682}
{"lang": "c", "code": "//\n// Created by Dmitriy Tseyler  on 21.07.2020.\n//\n\n#ifndef CEF_PCEFCLIENT_H\n#define CEF_PCEFCLIENT_H\n\n#include \"PCefRenderHandler.h\"\n#include \"include/cef_base.h\"\n#include \"include/cef_client.h\"\n\nclass PCefClient : public CefClient, public CefLifeSpanHandler {\n public:\n  PCefClient(const void* context, BrowserId id, PaintFn render, RectFn rect,\n             ScreenInfoFn screen_info);\n  ~PCefClient();\n  CefRefPtr<CefRenderHandler> GetRenderHandler() OVERRIDE;\n  CefRefPtr<CefLifeSpanHandler> GetLifeSpanHandler() OVERRIDE;\n  void OnAfterCreated(CefRefPtr<CefBrowser> browser) OVERRIDE;\n  bool DoClose(CefRefPtr<CefBrowser> browser) OVERRIDE;\n  void OnBeforeClose(CefRefPtr<CefBrowser> browser) OVERRIDE;\n\n private:\n  CefRefPtr<PCefRenderHandler> _handler;\n  BrowserId _id;\n  IMPLEMENT_REFCOUNTING(PCefClient);\n  DISALLOW_COPY_AND_ASSIGN(PCefClient);\n};\n\n\n#endif  // CEF_PCEFCLIENT_H\n\n", "comment_ratio": 0.125}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n\n@interface WDZFourScreenView : UIView\n/**\n \u95e8\u5e974\u4e2a\u6444\u50cf\u5934\u5217\u8868\n */\n@property (nonatomic, strong) NSArray *fourVideoList;\n\n@property (nonatomic, strong) WDZShopModel *shop;\n\n- (void)play;\n\n- (void)stop;\n\n@end\n\n", "comment_ratio": 0.2916666666666667}
{"lang": "c", "code": "#include \"stdio_impl.h\"\n//include <sys/ioctl.h>\n\nsize_t __stdout_write(FILE *f, const unsigned char *buf, size_t len)\n{\n   return __stdio_write(f, buf, len);\n}\n\n", "comment_ratio": 0.125}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n\n@class SBookController;\n@interface SyncBundleClass : NSObject {\n    /* Preference Panel */\n\n    IBOutlet NSView\t*syncPreferenceView;\n    IBOutlet id\t\tsync_sbook_deletes_addressbook;\n    IBOutlet NSTextField *sync_username;\n    IBOutlet NSTextField *sync_password;\n    IBOutlet NSTextField *sync_passphrase;\n    SBookController\t*sbc;\n}\n\n#define DEF_SBOOK_SYNC_USERNAME @\"Sync Username\"\n#define DEF_SBOOK_SYNC_PASSWORD @\"Sync Password\"\n#define DEF_SBOOK_SYNC_PASSPHRASE @\"Sync Passphrase\"\n\n\n@end\n\n", "comment_ratio": 0.2413793103448276}
{"lang": "c", "code": "#pragma once\n\n\nclass BaseWindow\n{\npublic:\n\n\tBaseWindow();\n\tvirtual ~BaseWindow() {}\n\n\tstatic LRESULT CALLBACK\tWindowProc(HWND, UINT, WPARAM, LPARAM);\n\n\tHRESULT Create(HINSTANCE hInstance);\n\tHRESULT Show(int nCmdShow);\n\n\tvirtual LRESULT OnReceiveMessage(UINT msg, WPARAM wparam, LPARAM lparam);\n\nprotected:\n\n\tHRESULT Register();\n\n\tvirtual LPCTSTR ClassName() const = 0;\n\tvirtual LPCTSTR MenuName() const { return NULL; }\n\tvirtual LPCTSTR WindowName() const = 0;\n\n\tvirtual void OnPaint() = 0;\n\n\n\tHWND\t\tm_hwnd;\n\tHINSTANCE\tm_hInstance;\n\n};\n", "comment_ratio": 0.3125}
{"lang": "c", "code": "//\n//  BDXBridgeScanCodeMethod.h\n//  BDXBridgeKit\n//\n//  Created by Lizhen Hu on 2020/8/6.\n//\n\n#import \"BDXBridgeMethod.h\"\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface BDXBridgeScanCodeMethod : BDXBridgeMethod\n\n@end\n\n@interface BDXBridgeScanCodeMethodParamModel : BDXBridgeModel\n\n@property (nonatomic, assign) BOOL cameraOnly;\n@property (nonatomic, assign) BOOL closeCurrent;\n\n@end\n\n@interface BDXBridgeScanCodeMethodResultModel : BDXBridgeModel\n\n@property (nonatomic, copy) NSString *result;\n\n@end\n\nNS_ASSUME_NONNULL_END\n\n", "comment_ratio": 0.2}
{"lang": "c", "code": "#import \"UIKit/UIKit.h\"\n#import \"AVFoundation/AVFoundation.h\"\n\n@interface Utils : NSObject\n\n+(NSMutableArray *)getQYSoundArray;\n+(NSMutableArray *)getQAYSoundArray;\n+(NSMutableArray *)getZYSoundArray;\n+(NSMutableArray *)getZAYSoundArray;\n+(NSMutableArray *)getTypeArray:(NSInteger)type arraycount:(NSInteger)count;\n+(UIColor *)getUIColorByString:(NSString *)hexcolor;\n@end\n\n", "comment_ratio": 0.3333333333333333}
{"lang": "c", "code": "#import \"SYBaseContentViewController.h\"\n\n@class SYScrolledTabBar;\n\n@interface SYScrollPageViewController : SYBaseContentViewController<UIScrollViewDelegate>\n{\n    UIScrollView* _scrollView;\n    //    UISegmentedControl* _segmentControl;\n    \n    SYScrolledTabBar* _scrolledTabBar;\n    \n    NSMutableArray* _hasLoadedTabViewControllers;\n}\n\n@property(nonatomic, readonly) NSInteger currentTabIdx;\n\n@property(nonatomic, readonly) SYScrolledTabBar* scrolledTabBar;\n\n- (NSArray *) tabBarViewControllers;\n\n- (SYBaseContentViewController *) currentTabBarViewController;\n\n- (SYBaseContentViewController *) tabBarViewControllerAtIndex:(NSInteger)index;\n\n- (CGFloat) bottomMargin;\n\n- (void) setBadgeCount:(NSInteger)count forTabIdx:(NSInteger)idx;\n- (void) setBadgeCount:(NSInteger)count forSubTabViewController:(SYBaseContentViewController *)controller;\n\n- (void) clearBadgeForTabIdx:(NSInteger)idx;\n\n- (void) selectTabAtIdx:(NSInteger)idx;\n\n@end\n\n", "comment_ratio": 0.18604651162790697}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface NSNumber (ATExt)\n\n/**\n Creates and returns an NSNumber object from a string.\n Valid format: @\"12\", @\"12.345\", @\" -0xFF\", @\" .23e99 \"...\n \n @param string  The string described an number.\n \n @return an NSNumber when parse succeed, or nil if an error occurs.\n */\n+ (nullable NSNumber *)numberWithString:(NSString *)string;\n\n@end\n\nNS_ASSUME_NONNULL_END\n\n", "comment_ratio": 0.27586206896551724}
{"lang": "c", "code": "#include \"cdefs-compat.h\"\n//__FBSDID(\"$FreeBSD: src/lib/msun/src/s_llrintf.c,v 1.1 2005/01/11 23:12:55 das Exp $\");\n\n#define type\t\tfloat\n#define\troundit\t\trintf\n#define dtype\t\tlong long\n#define\tfn\t\tllrintf\n\n#include \"s_lrint.c\"\n\n", "comment_ratio": 0.1}
{"lang": "c", "code": "//\n//  AppDelegate.h\n//  MyLoginDemo\n//\n//  Created by \u4e54\u6625\u6653 on 2021/1/25.\n//\n\n#import <UIKit/UIKit.h>\n\n@interface AppDelegate : UIResponder <UIApplicationDelegate>\n\n\n@end\n\n\n", "comment_ratio": 0.4}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n\n#import \"QuizletScope.h\"\n\ntypedef NS_ENUM(NSInteger, QuizletAccountType)\n{\n    QuizletAccountFree,\n    QuizletAccountPlus,\n    QuizletAccountTeacher,\n    QuizletAccountUnknown\n};\n\ntypedef void(^QuizletAuthCompletionSuccess)(void);\ntypedef void(^QuizletAuthCompletionFailure)(NSError *error);\n\n@interface QuizletAuth : NSObject\n\n@property (nonatomic, strong, readonly) NSString *accessToken;\n@property (nonatomic, readonly) double expiresIn;\n@property (nonatomic, readonly) QuizletScope scope;\n@property (nonatomic, strong, readonly) NSString *tokenType;\n@property (nonatomic, strong, readonly) NSString *userId;\n\n@property (nonatomic, readonly) QuizletAccountType accountType;\n@property (nonatomic, readwrite) BOOL isAuthorized;\n@property (nonatomic, strong, readwrite) QuizletAuthCompletionSuccess authSuccess;\n@property (nonatomic, strong, readwrite) QuizletAuthCompletionFailure authFailure;\n\n- (void)redirectToAuthServerWithClientID:(NSString *)clientID;\n- (void)requestTokenFromAuthServerWithClientID:(NSString *)clientID withSecretKey:(NSString *)secretKey withCode:(NSString *)code redirectURI:(NSString *)redirectURI;\n\n- (void)determineAccoutTypeFromString:(NSString *)string;\n\n@property (NS_NONATOMIC_IOSONLY, readonly, copy) NSDictionary *headerFieldsWithAccessToken;\n\n@end\n\n", "comment_ratio": 0.19148936170212766}
{"lang": "c", "code": "#pragma once\n#include \"ContentLoader.h\"\n#include <unordered_map>\n#include \"..\\Graphics\\MeshFilter.h\"\n\nclass MeshFilterLoader : public ContentLoader<MeshFilter>\n{\npublic:\n\tMeshFilterLoader(void){};\n\tvirtual ~MeshFilterLoader(void){};\n\nprotected:\n\tMeshFilter* LoadContent(const wstring& assetFile) override;\n\tvoid Destroy(MeshFilter* objToDestroy) override;\n\nprivate:\n\n\tenum MeshDataType : int\n\t{\n\t\tEND = 0,\n\t\tHEADER = 1,\n\t\tPOSITIONS = 2,\n\t\tINDICES = 3,\n\t\tNORMALS = 4,\n\t\tBINORMALS = 5,\n\t\tTANGENTS = 6,\t\t\n\t\tCOLORS = 7,\n\t\tTEXCOORDS = 8,\n\t\tBLENDINDICES = 9,\n\t\tBLENDWEIGHTS = 10,\n\t\tANIMATIONCLIPS = 11,\n\t\tSKELETON = 12\n\t};\n\nprivate:\n\t// -------------------------\n\t// Disabling default copy constructor and default \n\t// assignment operator.\n\t// -------------------------\n\tMeshFilterLoader(const MeshFilterLoader &obj);\n\tMeshFilterLoader& operator=(const MeshFilterLoader& obj);\n};\n", "comment_ratio": 0.2830188679245283}
{"lang": "c", "code": "#ifndef lldb_Host_windows_ProcessLauncherWindows_h_\n#define lldb_Host_windows_ProcessLauncherWindows_h_\n\n#include \"lldb/Host/ProcessLauncher.h\"\n#include \"lldb/Host/windows/windows.h\"\n\nnamespace lldb_private {\n\nclass ProcessLaunchInfo;\n\nclass ProcessLauncherWindows : public ProcessLauncher {\npublic:\n  HostProcess LaunchProcess(const ProcessLaunchInfo &launch_info,\n                            Status &error) override;\n\nprotected:\n  HANDLE GetStdioHandle(const ProcessLaunchInfo &launch_info, int fd);\n};\n}\n\n#endif\n\n", "comment_ratio": 0.23333333333333334}
{"lang": "c", "code": "#ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_TESTING_TEST_PAINT_ARTIFACT_H_\n#define THIRD_PARTY_BLINK_RENDERER_PLATFORM_TESTING_TEST_PAINT_ARTIFACT_H_\n\n#include <memory>\n#include \"base/memory/scoped_refptr.h\"\n#include \"third_party/blink/renderer/platform/graphics/color.h\"\n#include \"third_party/blink/renderer/platform/graphics/paint/display_item_list.h\"\n#include \"third_party/blink/renderer/platform/graphics/paint/paint_artifact.h\"\n#include \"third_party/blink/renderer/platform/graphics/paint/transform_paint_property_node.h\"\n#include \"third_party/blink/renderer/platform/wtf/allocator.h\"\n#include \"third_party/blink/renderer/platform/wtf/vector.h\"\n\nnamespace cc {\nclass Layer;\n}\n\nnamespace blink {\n\nclass ClipPaintPropertyNode;\nclass EffectPaintPropertyNode;\nclass FloatRect;\nclass PaintArtifact;\nclass TransformPaintPropertyNode;\n\n// Useful for quickly making a paint artifact in unit tests.\n// Must remain in scope while the paint artifact is used, because it owns the\n// display item clients.\n//\n// Usage:\n//   TestPaintArtifact artifact;\n//   artifact.Chunk(paintProperties)\n//       .RectDrawing(bounds, color)\n//       .RectDrawing(bounds2, color2);\n//   artifact.Chunk(otherPaintProperties)\n//       .RectDrawing(bounds3, color3);\n//   DoSomethingWithArtifact(artifact);\nclass TestPaintArtifact {\n  STACK_ALLOCATED();\n\n public:\n  TestPaintArtifact();\n  ~TestPaintArtifact();\n\n  // Add to the artifact.\n  TestPaintArtifact& Chunk(scoped_refptr<const TransformPaintPropertyNode>,\n                           scoped_refptr<const ClipPaintPropertyNode>,\n                           scoped_refptr<const EffectPaintPropertyNode>);\n  TestPaintArtifact& Chunk(const PropertyTreeState&);\n  TestPaintArtifact& RectDrawing(const FloatRect& bounds, Color);\n  TestPaintArtifact& ForeignLayer(const FloatPoint&,\n                                  const IntSize&,\n                                  scoped_refptr<cc::Layer>);\n  TestPaintArtifact& ScrollHitTest(\n      scoped_refptr<const TransformPaintPropertyNode> scroll_offset);\n  TestPaintArtifact& KnownToBeOpaque();\n\n  // Add to the artifact, with specified display item client. These are used\n  // to test incremental paint artifact updates.\n  TestPaintArtifact& Chunk(DisplayItemClient&,\n                           scoped_refptr<const TransformPaintPropertyNode>,\n                           scoped_refptr<const ClipPaintPropertyNode>,\n                           scoped_refptr<const EffectPaintPropertyNode>);\n  TestPaintArtifact& Chunk(DisplayItemClient&, const PropertyTreeState&);\n  TestPaintArtifact& RectDrawing(DisplayItemClient&,\n                                 const FloatRect& bounds,\n                                 Color);\n  TestPaintArtifact& ForeignLayer(DisplayItemClient&,\n                                  const FloatPoint&,\n                                  const IntSize&,\n                                  scoped_refptr<cc::Layer>);\n  TestPaintArtifact& ScrollHitTest(\n      DisplayItemClient&,\n      scoped_refptr<const TransformPaintPropertyNode> scroll_offset);\n\n  // Can't add more things once this is called.\n  const PaintArtifact& Build();\n\n  // Create a new display item client which is owned by this TestPaintArtifact.\n  DisplayItemClient& NewClient();\n\n  DisplayItemClient& Client(size_t) const;\n\n private:\n  class DummyRectClient;\n  Vector<std::unique_ptr<DummyRectClient>> dummy_clients_;\n\n  // Exists if m_built is false.\n  DisplayItemList display_item_list_;\n  PaintChunksAndRasterInvalidations paint_chunks_data_;\n\n  // Exists if m_built is true.\n  PaintArtifact paint_artifact_;\n\n  bool built_;\n};\n\n}  // namespace blink\n\n#endif  // THIRD_PARTY_BLINK_RENDERER_PLATFORM_TESTING_TEST_PAINT_ARTIFACT_H_\n\n", "comment_ratio": 0.23076923076923078}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n#import <Foundation/Foundation.h>\n#import <AVFoundation/AVFoundation.h>\n\n@class HJScanManager;\n\ntypedef void(^CaptureOutput)(AVCaptureOutput *captureOutput, NSArray* metadataObjects, AVCaptureConnection *connection);\ntypedef void(^CaptureOutputText)(HJScanManager *manager, NSString *message);\n\n@interface HJScanManager : NSObject\n\n+ (instancetype)instancePreview:(UIView *)preview;\n\n- (void)setOutput:(CaptureOutput)captureOutput;\n- (void)setOutputText:(CaptureOutputText)captureOutput;\n\n- (void)setup;\n- (void)shutDown;\n\n- (void)sessionStart;\n- (void)sessionStop;\n\n/**\n * \u5207\u6362\u6444\u50cf\u5934\n */\n- (void)cameraToggle;\n\n/**\n * \u662f\u5426\u4e3a\u524d\u7f6e\u6444\u50cf\u5934\n */\n@property (nonatomic, assign) BOOL isFront;\n\n@end\n\n", "comment_ratio": 0.16666666666666666}
{"lang": "c", "code": "#pragma once\n#include \"wopx_file.h\"\n#include <getopt.h>\n#include <stdio.h>\n#include <memory>\n\nenum { filesize_limit = 32 * 1024 * 1024 };\n\nstatic void display_help();\n\ntemplate <WOPx_Format F>\nstatic void textconv_file(const WOPxBankFile<F> &file);\n\ntemplate <WOPx_Format F>\nstatic void textconv_global(const WOPxBankFile<F> &file);\n\ntemplate <WOPx_Format F>\nstatic void textconv_inst(const WOPxInstrument<F> &inst);\n\ntemplate <WOPx_Format F>\nstatic void textconv_operator(unsigned no, const WOPxOperator<F> &op);\n\nstatic std::unique_ptr<uint8_t[]> file_contents(const char *path, size_t &size, size_t limit);\n\n//==============================================================================\nstruct FILE_deleter {\n    void operator()(FILE *x) const noexcept { fclose(x); }\n};\ntypedef std::unique_ptr<FILE, FILE_deleter> FILE_u;\n\n", "comment_ratio": 0.14285714285714285}
{"lang": "c", "code": "#import \"MAPointAnnotation.h\"\n\n@interface RVMANaviAnnotation : MAPointAnnotation\n{\n    long long _type;\n}\n\n@property(nonatomic) long long type; // @synthesize type=_type;\n\n@end\n\n\n", "comment_ratio": 0.3333333333333333}
{"lang": "c", "code": "#import \"NSObject.h\"\n\n@interface BMTile : NSObject\n{\n    int _height;\n    int _width;\n    float **_colorData;\n}\n\n- (_Bool)toBundle:(struct CVBundle *)arg1;\n- (void)dealloc;\n- (id)initWithWidth:(int)arg1 height:(int)arg2 data:(float **)arg3;\n\n@end\n\n\n", "comment_ratio": 0.22727272727272727}
{"lang": "c", "code": "#import \"DHImageThreeInputFilter.h\"\n\n@interface DHImageFourInputFilter : DHImageThreeInputFilter\n{\n    GPUImageFramebuffer *fourthInputFramebuffer;\n    \n    GLint filterFourthTextureCoordinateAttribute;\n    GLint filterInputTextureUniform4;\n    GPUImageRotationMode inputRotation4;\n    GLuint filterSourceTexture4;\n    CMTime fourthFrameTime;\n    \n    BOOL hasSetThirdTexture, hasReceivedFourthFrame, fourthFrameWasVideo;\n    BOOL fourthFrameCheckDisabled;\n}\n\n- (void)disableFourthFrameCheck;\n\n@end\n\n", "comment_ratio": 0.25}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n\n//! Project version number for DrawAction.\nFOUNDATION_EXPORT double DrawActionVersionNumber;\n\n//! Project version string for DrawAction.\nFOUNDATION_EXPORT const unsigned char DrawActionVersionString[];\n\n// In this header, you should import all the public headers of your framework using statements like #import <DrawAction/PublicHeader.h>\n\n\n\n", "comment_ratio": 0.15789473684210525}
{"lang": "c", "code": "#ifndef _SFUD_CFG_H_\r\n#define _SFUD_CFG_H_\r\n\r\n#define LUAT_TYPE_SPI           0\r\n#define LUAT_TYPE_SPI_DEVICE    1\r\n\r\ntypedef struct luat_sfud_flash\r\n{\r\n    int luat_spi;     // bus\r\n    void *user_data;// some user data\r\n} luat_sfud_flash_t;\r\n\r\n#define SFUD_DEBUG_MODE\r\n\r\n#define SFUD_USING_SFDP\r\n\r\n#define SFUD_USING_FLASH_INFO_TABLE\r\n\r\n#define SFUD_FLASH_DEVICE_TABLE {0}\r\n\r\n// enum {\r\n//     SFUD_XXXX_DEVICE_INDEX = 0,\r\n// };\r\n\r\n// #define SFUD_FLASH_DEVICE_TABLE                                                \\\r\n// {                                                                              \\\r\n//     [SFUD_XXXX_DEVICE_INDEX] = {.name = \"XXXX\", .spi.name = \"SPIX\"},           \\\r\n// }\r\n\r\n// #define SFUD_USING_QSPI\r\n\r\n#endif /* _SFUD_CFG_H_ */\r\n\n", "comment_ratio": 0.16393442622950818}
{"lang": "c", "code": "#ifndef C0P_PARAM_INIT_OBJECTS_SURFER__US_1O0__SURFTIMECONST_4O0__REORIENTATIONTIME_1O5_ORIENT_GROUP_MEMBER_PASSIVE_AXIS_CHOICE_H\n#define C0P_PARAM_INIT_OBJECTS_SURFER__US_1O0__SURFTIMECONST_4O0__REORIENTATIONTIME_1O5_ORIENT_GROUP_MEMBER_PASSIVE_AXIS_CHOICE_H\n#pragma once\n\n// THIS FILE SHOULD NOT BE EDITED DIRECTLY BY THE USERS.\n// THIS FILE WILL BE AUTOMATICALLY EDITED WHEN THE\n// CHOOSE COMMAND IS USED\n\n// choose your init\n#include \"core/init/objects/object/init/passive/axis/random/core.h\"\n#include \"param/init/objects/surfer__us_1o0__surftimeconst_4o0__reorientationtime_1o5/orient/group/_member/passive/axis/random/parameters.h\"\n\nnamespace c0p {\n    template<typename TypeSurferUs1O0Surftimeconst4O0Reorientationtime1O5Step>\n    using InitSurferUs1O0Surftimeconst4O0Reorientationtime1O5OrientGroupMemberPassiveAxis = InitInitPassiveAxisRandom<InitSurferUs1O0Surftimeconst4O0Reorientationtime1O5OrientGroupMemberPassiveAxisRandomParameters, TypeSurferUs1O0Surftimeconst4O0Reorientationtime1O5Step>;\n}\n\n#endif\n\n", "comment_ratio": 0.21052631578947367}
{"lang": "c", "code": "#ifndef SCRIPTLIB_INVOKER_HEADER\r\n#define SCRIPTLIB_INVOKER_HEADER\r\n\r\n#include <stl/string_fwd>\r\n\r\n#include <script/stack.h>\r\n\r\nnamespace script\r\n{\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n///\u0421\u0438\u0433\u043d\u0430\u0442\u0443\u0440\u0430 \u0448\u043b\u044e\u0437\u0430\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\nclass InvokerSignature\r\n{\r\n  public:  \r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n///\u041a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440\u044b / \u0434\u0435\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440 / \u043f\u0440\u0438\u0441\u0432\u0430\u0438\u0432\u0430\u043d\u0438\u0435\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n    InvokerSignature  ();\r\n    InvokerSignature  (const InvokerSignature&);\r\n    ~InvokerSignature ();\r\n\r\n    InvokerSignature& operator = (const InvokerSignature&);\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n///\u0422\u0438\u043f \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c\u043e\u0433\u043e \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n    const std::type_info& ResultType    () const;\r\n    void                  SetResultType (const std::type_info& type); //type \u0445\u0440\u0430\u043d\u0438\u0442\u0441\u044f \u043a\u0430\u043a \u043e\u0431\u044b\u0447\u043d\u0430\u044f \u0441\u0441\u044b\u043b\u043a\u0430\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n///\u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n    size_t ParametersCount () const;\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n///\u0422\u0438\u043f\u044b \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n    const std::type_info& ParameterType    (size_t index) const;\r\n    void                  SetParameterType (size_t index, const std::type_info& type);\r\n    \r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n///\u0414\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u0438\u0435 / \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u0435 \u0442\u0438\u043f\u043e\u0432 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n    size_t AddParameterType        (const std::type_info& type); //type \u0445\u0440\u0430\u043d\u0438\u0442\u0441\u044f \u043a\u0430\u043a \u043e\u0431\u044b\u0447\u043d\u0430\u044f \u0441\u0441\u044b\u043b\u043a\u0430\r\n    void   RemoveParameterType     (size_t index);\r\n    void   RemoveAllParameterTypes ();\r\n    \r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n///\u041f\u0440\u0438\u0432\u0435\u0434\u0435\u043d\u0438\u0435 \u043a \u0441\u0442\u0440\u043e\u043a\u0435\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n    const char* ToString () const;\r\n    \r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n///\u0421\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u0435\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n    bool operator == (const InvokerSignature&) const;\r\n    bool operator != (const InvokerSignature&) const;\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n///\u041e\u0431\u043c\u0435\u043d\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n    void Swap (InvokerSignature&);\r\n\r\n  private:\r\n    struct Impl;\r\n    Impl* impl;\r\n};\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n///\u041e\u0431\u043c\u0435\u043d\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\nvoid swap (InvokerSignature&, InvokerSignature&);\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n///\u0418\u043d\u0442\u0435\u0440\u0444\u0435\u0439\u0441 \u0448\u043b\u044e\u0437\u0430\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\nclass IInvoker\r\n{\r\n  public:\r\n    virtual ~IInvoker () {}\r\n  \r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n///\u0412\u044b\u0437\u043e\u0432 \u0448\u043b\u044e\u0437\u0430 \u0441 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 \u0432 \u0441\u0442\u0435\u043a\u0435\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n    virtual size_t operator () (IStack&) = 0;  \r\n    \r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n///\u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u0441\u0438\u0433\u043d\u0430\u0442\u0443\u0440\u044b\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n    virtual InvokerSignature GetSignature () = 0;\r\n};\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n///\u041f\u0440\u043e\u0441\u0442\u043e\u0439 \u0448\u043b\u044e\u0437 - \u0435\u0441\u0442\u044c \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u043a\u0430 \u0442\u043e\u043b\u044c\u043a\u043e \u0432\u044b\u0437\u043e\u0432\u0430 \u0441 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 \u0432 \u0441\u0442\u0435\u043a\u0435\r\n///  (\u043f\u0440\u0435\u0434\u043d\u0430\u0437\u043d\u0430\u0447\u0435\u043d \u043a\u0430\u043a \u0431\u0430\u0437\u043e\u0432\u044b\u0439 \u043a\u043b\u0430\u0441\u0441 \u0434\u043b\u044f \u043f\u0440\u043e\u0441\u0442\u044b\u0445 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0445 \u0448\u043b\u044e\u0437\u043e\u0432)\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\nclass SimpleInvoker: public IInvoker\r\n{\r\n  public:\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n///\u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u0441\u0438\u0433\u043d\u0430\u0442\u0443\u0440\u044b\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n    InvokerSignature GetSignature ();\r\n};\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n///\u0424\u0443\u043d\u043a\u0446\u0438\u044f-\u0448\u043b\u044e\u0437 \u043c\u0435\u0436\u0434\u0443 \u0441\u043a\u0440\u0438\u043f\u0442\u043e\u0432\u044b\u043c \u0434\u0432\u0438\u0436\u043a\u043e\u043c \u0438 C++ \u043a\u043e\u0434\u043e\u043c\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\nclass Invoker\r\n{\r\n  public:\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n///\u041a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440\u044b / \u0434\u0435\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440 / \u043f\u0440\u0438\u0441\u0432\u0430\u0438\u0432\u0430\u043d\u0438\u0435\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n    Invoker  ();\r\n    Invoker  (const Invoker&);\r\n    ~Invoker ();\r\n    \r\n    template <class Fn> Invoker (const Fn& first_overload_fn);\r\n    \r\n    Invoker& operator = (const Invoker&);\r\n    \r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n///\u041f\u0435\u0440\u0435\u0433\u0440\u0443\u0437\u043a\u0438\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n    size_t                  OverloadsCount    () const;\r\n    const InvokerSignature& OverloadSignature (size_t index) const;\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n///\u0414\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u0438 \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u0435 \u043f\u0435\u0440\u0435\u0433\u0440\u0443\u0437\u043e\u043a\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n    size_t AddOverload        (IInvoker* invoker); //invoker will be deleted in destructor\r\n    size_t AddOverloads       (const Invoker&);\r\n    void   RemoveOverload     (size_t index);\r\n    void   RemoveAllOverloads ();\r\n    \r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n///\u0412\u044b\u0437\u043e\u0432\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n    size_t operator () (IStack& stack) const;\r\n    size_t operator () (size_t overload_index, IStack& stack) const;\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n///\u041e\u0431\u043c\u0435\u043d\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n    void Swap (Invoker&);\r\n    \r\n  private:\r\n    void Init (IInvoker*);\r\n  \r\n    IInvoker* OverloadInvoker (size_t index) const;\r\n    \r\n  private:\r\n    struct Impl;\r\n    Impl* impl;\r\n};\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n///\u041e\u0431\u043c\u0435\u043d\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\nvoid swap (Invoker&, Invoker&);\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n///\u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043f\u0435\u0440\u0435\u0433\u0440\u0443\u0436\u0435\u043d\u043d\u043e\u0433\u043e \u0448\u043b\u044e\u0437\u0430\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\nInvoker make_invoker (const Invoker& invoker1, const Invoker& invoker2);\r\nInvoker make_invoker (const Invoker& invoker1, const Invoker& invoker2, const Invoker& invoker3);\r\nInvoker make_invoker (const Invoker& invoker1, const Invoker& invoker2, const Invoker& invoker3, const Invoker& invoker4);\r\nInvoker make_invoker (const Invoker& invoker1, const Invoker& invoker2, const Invoker& invoker3, const Invoker& invoker4,\r\n                      const Invoker& invoker5);\r\nInvoker make_invoker (const Invoker& invoker1, const Invoker& invoker2, const Invoker& invoker3, const Invoker& invoker4,\r\n                      const Invoker& invoker5, const Invoker& invoker6);\r\nInvoker make_invoker (const Invoker& invoker1, const Invoker& invoker2, const Invoker& invoker3, const Invoker& invoker4,\r\n                      const Invoker& invoker5, const Invoker& invoker6, const Invoker& invoker7);\r\nInvoker make_invoker (const Invoker& invoker1, const Invoker& invoker2, const Invoker& invoker3, const Invoker& invoker4,\r\n                      const Invoker& invoker5, const Invoker& invoker6, const Invoker& invoker7, const Invoker& invoker8);\r\nInvoker make_invoker (size_t invokers_count, const Invoker* invokers);\r\n\r\n#include <script/detail/invoker.inl>\r\n\r\n}\r\n\r\n#endif\r\n\n", "comment_ratio": 0.3924731182795699}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n#import \"VungleSDK.h\"\n\n@protocol VungleSDKNativeAds\n\n/**\n * If implemented, this will get called when the SDK has a placement that has triggered\n * a URL launch that will take the user out of the application\n * @param placement The ID of a placement which triggered the URL launch\n */\n- (void)nativeAdsPlacementWillTriggerURLLaunch:(NSString *)placement;\n\n/**\n * If implemented, this will get called when the SDK has successfully loaded an ad for\n * the specified placement\n * @param placement The ID of the placement that successfully loaded an ad\n */\n- (void)nativeAdsPlacementDidLoadAd:(NSString *)placement;\n\n/**\n * If implemented, this will get called when the SDK fails to load an ad for the\n * specified placement\n * @param placement The ID of the placement that failed to load an ad\n * @param error The NSError object containing details of the failed attempt\n */\n- (void)nativeAdsPlacement:(NSString *)placement didFailToLoadAdWithError:(NSError *)error;\n\n@end\n\n@interface VungleSDK ()\n\n@property (nonatomic, weak) id <VungleSDKNativeAds> nativeAdsDelegate;\n\n@end\n\n", "comment_ratio": 0.16279069767441862}
{"lang": "c", "code": "#ifndef hifi_InjectedAudioStream_h\n#define hifi_InjectedAudioStream_h\n\n#include <QtCore/QUuid>\n\n#include \"PositionalAudioStream.h\"\n\nclass InjectedAudioStream : public PositionalAudioStream {\npublic:\n    InjectedAudioStream(const QUuid& streamIdentifier, const bool isStereo, const InboundAudioStream::Settings& settings);\n\n    float getRadius() const { return _radius; }\n    float getAttenuationRatio() const { return _attenuationRatio; }\n\n    virtual const QUuid& getStreamIdentifier() const override { return _streamIdentifier; }\n\nprivate:\n    // disallow copying of InjectedAudioStream objects\n    InjectedAudioStream(const InjectedAudioStream&);\n    InjectedAudioStream& operator= (const InjectedAudioStream&);\n\n    AudioStreamStats getAudioStreamStats() const override;\n    int parseStreamProperties(PacketType type, const QByteArray& packetAfterSeqNum, int& numAudioSamples) override;\n\n    const QUuid _streamIdentifier;\n    float _radius;\n    float _attenuationRatio;\n};\n\n#endif // hifi_InjectedAudioStream_h\n\n", "comment_ratio": 0.2857142857142857}
{"lang": "c", "code": "#ifndef TRACKINGTYPE_H\n#define TRACKINGTYPE_H\n\n#include \"utils/NamedEnum.h\"\n\nenum class TrackingType\n{\n    NoTracking,  // Do not enable tracking at all\n    InstallTracking,  // Track that *this* install has happened\n    MachineTracking,  // Track the machine, ongoing\n    UserTracking  // Track the user, ongoing\n};\n\n// Implemented in Config.cpp\nconst NamedEnumTable< TrackingType >& trackingNames();\n\n#endif  //TRACKINGTYPE_H\n\n", "comment_ratio": 0.25925925925925924}
{"lang": "c", "code": "#ifndef MAIN_IR_DRIVER_IR_PROTOCOL_CPP_IRAIRWELL_H_\n#define MAIN_IR_DRIVER_IR_PROTOCOL_CPP_IRAIRWELL_H_\n\n#include \"IrSend.h\"\n/****************************************************************************/\n/***        Include files                                                 ***/\n/****************************************************************************/\n\n/****************************************************************************/\n/***        Macro Definitions                                             ***/\n/****************************************************************************/\n/// Native representation of a Airwell A/C message.\nunion AirwellProtocol\n{\n\tuint64_t raw; // The state of the IR remote in native IR code form.\n\tstruct\n\t{\n\t\tuint64_t : 19;\n\t\tuint64_t Temp : 4;\n\t\tuint64_t : 5;\n\t\tuint64_t Fan : 2;\n\t\tuint64_t Mode : 3;\n\t\tuint64_t PowerToggle : 1;\n\t\tuint64_t : 0;\n\t};\n};\n/****************************************************************************/\n/***        Type Definitions                                              ***/\n/****************************************************************************/\n// Constants\nconst uint64_t kAirwellKnownGoodState = 0x140500002; // Mode Fan, Speed 1, 25C\n// Temperature\nconst uint8_t kAirwellMinTemp = 16; // Celsius\nconst uint8_t kAirwellMaxTemp = 30; // Celsius\n// Fan\nconst uint8_t kAirwellFanLow = 0;\t // 0b00\nconst uint8_t kAirwellFanMedium = 1; // 0b01\nconst uint8_t kAirwellFanHigh = 2;\t // 0b10\nconst uint8_t kAirwellFanAuto = 3;\t // 0b11\n// Modes\nconst uint8_t kAirwellCool = 1; // 0b001\nconst uint8_t kAirwellHeat = 2; // 0b010\nconst uint8_t kAirwellAuto = 3; // 0b011\nconst uint8_t kAirwellDry = 4;\t// 0b100\nconst uint8_t kAirwellFan = 5;\t// 0b101\n/****************************************************************************/\n/***         Exported global functions                                     ***/\n/****************************************************************************/\nclass Ir_Airwell\n{\npublic:\n\tIr_Airwell(uint32_t frequency, uint16_t dutycycle);\n\tvirtual ~Ir_Airwell();\n\tvoid sendAirwell(const uint16_t repeat = kAirwellMinRepeats);\n\tvoid setparam(uint8_t power, uint8_t mode, uint8_t speed, uint8_t temp);\nprivate:\n    uint8_t convertFan(const stdAc::fanspeed_t speed);\n    uint8_t convertMode(const stdAc::opmode_t mode);\n\tvoid send(uint64_t data, uint16_t nbits = kAirwellBits,\n\t\t\t  uint16_t repeat = kAirwellMinRepeats);\n\n\tvoid stateReset();\n\tvoid setPowerToggle(const bool on);\n\tbool getPowerToggle() const;\n\tvoid setTemp(const uint8_t temp);\n\tuint8_t getTemp() const;\n\tvoid setFan(const uint8_t speed);\n\tuint8_t getFan() const;\n\tvoid setMode(const uint8_t mode);\n\tuint8_t getMode() const;\n\tuint64_t getRaw() const;\n\tvoid setRaw(const uint64_t state);\n\tAirwellProtocol _AirwellProtocol;\n\tIr_Send _ir_airwell_send;\n};\n#endif /* MAIN_IR_DRIVER_IR_PROTOCOL_CPP_IRAIRWELL_H_ */\n\n", "comment_ratio": 0.21428571428571427}
{"lang": "c", "code": "#ifndef _TCL_INTERFACE_\n#define _TCL_INTERFACE_\n\nnamespace ioPlacer {\n\n// LEF/DEF interface\nvoid import_lef(const char* file);\nvoid import_def(const char* file);\nvoid export_def(const char* file);\n\n// Parms interface\nvoid set_hor_metal_layer(int layer);\nint get_hor_metal_layer();\nvoid set_ver_metal_layer(int layer);\nint get_ver_metal_layer();\nvoid set_num_slots(int numSlots);\nint get_num_slots();\nvoid set_random_mode(int mode);\nint get_random_mode();\nvoid set_slots_factor(float factor);\nfloat get_slots_factor();\nvoid set_force_spread(bool force);\nbool get_force_spread();\nvoid set_usage(float usage);\nfloat get_usage();\nvoid set_usage_factor(float factor);\nfloat get_usage_factor();\nvoid set_blockages_file(const char* file);\nconst char* get_blockages_file();\nvoid add_blocked_area(long long int llx,\n                      long long int lly,\n                      long long int urx,\n                      long long int ury);\nvoid set_hor_length_extend(float length);\nvoid set_hor_length(float length);\nfloat get_hor_length();\nvoid set_ver_length_extend(float length);\nvoid set_ver_length(float length);\nfloat get_ver_length();\nvoid set_report_hpwl(bool report);\nbool get_report_hpwl();\nvoid set_interactive_mode(bool enable);\nbool is_interactive_mode();\nvoid print_all_parms();\nvoid set_num_threads(int numThreads);\nint get_num_threads();\nvoid set_rand_seed(double seed);\ndouble get_rand_seed();\nvoid set_hor_thick_multiplier(float length);\nvoid set_ver_thick_multiplier(float length);\nfloat get_ver_thick_multiplier();\nfloat get_hor_thick_multiplier();\nfloat get_hor_length_extend();\nfloat get_ver_length_extend();\nvoid set_boundaries_offset(int offset);\nvoid set_min_distance(int minDist);\n\n// flow\nvoid run_io_placement();\n\n// Reports\nint compute_io_nets_hpwl();\n\n}  // namespace ioPlacer\n#endif\n\n", "comment_ratio": 0.38613861386138615}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n\n@interface LLPMeifoView : UIView\n\n@property (weak, nonatomic) IBOutlet UIButton *leftBtn;\n@property (weak, nonatomic) IBOutlet UIButton *rightBtn;\n@property (weak, nonatomic) IBOutlet UILabel *location;\n@property (weak, nonatomic) IBOutlet UILabel *uidLb;\n@property (weak, nonatomic) IBOutlet UILabel *nickLb;\n@property (weak, nonatomic) IBOutlet UIImageView *sexImage;\n@property (weak, nonatomic) IBOutlet UIImageView *certificationIcon;\n@property (weak, nonatomic) IBOutlet UILabel *certificationDes;\n@property (weak, nonatomic) IBOutlet UILabel *goldNum;\n\n\n+(instancetype) loadInfoView;\n\n-(void) changeIconSize:(CGFloat) coefficient;\n\n-(void) changeLeftBtnImage:(UIImage*) image;\n\n-(void) changeRightBtnImage:(UIImage*) image;\n\n@end\n\n", "comment_ratio": 0.21212121212121213}
{"lang": "c", "code": "#ifndef QTIPCSERVER_H\n#define QTIPCSERVER_H\n\n// Define RNRC-Qt message queue name\n#define BITCOINURI_QUEUE_NAME \"RNRCURI\"\n\nvoid ipcScanRelay(int argc, char *argv[]);\nvoid ipcInit(int argc, char *argv[]);\n\n#endif // QTIPCSERVER_H\n\n", "comment_ratio": 0.18181818181818182}
{"lang": "c", "code": "#import \"Box2D.h\"\n#import \"b2Contact.h\"\nclass MyContactListener : public b2ContactListener\n{\npublic:\n\tMyContactListener();\n    \n    void BeginContact(b2Contact* contact);\n\tvoid EndContact(b2Contact* contact);\n};\n", "comment_ratio": 0.3888888888888889}
{"lang": "c", "code": "#pragma once\n#include \"pch.h\"\n\n//--------------------------------------------------------------------------------------\n// \n//--------------------------------------------------------------------------------------\nstruct PerObject\n{\n\tDirectX::XMFLOAT4X4 WorldInvTransposeMatrix;\n\tDirectX::XMFLOAT4X4 WorldMatrix;\n};\n\n\n\n\n\n//--------------------------------------------------------------------------------------\n// \n//--------------------------------------------------------------------------------------\nstruct PerFrame \n{\n\tDirectX::XMFLOAT4X4 ProjectionMatrix;\n\tDirectX::XMFLOAT4X4 ViewMatrix;\n\tDirectX::XMFLOAT4 CameraPosition;\n\tDirectX::XMFLOAT4 MousePosition;\n\tDirectX::XMFLOAT4 GlobalAmbient;\n\tUINT NumLights;\n};\n\n\n\n\n\n//--------------------------------------------------------------------------------------\n// \n//--------------------------------------------------------------------------------------\nstruct DepthMatrixBuffer\n{    \n\tDirectX::XMFLOAT4X4 LightViewProjectionMatrix;\n};\n\n\n\n\n\n\n//--------------------------------------------------------------------------------------\n// \n//--------------------------------------------------------------------------------------\nstruct Ray\n{\n\tsm::Vector3 origin;\n\tsm::Vector3 direction;\n};\n\n\n\n\n\n//--------------------------------------------------------------------------------------\n//\n//--------------------------------------------------------------------------------------\nstruct Light\n{\n\tDirectX::XMFLOAT4 position;\n\tDirectX::XMFLOAT4 direction;\n\tDirectX::XMFLOAT4 color;\n\tfloat specularPower;\n\tfloat shininess;\n\tfloat intensity;\n\tfloat range;\n\tUINT enabled;\n\tUINT type;\n};\n\n\n\n\n\n//--------------------------------------------------------------------------------------\n//\n//--------------------------------------------------------------------------------------\nstruct TextureResource\n{\n\tComPtr<ID3D11Texture2D> texture;\n\tComPtr<ID3D11RenderTargetView> renderTargetView;\n\tComPtr<ID3D11ShaderResourceView> shaderResourceView;\n};\n\n\n\n\n\n//--------------------------------------------------------------------------------------\n//\n//--------------------------------------------------------------------------------------\nstruct ImGuiCB\n{\n\tBOOL bPrintGPositionTexture;\n\tBOOL bPrintGDiffuseTexture;\n\tBOOL bPrintGNormalTexture;\n\tBOOL bPrintGDepthTexture;\n};\n\n\n\n\n//--------------------------------------------------------------------------------------\n//\n//--------------------------------------------------------------------------------------\nstruct Quad\n{\n\tDirectX::XMFLOAT3 position;\n\tDirectX::XMFLOAT3 normal;\n\tDirectX::XMFLOAT2 texCoord;\n};\n\n\n\n\n\n//--------------------------------------------------------------------------------------\n// \n//--------------------------------------------------------------------------------------\nstruct SimpleVertex\n{\n\tDirectX::XMFLOAT3 position;\t\t\t// 12 bytes\n\tDirectX::XMFLOAT3 normal;\t\t\t// 12 bytes\n\tDirectX::XMFLOAT2 texCoord;\t\t\t// 8 bytes\n\tDirectX::XMFLOAT3 tangent;\t\t\t// 12 bytes\n\t\t\t\t\t\t\t\t// Total: 44 bytes.\n\n\tSimpleVertex()\n\t\t: position({0.0f, 0.0f, 0.0f})\n\t\t, normal({0.0f, 0.0f, 0.0f})\n\t\t, texCoord({ 0.0f, 0.0f })\n\t\t, tangent({ 0.0f, 0.0f, 0.0f })\n\t{\n\t}\n\n\tSimpleVertex(const DirectX::XMFLOAT3& position, const DirectX::XMFLOAT3& normal, const DirectX::XMFLOAT2& texCoords, const DirectX::XMFLOAT3& tangent)\n\t{\n\t\tthis->position = position;\n\t\tthis->normal = normal;\n\t\tthis->texCoord = texCoords;\n\t\tthis->tangent = tangent;\n\t}\n};\n\n\n\n\n\n//--------------------------------------------------------------------------------------\n// \n//--------------------------------------------------------------------------------------\nstruct MeshData\n{\n\tstd::vector<DirectX::XMFLOAT3> vertices;\n\tstd::vector<DirectX::XMFLOAT3> normals;\n\tstd::vector<DirectX::XMFLOAT2> texCoords;\n\tstd::vector<DirectX::XMFLOAT3> tangents;\n\tstd::vector<DirectX::XMUINT3>  faces;\n\tstd::string mtllib;\n};\n\n\n\n\n\n//--------------------------------------------------------------------------------------\n// \n//--------------------------------------------------------------------------------------\nstruct Material\n{\n\tDirectX::XMFLOAT4 Ka;\n\tDirectX::XMFLOAT4 Kd;\n\tDirectX::XMFLOAT4 Ke;\n\tDirectX::XMFLOAT4 Ks;\n\tBOOL hasAmbientMap;\n\tBOOL hasDiffuseMap;\n\tBOOL hasEmissiveMap;\n\tBOOL hasSpecularMap;\n\tBOOL hasNormalMap;\n};\n\n", "comment_ratio": 0.20430107526881722}
{"lang": "c", "code": "//---------------------------------------------------------------------------\n#ifndef processH\n#define processH\n//---------------------------------------------------------------------------\n#define MAX_AXIS_VALUE\t\t100\n//---------------------------------------------------------------------------\n#endif\n\n", "comment_ratio": 0.375}
{"lang": "c", "code": "#ifndef SRC_DB_TIMING_TIMINGLIB_TIMINGLIB_FUNCTION_H_\n#define SRC_DB_TIMING_TIMINGLIB_TIMINGLIB_FUNCTION_H_\n\n#include <algorithm>\n#include <string>\n#include <utility>\n#include <unordered_map>\n\n#include \"db/core/object.h\"\n#include \"db/timing/timinglib/timinglib_commondef.h\"\n#include \"db/timing/timinglib/timinglib_libbuilder.h\"\n\nnamespace open_edi {\nnamespace db {\n\nclass TTerm;\n\nstruct TFuncToken {\n    std::string token;\n    bool is_operator;\n    FuncOpType op;\n};\n\nenum class TFuncConstant : unsigned char {\n    kConstantZero,\n    kConstantOne,\n    kUnknown\n};\n\nTFuncConstant operator&(const TFuncConstant& c1, const TFuncConstant& c2);\nTFuncConstant operator+(const TFuncConstant& c1, const TFuncConstant& c2);\nTFuncConstant operator^(const TFuncConstant& c1, const TFuncConstant& c2);\nTFuncConstant operator!(const TFuncConstant& c1);\n\nclass TFunction : public Object {\n  public:\n    using BaseType = Object;\n\n    /// @brief default constructor\n    TFunction();\n\n    /// @brief destructor\n    ~TFunction();\n\n    /// @brief constructor\n    TFunction(Object *owner, IndexType id);\n\n    /// @brief copy constructor\n    TFunction(TFunction const &rhs);\n\n    /// @brief move constructor\n    TFunction(TFunction &&rhs) noexcept;\n\n    /// @brief copy assignment\n    TFunction &operator=(TFunction const &rhs);\n\n    /// @brief move assignment\n    TFunction &operator=(TFunction &&rhs) noexcept;\n\n    /// @brief summarize memory usage of the object in bytes\n    IndexType memory() const;\n\n    /// set\n    void setTterm(ObjectId id);\n    void setOp(FuncOpType t);\n    void setLeft(ObjectId id);\n    void setRight(ObjectId id);\n    void setGroupId(ObjectId id);\n    void setFuncStr(const std::string &str);\n\n    /// get\n    TTerm *getTterm(void);\n    FuncOpType getOp(void);\n    TFunction *getLeft(void);\n    TFunction *getRight(void);\n    ObjectId getGroupId(void);\n    /// When timing sense is not specified, we can find it from function.\n    TimingSense getTimingSense(const TTerm* pTerm);\n\n    /// @brief output the information\n    void print(std::ostream &stream);\n    void buildExpressionTree(const std::string& str, const TTerm* related_pin, str_omap_t<std::vector<tb_namespace::TTerm *>>& bus_pin_map);\n    void buildExpressionTree(const TTerm* related_pin, str_omap_t<std::vector<tb_namespace::TTerm *>>& bus_pin_map);\n    TFuncConstant eval(std::unordered_map<TTerm*, TFuncConstant>& pin_values);\n\n  protected:\n    /// @brief copy object\n    void copy(TFunction const &rhs);\n    /// @brief move object\n    void move(TFunction &&rhs);\n    /// @brief overload output stream\n    friend OStreamBase &operator<<(OStreamBase &os, TFunction const &rhs);\n\n    static void tokenize(const std::string& func_str, std::vector<TFuncToken>& tokens);\n    //void tokenize(std::vector<TFuncToken>& tokens) const;\n    ObjectId newTFuncNode(FuncOpType op, std::string& op_char, ObjectId left, ObjectId right, ObjectId tterm);\n    ObjectId newOprandNode(TFuncToken& t, const TTerm* related_pin, str_omap_t<std::vector<tb_namespace::TTerm *>>& bus_pin_map);\n    ObjectId buildExpressionTree(std::vector<TFuncToken>& tokens, const TTerm* related_pin, str_omap_t<std::vector<tb_namespace::TTerm *>>& bus_pin_map);\n    int operatorPrecedence(const TFuncToken& t);\n\n  private:\n    SymbolIndex func_str_;\n    FuncOpType op_;\n    ObjectId tterm_;\n    ObjectId left_;\n    ObjectId right_;\n    ObjectId group_id_;\n};\n}  // namespace db\n}  // namespace open_edi\n\n#endif  // SRC_DB_TIMING_TIMINGLIB_TIMINGLIB_FUNCTION_H_\n\n", "comment_ratio": 0.15079365079365079}
{"lang": "c", "code": "#pragma once\n#include <calibu/cam/camera_crtp.h>\n#include <calibu/cam/camera_models_crtp.h>\n#include <calibu/cam/camera_crtp_interop.h>\n#include <sophus/se3.hpp>\n#include <ceres/ceres.h>\n\n/////////////////////////////////////////////////////////////////////////\ntemplate<typename CameraModel,typename Scalar=double>\nstruct ProjectionCostFunctor\n{\n  typedef Eigen::Matrix<Scalar, 2, 1> Vec2t;\n  typedef Eigen::Matrix<Scalar, 3, 1> Vec3t;\n\n  ProjectionCostFunctor(\n      const Vec3t& _pwj, // 3D point j in the world\n      const Vec2t& _zij,  // 2D image measurement of j from camera i\n      Scalar* _params\n      ) : pwj(_pwj), zij(_zij), params(_params) \n  {\n    //    t_vr = (calibu::RdfVision * calibu::RdfRobotics.inverse());\n  }\n\n  template<typename T>\n    bool operator()(\n        const T* const _t_wi,  // world pose of i'th camera\n        T* residuals\n        ) const \n    {\n      CHECK_NOTNULL(_t_wi);\n      CHECK_NOTNULL(residuals);\n\n      const Eigen::Map< const Eigen::Matrix<T,6,1> > temp(_t_wi);\n      const Sophus::SE3Group<T> t_wi = Sophus::SE3Group<T>::exp(temp);\n\n      // get point j infront of camera i\n      Eigen::Matrix<T,3,1> pij = t_wi.inverse() * pwj.template cast<T>();\n      T hij[2];\n\n      pij[0] /= pij[2];\n      pij[1] /= pij[2];\n\n      T fac = (T) 1;\n      const T param = (T) params[4];\n      if (param * param > 1e-5) {\n        const T mul2_tanw_by2 = (T)2.0 * tan(param / (T)2.0);\n        T rad = ceres::sqrt(pij[0]*pij[0] + pij[1]*pij[1]);\n        if (rad * rad < 1e-5) {\n          fac = mul2_tanw_by2 / param;\n        }\n        fac = atan(rad * mul2_tanw_by2) / (rad * param);\n      }\n\n      T pix_k[2];\n      pix_k[0] = fac * params[0] * pij[0] + params[2];\n      pix_k[1] = fac * params[1] * pij[1] + params[3];\n\n      //      r = zij - hij;\n      residuals[0] = (T)(zij(0) - pix_k[0]);\n      residuals[1] = (T)(zij(1) - pix_k[1]);\n      return true;\n    }\n\n  const Eigen::Matrix<Scalar,3,1>&  pwj; // point j in world frame\n  const Eigen::Matrix<Scalar,2,1>&  zij; // measurement of i from frame j\n  Scalar*                           params;\n};\n\n\n/////////////////////////////////////////////////////////////////////////\ntemplate<typename Scalar>\nceres::CostFunction* ProjectionCost(\n    const Eigen::Vector3d& _pwj, // 3D point j in the world\n    const Eigen::Vector2d& _zij, // 2D image measurement of j from camrea i\n    calibu::CameraInterface<Scalar>* _cam\n    )\n{\n  Scalar* _params = _cam->GetParams();\n  if( dynamic_cast<calibu::LinearCamera<Scalar>*>( _cam ) ){\n    typedef calibu::LinearCamera<Scalar> CamT;\n    return (new ceres::AutoDiffCostFunction<ProjectionCostFunctor<CamT>,2,6>(\n          new ProjectionCostFunctor<CamT>( _pwj,_zij,_params ) ) );\n  }\n  else if( dynamic_cast<calibu::FovCamera<Scalar>*>( _cam ) ){\n    typedef calibu::FovCamera<Scalar> CamT;\n    return (new ceres::AutoDiffCostFunction<ProjectionCostFunctor<CamT>,2,6>(\n          new ProjectionCostFunctor<CamT>( _pwj,_zij,_params ) ) );\n  }\n  return NULL;\n}\n\n\n", "comment_ratio": 0.13043478260869565}
{"lang": "c", "code": "#include \"scsi.h\"\r\n#include \"scsiPhy.h\"\r\n#include \"config.h\"\r\n#include \"diagnostic.h\"\r\n#include \"disk.h\"\r\n#include \"inquiry.h\"\r\n#include \"led.h\"\r\n#include \"mode.h\"\r\n#include \"time.h\"\r\n#include \"bsp.h\"\r\n#include \"cdrom.h\"\r\n//#include \"debug.h\"\r\n#include \"tape.h\"\r\n#include \"mo.h\"\r\n#include \"vendor.h\"\r\n\r\n#include <string.h>\r\n\r\n// Global SCSI device state.\r\nScsiDevice scsiDev S2S_DMA_ALIGN;\r\n\r\nstatic void enter_SelectionPhase(void);\r\nstatic void process_SelectionPhase(void);\r\nstatic void enter_BusFree(void);\r\nstatic void enter_MessageIn(uint8_t message);\r\nstatic void enter_Status(uint8_t status);\r\nstatic void enter_DataIn(int len);\r\nstatic void process_DataIn(void);\r\nstatic void process_DataOut(void);\r\nstatic void process_Command(void);\r\n\r\nstatic void doReserveRelease(void);\r\n\r\nstatic void enter_BusFree()\r\n{\r\n\t// This delay probably isn't needed for most SCSI hosts, but it won't\r\n\t// hurt either. It's possible some of the samplers needed this delay.\r\n\tif (scsiDev.compatMode < COMPAT_SCSI2)\r\n\t{\r\n\t\ts2s_delay_us(2);\r\n\t}\r\n\r\n#if 0\r\n\tif (scsiDev.status != GOOD && isDebugEnabled())\r\n\t{\r\n\t\t// We want to capture debug information for failure cases.\r\n\t\ts2s_delay_ms(64);\r\n\t}\r\n#endif\r\n\r\n\r\n\tscsiEnterBusFree();\r\n\r\n\t// Wait for the initiator to cease driving signals\r\n\t// Bus settle delay + bus clear delay = 1200ns\r\n\ts2s_delay_us(2);\r\n\r\n\r\n\ts2s_ledOff();\r\n\tscsiDev.phase = BUS_FREE;\r\n\tscsiDev.selFlag = 0;\r\n}\r\n\r\nstatic void enter_MessageIn(uint8_t message)\r\n{\r\n\tscsiDev.msgIn = message;\r\n\tscsiDev.phase = MESSAGE_IN;\r\n}\r\n\r\nvoid process_MessageIn()\r\n{\r\n\tscsiEnterPhase(MESSAGE_IN);\r\n\tscsiWriteByte(scsiDev.msgIn);\r\n\r\n\tif (unlikely(scsiDev.atnFlag))\r\n\t{\r\n\t\t// If there was a parity error, we go\r\n\t\t// back to MESSAGE_OUT first, get out parity error message, then come\r\n\t\t// back here.\r\n\t}\r\n\telse if ((scsiDev.msgIn == MSG_LINKED_COMMAND_COMPLETE) ||\r\n\t\t(scsiDev.msgIn == MSG_LINKED_COMMAND_COMPLETE_WITH_FLAG))\r\n\t{\r\n\t\t// Go back to the command phase and start again.\r\n\t\tscsiDev.phase = COMMAND;\r\n\t\tscsiDev.dataPtr = 0;\r\n\t\tscsiDev.savedDataPtr = 0;\r\n\t\tscsiDev.dataLen = 0;\r\n\t\tscsiDev.status = GOOD;\r\n\t\ttransfer.blocks = 0;\r\n\t\ttransfer.currentBlock = 0;\r\n\t}\r\n\telse /*if (scsiDev.msgIn == MSG_COMMAND_COMPLETE)*/\r\n\t{\r\n\t\tenter_BusFree();\r\n\t}\r\n}\r\n\r\nstatic void messageReject()\r\n{\r\n\tscsiEnterPhase(MESSAGE_IN);\r\n\tscsiWriteByte(MSG_REJECT);\r\n}\r\n\r\nstatic void enter_Status(uint8_t status)\r\n{\r\n\tscsiDev.status = status;\r\n\tscsiDev.phase = STATUS;\r\n\r\n\tscsiDev.lastStatus = scsiDev.status;\r\n\tscsiDev.lastSense = scsiDev.target->sense.code;\r\n\tscsiDev.lastSenseASC = scsiDev.target->sense.asc;\r\n}\r\n\r\nvoid process_Status()\r\n{\r\n\tscsiEnterPhase(STATUS);\r\n\r\n\tuint8_t message;\r\n\r\n\tuint8_t control = scsiDev.cdb[scsiDev.cdbLen - 1];\r\n\r\n\tif (scsiDev.target->cfg->quirks == S2S_CFG_QUIRKS_OMTI)\r\n\t{\r\n\t\t// OMTI non-standard LINK control\r\n\t\tif (control & 0x01)\r\n\t\t{\r\n\t\t\tscsiDev.phase = COMMAND;\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\r\n\tif ((scsiDev.status == GOOD) && (control & 0x01))\r\n\t{\r\n\t\t// Linked command.\r\n\t\tscsiDev.status = INTERMEDIATE;\r\n\t\tif (control & 0x02)\r\n\t\t{\r\n\t\t\tmessage = MSG_LINKED_COMMAND_COMPLETE_WITH_FLAG;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tmessage = MSG_LINKED_COMMAND_COMPLETE;\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tmessage = MSG_COMMAND_COMPLETE;\r\n\t}\r\n\r\n\tif (scsiDev.target->cfg->quirks == S2S_CFG_QUIRKS_OMTI)\r\n\t{\r\n\t\tscsiDev.status |= (scsiDev.target->targetId & 0x03) << 5;\r\n\t}\r\n\r\n\tscsiWriteByte(scsiDev.status);\r\n\r\n\tscsiDev.lastStatus = scsiDev.status;\r\n\tscsiDev.lastSense = scsiDev.target->sense.code;\r\n\tscsiDev.lastSenseASC = scsiDev.target->sense.asc;\r\n\r\n\t// Command Complete occurs AFTER a valid status has been\r\n\t// sent. then we go bus-free.\r\n\tenter_MessageIn(message);\r\n}\r\n\r\nstatic void enter_DataIn(int len)\r\n{\r\n\tscsiDev.dataLen = len;\r\n\tscsiDev.phase = DATA_IN;\r\n}\r\n\r\nstatic void process_DataIn()\r\n{\r\n\tuint32_t len;\r\n\r\n\tif (scsiDev.dataLen > sizeof(scsiDev.data))\r\n\t{\r\n\t\tscsiDev.dataLen = sizeof(scsiDev.data);\r\n\t}\r\n\r\n\tlen = scsiDev.dataLen - scsiDev.dataPtr;\r\n\tif (len > 0)\r\n\t{\r\n\t\tscsiEnterPhase(DATA_IN);\r\n\t\tscsiWrite(scsiDev.data + scsiDev.dataPtr, len);\r\n\t\tscsiDev.dataPtr += len;\r\n\t}\r\n\r\n\tif ((scsiDev.dataPtr >= scsiDev.dataLen) &&\r\n\t\t(transfer.currentBlock == transfer.blocks))\r\n\t{\r\n\t\tenter_Status(GOOD);\r\n\t}\r\n}\r\n\r\nstatic void process_DataOut()\r\n{\r\n\tuint32_t len;\r\n\r\n\tif (scsiDev.dataLen > sizeof(scsiDev.data))\r\n\t{\r\n\t\tscsiDev.dataLen = sizeof(scsiDev.data);\r\n\t}\r\n\r\n\tlen = scsiDev.dataLen - scsiDev.dataPtr;\r\n\tif (len > 0)\r\n\t{\r\n\t\tscsiEnterPhase(DATA_OUT);\r\n\r\n\t\tint parityError = 0;\r\n\t\tscsiRead(scsiDev.data + scsiDev.dataPtr, len, &parityError);\r\n\t\tscsiDev.dataPtr += len;\r\n\r\n\t\tif (parityError &&\r\n\t\t\t(scsiDev.boardCfg.flags & S2S_CFG_ENABLE_PARITY))\r\n\t\t{\r\n\t\t\tscsiDev.target->sense.code = ABORTED_COMMAND;\r\n\t\t\tscsiDev.target->sense.asc = SCSI_PARITY_ERROR;\r\n\t\t\tenter_Status(CHECK_CONDITION);\r\n\t\t}\r\n\t}\r\n\r\n\tif ((scsiDev.dataPtr >= scsiDev.dataLen) &&\r\n\t\t(transfer.currentBlock == transfer.blocks))\r\n\t{\r\n\t\tif (scsiDev.postDataOutHook != NULL)\r\n\t\t{\r\n\t\t\tscsiDev.postDataOutHook();\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tenter_Status(GOOD);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nstatic const uint8_t CmdGroupBytes[8] = {6, 10, 10, 6, 6, 12, 6, 6};\r\nstatic void process_Command()\r\n{\r\n\tint group;\r\n\tuint8_t command;\r\n\tuint8_t control;\r\n\r\n\tscsiEnterPhase(COMMAND);\r\n\r\n\tmemset(scsiDev.cdb + 6, 0, sizeof(scsiDev.cdb) - 6);\r\n\tint parityError = 0;\r\n\tscsiRead(scsiDev.cdb, 6, &parityError);\r\n\r\n\tgroup = scsiDev.cdb[0] >> 5;\r\n\tscsiDev.cdbLen = CmdGroupBytes[group];\r\n\tif (parityError &&\r\n\t\t(scsiDev.boardCfg.flags & S2S_CFG_ENABLE_PARITY))\r\n\t{\r\n\t\t// Don't try and read more bytes, as we cannot be sure what group\r\n\t\t// the command should be.\r\n\t}\r\n\telse if (scsiDev.cdbLen - 6 > 0)\r\n\t{\r\n\t\tscsiRead(scsiDev.cdb + 6, scsiDev.cdbLen - 6, &parityError);\r\n\t}\r\n\r\n\tcommand = scsiDev.cdb[0];\r\n\r\n\t// Prefer LUN's set by IDENTIFY messages for newer hosts.\r\n\tif (scsiDev.lun < 0)\r\n\t{\r\n\t\tscsiDev.lun = scsiDev.cdb[1] >> 5;\r\n\t}\r\n\r\n\tcontrol = scsiDev.cdb[scsiDev.cdbLen - 1];\r\n\r\n\tscsiDev.cmdCount++;\r\n\tconst S2S_TargetCfg* cfg = scsiDev.target->cfg;\r\n\r\n\tif (unlikely(scsiDev.resetFlag))\r\n\t{\r\n\t\t// Don't log bogus commands\r\n\t\tscsiDev.cmdCount--;\r\n\t\tmemset(scsiDev.cdb, 0xff, sizeof(scsiDev.cdb));\r\n\t\treturn;\r\n\t}\r\n\telse if (parityError &&\r\n\t\t(scsiDev.boardCfg.flags & S2S_CFG_ENABLE_PARITY))\r\n\t{\r\n\t\tscsiDev.target->sense.code = ABORTED_COMMAND;\r\n\t\tscsiDev.target->sense.asc = SCSI_PARITY_ERROR;\r\n\t\tenter_Status(CHECK_CONDITION);\r\n\t}\r\n\telse if ((control & 0x02) && ((control & 0x01) == 0))\r\n\t{\r\n\t\t// FLAG set without LINK flag.\r\n\t\tscsiDev.target->sense.code = ILLEGAL_REQUEST;\r\n\t\tscsiDev.target->sense.asc = INVALID_FIELD_IN_CDB;\r\n\t\tenter_Status(CHECK_CONDITION);\r\n\t}\r\n\telse if (command == 0x12)\r\n\t{\r\n\t\ts2s_scsiInquiry();\r\n\t}\r\n\telse if (command == 0x03)\r\n\t{\r\n\t\t// REQUEST SENSE\r\n\t\tuint32_t allocLength = scsiDev.cdb[4];\r\n\r\n\t\t// As specified by the SASI and SCSI1 standard.\r\n\t\t// Newer initiators won't be specifying 0 anyway.\r\n\t\tif (allocLength == 0) allocLength = 4;\r\n\r\n\t\tmemset(scsiDev.data, 0, 256); // Max possible alloc length\r\n\t\tscsiDev.data[0] = 0xF0;\r\n\t\tscsiDev.data[2] = scsiDev.target->sense.code & 0x0F;\r\n\r\n\t\tscsiDev.data[3] = transfer.lba >> 24;\r\n\t\tscsiDev.data[4] = transfer.lba >> 16;\r\n\t\tscsiDev.data[5] = transfer.lba >> 8;\r\n\t\tscsiDev.data[6] = transfer.lba;\r\n\r\n\t\t// Additional bytes if there are errors to report\r\n\t\tscsiDev.data[7] = 10; // additional length\r\n\t\tscsiDev.data[12] = scsiDev.target->sense.asc >> 8;\r\n\t\tscsiDev.data[13] = scsiDev.target->sense.asc;\r\n\r\n\t\t// Silently truncate results. SCSI-2 spec 8.2.14.\r\n\t\tenter_DataIn(allocLength);\r\n\r\n\t\t// This is a good time to clear out old sense information.\r\n\t\tscsiDev.target->sense.code = NO_SENSE;\r\n\t\tscsiDev.target->sense.asc = NO_ADDITIONAL_SENSE_INFORMATION;\r\n\t}\r\n\t// Some old SCSI drivers do NOT properly support\r\n\t// unitAttention. eg. the Mac Plus would trigger a SCSI reset\r\n\t// on receiving the unit attention response on boot, thus\r\n\t// triggering another unit attention condition.\r\n\telse if (scsiDev.target->unitAttention &&\r\n\t\t(scsiDev.boardCfg.flags & S2S_CFG_ENABLE_UNIT_ATTENTION))\r\n\t{\r\n\t\tscsiDev.target->sense.code = UNIT_ATTENTION;\r\n\t\tscsiDev.target->sense.asc = scsiDev.target->unitAttention;\r\n\r\n\t\t// If initiator doesn't do REQUEST SENSE for the next command, then\r\n\t\t// data is lost.\r\n\t\tscsiDev.target->unitAttention = 0;\r\n\r\n\t\tenter_Status(CHECK_CONDITION);\r\n\t}\r\n\telse if (scsiDev.lun)\r\n\t{\r\n\t\tscsiDev.target->sense.code = ILLEGAL_REQUEST;\r\n\t\tscsiDev.target->sense.asc = LOGICAL_UNIT_NOT_SUPPORTED;\r\n\t\tenter_Status(CHECK_CONDITION);\r\n\t}\r\n\telse if (command == 0x17 || command == 0x16)\r\n\t{\r\n\t\tdoReserveRelease();\r\n\t}\r\n\telse if ((scsiDev.target->reservedId >= 0) &&\r\n\t\t(scsiDev.target->reservedId != scsiDev.initiatorId))\r\n\t{\r\n\t\tenter_Status(CONFLICT);\r\n\t}\r\n\t// Handle odd device types first that may override basic read and\r\n\t// write commands. Will fall-through to generic disk handling.\r\n\telse if (((cfg->deviceType == S2S_CFG_OPTICAL) && scsiCDRomCommand()) ||\r\n\t\t((cfg->deviceType == S2S_CFG_SEQUENTIAL) && scsiTapeCommand()) ||\r\n\t\t((cfg->deviceType == S2S_CFG_MO) && scsiMOCommand()))\r\n\t{\r\n\t\t// Already handled.\r\n\t}\r\n\telse if (scsiDiskCommand())\r\n\t{\r\n\t\t// Already handled.\r\n\t\t// check for the performance-critical read/write\r\n\t\t// commands ASAP.\r\n\t}\r\n\telse if (command == 0x1C)\r\n\t{\r\n\t\tscsiReceiveDiagnostic();\r\n\t}\r\n\telse if (command == 0x1D)\r\n\t{\r\n\t\tscsiSendDiagnostic();\r\n\t}\r\n\telse if (command == 0x3B)\r\n\t{\r\n\t\tscsiWriteBuffer();\r\n\t}\r\n\telse if (command == 0x3C)\r\n\t{\r\n\t\tscsiReadBuffer();\r\n\t}\r\n\telse if (!scsiModeCommand() && !scsiVendorCommand())\r\n\t{\r\n\t\tscsiDev.target->sense.code = ILLEGAL_REQUEST;\r\n\t\tscsiDev.target->sense.asc = INVALID_COMMAND_OPERATION_CODE;\r\n\t\tenter_Status(CHECK_CONDITION);\r\n\t}\r\n\r\n\t// Successful\r\n\tif (scsiDev.phase == COMMAND) // No status set, and not in DATA_IN\r\n\t{\r\n\t\tenter_Status(GOOD);\r\n\t}\r\n\r\n}\r\n\r\nstatic void doReserveRelease()\r\n{\r\n\tint extentReservation = scsiDev.cdb[1] & 1;\r\n\tint thirdPty = scsiDev.cdb[1] & 0x10;\r\n\tint thirdPtyId = (scsiDev.cdb[1] >> 1) & 0x7;\r\n\tuint8_t command = scsiDev.cdb[0];\r\n\r\n\tint canRelease =\r\n\t\t(!thirdPty && (scsiDev.initiatorId == scsiDev.target->reservedId)) ||\r\n\t\t\t(thirdPty &&\r\n\t\t\t\t(scsiDev.target->reserverId == scsiDev.initiatorId) &&\r\n\t\t\t\t(scsiDev.target->reservedId == thirdPtyId)\r\n\t\t\t);\r\n\r\n\tif (extentReservation)\r\n\t{\r\n\t\t// Not supported.\r\n\t\tscsiDev.target->sense.code = ILLEGAL_REQUEST;\r\n\t\tscsiDev.target->sense.asc = INVALID_FIELD_IN_CDB;\r\n\t\tenter_Status(CHECK_CONDITION);\r\n\t}\r\n\telse if (command == 0x17) // release\r\n\t{\r\n\t\tif ((scsiDev.target->reservedId < 0) || canRelease)\r\n\t\t{\r\n\t\t\tscsiDev.target->reservedId = -1;\r\n\t\t\tscsiDev.target->reserverId = -1;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tenter_Status(CONFLICT);\r\n\t\t}\r\n\t}\r\n\telse // assume reserve.\r\n\t{\r\n\t\tif ((scsiDev.target->reservedId < 0) || canRelease)\r\n\t\t{\r\n\t\t\tscsiDev.target->reserverId = scsiDev.initiatorId;\r\n\t\t\tif (thirdPty)\r\n\t\t\t{\r\n\t\t\t\tscsiDev.target->reservedId = thirdPtyId;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tscsiDev.target->reservedId = scsiDev.initiatorId;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t// Already reserved by someone else!\r\n\t\t\tenter_Status(CONFLICT);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nstatic uint32_t resetUntil = 0;\r\n\r\nstatic void scsiReset()\r\n{\r\n\tscsiDev.rstCount++;\r\n\ts2s_ledOff();\r\n\r\n\tscsiPhyReset();\r\n\r\n\tscsiDev.phase = BUS_FREE;\r\n\tscsiDev.atnFlag = 0;\r\n\tscsiDev.resetFlag = 0;\r\n\tscsiDev.selFlag = 0;\r\n\tscsiDev.lun = -1;\r\n\tscsiDev.compatMode = COMPAT_UNKNOWN;\r\n\r\n\tif (scsiDev.target)\r\n\t{\r\n\t\tif (scsiDev.target->unitAttention != POWER_ON_RESET)\r\n\t\t{\r\n\t\t\tscsiDev.target->unitAttention = SCSI_BUS_RESET;\r\n\t\t}\r\n\t\tscsiDev.target->reservedId = -1;\r\n\t\tscsiDev.target->reserverId = -1;\r\n\t\tscsiDev.target->sense.code = NO_SENSE;\r\n\t\tscsiDev.target->sense.asc = NO_ADDITIONAL_SENSE_INFORMATION;\r\n\t}\r\n\tscsiDev.target = NULL;\r\n\r\n\tfor (int i = 0; i < S2S_MAX_TARGETS; ++i)\r\n\t{\r\n\t\tscsiDev.targets[i].syncOffset = 0;\r\n\t\tscsiDev.targets[i].syncPeriod = 0;\r\n\t}\r\n\tscsiDev.minSyncPeriod = 0;\r\n\r\n\tscsiDiskReset();\r\n\r\n\tscsiDev.postDataOutHook = NULL;\r\n\r\n\r\n\t// Sleep to allow the bus to settle down a bit.\r\n\t// We must be ready again within the \"Reset to selection time\" of\r\n\t// 250ms.\r\n\t// There is no guarantee that the RST line will be negated by then.\r\n\t// NOTE: We could be connected and powered by USB for configuration,\r\n\t// in which case TERMPWR cannot be supplied, and reset will ALWAYS\r\n\t// be true. Therefore, the sleep here must be slow to avoid slowing\r\n\t// USB comms\r\n\tresetUntil = s2s_getTime_ms() + 2; // At least 1ms.\r\n}\r\n\r\nstatic void enter_SelectionPhase()\r\n{\r\n\t// Ignore stale versions of this flag, but ensure we know the\r\n\t// current value if the flag is still set.\r\n\tscsiDev.atnFlag = 0;\r\n\tscsiDev.dataPtr = 0;\r\n\tscsiDev.savedDataPtr = 0;\r\n\tscsiDev.dataLen = 0;\r\n\tscsiDev.status = GOOD;\r\n\tscsiDev.phase = SELECTION;\r\n\tscsiDev.lun = -1;\r\n\tscsiDev.discPriv = 0;\r\n\r\n\tscsiDev.initiatorId = -1;\r\n\tscsiDev.target = NULL;\r\n\r\n\ttransfer.blocks = 0;\r\n\ttransfer.currentBlock = 0;\r\n\r\n\tscsiDev.postDataOutHook = NULL;\r\n\r\n\tscsiDev.needSyncNegotiationAck = 0;\r\n}\r\n\r\nstatic void process_SelectionPhase()\r\n{\r\n\t// Selection delays.\r\n\t// Many SCSI1 samplers that use a 5380 chip need a delay of at least 1ms.\r\n\t// The Mac Plus boot-time (ie. rom code) selection abort time\r\n\t// is < 1ms and must have no delay (standard suggests 250ms abort time)\r\n\t// Most newer SCSI2 hosts don't care either way.\r\n\tif (scsiDev.boardCfg.selectionDelay == 255) // auto\r\n\t{\r\n\t\tif (scsiDev.compatMode < COMPAT_SCSI2)\r\n\t\t{\r\n\t\t\ts2s_delay_ms(1);\r\n\t\t}\r\n\t}\r\n\telse if (scsiDev.boardCfg.selectionDelay != 0)\r\n\t{\r\n\t\ts2s_delay_ms(scsiDev.boardCfg.selectionDelay);\r\n\t}\r\n\r\n\tuint8_t selStatus = *SCSI_STS_SELECTED;\r\n\tif ((selStatus == 0) && (scsiDev.boardCfg.flags & S2S_CFG_ENABLE_SEL_LATCH))\r\n\t{\r\n\t\tselStatus = scsiDev.selFlag;\r\n\t}\r\n\r\n\tint tgtIndex;\r\n\tTargetState* target = NULL;\r\n\tfor (tgtIndex = 0; tgtIndex < S2S_MAX_TARGETS; ++tgtIndex)\r\n\t{\r\n\t\tif (scsiDev.targets[tgtIndex].targetId == (selStatus & 7))\r\n\t\t{\r\n\t\t\ttarget = &scsiDev.targets[tgtIndex];\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tif ((target != NULL) && (selStatus & 0x40))\r\n\t{\r\n\t\t// We've been selected!\r\n\t\t// Assert BSY - Selection success!\r\n\t\t// must happen within 200us (Selection abort time) of seeing our\r\n\t\t// ID + SEL.\r\n\t\t// (Note: the initiator will be waiting the \"Selection time-out delay\"\r\n\t\t// for our BSY response, which is actually a very generous 250ms)\r\n\t\t*SCSI_CTRL_BSY = 1;\r\n\t\ts2s_ledOn();\r\n\r\n\t\tscsiDev.target = target;\r\n\r\n\t\t// Do we enter MESSAGE OUT immediately ? SCSI 1 and 2 standards says\r\n\t\t// move to MESSAGE OUT if ATN is true before we assert BSY.\r\n\t\t// The initiator should assert ATN with SEL.\r\n\t\tscsiDev.atnFlag = selStatus & 0x80;\r\n\r\n\r\n\t\t// Unit attention breaks many older SCSI hosts. Disable it completely\r\n\t\t// for SCSI-1 (and older) hosts, regardless of our configured setting.\r\n\t\t// Enable the compatability mode also as many SASI and SCSI1\r\n\t\t// controllers don't generate parity bits.\r\n\t\tif (!scsiDev.atnFlag)\r\n\t\t{\r\n\t\t\ttarget->unitAttention = 0;\r\n\t\t\tscsiDev.compatMode = COMPAT_SCSI1;\r\n\t\t}\r\n\t\telse if (!(scsiDev.boardCfg.flags & S2S_CFG_ENABLE_SCSI2))\r\n\t\t{\r\n\t\t\tscsiDev.compatMode = COMPAT_SCSI2_DISABLED;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tscsiDev.compatMode = COMPAT_SCSI2;\r\n\t\t}\r\n\r\n\t\tscsiDev.selCount++;\r\n\r\n\r\n\t\t// Save our initiator now that we're no longer in a time-critical\r\n\t\t// section.\r\n\t\t// SCSI1/SASI initiators may not set their own ID.\r\n\t\tscsiDev.initiatorId = (selStatus >> 3) & 0x7;\r\n\r\n\t\twhile (likely(!scsiDev.resetFlag) && scsiStatusSEL())\r\n\t\t{\r\n\t\t\t// Wait until the end of the selection phase.\r\n\t\t}\r\n\r\n\t\tscsiDev.phase = COMMAND;\r\n\t}\r\n\telse if (!selStatus)\r\n\t{\r\n\t\tscsiDev.phase = BUS_BUSY;\r\n\t}\r\n\tscsiDev.selFlag = 0;\r\n}\r\n\r\nstatic void process_MessageOut()\r\n{\r\n\tint wasNeedSyncNegotiationAck = scsiDev.needSyncNegotiationAck;\r\n\tscsiDev.needSyncNegotiationAck = 0; // Successful on -most- messages.\r\n\r\n\tscsiEnterPhase(MESSAGE_OUT);\r\n\r\n\tscsiDev.atnFlag = 0;\r\n\tscsiDev.msgOut = scsiReadByte();\r\n\tscsiDev.msgCount++;\r\n\r\n\tif (scsiParityError() &&\r\n\t\t(scsiDev.boardCfg.flags & S2S_CFG_ENABLE_PARITY))\r\n\t{\r\n\t\t// Skip the remaining message bytes, and then start the MESSAGE_OUT\r\n\t\t// phase again from the start. The initiator will re-send the\r\n\t\t// same set of messages.\r\n\t\twhile (scsiStatusATN() && !scsiDev.resetFlag)\r\n\t\t{\r\n\t\t\tscsiReadByte();\r\n\t\t}\r\n\r\n\t\t// Go-back and try the message again.\r\n\t\tscsiDev.atnFlag = 1;\r\n\t}\r\n\telse if (scsiDev.msgOut == 0x00)\r\n\t{\r\n\t\t// COMMAND COMPLETE. but why would the target be receiving this ? nfi.\r\n\t\tenter_BusFree();\r\n\t}\r\n\telse if (scsiDev.msgOut == 0x06)\r\n\t{\r\n\t\t// ABORT\r\n\t\tscsiDiskReset();\r\n\t\tenter_BusFree();\r\n\t}\r\n\telse if (scsiDev.msgOut == 0x0C)\r\n\t{\r\n\t\t// BUS DEVICE RESET\r\n\r\n\t\tscsiDiskReset();\r\n\r\n\t\tscsiDev.target->unitAttention = SCSI_BUS_RESET;\r\n\r\n\t\t// ANY initiator can reset the reservation state via this message.\r\n\t\tscsiDev.target->reservedId = -1;\r\n\t\tscsiDev.target->reserverId = -1;\r\n\r\n\t\t// Cancel any sync negotiation\r\n\t\tscsiDev.target->syncOffset = 0;\r\n\t\tscsiDev.target->syncPeriod = 0;\r\n\r\n\t\tenter_BusFree();\r\n\t}\r\n\telse if (scsiDev.msgOut == 0x05)\r\n\t{\r\n\t\t// Initiate Detected Error\r\n\t\t// Ignore for now\r\n\t}\r\n\telse if (scsiDev.msgOut == 0x0F)\r\n\t{\r\n\t\t// INITIATE RECOVERY\r\n\t\t// Ignore for now\r\n\t}\r\n\telse if (scsiDev.msgOut == 0x10)\r\n\t{\r\n\t\t// RELEASE RECOVERY\r\n\t\t// Ignore for now\r\n\t\tenter_BusFree();\r\n\t}\r\n\telse if (scsiDev.msgOut == MSG_REJECT)\r\n\t{\r\n\t\t// Message Reject\r\n\t\t// Oh well.\r\n\r\n\t\tif (wasNeedSyncNegotiationAck)\r\n\t\t{\r\n\t\t\tscsiDev.target->syncOffset = 0;\r\n\t\t\tscsiDev.target->syncPeriod = 0;\r\n\t\t}\r\n\t}\r\n\telse if (scsiDev.msgOut == 0x08)\r\n\t{\r\n\t\t// NOP\r\n\t}\r\n\telse if (scsiDev.msgOut == 0x09)\r\n\t{\r\n\t\t// Message Parity Error\r\n\t\t// Go back and re-send the last message.\r\n\t\tscsiDev.phase = MESSAGE_IN;\r\n\r\n\t\tif (wasNeedSyncNegotiationAck)\r\n\t\t{\r\n\t\t\tscsiDev.target->syncOffset = 0;\r\n\t\t\tscsiDev.target->syncPeriod = 0;\r\n\t\t}\r\n\t}\r\n\telse if (scsiDev.msgOut & 0x80) // 0x80 -> 0xFF\r\n\t{\r\n\t\t// IDENTIFY\r\n\t\tif ((scsiDev.msgOut & 0x18) || // Reserved bits set.\r\n\t\t\t(scsiDev.msgOut & 0x20))  // We don't have any target routines!\r\n\t\t{\r\n\t\t\tmessageReject();\r\n\t\t}\r\n\r\n\t\tscsiDev.lun = scsiDev.msgOut & 0x7;\r\n\t\tscsiDev.discPriv = \r\n\t\t\t((scsiDev.msgOut & 0x40) && (scsiDev.initiatorId >= 0))\r\n\t\t\t\t? 1 : 0;\r\n\t}\r\n\telse if (scsiDev.msgOut >= 0x20 && scsiDev.msgOut <= 0x2F)\r\n\t{\r\n\t\t// Two byte message. We don't support these. read and discard.\r\n\t\tscsiReadByte();\r\n\r\n\t\tif (scsiDev.msgOut == 0x23) {\r\n\t\t\t// Ignore Wide Residue. We're only 8 bit anyway.\r\n\t\t} else {\r\n\t\t\tmessageReject();\r\n\t\t}\r\n\t}\r\n\telse if (scsiDev.msgOut == 0x01)\r\n\t{\r\n\t\tint i;\r\n\r\n\t\t// Extended message.\r\n\t\tint msgLen = scsiReadByte();\r\n\t\tif (msgLen == 0) msgLen = 256;\r\n\t\tuint8_t extmsg[256];\r\n\t\tfor (i = 0; i < msgLen && !scsiDev.resetFlag; ++i)\r\n\t\t{\r\n\t\t\t// Discard bytes.\r\n\t\t\textmsg[i] = scsiReadByte();\r\n\t\t}\r\n\r\n\t\tif (extmsg[0] == 3 && msgLen == 2) // Wide Data Request\r\n\t\t{\r\n\t\t\t// Negotiate down to 8bit\r\n\t\t\tscsiEnterPhase(MESSAGE_IN);\r\n\t\t\tstatic const uint8_t WDTR[] = {0x01, 0x02, 0x03, 0x00};\r\n\t\t\tscsiWrite(WDTR, sizeof(WDTR));\r\n\r\n\t\t\t// SDTR becomes invalidated.\r\n\t\t\tscsiDev.target->syncOffset = 0;\r\n\t\t\tscsiDev.target->syncPeriod = 0;\r\n\t\t}\r\n\t\telse if (extmsg[0] == 1 && msgLen == 3) // Synchronous data request\r\n\t\t{\r\n\t\t\tint oldPeriod = scsiDev.target->syncPeriod;\r\n\t\t\tint oldOffset = scsiDev.target->syncOffset;\r\n\r\n\t\t\tint transferPeriod = extmsg[1];\r\n\t\t\tint offset = extmsg[2];\r\n\r\n\t\t\tif ((\r\n\t\t\t\t\t(transferPeriod > 0) &&\r\n\t\t\t\t\t(transferPeriod < scsiDev.minSyncPeriod)) ||\r\n\t\t\t\t(scsiDev.minSyncPeriod == 0))\r\n\t\t\t{\r\n\t\t\t\tscsiDev.minSyncPeriod = transferPeriod;\r\n\t\t\t}\r\n\r\n\t\t\tif ((transferPeriod > 80) || // 320ns, 3.125MB/s\r\n\t\t\t\t// Amiga A590 (WD33C93 chip) only does 3.5MB/s sync\r\n\t\t\t\t// After 80 we start to run out of bits in the fpga timing\r\n\t\t\t\t// register.\r\n\t\t\t\t(transferPeriod == 0) ||\r\n\t\t\t\t(offset == 0) ||\r\n\t\t\t\t((scsiDev.boardCfg.scsiSpeed != S2S_CFG_SPEED_NoLimit) &&\r\n\t\t\t\t\t(scsiDev.boardCfg.scsiSpeed <= S2S_CFG_SPEED_ASYNC_50)))\r\n\t\t\t{\r\n\t\t\t\tscsiDev.target->syncOffset = 0;\r\n\t\t\t\tscsiDev.target->syncPeriod = 0;\r\n\t\t\t} else {\r\n\t\t\t\tscsiDev.target->syncOffset = offset <= 15 ? offset : 15;\r\n\t\t\t\t// FAST20 / 50ns / 20MHz is disabled for now due to\r\n\t\t\t\t// data corruption while reading data. We can count the\r\n\t\t\t\t// ACK's correctly, but can't save the data to a register\r\n\t\t\t\t// before it changes. (ie. transferPeriod == 12)\r\n\t\t\t\tif ((scsiDev.boardCfg.scsiSpeed == S2S_CFG_SPEED_TURBO) &&\r\n\t\t\t\t\t(transferPeriod <= 16))\r\n\t\t\t\t{\r\n\t\t\t\t\tscsiDev.target->syncPeriod = 16; // 15.6MB/s\r\n\t\t\t\t}\r\n\t\t\t\telse if (scsiDev.boardCfg.scsiSpeed == S2S_CFG_SPEED_TURBO)\r\n\t\t\t\t{\r\n\t\t\t\t\tscsiDev.target->syncPeriod = transferPeriod;\r\n\t\t\t\t}\r\n\t\t\t\telse if (transferPeriod <= 25 &&\r\n\t\t\t\t\t((scsiDev.boardCfg.scsiSpeed == S2S_CFG_SPEED_NoLimit) ||\r\n\t\t\t\t\t\t(scsiDev.boardCfg.scsiSpeed >= S2S_CFG_SPEED_SYNC_10)))\r\n\t\t\t\t{\r\n\t\t\t\t\tscsiDev.target->syncPeriod = 25; // 100ns, 10MB/s\r\n\r\n\t\t\t\t} else if (transferPeriod < 50 &&\r\n\t\t\t\t\t((scsiDev.boardCfg.scsiSpeed == S2S_CFG_SPEED_NoLimit) ||\r\n\t\t\t\t\t\t(scsiDev.boardCfg.scsiSpeed >= S2S_CFG_SPEED_SYNC_10)))\r\n\t\t\t\t{\r\n\t\t\t\t\tscsiDev.target->syncPeriod = transferPeriod;\r\n\t\t\t\t} else if (transferPeriod >= 50)\r\n\t\t\t\t{\r\n\t\t\t\t\tscsiDev.target->syncPeriod = transferPeriod;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tscsiDev.target->syncPeriod = 50;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (transferPeriod != oldPeriod ||\r\n\t\t\t\tscsiDev.target->syncPeriod != oldPeriod ||\r\n\t\t\t\toffset != oldOffset ||\r\n\t\t\t\tscsiDev.target->syncOffset != oldOffset ||\r\n\t\t\t\t!wasNeedSyncNegotiationAck) // Don't get into infinite loops negotiating.\r\n\t\t\t{\r\n\t\t\t\tscsiEnterPhase(MESSAGE_IN);\r\n\t\t\t\tuint8_t SDTR[] = {0x01, 0x03, 0x01, scsiDev.target->syncPeriod, scsiDev.target->syncOffset};\r\n\t\t\t\tscsiWrite(SDTR, sizeof(SDTR));\r\n\t\t\t\tscsiDev.needSyncNegotiationAck = 1; // Check if this message is rejected.\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t// Not supported\r\n\t\t\tmessageReject();\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tmessageReject();\r\n\t}\r\n\r\n\t// Re-check the ATN flag in case it stays asserted.\r\n\tscsiDev.atnFlag |= scsiStatusATN();\r\n\r\n\tif (!scsiDev.atnFlag)\r\n\t{\r\n\t\t// Message wasn't rejected!\r\n\t\tscsiDev.needSyncNegotiationAck = 0;\r\n\t}\r\n}\r\n\r\nvoid scsiPoll(void)\r\n{\r\n\tif (resetUntil != 0 && resetUntil > s2s_getTime_ms())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tresetUntil = 0;\r\n\r\n\tif (unlikely(scsiDev.resetFlag))\r\n\t{\r\n\t\tscsiReset();\r\n\t\t// Still in reset phase for a few ms.\r\n\t\t// Do not try and process any commands.\r\n\t\treturn;\r\n\t}\r\n\r\n\tswitch (scsiDev.phase)\r\n\t{\r\n\tcase BUS_FREE:\r\n\t\tif (scsiStatusBSY())\r\n\t\t{\r\n\t\t\tscsiDev.phase = BUS_BUSY;\r\n\t\t}\r\n\t\t// The Arbitration phase is optional for SCSI1/SASI hosts if there is only\r\n\t\t// one initiator in the chain. Support this by moving\r\n\t\t// straight to selection if SEL is asserted.\r\n\t\t// ie. the initiator won't assert BSY and it's own ID before moving to selection.\r\n\t\telse if (scsiDev.selFlag || *SCSI_STS_SELECTED)\r\n\t\t{\r\n\t\t\tenter_SelectionPhase();\r\n\t\t}\r\n\tbreak;\r\n\r\n\tcase BUS_BUSY:\r\n\t\t// Someone is using the bus. Perhaps they are trying to\r\n\t\t// select us.\r\n\t\tif (scsiDev.selFlag || *SCSI_STS_SELECTED)\r\n\t\t{\r\n\t\t\tenter_SelectionPhase();\r\n\t\t}\r\n\t\telse if (!scsiStatusBSY())\r\n\t\t{\r\n\t\t\tscsiDev.phase = BUS_FREE;\r\n\t\t}\r\n\tbreak;\r\n\r\n\tcase ARBITRATION:\r\n\t\t// TODO Support reselection.\r\n\t\tbreak;\r\n\r\n\tcase SELECTION:\r\n\t\tprocess_SelectionPhase();\r\n\tbreak;\r\n\r\n\tcase RESELECTION:\r\n\t\t// Not currently supported!\r\n\tbreak;\r\n\r\n\tcase COMMAND:\r\n\t\t// Do not check ATN here. SCSI 1 & 2 initiators must set ATN\r\n\t\t// and SEL together upon entering the selection phase if they\r\n\t\t// want to send a message (IDENTIFY) immediately.\r\n\t\tif (scsiDev.atnFlag)\r\n\t\t{\r\n\t\t\tprocess_MessageOut();\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tprocess_Command();\r\n\t\t}\r\n\tbreak;\r\n\r\n\tcase DATA_IN:\r\n\t\tscsiDev.atnFlag |= scsiStatusATN();\r\n\t\tif (scsiDev.atnFlag)\r\n\t\t{\r\n\t\t\tprocess_MessageOut();\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tprocess_DataIn();\r\n\t\t}\r\n\tbreak;\r\n\r\n\tcase DATA_OUT:\r\n\t\tscsiDev.atnFlag |= scsiStatusATN();\r\n\t\tif (scsiDev.atnFlag)\r\n\t\t{\r\n\t\t\tprocess_MessageOut();\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tprocess_DataOut();\r\n\t\t}\r\n\tbreak;\r\n\r\n\tcase STATUS:\r\n\t\tscsiDev.atnFlag |= scsiStatusATN();\r\n\t\tif (scsiDev.atnFlag)\r\n\t\t{\r\n\t\t\tprocess_MessageOut();\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tprocess_Status();\r\n\t\t}\r\n\tbreak;\r\n\r\n\tcase MESSAGE_IN:\r\n\t\tscsiDev.atnFlag |= scsiStatusATN();\r\n\t\tif (scsiDev.atnFlag)\r\n\t\t{\r\n\t\t\tprocess_MessageOut();\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tprocess_MessageIn();\r\n\t\t}\r\n\r\n\tbreak;\r\n\r\n\tcase MESSAGE_OUT:\r\n\t\tprocess_MessageOut();\r\n\tbreak;\r\n\t}\r\n}\r\n\r\nvoid scsiInit()\r\n{\r\n\tstatic int firstInit = 1;\r\n\r\n\tscsiDev.atnFlag = 0;\r\n\tscsiDev.resetFlag = 1;\r\n\tscsiDev.selFlag = 0;\r\n\tscsiDev.phase = BUS_FREE;\r\n\tscsiDev.target = NULL;\r\n\tscsiDev.compatMode = COMPAT_UNKNOWN;\r\n\r\n\tint i;\r\n\tfor (i = 0; i < S2S_MAX_TARGETS; ++i)\r\n\t{\r\n\t\tconst S2S_TargetCfg* cfg = s2s_getConfigByIndex(i);\r\n\t\tif (cfg && (cfg->scsiId & S2S_CFG_TARGET_ENABLED))\r\n\t\t{\r\n\t\t\tscsiDev.targets[i].targetId = cfg->scsiId & S2S_CFG_TARGET_ID_BITS;\r\n\t\t\tscsiDev.targets[i].cfg = cfg;\r\n\r\n\t\t\tscsiDev.targets[i].liveCfg.bytesPerSector = cfg->bytesPerSector;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tscsiDev.targets[i].targetId = 0xff;\r\n\t\t\tscsiDev.targets[i].cfg = NULL;\r\n\t\t}\r\n\t\tscsiDev.targets[i].reservedId = -1;\r\n\t\tscsiDev.targets[i].reserverId = -1;\r\n\t\tif (firstInit)\r\n\t\t{\r\n\t\t\tscsiDev.targets[i].unitAttention = POWER_ON_RESET;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tscsiDev.targets[i].unitAttention = PARAMETERS_CHANGED;\r\n\t\t}\r\n\t\tscsiDev.targets[i].sense.code = NO_SENSE;\r\n\t\tscsiDev.targets[i].sense.asc = NO_ADDITIONAL_SENSE_INFORMATION;\r\n\r\n\t\tscsiDev.targets[i].syncOffset = 0;\r\n\t\tscsiDev.targets[i].syncPeriod = 0;\r\n\t}\r\n\tfirstInit = 0;\r\n}\r\n\r\n/* TODO REENABLE\r\nvoid scsiDisconnect()\r\n{\r\n\tscsiEnterPhase(MESSAGE_IN);\r\n\tscsiWriteByte(0x02); // save data pointer\r\n\tscsiWriteByte(0x04); // disconnect msg.\r\n\r\n\t// For now, the caller is responsible for tracking the disconnected\r\n\t// state, and calling scsiReconnect.\r\n\t// Ideally the client would exit their loop and we'd implement this\r\n\t// as part of scsiPoll\r\n\tint phase = scsiDev.phase;\r\n\tenter_BusFree();\r\n\tscsiDev.phase = phase;\r\n}\r\n*/\r\n\r\n/* TODO REENABLE\r\nint scsiReconnect()\r\n{\r\n\tint reconnected = 0;\r\n\r\n\tint sel = SCSI_ReadFilt(SCSI_Filt_SEL);\r\n\tint bsy = SCSI_ReadFilt(SCSI_Filt_BSY);\r\n\tif (!sel && !bsy)\r\n\t{\r\n\t\ts2s_delay_us(1);\r\n\t\tsel = SCSI_ReadFilt(SCSI_Filt_SEL);\r\n\t\tbsy = SCSI_ReadFilt(SCSI_Filt_BSY);\r\n\t}\r\n\r\n\tif (!sel && !bsy)\r\n\t{\r\n\t\t// Arbitrate.\r\n\t\ts2s_ledOn();\r\n\t\tuint8_t scsiIdMask = 1 << scsiDev.target->targetId;\r\n\t\tSCSI_Out_Bits_Write(scsiIdMask);\r\n\t\tSCSI_Out_Ctl_Write(1); // Write bits manually.\r\n\t\tSCSI_SetPin(SCSI_Out_BSY);\r\n\r\n\t\ts2s_delay_us(3); // arbitrate delay. 2.4us.\r\n\r\n\t\tuint8_t dbx = scsiReadDBxPins();\r\n\t\tsel = SCSI_ReadFilt(SCSI_Filt_SEL);\r\n\t\tif (sel || ((dbx ^ scsiIdMask) > scsiIdMask))\r\n\t\t{\r\n\t\t\t// Lost arbitration.\r\n\t\t\tSCSI_Out_Ctl_Write(0);\r\n\t\t\tSCSI_ClearPin(SCSI_Out_BSY);\r\n\t\t\ts2s_ledOff();\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t// Won arbitration\r\n\t\t\tSCSI_SetPin(SCSI_Out_SEL);\r\n\t\t\ts2s_delay_us(1); // Bus clear + Bus settle.\r\n\r\n\t\t\t// Reselection phase\r\n\t\t\tSCSI_CTL_PHASE_Write(__scsiphase_io);\r\n\t\t\tSCSI_Out_Bits_Write(scsiIdMask | (1 << scsiDev.initiatorId));\r\n\t\t\tscsiDeskewDelay(); // 2 deskew delays\r\n\t\t\tscsiDeskewDelay(); // 2 deskew delays\r\n\t\t\tSCSI_ClearPin(SCSI_Out_BSY);\r\n\t\t\ts2s_delay_us(1);  // Bus Settle Delay\r\n\r\n\t\t\tuint32_t waitStart_ms = getTime_ms();\r\n\t\t\tbsy = SCSI_ReadFilt(SCSI_Filt_BSY);\r\n\t\t\t// Wait for initiator.\r\n\t\t\twhile (\r\n\t\t\t\t!bsy &&\r\n\t\t\t\t!scsiDev.resetFlag &&\r\n\t\t\t\t(elapsedTime_ms(waitStart_ms) < 250))\r\n\t\t\t{\r\n\t\t\t\tbsy = SCSI_ReadFilt(SCSI_Filt_BSY);\r\n\t\t\t}\r\n\r\n\t\t\tif (bsy)\r\n\t\t\t{\r\n\t\t\t\tSCSI_SetPin(SCSI_Out_BSY);\r\n\t\t\t\tscsiDeskewDelay(); // 2 deskew delays\r\n\t\t\t\tscsiDeskewDelay(); // 2 deskew delays\r\n\t\t\t\tSCSI_ClearPin(SCSI_Out_SEL);\r\n\r\n\t\t\t\t// Prepare for the initial IDENTIFY message.\r\n\t\t\t\tSCSI_Out_Ctl_Write(0);\r\n\t\t\t\tscsiEnterPhase(MESSAGE_IN);\r\n\r\n\t\t\t\t// Send identify command\r\n\t\t\t\tscsiWriteByte(0x80);\r\n\r\n\t\t\t\tscsiEnterPhase(scsiDev.phase);\r\n\t\t\t\treconnected = 1;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t// reselect timeout.\r\n\t\t\t\tSCSI_Out_Ctl_Write(0);\r\n\t\t\t\tSCSI_ClearPin(SCSI_Out_SEL);\r\n\t\t\t\tSCSI_CTL_PHASE_Write(0);\r\n\t\t\t\ts2s_ledOff();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn reconnected;\r\n}\r\n*/\r\n\r\n\n", "comment_ratio": 0.15286080273270708}
{"lang": "c", "code": "#include \"processmanager.h\"\n#include \"tock.h\"\n\n//MK_HANDLE_t _mk_Get_Process_Handle(MK_PROCESS_ID_u _eProcess_ID){\n//    return command(DRIVER_NUM_PM, 4, _eProcess_ID, 0);\n//}\n\nMK_ERROR_e _mk_Suspend_Process(MK_HANDLE_t _hProcess){\n    int ret = command(DRIVER_NUM_PM, 1, _hProcess, 0);\n    return ret;\n}\n\nMK_ERROR_e _mk_Resume_Process (MK_HANDLE_t _hProcess){\n    int ret = command(DRIVER_NUM_PM, 2, _hProcess, 0);\n      return ret ;\n}\n\nvoid _mk_Yield(void) { //(MK_HANDLE_t _hProcess){\n//void _mk_Yield(MK_HANDLE_t _hProcess){\n    __attribute__ ((unused)) int sret = command(DRIVER_NUM_PM, 3, 0, 0);\n//    yield();\n}\nint _testing (void) {\n    return command(DRIVER_NUM_PM,4,0,0);\n}\n\n//int process_cb(subscribe_cb callback, void* callback_args) {\n//  return subscribe(DRIVER_NUM_PM, 0, callback, callback_args);\n//}\n\n\n\n", "comment_ratio": 0.28125}
{"lang": "c", "code": "int pop(no **L, int prox){\n    \n    no *P;\n\tint aux;\n\tP = malloc(sizeof(no)); // endere\u00e7a memoria para o novo ponteiro do tipo no\n\tP = *L;\n\tif(&P->dado !== NULL){\t// verifica se existe dados na pilha\n\t\treturn pop(P->dado); // chama de forma recursiva a pilha\n\t\taux = P->prox; // variavel auxiliar recebe o proximo da pilha\n\t\tP->dado = aux; // o proximo dado \u00e9 mandado para o ponteiro auxiliar\n\t\tfree(aux);\n\t}\n\telse\n\t\treturn 0; // caso n\u00e3o exista valor na pilha retorna 0\n    \n   }\n\n", "comment_ratio": 0.35294117647058826}
{"lang": "c", "code": "#pragma once\n\n#include <xzero/Buffer.h>\n#include <xzero/CompletionHandler.h>\n#include <xzero/net/TcpConnection.h>\n#include <xzero/net/EndPointWriter.h>\n#include <xzero/http/http1/Generator.h>\n#include <xzero/http/http1/Parser.h>\n#include <xzero/http/client/HttpTransport.h>\n#include <xzero/http/HttpListener.h>\n\nnamespace xzero {\nnamespace http {\nnamespace client {\n\n/**\n * HTTP/1 client-side transport protocol implementation.\n */\nclass Http1Connection\n    : public TcpConnection,\n      public HttpTransport,\n      private HttpListener {\npublic:\n  /**\n   * Initializes the client-side HTTP/1 transport layer.\n   *\n   * @param channel HTTP channel to report HTTP and error events to.\n   * @param endpoint communication TcpEndPoint\n   * @param executor connection-level executor API\n   */\n  Http1Connection(HttpListener* channel, TcpEndPoint* endpoint, Executor* executor);\n  ~Http1Connection();\n\n  // HttpTransport overrides\n  void setListener(HttpListener* channel) override;\n  void send(const HttpRequestInfo& requestInfo,\n            CompletionHandler onComplete) override;\n  void send(const HttpRequestInfo& requestInfo,\n            const BufferRef& chunk,\n            CompletionHandler onComplete) override;\n  void send(const HttpRequestInfo& requestInfo,\n            Buffer&& chunk,\n            CompletionHandler onComplete) override;\n  void send(const HttpRequestInfo& requestInfo,\n            FileView&& chunk,\n            CompletionHandler onComplete) override;\n  void send(const HttpRequestInfo& requestInfo,\n            HugeBuffer&& chunk,\n            CompletionHandler onComplete) override;\n  void send(const BufferRef& chunk, CompletionHandler onComplete) override;\n  void send(Buffer&& chunk, CompletionHandler onComplete) override;\n  void send(FileView&& chunk, CompletionHandler onComplete) override;\n  void send(HugeBuffer&& chunk, CompletionHandler onComplete) override;\n  void completed() override;\n  void abort() override;\n\n  // TcpConnection overrides\n  void onReadable() override;\n  void onWriteable() override;\n  void onInterestFailure(const std::exception& error) override;\n\n  // HttpListener overrides\n  void onMessageBegin(HttpVersion version, HttpStatus code,\n                      const BufferRef& text) override;\n  void onMessageHeader(const BufferRef& name, const BufferRef& value) override;\n  void onMessageHeaderEnd() override;\n  void onMessageContent(const BufferRef& chunk) override;\n  void onMessageContent(FileView&& chunk) override;\n  void onMessageEnd() override;\n  void onError(std::error_code ec) override;\n\n private:\n  void onRequestComplete(bool success);\n  void onResponseComplete(bool success);\n  void parseFragment();\n\n  void setCompleter(CompletionHandler cb);\n  void notifySuccess() { invokeCompleter(true); }\n  void notifyFailure() { invokeCompleter(false); }\n  void invokeCompleter(bool success);\n\n private:\n  HttpListener* channel_;\n  CompletionHandler onComplete_;\n\n  // request generator\n  EndPointWriter writer_;\n  http1::Generator generator_;\n\n  // response parser\n  http1::Parser parser_;\n  Buffer inputBuffer_;\n  size_t inputOffset_;\n\n  bool expectsBody_;\n  bool responseComplete_;\n  size_t keepAliveCount_;\n};\n\n} // namespace client\n} // namespace http\n} // namespace xzero\n\n", "comment_ratio": 0.12727272727272726}
{"lang": "c", "code": "#pragma once\r\n//\r\n// $Id: pragma.h 24625 2009-07-31 01:05:55Z unknown $\r\n// Copyright (c) 2009 Cristian L. Vlasceanu\r\n//\r\n#include \"dsymbol.h\"\r\n\r\nstruct PragmaDeclaration;\r\nstruct StringExp;\r\n\r\n\r\nstruct PragmaScope : public ScopeDsymbol\r\n{\r\n    enum Kind\r\n    {\r\n        pragma_assembly,\r\n    } whatKind;\r\n\r\n    Module* module;\r\n\r\n    PragmaScope(PragmaDeclaration*, Dsymbol*, StringExp*);\r\n    Kind kind() const { return whatKind; }\r\n    void toObjFile(int multiobj);\r\n    void semantic(Scope*);    \r\n    void setScope(Scope*);\r\n    PragmaScope* isPragmaScope() { return this; }\r\n};\r\n\r\n\r\nPragmaScope* inPragmaAssembly(Dsymbol*);\r\n\n", "comment_ratio": 0.12903225806451613}
{"lang": "c", "code": "#ifndef THIRD_PARTY_BLINK_RENDERER_CORE_EDITING_ITERATORS_TEXT_ITERATOR_H_\n#define THIRD_PARTY_BLINK_RENDERER_CORE_EDITING_ITERATORS_TEXT_ITERATOR_H_\n\n#include \"third_party/blink/renderer/core/core_export.h\"\n#include \"third_party/blink/renderer/core/dom/range.h\"\n#include \"third_party/blink/renderer/core/editing/finder/find_options.h\"\n#include \"third_party/blink/renderer/core/editing/forward.h\"\n#include \"third_party/blink/renderer/core/editing/iterators/fully_clipped_state_stack.h\"\n#include \"third_party/blink/renderer/core/editing/iterators/text_iterator_behavior.h\"\n#include \"third_party/blink/renderer/core/editing/iterators/text_iterator_text_node_handler.h\"\n#include \"third_party/blink/renderer/core/editing/iterators/text_iterator_text_state.h\"\n#include \"third_party/blink/renderer/platform/heap/handle.h\"\n\nnamespace blink {\n\nCORE_EXPORT String\nPlainText(const EphemeralRange&,\n          const TextIteratorBehavior& = TextIteratorBehavior());\n\nString PlainText(const EphemeralRangeInFlatTree&,\n                 const TextIteratorBehavior& = TextIteratorBehavior());\n\n// Iterates through the DOM range, returning all the text, and 0-length\n// boundaries at points where replaced elements break up the text flow.  The\n// text comes back in chunks so as to optimize for performance of the iteration.\n\ntemplate <typename Strategy>\nclass CORE_TEMPLATE_CLASS_EXPORT TextIteratorAlgorithm {\n  STACK_ALLOCATED();\n\n public:\n  // [start, end] indicates the document range that the iteration should take\n  // place within (both ends inclusive).\n  TextIteratorAlgorithm(const PositionTemplate<Strategy>& start,\n                        const PositionTemplate<Strategy>& end,\n                        const TextIteratorBehavior& = TextIteratorBehavior());\n\n  // Same behavior as previous constructor but takes an EphemeralRange instead\n  // of two Positions\n  TextIteratorAlgorithm(const EphemeralRangeTemplate<Strategy>&,\n                        const TextIteratorBehavior& = TextIteratorBehavior());\n\n  ~TextIteratorAlgorithm();\n\n  bool AtEnd() const { return !text_state_.PositionNode() || should_stop_; }\n  void Advance();\n  bool IsInsideAtomicInlineElement() const;\n\n  EphemeralRangeTemplate<Strategy> Range() const;\n  const Node* GetNode() const;\n\n  const Document& OwnerDocument() const;\n  const Node& CurrentContainer() const;\n  int StartOffsetInCurrentContainer() const;\n  int EndOffsetInCurrentContainer() const;\n  PositionTemplate<Strategy> StartPositionInCurrentContainer() const;\n  PositionTemplate<Strategy> EndPositionInCurrentContainer() const;\n\n  // Returns the position before |char16_offset| in current text run.\n  PositionTemplate<Strategy> GetPositionBefore(int char16_offset) const;\n\n  // Returns the position after |char16_offset| in current text run.\n  PositionTemplate<Strategy> GetPositionAfter(int char16_offset) const;\n\n  const TextIteratorTextState& GetText() const { return text_state_; }\n  int length() const { return text_state_.length(); }\n  UChar CharacterAt(unsigned index) const {\n    return text_state_.CharacterAt(index);\n  }\n\n  bool BreaksAtReplacedElement() {\n    return !behavior_.DoesNotBreakAtReplacedElement();\n  }\n\n  // Calculate the minimum |actualLength >= minLength| such that code units\n  // with offset range [position, position + actualLength) are whole code\n  // points. Append these code points to |output| and return |actualLength|.\n  int CopyTextTo(ForwardsTextBuffer* output,\n                 int position,\n                 int min_length) const;\n  int CopyTextTo(ForwardsTextBuffer* output, int position = 0) const;\n\n  // Computes the length of the given range using a text iterator according to\n  // the specified iteration behavior. The default iteration behavior is to\n  // always emit object replacement characters for replaced elements.\n  // TODO(editing-dev): We should remove start/end version of |RangeLength()|.\n  static int RangeLength(\n      const PositionTemplate<Strategy>& start,\n      const PositionTemplate<Strategy>& end,\n      const TextIteratorBehavior& =\n          TextIteratorBehavior::DefaultRangeLengthBehavior());\n\n  static int RangeLength(\n      const EphemeralRangeTemplate<Strategy>&,\n      const TextIteratorBehavior& =\n          TextIteratorBehavior::DefaultRangeLengthBehavior());\n\n  static bool ShouldEmitTabBeforeNode(const Node&);\n  static bool ShouldEmitNewlineBeforeNode(const Node&);\n  static bool ShouldEmitNewlineAfterNode(const Node&);\n  static bool ShouldEmitNewlineForNode(const Node&, bool emits_original_text);\n\n  static bool SupportsAltText(const Node&);\n\n private:\n  enum IterationProgress {\n    kHandledNone,\n    kHandledOpenShadowRoots,\n    kHandledUserAgentShadowRoot,\n    kHandledNode,\n    kHandledChildren\n  };\n\n  void EmitChar16AfterNode(UChar code_unit, const Node& node);\n  void EmitChar16AsNode(UChar code_unit, const Node& node);\n  void EmitChar16BeforeNode(UChar code_unit, const Node& node);\n\n  void ExitNode();\n  bool ShouldRepresentNodeOffsetZero();\n  bool ShouldEmitSpaceBeforeAndAfterNode(const Node&);\n  void RepresentNodeOffsetZero();\n\n  // Returns true if text is emitted from the remembered progress (if any).\n  bool HandleRememberedProgress();\n\n  void HandleTextNode();\n  void HandleReplacedElement();\n  void HandleNonTextNode();\n\n  // Used by selection preservation code. There should be one character emitted\n  // between every VisiblePosition in the Range used to create the TextIterator.\n  // FIXME <rdar://problem/6028818>: This functionality should eventually be\n  // phased out when we rewrite moveParagraphs to not clone/destroy moved\n  // content.\n  bool EmitsCharactersBetweenAllVisiblePositions() const {\n    return behavior_.EmitsCharactersBetweenAllVisiblePositions();\n  }\n\n  bool EntersTextControls() const { return behavior_.EntersTextControls(); }\n\n  // Used in pasting inside password field.\n  bool EmitsOriginalText() const { return behavior_.EmitsOriginalText(); }\n\n  // Used when the visibility of the style should not affect text gathering.\n  bool IgnoresStyleVisibility() const {\n    return behavior_.IgnoresStyleVisibility();\n  }\n\n  // Used when the iteration should stop if form controls are reached.\n  bool StopsOnFormControls() const { return behavior_.StopsOnFormControls(); }\n\n  bool EmitsImageAltText() const { return behavior_.EmitsImageAltText(); }\n\n  bool EntersOpenShadowRoots() const {\n    return behavior_.EntersOpenShadowRoots();\n  }\n\n  bool EmitsObjectReplacementCharacter() const {\n    return behavior_.EmitsObjectReplacementCharacter();\n  }\n\n  bool ExcludesAutofilledValue() const {\n    return behavior_.ExcludeAutofilledValue();\n  }\n\n  bool DoesNotBreakAtReplacedElement() const {\n    return behavior_.DoesNotBreakAtReplacedElement();\n  }\n\n  // Clipboard should respect user-select style attribute\n  bool SkipsUnselectableContent() const {\n    return behavior_.SkipsUnselectableContent();\n  }\n\n  bool ForInnerText() const { return behavior_.ForInnerText(); }\n\n  bool IsBetweenSurrogatePair(unsigned position) const;\n\n  // Append code units with offset range [position, position + copyLength)\n  // to the output buffer.\n  void CopyCodeUnitsTo(ForwardsTextBuffer* output,\n                       unsigned position,\n                       unsigned copy_length) const;\n\n  // Ensure container node of current text run for computing position.\n  void EnsurePositionContainer() const;\n\n  // The range.\n  const Member<const Node> start_container_;\n  const unsigned start_offset_;\n  const Member<const Node> end_container_;\n  const unsigned end_offset_;\n  // |m_endNode| stores |Strategy::childAt(*m_endContainer, m_endOffset - 1)|,\n  // if it exists, or |nullptr| otherwise.\n  const Member<const Node> end_node_;\n  const Member<const Node> past_end_node_;\n\n  // Current position, not necessarily of the text being returned, but position\n  // as we walk through the DOM tree.\n  Member<const Node> node_;\n  IterationProgress iteration_progress_;\n  FullyClippedStateStackAlgorithm<Strategy> fully_clipped_stack_;\n  unsigned shadow_depth_;\n\n  // Used when there is still some pending text from the current node; when\n  // these are false, we go back to normal iterating.\n  bool needs_another_newline_ = false;\n  bool needs_handle_replaced_element_ = false;\n\n  Member<const Text> last_text_node_;\n\n  const TextIteratorBehavior behavior_;\n\n  // Used when stopsOnFormControls() is true to determine if the iterator should\n  // keep advancing.\n  bool should_stop_ = false;\n  // Used for use counter |InnerTextWithShadowTree| and\n  // |SelectionToStringWithShadowTree|, we should not use other purpose.\n  bool handle_shadow_root_ = false;\n\n  // Contains state of emitted text.\n  TextIteratorTextState text_state_;\n\n  // Helper for extracting text content from text nodes.\n  TextIteratorTextNodeHandler text_node_handler_;\n};\n\nextern template class CORE_EXTERN_TEMPLATE_EXPORT\n    TextIteratorAlgorithm<EditingStrategy>;\nextern template class CORE_EXTERN_TEMPLATE_EXPORT\n    TextIteratorAlgorithm<EditingInFlatTreeStrategy>;\n\nusing TextIterator = TextIteratorAlgorithm<EditingStrategy>;\nusing TextIteratorInFlatTree = TextIteratorAlgorithm<EditingInFlatTreeStrategy>;\n\n}  // namespace blink\n\n#endif  // THIRD_PARTY_BLINK_RENDERER_CORE_EDITING_ITERATORS_TEXT_ITERATOR_H_\n\n", "comment_ratio": 0.16666666666666666}
{"lang": "c", "code": "#ifndef CHROME_BROWSER_POLICY_BROWSER_DM_TOKEN_STORAGE_LINUX_H_\n#define CHROME_BROWSER_POLICY_BROWSER_DM_TOKEN_STORAGE_LINUX_H_\n\n#include \"chrome/browser/policy/browser_dm_token_storage.h\"\n\n#include <string>\n\n#include \"base/gtest_prod_util.h\"\n#include \"base/macros.h\"\n#include \"base/memory/scoped_refptr.h\"\n#include \"base/memory/weak_ptr.h\"\n#include \"base/sequence_checker.h\"\n#include \"base/single_thread_task_runner.h\"\n\nnamespace policy {\n\n// Implementation of BrowserDMTokenStorage for Linux. The global singleton\n// instance can be retrieved by calling BrowserDMTokenStorage::Get().\nclass BrowserDMTokenStorageLinux : public BrowserDMTokenStorage {\n public:\n  // Get the global singleton instance by calling BrowserDMTokenStorage::Get().\n  BrowserDMTokenStorageLinux();\n  ~BrowserDMTokenStorageLinux() override;\n\n private:\n  // override BrowserDMTokenStorage\n  std::string InitClientId() override;\n  std::string InitEnrollmentToken() override;\n  std::string InitDMToken() override;\n  bool InitEnrollmentErrorOption() override;\n  StoreTask SaveDMTokenTask(const std::string& token,\n                            const std::string& client_id) override;\n  scoped_refptr<base::TaskRunner> SaveDMTokenTaskRunner() override;\n\n  // Returns the content of \"/etc/machine-id\". Virtual for tests.\n  virtual std::string ReadMachineIdFile();\n\n  scoped_refptr<base::TaskRunner> task_runner_;\n\n  FRIEND_TEST_ALL_PREFIXES(BrowserDMTokenStorageLinuxTest, InitClientId);\n  FRIEND_TEST_ALL_PREFIXES(BrowserDMTokenStorageLinuxTest, InitEnrollmentToken);\n  FRIEND_TEST_ALL_PREFIXES(BrowserDMTokenStorageLinuxTest, InitDMToken);\n  FRIEND_TEST_ALL_PREFIXES(BrowserDMTokenStorageLinuxTest,\n                           InitDMTokenWithoutDirectory);\n  FRIEND_TEST_ALL_PREFIXES(BrowserDMTokenStorageLinuxTest, SaveDMToken);\n\n  DISALLOW_COPY_AND_ASSIGN(BrowserDMTokenStorageLinux);\n};\n\n}  // namespace policy\n#endif  // CHROME_BROWSER_POLICY_BROWSER_DM_TOKEN_STORAGE_LINUX_H_\n\n", "comment_ratio": 0.17857142857142858}
{"lang": "c", "code": "/****************************************************************************\n* Name: spea_frame_id.h  (SpeaFrame class)\n* list of ID used by SpeaFrame class\n* \n* JLP\n* Version 11/03/2016\n****************************************************************************/\n#ifndef _spea_frame_id_h_\n#define _spea_frame_id_h_\n\n// For compilers that support precompilation, includes \"wx/wx.h\".\n#include \"wx/wxprec.h\"\n\n#ifndef WX_PRECOMP\n    #include \"wx/wx.h\"\n#endif\n\n//---------------------------------------------------------------------\n//---------------------------------------------------------------------\nenum{\n//  ID_QUIT         = wxID_EXIT,\n  ID_QUIT         = 1050, \n\n// Menu/File:\n  ID_LOAD_SPECTRUM_FILE,\n  ID_LOAD_SHAPES_FILE,\n  ID_LOAD_RESULTS_FILE,\n  ID_LOAD_SPECTRAL_LIB,\n  ID_LOAD_IMAGE,\n  ID_LOAD_MUSE_IMAGE,\n  ID_LOAD_MUSE_NOISE,\n\n  ID_SAVE_SOLUTION_ASCII,\n  ID_SAVE_SOLUTION_FITS,\n\n// Menu/Help context\n  ID_CONTEXT_HELP,\n\n// Menu/Notebook:\n  ID_NOTEBK_NOTEBOOK,\n  ID_NOTEBK_PARAM,\n  ID_NOTEBK_GRAPHIC,\n  ID_NOTEBK_DISPLAY,\n  ID_NOTEBK_FIT,\n  ID_NOTEBK_TEXT,\n\n// Text panel:\n  ID_SHOW_HEADER,\n  ID_SHOW_BAD_FRAMES,\n  ID_SHOW_SHAPES,\n  ID_SHOW_RESULTS,\n  ID_TEXT_VALID_CHANGES,\n  ID_TEXT_CANCEL_CHANGES,\n  ID_TEXT_SAVETOFILE,\n\n// Param panel: \n  ID_PARAM_CMB_DUST,\n  ID_PARAM_CMB_WEIGHT,\n  ID_PARAM_WEIGHT_BUTTON,\n  ID_PARAM_VALID,\n  ID_PARAM_LOAD1,\n  ID_PARAM_LOAD2,\n  ID_PARAM_SAVE1,\n  ID_PARAM_SAVE2,\n  ID_PARAM_DEFAULT,\n\n// Fit panel: \n  ID_FIT_START1,\n  ID_FIT_START2,\n  ID_FIT_VALIDATE,\n\n// Plot\n  ID_PLOT_RESET,\n  ID_PLOT_SPECTRUM1,\n  ID_PLOT_SPECTRUM2,\n \n// Display \n  ID_DISPLAY_ICHECKBOX,\n  ID_DISPLAY_VCHECKBOX,\n\n// Display processing\n  ID_DISPROC_SHOW_SPECTRUM,\n  ID_DISPROC_IDLE,\n  ID_DISPROC_RESET,\n  ID_DISPROC_RECT,\n  ID_DISPROC_CIRC,\n  ID_DISPROC_ELLIPS,\n  ID_DISPROC_RING,\n  ID_DISPROC_CANCEL,\n  ID_DISPROC_MOVE,\n  ID_DISPROC_SELECT,\n  ID_DISPROC_ALL,\n  ID_DISPROC_REJECTION,\n \n// Logbook\n  ID_LOGBOOK_SHOW,\n  ID_LOGBOOK_HIDE,\n  ID_LOGBOOK_CLEAR,\n  ID_LOGBOOK_CLEAN,\n  ID_LOGBOOK_SAVE,\n\n// Dialogs:\n  ID_WEIGHT_OK,\n  ID_WEIGHT_CANCEL,\n\n// Help:\n  ID_ABOUT          = wxID_ABOUT,\n  ID_HELP           = wxID_HELP\n\n};\n\n#endif\n\n", "comment_ratio": 0.1415929203539823}
{"lang": "c", "code": "#ifndef  _ADJUST_COMMAND_EXECUTOR_H_\n#define  _ADJUST_COMMAND_EXECUTOR_H_\n\n#include <map>\n#include <string>\n#include <vector>\n#include \"Command.h\"\n#include \"Adjust/Adjust2dx.h\"\n#include \"Adjust/AdjustEvent2dx.h\"\n#include \"Adjust/AdjustConfig2dx.h\"\n#include \"Adjust/AdjustAttribution2dx.h\"\n#include \"Adjust/AdjustAppStoreSubscription2dx.h\"\n#include \"Adjust/AdjustPlayStoreSubscription2dx.h\"\n#include \"Adjust/AdjustEventFailure2dx.h\"\n#include \"Adjust/AdjustEventSuccess2dx.h\"\n#include \"Adjust/AdjustSessionSuccess2dx.h\"\n#include \"Adjust/AdjustSessionFailure2dx.h\"\n#include \"Adjust/AdjustThirdPartySharing2dx.h\"\n#include \"Adjust/test/TestLib2dx.h\"\n#include \"Adjust/test/TestConnectionOptions2dx.h\"\n\nclass AdjustCommandExecutor {\nprivate:\n    std::string baseUrl;\n    std::string gdprUrl;\n    std::string subscriptionUrl;\n    std::string basePath;\n    std::string gdprPath;\n    std::string subscriptionPath;\n    std::string extraPath;\n    std::map<std::int8_t, AdjustEvent2dx*> savedEvents;\n    std::map<std::int8_t, AdjustConfig2dx*> savedConfigs;\n    Command *command;\n\n    void testOptions();\n    void config();\n    void start();\n    void event();\n    void trackEvent();\n    void setReferrer();\n    void pause();\n    void resume();\n    void setEnabled();\n    void setOfflineMode();\n    void sendFirstPackages();\n    void addSessionCallbackParameter();\n    void addSessionPartnerParameter();\n    void removeSessionCallbackParameter();\n    void removeSessionPartnerParameter();\n    void resetSessionCallbackParameters();\n    void resetSessionPartnerParameters();\n    void setPushToken();\n    void openDeeplink();\n    void sendReferrer();\n    void gdprForgetMe();\n    void trackAdRevenue();\n    void disableThirdPartySharing();\n    void trackSubscription();\n    void trackThirdPartySharing();\n    void trackMeasurementConsent();\npublic:\n    static const std::string TAG;\n    AdjustCommandExecutor(std::string baseUrl, std::string gdprUrl, std::string subscriptionUrl);\n    void executeCommand(Command *command);\n};\n\n#endif // _ADJUST_COMMAND_EXECUTOR_H_\n", "comment_ratio": 0.10666666666666667}
{"lang": "c", "code": "#import <Cocoa/Cocoa.h>\n#import <RestKit/RestKit.h>\n\n@interface RKMacOSXAppDelegate : NSObject <NSApplicationDelegate>\n\n@property (nonatomic, strong) RKObjectManager *objectManager;\n@property (unsafe_unretained) IBOutlet NSWindow *window;\n\n@end\n\n", "comment_ratio": 0.3888888888888889}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n#import \"INSnapViewController.h\"\n#import \"INCaptureViewController.h\"\n\n@interface INHomeViewController : UIViewController <UITableViewDataSource, UITableViewDelegate, UIGestureRecognizerDelegate, INModelProviderDelegate>\n\n@property (weak, nonatomic) IBOutlet UITableView * tableView;\n@property (weak, nonatomic) IBOutlet UILabel *statusLabel;\n@property (strong, nonatomic) UIRefreshControl * tableRefreshControl;\n\n@property (nonatomic, strong) INSnapViewController * snapController;\n@property (nonatomic, strong) INCaptureViewController * captureController;\n\n@property (nonatomic, strong) INModelProvider * sendingProvider;\n@property (nonatomic, strong) INThreadProvider * threadProvider;\n\n@property (nonatomic, strong) INMessageProvider * messageProvider;\n\n- (void)dismissSnapViewController;\n\n@end\n\n", "comment_ratio": 0.23333333333333334}
{"lang": "c", "code": "#ifndef ZIRCON_KERNEL_ARCH_X86_INCLUDE_ARCH_X86_VMX_STATE_H_\n#define ZIRCON_KERNEL_ARCH_X86_INCLUDE_ARCH_X86_VMX_STATE_H_\n\n#include <zircon/compiler.h>\n\n#define VS_RESUME 0\n\n#define HS_RSP (VS_RESUME + 8)\n#define HS_XCR0 (HS_RSP + 8)\n\n#define GS_RAX (HS_XCR0 + 8)\n#define GS_RCX (GS_RAX + 8)\n#define GS_RDX (GS_RCX + 8)\n#define GS_RBX (GS_RDX + 8)\n#define GS_RBP (GS_RBX + 8)\n#define GS_RSI (GS_RBP + 8)\n#define GS_RDI (GS_RSI + 8)\n#define GS_R8 (GS_RDI + 8)\n#define GS_R9 (GS_R8 + 8)\n#define GS_R10 (GS_R9 + 8)\n#define GS_R11 (GS_R10 + 8)\n#define GS_R12 (GS_R11 + 8)\n#define GS_R13 (GS_R12 + 8)\n#define GS_R14 (GS_R13 + 8)\n#define GS_R15 (GS_R14 + 8)\n#define GS_CR2 (GS_R15 + 8)\n\n#ifndef __ASSEMBLER__\n\n#include <zircon/types.h>\n\n// Holds the register state used to restore a host.\nstruct HostState {\n  // Host stack pointer.\n  uint64_t rsp;\n\n  // Extended control registers.\n  uint64_t xcr0;\n};\n\nstruct GuestState {\n  //  RIP, RSP, and RFLAGS are automatically saved by VMX in the VMCS.\n  uint64_t rax;\n  uint64_t rcx;\n  uint64_t rdx;\n  uint64_t rbx;\n  uint64_t rbp;\n  uint64_t rsi;\n  uint64_t rdi;\n  uint64_t r8;\n  uint64_t r9;\n  uint64_t r10;\n  uint64_t r11;\n  uint64_t r12;\n  uint64_t r13;\n  uint64_t r14;\n  uint64_t r15;\n\n  // Control registers.\n  uint64_t cr2;\n\n  // Extended control registers.\n  uint64_t xcr0;\n};\n\nstruct VmxState {\n  bool resume;\n  HostState host_state;\n  GuestState guest_state;\n};\n\nstatic_assert(__offsetof(VmxState, resume) == VS_RESUME);\n\nstatic_assert(__offsetof(VmxState, host_state.rsp) == HS_RSP);\nstatic_assert(__offsetof(VmxState, host_state.xcr0) == HS_XCR0);\n\nstatic_assert(__offsetof(VmxState, guest_state.rax) == GS_RAX);\nstatic_assert(__offsetof(VmxState, guest_state.rbx) == GS_RBX);\nstatic_assert(__offsetof(VmxState, guest_state.rcx) == GS_RCX);\nstatic_assert(__offsetof(VmxState, guest_state.rdx) == GS_RDX);\nstatic_assert(__offsetof(VmxState, guest_state.rdi) == GS_RDI);\nstatic_assert(__offsetof(VmxState, guest_state.rsi) == GS_RSI);\nstatic_assert(__offsetof(VmxState, guest_state.rbp) == GS_RBP);\nstatic_assert(__offsetof(VmxState, guest_state.r8) == GS_R8);\nstatic_assert(__offsetof(VmxState, guest_state.r9) == GS_R9);\nstatic_assert(__offsetof(VmxState, guest_state.r10) == GS_R10);\nstatic_assert(__offsetof(VmxState, guest_state.r11) == GS_R11);\nstatic_assert(__offsetof(VmxState, guest_state.r12) == GS_R12);\nstatic_assert(__offsetof(VmxState, guest_state.r13) == GS_R13);\nstatic_assert(__offsetof(VmxState, guest_state.r14) == GS_R14);\nstatic_assert(__offsetof(VmxState, guest_state.r15) == GS_R15);\nstatic_assert(__offsetof(VmxState, guest_state.cr2) == GS_CR2);\n\n// Launch/resume the guest, and return when the guest next exits.\n//\n// If we return ZX_OK, the guest was successfully launched and has now\n// exited again. Otherwise, we failed to launch the guest.\nzx_status_t vmx_enter(VmxState* vmx_state);\n\n__BEGIN_CDECLS\n\n// Low-level functionality to save register and restore register state\n// before/after entering a guest. Should only be called by vmx_enter.\nzx_status_t vmx_enter_asm(VmxState* vmx_state);\n\n// The location where we jump to when a guest exits. An internal implementation\n// detail of vmx_enter_asm().\nvoid vmx_guest_exit();\n\n__END_CDECLS\n\n#endif  // __ASSEMBLER__\n\n#endif  // ZIRCON_KERNEL_ARCH_X86_INCLUDE_ARCH_X86_VMX_STATE_H_\n\n", "comment_ratio": 0.17355371900826447}
{"lang": "c", "code": "#ifndef __MIF_NET_HTTP_CLIENTS_H__\n#define __MIF_NET_HTTP_CLIENTS_H__\n\n// STD\n#include <memory>\n#include <string>\n\n// MIF\n#include \"mif/net/iclient_factory.h\"\n\nnamespace Mif\n{\n    namespace Net\n    {\n        namespace Http\n        {\n\n            class Clients final\n            {\n            public:\n                Clients(std::shared_ptr<IClientFactory> factory);\n                ~Clients();\n\n                IClientFactory::ClientPtr RunClient(std::string const &host, std::string const &port,\n                        std::string const &resource = \"\");\n\n            private:\n                class Impl;\n                std::unique_ptr<Impl> m_impl;\n            };\n\n        }   // namespace Http\n    }   // namespace Net\n}   // namespace Mif\n\n#endif  // !__MIF_NET_HTTP_CLIENTS_H__\n\n", "comment_ratio": 0.2727272727272727}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n#import <CoreData/CoreData.h>\n\n\n@interface BLYYoutubeUser : NSManagedObject\n\n@property (nonatomic, retain) NSString * sid;\n@property (nonatomic, retain) NSString * name;\n@property (nonatomic, retain) NSSet *videoComments;\n@end\n\n@interface BLYYoutubeUser (CoreDataGeneratedAccessors)\n\n- (void)addVideoCommentsObject:(NSManagedObject *)value;\n- (void)removeVideoCommentsObject:(NSManagedObject *)value;\n- (void)addVideoComments:(NSSet *)values;\n- (void)removeVideoComments:(NSSet *)values;\n\n@end\n\n", "comment_ratio": 0.25}
{"lang": "c", "code": "#ifndef CEF_TESTS_CEFSIMPLE_SIMPLE_APP_H_\n#define CEF_TESTS_CEFSIMPLE_SIMPLE_APP_H_\n\n#include \"include/cef_app.h\"\n\n// Implement application-level callbacks for the browser process.\nclass SimpleApp : public CefApp, public CefBrowserProcessHandler {\n public:\n  SimpleApp();\n\n  // CefApp methods:\n  CefRefPtr<CefBrowserProcessHandler> GetBrowserProcessHandler() override {\n    return this;\n  }\n\n  // CefBrowserProcessHandler methods:\n  void OnContextInitialized() override;\n  CefRefPtr<CefClient> GetDefaultClient() override;\n\n private:\n  // Include the default reference counting implementation.\n  IMPLEMENT_REFCOUNTING(SimpleApp);\n};\n\n#endif  // CEF_TESTS_CEFSIMPLE_SIMPLE_APP_H_\n\n", "comment_ratio": 0.26666666666666666}
{"lang": "c", "code": "#ifndef AROUTER_AROUTER_H_\n#define AROUTER_AROUTER_H_\n\n#include \"grdr/IntraCellRouter.h\"\n#include \"gr/GlobalRouter.h\"\n#include \"dr/DetailedRouter.h\"\n#include \"parser/GrDB2DrDB.h\"\n#include \"writer/gdsii/WriteGdsLayout.h\"\n\nPROJECT_NAMESPACE_BEGIN\n\n/// @class AROUTER::ARouter\n/// @brief Wrapper of everything\nclass ARouter\n{\n    public:\n        /// @brief default constructor\n        explicit ARouter() = default;\n        /// @brief start routing\n        /// @param the arguments to the program\n        void operator()(int argc, char** argv);\n    private:\n        /// @brief read the commands/ program arguments\n        /// @param the arguments to the program\n        bool readCMD(int argc, char** argv);\n        /// @brief parsing in the files\n        bool read();\n        /// @brief read terminal file \n        /// @return if sucessful\n        bool readTerminalFile();\n        /// @brief read placement layout file\n        /// @return if successful\n        bool readPlacementLayout();\n        /// @brief the core function\n        /// @return if successful\n        bool solve();\n        /// @brief data preprocessing\n        /// @return if succesful\n        bool preprocessing();\n        /// @brief the core function for global router\n        /// @return if successful\n        bool solveGR();\n        /// @brief the core function for detailed router\n        /// @return if successful\n        bool solveDR();\n        /// @brief convert the global routing result to detailed router\n        /// @return if succesful\n        bool convertGR2DR();\n        /// @brief write output layout\n        /// @return if successful\n        bool writeGDS();\n\n\n        /*------------------------------*/ \n        /* Heuristics                   */\n        /*------------------------------*/ \n        /// @brief ordering the terminals in nets in ordering of decending bbox area\n        void orderTerminalDecendingBBox();\n\n    protected:\n        Database _db;\n};\n\nPROJECT_NAMESPACE_END\n\n#endif ///AROUTER_AROUTER_H_\n\n", "comment_ratio": 0.35135135135135137}
{"lang": "c", "code": "#pragma once\n\n#include <future>\n\nnamespace System {\n\nnamespace Detail {\n\ntemplate<class T> using Future = std::future<T>;\n\ntemplate<class T> Future<T> async(std::function<T()>&& operation) {\n  return std::async(std::launch::async, std::move(operation));\n}\n\n}\n\n}\n\n", "comment_ratio": 0.24}
{"lang": "c", "code": "#include <stdlib.h>\n#include <stdio.h>\n#include \"../include/apiClient.h\"\n#include \"../include/list.h\"\n#include \"../external/cJSON.h\"\n#include \"../include/keyValuePair.h\"\n#include \"../include/binary.h\"\n#include \"../model/v1_api_resource_list.h\"\n#include \"../model/v1_delete_options.h\"\n#include \"../model/v1_horizontal_pod_autoscaler.h\"\n#include \"../model/v1_horizontal_pod_autoscaler_list.h\"\n#include \"../model/v1_status.h\"\n\n\n// create a HorizontalPodAutoscaler\n//\nv1_horizontal_pod_autoscaler_t*\nAutoscalingV1API_createNamespacedHorizontalPodAutoscaler(apiClient_t *apiClient, char * _namespace , v1_horizontal_pod_autoscaler_t * body , char * pretty , char * dryRun , char * fieldManager );\n\n\n// delete collection of HorizontalPodAutoscaler\n//\nv1_status_t*\nAutoscalingV1API_deleteCollectionNamespacedHorizontalPodAutoscaler(apiClient_t *apiClient, char * _namespace , char * pretty , char * _continue , char * dryRun , char * fieldSelector , int gracePeriodSeconds , char * labelSelector , int limit , int orphanDependents , char * propagationPolicy , char * resourceVersion , char * resourceVersionMatch , int timeoutSeconds , v1_delete_options_t * body );\n\n\n// delete a HorizontalPodAutoscaler\n//\nv1_status_t*\nAutoscalingV1API_deleteNamespacedHorizontalPodAutoscaler(apiClient_t *apiClient, char * name , char * _namespace , char * pretty , char * dryRun , int gracePeriodSeconds , int orphanDependents , char * propagationPolicy , v1_delete_options_t * body );\n\n\n// get available resources\n//\nv1_api_resource_list_t*\nAutoscalingV1API_getAPIResources(apiClient_t *apiClient);\n\n\n// list or watch objects of kind HorizontalPodAutoscaler\n//\nv1_horizontal_pod_autoscaler_list_t*\nAutoscalingV1API_listHorizontalPodAutoscalerForAllNamespaces(apiClient_t *apiClient, int allowWatchBookmarks , char * _continue , char * fieldSelector , char * labelSelector , int limit , char * pretty , char * resourceVersion , char * resourceVersionMatch , int timeoutSeconds , int watch );\n\n\n// list or watch objects of kind HorizontalPodAutoscaler\n//\nv1_horizontal_pod_autoscaler_list_t*\nAutoscalingV1API_listNamespacedHorizontalPodAutoscaler(apiClient_t *apiClient, char * _namespace , char * pretty , int allowWatchBookmarks , char * _continue , char * fieldSelector , char * labelSelector , int limit , char * resourceVersion , char * resourceVersionMatch , int timeoutSeconds , int watch );\n\n\n// partially update the specified HorizontalPodAutoscaler\n//\nv1_horizontal_pod_autoscaler_t*\nAutoscalingV1API_patchNamespacedHorizontalPodAutoscaler(apiClient_t *apiClient, char * name , char * _namespace , object_t * body , char * pretty , char * dryRun , char * fieldManager , int force );\n\n\n// partially update status of the specified HorizontalPodAutoscaler\n//\nv1_horizontal_pod_autoscaler_t*\nAutoscalingV1API_patchNamespacedHorizontalPodAutoscalerStatus(apiClient_t *apiClient, char * name , char * _namespace , object_t * body , char * pretty , char * dryRun , char * fieldManager , int force );\n\n\n// read the specified HorizontalPodAutoscaler\n//\nv1_horizontal_pod_autoscaler_t*\nAutoscalingV1API_readNamespacedHorizontalPodAutoscaler(apiClient_t *apiClient, char * name , char * _namespace , char * pretty );\n\n\n// read status of the specified HorizontalPodAutoscaler\n//\nv1_horizontal_pod_autoscaler_t*\nAutoscalingV1API_readNamespacedHorizontalPodAutoscalerStatus(apiClient_t *apiClient, char * name , char * _namespace , char * pretty );\n\n\n// replace the specified HorizontalPodAutoscaler\n//\nv1_horizontal_pod_autoscaler_t*\nAutoscalingV1API_replaceNamespacedHorizontalPodAutoscaler(apiClient_t *apiClient, char * name , char * _namespace , v1_horizontal_pod_autoscaler_t * body , char * pretty , char * dryRun , char * fieldManager );\n\n\n// replace status of the specified HorizontalPodAutoscaler\n//\nv1_horizontal_pod_autoscaler_t*\nAutoscalingV1API_replaceNamespacedHorizontalPodAutoscalerStatus(apiClient_t *apiClient, char * name , char * _namespace , v1_horizontal_pod_autoscaler_t * body , char * pretty , char * dryRun , char * fieldManager );\n\n\n\n", "comment_ratio": 0.27586206896551724}
{"lang": "c", "code": "#ifndef NX_APEX_EMITTER_ACTOR_H\n#define NX_APEX_EMITTER_ACTOR_H\n\n#include \"NxApex.h\"\n\nnamespace physx\n{\nnamespace apex\n{\n\nPX_PUSH_PACK_DEFAULT\n\nclass NxApexEmitterAsset;\nclass NxEmitterExplicitGeom;\nclass NxEmitterLodParamDesc;\nclass NxApexRenderVolume;\n\n/// Apex emitter actor class. Emits particles within a given shape.\nclass NxApexEmitterActor : public NxApexActor\n{\nprotected:\n\tvirtual ~NxApexEmitterActor() {}\n\npublic:\n\n\t/// This is an optional user validation callback interface.\n\t/// If the application wants to confirm/verify all emitted particles they can provide\n\t/// this callback interface by using the setApexEmitterValidateCallback method.\n\tclass NxApexEmitterValidateCallback\n\t{\n\tpublic:\n\t\t/**\n\t\t\\brief This application callback is used to verify an emitted particle position.\n\t\tIf the user returns false, then the particle will not be emitted.  If the user returns true\n\t\tif will be emitted but using the position value which is passed by reference.  The application\n\t\tcan choose to leave the emitter position alone, or modify it to a new location.  All locations\n\t\tare in world space.  For convenience to the application the world space emitter position is provided.\n\t\t*/\n\t\tvirtual bool validateEmitterPosition(const physx::PxVec3 &emitterOrigin,physx::PxVec3 &position) = 0;\n\t};\n\n\t/**\n\t\\brief Returns the asset the instance has been created from.\n\t*/\n\tvirtual NxApexEmitterAsset* getEmitterAsset() const = 0;\n\n\t/**\n\t\\brief Returns the explicit geometry for THIS ACTOR only\n\t*/\n\tvirtual NxEmitterExplicitGeom* isExplicitGeom() = 0;\n\n\t/**\n\t\\brief Gets the global pose\n\t*/\n\tvirtual physx::PxMat44\t     getGlobalPose() const = 0;\n\t/**\n\t\\brief Sets the curent pose of the emitter\n\t*/\n\tvirtual void\t\t\t\t setCurrentPose(const physx::PxMat44& pose) = 0;\n\t/**\n\t\\brief Sets the curent position of the emitter\n\t*/\n\tvirtual void\t\t\t\t setCurrentPosition(const physx::PxVec3& pos) = 0;\n\n#if (NX_SDK_VERSION_MAJOR == 2) || defined(DOXYGEN)\n\t/**\n\t\\brief PhysX SDK 2.8.X.  Attaches the emitter to an actor\n\tNxActor pointer can be NULL to detach existing actor\n\t*/\n\tvirtual void\t\t\t\t setAttachActor(NxActor*) = 0;\n#endif\n#if (NX_SDK_VERSION_MAJOR == 3) || defined(DOXYGEN)\n\t/**\n\t\\brief PhysX SDK 3.X.  Attaches the emitter to an actor\n\tPxActor pointer can be NULL to detach existing actor\n\t*/\n\tvirtual void\t\t\t\t setAttachActor(PxActor*) = 0;\n#endif\n\t/**\n\t\\brief sets the relative pose of the emitter in the space of the actor to which it is attached\n\t*/\n\tvirtual void\t\t\t\t setAttachRelativePose(const physx::PxMat44& pose) = 0;\n\n#if (NX_SDK_VERSION_MAJOR == 2) || defined(DOXYGEN)\n\t/// PhysX SDK 2.8.X.  Retrieves the actor, to which the emitter is attached. NULL is returned for an unattached emitter.\n\tvirtual const NxActor* \t\t getAttachActor() const = 0;\n#endif\n#if (NX_SDK_VERSION_MAJOR == 3) || defined(DOXYGEN)\n\t/// PhysX SDK 3.X. Retrieves the actor, to which the emitter is attached. NULL is returned for an unattached emitter.\n\tvirtual const PxActor* \t\t getAttachActor() const = 0;\n#endif\n\t/// Retrieves the relative pose of the emitter in the space of the actor to which it is attached\n\tvirtual const physx::PxMat44 getAttachRelativePose() const = 0;\n\t///\tRetrieves the particle radius\n\tvirtual physx::PxF32         getObjectRadius() const = 0;\n\n\t/* Collision filtering settings for overlap tests */\n\t/// Sets collision groups used to reject particles that overlap the geometry\n\tvirtual void\t\t\t\tsetOverlapTestCollisionGroups(physx::PxU32) = 0;\n#if (NX_SDK_VERSION_MAJOR == 2) || defined(DOXYGEN)\n\t/// PhysX SDK 2.8.X only.  Sets collision groups mask. \\sa NxGroupsMask\n\tvirtual void\t\t\t\tsetOverlapTestCollisionGroupsMask(NxGroupsMask*) = 0;\n#endif\n\n\t/// Gets collision groups used to reject particles that overlap the geometry\n\tvirtual physx::PxU32\t\tgetOverlapTestCollisionGroups() const = 0;\n#if (NX_SDK_VERSION_MAJOR == 2) || defined(DOXYGEN)\n\t/// PhysX SDK 2.8.X only.  Gets collision groups mask. \\sa NxGroupsMask\n\tvirtual const NxGroupsMask*\tgetOverlapTestCollisionGroupsMask() const = 0;\n#endif\n\n\t/*\n\t\\brief start emitting particles\n\t * If persistent is true, the emitter will emit every frame until stopEmit() is\n\t * called.\n\t */\n\tvirtual void                 startEmit(bool persistent = true) = 0;\n\t///stop emitting particles\n\tvirtual void                 stopEmit() = 0;\n\t///true if the emitter is emitting particles\n\tvirtual bool                 isEmitting() const = 0;\n\n\t///\tGets LOD settings\n\tvirtual const NxEmitterLodParamDesc& getLodParamDesc() const = 0;\n\t///\tSets LOD settings\n\tvirtual void\t\t\t\t setLodParamDesc(const NxEmitterLodParamDesc&) = 0;\n\n\n\t/* Override authored scalable parameters, if necessary */\n\t///Sets the range from which the density of particles within the volume is randomly chosen\n\tvirtual void                 setDensityRange(const NxRange<physx::PxF32>&) = 0;\n\t///Sets the range from which the emission rate is randomly chosen\n\tvirtual void                 setRateRange(const NxRange<physx::PxF32>&) = 0;\n\n\t///Sets the range from which the velocity of a particle is randomly chosen\n\tvirtual void                 setVelocityRange(const NxRange<physx::PxVec3>&) = 0;\n\t///Sets the range from which the lifetime of a particle is randomly chosen\n\tvirtual void                 setLifetimeRange(const NxRange<physx::PxF32>&) = 0;\n\n\t///Sets whether or not authored asset particles are emitted\n\tvirtual void\t\t\t\t emitAssetParticles(bool enable) = 0;\n\t///Gets whether or not authored asset particles are emitted\n\tvirtual bool\t\t\t\t getEmitAssetParticles() const = 0;\n\n\t///Emitted particles are injected to specified render volume on initial frame.\n\t///This will work only if you have one renderVolume for each emitter.\n\t///Set to NULL to clear the preferred volume.\n\tvirtual void                 setPreferredRenderVolume(NxApexRenderVolume* volume) = 0;\n\n\t///Gets the range from which the emission rate is randomly chosen\n\tvirtual void                 getRateRange(NxRange<physx::PxF32>&) const = 0;\n\n\tvirtual PxU32\t\t\t\t getSimParticlesCount() const = 0;\n\n\t///Returns the number of particles still alive\n\tvirtual PxU32\t\t\t\t getActiveParticleCount() const = 0;\n\n\t///Sets the origin of the density grid used by this emitter.  Important, this density grid may be shared with lots of other emitters as well, it is based on the underlying IOS\n\tvirtual void\t\t\t\tsetDensityGridPosition(const physx::PxVec3 &pos) = 0;\n\n\t/// Sets the ApexEmitterPosition validation callback interface\n\tvirtual void setApexEmitterValidateCallback(NxApexEmitterValidateCallback *callback) = 0;\n\n\t///Sets the uniform overall object scale\n\tPX_DEPRECATED virtual void\t\t\t\tsetObjectScale(PxF32 scale) = 0;\n\n\t//Retrieves the uniform overall object scale\n\tPX_DEPRECATED virtual PxF32\t\t\t\tgetObjectScale(void) const = 0;\n\n\t///Sets the uniform overall object scale\n\tvirtual void\t\t\t\tsetCurrentScale(PxF32 scale) = 0;\n\n\t//Retrieves the uniform overall object scale\n\tvirtual PxF32\t\t\t\tgetCurrentScale(void) const = 0;\n\n\n};\n\nPX_POP_PACK\n\n}\n} // end namespace physx::apex\n\n#endif // NX_APEX_EMITTER_ACTOR_H\n\n", "comment_ratio": 0.17857142857142858}
{"lang": "c", "code": "// WinDE.h : main header file for the WINDE application\n//\n\n#if !defined(AFX_WINDE_H__EE9EA094_4CFF_424E_A6E4_E859677488B2__INCLUDED_)\n#define AFX_WINDE_H__EE9EA094_4CFF_424E_A6E4_E859677488B2__INCLUDED_\n\n#if _MSC_VER > 1000\n#pragma once\n#endif // _MSC_VER > 1000\n\n#ifndef __AFXWIN_H__\n\t#error include 'stdafx.h' before including this file for PCH\n#endif\n\n#include \"resource.h\"\t\t// main symbols\n\n/////////////////////////////////////////////////////////////////////////////\n// CWinDEApp:\n// See WinDE.cpp for the implementation of this class\n//\n\nclass CWinDEApp : public CWinApp\n{\npublic:\n\tCWinDEApp();\n\tHACCEL m_haccel;\n// Overrides\n\t// ClassWizard generated virtual function overrides\n\t//{{AFX_VIRTUAL(CWinDEApp)\n\tpublic:\n\tvirtual BOOL InitInstance();\n\tvirtual BOOL ProcessMessageFilter(int code, LPMSG lpMsg);\n\t//}}AFX_VIRTUAL\n\n// Implementation\n\n\t//{{AFX_MSG(CWinDEApp)\n\t//}}AFX_MSG\n\tDECLARE_MESSAGE_MAP()\n};\n\n\n/////////////////////////////////////////////////////////////////////////////\n\n//{{AFX_INSERT_LOCATION}}\n// Microsoft Visual C++ will insert additional declarations immediately before the previous line.\n\n#endif // !defined(AFX_WINDE_H__EE9EA094_4CFF_424E_A6E4_E859677488B2__INCLUDED_)\n\n", "comment_ratio": 0.3877551020408163}
{"lang": "c", "code": "#ifndef __seekpt_h__\r\n#define __seekpt_h__\r\n\r\n\r\nclass CSeekingPassThru : public ISeekingPassThru, public CUnknown\r\n{\r\npublic:\r\n    static CUnknown *CreateInstance(LPUNKNOWN pUnk, HRESULT *phr);\r\n    CSeekingPassThru(TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr);\r\n    ~CSeekingPassThru();\r\n\r\n    DECLARE_IUNKNOWN;\r\n    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);\r\n\r\n    STDMETHODIMP Init(BOOL bSupportRendering, IPin *pPin);\r\n\r\nprivate:\r\n    CPosPassThru              *m_pPosPassThru;\r\n};\r\n\r\n#endif\r\n\n", "comment_ratio": 0.3125}
{"lang": "c", "code": "#ifndef CQTSSATIMESCALEWIDGET_H\n#define CQTSSATIMESCALEWIDGET_H\n\n#include <QWidget>\n#include <QLayout>\n#include <QPaintEvent>\n#include <QVBoxLayout>\n#include <QSlider>\n#include <QPainter>\n#include \"copasi/core/CVector.h\"\n\nclass PaintWidget : public QWidget\n{\n  Q_OBJECT\n\npublic:\n  PaintWidget(QWidget* parent = 0, const char* name = 0, Qt::WindowFlags fl = Qt::WindowFlags());\n  ~PaintWidget();\n\n  void paintTimeScale(int select);\n\n  CVector< C_FLOAT64> mVector;\n  bool mClear;\n\nprotected:\n  void paintEvent(QPaintEvent *);\n\nprivate:\n  int mSelection;\n};\n\nclass CQTSSATimeScaleWidget : public QWidget\n{\n  Q_OBJECT\n\npublic:\n  CQTSSATimeScaleWidget(QWidget* parent = 0, const char* name = 0, Qt::WindowFlags fl = Qt::WindowFlags());\n  ~CQTSSATimeScaleWidget();\n\n  void paintTimeScale(CVector< C_FLOAT64> vector);\n  void clearWidget();\n\npublic slots:\n  void changedInterval();\n\nprivate:\n  QVBoxLayout * mpVLayout;\n  PaintWidget * mpPaintWidget;\n  QSlider * mpSlider;\n};\n\n#endif // CQTSSATIMESCALEWIDGET_H\n\n", "comment_ratio": 0.2328767123287671}
{"lang": "c", "code": "#ifndef LH264_COMMON_DEFS_H\r\n#define LH264_COMMON_DEFS_H\r\n\r\n#include <stdint.h>\r\n\r\ntypedef enum {\n  EVideoFormatRGB = 0,\n  EVideoFormatRGBA,\n  EVideoFormatBGR,\n  EVideoFormatBGRA,\n  EVideoFormatARGB,\n  EVideoFormatABGR,\n\n  EVidoeFormatYUYV,\n  EVideoformatYVYU,\n  EVideoformatUYVY,\n  EVideoFormatI420,\n} LH264VideoFormat;\r\n\r\n// Rec. ITU-T H.264 approved in 2019-05, Table 7-6.\r\n// \"When slice_type has a value in the range 5..9, it is a requirement of bitstream conformance\r\n// that all other slices of the current coded picture shall have a value of slice_type equal to\r\n// the current value of slice_type or equal to the current value of slice_type minus 5.\"\r\nenum ESliceType {\n  ESlice_Type_P  = 0,    // P slice\n  ESlice_Type_B  = 1,    // B slice\n  ESlice_Type_I  = 2,    // I slice\n  ESlice_Type_SP = 3,    // SP slice\n  ESlice_Type_SI = 4,    // SI slice\n  //Slice_Type_P = 5,    // P slice\n  //Slice_Type_B = 6,    // B slice\n  //Slice_Type_I = 7,    // I slice\n  //Slice_Type_SP = 8,    // SP slice\n  //Slice_Type_SI = 9,    // SI slice\n};\r\n\r\n\r\n#endif  // LH264_COMMON_DEFS_H\r\n\r\n\n", "comment_ratio": 0.2054794520547945}
{"lang": "c", "code": "#pragma once\n#include \"Flux.h\"\n#include \"Utilities.h\"\n#include <arpa/inet.h>\n\ntypedef union\n{\n\tstruct sockaddr_in  ipv4;\n\tstruct sockaddr_in6 ipv6;\n\tstruct sockaddr\t\tsa;\n} sockaddr_t;\n\n// clang-format off\ntypedef enum\n{\n\t// Misc socket statuses.\n\tSS_DEAD       = 1 << 1,\n\tSS_WRITABLE   = 1 << 2,\n\t// For connecting sockets\n\tSS_CONNECTING = 1 << 3,\n\tSS_CONNECTED  = 1 << 4,\n\t// For Binding sockets.\n\tSS_ACCEPTING  = 1 << 5,\n\tSS_ACCEPTED   = 1 << 6,\n\t// Multiplexer statuses\n\tMX_WRITABLE   = 1 << 7,\n\tMX_READABLE   = 1 << 8\n} socketstatus_t;\n// clang-format on\n\nclass Socket : public Flags<socketstatus_t>\n{\n  protected:\n\tint\t\t   sock_fd;\n\tsockaddr_t sa;\n\n  public:\n\t// Delete the default constructor because it causes all kinds of fucking issues.\n\tSocket() = delete;\n\tSocket(int sock, int type, int protocol = SOCK_STREAM);\n\tvirtual ~Socket();\n\n\t// Socket Flags\n\tvoid SetNonBlocking(bool status);\n\n\t// I/O functions, these are overwritten in the sub-class sockets.\n\tvirtual size_t Write(const void *data, size_t len);\n\tvirtual size_t Read(void *data, size_t len);\n\n\t// Getters/Setters\n\tinline int GetFD() { return this->sock_fd; }\n\n\t// Interaction with the SocketMultiplexer\n\tvirtual bool MultiplexEvent();\n\tvirtual void MultiplexError();\n\tvirtual bool MultiplexRead();\n\tvirtual bool MultiplexWrite();\n\n\tstatic Flux::string GetAddress(sockaddr_t saddr);\n\tstatic short\t\tGetPort(sockaddr_t s);\n\tstatic sockaddr_t   GetSockAddr(int type, const Flux::string &addr, int port);\n};\n\nclass ConnectionSocket : public virtual Socket\n{\n\tFlux::string address;\n\tshort\t\t port;\n\n  public:\n\tConnectionSocket(bool ipv6);\n\tvirtual ~ConnectionSocket();\n\n\tbool MultiplexEvent();\n\tvoid MultiplexError();\n\n\tvoid Connect(const Flux::string &address, short port);\n\n\tvirtual void OnConnect() = 0;\n\tvirtual void OnError(const Flux::string &str);\n};\n\nclass ClientSocket;\n\nclass ListeningSocket : public virtual Socket\n{\n  protected:\n\tFlux::string address;\n\tshort\t\t port;\n\tbool\t\t ipv6;\n\n  public:\n\tListeningSocket(const Flux::string &bindaddr, short port, bool ipv6);\n\tvirtual ~ListeningSocket();\n\tbool MultiplexRead();\n\n\tvirtual ClientSocket *OnAccept(int fd, const sockaddr_t &addr) = 0;\n};\n\nclass ClientSocket : public virtual Socket\n{\n  public:\n\tListeningSocket *ls;\n\tClientSocket(ListeningSocket *ls, int sock_fd, const sockaddr_t &addr, bool ipv6);\n\tbool\t\t MultiplexEvent();\n\tvoid\t\t MultiplexError();\n\tvirtual void OnAccept();\n\tvirtual void OnError(const Flux::string &str);\n};\n\n", "comment_ratio": 0.22556390977443608}
{"lang": "c", "code": "#ifndef COMPONENTS_OFFLINE_PAGES_CORE_OFFLINE_STORE_TYPES_H_\n#define COMPONENTS_OFFLINE_PAGES_CORE_OFFLINE_STORE_TYPES_H_\n\n#include <stdint.h>\n\n#include <utility>\n#include <vector>\n\n// This file contains common types and callbacks used by storage of various\n// offline page related components.\nnamespace offline_pages {\n\n// Current store state. When LOADED, the store is operational. When\n// loading or reset fails, it is reflected appropriately.\nenum class StoreState {\n  NOT_LOADED,      // Store is not loaded yet.\n  LOADED,          // Store is properly loaded and operational.\n  FAILED_LOADING,  // Store initialization failed.\n  FAILED_RESET,    // Resetting the store failed.\n  INITIALIZING,    // Store is in the process of initializing.\n};\n\n// Statuses referring to actions taken on items in the stores.\n// GENERATED_JAVA_ENUM_PACKAGE:org.chromium.components.offlinepages\nenum class ItemActionStatus {\n  SUCCESS,\n  ALREADY_EXISTS,\n  NOT_FOUND,\n  STORE_ERROR,\n};\n\n// Result for synchronous operations (like database and file operations) that\n// are part of the tasks used by Offline Pages.\n// Keep it in sync with OfflinePagesSyncOperationResult in enums.xml for\n// histograms usages.\nenum class SyncOperationResult {\n  SUCCESS,                   // Successful operation\n  INVALID_DB_CONNECTION,     // Invalid database connection\n  TRANSACTION_BEGIN_ERROR,   // Failed when start a DB transaction\n  TRANSACTION_COMMIT_ERROR,  // Failed when commiting a DB transaction\n  DB_OPERATION_ERROR,        // Failed when executing a DB statement\n  FILE_OPERATION_ERROR,      // Failed while doing file operations\n  kMaxValue = FILE_OPERATION_ERROR,\n};\n\n// List of item action statuses mapped to item ID.\ntypedef std::vector<std::pair<int64_t, ItemActionStatus>> MultipleItemStatuses;\n\n// Collective result for store update.\ntemplate <typename T>\nclass StoreUpdateResult {\n public:\n  explicit StoreUpdateResult(StoreState state) : store_state(state) {}\n  ~StoreUpdateResult() {}\n\n  // Move-only to avoid accidental copies.\n  StoreUpdateResult(const StoreUpdateResult& other) = delete;\n  StoreUpdateResult(StoreUpdateResult&& other) = default;\n\n  StoreUpdateResult& operator=(const StoreUpdateResult&) = delete;\n  StoreUpdateResult& operator=(StoreUpdateResult&&) = default;\n\n  // List of Offline ID to item action status mappings.\n  // It is meant to be consumed by the original caller of the operation.\n  MultipleItemStatuses item_statuses;\n\n  // List of successfully updated offline page items as seen after operation\n  // concludes. It is meant to be used when passing to the observers.\n  std::vector<T> updated_items;\n\n  // State of the store after the operation is done.\n  StoreState store_state;\n};\n\n// This enum is backed by a UMA histogram therefore its entries should not be\n// deleted or re-ordered and new ones should only be appended.\n// See enum definition with the same name in tools/metrics/histograms/enum.xml.\nenum class OfflinePagesStoreEvent {\n  kOpenedFirstTime = 0,\n  kReopened = 1,\n  kClosed = 2,\n  kCloseSkipped = 3,\n  kMaxValue = kCloseSkipped,\n};\n\n}  // namespace offline_pages\n\n#endif  // COMPONENTS_OFFLINE_PAGES_CORE_OFFLINE_STORE_TYPES_H_\n\n", "comment_ratio": 0.3978494623655914}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n#import \"SortOrder.h\"\n\n@interface SortDefinition : NSObject{\n    \n    @private DataSortOrder sortOrder;// = SortOrder.Ascending;\n    NSString *ColumnNameWithoutAlias;\n}\n@property (readwrite,assign) DataSortOrder sortOrder;\n\n@property (readwrite,strong) NSString *ColumnNameWithoutAlias;\n\n\n- (id)initWithSortDefinition: (NSString*) columnName withOrder:(DataSortOrder) order;\n\n- (NSString *) ColumnName;\n- (void) setColumnName:(NSString *) value;\n\n- (DataSortOrder) Order;\n- (void) setOrder:(DataSortOrder) value;\n\n-(DataSortOrder)ReverseOrder;\n\n\n\n@end\n\n", "comment_ratio": 0.22857142857142856}
{"lang": "c", "code": "#ifndef IGL_PATH_TO_EDGES_H\n#define IGL_PATH_TO_EDGES_H\n\n#include \"igl_inline.h\"\n\n#include <Eigen/Core>\n\n#include <vector>\n\nnamespace igl\n{\n  // Given a path as an ordered list of N>=2 vertex indices I[0], I[1], ..., I[N-1]\n  // construct a list of edges [[I[0],I[1]], [I[1],I[2]], ..., [I[N-2], I[N-1]]]\n  // connecting each sequential pair of vertices.\n  //\n  // Inputs:\n  //   I  #I list of vertex indices\n  //   make_loop bool If true, include an edge connecting I[N-1] to I[0]\n  // Outputs:\n  //   E  #I-1 by 2 list of edges\n  // \n  template <typename DerivedI, typename DerivedE>\n  IGL_INLINE void path_to_edges(\n    const Eigen::MatrixBase<DerivedI> & I,\n    Eigen::PlainObjectBase<DerivedE> & E,\n    bool make_loop=false);\n  \n  template <typename Index, typename DerivedE>\n  IGL_INLINE void path_to_edges(\n    const std::vector<Index> & I,\n    Eigen::PlainObjectBase<DerivedE> & E,\n    bool make_loop=false);\n\n}\n#ifndef IGL_STATIC_LIBRARY\n#  include \"path_to_edges.cpp\"\n#endif\n#endif\n\n", "comment_ratio": 0.3695652173913043}
{"lang": "c", "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <tiledb/tiledb.h>\n\n// Name of array.\nconst char* array_name = \"array_metadata_array\";\n\nvoid create_array() {\n  // Create TileDB context\n  tiledb_ctx_t* ctx;\n  tiledb_ctx_alloc(NULL, &ctx);\n\n  // Create some array (it can be dense or sparse, with\n  // any number of dimensions and attributes).\n  int dim_domain[] = {1, 4, 1, 4};\n  int tile_extents[] = {4, 4};\n  tiledb_dimension_t* d1;\n  tiledb_dimension_alloc(\n      ctx, \"rows\", TILEDB_INT32, &dim_domain[0], &tile_extents[0], &d1);\n  tiledb_dimension_t* d2;\n  tiledb_dimension_alloc(\n      ctx, \"cols\", TILEDB_INT32, &dim_domain[2], &tile_extents[1], &d2);\n\n  // Create domain\n  tiledb_domain_t* domain;\n  tiledb_domain_alloc(ctx, &domain);\n  tiledb_domain_add_dimension(ctx, domain, d1);\n  tiledb_domain_add_dimension(ctx, domain, d2);\n\n  // Create a single attribute \"a\" so each (i,j) cell can store an integer\n  tiledb_attribute_t* a;\n  tiledb_attribute_alloc(ctx, \"a\", TILEDB_INT32, &a);\n\n  // Create array schema\n  tiledb_array_schema_t* array_schema;\n  tiledb_array_schema_alloc(ctx, TILEDB_SPARSE, &array_schema);\n  tiledb_array_schema_set_cell_order(ctx, array_schema, TILEDB_ROW_MAJOR);\n  tiledb_array_schema_set_tile_order(ctx, array_schema, TILEDB_ROW_MAJOR);\n  tiledb_array_schema_set_domain(ctx, array_schema, domain);\n  tiledb_array_schema_add_attribute(ctx, array_schema, a);\n\n  // Create array\n  tiledb_array_create(ctx, array_name, array_schema);\n\n  // Clean up\n  tiledb_attribute_free(&a);\n  tiledb_dimension_free(&d1);\n  tiledb_dimension_free(&d2);\n  tiledb_domain_free(&domain);\n  tiledb_array_schema_free(&array_schema);\n  tiledb_ctx_free(&ctx);\n}\n\nvoid write_array_metadata() {\n  // Create TileDB context\n  tiledb_ctx_t* ctx;\n  tiledb_ctx_alloc(NULL, &ctx);\n\n  // Open array for writing\n  tiledb_array_t* array;\n  tiledb_array_alloc(ctx, array_name, &array);\n  tiledb_array_open(ctx, array, TILEDB_WRITE);\n\n  // Write some metadata\n  int v = 100;\n  tiledb_array_put_metadata(ctx, array, \"aaa\", TILEDB_INT32, 1, &v);\n  float f[] = {1.1f, 1.2f};\n  tiledb_array_put_metadata(ctx, array, \"bb\", TILEDB_FLOAT32, 2, f);\n\n  // Close array - Important so that the metadata get flushed\n  tiledb_array_close(ctx, array);\n\n  // Clean up\n  tiledb_array_free(&array);\n  tiledb_ctx_free(&ctx);\n}\n\nvoid read_array_metadata() {\n  // Create TileDB context\n  tiledb_ctx_t* ctx;\n  tiledb_ctx_alloc(NULL, &ctx);\n\n  // Open array for reading\n  tiledb_array_t* array;\n  tiledb_array_alloc(ctx, array_name, &array);\n  tiledb_array_open(ctx, array, TILEDB_READ);\n\n  // Read with key\n  tiledb_datatype_t v_type;\n  uint32_t v_num;\n  const void* v;\n  tiledb_array_get_metadata(ctx, array, \"aaa\", &v_type, &v_num, &v);\n  printf(\"Details of item with key: '%s'\\n\", \"aaa\");\n  printf(\n      \"- Value type: %s\\n\",\n      (v_type == TILEDB_INT32) ? \"INT32\" : \"something went wrong\");\n  printf(\"- Value num: %u\\n\", v_num);\n  printf(\"- Value: %i\\n\", *(const int*)v);\n\n  tiledb_array_get_metadata(ctx, array, \"bb\", &v_type, &v_num, &v);\n  printf(\"Details of item with key: '%s'\\n\", \"bb\");\n  printf(\n      \"- Value type: %s\\n\",\n      (v_type == TILEDB_FLOAT32) ? \"FLOAT32\" : \"something went wrong\");\n  printf(\"- Value num: %u\\n\", v_num);\n  printf(\"- Value: %f, %f\\n\", ((const float*)v)[0], ((const float*)v)[1]);\n\n  // Enumerate all metadata items\n  uint64_t num = 0;\n  const char* key;\n  uint32_t key_len;\n  tiledb_array_get_metadata_num(ctx, array, &num);\n  printf(\"Enumerate all metadata items:\\n\");\n  for (uint64_t i = 0; i < num; ++i) {\n    tiledb_array_get_metadata_from_index(\n        ctx, array, i, &key, &key_len, &v_type, &v_num, &v);\n\n    printf(\"# Item %i\\n\", (int)i);\n    const char* v_type_str = (v_type == TILEDB_INT32) ? \"INT32\" : \"FLOAT32\";\n    printf(\"- Key: %.*s\\n\", key_len, key);\n    printf(\"- Value type: %s\\n\", v_type_str);\n    printf(\"- Value num: %u\\n\", v_num);\n    printf(\"- Value: \");\n    if (v_type == TILEDB_INT32) {\n      for (uint32_t j = 0; j < v_num; ++j)\n        printf(\"%i \", ((const int*)v)[j]);\n    } else if (v_type == TILEDB_FLOAT32) {\n      for (uint32_t j = 0; j < v_num; ++j)\n        printf(\"%f \", ((const float*)v)[j]);\n    }\n    printf(\"\\n\");\n  }\n\n  // Close array\n  tiledb_array_close(ctx, array);\n  tiledb_array_free(&array);\n  tiledb_ctx_free(&ctx);\n}\n\nint main() {\n  create_array();\n  write_array_metadata();\n  read_array_metadata();\n\n  return 0;\n}\n\n", "comment_ratio": 0.10614525139664804}
{"lang": "c", "code": "#include \"mariost.h\"\n\n#include \"battle/battle.h\"\n\n#include \"drv/animdrv.h\"\n#include \"drv/arcdrv.h\"\n#include \"drv/bgdrv.h\"\n#include \"drv/camdrv.h\"\n#include \"drv/casedrv.h\"\n#include \"drv/dispdrv.h\"\n#include \"drv/effdrv.h\"\n#include \"drv/envdrv.h\"\n#include \"drv/extdrv.h\"\n#include \"drv/fadedrv.h\"\n#include \"drv/hitdrv.h\"\n#include \"drv/icondrv.h\"\n#include \"drv/imgdrv.h\"\n#include \"drv/itemdrv.h\"\n#include \"drv/lightdrv.h\"\n#include \"drv/mapdrv.h\"\n#include \"drv/mobjdrv.h\"\n#include \"drv/msgdrv.h\"\n#include \"drv/npcdrv.h\"\n#include \"drv/offscreendrv.h\"\n#include \"drv/seqdrv.h\"\n#include \"drv/shadowdrv.h\"\n#include \"drv/swdrv.h\"\n#include \"drv/windowdrv.h\"\n\n#include \"evt/evt_badgeshop.h\"\n#include \"evt/evt_johoya.h\"\n#include \"evt/evt_yuugijou.h\"\n\n#include \"mgr/arammgr.h\"\n#include \"mgr/cardmgr.h\"\n#include \"mgr/dvdmgr.h\"\n#include \"mgr/evtmgr.h\"\n#include \"mgr/filemgr.h\"\n#include \"mgr/fontmgr.h\"\n#include \"mgr/winmgr.h\"\n\n#include \"sdk/DEMOInit.h\"\n\n#include \"win/win_main.h\"\n\n#include \"countdown.h\"\n#include \"error_handler.h\"\n#include \"mario.h\"\n#include \"memory.h\"\n#include \"nameent.h\"\n#include \"pmario_sound.h\"\n#include \"romfont.h\"\n#include \"sound.h\"\n#include \"statuswindow.h\"\n#include \"system.h\"\n\n#include <dolphin/vi.h>\n#include <string.h>\n\nextern void DEMOPadInit(void);\nextern BOOL g_bFirstSmartAlloc;\n\n//.bss\nstatic u8 stack[0x1000];\nOSThread DvdCheckThread;\nGlobalWork marioSt;\n\n//.sdata\nGlobalWork* gp = &marioSt;\nBOOL aoff_trg[4];\nOSTime aoff_time[4];\n\n//.sbss\nBOOL DvdCheckThreadOn; //DvdCheckTreadOn\ns32 _mariostSystemLevel;\nstatic OSTime none_key;\n\n//.data\nGXRenderModeObj sRMObjHReso = {\n\tVI_TVMODE_NTSC_INT, //viTVmode\n\t0x260, //fbWidth\n\t0x1C0, //efbHeight\n\t0x1C0, //xfbHeight\n\t0x1B, //viXOrigin\n\t0x10, //viYOrigin\n\t0x29A, //viWidth\n\t0x1C0, //viHeight\n\tVI_XFBMODE_DF, //xFBmode\n\t0, //field_rendering\n\t0, //aa\n\t6, 6, 6, 6, 6, 6, //pix 0\n\t6, 6, 6, 6, 6, 6, //pix 1\n\t6, 6, 6, 6, 6, 6, //pix 2\n\t6, 6, 6, 6, 6, 6, //pix 3\n\t8, 8, 10, 12, 10, 8, 8, //vfilter\n};\n\nGXRenderModeObj sRMObjHReso_prog = {\n\tVI_TVMODE_NTSC_PROG, //viTVmode\n\t0x260, //fbWidth\n\t0x1C0, //efbHeight\n\t0x1C0, //xfbHeight\n\t0x1B, //viXOrigin\n\t0x10, //viYOrigin\n\t0x29A, //viWidth\n\t0x1C0, //viHeight\n\tVI_XFBMODE_SF, //xFBmode\n\t0, //field_rendering\n\t0, //aa\n\t6, 6, 6, 6, 6, 6, //pix 0\n\t6, 6, 6, 6, 6, 6, //pix 1\n\t6, 6, 6, 6, 6, 6, //pix 2\n\t6, 6, 6, 6, 6, 6, //pix 3\n\t8, 8, 10, 12, 10, 8, 8, //vfilter\n};\n\nGXRenderModeObj GXNtsc480IntDfMarioSt = {\n\tVI_TVMODE_NTSC_INT, //viTVmode\n\t0x260, //fbWidth\n\t0x1E0, //efbHeight\n\t0x1E0, //xfbHeight\n\t0x1E, //viXOrigin\n\t0x0, //viYOrigin\n\t0x294, //viWidth\n\t0x1E0, //viHeight\n\tVI_XFBMODE_DF, //xFBmode\n\t0, //field_rendering\n\t0, //aa\n\t6, 6, 6, 6, 6, 6, //pix 0\n\t6, 6, 6, 6, 6, 6, //pix 1\n\t6, 6, 6, 6, 6, 6, //pix 2\n\t6, 6, 6, 6, 6, 6, //pix 3\n\t8, 8, 10, 12, 10, 8, 8, //vfilter\n};\n\nGXRenderModeObj GXNtsc480ProgMarioSt = {\n\tVI_TVMODE_NTSC_PROG, //viTVmode\n\t0x260, //fbWidth\n\t0x1E0, //efbHeight\n\t0x1E0, //xfbHeight\n\t0x1E, //viXOrigin\n\t0x0, //viYOrigin\n\t0x294, //viWidth\n\t0x1E0, //viHeight\n\tVI_XFBMODE_SF, //xFBmode\n\t0, //field_rendering\n\t0, //aa\n\t6, 6, 6, 6, 6, 6, //pix 0\n\t6, 6, 6, 6, 6, 6, //pix 1\n\t6, 6, 6, 6, 6, 6, //pix 2\n\t6, 6, 6, 6, 6, 6, //pix 3\n\t8, 8, 10, 12, 10, 8, 8, //vfilter\n};\n\n//local prototypes\nvoid viPostCallback(u32 retraceCount);\nvoid* gcDvdCheckThread(void* param);\nvoid gcRumbleCheck(void);\nvoid gcResetCheck(void);\n\nvoid marioStInit(void) {\n\tif (!OSIsRestart() || (OSGetResetCode() & OS_RESET_SHUTDOWN)) {\n\t\tDEMOInit(&GXNtsc480IntDfMarioSt);\n\t}\n\telse {\n\t\tswitch (OSGetResetCode() & OS_RESET_HOTRESET) {\n\t\tcase 0:\n\t\t\tDEMOInit(&GXNtsc480IntDfMarioSt);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tDEMOInit(&GXNtsc480ProgMarioSt);\n\t\t\tbreak;\n\t\t}\n\t}\n\tDEMOEnableGPHangWorkaround(5);\n\tsetupErrorHandler();\n\tDEMOPadInit();\n\tGXSetCopyClear((GXColor) { 0, 0, 0, 0 }, 0xFFFFFF);\n\t__GXSetIndirectMask(0);\n\tmemset(gp, 0, sizeof(GlobalWork));\n\tgp->fbWidth = DEMOGetRenderModeObj()->fbWidth;\n\tgp->efbHeight = DEMOGetRenderModeObj()->efbHeight;\n\tgp->field_0x1294 = 1;\n\tgp->field_0x1274 = 0;\n\n\tgp->mLastFrameRetraceLocalTime = 0;\n\tgp->mLastFrameRetraceDeltaTime = 0;\n\n\tgp->mLastFrameRetraceTime = OSGetTime();\n\n\tgp->mAnimationTimeNoBattle = 0;\n\tgp->mAnimationTimeInclBattle = 0;\n\n\tgp->field_0x60 = 0;\n\tgp->field_0x58 = 0;\n\tgp->field_0x50 = 0;\n\tgp->field_0x48 = 0;\n\n\tgp->mNextMapChangeFadeOutType = 9;\n\tgp->mNextMapChangeFadeOutDuration = 300;\n\tgp->mNextMapChangeFadeInType = 10;\n\tgp->mNextMapChangeFadeInDuration = 300;\n\tgp->mNextAreaChangeFadeOutType = 9;\n\tgp->mNextAreaChangeFadeOutDuration = 300;\n\tgp->mNextAreaChangeFadeInType = 10;\n\tgp->mNextAreaChangeFadeInDuration = 300;\n\tif ((OSGetFontEncode() == OS_FONT_ENCODE_SJIS) && !(gp->mFlags & 0x1000))\n\t\tgp->mLanguage = 0;\n\telse\n\t\tgp->mLanguage = 1;\n\tgp->mFPS = 60;\n\tgp->mSystemLevelFlags = 0;\n\tbadgeShop_init(); //Badge Shop\n\tyuugijou_init(); //Pianta Parlor\n\tjohoya_init(); //?????\n\tgp->mpMapAlloc = __memAlloc(HEAP_DEFAULT, 660 * 1024);\n\tVISetPostRetraceCallback(viPostCallback);\n\tromFontInit();\n\tOSCreateThread(&DvdCheckThread, gcDvdCheckThread, NULL, (void*)((u32)&stack + sizeof(stack)), sizeof(stack), 16, OS_THREAD_ATTR_DETACH);\n\tDvdCheckThreadOn = TRUE;\n\tOSResumeThread(&DvdCheckThread);\n\tDVDMgrInit();\n\tpsndInit();\n\taramMgrInit();\n\tfileInit();\n\tsmartInit();\n\tdispInit();\n\tcamInit();\n\tfontmgrInit();\n\twindowInit();\n\tmapInit();\n\thitInit();\n\titemInit();\n\ticonInit();\n\tfadeInit();\n\tbgInit();\n\tshadowInit();\n\tevtmgrInit();\n\tanimInit();\n\tmsgInit();\n\tnpcInit();\n\tmobjInit();\n\teffInit();\n\tmarioInit();\n\tcaseInit();\n\timgInit();\n\tlightInit();\n\toffscreenInit();\n\tarcInit();\n\textInit();\n\tswInit();\n\tcardInit();\n\twinInit();\n\tstatusWinInit();\n\tenvInit();\n\tcountDownInit();\n\tnameEntInit();\n\twinMgrInit();\n\tseqInit_MARIOSTORY();\n\tseqSetSeq(0, NULL, NULL);\n\tgp->field_0x1274 = 0;\n\tif (OSGetSoundMode() == OS_SOUND_MODE_MONO) {\n\t\tSoundSetOutputMode(SND_OUTPUTMODE_MONO);\n\t}\n\telse {\n\t\tSoundSetOutputMode(SND_OUTPUTMODE_STEREO);\n\t}\n}\n\nvoid marioStMain(void) {\n\tint i;\n\n\twhile (gp->mDVDError) {\n\t\tOSYieldThread();\n\t}\n\tmakeKey();\n\tseqMain();\n\tcardMain();\n\tbgMain();\n\tshadowMain();\n\tanimMain();\n\tbattleMain();\n\tcamMain();\n\twindowMain();\n\tmapMain();\n\thitMain();\n\tevtmgrMain();\n\tmapDisp();\n\tmarioMain();\n\tmobjMain();\n\tnpcMain();\n\tfadeMain();\n\timgMain();\n\tlightMain();\n\toffscreenMain();\n\titemMain();\n\tcaseMain();\n\ticonMain();\n\textMain();\n\tpsndMain();\n\twinMain();\n\tstatusWinMain();\n\tenvMain();\n\tcountDownMain();\n\tnameEntMain();\n\twinMgrMain();\n\teffMain();\n\tgcResetCheck();\n\tif (gp->mFlags & 0x1000) {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tif (gp->mDir[i]) break;\n\t\t\tif (gp->mButton[i]) break;\n\t\t\tif (gp->mStickX[i]) break;\n\t\t\tif (gp->mStickY[i]) break;\n\t\t\tif (gp->mSubStickX[i]) break;\n\t\t\tif (gp->mSubStickY[i]) break;\n\t\t\tif (gp->mTriggerL[i]) break;\n\t\t\tif (gp->mTriggerR[i]) break;\n\t\t}\n\t}\n\tif (i >= 4) {\n\t\tif (OSTicksToSeconds(OSGetTime() - none_key) > 120 && (seqGetSeq() == 2 || seqGetSeq() == 4)) {\n\t\t\tgp->mFlags |= 0x2000u;\n\t\t}\n\t}\n\telse {\n\t\tnone_key = OSGetTime();\n\t}\n}\n\nvoid marioStDisp(void) {\n\tcamDraw();\n\tg_bFirstSmartAlloc = 0;\n}\n\nvoid marioStSystemLevel(s32 level) {\n\tswitch (level) {\n\t\tcase 0:\n\t\t\t_mariostSystemLevel = level;\n\t\t\tgp->mSystemLevelFlags &= ~0xF;\n\t\t\tevtStartAll(0xEF);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t_mariostSystemLevel = level;\n\t\t\tgp->mSystemLevelFlags &= ~0xE;\n\t\t\tgp->mSystemLevelFlags |= 1;\n\t\t\tevtStopAll(1);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t_mariostSystemLevel = level;\n\t\t\tgp->mSystemLevelFlags &= ~0xC;\n\t\t\tgp->mSystemLevelFlags |= 3;\n\t\t\tevtStopAll(2);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\t_mariostSystemLevel = level;\n\t\t\tgp->mSystemLevelFlags &= ~8;\n\t\t\tgp->mSystemLevelFlags |= 7;\n\t\t\tevtStopAll(0x10);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\t_mariostSystemLevel = level;\n\t\t\tgp->mSystemLevelFlags |= 0xF;\n\t\t\tevtStopAll(0xEF);\n\t\t\tbreak;\n\t}\n}\n\ns32 marioStGetSystemLevel(void) {\n\treturn gp->mSystemLevelFlags;\n}\n\nvoid viPostCallback(u32 retraceCount) {\n\n}\n\n//TODO: fuck up float conversions for 1:1 cuz this is cleaner\nvoid* gcDvdCheckThread(void* param) {\n\tconst char* message;\n\ts32 msgId;\n\tf32 width;\n\tMtx44 mtx;\n\n\twhile (1) {\n\t\tmsgId = 0;\n\t\tswitch (DVDGetDriveStatus()) {\n\t\t\tcase DVD_STATE_COVER_OPEN:\n\t\t\t\tmsgId = 5;\n\t\t\t\tgp->mDVDError = TRUE;\n\t\t\t\tbreak;\n\t\t\tcase DVD_STATE_NO_DISK:\n\t\t\t\tmsgId = 6;\n\t\t\t\tgp->mDVDError = TRUE;\n\t\t\t\tbreak;\n\t\t\tcase DVD_STATE_WRONG_DISK:\n\t\t\t\tmsgId = 6;\n\t\t\t\tgp->mDVDError = TRUE;\n\t\t\t\tbreak;\n\t\t\tcase DVD_STATE_RETRY:\n\t\t\t\tmsgId = 7;\n\t\t\t\tgp->mDVDError = TRUE;\n\t\t\t\tbreak;\n\t\t\tcase DVD_RESULT_FATAL_ERROR:\n\t\t\t\tmsgId = 8;\n\t\t\t\tgp->mDVDError = TRUE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgp->mDVDError = FALSE;\n\t\t\t\tbreak;\n\t\t\tcase DVD_STATE_WAITING:\n\t\t\t\tbreak;\n\t\t}\n\t\tif (gp->mDVDError) {\n\t\t\tSoundOpenCover();\n\t\t}\n\t\telse {\n\t\t\tSoundCloseCover();\n\t\t}\n\t\tif (gp->mDVDError) {\n\t\t\tif (cardIsExec()) {\n\t\t\t\tgp->mDVDError = 0;\n\t\t\t}\n\t\t}\n\t\tif (gp->mDVDError) {\n\t\t\tDEMOBeforeRender();\n\t\t\tif (msgId) {\n\t\t\t\tmessage = romFontGetMessage(msgId);\n\t\t\t\twidth = (f32)romFontGetWidth(message);\n\t\t\t\tMTXPerspective(mtx, 25.0f, 1.2666667f, 1.0f, 10000.0f);\n\t\t\t\tGXSetProjection(mtx, GX_PERSPECTIVE);\n\t\t\t\tromFontPrintGX(-width * 0.5f, 60.0f, 1.0f, (GXColor){0xFF, 0xFF, 0xFF, 0xFF}, message);\n\t\t\t}\n\t\t\tDEMODoneRender();\n\t\t\tmakeKey();\n\t\t\tgcResetCheck();\n\t\t}\n\t\tOSYieldThread();\n\t}\n}\n\nvoid gcRumbleCheck(void) {\n\t/*OSTime start;\n\tvolatile BOOL array[4] = { 0 };\n\tint i;\n\n\tstart = OSGetTime();\n\tfor (i = 0; i < 4; i++) {\n\t\tif (gp->field_0x12E8[i]) {\n\t\t\tif (OSTicksToMilliseconds(start - gp->field_0x12F0[i]) > 30000) {\n\t\t\t\tgp->field_0x12EC[i] = 0;\n\t\t\t\tgp->field_0x12E8[i] = 0;\n\t\t\t}\n\t\t\tarray[i] = TRUE;\n\t\t}\n\t}*/\n}\n\nvoid gcResetCheck(void) {\n\tu32 code;\n\n\tif (gp->field_0x1278) {\n\t\tVISetBlack(TRUE);\n\t\tVIFlush();\n\t\tVIWaitForRetrace();\n\t\tVIWaitForRetrace();\n\t\tVIWaitForRetrace();\n\t\tpsndExit();\n\t\tDVDMgrDelete();\n\t\tif ((OSGetCurrentThread() != &DvdCheckThread) && DvdCheckThreadOn) {\n\t\t\tOSCancelThread(&DvdCheckThread);\n\t\t\tDvdCheckThreadOn = FALSE;\n\t\t}\n\t\twhile (cardIsExec()) {\n\t\t\tcardMain();\n\t\t\tVIWaitForRetrace();\n\t\t}\n\t\tif (gp->field_0x1278 != 2) {\n\t\t\tif (!(gp->mFlags & 4)) {\n\t\t\t\tcode = OS_RESET_SHUTDOWN;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!(gp->mFlags & 8)) {\n\t\t\t\t\tcode = OS_RESET_RESTART;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcode = OS_RESET_HOTRESET;\n\t\t\t\t}\n\t\t\t}\n\t\t\tOSResetSystem(OS_RESET_RESTART, code, FALSE);\n\t\t}\n\t\telse {\n\t\t\tOSResetSystem(OS_RESET_HOTRESET, 0, TRUE);\n\t\t}\n\t\twhile (1) {}\n\t}\n}\n", "comment_ratio": 0.14919354838709678}
{"lang": "c", "code": "#import <Cocoa/Cocoa.h>\n@class MEConnection;\n@class MEDatabase;\n@class MECursor;\n@class MEArray;\n\n@interface MECollection : NSObject {\n}\n\n@property(nonatomic, retain) MEConnection *connection;\n@property(nonatomic, retain) MEDatabase *database;\n@property(nonatomic, copy) NSString *fullName;\n@property(nonatomic, copy) NSString *name;\n@property(nonatomic, readonly) NSUInteger documentsCount;\n@property(nonatomic, readonly) NSString *description;\n@property(nonatomic, readonly) NSString *namespace;\n@property(nonatomic, retain) MEArray *array;\n@property(nonatomic, retain) NSArray *documentKeys;\n\n-(id)initWithDatabase:(MEDatabase *)database info:(NSDictionary *)info connection:(MEConnection *)connection;\n\n/**\n * Returns an NSArray (autoreleased) that contains the keys of the first few documents.\n * Useful to provide builders for queries and such.\n */\n-(NSArray *)buildDocumentKeys;\n\n/**\n * Returns an MECursor that will return all documents when iterated over.\n */\n-(MECursor *)find;\n\n/**\n * Returns an MECursor that will find a subset of all documents, when iterated over.\n */\n-(MECursor *)find:(NSDictionary *)query;\n\n@end\n\n", "comment_ratio": 0.14893617021276595}
{"lang": "c", "code": "#ifndef CONTENT_CHILD_CHILD_THREAD_IMPL_H_\n#define CONTENT_CHILD_CHILD_THREAD_IMPL_H_\n\n#include <stddef.h>\n#include <stdint.h>\n\n#include <memory>\n#include <string>\n\n#include \"base/memory/raw_ptr.h\"\n#include \"base/memory/scoped_refptr.h\"\n#include \"base/memory/weak_ptr.h\"\n#include \"base/task/single_thread_task_runner.h\"\n#include \"base/threading/thread.h\"\n#include \"build/build_config.h\"\n#include \"components/variations/child_process_field_trial_syncer.h\"\n#include \"content/common/associated_interfaces.mojom.h\"\n#include \"content/common/child_process.mojom.h\"\n#include \"content/public/child/child_thread.h\"\n#include \"ipc/ipc.mojom.h\"\n#include \"ipc/ipc_buildflags.h\"  // For BUILDFLAG(IPC_MESSAGE_LOG_ENABLED).\n#include \"ipc/ipc_platform_file.h\"\n#include \"ipc/message_router.h\"\n#include \"mojo/public/cpp/bindings/associated_receiver.h\"\n#include \"mojo/public/cpp/bindings/associated_receiver_set.h\"\n#include \"mojo/public/cpp/bindings/associated_remote.h\"\n#include \"mojo/public/cpp/bindings/binder_map.h\"\n#include \"mojo/public/cpp/bindings/generic_pending_receiver.h\"\n#include \"mojo/public/cpp/bindings/pending_associated_receiver.h\"\n#include \"mojo/public/cpp/bindings/shared_remote.h\"\n#include \"mojo/public/cpp/system/message_pipe.h\"\n#include \"services/tracing/public/mojom/background_tracing_agent.mojom.h\"\n#include \"third_party/blink/public/mojom/associated_interfaces/associated_interfaces.mojom.h\"\n\n#if defined(OS_WIN)\n#include \"content/public/common/font_cache_win.mojom.h\"\n#include \"mojo/public/cpp/bindings/remote.h\"\n#endif\n\nnamespace IPC {\nclass MessageFilter;\nclass SyncChannel;\nclass SyncMessageFilter;\n}  // namespace IPC\n\nnamespace mojo {\nclass OutgoingInvitation;\nnamespace core {\nclass ScopedIPCSupport;\n}  // namespace core\n}  // namespace mojo\n\nnamespace tracing {\nclass BackgroundTracingAgentProviderImpl;\n}  // namespace tracing\n\nnamespace content {\nclass InProcessChildThreadParams;\n\n// The main thread of a child process derives from this class.\nclass ChildThreadImpl : public IPC::Listener, virtual public ChildThread {\n public:\n  struct Options;\n\n  // Creates the thread.\n  explicit ChildThreadImpl(base::RepeatingClosure quit_closure);\n  // Allow to be used for single-process mode and for in process gpu mode via\n  // options.\n  ChildThreadImpl(base::RepeatingClosure quit_closure, const Options& options);\n\n  ChildThreadImpl(const ChildThreadImpl&) = delete;\n  ChildThreadImpl& operator=(const ChildThreadImpl&) = delete;\n\n  // ChildProcess::main_thread() is reset after Shutdown(), and before the\n  // destructor, so any subsystem that relies on ChildProcess::main_thread()\n  // must be terminated before Shutdown returns. In particular, if a subsystem\n  // has a thread that post tasks to ChildProcess::main_thread(), that thread\n  // should be joined in Shutdown().\n  ~ChildThreadImpl() override;\n  virtual void Shutdown();\n  // Returns true if the thread should be destroyed.\n  virtual bool ShouldBeDestroyed();\n\n  // IPC::Sender implementation:\n  bool Send(IPC::Message* msg) override;\n\n  // ChildThread implementation:\n#if defined(OS_WIN)\n  void PreCacheFont(const LOGFONT& log_font) override;\n  void ReleaseCachedFonts() override;\n#endif\n  void RecordAction(const base::UserMetricsAction& action) override;\n  void RecordComputedAction(const std::string& action) override;\n  void BindHostReceiver(mojo::GenericPendingReceiver receiver) override;\n  scoped_refptr<base::SingleThreadTaskRunner> GetIOTaskRunner() override;\n  void SetFieldTrialGroup(const std::string& trial_name,\n                          const std::string& group_name) override;\n\n  IPC::SyncChannel* channel() { return channel_.get(); }\n\n  IPC::MessageRouter* GetRouter();\n\n  IPC::SyncMessageFilter* sync_message_filter() const {\n    return sync_message_filter_.get();\n  }\n\n  scoped_refptr<base::SingleThreadTaskRunner> main_thread_runner() const {\n    return main_thread_runner_;\n  }\n\n  // Returns the one child thread. Can only be called on the main thread.\n  static ChildThreadImpl* current();\n\n  void GetBackgroundTracingAgentProvider(\n      mojo::PendingReceiver<tracing::mojom::BackgroundTracingAgentProvider>\n          receiver);\n\n  // Returns a reference to the thread-safe SharedRemote<ChildProcessHost>\n  // interface endpoint.\n  const mojo::SharedRemote<mojom::ChildProcessHost>& child_process_host()\n      const {\n    return child_process_host_;\n  }\n\n  // Explicitly closes the ChildProcessHost connection. This will cause the\n  // host-side object to be torn down and clean up resources tied to this\n  // process (or this thread object, in single-process mode).\n  void DisconnectChildProcessHost();\n\n  virtual void RunServiceDeprecated(const std::string& service_name,\n                                    mojo::ScopedMessagePipeHandle service_pipe);\n\n  virtual void BindServiceInterface(mojo::GenericPendingReceiver receiver);\n\n  virtual void OnBindReceiver(mojo::GenericPendingReceiver receiver);\n\n protected:\n  friend class ChildProcess;\n\n  // Called when the process refcount is 0.\n  virtual void OnProcessFinalRelease();\n\n  // Must be called by subclasses during initialization if and only if they set\n  // |Options::expose_interfaces_to_browser| to |true|. This makes |binders|\n  // available to handle incoming interface requests from the browser.\n  void ExposeInterfacesToBrowser(mojo::BinderMap binders);\n\n  virtual bool OnControlMessageReceived(const IPC::Message& msg);\n  // IPC::Listener implementation:\n  bool OnMessageReceived(const IPC::Message& msg) override;\n  void OnAssociatedInterfaceRequest(\n      const std::string& interface_name,\n      mojo::ScopedInterfaceEndpointHandle handle) override;\n  void OnChannelConnected(int32_t peer_pid) override;\n  void OnChannelError() override;\n  bool on_channel_error_called() const { return on_channel_error_called_; }\n\n  bool IsInBrowserProcess() const;\n\n private:\n  // TODO(crbug.com/1111231): This class is a friend so that it can call our\n  // private mojo implementation methods, acting as a pass-through. This is only\n  // necessary during the associated interface migration, after which,\n  // AgentSchedulingGroup will not act as a pass-through to the private methods\n  // here. At that point we'll remove this friend class.\n  friend class AgentSchedulingGroup;\n\n  class IOThreadState;\n\n  class ChildThreadMessageRouter : public IPC::MessageRouter {\n   public:\n    // |sender| must outlive this object.\n    explicit ChildThreadMessageRouter(IPC::Sender* sender);\n    bool Send(IPC::Message* msg) override;\n\n    // MessageRouter overrides.\n    bool RouteMessage(const IPC::Message& msg) override;\n\n   private:\n    const raw_ptr<IPC::Sender> sender_;\n  };\n\n  void Init(const Options& options);\n\n  // IPC message handlers.\n\n  void EnsureConnected();\n\n#if defined(OS_WIN)\n  const mojo::Remote<mojom::FontCacheWin>& GetFontCacheWin();\n#endif\n\n  base::Thread mojo_ipc_thread_{\"Mojo IPC\"};\n  std::unique_ptr<mojo::core::ScopedIPCSupport> mojo_ipc_support_;\n#if defined(OS_WIN)\n  mutable mojo::Remote<mojom::FontCacheWin> font_cache_win_;\n#endif\n\n  std::unique_ptr<IPC::SyncChannel> channel_;\n\n  // Allows threads other than the main thread to send sync messages.\n  scoped_refptr<IPC::SyncMessageFilter> sync_message_filter_;\n\n  // Implements message routing functionality to the consumers of\n  // ChildThreadImpl.\n  ChildThreadMessageRouter router_;\n\n  // The OnChannelError() callback was invoked - the channel is dead, don't\n  // attempt to communicate.\n  bool on_channel_error_called_;\n\n  // TaskRunner to post tasks to the main thread.\n  scoped_refptr<base::SingleThreadTaskRunner> main_thread_runner_;\n\n  // Used to quit the main thread.\n  base::RepeatingClosure quit_closure_;\n\n  std::unique_ptr<tracing::BackgroundTracingAgentProviderImpl>\n      background_tracing_agent_provider_;\n\n  scoped_refptr<base::SingleThreadTaskRunner> browser_process_io_runner_;\n\n  // Pointer to a global object which is never deleted.\n  raw_ptr<variations::ChildProcessFieldTrialSyncer> field_trial_syncer_ =\n      nullptr;\n\n  std::unique_ptr<base::WeakPtrFactory<ChildThreadImpl>>\n      channel_connected_factory_;\n\n  scoped_refptr<base::SingleThreadTaskRunner> ipc_task_runner_;\n\n  // An interface to the browser's process host object.\n  mojo::SharedRemote<mojom::ChildProcessHost> child_process_host_;\n\n  // ChildThreadImpl state which lives on the IO thread, including its\n  // implementation of the mojom ChildProcess interface.\n  scoped_refptr<IOThreadState> io_thread_state_;\n\n  base::WeakPtrFactory<ChildThreadImpl> weak_factory_{this};\n};\n\nstruct ChildThreadImpl::Options {\n  Options(const Options& other);\n  ~Options();\n\n  class Builder;\n\n  bool with_legacy_ipc_channel = true;\n  bool connect_to_browser = false;\n  scoped_refptr<base::SingleThreadTaskRunner> browser_process_io_runner;\n  std::vector<IPC::MessageFilter*> startup_filters;\n  raw_ptr<mojo::OutgoingInvitation> mojo_invitation = nullptr;\n  scoped_refptr<base::SingleThreadTaskRunner> ipc_task_runner;\n\n  // Indicates that this child process exposes one or more Mojo interfaces to\n  // the browser process. Subclasses which initialize this to |true| must\n  // explicitly call |ExposeInterfacesToBrowser()| some time during\n  // initialization.\n  bool exposes_interfaces_to_browser = false;\n\n  using ServiceBinder =\n      base::RepeatingCallback<void(mojo::GenericPendingReceiver*)>;\n  ServiceBinder service_binder;\n\n private:\n  Options();\n};\n\nclass ChildThreadImpl::Options::Builder {\n public:\n  Builder();\n\n  Builder(const Builder&) = delete;\n  Builder& operator=(const Builder&) = delete;\n\n  Builder& InBrowserProcess(const InProcessChildThreadParams& params);\n  Builder& ConnectToBrowser(bool connect_to_browser);\n  Builder& WithLegacyIPCChannel(bool with_legacy_ipc_channel);\n  Builder& AddStartupFilter(IPC::MessageFilter* filter);\n  Builder& IPCTaskRunner(\n      scoped_refptr<base::SingleThreadTaskRunner> ipc_task_runner);\n  Builder& ServiceBinder(ServiceBinder binder);\n  Builder& ExposesInterfacesToBrowser();\n\n  Options Build();\n\n private:\n  struct Options options_;\n};\n\n}  // namespace content\n\n#endif  // CONTENT_CHILD_CHILD_THREAD_IMPL_H_\n\n", "comment_ratio": 0.18791946308724833}
{"lang": "c", "code": "#ifndef LLVM_CODEGEN_MACHINEBRANCHPROBABILITYINFO_H\n#define LLVM_CODEGEN_MACHINEBRANCHPROBABILITYINFO_H\n\n#include \"llvm/CodeGen/MachineBasicBlock.h\"\n#include \"llvm/Pass.h\"\n#include \"llvm/Support/BranchProbability.h\"\n#include <climits>\n#include <numeric>\n\nnamespace llvm {\n\nclass MachineBranchProbabilityInfo : public ImmutablePass {\n  virtual void anchor();\n\n  // Default weight value. Used when we don't have information about the edge.\n  // TODO: DEFAULT_WEIGHT makes sense during static predication, when none of\n  // the successors have a weight yet. But it doesn't make sense when providing\n  // weight to an edge that may have siblings with non-zero weights. This can\n  // be handled various ways, but it's probably fine for an edge with unknown\n  // weight to just \"inherit\" the non-zero weight of an adjacent successor.\n  static const uint32_t DEFAULT_WEIGHT = 16;\n\npublic:\n  static char ID;\n\n  MachineBranchProbabilityInfo() : ImmutablePass(ID) {\n    PassRegistry &Registry = *PassRegistry::getPassRegistry();\n    initializeMachineBranchProbabilityInfoPass(Registry);\n  }\n\n  void getAnalysisUsage(AnalysisUsage &AU) const override {\n    AU.setPreservesAll();\n  }\n\n  // Return edge probability.\n  BranchProbability getEdgeProbability(const MachineBasicBlock *Src,\n                                       const MachineBasicBlock *Dst) const;\n\n  // Same as above, but using a const_succ_iterator from Src. This is faster\n  // when the iterator is already available.\n  BranchProbability\n  getEdgeProbability(const MachineBasicBlock *Src,\n                     MachineBasicBlock::const_succ_iterator Dst) const;\n\n  // A 'Hot' edge is an edge which probability is >= 80%.\n  bool isEdgeHot(const MachineBasicBlock *Src,\n                 const MachineBasicBlock *Dst) const;\n\n  // Return a hot successor for the block BB or null if there isn't one.\n  // NB: This routine's complexity is linear on the number of successors.\n  MachineBasicBlock *getHotSucc(MachineBasicBlock *MBB) const;\n\n  // Print value between 0 (0% probability) and 1 (100% probability),\n  // however the value is never equal to 0, and can be 1 only iff SRC block\n  // has only one successor.\n  raw_ostream &printEdgeProbability(raw_ostream &OS,\n                                    const MachineBasicBlock *Src,\n                                    const MachineBasicBlock *Dst) const;\n};\n\n}\n\n\n#endif\n\n", "comment_ratio": 0.34615384615384615}
{"lang": "c", "code": "template <class T, bool bUseCustomAllocator>\nST_INLINE CArray<T, bUseCustomAllocator>::CArray( ) : \n\tm_pData(NULL),\n\tm_uiSize(0),\n\tm_uiDataSize(0),\n\tm_pHeapDesc(NULL),\n\tm_bExternalMemory(false)\n{\n}\n\n\n/////////////////////////////////////////////////////////////////////\n// CArray::CArray\n\ntemplate <class T, bool bUseCustomAllocator>\nST_INLINE CArray<T, bUseCustomAllocator>::CArray(size_t uiSize, const T& tDefault) : \n\tm_pData(NULL),\n\tm_uiSize(0),\n\tm_uiDataSize(0),\n\tm_pHeapDesc(NULL),\n\tm_bExternalMemory(false)\n{\n\tresize(uiSize, tDefault);\n}\n\n\n/////////////////////////////////////////////////////////////////////\n// CArray::CArray\n\ntemplate <class T, bool bUseCustomAllocator>\nST_INLINE CArray<T, bUseCustomAllocator>::CArray(const CArray<T, bUseCustomAllocator>& cCopy) :\n\tm_pData(NULL),\n\tm_uiSize(0),\n\tm_uiDataSize(0),\n\tm_bExternalMemory(false)\n{\n\t*this = cCopy;\n}\n\n\n/////////////////////////////////////////////////////////////////////\n// CArray::~CArray\n\ntemplate <class T, bool bUseCustomAllocator>\nST_INLINE CArray<T, bUseCustomAllocator>::~CArray( )\n{\n\tif (m_bExternalMemory)\n\t\tSetExternalMemory(NULL, 0);\n\tclear( );\n}\n\n\n/////////////////////////////////////////////////////////////////////\n// CArray::clear\n\ntemplate <class T, bool bUseCustomAllocator>\nST_INLINE void CArray<T, bUseCustomAllocator>::clear(void)\n{\n\tif (m_bExternalMemory)\n\t{\n\t\tm_uiSize = 0;\n\t}\n\telse\n\t{\n\t\tDeallocate(m_pData);\n\t\tm_pData = NULL;\n\t\tm_uiSize = m_uiDataSize = 0;\n\t}\n}\n\n\n/////////////////////////////////////////////////////////////////////\n// CArray::empty\n\ntemplate <class T, bool bUseCustomAllocator>\nST_INLINE bool CArray<T, bUseCustomAllocator>::empty(void) const\n{\n\treturn !m_uiSize;\n}\n\n\n/////////////////////////////////////////////////////////////////////\n// CArray::size\n\ntemplate <class T, bool bUseCustomAllocator>\nST_INLINE size_t CArray<T, bUseCustomAllocator>::size(void) const\n{\n\treturn m_uiSize;\n}\n\n\n/////////////////////////////////////////////////////////////////////\n// CArray::capacity\n\ntemplate <class T, bool bUseCustomAllocator>\nST_INLINE size_t CArray<T, bUseCustomAllocator>::capacity(void) const\n{\n\treturn m_uiDataSize;\n}\n\n\n/////////////////////////////////////////////////////////////////////\n// CArray::resize\n\ntemplate <class T, bool bUseCustomAllocator>\nST_INLINE bool CArray<T, bUseCustomAllocator>::resize(size_t uiSize)\n{\n\tif (reserve(uiSize))\n\t{\n\t\tm_uiSize = uiSize;\n\t\treturn true;\n\t}\n\n\tm_uiSize = m_uiDataSize;\n\n\treturn false;\n}\n\n\n/////////////////////////////////////////////////////////////////////\n// CArray::resize\n\ntemplate <class T, bool bUseCustomAllocator>\nST_INLINE bool CArray<T, bUseCustomAllocator>::resize(size_t uiSize, const T& tDefault)\n{\n\tbool bReturn = false;\n\tsize_t uiEnd = m_uiDataSize;\n\tif (reserve(uiSize))\n\t{\n\t\tuiEnd = uiSize;\n\t\tbReturn = true;\n\t}\n\n\tfor (size_t i = m_uiSize; i < uiEnd; ++i)\n\t\tm_pData[i] = tDefault;\n\tm_uiSize = uiEnd;\n\n\treturn bReturn;\n}\n\n\n/////////////////////////////////////////////////////////////////////\n// CArray::reserve\n\ntemplate <class T, bool bUseCustomAllocator>\nST_INLINE bool CArray<T, bUseCustomAllocator>::reserve(size_t uiSize)\n{\n\tif (m_bExternalMemory)\n\t{\n\t\treturn (uiSize <= m_uiDataSize);\n\t}\n\n\tif (uiSize > m_uiDataSize)\n\t{\n\t\tT* pNewData = Allocate(uiSize);\n\t\tif (m_uiSize > 0)\n\t\t{\n\t\t\tT* pNew = pNewData;\n\t\t\tT* pOld = m_pData;\n\t\t\tfor (size_t i = 0; i < m_uiSize; ++pNew, ++pOld, ++i)\n\t\t\t\t*pNew = *pOld;\n\t\t}\n\n\t\tDeallocate(m_pData);\n\t\tm_pData = pNewData;\n\t\tm_uiDataSize = uiSize;\n\t}\n\n\treturn true;\n}\n\n\n/////////////////////////////////////////////////////////////////////\n// CArray::push_back\n\ntemplate <class T, bool bUseCustomAllocator>\nST_INLINE bool CArray<T, bUseCustomAllocator>::push_back(const T& tNew)\n{\n\tbool bReturn = true;\n\n\tif (m_bExternalMemory)\n\t{\n\t\tif (m_uiSize < m_uiDataSize)\n\t\t\tm_pData[m_uiSize++] = tNew;\n\t\telse\n\t\t\tbReturn = false;\n\t}\n\telse \n\t{\n\t\tif (m_uiSize == m_uiDataSize)\n\t\t{\n\t\t\tif (m_uiDataSize < 8)\n\t\t\t\tm_uiDataSize = 8;\n\t\t\treserve(m_uiDataSize * 2 + 1);\n\t\t}\n\t\tm_pData[m_uiSize++] = tNew;\n\t}\n\n\treturn bReturn;\n}\n\n\n/////////////////////////////////////////////////////////////////////\n// CArray::pop_back\n\ntemplate <class T, bool bUseCustomAllocator>\nST_INLINE void CArray<T, bUseCustomAllocator>::pop_back(void)\n{\n\tif (m_uiSize > 0)\n\t\t--m_uiSize;\n}\n\n\n/////////////////////////////////////////////////////////////////////\n// CArray::clip\n\ntemplate <class T, bool bUseCustomAllocator>\nST_INLINE void CArray<T, bUseCustomAllocator>::clip(void)\n{\n\tif (!m_bExternalMemory && m_uiDataSize > m_uiSize)\n\t{\n\t\tif (m_uiSize > 0)\n\t\t{\n\t\t\tT* pNewData = Allocate(m_uiSize);\n\t\t\tT* pNew = pNewData;\n\t\t\tT* pOld = m_pData;\n\t\t\tfor (size_t i = 0; i < m_uiSize; ++pNew, ++pOld, ++i)\n\t\t\t\t*pNew = *pOld;\n\t\t\tDeallocate(m_pData);\n\t\t\tm_pData = pNewData;\n\t\t\tm_uiDataSize = m_uiSize;\n\t\t}\n\t\telse\n\t\t\tclear( );\n\t}\n}\n\n\n/////////////////////////////////////////////////////////////////////\n// CArray::erase_all\n\ntemplate <class T, bool bUseCustomAllocator>\nST_INLINE void CArray<T, bUseCustomAllocator>::erase_all(const T& tErase)\n{\n\tif (m_uiSize > 0)\n\t{\n\t\titerator iterTest = m_pData + m_uiSize;\n\t\twhile (--iterTest >= m_pData)\n\t\t{\n\t\t\tif (*iterTest == tErase)\n\t\t\t\terase(iterTest);\n\t\t}\n\t}\n}\n\n\n/////////////////////////////////////////////////////////////////////\n// CArray::front\n\ntemplate <class T, bool bUseCustomAllocator>\nST_INLINE T& CArray<T, bUseCustomAllocator>::front(void)\n{\n\treturn m_pData[0];\n}\n\n\n/////////////////////////////////////////////////////////////////////\n// CArray::back\n\ntemplate <class T, bool bUseCustomAllocator>\nST_INLINE T& CArray<T, bUseCustomAllocator>::back(void)\n{\n\treturn m_pData[m_uiSize - 1];\n}\n\n\n/////////////////////////////////////////////////////////////////////\n// CArray::operator []\n\ntemplate <class T, bool bUseCustomAllocator>\nST_INLINE T& CArray<T, bUseCustomAllocator>::operator [] (size_t uiIndex)\n{\n\tst_assert(uiIndex < m_uiSize, \"CArray index out of range\");\n\n\treturn m_pData[uiIndex];\n}\n\n\n/////////////////////////////////////////////////////////////////////\n// CArray::operator []\n\ntemplate <class T, bool bUseCustomAllocator>\nST_INLINE const T& CArray<T, bUseCustomAllocator>::operator [] (size_t uiIndex) const\n{\n\tst_assert(uiIndex < m_uiSize, \"CArray index out of range\");\n\n\treturn m_pData[uiIndex];\n}\n\n\n/////////////////////////////////////////////////////////////////////\n// CArray::at\n\ntemplate <class T, bool bUseCustomAllocator>\nST_INLINE T& CArray<T, bUseCustomAllocator>::at(size_t uiIndex)\n{\n\tst_assert(uiIndex < m_uiSize, \"CArray index out of range\");\n\n\treturn m_pData[uiIndex];\n}\n\n\n/////////////////////////////////////////////////////////////////////\n// CArray::at\n\ntemplate <class T, bool bUseCustomAllocator>\nST_INLINE const T& CArray<T, bUseCustomAllocator>::at(size_t uiIndex) const\n{\n\tst_assert(uiIndex < m_uiSize, \"CArray index out of range\");\n\n\treturn m_pData[uiIndex];\n}\n\n\n/////////////////////////////////////////////////////////////////////\n// CArray::operator =\n\ntemplate <class T, bool bUseCustomAllocator>\nST_INLINE CArray<T, bUseCustomAllocator>& CArray<T, bUseCustomAllocator>::operator = (const CArray<T, bUseCustomAllocator>& cRight)\n{\n    if (!m_pHeapDesc)\n\t    m_pHeapDesc = cRight.m_pHeapDesc;\n\n\tif (m_bExternalMemory)\n\t{\n\t\tm_uiSize = cRight.m_uiSize;\n\t\tif (m_uiSize > m_uiDataSize)\n\t\t\tm_uiSize = m_uiDataSize;\n\t}\n\telse\n\t{\n\t\tif (cRight.m_uiSize > m_uiDataSize)\n\t\t{\n\t\t\tT* pNewData = Allocate(cRight.m_uiSize);\n\t\t\tDeallocate(m_pData);\n\t\t\tm_pData = pNewData;\n\t\t\tm_uiDataSize = cRight.m_uiSize;\n\t\t}\n\t\tm_uiSize = cRight.m_uiSize;\n\t}\n\n\tif (m_uiSize > 0)\n\t{\n\t\tT* pNew = m_pData;\n\t\tT* pOld = cRight.m_pData;\n\t\tfor (size_t i = 0; i < size_t(m_uiSize); ++pNew, ++pOld, ++i)\n\t\t\t*pNew = *pOld;\n\t}\n\n\treturn *this;\n}\n\n\n/////////////////////////////////////////////////////////////////////\n// CArray::begin\n\ntemplate <class T, bool bUseCustomAllocator>\nST_INLINE T* CArray<T, bUseCustomAllocator>::begin(void)\n{\n\treturn m_pData;\n}\n\n\n/////////////////////////////////////////////////////////////////////\n// CArray::end\n\ntemplate <class T, bool bUseCustomAllocator>\nST_INLINE T* CArray<T, bUseCustomAllocator>::end(void)\n{\n\treturn (m_pData + m_uiSize);\n}\n\n\n/////////////////////////////////////////////////////////////////////\n// CArray::begin\n\ntemplate <class T, bool bUseCustomAllocator>\nST_INLINE T const* CArray<T, bUseCustomAllocator>::begin(void) const\n{\n\treturn m_pData;\n}\n\n\n/////////////////////////////////////////////////////////////////////\n// CArray::end\n\ntemplate <class T, bool bUseCustomAllocator>\nST_INLINE T const* CArray<T, bUseCustomAllocator>::end(void) const\n{\n\treturn (m_pData + m_uiSize);\n}\n\n\n/////////////////////////////////////////////////////////////////////\n// CArray::erase\n\ntemplate <class T, bool bUseCustomAllocator>\nST_INLINE typename CArray<T, bUseCustomAllocator>::iterator CArray<T, bUseCustomAllocator>::erase(iterator iterWhere)\n{\n\t// make sure iterator is part of this list\n\tst_assert(m_pData != NULL, \"CArray::erase() called before CArray was propertly initialized\");\n\tst_assert(iterWhere >= m_pData && iterWhere < m_pData + m_uiSize, \"CArray iterator out of bounds\");\n\n\tif (iterWhere == m_pData + m_uiSize - 1)\n\t{\n\t\t// at the end, so just decrement size\n\t\t--m_uiSize;\n\t}\n\telse\n\t{\n\t\t// move the erased one to the end so destructors are called correctly\n\t\tchar achTemp[sizeof(T)];\n\t\tmemmove(achTemp, iterWhere, sizeof(T));\n\t\tmemmove(iterWhere, iterWhere + 1, (m_uiSize - (iterWhere - m_pData) - 1) * sizeof(T));\n\t\t--m_uiSize;\n\t\tmemmove(m_pData + m_uiSize, achTemp, sizeof(T));\n\t}\n\n\treturn iterWhere;\n}\n\n\n/////////////////////////////////////////////////////////////////////\n// CArray::insert\n\ntemplate <class T, bool bUseCustomAllocator>\nST_INLINE typename CArray<T, bUseCustomAllocator>::iterator CArray<T, bUseCustomAllocator>::insert(iterator iterWhere, const T& tData)\n{\n\t// make sure iterator is part of this list\n\t#ifdef SPEEDTREE_ITERATOR_DEBUGGING\n\t\tassert((m_pData != NULL && iterWhere != NULL) || (m_pData == NULL && iterWhere == NULL));\n\t\tif (m_pData != NULL)\n\t\t{\n\t\t\tassert(iterWhere >= m_pData);\n\t\t\tassert(iterWhere < m_pData + m_uiSize + 1);\n\t\t}\n\t#endif\n\n\t// remember iterator position\n\tsize_t uiIndex = iterWhere - m_pData;\n\n\t// this will ensure the array is big enough, etc.\n\tif (push_back(tData))\n\t{\n\t\tif (m_uiSize > 1)\n\t\t{\n\t\t\t// move the new one from the end so destructors are called correctly\n\t\t\tchar achTemp[sizeof(T)];\n\t\t\tmemmove(achTemp, static_cast<void*>(m_pData + m_uiSize - 1), sizeof(T));\n\t\t\tmemmove(static_cast<void*>(m_pData + uiIndex + 1), static_cast<void*>(m_pData + uiIndex), (m_uiSize - uiIndex - 1) * sizeof(T));\n\t\t\tmemmove(static_cast<void*>(m_pData + uiIndex), achTemp, sizeof(T));\n\t\t}\n\n\t\treturn (m_pData + uiIndex);\n\t}\n\n\treturn NULL;\n}\n\n\n/////////////////////////////////////////////////////////////////////\n// CArray::lower\n\ntemplate <class T, bool bUseCustomAllocator>\nST_INLINE typename CArray<T, bUseCustomAllocator>::iterator CArray<T, bUseCustomAllocator>::lower(const T& tData)\n{\n\tif (m_uiSize == 0 || tData < m_pData[0])\n\t\treturn m_pData + m_uiSize;\n\n\tsize_t uiWidth = m_uiSize / 2;\n\titerator iterStart = m_pData;\n\titerator iterEnd = m_pData + m_uiSize;\n\t\n\twhile (uiWidth > 0)\n\t{\n\t\titerator iterMiddle = iterStart + uiWidth;\n\t\tif (tData < *iterMiddle)\n\t\t\titerEnd = iterMiddle;\n\t\telse\n\t\t\titerStart = iterMiddle;\n\t\tuiWidth = (iterEnd - iterStart) / 2;\n\t}\n\t\n\treturn iterStart;\n}\n\n\n/////////////////////////////////////////////////////////////////////\n// CArray::higher\n\ntemplate <class T, bool bUseCustomAllocator>\nST_INLINE typename CArray<T, bUseCustomAllocator>::iterator CArray<T, bUseCustomAllocator>::higher(const T& tData)\n{\n\titerator iterBound = lower(tData);\n\tif (iterBound == end( ))\n\t{\n\t\tif (m_uiSize > 0 && tData < *m_pData)\n\t\t\titerBound = m_pData;\n\t}\n\telse if (*iterBound < tData)\n\t\titerBound++;\n\treturn iterBound;\n}\n\n\n/////////////////////////////////////////////////////////////////////\n// CArray::lower_and_higher\n\ntemplate <class T, bool bUseCustomAllocator>\nvoid CArray<T, bUseCustomAllocator>::lower_and_higher(const T& tData, iterator& iterLower, iterator& iterHigher)\n{\n\titerLower = lower(tData);\n\titerHigher = iterLower;\n\tif (iterHigher == end( ))\n\t{\n\t\tif (m_uiSize > 0 && tData < *m_pData)\n\t\t\titerHigher = m_pData;\n\t}\n\telse if (*iterHigher < tData)\n\t\titerHigher++;\n}\n\n\n/////////////////////////////////////////////////////////////////////\n// CArray::insert_sorted\n\ntemplate <class T, bool bUseCustomAllocator>\nST_INLINE typename CArray<T, bUseCustomAllocator>::iterator CArray<T, bUseCustomAllocator>::insert_sorted(const T& tData)\n{\n\treturn insert(higher(tData), tData);\t\t\n}\n\n\n/////////////////////////////////////////////////////////////////////\n// CArray::insert_sorted_unique\n\ntemplate <class T, bool bUseCustomAllocator>\nST_INLINE typename CArray<T, bUseCustomAllocator>::iterator CArray<T, bUseCustomAllocator>::insert_sorted_unique(const T& tData)\n{\n\titerator iterLower;\n\titerator iterHigher;\n\tlower_and_higher(tData, iterLower, iterHigher);\n\n\tif (iterLower == end( ) || iterLower != iterHigher)\n\t\treturn insert(iterHigher, tData);\n\treturn iterLower;\t\n}\n\n\n/////////////////////////////////////////////////////////////////////\n// Array sorting functors\n\nclass CArrayPointerSwap\n{\npublic:\n\ttemplate <class T> void operator () (T* pOne, T* pTwo, T* pTemp) const \n\t{ \n\t\t*pTemp = *pOne;\n\t\t*pOne = *pTwo;\n\t\t*pTwo = *pTemp;\n\t}\n};\n\nclass CArrayPointerMemorySwap\n{\npublic:\n\ttemplate <class T> void operator () (T* pOne, T* pTwo, T* pTemp) const \n\t{ \n\t\tmemmove(pTemp, pOne, sizeof(T));\n\t\tmemmove(pOne, pTwo, sizeof(T));\n\t\tmemmove(pTwo, pTemp, sizeof(T));\n\t}\n};\n\nclass CArrayPointerCopy\n{\npublic:\n\ttemplate <class T> void operator () (T* pDest, T* pSrc) const { *pDest = *pSrc; }\n};\n\nclass CArrayPointerMemoryCopy\n{\npublic:\n\ttemplate <class T> void operator () (T* pDest, T* pSrc) const { memmove(pDest, pSrc, sizeof(T)); }\n};\n\n\n/////////////////////////////////////////////////////////////////////\n// CArray::ArrayQuickSort\n\t\ntemplate <class T, class CompareFunctor, class SwapFunctor, class CopyFunctor>\ninline void ArrayQuickSort(T* pBegin, T* pEnd, const CompareFunctor& Compare, const SwapFunctor& Swap, const CopyFunctor& Copy, T* pTemp)\n{\n\tsize_t uiSize = pEnd - pBegin + 1;\n\t\n\tif (pEnd - pBegin < 16)\n\t{\n\t\t// insertion sort\n\t\tfor (size_t i = 1; i < uiSize; ++i)\n\t\t{\n\t\t\tCopy(pTemp, &pBegin[i]);\n\t\t\tsize_t j = i;\n\t\t\tfor ( ; j > 0 && Compare(*pTemp, pBegin[j - 1]); --j)\n\t\t\t\tCopy(&pBegin[j], &pBegin[j - 1]);\n\t\t\tCopy(&pBegin[j], pTemp);\n\t\t}\n\t}\n\telse\n\t{\n\t\t// median of 3 pivot choice\n\t\tT* pMiddle = pBegin + uiSize / 2;\n\t\tif (Compare(*pMiddle, *pBegin))\n\t\t\tSwap(pMiddle, pBegin, pTemp);\n\t\tif (Compare(*pEnd, *pBegin))\n\t\t\tSwap(pEnd, pBegin, pTemp);\n\t\tif (Compare(*pEnd, *pMiddle))\n\t\t\tSwap(pEnd, pMiddle, pTemp);\n\t\t\n\t\t// position pivot\n\t\tT* pPivot = pEnd - 1;\n\t\tSwap(pMiddle, pPivot, pTemp);\n\t\t\n\t\t// partition\n\t\tT* pLow(pBegin);\n\t\tT* pHigh(pPivot);\n\t\tfor ( ; ; )\n\t\t{\n\t\t\twhile (Compare(*(++pLow), *pPivot)) ;\n\t\t\twhile (Compare(*pPivot, *(--pHigh))) ;\n\t\t\tif (pLow < pHigh)\n\t\t\t\tSwap(pLow, pHigh, pTemp);\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\t// restore pivot\n\t\tSwap(pLow, pPivot, pTemp);\n\t\t\n\t\t// recursive sort\n\t\tArrayQuickSort(pBegin, pLow - 1, Compare, Swap, Copy, pTemp);\n\t\tArrayQuickSort(pLow + 1, pEnd, Compare, Swap, Copy, pTemp);\n\t}\n}\n\n\n/////////////////////////////////////////////////////////////////////\n// CArray::sort\n\ntemplate <class T, bool bUseCustomAllocator>\ntemplate <class CompareFunctor>\nST_INLINE void CArray<T, bUseCustomAllocator>::sort(const CompareFunctor& Compare, bool bMemorySwap)\n{\n\tif (m_uiSize < 2)\n\t\treturn;\n\t\n\tif (bMemorySwap)\n\t{\n\t\tchar achTemp[sizeof(T)];\n\t\tArrayQuickSort(m_pData, m_pData + m_uiSize - 1, Compare, CArrayPointerMemorySwap( ), CArrayPointerMemoryCopy( ), (T*)achTemp);\n\t}\n\telse\n\t{\n\t\tT tTemp;\n\t\tArrayQuickSort(m_pData, m_pData + m_uiSize - 1, Compare, CArrayPointerSwap( ), CArrayPointerCopy( ), &tTemp);\n\t}\n}\t\n\n\n/////////////////////////////////////////////////////////////////////\n// CArray::sort\n\ntemplate <class T, bool bUseCustomAllocator>\nST_INLINE void CArray<T, bUseCustomAllocator>::sort(bool bMemorySwap)\n{\n\tif (m_uiSize < 2)\n\t\treturn;\n\t\n\tif (bMemorySwap)\n\t{\n\t\tchar achTemp[sizeof(T)];\n\t\tArrayQuickSort(m_pData, m_pData + m_uiSize - 1, CDefaultArraySort( ), CArrayPointerMemorySwap( ), CArrayPointerMemoryCopy( ), (T*)achTemp);\n\t}\n\telse\n\t{\n\t\tT tTemp;\n\t\tArrayQuickSort(m_pData, m_pData + m_uiSize - 1, CDefaultArraySort( ), CArrayPointerSwap( ), CArrayPointerCopy( ), &tTemp);\n\t}\n}\t\n\t\n\n/////////////////////////////////////////////////////////////////////\n// CArray::Allocate\n\ntemplate <class T, bool bUseCustomAllocator>\nST_INLINE T* CArray<T, bUseCustomAllocator>::Allocate(size_t uiSize)\n{\n\tassert(!m_bExternalMemory);\n\n\treturn \n\t#ifndef SPEEDTREE_NO_ALLOCATORS\n\t\tbUseCustomAllocator ? st_new_array<T>(uiSize, m_pHeapDesc ? m_pHeapDesc : \"CArray\") :\n\t#endif \n\t\tnew T[uiSize];\n}\n\n\n/////////////////////////////////////////////////////////////////////\n// CArray::Deallocate\n\ntemplate <class T, bool bUseCustomAllocator>\nST_INLINE void CArray<T, bUseCustomAllocator>::Deallocate(T* pData)\n{ \n\tassert(!m_bExternalMemory);\n\t#ifndef SPEEDTREE_NO_ALLOCATORS\n\t\tbUseCustomAllocator ? st_delete_array<T>(pData) :\n\t#endif\n\t\tdelete[] pData;\n}\n\n\n/////////////////////////////////////////////////////////////////////\n// CArray::SetExternalMemory\n\ntemplate <class T, bool bUseCustomAllocator>\nST_INLINE void CArray<T, bUseCustomAllocator>::SetExternalMemory(unsigned char* pMemory, size_t uiSize)\n{\n\tclear( );\n\n\tif (m_bExternalMemory)\n\t{\n\t\t// call destructors\n\t\tfor (size_t i = 0; i < m_uiDataSize; ++i)\n\t\t\tm_pData[i].~T( );\n\n\t\tm_uiDataSize = 0;\n\t\tm_pData = NULL;\n\t}\n\n\tif (pMemory == NULL)\n\t{\n\t\tm_bExternalMemory = false;\n\t}\n\telse\n\t{\n\t\tm_uiDataSize = uiSize / sizeof(T);\n\t\tm_pData = (T*) pMemory;\n\n\t    for (size_t i = 0; i < m_uiDataSize; ++i)\n\t\t    (void) new (static_cast<void*>(m_pData + i)) T;\n\n\t\tm_bExternalMemory = true;\n\t}\n}\n\n\n/////////////////////////////////////////////////////////////////////\n// CArray::SetHeapDescription\n\ntemplate <class T, bool bUseCustomAllocator>\nST_INLINE void CArray<T, bUseCustomAllocator>::SetHeapDescription(const char* pDesc)\n{\n\tm_pHeapDesc = pDesc;\n}\n\n\n\n\n", "comment_ratio": 0.14782608695652175}
{"lang": "c", "code": "#ifndef FLUTTER_SHELL_PLATFORM_FUCHSIA_FLUTTER_GFX_EXTERNAL_VIEW_EMBEDDER_H_\n#define FLUTTER_SHELL_PLATFORM_FUCHSIA_FLUTTER_GFX_EXTERNAL_VIEW_EMBEDDER_H_\n\n#include <fuchsia/ui/views/cpp/fidl.h>\n#include <lib/ui/scenic/cpp/id.h>\n#include <lib/ui/scenic/cpp/resources.h>\n#include <lib/ui/scenic/cpp/view_ref_pair.h>\n\n#include <cstdint>  // For uint32_t & uint64_t\n#include <memory>\n#include <string>\n#include <unordered_map>\n#include <vector>\n\n#include \"flutter/flow/embedded_views.h\"\n#include \"flutter/flow/rtree.h\"\n#include \"flutter/fml/logging.h\"\n#include \"flutter/fml/macros.h\"\n#include \"flutter/shell/common/canvas_spy.h\"\n#include \"third_party/skia/include/core/SkCanvas.h\"\n#include \"third_party/skia/include/core/SkPictureRecorder.h\"\n#include \"third_party/skia/include/core/SkPoint.h\"\n#include \"third_party/skia/include/core/SkRect.h\"\n#include \"third_party/skia/include/core/SkSize.h\"\n#include \"third_party/skia/include/gpu/GrDirectContext.h\"\n\n#include \"gfx_session_connection.h\"\n#include \"surface_producer.h\"\n\nnamespace flutter_runner {\n\nusing ViewCallback = std::function<void()>;\nusing GfxViewIdCallback = std::function<void(scenic::ResourceId)>;\n\n// This struct represents a transformed clip rect.\nstruct TransformedClip {\n  SkMatrix transform = SkMatrix::I();\n  SkRect rect = SkRect::MakeEmpty();\n\n  bool operator==(const TransformedClip& other) const {\n    return transform == other.transform && rect == other.rect;\n  }\n};\n\n// This struct represents all the mutators that can be applied to a\n// PlatformView, unpacked from the `MutatorStack`.\nstruct ViewMutators {\n  std::vector<TransformedClip> clips;\n  SkMatrix total_transform = SkMatrix::I();\n  SkMatrix transform = SkMatrix::I();\n  SkScalar opacity = 1.f;\n\n  bool operator==(const ViewMutators& other) const {\n    return clips == other.clips && total_transform == other.total_transform &&\n           transform == other.transform && opacity == other.opacity;\n  }\n};\n\n// This class orchestrates interaction with the Scenic compositor on Fuchsia. It\n// ensures that flutter content and platform view content are both rendered\n// correctly in a unified scene.\nclass GfxExternalViewEmbedder final : public flutter::ExternalViewEmbedder {\n public:\n  // Layer separation is as infinitesimal as possible without introducing\n  // Z-fighting.\n  constexpr static float kScenicZElevationBetweenLayers = 0.0001f;\n  constexpr static float kScenicZElevationForPlatformView = 100.f;\n  constexpr static float kScenicElevationForInputInterceptor = 500.f;\n  constexpr static SkAlpha kBackgroundLayerOpacity = SK_AlphaOPAQUE;\n  constexpr static SkAlpha kOverlayLayerOpacity = SK_AlphaOPAQUE - 1;\n\n  GfxExternalViewEmbedder(std::string debug_label,\n                          fuchsia::ui::views::ViewToken view_token,\n                          scenic::ViewRefPair view_ref_pair,\n                          std::shared_ptr<GfxSessionConnection> session,\n                          std::shared_ptr<SurfaceProducer> surface_producer,\n                          bool intercept_all_input = false);\n  ~GfxExternalViewEmbedder();\n\n  // |ExternalViewEmbedder|\n  SkCanvas* GetRootCanvas() override;\n\n  // |ExternalViewEmbedder|\n  std::vector<SkCanvas*> GetCurrentCanvases() override;\n\n  // |ExternalViewEmbedder|\n  void PrerollCompositeEmbeddedView(\n      int view_id,\n      std::unique_ptr<flutter::EmbeddedViewParams> params) override;\n\n  // |ExternalViewEmbedder|\n  SkCanvas* CompositeEmbeddedView(int view_id) override;\n\n  // |ExternalViewEmbedder|\n  flutter::PostPrerollResult PostPrerollAction(\n      fml::RefPtr<fml::RasterThreadMerger> raster_thread_merger) override;\n\n  // |ExternalViewEmbedder|\n  void BeginFrame(\n      SkISize frame_size,\n      GrDirectContext* context,\n      double device_pixel_ratio,\n      fml::RefPtr<fml::RasterThreadMerger> raster_thread_merger) override;\n\n  // |ExternalViewEmbedder|\n  void EndFrame(\n      bool should_resubmit_frame,\n      fml::RefPtr<fml::RasterThreadMerger> raster_thread_merger) override;\n\n  // |ExternalViewEmbedder|\n  void SubmitFrame(GrDirectContext* context,\n                   std::unique_ptr<flutter::SurfaceFrame> frame) override;\n\n  // |ExternalViewEmbedder|\n  void CancelFrame() override { Reset(); }\n\n  // |ExternalViewEmbedder|\n  bool SupportsDynamicThreadMerging() override { return false; }\n\n  // View manipulation.\n  // |SetViewProperties| doesn't manipulate the view directly -- it sets pending\n  // properties for the next |UpdateView| call.\n  void EnableWireframe(bool enable);\n  void CreateView(int64_t view_id,\n                  ViewCallback on_view_created,\n                  GfxViewIdCallback on_view_bound);\n  void DestroyView(int64_t view_id, GfxViewIdCallback on_view_unbound);\n  void SetViewProperties(int64_t view_id,\n                         const SkRect& occlusion_hint,\n                         bool hit_testable,\n                         bool focusable);\n\n private:\n  void Reset();  // Reset state for a new frame.\n\n  struct EmbedderLayer {\n    EmbedderLayer(const SkISize& frame_size,\n                  std::optional<flutter::EmbeddedViewParams> view_params,\n                  flutter::RTreeFactory rtree_factory)\n        : rtree(rtree_factory.getInstance()),\n          embedded_view_params(std::move(view_params)),\n          recorder(std::make_unique<SkPictureRecorder>()),\n          canvas_spy(std::make_unique<flutter::CanvasSpy>(\n              recorder->beginRecording(SkRect::Make(frame_size),\n                                       &rtree_factory))),\n          surface_size(frame_size),\n          picture(nullptr) {}\n\n    // Records paint operations applied to this layer's `SkCanvas`.\n    // These records are used to determine which portions of this layer\n    // contain content. The embedder propagates this information to scenic, so\n    // that scenic can accurately decide which portions of this layer may\n    // interact with input.\n    sk_sp<flutter::RTree> rtree;\n\n    std::optional<flutter::EmbeddedViewParams> embedded_view_params;\n    std::unique_ptr<SkPictureRecorder> recorder;\n    std::unique_ptr<flutter::CanvasSpy> canvas_spy;\n    SkISize surface_size;\n    sk_sp<SkPicture> picture;\n  };\n  using EmbedderLayerId = std::optional<uint32_t>;\n  constexpr static EmbedderLayerId kRootLayerId = EmbedderLayerId{};\n\n  struct ScenicView {\n    std::vector<scenic::EntityNode> clip_nodes;\n    scenic::OpacityNodeHACK opacity_node;\n    scenic::EntityNode transform_node;\n    scenic::ViewHolder view_holder;\n\n    ViewMutators mutators;\n    float elevation = 0.f;\n\n    SkSize size = SkSize::MakeEmpty();\n    SkRect occlusion_hint = SkRect::MakeEmpty();\n    SkRect pending_occlusion_hint = SkRect::MakeEmpty();\n    bool hit_testable = true;\n    bool pending_hit_testable = true;\n    bool focusable = true;\n    bool pending_focusable = true;\n  };\n\n  // GFX resources required to render a composited flutter layer (i.e. an\n  // SkPicture).\n  struct ScenicImage {\n    scenic::ShapeNode shape_node;\n    scenic::Material material;\n  };\n\n  // All resources required to represent a flutter layer in the GFX scene\n  // graph. The structure of the subgraph for a particular layer is:\n  //\n  //         layer_node\n  //        /          \\\n  //  image node     hit regions (zero or more)\n  //\n  // NOTE: `hit_regions` must be cleared before submitting each new frame;\n  // otherwise, we will report stale hittable geometry to scenic.\n  struct ScenicLayer {\n    // Root of the subtree containing the scenic resources for this layer.\n    scenic::EntityNode layer_node;\n\n    // Scenic resources used to render this layer's image.\n    ScenicImage image;\n\n    // Scenic resources that specify which parts of this layer are responsive\n    // to input.\n    std::vector<scenic::ShapeNode> hit_regions;\n  };\n\n  std::shared_ptr<GfxSessionConnection> session_;\n  std::shared_ptr<SurfaceProducer> surface_producer_;\n\n  scenic::View root_view_;\n  scenic::EntityNode metrics_node_;\n  scenic::EntityNode layer_tree_node_;\n  std::optional<scenic::ShapeNode> input_interceptor_node_;\n\n  std::unordered_map<uint64_t, scenic::Rectangle> scenic_interceptor_rects_;\n  std::unordered_map<uint64_t, std::vector<scenic::Rectangle>> scenic_rects_;\n  std::unordered_map<int64_t, ScenicView> scenic_views_;\n  std::vector<ScenicLayer> scenic_layers_;\n\n  std::unordered_map<EmbedderLayerId, EmbedderLayer> frame_layers_;\n  std::vector<EmbedderLayerId> frame_composition_order_;\n  SkISize frame_size_ = SkISize::Make(0, 0);\n  float frame_dpr_ = 1.f;\n\n  FML_DISALLOW_COPY_AND_ASSIGN(GfxExternalViewEmbedder);\n};\n\n}  // namespace flutter_runner\n\n#endif  // FLUTTER_SHELL_PLATFORM_FUCHSIA_FLUTTER_GFX_EXTERNAL_VIEW_EMBEDDER_H_\n\n", "comment_ratio": 0.200836820083682}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n\n@interface AppDelegate : UIResponder <UIApplicationDelegate>\n\n@property (strong, nonatomic) UIWindow *window;\n\n\n@end\n\n\n", "comment_ratio": 0.3888888888888889}
{"lang": "c", "code": "#ifndef KERNEL_ARCH_ARM64_KERNEL_ARGS_H\n#define KERNEL_ARCH_ARM64_KERNEL_ARGS_H\n\n#ifndef KERNEL_BOOT_KERNEL_ARGS_H\n#\terror This file is included from <boot/kernel_args.h> only\n#endif\n\n\n#include <util/FixedWidthPointer.h>\n#include <boot/uart.h>\n\n\n#define _PACKED __attribute__((packed))\n\n\ntypedef struct {\n\t// needed for UEFI, otherwise kernel acpi support can't find ACPI root\n\tFixedWidthPointer<void> acpi_root;\n//\tTODO:  Deal with this later in the port\n//\tFixedWidthPointer<void> fdt;\n//\tuart_info\t\tuart;\n} _PACKED arch_kernel_args;\n\n#endif\t/* KERNEL_ARCH_ARM64_KERNEL_ARGS_H */\n\n", "comment_ratio": 0.13793103448275862}
{"lang": "c", "code": "#include \"sdl_stuff.h\"\r\n#include <unistd.h>\r\n\r\n\r\nSDL_Surface * bmp;\r\nSDL_Surface * screen;\r\n\r\nfloat x_pos = 0.0f;\r\nfloat y_pos = 0.0f;\r\n\r\nint sdl_startup()\r\n{\r\n    // initialize SDL video\r\n    if ( SDL_Init( SDL_INIT_VIDEO ) < 0 )\r\n    {\r\n        printf( \"Unable to init SDL: %s\\n\", SDL_GetError() );\r\n        return 0;\r\n    }\r\n\r\n    // make sure SDL cleans up before exit\r\n    atexit(SDL_Quit);\r\n\r\n    // create a new window\r\n    screen = SDL_SetVideoMode(WINDOW_SIZE, WINDOW_SIZE, 32,\r\n                              SDL_HWSURFACE|SDL_DOUBLEBUF);\r\n    if ( !screen )\r\n    {\r\n        printf(\"Unable to set  video: %s\\n\", SDL_GetError());\r\n        return 0;\r\n    }\r\n\r\n    // load an image\r\n    bmp = SDL_LoadBMP(\"balle.bmp\");\r\n    if (!bmp)\r\n    {\r\n        printf(\"Unable to load bitmap: %s\\n\", SDL_GetError());\r\n        return 0;\r\n    }\r\n    SDL_SetColorKey(bmp, SDL_SRCCOLORKEY, 0x000000);\r\n\r\n    return 1;\r\n}\r\n\r\n\r\nint sdl_loop()\r\n{\r\n\r\n    // message processing loop\r\n    SDL_Event event;\r\n    while (SDL_PollEvent(&event))\r\n    {\r\n        // check for messages\r\n        switch (event.type)\r\n        {\r\n            // exit if the window is closed\r\n        case SDL_QUIT:\r\n            return 0;\r\n            break;\r\n\r\n            // check for keypresses\r\n        case SDL_KEYDOWN:\r\n        {\r\n            // exit if ESCAPE is pressed\r\n            if (event.key.keysym.sym == SDLK_ESCAPE)\r\n                return 0;\r\n            break;\r\n        }\r\n        } // end switch\r\n    } // end of message processing\r\n\r\n    // DRAWING STARTS HERE\r\n\r\n    // clear screen\r\n    SDL_FillRect(screen, 0, SDL_MapRGB(screen->format, 0, 0, 0));\r\n\r\n    // position de la balle en pixels\r\n    SDL_Rect dstrect;\r\n    dstrect.x =  WINDOW_SIZE*x_pos - bmp->w/2;\r\n    dstrect.y =  WINDOW_SIZE - WINDOW_SIZE*y_pos - bmp->h/2;\r\n\r\n    // draw bitmap\r\n    SDL_BlitSurface(bmp, 0, screen, &dstrect);\r\n\r\n    // DRAWING ENDS HERE\r\n\r\n    // finally, update the screen :)\r\n    SDL_Flip(screen);\r\n\t\r\n\tusleep(1000);\r\n\r\n    return 1;\r\n}\r\n\r\n\r\nvoid sdl_setBallPosition(float x,float y)\r\n{\r\n    x_pos = x;\r\n    y_pos = y;\r\n}\r\n\r\n\r\nvoid sdl_clean()\r\n{\r\n    // free loaded bitmap\r\n    SDL_FreeSurface(bmp);\r\n\r\n    // all is well ;)\r\n    printf(\"Exited cleanly\\n\");\r\n}\r\n\n", "comment_ratio": 0.17272727272727273}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n#import \"FLAnimatedImage.h\"\n@class KNProgressHUD;\n\ntypedef void(^PhotoBrowerSingleTap)(void);\ntypedef void(^PhotoBrowerLongPressTap)(void);\n\n@interface KNPhotoBrowserImageView : UIView\n\n// all base control that can scroll\n@property (nonatomic, strong) UIScrollView *scrollView;\n\n@property (nonatomic, strong) FLAnimatedImageView *imageView;\n\n// single tap\n@property (nonatomic,copy  ) PhotoBrowerSingleTap singleTap;\n// longPress tap\n@property (nonatomic,copy  ) PhotoBrowerLongPressTap longPressTap;\n\n- (void)sd_ImageWithUrl:(NSURL *)url progressHUD:(KNProgressHUD *)progressHUD placeHolder:(UIImage *)placeHolder;\n\n@end\n\n", "comment_ratio": 0.3225806451612903}
{"lang": "c", "code": "#ifndef UI_DISPLAY_CHROMEOS_TEST_TEST_DISPLAY_SNAPSHOT_H_\n#define UI_DISPLAY_CHROMEOS_TEST_TEST_DISPLAY_SNAPSHOT_H_\n\n#include <stdint.h>\n\n#include \"base/macros.h\"\n#include \"ui/display/display_export.h\"\n#include \"ui/display/types/display_snapshot.h\"\n\nnamespace ui {\n\nclass DISPLAY_EXPORT TestDisplaySnapshot : public DisplaySnapshot {\n public:\n  TestDisplaySnapshot();\n  TestDisplaySnapshot(int64_t display_id,\n                      const gfx::Point& origin,\n                      const gfx::Size& physical_size,\n                      DisplayConnectionType type,\n                      bool is_aspect_preserving_scaling,\n                      int64_t product_id,\n                      const std::vector<const DisplayMode*>& modes,\n                      const DisplayMode* current_mode,\n                      const DisplayMode* native_mode);\n  ~TestDisplaySnapshot() override;\n\n  void set_type(DisplayConnectionType type) { type_ = type; }\n  void set_modes(const std::vector<const DisplayMode*>& modes) {\n    modes_ = modes;\n  }\n  void set_current_mode(const ui::DisplayMode* mode) { current_mode_ = mode; }\n  void set_native_mode(const ui::DisplayMode* mode) { native_mode_ = mode; }\n  void set_is_aspect_preserving_scaling(bool state) {\n    is_aspect_preserving_scaling_ = state;\n  }\n  void set_display_id(int64_t id) { display_id_ = id; }\n\n  // DisplaySnapshot overrides:\n  std::string ToString() const override;\n\n private:\n  DISALLOW_COPY_AND_ASSIGN(TestDisplaySnapshot);\n};\n\n}  // namespace ui\n\n#endif  // UI_DISPLAY_CHROMEOS_TEST_TEST_DISPLAY_SNAPSHOT_H_\n\n", "comment_ratio": 0.11764705882352941}
{"lang": "c", "code": "#ifndef QUICHE_QUIC_TEST_TOOLS_SIMULATOR_QUIC_ENDPOINT_BASE_H_\n#define QUICHE_QUIC_TEST_TOOLS_SIMULATOR_QUIC_ENDPOINT_BASE_H_\n\n#include <memory>\n\n#include \"absl/container/flat_hash_map.h\"\n#include \"quic/core/crypto/null_decrypter.h\"\n#include \"quic/core/crypto/null_encrypter.h\"\n#include \"quic/core/quic_connection.h\"\n#include \"quic/core/quic_default_packet_writer.h\"\n#include \"quic/core/quic_packets.h\"\n#include \"quic/core/quic_stream_frame_data_producer.h\"\n#include \"quic/core/quic_trace_visitor.h\"\n#include \"quic/platform/api/quic_containers.h\"\n#include \"quic/test_tools/simple_session_notifier.h\"\n#include \"quic/test_tools/simulator/link.h\"\n#include \"quic/test_tools/simulator/queue.h\"\n\nnamespace quic {\nnamespace simulator {\n\n// Size of the TX queue used by the kernel/NIC.  1000 is the Linux\n// kernel default.\nconst QuicByteCount kTxQueueSize = 1000;\n\n// Generate a random local network host-port tuple based on the name of the\n// endpoint.\nQuicSocketAddress GetAddressFromName(std::string name);\n\n// A QUIC connection endpoint.  If the specific data transmitted does not matter\n// (e.g. for congestion control purposes), QuicEndpoint is the subclass that\n// transmits dummy data.  If the actual semantics of the connection matter,\n// subclassing QuicEndpointBase is required.\nclass QuicEndpointBase : public Endpoint,\n                         public UnconstrainedPortInterface,\n                         public Queue::ListenerInterface {\n public:\n  // Does not create the connection; the subclass has to create connection by\n  // itself.\n  QuicEndpointBase(Simulator* simulator,\n                   std::string name,\n                   std::string peer_name);\n  ~QuicEndpointBase() override;\n\n  inline QuicConnection* connection() { return connection_.get(); }\n  inline size_t write_blocked_count() { return write_blocked_count_; }\n\n  // Drop the next packet upon receipt.\n  void DropNextIncomingPacket();\n\n  // UnconstrainedPortInterface method.  Called whenever the endpoint receives a\n  // packet.\n  void AcceptPacket(std::unique_ptr<Packet> packet) override;\n\n  // Enables logging of the connection trace at the end of the unit test.\n  void RecordTrace();\n\n  // Begin Endpoint implementation.\n  UnconstrainedPortInterface* GetRxPort() override;\n  void SetTxPort(ConstrainedPortInterface* port) override;\n  // End Endpoint implementation.\n\n  // Actor method.\n  void Act() override {}\n\n  // Queue::ListenerInterface method.\n  void OnPacketDequeued() override;\n\n protected:\n  // A Writer object that writes into the |nic_tx_queue_|.\n  class Writer : public QuicPacketWriter {\n   public:\n    explicit Writer(QuicEndpointBase* endpoint);\n    ~Writer() override;\n\n    WriteResult WritePacket(const char* buffer,\n                            size_t buf_len,\n                            const QuicIpAddress& self_address,\n                            const QuicSocketAddress& peer_address,\n                            PerPacketOptions* options) override;\n    bool IsWriteBlocked() const override;\n    void SetWritable() override;\n    QuicByteCount GetMaxPacketSize(\n        const QuicSocketAddress& peer_address) const override;\n    bool SupportsReleaseTime() const override;\n    bool IsBatchMode() const override;\n    QuicPacketBuffer GetNextWriteLocation(\n        const QuicIpAddress& self_address,\n        const QuicSocketAddress& peer_address) override;\n    WriteResult Flush() override;\n\n   private:\n    QuicEndpointBase* endpoint_;\n\n    bool is_blocked_;\n  };\n\n  // The producer outputs the repetition of the same byte.  That sequence is\n  // verified by the receiver.\n  class DataProducer : public QuicStreamFrameDataProducer {\n   public:\n    WriteStreamDataResult WriteStreamData(QuicStreamId id,\n                                          QuicStreamOffset offset,\n                                          QuicByteCount data_length,\n                                          QuicDataWriter* writer) override;\n    bool WriteCryptoData(EncryptionLevel level,\n                         QuicStreamOffset offset,\n                         QuicByteCount data_length,\n                         QuicDataWriter* writer) override;\n  };\n\n  std::string peer_name_;\n\n  Writer writer_;\n  // The queue for the outgoing packets.  In reality, this might be either on\n  // the network card, or in the kernel, but for concreteness we assume it's on\n  // the network card.\n  Queue nic_tx_queue_;\n  // Created by the subclass.\n  std::unique_ptr<QuicConnection> connection_;\n\n  // Counts the number of times the writer became write-blocked.\n  size_t write_blocked_count_;\n\n  // If true, drop the next packet when receiving it.\n  bool drop_next_packet_;\n\n  std::unique_ptr<QuicTraceVisitor> trace_visitor_;\n};\n\n// Multiplexes multiple connections at the same host on the network.\nclass QuicEndpointMultiplexer : public Endpoint,\n                                public UnconstrainedPortInterface {\n public:\n  QuicEndpointMultiplexer(std::string name,\n                          const std::vector<QuicEndpointBase*>& endpoints);\n  ~QuicEndpointMultiplexer() override;\n\n  // Receives a packet and passes it to the specified endpoint if that endpoint\n  // is one of the endpoints being multiplexed, otherwise ignores the packet.\n  void AcceptPacket(std::unique_ptr<Packet> packet) override;\n  UnconstrainedPortInterface* GetRxPort() override;\n\n  // Sets the egress port for all the endpoints being multiplexed.\n  void SetTxPort(ConstrainedPortInterface* port) override;\n\n  void Act() override {}\n\n private:\n  absl::flat_hash_map<std::string, QuicEndpointBase*> mapping_;\n};\n\n}  // namespace simulator\n}  // namespace quic\n\n#endif  // QUICHE_QUIC_TEST_TOOLS_SIMULATOR_QUIC_ENDPOINT_BASE_H_\n\n", "comment_ratio": 0.22981366459627328}
{"lang": "c", "code": "#include \"lmic.h\"\n#include \"peripherals.h\"\n\n#include \"bootloader.h\"\n#include \"boottab.h\"\n\n#if defined(CFG_perso)\n#include \"perso.h\"\n#endif\n\n#if defined(SVC_eefs)\n#include \"eefs/eefs.h\"\n#endif\n\n#if defined(SVC_pwrman)\n#include \"pwrman/pwrman.h\"\n#endif\n\n// HAL state\nstatic struct {\n    s4_t irqlevel;\n    u4_t ticks;\n    int watchcount;\n    u4_t reset;\n#ifdef CFG_rtstats\n    struct {\n        uint32_t run;                   // ticks running\n        uint32_t sleep[HAL_SLEEP_CNT];  // ticks sleeping\n    } rtstats;\n#endif\n    u1_t maxsleep[HAL_SLEEP_CNT-1]; // deep sleep restrictions\n    u1_t battlevel;\n    boot_boottab* boottab;\n} HAL;\n\n\n// -----------------------------------------------------------------------------\n// Panic\n\n// don't change these values, so we know what they are in the field...\nenum {\n    PANIC_HAL_FAILED    = 0,\n    PANIC_LSE_NOSTART   = 1,\n    PANIC_CAL_FAILED    = 2,\n    PANIC_STS_FAILED    = 3,\n    PANIC_SR_BUSY       = 4,\n};\n\n#ifdef CFG_panic911\n__attribute__((noinline)) // ensure function has a frame, since called from naked\nstatic void call911 (uint32_t reason, uint32_t addr) {\n    struct {\n        uint32_t magic;\n        unsigned char deveui[8];\n        uint32_t reason;\n        uint32_t addr;\n    } info;\n    info.magic = 0x504c4548; // HELP\n    memcpy(info.deveui, BOOT_DEVINFO->deveui, 8);\n    info.reason = reason;\n    info.addr = addr;\n    memcpy(LMIC.frame, &info, LMIC.dataLen = sizeof(info));\n\n#if defined(CFG_eu868)\n    LMIC.freq = 868300000;\n    LMIC.rps = updr2rps(DR_SF12);\n#elif defined(CFG_us915)\n    LMIC.freq = 903700000;\n    LMIC.rps = updr2rps(DR_SF10);\n#else\n#error \"Unsupported region\"\n#endif\n    LMIC.txpow = 14;\n    os_radio(RADIO_TX);\n}\n#endif\n\n__attribute__((noreturn))\nstatic void panic (uint32_t reason, uint32_t addr) {\n    // disable interrupts\n    __disable_irq();\n\n#ifdef CFG_panic911\n    // yelp for help\n    call911(reason, addr);\n#endif\n\n    // call bootloader's panic function\n    HAL.boottab->panic(reason, addr);\n    // not reached\n}\n\n__attribute__((noreturn, naked))\nvoid hal_failed () {\n    // get return address\n    uint32_t addr;\n    __asm__(\"mov %[addr], lr\" : [addr]\"=r\" (addr) : : );\n    // in thumb mode the linked address is the address of the calling instruction plus 4 bytes\n    addr -= 4;\n\n#ifdef SVC_backtrace\n    // log address of assertion\n    bt_addr(__LINE__, addr);\n    // save trace to EEPROM\n    bt_save();\n#endif\n\n    // call panic function\n    panic(PANIC_HAL_FAILED, addr);\n    // not reached\n}\n\n\n// -----------------------------------------------------------------------------\n// timer rollover based watchdog\n\nvoid hal_watchcount (int cnt) {\n    HAL.watchcount = cnt;\n}\n\n// -----------------------------------------------------------------------------\n// SPI\n\n#if BRD_RADIO_SPI == 1\n#define SPIx                    SPI1\n#define SPIx_enable()           do { RCC->APB2ENR |= RCC_APB2ENR_SPI1EN; } while (0)\n#define SPIx_disable()          do { RCC->APB2ENR &= ~RCC_APB2ENR_SPI1EN; } while (0)\n#define RCC_APB2ENR_SPIxEN      RCC_APB2ENR_SPI1EN\n#elif BRD_RADIO_SPI == 2\n#define SPIx                    SPI2\n#define SPIx_enable()           do { RCC->APB1ENR |= RCC_APB1ENR_SPI2EN; } while (0)\n#define SPIx_disable()          do { RCC->APB1ENR &= ~RCC_APB1ENR_SPI2EN; } while (0)\n#else\n#error \"Unsupported value for BRD_RADIO_SPI\"\n#endif\n\n\nstatic void hal_spi_init () {\n    // enable clock for SPI interface 1\n    SPIx_enable();\n\n    // configure and activate the SPI (master, internal slave select, software slave mgmt)\n    // (use default mode: 8-bit, 2-wire, no crc, MSBF, CPOL0 [clock is low when idle], CPHA0, PCLK32/4=8MHz)\n    SPIx->CR1 = SPI_CR1_MSTR | SPI_CR1_SSI | SPI_CR1_SSM | SPI_CR1_SPE | SPI_CR1_BR_0;\n\n    // configure I/O lines and disable clock\n    hal_spi_select(0);\n}\n\nvoid hal_spi_select (int on) {\n    if (on) {\n        // enable clock for SPI interface 1\n        SPIx_enable();\n        // configure pins for alternate function SPIx (SCK, MISO, MOSI)\n        CFG_PIN_AF(GPIO_SCK, GPIOCFG_OSPEED_40MHz | GPIOCFG_OTYPE_PUPD | GPIOCFG_PUPD_PDN);\n        CFG_PIN_AF(GPIO_MISO, GPIOCFG_OSPEED_40MHz | GPIOCFG_OTYPE_PUPD | GPIOCFG_PUPD_PDN);\n        CFG_PIN_AF(GPIO_MOSI, GPIOCFG_OSPEED_40MHz | GPIOCFG_OTYPE_PUPD | GPIOCFG_PUPD_PDN);\n        // drive chip select low\n        SET_PIN(GPIO_NSS, 0);\n        CFG_PIN(GPIO_NSS, GPIOCFG_MODE_OUT | GPIOCFG_OSPEED_40MHz | GPIOCFG_OTYPE_PUPD | GPIOCFG_PUPD_NONE);\n    } else {\n        // stop driving chip select, activate pull-up\n        CFG_PIN(GPIO_NSS, GPIOCFG_MODE_INP | GPIOCFG_PUPD_PUP);\n        // put SCK, MISO, MOSI back to analog input (HiZ) mode\n#if defined(BRD_sck_mosi_pulldown)\n        CFG_PIN(GPIO_SCK, GPIOCFG_MODE_INP | GPIOCFG_PUPD_PDN);\n        CFG_PIN(GPIO_MOSI, GPIOCFG_MODE_INP | GPIOCFG_PUPD_PDN);\n#elif defined(BRD_sck_mosi_drivelow)\n        SET_PIN(GPIO_SCK, 0);\n        CFG_PIN(GPIO_SCK, GPIOCFG_MODE_OUT | GPIOCFG_OSPEED_40MHz | GPIOCFG_OTYPE_PUPD | GPIOCFG_PUPD_NONE);\n        SET_PIN(GPIO_MOSI, 0);\n        CFG_PIN(GPIO_MOSI, GPIOCFG_MODE_OUT | GPIOCFG_OSPEED_40MHz | GPIOCFG_OTYPE_PUPD | GPIOCFG_PUPD_NONE);\n#else\n        CFG_PIN_DEFAULT(GPIO_SCK);\n        CFG_PIN_DEFAULT(GPIO_MOSI);\n#endif\n        CFG_PIN_DEFAULT(GPIO_MISO);\n        // disable clock for SPI interface\n        SPIx_disable();\n    }\n}\n\n// perform SPI transaction with radio\nu1_t hal_spi (u1_t out) {\n    SPIx->DR = out;\n    while( (SPIx->SR & SPI_SR_RXNE ) == 0);\n    return SPIx->DR; // in\n}\n\n\n// -----------------------------------------------------------------------------\n// Clock and Time\n//\n// Notes:\n// - 32.768kHz LSE must be available\n// - LPTIM1 using LSE as clock source to keep time (always on)\n// - LPTIM1 is 16bit, so it will roll-over every 2 seconds, causing a wake-up\n//\n// - TIM22 also uses the LSE as clock source\n// - TIM22 can be correlated to LPTIM1\n// - TIM22 is used as the on-time wake-up source for S0/S1\n// - TIM22 can be used to timestamp external events, e.g. DIO0 from the radio\n//\n//\n//    R0 \u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n//    \u2577        \u2502        \u2502\n//    \u2502        \u25be        \u25be\n//    \u2502        R1       R2\n//    \u2502        \u2577        \u2577\n//    \u2502        \u2502        \u2502\n//    \u25be        \u25be        \u25be\n//    S0       S1       S2\n//\n//\n// R0 is the main run mode. R1-2 are only used on the way to and from their\n// respective sleep modes. Also, timer roll-over is handled in the R mode\n// corresponding to the current sleep mode to avoid waking up completely.\n// Otherwise, a wake-up out of any sleep mode will return from the\n// corresponding R mode back to R0.\n//\n// S0 is a low-latency sleep mode, i.e. it can be entered and exited in less\n// than 1 tick.\n//\n// Run modes:\n// - R0: Run       32MHz HSI  ~ 7.15    mA\n// - R1: Run        4MHz MSI  ~ 0.700   mA\n// - R2: LP Run    65kHz MSI  ~ 0.00945 mA     - flash off (must run from RAM)\n//\n// Sleep modes:\n// - S0: Sleep     32MHz HSI  ~ 1.750   mA     - e.g. when high-speed-clock-dependent peripherals are active\n// - S1: Sleep      4MHz MSI  ~ 0.150   mA     - e.g. when the time is near\n// - S2: Stop            n/a  ~ 0.00043 mA     - all other cases\n//\n// Peripherals and applications can use the hal_setMaxSleep() and\n// hal_clearMaxSleep() APIs in matching pairs to restrict the HAL from entering\n// the deeper sleep modes.\n//\n// Wake-up times to R0 (empirical)\n// - from S0         < 1 tick\n// - from S1         ~ 4 ticks\n// - from S2       ~ 177 ticks\n//\n// Observations:\n// - The events of the LPTIM peripheral fire a tick \"late\":\n//   - After CMPM, CNT reads CMP+1\n//   - After ARRM, CNT reads 0\n// - When switching clocks or clock frequencies, the TIM22 peripheral misses\n//   some clock edges.\n//\n// Things to consider:\n// - Option to set Run speed (16Mhz could be enough and save power)\n\n\n#define PWR_CR_VOS_VRANGE1      (               PWR_CR_VOS_0)   // 1.8 V\n#define PWR_CR_VOS_VRANGE2      (PWR_CR_VOS_1               )   // 1.5 V\n#define PWR_CR_VOS_VRANGE3      (PWR_CR_VOS_1 | PWR_CR_VOS_0)   // 1.2 V\n\n// Busy wait on condition with timeout (about 10s)\n#define SAFE_while(reason, expr) do { \\\n    uint32_t __timeout = (1 << 25); \\\n    while( expr ) { \\\n        if( __timeout-- == 0 ) { \\\n            panic(reason, hal_getpc()); \\\n        } \\\n    } \\\n} while (0)\n\n// initialize the LSE and the LPTIM1 peripheral\nstatic void time_init (void) {\n    // check if LSE is still on\n    if( (RCC->CSR & RCC_CSR_LSEON) == 0) {\n        // enable power manager peripheral\n        RCC->APB1ENR |= RCC_APB1ENR_PWREN;\n        // disable RTC write protection (LSE bits in RCC->CSR are in RTC domain)\n        PWR->CR |= PWR_CR_DBP;\n\n        // Reset RTC\n        RCC->CSR |= RCC_CSR_RTCRST;\n        RCC->CSR &= ~RCC_CSR_RTCRST;\n\n#ifdef BRD_clock_lsedrv\n        // set the drive strength for the LSE (specify in board file if needed)\n        RCC->CSR = (RCC->CSR & ~RCC_CSR_LSEDRV) | BRD_clock_lsedrv;\n#endif\n\n        // turn on LSE\n        RCC->CSR |= RCC_CSR_LSEON;\n\n        // re-enable RTC write protection\n        PWR->CR &= ~PWR_CR_DBP;\n        // disable power manager peripheral\n        RCC->APB1ENR &= ~RCC_APB1ENR_PWREN;\n    }\n\n    // wait until LSE is ready\n    SAFE_while(PANIC_LSE_NOSTART, (RCC->CSR & RCC_CSR_LSERDY) == 0);\n\n    // select LSE as LPTIM1 clock source\n    RCC->CCIPR |= (RCC_CCIPR_LPTIM1SEL_0 | RCC_CCIPR_LPTIM1SEL_1);\n\n    // enable clock to LPTIM1 peripheral\n    RCC->APB1ENR |= RCC_APB1ENR_LPTIM1EN;\n\n    // reset LPTIM1 peripheral\n    RCC->APB1RSTR |= RCC_APB1RSTR_LPTIM1RST;\n    RCC->APB1RSTR &= ~RCC_APB1RSTR_LPTIM1RST;\n\n    // enable LPTIM1 peripheral\n    LPTIM1->CR |= LPTIM_CR_ENABLE;\n\n    // initialize auto-reload register\n    LPTIM1->ICR = LPTIM_ICR_ARROKCF;\n    LPTIM1->ARR = 0xffff;\n    while( (LPTIM1->ISR & LPTIM_ISR_ARROK) == 0 );\n\n    // enable auto-reload interrupt\n    NVIC_EnableIRQ(LPTIM1_IRQn);\n    LPTIM1->IER = LPTIM_IER_ARRMIE;\n\n    // start counting in continuous mode\n    LPTIM1->CR |= LPTIM_CR_CNTSTRT;\n\n    // enable clock to TIM22 peripheral\n    RCC->APB2ENR |= RCC_APB2ENR_TIM22EN;\n\n    // reset TIM22 peripheral\n    RCC->APB2RSTR |= RCC_APB2RSTR_TIM22RST;\n    RCC->APB2RSTR &= ~RCC_APB2RSTR_TIM22RST;\n\n    // set TIM22 clock source to LSE\n    TIM22->SMCR = TIM_SMCR_ECE;\n    TIM22->OR |= 3;\n\n    // enable TIM22 interrupts in NVIC\n    NVIC_EnableIRQ(TIM22_IRQn);\n\n    // start counting\n    TIM22->CR1 = TIM_CR1_CEN;\n\n#if CFG_watchdog\n    // configure watchdog\n    IWDG->KR = 0xcccc;          // start\n    IWDG->KR = 0x5555;          // enable write\n    IWDG->PR = 4;               // prescaler: 64\n    IWDG->RLR = (1 << 12) - 1;  // 37kHz\u207b\u00b9 * 64 * 2^12 = ~7s\n    while( IWDG->SR );          // wait until ready\n    IWDG->KR = 0xaaaa;          // refresh\n#endif\n}\n\n__attribute__((noinline,used)) static void _time_irq (uint32_t addr) {\n    // overflow\n    if( (LPTIM1->ISR & LPTIM_ISR_ARRM) != 0 ) {\n        LPTIM1->ICR = LPTIM_ICR_ARRMCF;\n        HAL.ticks += 1;\n        if( HAL.watchcount && --HAL.watchcount == 0 ) {\n            // log return address\n            TRACE_ADDR(addr);\n            // fail and reboot\n            ASSERT(0);\n        }\n#if CFG_watchdog\n        IWDG->KR = 0xaaaa; // refresh\n#endif\n    }\n    if( (LPTIM1->ISR & LPTIM_ISR_CMPM) != 0 ) {\n        LPTIM1->ICR = LPTIM_ICR_CMPMCF;\n    }\n}\n\n__attribute__((naked)) void time_irq (void) {\n    __asm__(\"    movs r0, #4\\n\"\n            \"    mov  r1, lr\\n\"\n            \"    tst  r0, r1\\n\"\n            \"    bne  1f\\n\"\n            \"    mrs  r0, msp\\n\"\n            \"    b    2f\\n\"\n            \"1:  mrs  r0, psp\\n\"\n            \"2:  ldr  r0, [r0, #0x18]\\n\"\n            \"    b    _time_irq\");\n}\n\n// NOTE: only call if interrupts are disabled\n// NOTE: only call if clock is fast enough\nstatic uint32_t time_cnt_unsafe (void) {\n    uint32_t t0, t1;\n    t1 = LPTIM1->CNT;\n    do {\n        t0 = t1;\n        t1 = LPTIM1->CNT;\n    } while( t1 != t0 );\n    return t1;\n}\n\n__attribute__((always_inline)) static inline void flash_off (void) {\n    // unlock RUN_PD bit\n    FLASH->PDKEYR = 0x04152637;\n    FLASH->PDKEYR = 0xFAFBFCFD;\n    // disable flash\n    FLASH->ACR |= FLASH_ACR_RUN_PD;\n    RCC->AHBENR &= ~RCC_AHBENR_MIFEN;\n}\n\n__attribute__((always_inline)) static inline void flash_on (void) {\n    // enable flash (this also relocks the RUN_PD bit)\n    RCC->AHBENR |= RCC_AHBENR_MIFEN;\n    (void) FLASH->ACR; // dummy read (see STM32L0xx errata)\n    FLASH->ACR &= ~FLASH_ACR_RUN_PD;\n}\n\n// Sleep until hticks reaches htt (or other interrupt occurs)\n// - implemented in sleep.S\n// - fastcode, i.e. can be called with Flash off\nextern u4_t sleep_htt (u4_t hticks, u4_t htt);\n\n// Sleep until hticks reaches htt and lticks reaches ltt (or other interrupt occurs)\n// Note: The secondary sleep step uses the TIM22 peripheral, correlation\n//       to which only works at higher clock speeds.\nstatic u4_t sleep_htt_ltt (u4_t hticks, u4_t htt, u4_t ltt) {\n    while( hticks < htt ) {\n        // zzzz....\n        __WFI();\n\n        // read and check ISR\n        uint32_t isr = LPTIM1->ISR & LPTIM_ISR_ARRM;\n        if( isr == 0 ) {\n            // other interrupt, g'day\n            goto done;\n        }\n\n        // clear ISR bits and NVIC\n        LPTIM1->ICR = isr;\n        while( (LPTIM1->ISR & isr) != 0 );\n        NVIC->ICPR[0] = (1 << LPTIM1_IRQn);\n\n        // increment hticks\n        hticks += 1;\n#if CFG_watchdog\n        IWDG->KR = 0xaaaa; // refresh\n#endif\n    }\n\n    // correlate LPTIM1 and TIM22\n    u4_t t0, t1, tx;\n    t1 = LPTIM1->CNT;\n    do {\n        t0 = t1;\n        tx = TIM22->CNT;\n        t1 = LPTIM1->CNT;\n    } while( t1 != t0);\n\n    // calculate number of ticks for secondary sleep phase\n    s4_t d = (s4_t) ltt - (s4_t) t0;\n    if( d > 0 ) {\n        TIM22->CCR2 = (tx + d) & 0xffff;\n        TIM22->SR = ~TIM_SR_CC2IF;\n        TIM22->DIER |= TIM_DIER_CC2IE;\n        TIM22->CCER |= TIM_CCER_CC2E;\n\n        // zzzz....\n        __WFI();\n\n        TIM22->CCER &= ~TIM_CCER_CC2E;\n        TIM22->DIER &= ~TIM_DIER_CC2IE;\n        TIM22->SR = ~TIM_SR_CC2IF;\n        NVIC->ICPR[0] = (1 << TIM22_IRQn);\n    }\ndone:\n    return hticks;\n}\n\n// used by both wake-up and init\nstatic void clock_run (void) {\n    // use 1 flash wait state (required for 32+MHz in Vrange 1 and 16+MHz in Vrange 2)\n    FLASH->ACR |= FLASH_ACR_LATENCY;\n    while( (FLASH->ACR & FLASH_ACR_LATENCY) == 0 );\n    // enable flash prefetch buffer\n    FLASH->ACR |= FLASH_ACR_PRFTEN;\n\n    // disable LP sleep, select Vrange 1\n    RCC->APB1ENR |= RCC_APB1ENR_PWREN;\n    PWR->CR &= ~PWR_CR_LPRUN; // must be cleared seperately\n    PWR->CR = PWR_CR_VOS_VRANGE1;\n    while( (PWR->CSR & PWR_CSR_VOSF) != 0 );\n    RCC->APB1ENR &= ~RCC_APB1ENR_PWREN;\n\n    // clear deep sleep (stop mode)\n    SCB->SCR &= ~SCB_SCR_SLEEPDEEP_Msk;\n\n    // enable HSI\n    RCC->CR |= RCC_CR_HSION;\n    while( (RCC->CR & RCC_CR_HSIRDY) == 0 );\n\n    // enable PLL\n    RCC->CR |= RCC_CR_PLLON;\n    while( (RCC->CR & RCC_CR_PLLRDY) == 0 );\n\n    // switch clock source to PLL\n    RCC->CFGR |= RCC_CFGR_SW_PLL;\n    while( (RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_PLL );\n\n    // disable MSI\n    RCC->CR &= ~RCC_CR_MSION;\n}\n\nstatic void clock_sleep (int stype) {\n    // startup MSI\n    if( stype == HAL_SLEEP_S1 ) {\n        RCC->ICSCR = (RCC->ICSCR & ~RCC_ICSCR_MSIRANGE) | RCC_ICSCR_MSIRANGE_6; // 4MHz\n    } else {\n        RCC->ICSCR = (RCC->ICSCR & ~RCC_ICSCR_MSIRANGE) | RCC_ICSCR_MSIRANGE_0; // 65kHz\n    }\n    RCC->CR |= RCC_CR_MSION;\n    while( (RCC->CR & RCC_CR_MSIRDY) == 0 );\n\n    // switch clock source to MSI\n    RCC->CFGR = (RCC->CFGR & ~RCC_CFGR_SW) | RCC_CFGR_SW_MSI;\n    while( (RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_MSI );\n\n    // disable flash prefetch buffer\n    FLASH->ACR &= ~FLASH_ACR_PRFTEN;\n    // disable flash wait states\n    FLASH->ACR &= ~FLASH_ACR_LATENCY;\n    while( (FLASH->ACR & FLASH_ACR_LATENCY) != 0 );\n\n    // disable PLL and HSI\n    RCC->CR &= ~(RCC_CR_PLLON | RCC_CR_HSION);\n\n    // select Vrange and LP options (LP modes require Vrange 2!)\n    uint32_t pwr_cr;\n    if( stype == HAL_SLEEP_S2 ) {\n        pwr_cr = PWR_CR_VOS_VRANGE2\n            | PWR_CR_LPSDSR      // LP sleep\n            | PWR_CR_ULP         // Ultra LP sleep (no Vref, thus no BOR, PVD, temp sensor)\n          /*| PWR_CR_DSEEKOFF */ // Do not power up NVM on wake up   FIXME doesn't work as advertized ?!?\n            ;\n        // set sleep mode to deep (maps to Stop mode)\n        SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;\n    } else {\n        pwr_cr = PWR_CR_VOS_VRANGE3;\n    }\n    RCC->APB1ENR |= RCC_APB1ENR_PWREN;\n    PWR->CR = pwr_cr;\n    while( (PWR->CSR & PWR_CSR_VOSF) != 0 );\n    if( stype != HAL_SLEEP_S1 ) {\n        PWR->CR |= PWR_CR_LPRUN; // LP run\n    }\n    RCC->APB1ENR &= ~RCC_APB1ENR_PWREN;\n}\n\n__fastcode static u4_t sleep2 (u4_t hticks, u4_t htt, u4_t ltt) {\n    clock_sleep(HAL_SLEEP_S2);\n    flash_off();\n    hticks = sleep_htt(HAL.ticks, htt);\n    flash_on();\n    clock_run();\n    return hticks;\n}\n\nstatic u4_t sleep1 (u4_t hticks, u4_t htt, u4_t ltt) {\n    clock_sleep(HAL_SLEEP_S1);\n    hticks = sleep_htt_ltt(HAL.ticks, htt, ltt);\n    clock_run();\n    return hticks;\n}\n\nstatic u4_t sleep0 (u4_t hticks, u4_t htt, u4_t ltt) {\n    hticks = sleep_htt_ltt(HAL.ticks, htt, ltt);\n    return hticks;\n}\n\nstatic void sleep (int stype, u4_t htt, u4_t ltt) {\n    static const u4_t(*sleepfuncs[])(u4_t,u4_t,u4_t) = {\n        sleep0,\n        sleep1,\n        sleep2,\n    };\n    HAL.ticks = sleepfuncs[stype](HAL.ticks, htt, ltt);\n}\n\nstatic void clock_init() {\n    // System is clocked by MSI @2.1MHz at startup\n    // We want to go to PLL(HSI16) @32MHz\n\n    // configure PLL: source=HSI16, multiplier=4, divider=2\n    RCC->CFGR |= (RCC_CFGR_PLLSRC_HSI | RCC_CFGR_PLLMUL4 | RCC_CFGR_PLLDIV2);\n\n    // startup HSI/PLL fast clock\n    clock_run();\n\n    // sleep mode settings\n    FLASH->ACR |= FLASH_ACR_SLEEP_PD; // enable flash power-off during sleep\n}\n\n// NOTE: only call if interrupts are disabled\n#define hal_ticks_unsafe() ((u4_t) hal_xticks_unsafe())\nstatic u8_t hal_xticks_unsafe (void) {\n    u8_t xt = HAL.ticks;\n    u4_t cnt = time_cnt_unsafe();\n    if( (LPTIM1->ISR & LPTIM_ISR_ARRM) != 0 ) {\n        // include pending overflow in evaluation\n        cnt = time_cnt_unsafe();\n        xt++;\n    }\n    return (xt << 16) | cnt;\n}\n\nu8_t hal_xticks () {\n    hal_disableIRQs();\n    u8_t xt = hal_xticks_unsafe();\n    hal_enableIRQs();\n    return xt;\n}\n\nu4_t hal_ticks () {\n    return hal_xticks();\n}\n\n// NOTE: interrupts are already be disabled when this HAL function is called!\nu1_t hal_sleep (u1_t type, u4_t targettime) {\n    static const u8_t S_TH[] = {\n        0, 6, 190\n    };\n\n    u8_t xnow = hal_xticks_unsafe();\n    s4_t dt;\n    if( type == HAL_SLEEP_FOREVER ) {\n        dt = sec2osticks(12*60*60); // 12 h\n    } else {\n        dt = (s4_t) targettime - (s4_t) xnow;\n    }\n    if( dt <= 0 ) {\n        return 0; // it's time now\n    }\n\n    // select sleep type\n    int stype;\n    for( stype = 0; stype < (HAL_SLEEP_CNT-1); stype++ ) {\n        if( dt < S_TH[stype + 1] || HAL.maxsleep[stype] ) {\n            break;\n        }\n    }\n\n    // only use S2 if htt would be strictly larger\n    if( stype == HAL_SLEEP_S2 ) {\n        u8_t xtt = xnow + dt - S_TH[HAL_SLEEP_S2];\n        if( (xtt >> 16) <= (xnow >> 16) ) {\n            stype -= 1;\n        }\n    }\n\n#ifdef CFG_rtstats\n    static ostime_t wakeup;\n    ostime_t t1 = xnow;\n    ASSERT((t1 - wakeup) >= 0);\n    HAL.rtstats.run += (t1 - wakeup);\n#endif\n\n    xnow += (dt - S_TH[stype]);\n    sleep(stype, xnow >> 16, xnow & 0xffff);\n\n#ifdef CFG_rtstats\n    ostime_t t2 = hal_ticks_unsafe();\n    ASSERT((t2 - t1) >= 0);\n    HAL.rtstats.sleep[stype] += (t2 - t1);\n    wakeup = t2;\n#endif\n\n    return 1; // we slept\n}\n\n// short-term busy wait\n// shouldn't be used for extended periods of time\n// cannot possibly wait for more than 2 sec when interrupts are disabled because of timer overrun\nvoid hal_waitUntil (u4_t time) {\n    // assure waiting period is in intended range of up to 1 sec (and hasn't expired too long ago)\n    ostime_t diff = time - hal_ticks();\n    ASSERT(diff > -sec2osticks(1) && diff < sec2osticks(1));\n    // busy wait until timestamp is reached\n    while( ((s4_t) time - (s4_t) hal_ticks()) > 0 );\n}\n\nvoid hal_setMaxSleep (unsigned int level) {\n    hal_disableIRQs();\n    ASSERT(level < HAL_SLEEP_CNT-1);\n    HAL.maxsleep[level] += 1;\n    hal_enableIRQs();\n}\n\nvoid hal_clearMaxSleep (unsigned int level) {\n    hal_disableIRQs();\n    ASSERT(level < HAL_SLEEP_CNT-1);\n    ASSERT(HAL.maxsleep[level]);\n    HAL.maxsleep[level] -= 1;\n    hal_enableIRQs();\n}\n\n\n// -----------------------------------------------------------------------------\n// I/O\n\nstatic void hal_io_init () {\n#ifndef CFG_noradio\n#if defined(GPIO_RX)\n    SET_PIN_ONOFF(GPIO_RX, 0);\n    CFG_PIN(GPIO_RX, GPIOCFG_MODE_OUT | GPIOCFG_OSPEED_40MHz | GPIOCFG_OTYPE_PUPD | GPIOCFG_PUPD_NONE);\n#endif\n#if defined(GPIO_TX)\n    SET_PIN_ONOFF(GPIO_TX, 0);\n    CFG_PIN(GPIO_TX, GPIOCFG_MODE_OUT | GPIOCFG_OSPEED_40MHz | GPIOCFG_OTYPE_PUPD | GPIOCFG_PUPD_NONE);\n#endif\n#if defined(GPIO_TX2)\n    SET_PIN_ONOFF(GPIO_TX2, 0);\n    CFG_PIN(GPIO_TX2, GPIOCFG_MODE_OUT | GPIOCFG_OSPEED_40MHz | GPIOCFG_OTYPE_PUPD | GPIOCFG_PUPD_NONE);\n#endif\n#ifdef GPIO_TXRX_EN\n    SET_PIN_ONOFF(GPIO_TXRX_EN, 0);\n    CFG_PIN(GPIO_TXRX_EN, GPIOCFG_MODE_OUT | GPIOCFG_OSPEED_40MHz | GPIOCFG_OTYPE_PUPD | GPIOCFG_PUPD_NONE);\n#endif\n#ifdef GPIO_DIO0\n    IRQ_PIN(GPIO_DIO0, GPIO_IRQ_RISING);\n#endif\n#ifdef GPIO_DIO1\n    IRQ_PIN(GPIO_DIO1, GPIO_IRQ_RISING);\n#endif\n#ifdef GPIO_DIO2\n    IRQ_PIN(GPIO_DIO2, GPIO_IRQ_RISING);\n#endif\n#ifdef GPIO_DIO3\n    IRQ_PIN(GPIO_DIO3, GPIO_IRQ_RISING);\n#endif\n#endif\n}\n\nbool hal_pin_tcxo (u1_t val) {\n#if defined(GPIO_TCXO_PWR)\n    if (val != 0) {\n        SET_PIN(GPIO_TCXO_PWR, 1);\n        CFG_PIN(GPIO_TCXO_PWR, GPIOCFG_MODE_OUT | GPIOCFG_OSPEED_400kHz | GPIOCFG_OTYPE_PUPD | GPIOCFG_PUPD_NONE);\n    } else {\n        SET_PIN(GPIO_TCXO_PWR, 0);\n        CFG_PIN_DEFAULT(GPIO_TCXO_PWR);\n    }\n    return true;\n#else\n    return false;\n#endif\n}\n\nvoid hal_ant_switch (u1_t val) {\n#ifdef SVC_pwrman\n    static ostime_t t1;\n    static int ctype;\n    static uint32_t radio_ua;\n    ostime_t now = hal_ticks();\n    if( radio_ua ) {\n        pwrman_consume(ctype, now - t1, radio_ua);\n        radio_ua = 0;\n    }\n#endif\n    if (val == HAL_ANTSW_OFF) {\n#ifdef GPIO_TXRX_EN\n        SET_PIN_ONOFF(GPIO_TXRX_EN, 0);\n#endif\n    } else {\n#ifdef SVC_pwrman\n        t1 = now;\n        ctype = (val == HAL_ANTSW_RX) ? PWRMAN_C_RX : PWRMAN_C_TX;\n        radio_ua = LMIC.radioPwr_ua;\n#endif\n#ifdef GPIO_TXRX_EN\n        SET_PIN_ONOFF(GPIO_TXRX_EN, 1);\n#endif\n    }\n#ifdef GPIO_RX\n    SET_PIN_ONOFF(GPIO_RX, (val == HAL_ANTSW_RX));\n#endif\n#ifdef GPIO_TX\n    SET_PIN_ONOFF(GPIO_TX, (val == HAL_ANTSW_TX));\n#endif\n#ifdef GPIO_TX2\n    SET_PIN_ONOFF(GPIO_TX2, (val == HAL_ANTSW_TX2));\n#endif\n}\n\n// set radio RST pin to given value (or keep floating!)\nvoid hal_pin_rst (u1_t val) {\n    if(val == 0 || val == 1) { // drive pin\n        SET_PIN(GPIO_RST, val);\n        CFG_PIN(GPIO_RST, GPIOCFG_MODE_OUT | GPIOCFG_OSPEED_40MHz | GPIOCFG_OTYPE_PUPD | GPIOCFG_PUPD_NONE);\n    } else { // keep pin floating\n        CFG_PIN(GPIO_RST, GPIOCFG_MODE_ANA | GPIOCFG_OSPEED_400kHz | GPIOCFG_OTYPE_OPEN | GPIOCFG_PUPD_NONE);\n    }\n}\n\nvoid hal_pin_busy_wait (void) {\n#ifdef GPIO_BUSY\n    CFG_PIN(GPIO_BUSY, GPIOCFG_MODE_INP | GPIOCFG_OSPEED_40MHz);\n\n    while (GET_PIN(GPIO_BUSY) != 0);\n\n    CFG_PIN_DEFAULT(GPIO_BUSY);\n#endif\n}\n\n#define DIO_UPDATE(dio,mask,time) do { \\\n    if( (EXTI->PR & (1 << BRD_PIN(GPIO_DIO ## dio))) ) { \\\n        EXTI->PR = (1 << BRD_PIN(GPIO_DIO ## dio)); \\\n        *(mask) |= (1 << dio); \\\n        /* if( BRD_GPIO_GET_CHAN(GPIO_DIO ## dio) ) { \\\n            unsigned int ch = BRD_GPIO_GET_CHAN(GPIO_DIO ## dio) - 1; \\\n            ASSERT(TIMx->SR & (TIM_SR_CC1IF << ch)); \\\n            s2_t ct = (&(TIMx->CCR1))[ch]; \\\n            *(time) += (ct - (s2_t) *(time)); \\\n        } */ \\\n    } \\\n} while( 0 )\n\n// generic EXTI IRQ handler for all channels\nstatic void EXTI_IRQHandler () {\n    u4_t now = hal_ticks_unsafe();\n    u1_t diomask = 0;\n#ifdef GPIO_DIO0\n    // DIO 0\n    DIO_UPDATE(0, &diomask, &now);\n#endif\n#ifdef GPIO_DIO1\n    // DIO 1\n    DIO_UPDATE(1, &diomask, &now);\n#endif\n#ifdef GPIO_DIO2\n    // DIO 2\n    DIO_UPDATE(2, &diomask, &now);\n#endif\n#ifdef GPIO_DIO3\n    // DIO 3\n    DIO_UPDATE(3, &diomask, &now);\n#endif\n\n    if(diomask) {\n        // invoke radio handler (on IRQ)\n        radio_irq_handler(diomask, now);\n    }\n\n#ifdef CFG_EXTI_IRQ_HANDLER\n    // invoke user-defined interrupt handler\n    {\n        extern void CFG_EXTI_IRQ_HANDLER(void);\n        CFG_EXTI_IRQ_HANDLER();\n    }\n#endif // CFG_EXTI_IRQ_HANDLER\n}\n\nstatic void dio_config (int mask, int pin, int gpio) {\n    if( mask & pin ) {\n#if 0\n        if( BRD_GPIO_GET_CHAN(gpio) ) {\n            unsigned int ch = BRD_GPIO_GET_CHAN(gpio) - 1;\n            TIMx->CCMR1 |= (1 << (ch << 3));\n            TIMx->SR = ~(TIM_SR_CC1IF << ch);\n            TIMx->CCER |= (TIM_CCER_CC1E << (ch << 2));\n            CFG_PIN_AF(gpio, 0);\n        } else\n#endif\n        {\n            CFG_PIN(gpio, GPIOCFG_MODE_INP);\n        }\n        IRQ_PIN_SET(gpio, 1);\n    } else {\n#if 0\n        if( BRD_GPIO_GET_CHAN(gpio) ) {\n            unsigned int ch = BRD_GPIO_GET_CHAN(gpio) - 1;\n            TIMx->CCER &= ~(TIM_CCER_CC1E << (ch << 2));\n        }\n#endif\n        IRQ_PIN_SET(gpio, 0);\n        CFG_PIN_DEFAULT(gpio);\n        EXTI->PR = (1 << BRD_PIN(gpio)); // clear irq\n    }\n}\n\nvoid hal_irqmask_set (int mask) {\n    static int prevmask = 0;\n\n#ifdef GPIO_DIO0\n    dio_config(mask, HAL_IRQMASK_DIO0, GPIO_DIO0);\n#endif\n#ifdef GPIO_DIO1\n    dio_config(mask, HAL_IRQMASK_DIO1, GPIO_DIO1);\n#endif\n#ifdef GPIO_DIO2\n    dio_config(mask, HAL_IRQMASK_DIO2, GPIO_DIO2);\n#endif\n#ifdef GPIO_DIO3\n    dio_config(mask, HAL_IRQMASK_DIO3, GPIO_DIO3);\n#endif\n\n    mask = (mask != 0);\n    if (prevmask != mask) {\n        // prevent sleep if we are waiting for radio interrupts\n        // TODO - evaluate if that is the correct thing to do\n        if (mask) {\n            hal_setMaxSleep(HAL_SLEEP_S0);\n        } else {\n            hal_clearMaxSleep(HAL_SLEEP_S0);\n        }\n        prevmask = mask;\n    }\n}\n\n\n// -----------------------------------------------------------------------------\n// IRQ\n\nvoid hal_disableIRQs () {\n    __disable_irq();\n    HAL.irqlevel++;\n}\n\nvoid hal_enableIRQs () {\n    if(--HAL.irqlevel == 0) {\n        __enable_irq();\n    }\n}\n\n#ifdef CFG_rtstats\nvoid hal_rtstats_collect (hal_rtstats* stats) {\n    stats->run_ticks = HAL.rtstats.run;\n    HAL.rtstats.run = 0;\n    for( int i = 0; i < HAL_SLEEP_CNT; i++ ) {\n        stats->sleep_ticks[i] = HAL.rtstats.sleep[i];\n        HAL.rtstats.sleep[i] = 0;\n    }\n}\n#endif\n\n\n#ifdef BRD_borlevel\n// -----------------------------------------------------------------------------\n// Brown-out reset\n\n__fastcode static void write_optbyte (volatile uint32_t* pdest, uint32_t data) {\n    // unlock data eeprom memory and registers\n    FLASH->PEKEYR = 0x89ABCDEF; // FLASH_PEKEY1\n    FLASH->PEKEYR = 0x02030405; // FLASH_PEKEY2\n\n    // unlock option bytes area\n    FLASH->OPTKEYR = 0xFBEAD9C8; // FLASH_OPTKEY1\n    FLASH->OPTKEYR = 0x24252627; // FLASH_OPTKEY2\n\n    // write option byte with complement\n    *pdest = data | (~data << 16);\n\n    // wait for programming to complete\n    SAFE_while(PANIC_SR_BUSY, FLASH->SR & FLASH_SR_BSY);\n\n    // check status\n    ASSERT(FLASH->SR & FLASH_SR_EOP);\n    FLASH->SR = FLASH_SR_EOP;\n\n    // reload option bytes (causes reset)\n    FLASH->PECR |= FLASH_PECR_OBL_LAUNCH;\n}\n\nstatic void setbrownout (int level) {\n    unsigned int user = OB->USER & 0xffff;\n    if( (user & 0xf) != level ) {\n        write_optbyte(&OB->USER, (user & ~0xf) | level);\n        // not reached\n        ASSERT(0);\n    }\n}\n\n#endif\n\n\n// -----------------------------------------------------------------------------\n\n#ifdef CFG_DEBUG\nstatic void debug_init (void); // fwd decl\n#endif\n\nvoid hal_init (void* bootarg) {\n    memset(&HAL, 0x00, sizeof(HAL));\n    HAL.boottab = bootarg;\n    HAL.battlevel = MCMD_DEVS_BATT_NOINFO;\n\n    HAL.reset = RCC->CSR;\n    RCC->CSR |= RCC_CSR_RMVF;\n\n    ASSERT(HAL.boottab->version >= 0x105); // require bootloader v261\n\n#ifdef BRD_borlevel\n    setbrownout(BRD_borlevel);\n#endif\n\n    hal_disableIRQs();\n\n    clock_init();\n\n    pd_init();\n\n#if 1\n    // disable single-wire debug (SWD) when running\n    CFG_PIN_DEFAULT(BRD_GPIO(PORT_A, 13));\n    CFG_PIN_DEFAULT(BRD_GPIO(PORT_A, 14));\n#endif\n\n#if defined(CFG_wailmer_board) || defined(CFG_wailord_board) || defined(CFG_coxproto_board) || defined(CFG_itrack_board)\n    // ensure GNSS is turned off (there is no external pull-down on load switch control line)\n    CFG_PIN(GPIO_GNSS_EN, GPIOCFG_MODE_OUT | GPIOCFG_OSPEED_400kHz | GPIOCFG_OTYPE_PUPD | GPIOCFG_PUPD_NONE);\n    SET_PIN(GPIO_GNSS_EN, 0);\n#endif\n\n    // configure radio I/O and interrupt handler\n    hal_io_init();\n    // configure radio SPI\n    hal_spi_init();\n    // configure timer and interrupt handler\n    time_init();\n\n    hal_enableIRQs();\n\n    leds_init();\n#ifdef BRD_USART\n    usart_init();\n#endif\n#ifdef BRD_VIBE_TIM\n    vibe_init();\n#endif\n\n#if defined(CFG_perso)\n    perso_enter();\n#endif\n\n#ifdef CFG_DEBUG\n    debug_init();\n#endif\n\n#if defined(SVC_eefs)\n    eefs_init((void*) APPDATA_BASE, APPDATA_SZ);\n#endif\n}\n\nconst irqdef HAL_irqdefs[] = {\n    { EXTI0_1_IRQn, EXTI_IRQHandler },\n    { EXTI2_3_IRQn, EXTI_IRQHandler },\n    { EXTI4_15_IRQn, EXTI_IRQHandler },\n\n    { LPTIM1_IRQn, time_irq },\n\n#if defined(BRD_I2C)\n#if BRD_I2C == 1\n    { I2C1_IRQn, i2c_irq },\n#endif\n#endif\n\n#if defined(BRD_USART)\n#if BRD_USART == 1\n    { USART1_IRQn, usart_irq },\n#elif BRD_USART == BRD_LPUART(1)\n    { LPUART1_IRQn, usart_irq },\n#endif\n#endif\n\n#if defined(BRD_PWM_TIM)\n#if BRD_PWM_TIM == 3\n    { TIM3_IRQn, pwm_irq },\n#endif\n#endif\n\n#if defined(BRD_PIR_TIM)\n#if BRD_PIR_TIM == 3\n    { TIM3_IRQn, pir_tim_irq },\n#endif\n#endif\n\n#if defined(BRD_LED_TIM)\n#if BRD_LED_TIM == 2\n    { TIM2_IRQn, leds_pwm_irq },\n#endif\n#endif\n\n#if defined(BRD_IR_TIM)\n    { TIM2_IRQn, ir_tim_irq },\n#endif\n\n    { ~0, NULL } // end of list\n};\n\nunsigned int crc32 (void* ptr, int nwords) {\n    return HAL.boottab->crc32(ptr, nwords);\n}\n\nu1_t hal_getBattLevel (void) {\n    return HAL.battlevel;\n}\n\nvoid hal_setBattLevel (u1_t level) {\n    HAL.battlevel = level;\n}\n\n\n#ifdef CFG_DEBUG\n\n#if BRD_DBG_UART == 1\n#define DBG_USART USART1\n#define DBG_USART_enable()    do { RCC->APB2ENR |= RCC_APB2ENR_USART1EN; } while (0)\n#define DBG_USART_disable()   do { RCC->APB2ENR &= ~RCC_APB2ENR_USART1EN; } while (0)\n#elif BRD_DBG_UART == 2\n#define DBG_USART USART2\n#define DBG_USART_enable()    do { RCC->APB1ENR |= RCC_APB1ENR_USART2EN; } while (0)\n#define DBG_USART_disable()   do { RCC->APB1ENR &= ~RCC_APB1ENR_USART2EN; } while (0)\n#elif BRD_DBG_UART == 4\n#define DBG_USART USART4\n#define DBG_USART_enable()    do { RCC->APB1ENR |= RCC_APB1ENR_USART4EN; } while (0)\n#define DBG_USART_disable()   do { RCC->APB1ENR &= ~RCC_APB1ENR_USART4EN; } while (0)\n#endif\n#define DBG_USART_WRITE(c)    do { DBG_USART->TDR = (c); } while (0)\n#define DBG_USART_BUSY()      ((DBG_USART->ISR & USART_ISR_TXE) == 0)\n#define DBG_USART_TXING()     ((DBG_USART->ISR & USART_ISR_TC) == 0)\n\nstatic void debug_init (void) {\n    // configure USART (115200/8N1, tx-only)\n    DBG_USART_enable();\n    DBG_USART->BRR = 16; // 2000000 baud (APB1 clock @32MHz)\n    DBG_USART->CR1 = USART_CR1_UE | USART_CR1_TE; // usart + transmitter enable\n    DBG_USART_disable();\n#if CFG_DEBUG != 0\n    debug_str(\"\\r\\n============== DEBUG STARTED ==============\\r\\n\");\n#endif\n}\n\nvoid hal_debug_str (const char* str) {\n    DBG_USART_enable();\n    CFG_PIN_AF(GPIO_DBG_TX, GPIOCFG_OSPEED_40MHz | GPIOCFG_OTYPE_PUPD | GPIOCFG_PUPD_NONE);\n    char c;\n    while( (c = *str++) ) {\n        while( DBG_USART_BUSY() );\n        DBG_USART_WRITE(c);\n    }\n    while( DBG_USART_TXING() );\n    CFG_PIN(GPIO_DBG_TX, GPIOCFG_MODE_INP | GPIOCFG_OSPEED_400kHz | GPIOCFG_OTYPE_OPEN | GPIOCFG_PUPD_PUP);\n    DBG_USART_disable();\n}\n\nvoid hal_debug_led (int val) {\n#if defined(GPIO_DBG_LED)\n    leds_set(GPIO_DBG_LED, val);\n#endif\n}\n\n#endif\n\n\nvoid hal_fwinfo (hal_fwi* fwi) {\n    fwi->blversion = HAL.boottab->version;\n\n    extern volatile hal_fwhdr fwhdr;\n    fwi->version = fwhdr.version;\n    fwi->crc = fwhdr.boot.crc;\n    fwi->flashsz = FLASH_SZ;\n}\n\nu4_t hal_unique (void) {\n    uint32_t unique[3] = {\n        *((uint32_t*) UNIQUE_ID0),\n        *((uint32_t*) UNIQUE_ID1),\n        *((uint32_t*) UNIQUE_ID2)\n    };\n    return crc32(&unique, 3);\n}\n\nvoid hal_reboot (void) {\n    NVIC_SystemReset();\n    // not reached\n    hal_failed();\n}\n\n// persistent storage of stack data\ntypedef struct {\n    uint32_t    dnonce[4];      // dev nonce history\n    uint32_t    jnonce[4];      // join nonce history\n} pdata;\n\n// Note: The next nonce is stored, and the writes are spread over 4 fields. At\n// 100k write cycles, this will allow 400k join requests. The DevNonce counter\n// is only 16 bits, so it will roll-over much earlier, but the counter can be\n// restarted at 0 if/when the Join EUI changes.\n\nu4_t hal_dnonce_next (void) {\n    pdata* p = (pdata*) STACKDATA_BASE;\n    int x = 0;\n    while( x < 3 && p->dnonce[x] < p->dnonce[x + 1] ) {\n        x += 1;\n    }\n    u4_t dn = p->dnonce[x];\n    eeprom_write(p->dnonce + ((x + 1) & 3), dn + 1);\n    return dn;\n}\n\nvoid hal_dnonce_clear (void) {\n    pdata* p = (pdata*) STACKDATA_BASE;\n    for( int i = 0; i < 4; i++) {\n        eeprom_write(p->dnonce + i, 0);\n    }\n}\n\nvoid sha256 (uint32_t* hash, const uint8_t* msg, uint32_t len) {\n    HAL.boottab->sha256(hash, msg, len);\n}\n\nbool hal_set_update (void* ptr) {\n    return HAL.boottab->update(ptr, NULL) == BOOT_OK;\n}\n\nvoid flash_write (void* dst, const void* src, unsigned int nwords, bool erase) {\n    hal_disableIRQs();\n    HAL.boottab->wr_flash(dst, src, nwords, erase);\n    hal_enableIRQs();\n}\n\nvoid hal_logEv (uint8_t evcat, uint8_t evid, uint32_t evparam) {\n    // XXX:TBD\n}\n\n", "comment_ratio": 0.20535714285714285}
{"lang": "c", "code": "#pragma once\n\n#include \"Resource.h\"\n\nclass Serializer;\n\n// Class for handling different resource types using the same interface. \n// Threadsafe\nclass AssetTracker\n{\nprivate:\n\tusing AssetIter = std::unordered_map<Resource::Id, Resource*>::const_iterator;\n\tusing AssetPair = std::pair<const Resource::Id, Resource*>;\n\tusing RegisterIter = std::unordered_map<std::string, Resource::Id>::const_iterator;\n\tusing TLSSerializers = tbb::enumerable_thread_specific<Serializer*>;\n\npublic:\n\tAssetTracker();\n\t~AssetTracker();\n\n\t// Saves an asset to the disk. Tracks it for future use\n\t// Automatically appends Asset extension if it's missing\n\t// Threadsafe\n\ttemplate<class TAsset>\n\tvoid SaveAndTrack(\n\t\tconst std::string& aPath,\n\t\tHandle<TAsset> aHandle\n\t);\n\n\t// Saves an asset to the disk. Tracks it for future use\n\t// Automatically appends Asset extension if it's missing\n\t// Threadsafe\n\ttemplate<class TAsset>\n\tvoid SaveAndTrack(\n\t\tconst std::string& aPath,\n\t\tTAsset* aRes\n\t);\n\n\t// Creates an asset and schedules for load, otherwise just returns an existing asset.\n\t// Threadsafe\n\ttemplate<class TAsset>\n\tHandle<TAsset> GetOrCreate(const std::string& aPath);\n\nprivate:\n\tvoid SaveAndTrackImpl(\n\t\tconst std::string& aPath,\n\t\tResource& aHandle\n\t);\n\n\t// Utility method to clean-up the resource from registry and asset collections\n\t// Doesn't delete the actual resource - it's Handle's responsibility\n\t// Threadsafe\n\tvoid RemoveResource(const Resource* aRes);\n\n\tResource::Id GetOrCreateResourceId(const std::string& aPath);\n\n\t// returns true if a Resource was found, false otherwise\n\ttemplate<class TAsset>\n\tbool GetOrCreateResource(Resource::Id anId, const std::string& aPath, TAsset*& aRes);\n\n\tvoid StartLoading(Handle<Resource> aRes);\n\n\ttbb::spin_mutex myRegisterMutex;\n\ttbb::spin_mutex myAssetMutex;\n\tstd::atomic<Resource::Id> myCounter;\n\t// since all resources come from disk, we can track them by their path\n\tstd::unordered_map<std::string, Resource::Id> myRegister;\n\t// Resources have unique(among their type) Id, and it's the main way to find it\n\t// Yes, it's stored as raw, but the memory is managed by Handles\n\tstd::unordered_map<Resource::Id, Resource*> myAssets;\n\toneapi::tbb::task_group myLoadTaskGroup;\n\n\tTLSSerializers myReadSerializers;\n\tTLSSerializers myWriteSerializers;\n};\n\ntemplate<class TAsset>\nvoid AssetTracker::SaveAndTrack(const std::string& aPath, Handle<TAsset> aHandle)\n{\n\tstatic_assert(std::is_base_of_v<Resource, TAsset>, \"Asset tracker cannot track this type!\");\n\tstatic_assert(!std::is_same_v<TAsset, Resource>, \"Invalid type, can't save a generic resource!\");\n\n\tASSERT_STR(aHandle.IsValid(), \"Trying to save invalid handle!\");\n\tif (aPath.rfind(TAsset::kExtension.CStr()) == std::string::npos)\n\t{\n\t\tSaveAndTrackImpl(aPath + TAsset::kExtension.CStr(), *aHandle.Get());\n\t}\n\telse\n\t{\n\t\tSaveAndTrackImpl(aPath, *aHandle.Get());\n\t}\n}\n\ntemplate<class TAsset>\nvoid AssetTracker::SaveAndTrack(const std::string& aPath, TAsset* aRes)\n{\n\tstatic_assert(std::is_base_of_v<Resource, TAsset>, \"Asset tracker cannot track this type!\");\n\tstatic_assert(!std::is_same_v<TAsset, Resource>, \"Invalid type, can't save a generic resource!\");\n\n\tASSERT_STR(aRes, \"Trying to save invalid resource!\");\n\tif (aPath.rfind(TAsset::kExtension.CStr()) == std::string::npos)\n\t{\n\t\tSaveAndTrackImpl(aPath + TAsset::kExtension.CStr(), *aRes);\n\t}\n\telse\n\t{\n\t\tSaveAndTrackImpl(aPath, *aRes);\n\t}\n}\n\ntemplate<class TAsset>\nHandle<TAsset> AssetTracker::GetOrCreate(const std::string& aPath)\n{\n\tstatic_assert(std::is_base_of_v<Resource, TAsset>, \"Asset tracker cannot track this type!\");\n\tstatic_assert(!std::is_same_v<TAsset, Resource>, \"Invalid type, can't load a generic resource!\");\n\n\t// first gotta check if we have it in the registry\n\tstd::string path = Resource::kAssetsFolder.CStr() + aPath;\n\tResource::Id resourceId = GetOrCreateResourceId(path);\n\n\t// now that we have an id, we can find it\n\tTAsset* asset = nullptr;\n\tif (GetOrCreateResource(resourceId, path, asset))\n\t{\n\t\treturn Handle<TAsset>(asset);\n\t}\n\n\t// We didn't find it, which means it's newly created and needs loading\n\t// set up the onDestroy callback, so that we can clean up \n\t// the registry and assets containters when it gets removed\n\tasset->AddOnDestroyCB([=](const Resource* aRes) { RemoveResource(aRes); });\n\n\t// adding it to the queue of loading, since we know that it'll be loaded from file\n\tHandle<TAsset> assetHandle{ asset };\n\tStartLoading(assetHandle);\n\n\treturn assetHandle;\n}\n\ntemplate<class TAsset>\nbool AssetTracker::GetOrCreateResource(Resource::Id anId, const std::string& aPath, TAsset*& aRes)\n{\n\ttbb::spin_mutex::scoped_lock lock(myAssetMutex);\n\tAssetIter pair = myAssets.find(anId);\n\tif (pair != myAssets.end())\n\t{\n\t\taRes = static_cast<TAsset*>(pair->second);\n\t\treturn true;\n\t}\n\n\taRes = new TAsset(anId, aPath);\n\tmyAssets[anId] = aRes;\n\treturn false;\n}\n", "comment_ratio": 0.14935064935064934}
{"lang": "c", "code": "#import \"PYBaseTableHeaderFooterView.h\"\n#import \"BaseJsonViewStepModel.h\"\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface BaseJsonViewSearchResultTableViewHeaderView : PYBaseTableHeaderFooterView\n@property (nonatomic,copy) NSString *title;\n\n+ (NSString *) getTitleWithModel: (BaseJsonViewStepModel *)model;\n\n+ (CGFloat) getHWithString: (NSString *)str;\n@end\n\nNS_ASSUME_NONNULL_END\n\n", "comment_ratio": 0.30434782608695654}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n\n@interface WorthAroundVerModel : NSObject\n\n@property (nonatomic, strong) NSString * ProductImgWX;//\u56fe\u7247\n@property (nonatomic, strong) NSString *Name;\n@property (nonatomic, strong) NSNumber *NewPrice;\n@property (nonatomic, strong) NSNumber *OldPrice;\n@property (nonatomic, strong) NSNumber *Discount;\n@property (nonatomic, assign) NSInteger SaleTotal;\n@property (nonatomic, assign) BOOL IsBaoYou;\n@property (nonatomic, strong) NSString *ProductUrl;\n\n@end\n\n", "comment_ratio": 0.34782608695652173}
{"lang": "c", "code": "#include \"can.h\"\n#include \"bsp_can.h\"\n#include \"cmsis_os.h\"\n\n\n//moto_measure_t moto_pit;\n//moto_measure_t moto_yaw;\n//moto_measure_t moto_poke;\t//\u62e8\u5355\u7535\u673a\nmoto_measure_t moto_chassis[8] = {0};\nmoto_measure_t moto_info;\n\n\nvoid get_total_angle(moto_measure_t *p);\nvoid get_moto_offset(moto_measure_t *ptr, CAN_HandleTypeDef* hcan);\n\n/*******************************************************************************************\n  * @Func\t\tmy_can_filter_init\n  * @Brief    CAN1\u548cCAN2\u6ee4\u6ce2\u5668\u914d\u7f6e\n  * @Param\t\tCAN_HandleTypeDef* hcan\n  * @Retval\t\tNone\n  * @Date     2015/11/30\n *******************************************************************************************/\nvoid my_can_filter_init_recv_all(CAN_HandleTypeDef* _hcan)\n{\n    //can1 &can2 use same filter config\n    CAN_FilterConfTypeDef\t\tCAN_FilterConfigStructure;\n    static CanTxMsgTypeDef\t\tTx1Message;\n    static CanRxMsgTypeDef \t\tRx1Message;\n    static CanTxMsgTypeDef\t\tTx2Message;\n    static CanRxMsgTypeDef \t\tRx2Message;\n\n    CAN_FilterConfigStructure.FilterNumber = 0;\n    CAN_FilterConfigStructure.FilterMode = CAN_FILTERMODE_IDMASK;\n    CAN_FilterConfigStructure.FilterScale = CAN_FILTERSCALE_32BIT;\n    CAN_FilterConfigStructure.FilterIdHigh = 0x0000;\n    CAN_FilterConfigStructure.FilterIdLow = 0x0000;\n    CAN_FilterConfigStructure.FilterMaskIdHigh = 0x0000;\n    CAN_FilterConfigStructure.FilterMaskIdLow = 0x0000;\n    CAN_FilterConfigStructure.FilterFIFOAssignment = CAN_FilterFIFO0;\n    CAN_FilterConfigStructure.BankNumber = 14;//can1(0-13)\u548ccan2(14-27)\u5206\u522b\u5f97\u5230\u4e00\u534a\u7684filter\n    CAN_FilterConfigStructure.FilterActivation = ENABLE;\n\n    if(HAL_CAN_ConfigFilter(_hcan, &CAN_FilterConfigStructure) != HAL_OK)\n    {\n        //err_deadloop(); //show error!\n    }\n\n    //filter config for can2\n    //can1(0-13)\u548ccan2(14-27)\u5206\u522b\u5f97\u5230\u4e00\u534a\u7684filter\n    CAN_FilterConfigStructure.FilterNumber = 14;\n    if(HAL_CAN_ConfigFilter(_hcan, &CAN_FilterConfigStructure) != HAL_OK)\n    {\n        //err_deadloop();\n    }\n\n    if(_hcan == &hcan1) {\n        _hcan->pTxMsg = &Tx1Message;\n        _hcan->pRxMsg = &Rx1Message;\n    }\n\n    if(_hcan == &hcan2) {\n        _hcan->pTxMsg = &Tx2Message;\n        _hcan->pRxMsg = &Rx2Message;\n    }\n\n}\n\n/*******************************************************************************************\n  * @Func\t\t\tvoid can_filter_recv_special(CAN_HandleTypeDef* _hcan, s16 id)\n  * @Brief    \u5f85\u6d4b\u8bd5\uff01\uff01\uff01\n  * @Param\t\t\u53ea\u63a5\u6536filtered id\uff0c\u5176\u4ed6\u7684\u5168\u5c4f\u853d\u3002\n  * @Retval\t\teg\uff1a \tCAN1_FilterConfiguration(0, HOST_CONTROL_ID);\n\t\t\t\t\t\t\t\t\t\tCAN1_FilterConfiguration(1, SET_CURRENT_ID);\n\t\t\t\t\t\t\t\t\t\tCAN1_FilterConfiguration(2, SET_VOLTAGE_ID);\n\t\t\t\t\t\t\t\t\t\tCAN1_FilterConfiguration(3, ESC_CAN_DEVICE_ID);\n\t\t\t\t\t\t\t\t\t\tCAN1_FilterConfiguration(4, SET_POWER_ID);\n\t\t\t\t\t\t\t\t\t\tCAN1_FilterConfiguration(5, SET_LIMIT_RECOVER_ID);\n  * @Date     2016\u5e7411\u670811\u65e5\n *******************************************************************************************/\nvoid can_filter_recv_special(CAN_HandleTypeDef* hcan, uint8_t filter_number, uint16_t filtered_id)\n{\n    CAN_FilterConfTypeDef   cf;\n    cf.FilterNumber = filter_number;\t//\u8fc7\u6ee4\u5668\u7ec4\u7f16\u53f7\n    cf.FilterMode = CAN_FILTERMODE_IDMASK;\t//id\u5c4f\u853d\u6a21\u5f0f\n    cf.FilterScale = CAN_FILTERSCALE_32BIT;\t//32bit \u6ee4\u6ce2\n    cf.FilterIdHigh = (filtered_id<<21) >> 16;\t//high 16 bit\t\t\u5176\u5b9e\u8fd9\u4e24\u4e2a\u7ed3\u6784\u4f53\u6210\u5458\u53d8\u91cf\u662f16\u4f4d\u5bbd\n    cf.FilterIdLow = filtered_id<<21;\t//low 16bit\n    cf.FilterMaskIdHigh = 0xFFFF;\n    cf.FilterMaskIdLow = 0xFFF8;\t//IDE[2], RTR[1] TXRQ[0] \u4f4e\u4e09\u4f4d\u4e0d\u8003\u8651\u3002\n    cf.FilterFIFOAssignment = CAN_FilterFIFO0;\n    cf.BankNumber = 14;\t//can1(0-13)\u548ccan2(14-27)\u5206\u522b\u5f97\u5230\u4e00\u534a\u7684filter\n    cf.FilterActivation = ENABLE;\n    HAL_CAN_ConfigFilter(hcan, &cf);\n}\n\n\nHAL_StatusTypeDef can_send_msg()\n{\n//\tif(_hcan->Instance->ESR){\n//\t\t//can error occured, sleep can and reset!\n//\t\t_hcan->Instance->MCR |= 0x02;\n//\t\t_hcan->Instance->MCR &= ~(0x02);\n//\t}//\u8fd9\u4e2a\u662fzw\u8bd5\u8fc7\u7684\u53ef\u4ee5\u89e3\u51b3can\u9519\u8bef  \u6709\u5f85\u9a8c\u8bc1\uff01\n    return HAL_OK;\n}\n\nfloat ZGyroModuleAngle;\n/*******************************************************************************************\n  * @Func\t\t\tvoid HAL_CAN_RxCpltCallback(CAN_HandleTypeDef* _hcan)\n  * @Brief    \u8fd9\u662f\u4e00\u4e2a\u56de\u8c03\u51fd\u6570,\u90fd\u4e0d\u7528\u58f0\u660e\n  * @Param\n  * @Retval\t\tNone\n  * @Date     2015/11/24\n *******************************************************************************************/\nvoid HAL_CAN_RxCpltCallback(CAN_HandleTypeDef* _hcan)\n{\n    //ignore can1 or can2.\n    switch(_hcan->pRxMsg->StdId) {\n    case CAN_3508Moto1_ID:\n    case CAN_3508Moto2_ID:\n    case CAN_3508Moto3_ID:\n    case CAN_3508Moto4_ID:\n    case CAN_3508Moto5_ID:\n    case CAN_3508Moto6_ID:\n    case CAN_3508Moto7_ID:\n    case CAN_3508Moto8_ID:\n    {\n        static u8 i;\n        i = _hcan->pRxMsg->StdId - CAN_3508Moto1_ID;\n\n        moto_chassis[i].msg_cnt++ <= 50\t?\tget_moto_offset(&moto_chassis[i], _hcan) : get_moto_measure(&moto_chassis[i], _hcan);\n        get_moto_measure(&moto_info, _hcan);\n        //get_moto_measure(&moto_chassis[i], _hcan);\n    }\n    break;\n\n\n    }\n\n\n    //hcan1.Instance->IER|=0x00008F02;\n    /*#### add enable can it again to solve can receive only one ID problem!!!####**/\n    __HAL_CAN_ENABLE_IT(&hcan1, CAN_IT_FMP0);\n    __HAL_CAN_ENABLE_IT(&hcan2, CAN_IT_FMP0);\n    /*#### add enable can it again to solve can receive only one ID problem!!!####**/\n}\n\n/*******************************************************************************************\n  * @Func\t\t\tvoid get_moto_measure(moto_measure_t *ptr, CAN_HandleTypeDef* hcan)\n  * @Brief    \u63a5\u6536\u4e91\u53f0\u7535\u673a,3510\u7535\u673a\u901a\u8fc7CAN\u53d1\u8fc7\u6765\u7684\u4fe1\u606f\n  * @Param\n  * @Retval\t\tNone\n  * @Date     2015/11/24\n *******************************************************************************************/\nvoid get_moto_measure(moto_measure_t *ptr, CAN_HandleTypeDef* hcan)\n{\n//\tu32  sum=0;\n//\tu8\t i = FILTER_BUF_LEN;\n\n    /*BUG!!! dont use this para code*/\n//\tptr->angle_buf[ptr->buf_idx] = (uint16_t)(hcan->pRxMsg->Data[0]<<8 | hcan->pRxMsg->Data[1]) ;\n//\tptr->buf_idx = ptr->buf_idx++ > FILTER_BUF_LEN ? 0 : ptr->buf_idx;\n//\twhile(i){\n//\t\tsum += ptr->angle_buf[--i];\n//\t}\n//\tptr->fited_angle = sum / FILTER_BUF_LEN;\n    ptr->last_angle = ptr->angle;\n    ptr->angle = (uint16_t)(hcan->pRxMsg->Data[0]<<8 | hcan->pRxMsg->Data[1]) ;\n    ptr->speed_rpm = (int16_t)(hcan->pRxMsg->Data[2]<<8 | hcan->pRxMsg->Data[3]);\n\n    //ptr->real_current  = (int16_t)(hcan->pRxMsg->Data[2]<<8 | hcan->pRxMsg->Data[3]);\n    //ptr->speed_rpm = ptr->real_current;\t//\u8fd9\u91cc\u662f\u56e0\u4e3a\u4e24\u79cd\u7535\u8c03\u5bf9\u5e94\u4f4d\u4e0d\u4e00\u6837\u7684\u4fe1\u606f\n    //ptr->given_current = (int16_t)(hcan->pRxMsg->Data[4]<<8 | hcan->pRxMsg->Data[5]);///-5;\n    //ptr->given_current = (int16_t)(hcan->pRxMsg->Data[4]<<8 | hcan->pRxMsg->Data[5]) ;//\u83b7\u53d6\u7535\u6d41(mm/s) / 819.2\n\n    ptr->real_current = ((int16_t)(hcan->pRxMsg->Data[4]<<8 | hcan->pRxMsg->Data[5])) / 819.2;//\u83b7\u53d6\u7535\u6d41(mm/s) / 819.2\n    //(ptr)->given_current = (uint16_t)((rx_message)->Data[4] << 8 | (rx_message)->Data[5]);\n    //ptr->given_current = (hcan->pRxMsg->Data[4]<<8 | hcan->pRxMsg->Data[5])*5.f/16384.f;//\u83b7\u5f97\u8f6c\u77e9\n    ptr->hall = hcan->pRxMsg->Data[6];\n    if(ptr->angle - ptr->last_angle > 4096)\n        ptr->round_cnt --;\n    else if (ptr->angle - ptr->last_angle < -4096)\n        ptr->round_cnt ++;\n    ptr->total_angle = ptr->round_cnt * 8192 + ptr->angle - ptr->offset_angle;\n}\n\n/*this function should be called after system+can init */\nvoid get_moto_offset(moto_measure_t *ptr, CAN_HandleTypeDef* hcan)\n{\n    ptr->angle = (uint16_t)(hcan->pRxMsg->Data[0]<<8 | hcan->pRxMsg->Data[1]) ;\n    ptr->offset_angle = ptr->angle;\n}\n\n#define ABS(x)\t( (x>0) ? (x) : (-x) )\n/**\n*@bref \u7535\u673a\u4e0a\u7535\u89d2\u5ea6=0\uff0c \u4e4b\u540e\u7528\u8fd9\u4e2a\u51fd\u6570\u66f4\u65b03510\u7535\u673a\u7684\u76f8\u5bf9\u5f00\u673a\u540e\uff08\u4e3a0\uff09\u7684\u76f8\u5bf9\u89d2\u5ea6\u3002\n\t*/\nvoid get_total_angle(moto_measure_t *p) {\n\n    int res1, res2, delta;\n    if(p->angle < p->last_angle) {\t\t\t//\u53ef\u80fd\u7684\u60c5\u51b5\n        res1 = p->angle + 8192 - p->last_angle;\t//\u6b63\u8f6c\uff0cdelta=+\n        res2 = p->angle - p->last_angle;\t\t\t\t//\u53cd\u8f6c\tdelta=-\n    } else {\t//angle > last\n        res1 = p->angle - 8192 - p->last_angle ;//\u53cd\u8f6c\tdelta -\n        res2 = p->angle - p->last_angle;\t\t\t\t//\u6b63\u8f6c\tdelta +\n    }\n    //\u4e0d\u7ba1\u6b63\u53cd\u8f6c\uff0c\u80af\u5b9a\u662f\u8f6c\u7684\u89d2\u5ea6\u5c0f\u7684\u90a3\u4e2a\u662f\u771f\u7684\n    if(ABS(res1)<ABS(res2))\n        delta = res1;\n    else\n        delta = res2;\n\n    p->total_angle += delta;\n    p->last_angle = p->angle;\n}\n\n//void set_moto_current(CAN_HandleTypeDef* hcan, s16 iq1, s16 iq2, s16 iq3, s16 iq4){\n\n//\thcan->pTxMsg->StdId = 0x200;\n//\thcan->pTxMsg->IDE = CAN_ID_STD;\n//\thcan->pTxMsg->RTR = CAN_RTR_DATA;\n//\thcan->pTxMsg->DLC = 0x08;\n//\thcan->pTxMsg->Data[0] = iq1 >> 8;\n//\thcan->pTxMsg->Data[1] = iq1;\n//\thcan->pTxMsg->Data[2] = iq2 >> 8;\n//\thcan->pTxMsg->Data[3] = iq2;\n//\thcan->pTxMsg->Data[4] = iq3 >> 8;\n//\thcan->pTxMsg->Data[5] = iq3;\n//\thcan->pTxMsg->Data[6] = iq4 >> 8;\n//\thcan->pTxMsg->Data[7] = iq4;\n//\n//\tHAL_CAN_Transmit(hcan, 1000);\n//}\n\n", "comment_ratio": 0.3178294573643411}
{"lang": "c", "code": "#ifndef CHROME_BROWSER_UI_VIEWS_EXTENSIONS_EXTENSION_ACTION_TEST_HELPER_VIEWS_H_\n#define CHROME_BROWSER_UI_VIEWS_EXTENSIONS_EXTENSION_ACTION_TEST_HELPER_VIEWS_H_\n\n#include <memory>\n\n#include \"chrome/browser/ui/extensions/extension_action_test_helper.h\"\n\nclass BrowserActionsContainer;\n\nclass ExtensionActionTestHelperViews : public ExtensionActionTestHelper {\n public:\n  ExtensionActionTestHelperViews(const ExtensionActionTestHelperViews&) =\n      delete;\n  ExtensionActionTestHelperViews& operator=(\n      const ExtensionActionTestHelperViews&) = delete;\n  ~ExtensionActionTestHelperViews() override;\n\n  // ExtensionActionTestHelper:\n  int NumberOfBrowserActions() override;\n  int VisibleBrowserActions() override;\n  void InspectPopup(int index) override;\n  bool HasIcon(int index) override;\n  gfx::Image GetIcon(int index) override;\n  void Press(int index) override;\n  std::string GetExtensionId(int index) override;\n  std::string GetTooltip(int index) override;\n  gfx::NativeView GetPopupNativeView() override;\n  bool HasPopup() override;\n  bool HidePopup() override;\n  void SetWidth(int width) override;\n  ToolbarActionsBar* GetToolbarActionsBar() override;\n  ExtensionsContainer* GetExtensionsContainer() override;\n  void WaitForExtensionsContainerLayout() override;\n  std::unique_ptr<ExtensionActionTestHelper> CreateOverflowBar(\n      Browser* browser) override;\n  void LayoutForOverflowBar() override;\n  gfx::Size GetMinPopupSize() override;\n  gfx::Size GetMaxPopupSize() override;\n  gfx::Size GetToolbarActionSize() override;\n  gfx::Size GetMaxAvailableSizeToFitBubbleOnScreen(int action_index) override;\n\n private:\n  friend class ExtensionActionTestHelper;\n\n  class TestToolbarActionsBarHelper;\n\n  // Constructs a version of ExtensionActionTestHelperViews that does not own\n  // the BrowserActionsContainer it tests.\n  explicit ExtensionActionTestHelperViews(\n      BrowserActionsContainer* browser_actions_container);\n  // Constructs a version of ExtensionActionTestHelperViews given a\n  // |test_helper| responsible for owning the BrowserActionsContainer.\n  explicit ExtensionActionTestHelperViews(\n      std::unique_ptr<TestToolbarActionsBarHelper> test_helper);\n\n  std::unique_ptr<TestToolbarActionsBarHelper> test_helper_;\n\n  // The associated BrowserActionsContainer. Not owned.\n  BrowserActionsContainer* const browser_actions_container_;\n};\n\n#endif  // CHROME_BROWSER_UI_VIEWS_EXTENSIONS_EXTENSION_ACTION_TEST_HELPER_VIEWS_H_\n\n", "comment_ratio": 0.14925373134328357}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n#import \"JGTextView.h\"\n\n@class JGBusOppFirstViewCell;\n@protocol JGBusOppFirstViewDelegate <NSObject>\n\n@optional\n- (void)JGBusOppFirstViewTextViewDidChange:(NSString *)Str andTableViewCell:(JGBusOppFirstViewCell *)cell;\n@end\n\n@interface JGBusOppFirstViewCell : UITableViewCell\n\n@property (weak, nonatomic) IBOutlet UILabel *titleLbl;\n\n@property (weak, nonatomic) IBOutlet JGTextView *contentTextV;\n\n/** \u4ee3\u7406 */\n@property (nonatomic, weak) id <JGBusOppFirstViewDelegate>JGBusOppFirstViewDelegate;\n@end\n\n", "comment_ratio": 0.25}
{"lang": "c", "code": "#import <FrontBoard/FrontBoard-Structs.h>\n#import <libobjc.A.dylib/NSCopying.h>\n#import <libobjc.A.dylib/NSMutableCopying.h>\n\n@protocol FBProcessWatchdogProviding;\n@class RBSProcessIdentity, NSArray, NSDictionary, NSURL;\n\n@interface FBProcessExecutionContext : NSObject <NSCopying, NSMutableCopying> {\n\n\tRBSProcessIdentity* _identity;\n\tNSArray* _arguments;\n\tNSDictionary* _environment;\n\tNSURL* _standardOutputURL;\n\tNSURL* _standardErrorURL;\n\tBOOL _waitForDebugger;\n\tBOOL _disableASLR;\n\tBOOL _checkForLeaks;\n\tlong long _launchIntent;\n\tunsigned _launchAssertionFlags;\n\tid<FBProcessWatchdogProviding> _watchdogProvider;\n\tdouble _watchdogExtension;\n\n}\n\n@property (nonatomic,copy) NSArray * arguments;                                            //@synthesize arguments=_arguments - In the implementation block\n@property (nonatomic,copy) NSDictionary * environment;                                     //@synthesize environment=_environment - In the implementation block\n@property (nonatomic,retain) NSURL * standardOutputURL;                                    //@synthesize standardOutputURL=_standardOutputURL - In the implementation block\n@property (nonatomic,retain) NSURL * standardErrorURL;                                     //@synthesize standardErrorURL=_standardErrorURL - In the implementation block\n@property (assign,nonatomic) BOOL waitForDebugger;                                         //@synthesize waitForDebugger=_waitForDebugger - In the implementation block\n@property (assign,nonatomic) BOOL disableASLR;                                             //@synthesize disableASLR=_disableASLR - In the implementation block\n@property (assign,nonatomic) BOOL checkForLeaks;                                           //@synthesize checkForLeaks=_checkForLeaks - In the implementation block\n@property (assign,nonatomic) long long launchIntent;                                       //@synthesize launchIntent=_launchIntent - In the implementation block\n@property (assign,nonatomic) unsigned launchAssertionFlags;                                //@synthesize launchAssertionFlags=_launchAssertionFlags - In the implementation block\n@property (nonatomic,retain) id<FBProcessWatchdogProviding> watchdogProvider;              //@synthesize watchdogProvider=_watchdogProvider - In the implementation block\n@property (assign,nonatomic) double watchdogExtension;                                     //@synthesize watchdogExtension=_watchdogExtension - In the implementation block\n@property (nonatomic,copy) RBSProcessIdentity * identity;                                  //@synthesize identity=_identity - In the implementation block\n-(id)copyWithZone:(NSZone*)arg1 ;\n-(id)mutableCopyWithZone:(NSZone*)arg1 ;\n-(RBSProcessIdentity *)identity;\n-(NSArray *)arguments;\n-(NSDictionary *)environment;\n-(void)setArguments:(NSArray *)arg1 ;\n-(void)setEnvironment:(NSDictionary *)arg1 ;\n-(id)initWithIdentity:(id)arg1 ;\n-(void)setIdentity:(RBSProcessIdentity *)arg1 ;\n-(id)_initWithExecutionContext:(id)arg1 ;\n-(NSURL *)standardOutputURL;\n-(NSURL *)standardErrorURL;\n-(BOOL)waitForDebugger;\n-(BOOL)disableASLR;\n-(BOOL)checkForLeaks;\n-(long long)launchIntent;\n-(unsigned)launchAssertionFlags;\n-(id<FBProcessWatchdogProviding>)watchdogProvider;\n-(double)watchdogExtension;\n-(unsigned)_launchAssertionFlags;\n-(void)setStandardOutputURL:(NSURL *)arg1 ;\n-(void)setStandardErrorURL:(NSURL *)arg1 ;\n-(void)setWaitForDebugger:(BOOL)arg1 ;\n-(void)setDisableASLR:(BOOL)arg1 ;\n-(void)setCheckForLeaks:(BOOL)arg1 ;\n-(void)setLaunchIntent:(long long)arg1 ;\n-(void)setLaunchAssertionFlags:(unsigned)arg1 ;\n-(void)setWatchdogProvider:(id<FBProcessWatchdogProviding>)arg1 ;\n-(void)setWatchdogExtension:(double)arg1 ;\n@end\n\n\n", "comment_ratio": 0.15789473684210525}
{"lang": "c", "code": "#ifndef CONTENT_RENDERER_MEDIA_ANDROID_FLINGING_RENDERER_CLIENT_FACTORY_H_\n#define CONTENT_RENDERER_MEDIA_ANDROID_FLINGING_RENDERER_CLIENT_FACTORY_H_\n\n#include <memory>\n#include <string>\n\n#include \"content/common/content_export.h\"\n#include \"media/base/media_status.h\"\n#include \"media/base/renderer_factory.h\"\n#include \"media/renderers/remote_playback_client_wrapper.h\"\n\nnamespace media {\nclass MojoRendererFactory;\n}\n\nnamespace content {\n\n// Creates a renderer for media flinging.\n// The FRCF uses a MojoRendererFactory to create a FlingingRenderer in the\n// browser process.\nclass CONTENT_EXPORT FlingingRendererClientFactory\n    : public media::RendererFactory {\n public:\n  FlingingRendererClientFactory(\n      std::unique_ptr<media::MojoRendererFactory> mojo_renderer_factory,\n      std::unique_ptr<media::RemotePlaybackClientWrapper>\n          remote_playback_client);\n\n  FlingingRendererClientFactory(const FlingingRendererClientFactory&) = delete;\n  FlingingRendererClientFactory& operator=(\n      const FlingingRendererClientFactory&) = delete;\n\n  ~FlingingRendererClientFactory() override;\n\n  // Sets a callback that renderers created by |this| will use to propagate\n  // Play/Pause state changes on remote devices.\n  // NOTE: This must be called before CreateRenderer().\n  void SetRemotePlayStateChangeCB(media::RemotePlayStateChangeCB callback);\n\n  std::unique_ptr<media::Renderer> CreateRenderer(\n      const scoped_refptr<base::SingleThreadTaskRunner>& media_task_runner,\n      const scoped_refptr<base::TaskRunner>& worker_task_runner,\n      media::AudioRendererSink* audio_renderer_sink,\n      media::VideoRendererSink* video_renderer_sink,\n      media::RequestOverlayInfoCB request_overlay_info_cb,\n      const gfx::ColorSpace& target_color_space) override;\n\n  // Returns whether media flinging has started, based off of whether the\n  // |remote_playback_client_| has a presentation ID or not. Called by\n  // RendererFactorySelector to determine when to create a FlingingRenderer.\n  bool IsFlingingActive();\n\n private:\n  std::string GetActivePresentationId();\n\n  std::unique_ptr<media::MojoRendererFactory> mojo_flinging_factory_;\n  std::unique_ptr<media::RemotePlaybackClientWrapper> remote_playback_client_;\n\n  media::RemotePlayStateChangeCB remote_play_state_change_cb_;\n};\n\n}  // namespace content\n\n#endif  // CONTENT_RENDERER_MEDIA_ANDROID_FLINGING_RENDERER_CLIENT_FACTORY_H_\n\n", "comment_ratio": 0.2028985507246377}
{"lang": "c", "code": "//\n//  ABI41_0_0AIRGoogleMapMarker.h\n//  AirMaps\n//\n//  Created by Gil Birman on 9/2/16.\n//\n\n#ifdef ABI41_0_0HAVE_GOOGLE_MAPS\n\n#import <GoogleMaps/GoogleMaps.h>\n#import <ABI41_0_0React/ABI41_0_0RCTBridge.h>\n#import \"ABI41_0_0AIRGMSMarker.h\"\n#import \"ABI41_0_0AIRGoogleMap.h\"\n#import \"ABI41_0_0AIRGoogleMapCallout.h\"\n#import \"ABI41_0_0AIRGoogleMapCalloutSubview.h\"\n\n@interface ABI41_0_0AIRGoogleMapMarker : UIView\n\n@property (nonatomic, weak) ABI41_0_0RCTBridge *bridge;\n@property (nonatomic, strong) ABI41_0_0AIRGoogleMapCallout *calloutView;\n@property (nonatomic, strong) NSString *identifier;\n@property (nonatomic, assign) CLLocationCoordinate2D coordinate;\n@property (nonatomic, assign) CLLocationDegrees rotation;\n@property (nonatomic, strong) ABI41_0_0AIRGMSMarker* realMarker;\n@property (nonatomic, copy) ABI41_0_0RCTBubblingEventBlock onPress;\n@property (nonatomic, copy) ABI41_0_0RCTDirectEventBlock onDragStart;\n@property (nonatomic, copy) ABI41_0_0RCTDirectEventBlock onDrag;\n@property (nonatomic, copy) ABI41_0_0RCTDirectEventBlock onDragEnd;\n@property (nonatomic, copy) NSString *imageSrc;\n@property (nonatomic, copy) NSString *iconSrc;\n@property (nonatomic, copy) NSString *title;\n@property (nonatomic, copy) NSString *subtitle;\n@property (nonatomic, strong) UIColor *pinColor;\n@property (nonatomic, assign) CGPoint anchor;\n@property (nonatomic, assign) CGPoint calloutAnchor;\n@property (nonatomic, assign) NSInteger zIndex;\n@property (nonatomic, assign) double opacity;\n@property (nonatomic, assign) BOOL draggable;\n@property (nonatomic, assign) BOOL tracksViewChanges;\n@property (nonatomic, assign) BOOL tracksInfoWindowChanges;\n\n- (void)showCalloutView;\n- (void)hideCalloutView;\n- (void)redraw;\n- (UIView *)markerInfoContents;\n- (UIView *)markerInfoWindow;\n- (void)didTapInfoWindowOfMarker:(ABI41_0_0AIRGMSMarker *)marker;\n- (void)didTapInfoWindowOfMarker:(ABI41_0_0AIRGMSMarker *)marker point:(CGPoint)point frame:(CGRect)frame;\n- (void)didTapInfoWindowOfMarker:(ABI41_0_0AIRGMSMarker *)marker subview:(ABI41_0_0AIRGoogleMapCalloutSubview*)subview point:(CGPoint)point frame:(CGRect)frame;\n- (void)didBeginDraggingMarker:(ABI41_0_0AIRGMSMarker *)marker;\n- (void)didEndDraggingMarker:(ABI41_0_0AIRGMSMarker *)marker;\n- (void)didDragMarker:(ABI41_0_0AIRGMSMarker *)marker;\n@end\n\n#endif\n\n", "comment_ratio": 0.10714285714285714}
{"lang": "c", "code": "//\n// Created by Yunzhe on 2017/12/4.\n//\n\n#ifndef GPUBASEDRENDERING_A3_SYSTEM_H\n#define GPUBASEDRENDERING_A3_SYSTEM_H\n\n// Include related head files\n#include \"global.h\"\n#include \"utility.h\"\n#include \"draw.h\"\n\n// Using namespace std for cout\nusing namespace std;\n\nvoid Idle();\n\nvoid Redraw();\n\nvoid Reshape(int width, int height);\n\nvoid ProcessMouseClick(int button, int state, int x, int y);\n\nvoid ProcessMouseMove(int x, int y);\n\nvoid ProcessFocus(int state);\n\nvoid ProcessNormalKey(unsigned char k, int x, int y);\n\nvoid PrintStatus();\n\nvoid initVBO();\n\nvoid setShader();\n\nvoid updateMVP();\n\nvoid updateShader();\n\nvoid initShader();\n\n#endif //GPUBASEDRENDERING_A3_SYSTEM_H\n\n", "comment_ratio": 0.13953488372093023}
{"lang": "c", "code": "#import \"UIButton.h\"\n\n#import \"CAAnimationDelegate.h\"\n\n@class NSString;\n\n@interface SpriteBox : UIButton <CAAnimationDelegate>\n{\n}\n\n- (id)hitTest:(struct CGPoint)arg1 withEvent:(id)arg2;\n- (void)startAnimating:(id)arg1;\n- (void)stopAnimating;\n\n// Remaining properties\n@property(readonly, copy) NSString *debugDescription;\n@property(readonly, copy) NSString *description;\n@property(readonly) unsigned long long hash;\n@property(readonly) Class superclass;\n\n@end\n\n\n", "comment_ratio": 0.20689655172413793}
{"lang": "c", "code": "#ifndef LayerPainterChromium_h\n#define LayerPainterChromium_h\n\nclass SkCanvas;\n\nnamespace gfx {\nclass Rect;\nclass RectF;\n}\n\nnamespace cc {\n\nclass LayerPainter {\npublic:\n    virtual ~LayerPainter() { }\n    virtual void paint(SkCanvas*, const gfx::Rect& contentRect, gfx::RectF& opaque) = 0;\n};\n\n} // namespace cc\n#endif // LayerPainterChromium_h\n\n", "comment_ratio": 0.19230769230769232}
{"lang": "c", "code": "#ifndef MAME_MACHINE_GAYLE_H\n#define MAME_MACHINE_GAYLE_H\n\n#pragma once\n\n\n\n//**************************************************************************\n//  INTERFACE CONFIGURATION MACROS\n//**************************************************************************\n\n#define MCFG_GAYLE_ADD(_tag, _clock, _id) \\\n\tMCFG_DEVICE_ADD(_tag, GAYLE, _clock) \\\n\tdowncast<gayle_device &>(*device).set_id(_id);\n\n#define MCFG_GAYLE_INT2_HANDLER(_devcb) \\\n\tdevcb = &downcast<gayle_device &>(*device).set_int2_handler(DEVCB_##_devcb);\n\n#define MCFG_GAYLE_CS0_READ_HANDLER(_devcb) \\\n\tdevcb = &downcast<gayle_device &>(*device).set_cs0_read_handler(DEVCB_##_devcb);\n\n#define MCFG_GAYLE_CS0_WRITE_HANDLER(_devcb) \\\n\tdevcb = &downcast<gayle_device &>(*device).set_cs0_write_handler(DEVCB_##_devcb);\n\n#define MCFG_GAYLE_CS1_READ_HANDLER(_devcb) \\\n\tdevcb = &downcast<gayle_device &>(*device).set_cs1_read_handler(DEVCB_##_devcb);\n\n#define MCFG_GAYLE_CS1_WRITE_HANDLER(_devcb) \\\n\tdevcb = &downcast<gayle_device &>(*device).set_cs1_write_handler(DEVCB_##_devcb);\n\n\n//**************************************************************************\n//  TYPE DEFINITIONS\n//**************************************************************************\n\n// ======================> gayle_device\n\nclass gayle_device : public device_t\n{\npublic:\n\t// construction/destruction\n\tgayle_device(const machine_config &mconfig, const char *tag, device_t *owner, uint32_t clock);\n\n\t// callbacks\n\ttemplate <class Object> devcb_base &set_int2_handler(Object &&cb) { return m_int2_w.set_callback(std::forward<Object>(cb)); }\n\ttemplate <class Object> devcb_base &set_cs0_read_handler(Object &&cb) { return m_cs0_read.set_callback(std::forward<Object>(cb)); }\n\ttemplate <class Object> devcb_base &set_cs0_write_handler(Object &&cb) { return m_cs0_write.set_callback(std::forward<Object>(cb)); }\n\ttemplate <class Object> devcb_base &set_cs1_read_handler(Object &&cb) { return m_cs1_read.set_callback(std::forward<Object>(cb)); }\n\ttemplate <class Object> devcb_base &set_cs1_write_handler(Object &&cb) { return m_cs1_write.set_callback(std::forward<Object>(cb)); }\n\n\t// interface\n\tDECLARE_WRITE_LINE_MEMBER( ide_interrupt_w );\n\n\tDECLARE_READ16_MEMBER( gayle_r );\n\tDECLARE_WRITE16_MEMBER( gayle_w );\n\tDECLARE_READ16_MEMBER( gayle_id_r );\n\tDECLARE_WRITE16_MEMBER( gayle_id_w );\n\n\t// inline configuration\n\tvoid set_id(uint8_t id) { m_gayle_id = id; }\n\nprotected:\n\tvirtual void device_start() override;\n\tvirtual void device_reset() override;\n\nprivate:\n\tenum\n\t{\n\t\tGAYLE_CS = 0,   // interrupt status\n\t\tGAYLE_IRQ,      // interrupt change\n\t\tGAYLE_INTEN,    // interrupt enable register\n\t\tGAYLE_CFG       // config register\n\t};\n\n\tdevcb_write_line m_int2_w;\n\n\tdevcb_read16 m_cs0_read;\n\tdevcb_write16 m_cs0_write;\n\tdevcb_read16 m_cs1_read;\n\tdevcb_write16 m_cs1_write;\n\n\tuint8_t m_gayle_id;\n\tint m_gayle_id_count;\n\tuint8_t m_gayle_reg[4];\n};\n\n// device type definition\nDECLARE_DEVICE_TYPE(GAYLE, gayle_device)\n\n#endif // MAME_MACHINE_GAYLE_H\n\n", "comment_ratio": 0.18811881188118812}
{"lang": "c", "code": "#import \"WloginTlv.h\"\n\n@class NSData;\n\n@interface WloginTlv_Buff : WloginTlv\n{\n    NSData *acSigBuff;\n}\n\n@property(retain) NSData *acSigBuff; // @synthesize acSigBuff;\n- (id)copy;\n- (void)dealloc;\n- (int)encode:(id)arg1;\n- (int)decode:(char **)arg1 andBuffLen:(int *)arg2;\n\n@end\n\n\n", "comment_ratio": 0.25}
{"lang": "c", "code": "#include \"sys/unistd.h\"\n#include \"string.h\"\n#include \"limits.h\"\n#include \"stdio.h\"\n\n#if 0\n#include \"vfs.h\"\n\nint rmdir(const char *path)\n{\n    char absolute_path[PATH_MAX];\n\n    get_absolute_normalized_path(path, absolute_path);\n\n    int32_t mp_id = get_mountpoint_id(absolute_path);\n    if (mp_id < 0) {\n        printf(\"rmdir: failed to remove '%s':\"\n               \"Cannot find mount-point\\n\",\n               path);\n\n        return -1;\n    }\n\n    if (mountpoint_list[mp_id].dir_op.rmdir_f == NULL) {\n        return -1;\n    }\n\n    return mountpoint_list[mp_id].dir_op.rmdir_f(absolute_path);\n}\n\n#endif\n", "comment_ratio": 0.13513513513513514}
{"lang": "c", "code": "#pragma once\n\n// @generated by tools/codegen/gen.py from NativeFunction.h\n\n#include <c10/core/Scalar.h>\n#include <c10/core/Storage.h>\n#include <c10/core/TensorOptions.h>\n#include <c10/util/Deprecated.h>\n#include <c10/util/Optional.h>\n#include <c10/core/QScheme.h>\n#include <ATen/core/Reduction.h>\n#include <ATen/core/Tensor.h>\n#include <tuple>\n#include <vector>\n#include <ATen/ops/upsample_nearest1d_backward_meta.h>\n\nnamespace at {\nnamespace native {\n\nTORCH_API at::Tensor upsample_nearest1d_backward(const at::Tensor & grad_output, c10::optional<at::IntArrayRef> output_size, at::IntArrayRef input_size, c10::optional<at::ArrayRef<double>> scale_factors);\nstruct TORCH_API structured_upsample_nearest1d_backward_out_cpu : public at::meta::structured_upsample_nearest1d_backward {\nvoid impl(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales, const at::Tensor & grad_input);\n};\nstruct TORCH_API structured_upsample_nearest1d_backward_out_cuda : public at::meta::structured_upsample_nearest1d_backward {\nvoid impl(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales, const at::Tensor & grad_input);\n};\n\n} // namespace native\n} // namespace at\n\n", "comment_ratio": 0.1}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface LHQSearchBar : UISearchBar\n\n//\u6e05\u9664\u6309\u94ae\u662f\u5426\u9690\u85cf\n@property(nonatomic,assign)BOOL clearBtnHidden;\n\n//placeHolder \u662f\u5426\u5c45\u4e2d iOS11\u4e4b\u524d\u9ed8\u8ba4\u662f\u5c45\u4e2d\u7684 iOS11\u4e4b\u540e\u5c45\u5de6\n@property(nonatomic,assign)BOOL placeHolderCenter;\n\n//placeHolder\u6587\u5b57\n@property(nonatomic,copy)NSString* placeHolderString;\n\n//placeHolder\u5b57\u53f7 \u9ed8\u8ba416 \u548c\u8f93\u5165\u6846\u6587\u5b57\u5b57\u53f7\u4e00\u6837\n@property(nonatomic,strong)UIFont* placeHolderStringFont;\n\n//placeHolder\u6587\u5b57\u989c\u8272\n@property(nonatomic,strong)UIColor* placeHolderStringColor;\n\n//\u53d6\u6d88\u6309\u94ae\u6587\u5b57  \u7cfb\u7edf\u9ed8\u8ba4cancel,\u8fd9\u91cc\u9ed8\u8ba4 \u53d6\u6d88\n@property(nonatomic,copy)NSString* cancelBtnTitle;\n\n//\u53d6\u6d88\u6309\u94ae\u6587\u5b57\u989c\u8272\n@property(nonatomic,strong)UIColor* cancelBtnTitleColor;\n\n//\u53d6\u6d88\u6309\u94ae\u6587\u5b57\u5927\u5c0f\n@property(nonatomic,strong)UIFont* cancelBtnTitleFont;\n\n//\u5706\u89d2\n@property(nonatomic,assign)CGFloat cornerRadius;\n\n//\u8fb9\u6846\u989c\u8272\n@property(nonatomic,strong)UIColor* borderColor;\n\n//\u8fb9\u6846\u5bbd\u5ea6\n@property(nonatomic,assign)CGFloat borderWidth;\n\n//\u8bb0\u5f55\u9ed8\u8ba4\u60c5\u51b5\u4e0b\u7684\u641c\u7d22\u56fe\u7247\u504f\u79fb\n@property(nonatomic,assign)UIOffset originPositionSearchOffSet;\n\n//\u7cfb\u7edfsearchbar\uff0c\u5982\u679csearch\u6ca1\u6709\u83b7\u5f97\u7126\u70b9\uff0c\u70b9\u51fb\u53d6\u6d88\u9ed8\u8ba4\u4f1a\u83b7\u5f97\u7126\u70b9\uff08\u800c\u4e0d\u4f1a\u54cd\u5e94\u53d6\u6d88\u4e8b\u4ef6\uff09\n//cancelInputDisabled yes \u76f4\u63a5\u54cd\u5e94\u53d6\u6d88\u4e8b\u4ef6\n@property(nonatomic,assign)BOOL cancelInputDisabled;\n\n@property (nonatomic, strong) UIColor *textFieldColor;\n\n@property (nonatomic, assign) CGFloat textFieldHeight;\n\n-(UITextField*)textField;\n\n@end\n\nNS_ASSUME_NONNULL_END\n\n", "comment_ratio": 0.328125}
{"lang": "c", "code": "#ifndef KEYBDIMM_H\n#define KEYBDIMM_H\n\n#define STRICT\n#include <windows.h>\n#include <dinput.h>\n#include \"resource.h\"\n\n\n//-----------------------------------------------------------------------------\n// External function-prototypes\n//-----------------------------------------------------------------------------\nextern HRESULT InitDirectInput( HWND hDlg );\nextern HRESULT SetAcquire( HWND hDlg );\nextern HRESULT FreeDirectInput();\nextern HRESULT UpdateInputState( HWND hDlg );\n\nextern BOOL    g_bActive;\t\t\n\n\n#endif // KEYBDIMM_H\n\n", "comment_ratio": 0.3793103448275862}
{"lang": "c", "code": "#pragma once\n\n#include <windowsmediaphoto.h>\n#ifndef WIN32\n#include <wmspecstring.h>\n#endif\n\n#ifndef UNREFERENCED_PARAMETER\n#define UNREFERENCED_PARAMETER(P) { (P) = (P); }\n#endif\n\n//================================================================\n// Container\n//================================================================\n\n// Keep these in sort order so that we can easily confirm we are outputting tags in ascending order\n#define WMP_tagNull 0\n\n#define WMP_tagDocumentName         0x010d  // Descriptive metadata tag\n#define WMP_tagImageDescription     0x010e  // Descriptive metadata tag\n#define WMP_tagCameraMake           0x010f  // Descriptive metadata tag\n#define WMP_tagCameraModel          0x0110  // Descriptive metadata tag\n#define WMP_tagPageName             0x011d  // Descriptive metadata tag\n#define WMP_tagPageNumber           0x0129  // Descriptive metadata tag\n#define WMP_tagSoftware             0x0131  // Descriptive metadata tag\n#define WMP_tagDateTime             0x0132  // Descriptive metadata tag\n#define WMP_tagArtist               0x013b  // Descriptive metadata tag\n#define WMP_tagHostComputer         0x013c  // Descriptive metadata tag\n\n#define WMP_tagXMPMetadata 0x02bc\n\n#define WMP_tagRatingStars          0x4746  // Descriptive metadata tag\n#define WMP_tagRatingValue          0x4749  // Descriptive metadata tag\n#define WMP_tagCopyright            0x8298  // Descriptive metadata tag\n\n#define WMP_tagEXIFMetadata 0x8769\n#define WMP_tagGPSInfoMetadata 0x8825\n#define WMP_tagIPTCNAAMetadata 0x83bb\n#define WMP_tagPhotoshopMetadata 0x8649\n#define WMP_tagInteroperabilityIFD 0xa005\n#define WMP_tagIccProfile 0x8773 // Need to use same tag as TIFF!!\n\n#define WMP_tagCaption              0x9c9b  // Descriptive metadata tag\n\n#define WMP_tagPixelFormat 0xbc01\n#define WMP_tagTransformation 0xbc02\n#define WMP_tagCompression 0xbc03\n#define WMP_tagImageType 0xbc04\n\n#define WMP_tagImageWidth 0xbc80\n#define WMP_tagImageHeight 0xbc81\n\n#define WMP_tagWidthResolution 0xbc82\n#define WMP_tagHeightResolution 0xbc83\n\n#define WMP_tagImageOffset 0xbcc0\n#define WMP_tagImageByteCount 0xbcc1\n#define WMP_tagAlphaOffset 0xbcc2\n#define WMP_tagAlphaByteCount 0xbcc3\n#define WMP_tagImageDataDiscard 0xbcc4\n#define WMP_tagAlphaDataDiscard 0xbcc5\n\n\n#define WMP_typBYTE 1\n#define WMP_typASCII 2\n#define WMP_typSHORT 3\n#define WMP_typLONG 4\n#define WMP_typRATIONAL 5\n#define WMP_typSBYTE 6\n#define WMP_typUNDEFINED 7\n#define WMP_typSSHORT 8\n#define WMP_typSLONG 9\n#define WMP_typSRATIONAL 10\n#define WMP_typFLOAT 11\n#define WMP_typDOUBLE 12\n\n\n#define WMP_valCompression 0xbc\n#define WMP_valWMPhotoID WMP_valCompression\n\n\n#ifdef WIN32\n#define __in_win\n#define __out_win\n#endif\n\n\n//================================================================\n\ntypedef enum\n{\n    DPKVT_EMPTY = 0,\n    DPKVT_UI1 = 17,\n    DPKVT_UI2 = 18,\n    DPKVT_UI4 = 19,\n    DPKVT_LPSTR = 30,\n    DPKVT_LPWSTR = 31,\n    DPKVT_BYREF = 0x4000,\n} DPKVARTYPE;\n\ntypedef struct DPKPROPVARIANT\n{\n    DPKVARTYPE  vt;\n    union\n    {\n        U8 bVal;        // DPKVT_UI1\n        U16 uiVal;      // DPKVT_UI2\n        U32 ulVal;      // DPKVT_UI4\n        char *pszVal;   // DPKVT_LPSTR\n        U16 *pwszVal;   // DPKVT_LPWSTR\n        U8 *pbVal;      // DPKVT_BYREF | DPKVT_UI1\n    } VT;\n} DPKPROPVARIANT;\n\ntypedef struct DESCRIPTIVEMETADATA\n{\n    DPKPROPVARIANT  pvarImageDescription;   // WMP_tagImageDescription\n    DPKPROPVARIANT  pvarCameraMake;         // WMP_tagCameraMake\n    DPKPROPVARIANT  pvarCameraModel;        // WMP_tagCameraModel\n    DPKPROPVARIANT  pvarSoftware;           // WMP_tagSoftware\n    DPKPROPVARIANT  pvarDateTime;           // WMP_tagDateTime\n    DPKPROPVARIANT  pvarArtist;             // WMP_tagArtist\n    DPKPROPVARIANT  pvarCopyright;          // WMP_tagCopyright\n    DPKPROPVARIANT  pvarRatingStars;        // WMP_tagRatingStars\n    DPKPROPVARIANT  pvarRatingValue;        // WMP_tagRatingValue\n    DPKPROPVARIANT  pvarCaption;            // WMP_tagCaption\n    DPKPROPVARIANT  pvarDocumentName;       // WMP_tagDocumentName\n    DPKPROPVARIANT  pvarPageName;           // WMP_tagPageName\n    DPKPROPVARIANT  pvarPageNumber;         // WMP_tagPageNumber\n    DPKPROPVARIANT  pvarHostComputer;       // WMP_tagHostComputer\n} DESCRIPTIVEMETADATA;\n\ntypedef struct tagWmpDE\n{\n    U16 uTag;\n    U16 uType;\n    U32 uCount;\n    U32 uValueOrOffset;\n} WmpDE;\n\ntypedef struct tagWmpDEMisc\n{\n    U32 uImageOffset;\n    U32 uImageByteCount;\n    U32 uAlphaOffset;\n    U32 uAlphaByteCount;\n\n    U32 uOffPixelFormat;\n    U32 uOffImageByteCount;\n    U32 uOffAlphaOffset;\n    U32 uOffAlphaByteCount;\n    U32 uColorProfileOffset;\n    U32 uColorProfileByteCount;\n    U32 uXMPMetadataOffset;\n    U32 uXMPMetadataByteCount;\n    U32 uEXIFMetadataOffset;\n    U32 uEXIFMetadataByteCount;\n    U32 uGPSInfoMetadataOffset;\n    U32 uGPSInfoMetadataByteCount;\n    U32 uIPTCNAAMetadataOffset;\n    U32 uIPTCNAAMetadataByteCount;\n    U32 uPhotoshopMetadataOffset;\n    U32 uPhotoshopMetadataByteCount;\n    U32 uDescMetadataOffset;\n    U32 uDescMetadataByteCount;\n} WmpDEMisc;\n\n\n//================================================================\nEXTERN_C ERR GetUShort(\n    __in_ecount(1) struct WMPStream* pWS,\n    size_t offPos,\n    __out_ecount(1) U16* puValue\n);\n\nEXTERN_C ERR PutUShort(\n    __in_ecount(1) struct WMPStream* pWS,\n    size_t offPos,\n    U16 uValue\n);\n\nEXTERN_C ERR GetULong(\n    __in_ecount(1) struct WMPStream* pWS,\n    size_t offPos,\n    __out_ecount(1) U32* puValue\n);\n\nEXTERN_C ERR PutULong(\n    __in_ecount(1) struct WMPStream* pWS,\n    size_t offPos,\n    U32 uValue\n);\n\nEXTERN_C ERR WriteWmpDE(\n    __in_ecount(1) struct WMPStream* pWS,\n    size_t *pOffPos,\n    const __in_ecount(1) WmpDE* pDE,\n    const U8 *pbData,\n    U32 *pcbDataWrittenToOffset\n);\n\n\nEXTERN_C ERR ReadPropvar(__in_ecount(1) struct WMPStream* pWS,\n                         const __in_win U16 uType,\n                         const __in_win U32 uCount,\n                         const __in_win U32 uValue,\n                         __out_win DPKPROPVARIANT *pvar);\n\n\n\n// read and write little endian words/dwords from a buffer on both big and little endian cpu's\n// with full buffer overflow checking\n\n#define WMP_INTEL_ENDIAN    ('I')\n\nEXTERN_C ERR getbfcpy(U8* pbdest, const U8* pb, size_t cb, size_t ofs, U32 n);\nEXTERN_C ERR getbfw(const U8* pb, size_t cb, size_t ofs, U16* pw);\nEXTERN_C ERR getbfdw(const U8* pb, size_t cb, size_t ofs, U32* pdw);\nEXTERN_C ERR getbfwbig(const U8* pb, size_t cb, size_t ofs, U16* pw);\nEXTERN_C ERR getbfdwbig(const U8* pb, size_t cb, size_t ofs, U32* pdw);\nEXTERN_C ERR getbfwe(const U8* pb, size_t cb, size_t ofs, U16* pw, U8 endian);\nEXTERN_C ERR getbfdwe(const U8* pb, size_t cb, size_t ofs, U32* pdw, U8 endian);\nEXTERN_C ERR setbfcpy(U8* pb, size_t cb, size_t ofs, const U8* pbset, size_t cbset);\nEXTERN_C ERR setbfw(U8* pb, size_t cb, size_t ofs, U16 dw);\nEXTERN_C ERR setbfdw(U8* pb, size_t cb, size_t ofs, U32 dw);\nEXTERN_C ERR setbfwbig(U8* pb, size_t cb, size_t ofs, U16 dw);\nEXTERN_C ERR setbfdwbig(U8* pb, size_t cb, size_t ofs, U32 dw);\nEXTERN_C ERR BufferCalcIFDSize(const U8* pb, size_t cb, U32 uIFDOfs, U8 endian, U32 *pcbifd);\nEXTERN_C ERR StreamCalcIFDSize(struct WMPStream* pWS, U32 uIFDOfs, U32 *pcbifd);\nEXTERN_C ERR BufferCopyIFD(const U8* pbsrc, U32 cbsrc, U32 ofssrc, U8 endian, U8* pbdest, U32 cbdest, U32* pofsdest);\nEXTERN_C ERR StreamCopyIFD(struct WMPStream* pWS, U32 ofssrc, U8* pbdest, U32 cbdest, U32* pofsdest);\n\n", "comment_ratio": 0.2702702702702703}
{"lang": "c", "code": "@interface DonezoTaskList : NSObject {\n  NSString *key;\n  NSString *name;\n  NSNumber *tasksCount;\n}\n\n@property (nonatomic, copy) NSString *key;\n@property (nonatomic, copy) NSString *name;\n@property (nonatomic, copy) NSNumber *tasksCount;\n\n+ (DonezoTaskList*) taskListFromDictionary:(NSDictionary*)dict;\n\n@end\n\n", "comment_ratio": 0.3181818181818182}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n#import <AVFoundation/AVFoundation.h>\n\n#import \"DBCameraDelegate.h\"\n\n@interface DBCameraView : UIView\n@property (nonatomic, weak) id <DBCameraViewDelegate> delegate;\n@property (nonatomic, strong, readonly) AVCaptureVideoPreviewLayer *previewLayer;\n@property (nonatomic, strong, readonly) UIView *stripe;\n@property (nonatomic, strong, readonly) UITapGestureRecognizer *singleTap, *doubleTap;\n@property (nonatomic, strong, readonly) UIPinchGestureRecognizer *pinch;\n\n+ (id) initWithFrame:(CGRect)frame;\n+ (DBCameraView *) initWithCaptureSession:(AVCaptureSession *)captureSession;\n\n- (void) defaultInterface;\n- (void) drawFocusBoxAtPointOfInterest:(CGPoint)point andRemove:(BOOL)remove;\n- (void) drawExposeBoxAtPointOfInterest:(CGPoint)point andRemove:(BOOL)remove;\n- (void) draw:(CALayer *)layer atPointOfInterest:(CGPoint)point andRemove:(BOOL)remove;\n- (void) pinchCameraViewWithScalNum:(CGFloat)scale;\n- (void) createGesture;\n\n@end\n", "comment_ratio": 0.22580645161290322}
{"lang": "c", "code": "#ifndef __MAIN_H\n#define __MAIN_H\n\n\n// Define to any non-zero value when a HSE is present\n#define DEVICE_HSE_PRESENT         1\n\n\n// Internal peripherals\n#include \"rcc.h\"\n#include \"pwr.h\"\n#include \"gpio.h\"\n#include \"usart.h\"\n#include \"spi.h\"\n#include \"i2c.h\"\n#include \"delay.h\"\n\n#include \"tmp116.h\"\n\n\n// Debug USART port\n#define DBG_USART                  USART1\n\n// Alias for printf, redirect output to debug USART port)\n#if (USART_USE_PRINTF)\n#define printf(...)                USART_printf(DBG_USART, __VA_ARGS__)\n#endif\n\n#endif // __MAIN_H\n\n", "comment_ratio": 0.16666666666666666}
{"lang": "c", "code": "//Inclue header file==============================================\n#include <stdio.h>\n#include <stdlib.h>\n#include <malloc.h>\n#include <string.h>\n#include <math.h>\n//================================================================\n\n//Define struct===================================================\n//Link---------------------------\ntypedef struct _link\n{\n    int link_id;\n    int from_node_id;\n    int to_node_id;\n    float FFT;\n    float capacity;\n    int next_inlink_id;\n    int next_outlink_id;\n} Link_t;\n\n//Node---------------------------\ntypedef struct _node\n{\n    int node_id;\n    int first_inlink_id;\n    int first_outlink_id;\n    int heap_position; //heap\n    float spl;         //Shortest path length\n    int search_flag;   //Use in dijkstra\n} Node_t;\n\n//Function prottype===============================================\n//-------------------------------------------\nint input_parameter_data(char *folder_path_, int *Num_Link_, int *Num_Node_);\nint input_netwok_data(char *folder_path_, Link_t *Link_table_, int *Num_Link_, Node_t *Node_table_, int *Num_Node_);\n\n//-------------------------------------------\nint dijkstra(Link_t *Link_table_, int *Num_Link_, Node_t *Node_table_, int *Num_Node_);//, int *heap_tree_, int* last_position_);\nint pickup_heap(int *heap_tree_, int *last_position_, Node_t *Node_table_);\nint add_heap(int *heap_tree_, int *last_position_, Node_t *Node_table_, int add_node_id_);\nint up_heap(int *heap_tree_, Node_t *Node_table_, int tr_position_);\nint down_heap(int *heap_tree_, int *last_position_, Node_t *Node_table_, int tr_position_);\n\n//main============================================================\nint main()\n{\n    //Setting folder path=========================================\n    char *folder_path = malloc(50 * sizeof(char));\n    printf(\"Input folder path\\n\");\n    scanf(\"%s\", folder_path);\n\n    // Input data=================================================\n    // Define parameter-------------------------\n    int *Num_Node = malloc(sizeof(int));\n    int *Num_Link = malloc(sizeof(int));\n\n    //Input parameter data-----------------------\n    input_parameter_data(folder_path, Num_Link, Num_Node);\n\n    printf(\"dbg1\\n\");\n    //Construct Node_t array and Link_t array-----\n    int node_table_len = *Num_Node + 1;\n    int link_table_len = *Num_Link + 1;\n    Node_t *Node_table = malloc(node_table_len * sizeof(Node_t));\n    Link_t *Link_table = malloc(link_table_len * sizeof(Link_t));\n\n    //Input network data------------------------\n    printf(\"dbg2\\n\");\n    input_netwok_data(folder_path, Link_table, Num_Link, Node_table, Num_Node);\n    printf(\"dbg3\\n\");\n\n    printf(\"Link:%i\\n\", *Num_Link);\n    printf(\"Node:%i\\n\", *Num_Node);\n\n\n    dijkstra(Link_table, Num_Link, Node_table, Num_Node);\n\n    for (int tr_link_id = 1; tr_link_id <= *Num_Link; ++tr_link_id)\n    {\n        printf(\"link-id:%i\\tcapa:%f\\n\", tr_link_id, Link_table[tr_link_id].capacity);\n    }\n\n    for (int tr_node_id = 0; tr_node_id < *Num_Node; ++tr_node_id)\n    {\n        printf(\"node-id:%i\\tspl:%f\\n\", tr_node_id, Node_table[tr_node_id].spl);\n    }\n\n    free(Num_Link);\n    free(Num_Node);\n    free(Link_table);\n    free(Node_table);\n    return 0;\n}\n\n//dijkstra=======================================================\nint dijkstra(Link_t *Link_table_, int *Num_Link_, Node_t *Node_table_, int *Num_Node_)\n{\n    printf(\"dbg4\\n\");\n    int pivot_node_id = 0;\n    Node_table_[pivot_node_id].spl = 0;\n\n\n    int *heap_tree = malloc((*Num_Node_ + 1) * sizeof(int));\n    heap_tree[1] = pivot_node_id; //Set Origin Node ID\n    \n    int *last_position = malloc(sizeof(int));\n    *last_position = 1;\n    \n\n\n    while (1)\n    {\n        printf(\"==================================\");\n        pivot_node_id = pickup_heap(heap_tree, last_position, Node_table_);\n\n        printf(\"pivot_node_id:%i\\n\", pivot_node_id);\n        printf(\"last_position:%i\\n\", *last_position);\n\n        int tr_link_id = Node_table_[pivot_node_id].first_outlink_id;\n        while (tr_link_id != -1)\n        {\n            printf(\"tr_link_id:%i\\n\", tr_link_id);\n            int tr_node_id = Link_table_[tr_link_id].to_node_id;\n            if (Node_table_[tr_node_id].search_flag != 2)\n            {\n                Node_table_[tr_node_id].search_flag = 1;\n                if (Node_table_[tr_node_id].spl > Node_table_[pivot_node_id].spl + Link_table_[tr_link_id].FFT)\n                {\n                    Node_table_[tr_node_id].spl = Node_table_[pivot_node_id].spl + Link_table_[tr_link_id].FFT;\n                    printf(\"Add node %i\\n\", tr_node_id);\n                    add_heap(heap_tree, last_position, Node_table_, tr_node_id);\n                }\n            }\n            tr_link_id = Link_table_[tr_link_id].next_outlink_id;\n        }\n        //--------------------------\n\n        Node_table_[pivot_node_id].search_flag = 2;\n\n        if (*last_position == 0)\n        {\n            break;\n        }\n    }\n    free(last_position);\n    free(heap_tree);\n    return 0;\n}\n\n//==============================================================\nint add_heap(int *heap_tree_, int *last_position_, Node_t *Node_table_, int add_node_id_)\n{\n    if (Node_table_[add_node_id_].heap_position == -1)\n    {\n        //new node\n        int add_position = *last_position_ + 1;\n\n        heap_tree_[add_position] = add_node_id_;\n        Node_table_[add_node_id_].heap_position = add_position;\n        *last_position_ = add_position;\n        \n        printf(\"last_posi:%i\\n\", *last_position_);\n        getchar();\n\n        up_heap(heap_tree_, Node_table_, add_position);\n    }\n    else\n    {\n        //already exist\n        int add_position = Node_table_[add_node_id_].heap_position;\n        up_heap(heap_tree_, Node_table_, add_position);\n    }\n    return 0;\n}\n\n//===============================================================\nint pickup_heap(int *heap_tree_, int *last_position_, Node_t *Node_table_)\n{\n    int top_node_id = heap_tree_[1];\n    int last_position = *last_position_;\n\n    heap_tree_[1] = heap_tree_[last_position];\n    Node_table_[heap_tree_[last_position]].heap_position = 1;\n\n    *last_position_ = last_position - 1;\n\n    down_heap(heap_tree_, last_position_, Node_table_, 1);\n    return top_node_id;\n}\n\n//===============================================================\nint down_heap(int *heap_tree_, int *last_position_, Node_t *Node_table_, int tr_position_)\n{\n    int tr_position = tr_position_;\n    int small_child_position;\n\n    while (tr_position * 2 <= *last_position_)\n    {\n        int child1_position = tr_position * 2;\n        int child2_position = tr_position * 2 + 1;\n\n        if (child2_position > *last_position_)\n        {\n            small_child_position = child1_position;\n        }\n        else if (Node_table_[heap_tree_[child1_position]].spl < Node_table_[heap_tree_[child2_position]].spl)\n        {\n            small_child_position = child1_position;\n        }\n        else\n        {\n            small_child_position = child2_position;\n        }\n\n        if (Node_table_[heap_tree_[tr_position]].spl > Node_table_[heap_tree_[small_child_position]].spl)\n        {\n            int tmp_smallest_node_id = heap_tree_[small_child_position];\n\n            heap_tree_[small_child_position] = heap_tree_[tr_position];\n            Node_table_[heap_tree_[tr_position]].heap_position = small_child_position;\n\n            heap_tree_[tr_position] = tmp_smallest_node_id;\n            Node_table_[tmp_smallest_node_id].heap_position = tr_position;\n\n            tr_position = small_child_position;\n        }\n        else\n        {\n            //---\n            break;\n        }\n    }\n    return 0;\n}\n\n//================================================================\nint up_heap(int *heap_tree_, Node_t *Node_table_, int tr_position_)\n{\n    int tr_position = tr_position_;\n    int parent_position;\n\n    while (tr_position > 1)\n    {\n        parent_position = tr_position / 2;\n        if (Node_table_[heap_tree_[parent_position]].spl < Node_table_[heap_tree_[tr_position]].spl)\n        {\n            int tmp_smallest_node_id = heap_tree_[parent_position];\n\n            heap_tree_[parent_position] = heap_tree_[tr_position];\n            Node_table_[heap_tree_[tr_position]].heap_position = parent_position;\n\n            heap_tree_[tr_position] = tmp_smallest_node_id;\n            Node_table_[tmp_smallest_node_id].heap_position = tr_position;\n\n            tr_position = parent_position;\n        }\n        else\n        {\n            break;\n        }\n    }\n    return 0;\n}\n\n// Input paremeter data function===================================\nint input_parameter_data(char *folder_path_, int *Num_Link_, int *Num_Node_)\n{\n    char tmp_folder_path[50];\n    strcpy(tmp_folder_path, folder_path_);\n    FILE *input_file = fopen(strcat(tmp_folder_path, \"\\\\parameter.dat\"), \"r\");\n    if (input_file == NULL)\n    {\n        fprintf(stderr, \"File Open Failed\\n\");\n        exit(1);\n    }\n    // int node;\n    fscanf(input_file, \"%i%i\\n\", Num_Node_, Num_Link_);\n    fclose(input_file);\n    return 0;\n}\n//--------------------------------------------\n\n// Input networks data function====================================\nint input_netwok_data(char *folder_path_, Link_t *Link_table_, int *Num_Link_, Node_t *Node_table_, int *Num_Node_)\n{\n    //Init Node_table----------------------------\n    for (int i = 0; i <= *Num_Node_; ++i)\n    {\n        Node_table_[i].node_id = i;\n        Node_table_[i].first_inlink_id = -1;\n        Node_table_[i].first_outlink_id = -1;\n        Node_table_[i].heap_position = -1; //heap\n        Node_table_[i].spl = 999999;         //Shortest path length\n        Node_table_[i].search_flag = 0;   //Use in dijkstra\n    }\n\n    //------------------------------------------\n    char tmp_folder_path[50];\n    strcpy(tmp_folder_path, folder_path_);\n    FILE *input_file = fopen(strcat(tmp_folder_path, \"\\\\network.dat\"), \"r\");\n    if (input_file == NULL)\n    {\n        fprintf(stderr, \"File Open Failed\\n\");\n        exit(1);\n    }\n    int Link_id = 1;\n    while (Link_id <= *Num_Link_)\n    {\n        int from_node_id;\n        int to_node_id;\n        float FFT;\n        float capacity;\n        fscanf(input_file, \"%i%i%f%f\\n\", &from_node_id, &to_node_id, &FFT, &capacity);\n        Link_table_[Link_id].from_node_id = from_node_id;\n        Link_table_[Link_id].to_node_id = to_node_id;\n        Link_table_[Link_id].FFT = FFT;\n        Link_table_[Link_id].capacity = capacity;\n        Link_table_[Link_id].next_inlink_id = -1;\n        Link_table_[Link_id].next_outlink_id = -1;\n        //Add inlink and outlink information to Node_table-------------\n        //from_node--------------------\n        Node_table_[from_node_id].node_id = from_node_id;\n        if (Node_table_[from_node_id].first_outlink_id == -1)\n        {\n            Node_table_[from_node_id].first_outlink_id = Link_id;\n        }\n        else\n        {\n            int tr_link_id;\n            tr_link_id = Node_table_[from_node_id].first_outlink_id;\n            while (1)\n            {\n                if (Link_table_[tr_link_id].next_outlink_id == -1)\n                {\n                    Link_table_[tr_link_id].next_outlink_id = Link_id;\n                    Link_table_[Link_id].next_outlink_id = -1;\n                    break;\n                }\n                tr_link_id = Link_table_[tr_link_id].next_outlink_id;\n            }\n        }\n        //-------------------------------------------\n        //to_node------------------------------------\n        Node_table_[to_node_id].node_id = to_node_id;\n        if (Node_table_[to_node_id].first_inlink_id == -1)\n        {\n            Node_table_[to_node_id].first_inlink_id = Link_id;\n            Link_table_[Link_id].next_inlink_id = -1;\n        }\n        else\n        {\n            int tr_link_id;\n            tr_link_id = Node_table_[to_node_id].first_inlink_id;\n            while (1)\n            {\n                if (Link_table_[tr_link_id].next_inlink_id == -1)\n                {\n                    Link_table_[tr_link_id].next_inlink_id = Link_id;\n                    Link_table_[Link_id].next_inlink_id = -1;\n                    break;\n                }\n                tr_link_id = Link_table_[tr_link_id].next_inlink_id;\n            }\n        }\n        //----------------------------------------------\n        Link_id = Link_id + 1;\n    }\n    fclose(input_file);\n    return 0;\n}\n", "comment_ratio": 0.11590296495956873}
{"lang": "c", "code": "\r\n#ifndef __FIG_BASE_H\r\n#define __FIG_BASE_H\r\n\r\n#include <iostream>\r\nusing std::istream;\r\nusing std::ostream;\r\n\r\nclass FigBase {\r\n\r\nfriend ostream& operator<< (ostream &, const FigBase &);\r\nfriend istream& operator>> (istream &, FigBase &);\r\n\r\nprivate:\r\n    double x, y;\r\n\r\n    // atributos da linha\r\n    int espessura; // inteiro de 1 a 5\r\n    int cor;       // inteiro de 1 a 5\r\n    int tipo;      // inteiro de 1 a 3\r\n\r\npublic:\r\n    FigBase(double=0.0, double=0.0, int=1, int=1, int=1);\r\n\r\n    double getX() const;\r\n    void setX(double);\r\n\r\n    double getY() const;\r\n    void setY(double);\r\n\r\n    int getEspessura() const;\r\n    void setEspessura(int);\r\n\r\n    int getCor() const;\r\n    void setCor(int);\r\n\r\n    int getTipo() const;\r\n    void setTipo(int);\r\n\r\n    virtual float area() const = 0;\r\n    virtual float perimetro() const = 0;\r\n    virtual void imprime() const;\r\n    virtual void ler();   // funcao adicional (nao especificada no UML)\r\n\r\n};\r\n\r\n#endif\r\n\n", "comment_ratio": 0.10416666666666667}
{"lang": "c", "code": "#ifndef ENTMaterial_h\n#define ENTMaterial_h\n\n// Written: fmk \n// Created: 07/98\n// Revision: A\n//\n// Description: This file contains the class definition for \n// ENTMaterial. ENTMaterial provides the abstraction\n// of an elastic  uniaxial material under compression\n// i.e. stress = E*strain e\n// under tension however it exhbits the following\n//     stress = a*(tanh(strain*b))\n//     tangent = a*(1-tanh(strain*b)*tanh(strain*b));\n//\n//\n// What: \"@(#) ENTMaterial.h, revA\"\n\n#include <UniaxialMaterial.h>\n\nclass ENTMaterial : public UniaxialMaterial\n{\n  public:\n  ENTMaterial(int tag, double E, double a = 0.0, double b = 1.0);    \n    ENTMaterial();    \n    ~ENTMaterial();\n\n    const char *getClassType(void) const {return \"ENTMaterial\";};\n\n    int setTrialStrain(double strain, double strainRate = 0.0); \n    double getStrain(void);\n    double getStress(void);\n    double getTangent(void);\n    double getInitialTangent(void) {return E;};\n\n    int commitState(void);\n    int revertToLastCommit(void);    \n    int revertToStart(void);        \n\n    UniaxialMaterial *getCopy(void);\n    \n    int sendSelf(int commitTag, Channel &theChannel);  \n    int recvSelf(int commitTag, Channel &theChannel, \n\t\t FEM_ObjectBroker &theBroker);    \n    \n    void Print(OPS_Stream &s, int flag =0);\n    \n    int setParameter(const char **argv, int argc, Parameter &param);\n    int updateParameter(int parameterID, Information &info);\n\n    // AddingSensitivity:BEGIN //////////////////////////////////////////\n    int activateParameter(int parameterID);\n    double getStressSensitivity(int gradIndex, bool conditional);\n    double getInitialTangentSensitivity(int gradIndex);\n    int commitSensitivity(double strainGradient, int gradIndex, int numGrads);\n    // AddingSensitivity:END ///////////////////////////////////////////\n\n  protected:\n    \n  private:\n    double E;\n    double commitStrain;\n    double trialStrain;\n\n    // AddingSensitivity:BEGIN //////////////////////////////////////////\n    int parameterID;\n    // AddingSensitivity:END ///////////////////////////////////////////\n\n    double a;\n    double b;\n};\n\n\n#endif\n\n\n", "comment_ratio": 0.2079207920792079}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n\n@interface AppDelegate : UIResponder <UIApplicationDelegate>\n\n@property (strong, nonatomic) UIWindow *window;\n\n\n@end\n\n\n", "comment_ratio": 0.3888888888888889}
{"lang": "c", "code": "#ifndef PERIDOT_BIN_SESSIONMGR_AGENT_RUNNER_AGENT_RUNNER_STORAGE_IMPL_H_\n#define PERIDOT_BIN_SESSIONMGR_AGENT_RUNNER_AGENT_RUNNER_STORAGE_IMPL_H_\n\n#include <fuchsia/ledger/cpp/fidl.h>\n#include <lib/async/cpp/operation.h>\n#include <src/lib/fxl/macros.h>\n\n#include \"peridot/bin/sessionmgr/agent_runner/agent_runner_storage.h\"\n#include \"peridot/lib/ledger_client/ledger_client.h\"\n#include \"peridot/lib/ledger_client/page_client.h\"\n#include \"peridot/lib/ledger_client/types.h\"\n\nnamespace modular {\n\n// An implementation of |AgentRunnerStorage| that persists data in the ledger.\nclass AgentRunnerStorageImpl : public AgentRunnerStorage, PageClient {\n public:\n  explicit AgentRunnerStorageImpl(LedgerClient* ledger_client, fuchsia::ledger::PageId page_id);\n  ~AgentRunnerStorageImpl() override;\n\n private:\n  // |AgentRunnerStorage|\n  void Initialize(NotificationDelegate* delegate, fit::function<void()> done) override;\n\n  // |AgentRunnerStorage|\n  void WriteTask(const std::string& agent_url, TriggerInfo data,\n                 fit::function<void(bool)> done) override;\n\n  // |AgentRunnerStorage|\n  void DeleteTask(const std::string& agent_url, const std::string& task_id,\n                  fit::function<void(bool)> done) override;\n\n  // Operation subclasses:\n  class InitializeCall;\n  class WriteTaskCall;\n  class DeleteTaskCall;\n\n  // |PageClient|\n\n  void OnPageChange(const std::string& key, const std::string& value) override;\n  // |PageClient|\n  void OnPageDelete(const std::string& key) override;\n\n  // Only valid after |Initialize()| is called.\n  NotificationDelegate* delegate_;  // Not owned.\n\n  OperationQueue operation_queue_;\n\n  FXL_DISALLOW_COPY_AND_ASSIGN(AgentRunnerStorageImpl);\n};\n\n}  // namespace modular\n\n#endif  // PERIDOT_BIN_SESSIONMGR_AGENT_RUNNER_AGENT_RUNNER_STORAGE_IMPL_H_\n\n", "comment_ratio": 0.23728813559322035}
{"lang": "c", "code": "\r\n#ifndef __ACESTEXT_H__\r\n#define __ACESTEXT_H__\r\n\r\n#include \"acdb.h\"\r\n#include \"AdAChar.h\"\r\n\r\n#include \"..\\inc\\zacestext.h\"\r\n\r\n#ifndef ACHAR\r\n#define ACHAR\t\tZTCHAR\r\n#endif //#ifndef ACHAR\r\n\r\n#ifndef Acad\r\n#define Acad\t\tZcad\r\n#endif //#ifndef Acad\r\n\r\n#ifndef acadErrorStatusText\r\n#define acadErrorStatusText\t\tzcadErrorStatusText\r\n#endif //#ifndef acadErrorStatusText\r\n\r\n#endif //#ifndef __ACESTEXT_H__\r\n\n", "comment_ratio": 0.17391304347826086}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n#import \"Masonry.h\"\n#import \"RRGB.h\"\n\n@interface RCollectionViewCell : UICollectionViewCell\n\n/**\n \u65e5\n */\n@property (nonatomic,strong)NSString *day;\n\n/**\n \u519c\u5386 \u65e5\n */\n@property (nonatomic,strong)NSString *znDay;\n\n/**\n \u662f\u5426\u9009\u4e2d\n */\n@property (nonatomic, assign)BOOL isSelected;\n/**\n \u8be5\u5929\u662f\u5426\u6709\u7ed1\u5b9a\u6570\u636e\n */\n@property (nonatomic, assign)BOOL isDataSource;\n\n\n/**\n \u662f\u5426\u662f\u4eca\u5929\n */\n@property (nonatomic, assign)BOOL isToDay;\n\n/**\n  day uicolor\n */\n@property (nonatomic, assign)UIColor *dayLabelTextColor;\n\n/**\n \u65e5\u671f\u65b9\u683c\u7684\u80cc\u666f\u989c\u8272\n */\n@property (nonatomic, assign)UIColor *bgViewColor;\n@end\n\n", "comment_ratio": 0.14}
{"lang": "c", "code": "#ifndef DampingFilter_h\n#define DampingFilter_h\n\n//#include \"AudioModule.h\"\n#include \"Definitions.h\"\n#include \"MoreMath.h\"\nusing namespace MoreMath;\n\n/**\n\nThis class implements a filter which is meant be used as a frequency dependent\ngain inside a feedback loop, so as to apply a frequency dependent damping \ninside the loop. It applies a global gain factor to a signal as well as a \nfirst order low-shelving and a first order high-shelving filter. \nIn that respect, it is very much like the ToneControl class, but here we use a\ndifferent definition of the corner-frequency. In the ToneControl class, the\ncorner-frequency is defined to be the frequency at which the gain is the\ngeometric mean between the gain the reference gain (which is unity) - here the \nrereference gain does not need to be unity and the relative gain at the \ncorner-frequency can be specified arbitrarily. This facilitates the use of the \nfilter inside the feedback-loop of a delay-line - here it may be desirable to \ndefine the corner-freq in terms of decay-time instead of in terms of gain.\n\n*/\n\nclass DampingFilter\n{\n\npublic:\n\n //---------------------------------------------------------------------------\n //construction/destruction:\n\n DampingFilter();   ///< Constructor.\n ~DampingFilter();  ///< Destructor.\n\n //---------------------------------------------------------------------------\n // parameter settings:\n\n void setSampleRate(double newSampleRate);\n ///< Overrides the setSampleRate() method of the AudioModule base class.\n\n void setGlobalGainFactor(double newGlobalGainFactor);\n /** Sets up a global gain factor (as factor, not in dB). */\n\n void setLowGainFactor(double newLowGainFactor);\n /**< Sets the realative gain factor of the low-shelving filter  */\n\n void setLowCrossoverFreq(double newLowCornerFreq);\n /**< Sets the corner frequency of the low-shelving filter */\n\n void setLowCrossoverGainFactor(double newLowCrossoverGainFactor);\n /**< Sets the relative gain factor at which the crossover-frequency is \n      measured for the low-shelving filter. See Orfanidis' paper about \n      High Order Equalizers for details. */\n\n void setHighGainFactor(double newHighGainFactor);\n /**< Sets the relative gain factor of the high-shelving filter. */\n\n void setHighCrossoverFreq(double newHighCornerFreq);\n /**< Sets the corner frequency of the high-shelving filter. */\n\n void setHighCrossoverGainFactor(double newHighCrossoverGainFactor);\n /**< Sets the relative gain factor at which the crossover-frequency is \n      measured for the high-shelving filter. */\n\n //---------------------------------------------------------------------------\n // audio processing:\n\n INLINE double getSample(double in);\n ///< Calculates one output sample at a time.\n\n //---------------------------------------------------------------------------\n //others:\n\n void resetBuffers();\n ///< Resets the internal buffers of the filter to zero.\n\n //===========================================================================\n\nprotected:\n\n // buffering:\n doubleA out;\n doubleA x1, x2;  // past input values\n doubleA y1, y2;  // past output values\n\n // overall 2-pole filter-coefficients:\n doubleA b0, b1, b2; // feedforward coeffs\n doubleA     a1, a2; // feedback coeffs\n\n // 1-pole filter-coefficients:\n doubleA b0Ls, b1Ls, a1Ls; // low-shelf coeffs\n doubleA b0Hs, b1Hs, a1Hs; // high-shelf coeffs\n\n // filter parameters:\n doubleA globalGainFactor;\n\n doubleA lowCrossoverFreq;\n doubleA lowCrossoverGainFactor;\n doubleA lowGainFactor;\n\n doubleA highCrossoverFreq;\n doubleA highCrossoverGainFactor;\n doubleA highGainFactor;\n\n doubleA sampleRate;\n doubleA sampleRateRec;  // reciprocal of the sampleRate\n \n // private member functions:\n void calcLowShelfCoeffs();  // calculates the low-shelving coeffs\n void calcHighShelfCoeffs(); // calculates the high-shelving coeffs\n void calcBiquadCoeffs();    // combines the two first order filters into one\n                             // biquad filter\n\n};\n\n//-----------------------------------------------------------------------------\n//from here: definitions of the functions to be inlined, i.e. all functions\n//which are supposed to be called at audio-rate (they can't be put into\n//the .cpp file):\n\nINLINE double DampingFilter::getSample(double in)\n{\n // calculate output-sample:\n out = b0*in + b1*x1 + b2*x2\n             + a1*y1 + a2*y2;\n\n // update buffer-variables:\n x2 = x1;\n x1 = in;\n y2 = y1;\n y1 = out;\n\n return out;\n}\n\n#endif // DampingFilter_h\n\n", "comment_ratio": 0.2733812949640288}
{"lang": "c", "code": "#pragma once\n\n#include <string>\n#include <fstream>\n\n/// File Format\n///  =============== Header ===============\n///   4 Byte: Header == REC\\0\n///   sizeof(int16_t) Byte: File version == REC_FILE_VERSION\n///   sizeof(uint32_t) Byte: overall size of network messages\n///   char[36]: Game UUID\n///   sizeof(int64_t) Byte: Game start time\n///  ================ Body ================\n///   --------- Network message ----------\n///   sizeof(int32_t) Byte: Size of message\n///   size Byte: The message\n///   ------------------------------------\n///   ...\n\nnamespace Net {\nclass NetworkMessage;\n}\n\nnamespace Game {\nclass Game;\n}\n\nnamespace IO {\n\nclass GameWriteStream\n{\nprivate:\n    std::fstream stream_;\n    bool open_;\n    uint32_t size_;\n    std::string filename_;\npublic:\n    GameWriteStream() :\n        open_(false),\n        size_(0)\n    { }\n    ~GameWriteStream();\n\n    bool Open(const std::string& dir, Game::Game* game);\n    void Close();\n    void Write(const Net::NetworkMessage& msg);\n    bool IsOpen() const\n    {\n        return open_;\n    }\n    std::string GetFilename() const { return filename_; }\n};\n\nclass GameReadStream\n{\nprivate:\n    std::fstream stream_;\n    bool open_;\n    int64_t startTime_;\n    uint32_t read_;\n    uint32_t size_;\n    std::string gameUuid_;\npublic:\n    GameReadStream() :\n        open_(false),\n        startTime_(0),\n        read_(0),\n        size_(0)\n    { }\n    ~GameReadStream();\n\n    bool Open(const std::string& dir, const std::string& instance);\n    void Close();\n    bool Read(Net::NetworkMessage& msg);\n    bool IsOpen() const\n    {\n        return open_;\n    }\n    const std::string& GetGameUuid() const\n    {\n        return gameUuid_;\n    }\n};\n\n}\n\n", "comment_ratio": 0.12149532710280374}
{"lang": "c", "code": "#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"PlayFabRuntimeSettings.generated.h\"\n\n/**\n* Implements the settings for the PlayFab plugin in the Unreal GUI\n* This ends up being more like \"build time constants\", as they can't be changed at runtime\n*/\nUCLASS(config = Engine, defaultconfig)\nclass PLAYFABCOMMON_API UPlayFabRuntimeSettings : public UObject\n{\n    GENERATED_BODY()\npublic:\n    UPlayFabRuntimeSettings();\n\n    // URL endpoint of the PlayFab production environment\n    UPROPERTY(EditAnywhere, config, Category = Settings)\n    FString ProductionEnvironmentURL;\n\n    // Game Title ID\n    UPROPERTY(EditAnywhere, config, Category = Settings)\n    FString TitleId;\n\n    // Secret Key, Do not add this to the clients!\n    UPROPERTY(EditAnywhere, config, Category = Settings)\n    FString DeveloperSecretKey;\n};\n\n", "comment_ratio": 0.17647058823529413}
{"lang": "c", "code": "@import UIKit;\n\n@class BOXContentClient;\n@class BOXUser;\n\n/**\n * BOXAuthorizationViewController is a UIViewController that displays a WKWebview\n * that loads the OAuth2 authorize URL. An app may present this view controller to\n * log a user in to Box.\n *\n * This view controller also has extra logic to handle various Single Sign-ON (SSO)\n * configurations which require special handling beyond what a web view provides.\n * SSO is a session/user authentication process that allows a user to provide his\n * or her credentials once in order to access multiple applications. It is widely\n * used by corporations and institutions to secure and simplify the authentication\n * process for their users.\n *\n * **Important**: This controller performs valuable cookie-related operations on deallocation,\n * as such it should not be kept it memory after it is dismissed.\n *\n * @warning This is the only part of the Box SDK that is specific to iOS. If you wish to\n *   include the Box SDK in an OS X project, remove this source file.\n */\n@interface BOXAuthorizationViewController : UIViewController\n\n/** @name Initializers */\n\n/**\n * Designated initializer.\n * @param SDKClient         The SDKClient to use to authenticate a new account session.\n * @param completionBlock   You will likely want to dismiss the authorizationViewController. If successful, a BoxUser object will be returned, otherwise an NSError will be returned.\n * @param cancelBlock       You will likely want to dismiss the authorizationViewController through this block.\n */\n- (instancetype)initWithSDKClient:(BOXContentClient *)SDKClient\n                  completionBlock:(void (^)(BOXAuthorizationViewController *authorizationViewController, BOXUser *user, NSError *error))completionBlock\n                      cancelBlock:(void (^)(BOXAuthorizationViewController *authorizationViewController))cancelBlock;\n\n/**\n * Advanced initializer.\n * @param SDKClient         The SDKClient to use to authenticate a new account session.\n * @param authorizeURL      The authorization URL to be used. Optional, a default value is used when nil.\n * @param redirectURI       The redirect URI to be used, this has to match the redirect URI. Optional, a default value is used when nil.\n * @param headers           Custom headers to use in the authorization request. Optional, defaults to nil.\n * @param completionBlock   You will likely want to dismiss the authorizationViewController. If successful, a BoxUser object will be returned, otherwise an NSError will be returned.\n * @param cancelBlock       You will likely want to dismiss the authorizationViewController through this block.\n */\n- (instancetype)initWithSDKClient:(BOXContentClient *)SDKClient\n                     authorizeURL:(NSURL *)authorizeURL\n                      redirectURI:(NSString *)redirectURI\n                          headers:(NSDictionary *)headers\n                  completionBlock:(void (^)(BOXAuthorizationViewController *authorizationViewController, BOXUser *user, NSError *error))completionBlock\n                      cancelBlock:(void (^)(BOXAuthorizationViewController *authorizationViewController))cancelBlock;\n\n@end\n\n", "comment_ratio": 0.1111111111111111}
{"lang": "c", "code": "#ifndef GRAPH_EXECUTOR_QUERY_UNWINDEXECUTOR_H_\n#define GRAPH_EXECUTOR_QUERY_UNWINDEXECUTOR_H_\n\n#include \"graph/executor/Executor.h\"\n// expand multiple columns of data into one column\nnamespace nebula {\nnamespace graph {\n\nclass UnwindExecutor final : public Executor {\n public:\n  UnwindExecutor(const PlanNode *node, QueryContext *qctx)\n      : Executor(\"UnwindExecutor\", node, qctx) {}\n\n  folly::Future<Status> execute() override;\n\n private:\n  std::vector<Value> extractList(const Value &val);\n};\n\n}  // namespace graph\n}  // namespace nebula\n\n#endif  // GRAPH_EXECUTOR_QUERY_UNWINDEXECUTOR_H_\n\n", "comment_ratio": 0.25}
{"lang": "c", "code": "#ifndef V8_DEBUG_DEBUG_COVERAGE_H_\n#define V8_DEBUG_DEBUG_COVERAGE_H_\n\n#include <memory>\n#include <vector>\n\n#include \"src/debug/debug-interface.h\"\n#include \"src/handles/handles.h\"\n#include \"src/objects/objects.h\"\n\nnamespace v8 {\nnamespace internal {\n\n// Forward declaration.\nclass Isolate;\n\nstruct CoverageBlock {\n  CoverageBlock(int s, int e, uint32_t c) : start(s), end(e), count(c) {}\n  CoverageBlock() : CoverageBlock(kNoSourcePosition, kNoSourcePosition, 0) {}\n\n  int start;\n  int end;\n  uint32_t count;\n};\n\nstruct CoverageFunction {\n  CoverageFunction(int s, int e, uint32_t c, Handle<String> n)\n      : start(s), end(e), count(c), name(n), has_block_coverage(false) {}\n\n  bool HasNonEmptySourceRange() const { return start < end && start >= 0; }\n  bool HasBlocks() const { return !blocks.empty(); }\n\n  int start;\n  int end;\n  uint32_t count;\n  Handle<String> name;\n  // Blocks are sorted by start position, from outer to inner blocks.\n  std::vector<CoverageBlock> blocks;\n  bool has_block_coverage;\n};\n\nstruct CoverageScript {\n  // Initialize top-level function in case it has been garbage-collected.\n  explicit CoverageScript(Handle<Script> s) : script(s) {}\n  Handle<Script> script;\n  // Functions are sorted by start position, from outer to inner function.\n  std::vector<CoverageFunction> functions;\n};\n\nclass Coverage : public std::vector<CoverageScript> {\n public:\n  // Collecting precise coverage only works if the modes kPreciseCount or\n  // kPreciseBinary is selected. The invocation count is reset on collection.\n  // In case of kPreciseCount, an updated count since last collection is\n  // returned. In case of kPreciseBinary, a count of 1 is returned if a\n  // function has been executed for the first time since last collection.\n  static std::unique_ptr<Coverage> CollectPrecise(Isolate* isolate);\n  // Collecting best effort coverage always works, but may be imprecise\n  // depending on selected mode. The invocation count is not reset.\n  static std::unique_ptr<Coverage> CollectBestEffort(Isolate* isolate);\n\n  // Select code coverage mode.\n  static void SelectMode(Isolate* isolate, debug::CoverageMode mode);\n\n private:\n  static std::unique_ptr<Coverage> Collect(\n      Isolate* isolate, v8::debug::CoverageMode collectionMode);\n\n  Coverage() = default;\n};\n\n}  // namespace internal\n}  // namespace v8\n\n#endif  // V8_DEBUG_DEBUG_COVERAGE_H_\n\n", "comment_ratio": 0.225}
{"lang": "c", "code": "#pragma once\n\n#include <iostream>\n#include \"vArchive.h\"\n\n// FULLY STATIC CLASS\nclass CTGAFormat  \n{\npublic:\n    static unsigned char* getRGBA(std::istream* inputStream,int size);\n    static unsigned char* getRGB(std::istream* inputStream,int size,bool& isRgba,unsigned char invisibleColor[3]=nullptr);\n    static unsigned char* getImageData(std::string name,int& resX,int& resY,bool& isRgba,unsigned char invisibleColor[3]=nullptr,int bitsPerPixel[1]=nullptr);\n    static unsigned char* getImageData(std::istream* inputStream,int& resX,int& resY,bool& isRgba,unsigned char invisibleColor[3]=nullptr,int bitsPerPixel[1]=nullptr);\n    static unsigned char* getV_RGBA(VArchive& inputStream,int size);\n    static unsigned char* getV_RGB(VArchive& inputStream,int size,bool& isRgba,unsigned char invisibleColor[3]=nullptr);\n    static unsigned char* getV_ImageData(VArchive& inputStream,int& resX,int& resY,bool& isRgba,unsigned char invisibleColor[3]=nullptr,int bitsPerPixel[1]=nullptr);\n    static unsigned char* getQ_ImageData(const char* fileAndPath,int& resX,int& resY,bool& isRgba,unsigned char invisibleColor[3]=nullptr,int bitsPerPixel[1]=nullptr);\n};\n\n", "comment_ratio": 0.17391304347826086}
{"lang": "c", "code": "#import \"Mantle.h\"\n\n@interface TCMetaPostServer : MTLModel<MTLJSONSerializing>\n\n@property(nonatomic) NSString *urlTemplateOAuthAuth;\n@property(nonatomic) NSString *urlTemplateOAuthToken;\n@property(nonatomic) NSString *urlTemplateNewPost;\n@property(nonatomic) NSString *urlTemplatePostAttachment;\n@property(nonatomic) NSString *urlTemplateAttachment;\n@property(nonatomic) NSString *urlTemplateBatch;\n@property(nonatomic) NSString *urlTemplatePostsFeed;\n@property(nonatomic) NSString *urlTemplatePost;\n@property(nonatomic) NSString *urlTemplateServerInfo;\n@property(nonatomic) NSString *urlTemplateDiscover;\n\n@property(nonatomic) NSString *protocolVersion;\n\n@property(nonatomic) NSNumber *preferenceIndex;\n\n- (NSURL *)oauthAuthURL;\n- (NSURL *)oauthAuthURLWithAppID:(NSString *)clientID;\n- (NSURL *)oauthAuthURLWithAppID:(NSString *)clientID state:(NSString *)state;\n- (NSURL *)oauthTokenURL;\n- (NSURL *)newPostURL;\n- (NSURL *)postAttachmentURLWithEntity:(NSString *)entity\n                                postID:(NSString *)post\n                        attachmentName:(NSString *)name;\n- (NSURL *)attachmentURLWithEntity:(NSString *)entity\n                  attachmentDigest:(NSString *)digest;\n- (NSURL *)batchURL;\n- (NSURL *)postsFeedURL;\n- (NSURL *)postURLWithEntity:(NSString *)entity postID:(NSString *)post;\n- (NSURL *)serverInfoURL;\n- (NSURL *)discoveryURL;\n\n@end\n\n", "comment_ratio": 0.19148936170212766}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n\n@interface AppDelegate : UIResponder <UIApplicationDelegate>\n\n@property (strong, nonatomic) UIWindow *window;\n\n\n@end\n\n\n", "comment_ratio": 0.3888888888888889}
{"lang": "c", "code": "#pragma once\r\n#include <SFML/Graphics.hpp>\r\n\r\nusing namespace sf;\r\n\r\nclass PlayableCharacter {\r\n\r\nprotected:\r\n\r\n\t//Sprite\r\n\tSprite m_Sprite;\r\n\r\n\t//Duration of jump\r\n\tfloat m_JumpDuration;\r\n\r\n\t//Is character currently falling or jumping\r\n\tbool m_IsJumping;\r\n\tbool m_IsFalling;\r\n\r\n\t//Which direction is the character moving\r\n\tbool m_LeftPressed;\r\n\tbool m_RightPressed;\r\n\r\n\t//How long has the jump lasted\r\n\tfloat m_TimeThisJump;\r\n\r\n\t//Has the player just initiated a jump?\r\n\tbool m_JustJumped = false;\r\n\r\nprivate:\r\n\r\n\t//The constant gravity variable affecting the player\r\n\tfloat m_Gravity;\r\n\r\n\t//Character move speed\r\n\tfloat m_Speed = 400;\r\n\r\n\t//Character position\r\n\tVector2f m_Position;\r\n\r\n\t//Where are the character's various body parts?\r\n\tFloatRect m_Feet;\r\n\tFloatRect m_Head;\r\n\tFloatRect m_Right;\r\n\tFloatRect m_Left;\r\n\r\n\t//Texture\r\n\tTexture m_Texture;\r\n\r\npublic:\r\n\r\n\t//Spawns the character on the map\r\n\tvoid spawn(Vector2f startPosition, float gravity);\r\n\r\n\t//This is a pure virtual function for handling input for each sub-class object\r\n\tbool virtual handleInput() = 0;\r\n\r\n\t//Player's location\r\n\tFloatRect getPosition();\r\n\r\n\t//Getter functions for player's hit box\r\n\tFloatRect getFeet();\r\n\tFloatRect getHead();\r\n\tFloatRect getRight();\r\n\tFloatRect getLeft();\r\n\r\n\t//Getter function for sprite\r\n\tSprite getSprite();\r\n\r\n\t//Stop player's movement when input has ceased or to prevent moving through a \"solid\" tile; for collisions\r\n\tvoid stopFalling(float position);\r\n\tvoid stopRight(float position);\r\n\tvoid stopLeft(float position);\r\n\tvoid stopJump();\r\n\r\n\t//Return center of character\r\n\tVector2f getCenter();\r\n\r\n\t//Position and movement updater; to be called once per frame\r\n\tvoid update(float elapsedTime);\r\n\r\n};\n", "comment_ratio": 0.23170731707317074}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n\n@interface UIViewController (HUD)\n- (void)showHudInView:(UIView *)view hint:(NSString *)hint;\n\n- (void)hideHud;\n\n-(void)showHint:(NSString *)hint inView:(UIView *)view;\n-(void)showProgressImageViewInView:(UIView *)view;\n- (void)showHint:(NSString *)hint;\n\n- (void)showHint:(NSString *)hint yOffset:(float)yOffset;\n\n// \u6ca1\u6709\u6570\u636e\u7684\u65f6\u65f6\u5019\u663e\u793a\n- (void)ShowNoDataViewWithStr:(NSString *) ShowStr yOffset:(float)yOffset;\n- (void) hintNodataView;\n@end\n\n", "comment_ratio": 0.3076923076923077}
{"lang": "c", "code": "#ifndef __AssetHandleD_h\n#define __AssetHandleD_h\n\n#include <map>\n#include <string>\n#include <vector>\n#include <khException.h>\n#include <khFileUtils.h>\n\n\n/******************************************************************************\n ***  Derived ReadOnly Handles (Daemon Version)\n ***\n ***  This is for things like MosaicAssetD & BlendAssetVersionD\n ***      It derives from the ReadOnly derived handle (e.g. MosaicAsset) as well\n ***  as the generic daemon handle (e.g. AssetD)\n ******************************************************************************/\ntemplate <class ROBase_, class BaseD_, class Impl_>\nclass DerivedAssetHandleD_ : public virtual BaseD_, public ROBase_\n{\n public:\n  typedef Impl_ Impl;\n  typedef ROBase_ ROBase;\n  typedef BaseD_ BaseD;\n  typedef typename BaseD::Base BBase; // virtual base 'Asset' or 'Version'\n  typedef typename BBase::HandleType HandleType;\n protected:\n  // must overide both of these to verify that things match\n  // my 'Impl' type\n  virtual HandleType CacheFind(const std::string &boundref) const {\n    HandleType entry;\n    if (this->cache().Find(boundref, entry)) {\n      // we have to check if it maps to Impl* since somebody\n      // else may have put it in the cache\n      if (!dynamic_cast<Impl*>(&*entry)) {\n        entry = HandleType();\n      }\n    }\n    return entry;\n  }\n  virtual HandleType Load(const std::string &boundref) const {\n    // Impl::Load will succeed or throw.\n    // The derived khRefGuard will be automatically converted\n    // the the base khRefGuard\n    return HandleType(Impl::Load(boundref));\n  }\n public:\n  DerivedAssetHandleD_(void) : BBase(), BaseD(), ROBase() { }\n  DerivedAssetHandleD_(const std::string &ref_) :\n      BBase(ref_), BaseD(), ROBase() { }\n\n  // the compiler generated assignment and copy constructor are fine for us\n  // we have no addition members or semantics to maintain\n\n  const Impl* operator->(void) const {\n    this->Bind();\n    // we ensure that the base class handle always points to our derived\n    // type so this dynamic cast should never fail.  but it needs to be\n    // dynamic instead of static since we're casting from a virtual base\n    return dynamic_cast<const Impl*>(this->handle.operator->());\n  }\n};\n\n\n// ****************************************************************************\n// ***  Used for MutableAssetD & MutableAssetVersionD\n// ****************************************************************************\n\n\ntemplate <class Base_>\nclass MutableAssetHandleD_ : public virtual Base_ {\n  friend class khAssetManager;\n\n public:\n  typedef Base_ Base;\n  // our base also has a virtual base\n  typedef typename Base::Base BBase;\n  typedef typename Base::Impl Impl;\n\n  typedef std::map<std::string, Base> DirtyMap;\n  static DirtyMap dirtyMap;\n\n  // Test whether an asset is a project asset version.\n  static inline bool IsProjectAssetVersion(const std::string& assetName) {\n    return assetName.find(kProjectAssetVersionNumPrefix) != std::string::npos;\n  }\n\n  // Purge the cache if needed and keep recent \"toKeep\" items.\n  static void PurgeCacheIfNeeded(size_t toKeep) {\n    // Proceed only when the cache gets full.\n    if (Base::cache().size() < (Base::cache().capacity()) ||\n      // Don't proceed if there are no more than 1 mutable items to purge,\n      // since immutable items will be purged automatically by LRU cache.\n      dirtyMap.size() <= 1) {\n      return;\n    }\n    try {\n      // When there are more items to keep than cache's capacity,\n      // nothing can be purged and cache's capacity needs to be increased\n      // for better performance.\n      if (Base::cache().capacity() < toKeep) {\n        static bool warned = false;\n        if (!warned) {\n          notify(NFY_FATAL, \"You may need to increase cache capacity for \"\n            \"better performance: cache size %lu, cache capacity %lu, number \"\n            \"of items requested to keep %lu\", Base::cache().size(),\n            Base::cache().capacity(), toKeep);\n          warned = true;\n        }\n        return;\n      }\n\n      // Get old cache items that could be purged.\n      std::vector<std::string> toDelete;\n      Base::cache().GetOldKeys(toKeep, &toDelete);\n\n      // Skip project asset versions, which should always stay in the cache.\n      toDelete.erase(\n          std::remove_if(toDelete.begin(), toDelete.end(),\n              MutableAssetHandleD_::IsProjectAssetVersion),\n          toDelete.end());\n\n      // Save mutable items.\n      khFilesTransaction filetrans(\".new\");\n      for (std::vector<std::string>::iterator it = toDelete.begin();\n           it != toDelete.end(); ++it) {\n        if (dirtyMap.find(*it) != dirtyMap.end()) {\n          std::string filename = dirtyMap[*it]->XMLFilename() + \".new\";\n          if (dirtyMap[*it]->Save(filename)) {\n            filetrans.AddNewPath(filename);\n          }\n        }\n      }\n      if (!filetrans.Commit()) {\n        throw khException(\"Unable to commit file saving in cache purge.\");\n      }\n\n      // Discard saved mutable items from dirtyMap.\n      size_t dirties = dirtyMap.size();\n      for (std::vector<std::string>::iterator it = toDelete.begin();\n           it != toDelete.end(); ++it) {\n        if (dirtyMap.find(*it) != dirtyMap.end()) {\n          dirtyMap.erase(*it);\n        }\n      }\n\n      // Remove both immutable and mutable items from cache.\n      size_t cached = Base::cache().size();\n      for (std::vector<std::string>::iterator it = toDelete.begin();\n           it != toDelete.end(); ++it) {\n        Base::cache().Remove(*it, false);  // Do not prune for now.\n      }\n\n      // Prune the cache in the end.\n      Base::cache().Prune();\n\n      notify(NFY_INFO, \"cache size %lu, dirty map %lu, \"\n        \"assets to keep %lu, mutable assets purged %lu, total purged %lu\",\n        Base::cache().size(), dirtyMap.size(), toKeep,\n        dirties - dirtyMap.size(), cached - Base::cache().size());\n    }\n    catch (const std::runtime_error& e) {\n      notify(NFY_INFO, \"Exception in cache purge: %s\", e.what());\n    }\n  }\n\n protected:\n  virtual void OnBind(const std::string &boundref) const {\n    Base::OnBind(boundref);\n    // if already exists, old one will win, that's OK\n    dirtyMap.insert(std::make_pair(boundref, *this));\n  }\n\n  // must not throw since it's called during stack unwinding\n  static void AbortDirty(void) throw()\n  {\n    // remove all the dirty Impls from the cache\n    for (typename DirtyMap::const_iterator d = dirtyMap.begin();\n         d != dirtyMap.end(); ++d) {\n      Base::cache().Remove(d->first, false); // false -> don't prune\n    }\n    Base::cache().Prune(); // prune at the end to avoid possible prune thrashing\n\n    // now clear the dirtyMap itself\n    dirtyMap.clear();\n  }\n\n  static void PrintDirty(const std::string &header) {\n    if (dirtyMap.size()) {\n      fprintf(stderr, \"========== %d dirty %s ==========\\n\",\n              dirtyMap.size(), header.c_str());\n      for (typename DirtyMap::const_iterator d = dirtyMap.begin();\n           d != dirtyMap.end(); ++d) {\n        fprintf(stderr, \"%s -> %p\\n\",\n                d->first.c_str(), d->second.operator->());\n      }\n    }\n  }\n\n\n  static bool SaveDirtyToDotNew(khFilesTransaction &savetrans,\n                                std::vector<std::string> *saveDirty) {\n    for (typename DirtyMap::const_iterator d = dirtyMap.begin();\n         d != dirtyMap.end(); ++d) {\n      // TODO: - check to see if actually dirty\n      if ( 1 ) {\n        std::string filename = d->second->XMLFilename() + \".new\";\n        if (d->second->Save(filename)) {\n          savetrans.AddNewPath(filename);\n          if (saveDirty) {\n            saveDirty->push_back(d->first);\n          }\n        } else {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n\n  // the compiler generated assignment and copy constructor are fine for us\n  // ref & handle have stable copy semantics and we don't have to worry about\n  // adding to the dirtyMap because the src object will already have\n  // done that\n public:\n  MutableAssetHandleD_(void) : BBase(), Base() { }\n  MutableAssetHandleD_(const std::string &ref_) : BBase(ref_), Base() { }\n\n  // you should be able to create a mutable handle from the non-mutable\n  // equivalent. Don't automatically bind it and add it to the dirtyMap\n  // If they never use it via the MutableHandle it isn't really dirty\n  MutableAssetHandleD_(const Base &o) :\n      BBase(o.Ref()), Base() { }\n\n  // you should be able to create a mutable handle from the non-mutable,\n  // non-daemon equivalent. Don't automatically bind it and add it to\n  // the dirtyMap. If they never use it via the MutableHandle it isn't\n  // really dirty\n  MutableAssetHandleD_(const BBase &o) :\n      BBase(o.Ref()), Base() { }\n\n  using Base::operator->;\n  Impl* operator->(void) {\n    return const_cast<Impl*>(Base::operator->());\n  }\n};\n\n\n// ****************************************************************************\n// ***  MutableDerivedAssetHandleD_\n// ***\n// ***  Used for MutableMosaicAssetD & MutableBlendAssetVersionD\n// ****************************************************************************\ntemplate <class DerivedBase_, class MutableBase_>\nclass MutableDerivedAssetHandleD_ : public DerivedBase_, public MutableBase_\n{\n public:\n  typedef DerivedBase_ DerivedBase;\n  typedef MutableBase_ MutableBase;\n  typedef typename DerivedBase::Impl  Impl;\n  typedef typename DerivedBase::BBase BBase;  // vbase 'Asset' or 'Version'\n  typedef typename DerivedBase::BaseD BaseD;  // vbase 'AssetD' or 'VersionD'\n  typedef typename BBase::HandleType HandleType;\n protected:\n  // must overide these to resolve ambiguities\n  virtual HandleType CacheFind(const std::string &boundref) const {\n    return DerivedBase::CacheFind(boundref);\n  }\n  virtual HandleType Load(const std::string &boundref) const {\n    return DerivedBase::Load(boundref);\n  }\n  virtual void OnBind(const std::string &boundref) const {\n    return MutableBase::OnBind(boundref);\n  }\n\n public:\n  //    Only this leaf-most daemon handle can be constructed from\n  // the raw Impl. Rather than give all the base classes constructors\n  // that could be mistakenly used, this one will just do all the work\n  // iteself\n  //    This is public because the various {name}Factory classes must\n  // invoke this constructor and there is no way to declare it a friend\n  // here since we can't list the name\n  explicit MutableDerivedAssetHandleD_(const khRefGuard<Impl> &handle_) :\n      BBase(), BaseD(), DerivedBase(), MutableBase() {\n    this->handle = handle_;\n    if (this->handle) {\n      // we have a good handle\n\n      // record the ref - since it comes from GetRef() we don't have to\n      // call BindRef()\n      this->ref = this->handle->GetRef();\n\n      // add it to the cache\n      this->cache().Add(this->ref, this->handle);\n\n      // add it to the dirty list - since it just sprang into existence\n      // we need to make sure it get's saved\n      MutableBase::dirtyMap.insert(std::make_pair(this->ref, *this));\n    }\n  }\n\n public:\n  MutableDerivedAssetHandleD_(void) :\n      BBase(), BaseD(), DerivedBase(), MutableBase() { }\n  MutableDerivedAssetHandleD_(const std::string &ref_) :\n      BBase(ref_), BaseD(), DerivedBase(), MutableBase() { }\n\n  // you should be able to create a mutable handle from the non-mutable\n  // equivalent. Don't automatically bind it and add it to the dirtyMap\n  // If they never use it via the MutableHandle it isn't really dirty\n  MutableDerivedAssetHandleD_(const DerivedBase &o) :\n      BBase(o.Ref()), BaseD(), DerivedBase(), MutableBase() { }\n\n\n  // the compiler generated assignment and copy constructor are fine for us\n  // we have no addition members or semantics to maintain\n\n  using DerivedBase::operator->;\n  Impl* operator->(void) {\n    return const_cast<Impl*>(DerivedBase::operator->());\n  }\n};\n\n\n#endif /* __AssetHandleD_h */\n\n", "comment_ratio": 0.2238372093023256}
{"lang": "c", "code": "#pragma once\n\n#ifndef RTOS_PRIVATE_H\n#define RTOS_PRIVATE_H\n\n#ifdef RTOS_USE_ARDUINO\n    void init_arduino();\n#endif\n\nnamespace RTOS {\n\n    namespace Registers {\n\n        // A value that will be set with the bitwise ORed values of all active\n        // events\n        extern volatile Event_t events;\n\n        // The last trace that occured.\n        extern volatile Trace_t trace;\n\n        // Memory pool used for the allocation of tasks\n        extern Memory::Pool_t * task_pool;\n\n        // Current task being run\n        extern Task_t * current_task;\n\n        // Head of a task list used for periodic tasks\n        extern Task_t * periodic_tasks;\n\n        // Head of a task list used for delayed tasks\n        extern Task_t * delayed_tasks;\n\n        // Head of a task list used for event tasks\n        extern Task_t * event_tasks;\n\n        // Tail of a task list used for event tasks\n        extern Task_t * event_tasks_tail;\n\n    }\n\n    namespace Task {\n\n        // Special case, task is an event task when it enters, but a periodic task when it leaves\n        // Need to check if task has events on enter\n        // If it does, need to manually remove it from event_tasks after\n        // Not a big deal. Need to copy events anyways in order to clear the events register\n\n        /**\n         * Runs a task. Produces a trace for the start and stop of the task. If\n         * the task is an event task, all events it responded to will be \n         * cleared.\n         */\n        void run(Task_t * task);\n\n        /**\n         * Returns true if the task is expected to fit in the given time \n         * window.\n         * \n         * @param   Task_t * task the task\n         * @returns bool          true if the task fits\n         */\n        bool fits(Task_t * task, i64 time);\n\n        /**\n         * Returns the next task in a task list. If the provided task list has\n         * only a single item, nullptr is returned.\n         * \n         * @param   Task_t * tasks the task list\n         * @returns Task_t *       the next task in the list\n         */\n        Task_t * cdr(Task_t * tasks);\n\n        /**\n         * Inserts `task` as the tail of `tasks_tail`. \n         * \n         * @param   Task_t * tasks the tail of a task list\n         * @param   Task_t * task  the task to insert\n         * @returns Task_t *       the new tail of the task list\n         */\n        Task_t * insert_tail(Task_t * tasks_tail, Task_t * task);\n\n        /**\n         * Inserts `task` into `tasks` at an ordered position. Order is based \n         * which task should be scheduled next. If two tasks are scheduled for\n         * the same time the task that wa salready in `tasks` should appear\n         * first.\n         * \n         * @param Task_t * tasks the head of a task list\n         * @param Task_t * task  the task to insert\n         * @returns Task_t *     the new head of the task list\n         */\n        Task_t * insert_ordered(Task_t * tasks, Task_t * task);\n\n        /**\n         * Calculates the next time the given task is expected to be run.\n         * \n         * @param   Task_t * task the task\n         * @returns i64           the next expected time\n         */\n        i64 time_next(Task_t * task);\n\n        /**\n         * Calculates the time remaining for a given task and a given point in\n         * time. Time remaining is calulated by:\n         * \n         *   (last_time + period + delay) - time\n         * \n         * @param   Task_t * task the task\n         * @param   i64      time the time to measure from\n         * @returns i64           the remaining time\n         */\n        i64 time_remaining(Task_t * task, i64 time_ms);\n\n    }\n\n}\n\n#endif /* RTOS_PRIVATE_H */\n", "comment_ratio": 0.11016949152542373}
{"lang": "c", "code": "// heap sort a[1:n]\r\n#ifndef heapSort_\r\n#define heapSort_\r\n\r\n#include \"maxHeap.h\"\r\n\r\nusing namespace std;\r\n\r\ntemplate <class T>\r\nvoid heapSort(T a[], int n)\r\n{// Sort a[1:n] using the heap sort method.\r\n   // create a max heap of the elements\r\n   maxHeap<T> heap(1);\r\n   heap.initialize(a, n);\r\n\r\n   // extract one by one from the max heap\r\n   for (int i = n - 1; i >= 1; i--)\r\n   {\r\n      T x = heap.top();\r\n      heap.pop();\r\n      a[i+1] = x;\r\n   }\r\n\r\n   // save array a from heap destructor\r\n   heap.deactivateArray();\r\n}\r\n\r\n#endif\r\n\n", "comment_ratio": 0.1724137931034483}
{"lang": "c", "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n//#region TAIL FACTORIAL\n/**\n * Factorial function with tail impementation\n * @param n number entered\n * @param tail tail init value\n * @return factorial of n\n */\nunsigned long long factorialTail(unsigned long long n, unsigned long long tail) {\n    return n == 0 ? tail : factorialTail(n-1, n * tail);\n}\n//#endregion\n\n//#region NEXT PRIME\n/**\n * Finds the next prime after n\n * @param n number entered\n * @return next prime number\n */\nunsigned long long nextPrime(unsigned long long n) {\n    // quantity of divisors\n    int div = 0;\n    // only breaks when div = 1, which means  only was divided by 1\n    while(div != 1) {\n        // resets div every run\n        div = 0;\n        // increments number\n        n++;\n        // see quantity of divisors in n\n        for (unsigned long long i = 1; i < n; i++) {\n            if (n % i == 0) {\n                div++;\n            }\n        }\n    }\n    return n;\n}\n//#endregion\n\n//#region PRIME OMEGA FUNCTION\n/**\n * prime omega function in math\n * @param n\n * @return number of different prime divisors\n */\nunsigned long long primeOmegaFunction(unsigned long long n) {\n    // sets the size of the primediv array, and second n for verification\n    unsigned long long size = 0,nlast = n;\n    // array of prime numbers\n    unsigned long long *primediv;\n    // executes until n is fully factored\n    while(n != 1) {\n        // verifies if size is 0, first case\n        if(size == 0) {\n            // sets size of primediv to 1, and first primediv[0] first prime number\n            primediv = (unsigned long long *) calloc(++size, sizeof(unsigned long long));\n            primediv[0] = 2;\n        // verifies if n is divisible by current prime number\n        }else if(n % primediv[size - 1] == 0) {\n            // divides n\n            n /= primediv[size - 1];\n        // if n is not divisible then verifies if n was actually divided or not\n        } else if(nlast != n){\n            // resizes primediv for next number\n            primediv = (unsigned long long *) realloc(primediv, ++size * sizeof(unsigned long long));\n            // adds next prime number in the next element\n            primediv[size - 1] = nextPrime(primediv[size - 2]);\n            nlast = n;\n        // case n wasn't divided means n is not factorable by current number\n        } else {\n            // updates prime number without changing size\n            primediv[size - 1] = nextPrime(primediv[size - 1]);\n        }\n    }\n    // frees the memory used\n    free(primediv);\n    return size;\n}\n//#endregion\n\n//#region FIND DIVISORS FUNCTION\n/**\n * Function to find number of divisors or particullar divisor,\n * in decremental order,\n * ex.: if n = 6 returns 6 when n_div = 1,3 when n_div = 2,...\n * @param n number\n * @param n_div number of divisor, 0 equals to find all divisors\n * @return number of divisors of n or particullar divisor of n\n */\nunsigned long long findDivisorsFunction(unsigned long long n, int n_div) {\n    // number of divisors of n\n    unsigned long long div = 0;\n    for(unsigned long long i = 1; i <= n; i++) {\n        // verifies if n is divisible by i\n        if(n % i == 0) {\n            // increments divisor\n            div++;\n\n            if(div > 8 || n % 256 == 0 || n % 6561 == 0 ||\n                n % 390625 == 0 || n % 576481 == 0 || n % 214358881 == 0)\n                return 1;\n            // what n_div == 0 means is to find all divisors\n            else if(n_div == 0)\n                continue;\n            // if n_div != 0 means to find n_div divisor\n            else if(n_div == div)\n                return i;\n        }\n    }\n    return div;\n}\n//#endregion\n\n//#region SUMMATORY SPECIAL FUNCTION\nunsigned long long summatorySpecialFunction(unsigned long long n) {\n    unsigned long long sum = 0;\n    for (unsigned long long i = 1; i < n; i++) {\n        if (findDivisorsFunction(i,0) == 8)\n            sum++;\n        printf(\"%llu\\n\",i);\n    }\n    return sum;\n}\n//#endregion\n\nint main() {\n    printf(\"%llu\",summatorySpecialFunction(pow(10,7)));\n    return 0;\n}\n\n", "comment_ratio": 0.24812030075187969}
{"lang": "c", "code": "//\n//  PiPanoSDK.h\n//  Unity-iPhone\n//\n//  Created by forest on 2017/5/18.\n//\n//\n\n#ifndef PiPano_Specific_h\n#define PiPano_Specific_h\n\n#import \"PiPano.h\"\n\n@interface PiPano (Specific)\n\n+(PiViewMode) defaultViewMode;\n\n+(PiSourceMode) defaultSourceMode;\n\n+(PiCameraDirection) defaultCameraDir;\n\n/**\n \u89e3\u7801 H264\u89c6\u9891\u6d41\u7684\u4e00\u5e27\uff0c\u89e3\u7801\u6210\u529f\u540e\u7b49\u5f85\u88ab\u6e32\u67d3\u3002\n \u5982\u679c\u4f60\u7684\u4ea7\u54c1\u6ca1\u6709\u89c6\u9891\u89e3\u7801\u529f\u80fd\uff0c\u8bf7\u5728\u83b7\u53d6\u5230\u89c6\u9891\u6d41\u540e\u8c03\u7528\u8fd9\u4e2a\u65b9\u6cd5\u89e3\u7801\u3002\n \n @param nalu_data \u4e00\u5e27h264\u683c\u5f0f\u7684\u89c6\u9891\u6d41\u6570\u636e\n @param nalu_size \u6570\u636e\u5927\u5c0f\n @return \u89e3\u7801\u7ed3\u679c\u7684\u9519\u8bef\u7801\n */\n+(int) decodeH264VideoFrame:(unsigned char*) nalu_data dataSize:(int) nalu_size;\n\n/**\n \u83b7\u53d6PiPanoSDK\u7248\u672c\u53f7\n\n @return \u4e00\u4e32\u6570\u5b57\u7684\u7248\u672c\u53f7\n */\n+(NSString*) getVersion;\n\n\n/**\n \u83b7\u53d6PiPanoSDK build\u7248\u672c\u53f7\n\n @return \u5e26\u6709version key\u7684\u7248\u672c\u53f7\n */\n+(NSString*) getBuildVersionString;\n\n\n/**\n \u83b7\u53d6\u7248\u6b21\u540d\n \n @return \u7248\u6b21\u540d\uff0c\u6bd4\u5982\uff1aPiPanoSDKBasic\n */\n+(NSString*) getEditionName;\n\n\n@end\n\n#endif /* PiPano_Specific_h */\n\n", "comment_ratio": 0.11864406779661017}
{"lang": "c", "code": "#pragma once\n\n#include <atomic>\n#include <cstdint>\n#include <memory>\n#include <string>\n\n#include \"arrow/status.h\"\n#include \"arrow/type_fwd.h\"\n#include \"arrow/util/visibility.h\"\n\nnamespace arrow {\n\nnamespace internal {\n\n///////////////////////////////////////////////////////////////////////\n// Helper tracking memory statistics\n\nclass MemoryPoolStats {\n public:\n  MemoryPoolStats() : bytes_allocated_(0), max_memory_(0) {}\n\n  int64_t max_memory() const { return max_memory_.load(); }\n\n  int64_t bytes_allocated() const { return bytes_allocated_.load(); }\n\n  inline void UpdateAllocatedBytes(int64_t diff) {\n    auto allocated = bytes_allocated_.fetch_add(diff) + diff;\n    // \"maximum\" allocated memory is ill-defined in multi-threaded code,\n    // so don't try to be too rigorous here\n    if (diff > 0 && allocated > max_memory_) {\n      max_memory_ = allocated;\n    }\n  }\n\n protected:\n  std::atomic<int64_t> bytes_allocated_;\n  std::atomic<int64_t> max_memory_;\n};\n\n}  // namespace internal\n\n/// Base class for memory allocation on the CPU.\n///\n/// Besides tracking the number of allocated bytes, the allocator also should\n/// take care of the required 64-byte alignment.\nclass ARROW_EXPORT MemoryPool {\n public:\n  virtual ~MemoryPool() = default;\n\n  /// \\brief EXPERIMENTAL. Create a new instance of the default MemoryPool\n  static std::unique_ptr<MemoryPool> CreateDefault();\n\n  /// Allocate a new memory region of at least size bytes.\n  ///\n  /// The allocated region shall be 64-byte aligned.\n  virtual Status Allocate(int64_t size, uint8_t** out) = 0;\n\n  /// Resize an already allocated memory section.\n  ///\n  /// As by default most default allocators on a platform don't support aligned\n  /// reallocation, this function can involve a copy of the underlying data.\n  virtual Status Reallocate(int64_t old_size, int64_t new_size, uint8_t** ptr) = 0;\n\n  /// Free an allocated region.\n  ///\n  /// @param buffer Pointer to the start of the allocated memory region\n  /// @param size Allocated size located at buffer. An allocator implementation\n  ///   may use this for tracking the amount of allocated bytes as well as for\n  ///   faster deallocation if supported by its backend.\n  virtual void Free(uint8_t* buffer, int64_t size) = 0;\n\n  /// Return unused memory to the OS\n  ///\n  /// Only applies to allocators that hold onto unused memory.  This will be\n  /// best effort, a memory pool may not implement this feature or may be\n  /// unable to fulfill the request due to fragmentation.\n  virtual void ReleaseUnused() {}\n\n  /// The number of bytes that were allocated and not yet free'd through\n  /// this allocator.\n  virtual int64_t bytes_allocated() const = 0;\n\n  /// Return peak memory allocation in this memory pool\n  ///\n  /// \\return Maximum bytes allocated. If not known (or not implemented),\n  /// returns -1\n  virtual int64_t max_memory() const;\n\n  /// The name of the backend used by this MemoryPool (e.g. \"system\" or \"jemalloc\").\n  virtual std::string backend_name() const = 0;\n\n protected:\n  MemoryPool() = default;\n};\n\nclass ARROW_EXPORT LoggingMemoryPool : public MemoryPool {\n public:\n  explicit LoggingMemoryPool(MemoryPool* pool);\n  ~LoggingMemoryPool() override = default;\n\n  Status Allocate(int64_t size, uint8_t** out) override;\n  Status Reallocate(int64_t old_size, int64_t new_size, uint8_t** ptr) override;\n\n  void Free(uint8_t* buffer, int64_t size) override;\n\n  int64_t bytes_allocated() const override;\n\n  int64_t max_memory() const override;\n\n  std::string backend_name() const override;\n\n private:\n  MemoryPool* pool_;\n};\n\n/// Derived class for memory allocation.\n///\n/// Tracks the number of bytes and maximum memory allocated through its direct\n/// calls. Actual allocation is delegated to MemoryPool class.\nclass ARROW_EXPORT ProxyMemoryPool : public MemoryPool {\n public:\n  explicit ProxyMemoryPool(MemoryPool* pool);\n  ~ProxyMemoryPool() override;\n\n  Status Allocate(int64_t size, uint8_t** out) override;\n  Status Reallocate(int64_t old_size, int64_t new_size, uint8_t** ptr) override;\n\n  void Free(uint8_t* buffer, int64_t size) override;\n\n  int64_t bytes_allocated() const override;\n\n  int64_t max_memory() const override;\n\n  std::string backend_name() const override;\n\n private:\n  class ProxyMemoryPoolImpl;\n  std::unique_ptr<ProxyMemoryPoolImpl> impl_;\n};\n\n/// \\brief Return a process-wide memory pool based on the system allocator.\nARROW_EXPORT MemoryPool* system_memory_pool();\n\n/// \\brief Return a process-wide memory pool based on jemalloc.\n///\n/// May return NotImplemented if jemalloc is not available.\nARROW_EXPORT Status jemalloc_memory_pool(MemoryPool** out);\n\n/// \\brief Set jemalloc memory page purging behavior for future-created arenas\n/// to the indicated number of milliseconds. See dirty_decay_ms and\n/// muzzy_decay_ms options in jemalloc for a description of what these do. The\n/// default is configured to 1000 (1 second) which releases memory more\n/// aggressively to the operating system than the jemalloc default of 10\n/// seconds. If you set the value to 0, dirty / muzzy pages will be released\n/// immediately rather than with a time decay, but this may reduce application\n/// performance.\nARROW_EXPORT\nStatus jemalloc_set_decay_ms(int ms);\n\n/// \\brief Return a process-wide memory pool based on mimalloc.\n///\n/// May return NotImplemented if mimalloc is not available.\nARROW_EXPORT Status mimalloc_memory_pool(MemoryPool** out);\n\nARROW_EXPORT std::vector<std::string> SupportedMemoryBackendNames();\n\n}  // namespace arrow\n\n", "comment_ratio": 0.3817204301075269}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n\n@interface SDMouseFollower : NSObject\n\n+ (SDMouseFollower*) sharedFollower;\n\n- (void) startListening;\n\n@end\n\n", "comment_ratio": 0.3888888888888889}
{"lang": "c", "code": "#ifndef __BaseCat_Stream__\r\n#define __BaseCat_Stream__\r\n\r\n#include \"SystemBase.h\"\r\n#include \"SmartHeap.h\"\r\n\r\nnamespace BaseCat\r\n{\r\n    namespace System\r\n    {\r\n        namespace Stream\r\n        {\r\n            typedef struct _Handle\r\n            {\r\n            } *Handle;\r\n\r\n            SYSTEM_API Handle __stdcall CreateHandle(void);\r\n            SYSTEM_API void __stdcall DestroyHandle(Handle stream);\r\n\r\n            SYSTEM_API size_t __stdcall Read(Handle stream, void *p, size_t size);\r\n            SYSTEM_API size_t __stdcall Write(Handle stream, const void *p, size_t size);\r\n            SYSTEM_API size_t __stdcall Peek(Handle stream, void *p, size_t size);\r\n            SYSTEM_API size_t __stdcall RemoveLeft(Handle stream, size_t size);\r\n            SYSTEM_API size_t __stdcall RemoveRight(Handle stream, size_t size);\r\n            SYSTEM_API bool __stdcall Clear(Handle stream);\r\n            SYSTEM_API size_t __stdcall GetLength(Handle stream);\r\n\r\n            SYSTEM_API bool __stdcall Attach(Handle stream, SmartHeap::Block p);\r\n            SYSTEM_API SmartHeap::Block __stdcall Detach(Handle stream);\r\n            SYSTEM_API SmartHeap::Block __stdcall GetRawPtr(Handle stream);\r\n\r\n            SYSTEM_API Handle __stdcall Clone(Handle stream);\r\n        }\r\n    }\r\n}\r\n\r\n#endif\r\n\n", "comment_ratio": 0.2909090909090909}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n@class ZHDPOption;// \u64cd\u4f5c\u680f\n@class ZHDPContent;// \u5185\u5bb9\u5217\u8868\u5bb9\u5668\n\ntypedef NS_ENUM(NSInteger, ZHDebugPanelStatus) {\n    ZHDebugPanelStatus_Unknown     = 0,\n    ZHDebugPanelStatus_Show      = 1,\n    ZHDebugPanelStatus_Hide      = 2,\n};\n\n@interface ZHDebugPanel : UIView\n@property (nonatomic,assign) ZHDebugPanelStatus status;\n\n@property (nonatomic,strong) ZHDPOption *option;\n@property (nonatomic,strong) ZHDPContent *content;\n@end\n\n", "comment_ratio": 0.36}
{"lang": "c", "code": "// This file was generated based on '/usr/local/share/uno/Packages/Fuse.Navigation/0.24.6/$.uno'.\n// WARNING: Changes might be lost if you edit this file directly.\n\n#pragma once\n#include <Uno.Object.h>\nnamespace g{namespace Fuse{namespace Navigation{struct UpdateSeekArgs;}}}\n\nnamespace g{\nnamespace Fuse{\nnamespace Navigation{\n\n// public sealed class UpdateSeekArgs :1691\n// {\nuType* UpdateSeekArgs_typeof();\nvoid UpdateSeekArgs__ctor__fn(UpdateSeekArgs* __this, float* delta, float* distance, float* scale, double* time);\nvoid UpdateSeekArgs__get_Delta_fn(UpdateSeekArgs* __this, float* __retval);\nvoid UpdateSeekArgs__set_Delta_fn(UpdateSeekArgs* __this, float* value);\nvoid UpdateSeekArgs__get_Distance_fn(UpdateSeekArgs* __this, float* __retval);\nvoid UpdateSeekArgs__set_Distance_fn(UpdateSeekArgs* __this, float* value);\nvoid UpdateSeekArgs__New1_fn(float* delta, float* distance, float* scale, double* time, UpdateSeekArgs** __retval);\nvoid UpdateSeekArgs__get_RelativeDelta_fn(UpdateSeekArgs* __this, float* __retval);\nvoid UpdateSeekArgs__get_RelativeDistance_fn(UpdateSeekArgs* __this, float* __retval);\n\nstruct UpdateSeekArgs : uObject\n{\n    float _scale;\n    double _time;\n    float _Delta;\n    float _Distance;\n\n    void ctor_(float delta, float distance, float scale, double time);\n    float Delta();\n    void Delta(float value);\n    float Distance();\n    void Distance(float value);\n    float RelativeDelta();\n    float RelativeDistance();\n    static UpdateSeekArgs* New1(float delta, float distance, float scale, double time);\n};\n// }\n\n}}} // ::g::Fuse::Navigation\n\n", "comment_ratio": 0.13953488372093023}
{"lang": "c", "code": "#pragma once\n#include \"base.h\"\n\n\nbool IsKeyDown(SDL_Scancode key);\nVec2i GetMousePosition(void);\n\n// SDL_BUTTON_LEFT / SDL_BUTTON_RIGHT\nbool IsMouseKeyDown(int key);\nbool IsMouseOver(SDL_Rect shape);\n\n// CONTROLLERS //\n\nvoid InitController();\nvoid CloseController();\nbool IsControllerKeyDown(int key);\n\n", "comment_ratio": 0.11764705882352941}
{"lang": "c", "code": "#include \"checksum.h\"\n\n#ifdef _MSC_VER\n#  define FORCE_INLINE __forceinline\n#else\n#  ifdef __GNUC__\n#    if __GNUC__ < 3\n#      define FORCE_INLINE inline\n#    else\n#      define FORCE_INLINE inline __attribute__ ((always_inline))\n#    endif\n#  else\n#    define FORCE_INLINE inline\n#  endif\n#endif\n\n/* ------------------------ CRC32 checksum calculation ----------------- */\n\nUINT CRCTable[256];\nBOOL bInitCRC = FALSE;\n\nFORCE_INLINE void InitCRC() {\n  int i, j; unsigned long c;\n  for (c = i = 0; i < 256; c = ++i) {\n    for (j = 0; j < 8; j++) {\n      if (c & 1) c = (c>>1) ^ 0xEDB88320;\n      else       c >>= 1;\n    }\n    CRCTable[i] = c;\n  }\n  bInitCRC = TRUE;\n}\n\n#define CRCBLOCKSIZE    4096\n\nBOOL FileCRC(HANDLE hFile, DWORD *crc) {\n  static BYTE crcblock[CRCBLOCKSIZE];\n  DWORD read;\n  BYTE *p;\n\n  UINT c = 0xFFFFFFFF;\n  if (bInitCRC == FALSE)\n    InitCRC();\n  \n  SetFilePointer(hFile, 0, NULL, FILE_BEGIN);\n  do {\n    if (ReadFile(hFile, crcblock, CRCBLOCKSIZE, &read, NULL) == FALSE)\n      return FALSE;\n    for (p = crcblock; p < crcblock + read; p++)\n      c = CRCTable[(c & 0xFF) ^ *p] ^ (c >> 8);\n  } while (read);\n\n  *crc = (c ^ 0xFFFFFFFF);\n\n  return TRUE;\n}\n\nvoid CRC32ToString(char* string, DWORD crc) {\n  int i = 0;\n  int j = 7;\n  int a1, a2;\n  for(i = 0; i < 4; i++) {\n    a1 = (crc >> 4) % 16;\n    a2 = crc % 16;\n    string[j--] = a2 < 10 ? ('0' + a2) : ('A' + a2 - 10);\n    string[j--] = a1 < 10 ? ('0' + a1) : ('A' + a1 - 10);\n    crc = crc >> 8;\n  }\n}\n\n/* ------------------------ MD5 checksum calculation ----------------- */\n\n#define MD5BLOCKSIZE    16384\n\nBOOL FileMD5(HANDLE hFile, md5_byte_t digest[16]) {\n  static BYTE md5block[MD5BLOCKSIZE];\n  DWORD read;\n\n  md5_state_t state;\n  \n  md5_init(&state);\n \n  SetFilePointer(hFile, 0, NULL, FILE_BEGIN);\n  do {\n    if (ReadFile(hFile, md5block, MD5BLOCKSIZE, &read, NULL) == FALSE)\n      return FALSE;\n    md5_append(&state, md5block, read);\n  } while (read);\n\n  md5_finish(&state, digest);\n  return TRUE;\n}\n\nvoid MD5ToString(char* string, md5_byte_t checksum[16]) {\n  int i = 0;\n  int j = 0;\n  int a1, a2;\n  for(i = 0; i < 16; i++) {\n    a1 = (checksum[i] >> 4) % 16;\n    a2 = checksum[i] % 16;\n    string[j++] = a1 < 10 ? ('0' + a1) : ('A' + a1 - 10);\n    string[j++] = a2 < 10 ? ('0' + a2) : ('A' + a2 - 10);\n  }\n}\n\n", "comment_ratio": 0.18461538461538463}
{"lang": "c", "code": "#ifndef SIMPLE_MAHJONG_SIMPLE_GAME_H\n#define SIMPLE_MAHJONG_SIMPLE_GAME_H\n\n#include <string>\n\n#include <Board.h>\n#include <Game.h>\n\nnamespace mahjong {\nclass SimpleGame : public Game {\n public:\n    SimpleGame(Player *p1, Player *p2, Player *p3, Player *p4, int roundCount);\n    ~SimpleGame() {\n        delete mBoard;\n    }\n\n    void startGame() override;\n\n    // Callback interfaces.\n    void onRoundSetup() override { /* Not used */ }\n    void onRoundStart() override;\n    void onBeforePlayerPickTile(Player *player, Tile tile) override;\n    void onAfterPlayerPickTile(Player *player, Tile tile) override;\n    void onPlayerDiscardTile(Player *player, Tile tile) override;\n    void onPlayerPass(Player *player) override;\n    void onRoundFinished(bool drained, Player *winner) override;\n    void onNextRound(bool eastWin) override;\n\n    void onGameOver() override;\n\n    // Rule interfaces.\n    int calculateScore(Hand mHand) override;\n\n private:\n    std::map<Player *, int> mPlayerWinCount;\n    Board *mBoard;\n\n    void printPlayer(Player *p);\n    void printBoard();\n};\n} // namespace mahjong.\n\n#endif // SIMPLE_MAHJONG_SIMPLE_GAME_H\n", "comment_ratio": 0.3220338983050847}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n\n\n@protocol OTHomeCategoryViewDelegate <NSObject>\n\n@optional\n- (void)didSelectHomeCategoryViewItemIndex:(NSInteger)index;\n\n@end\n\n@interface OTHomeCategoryView : UIView\n\n@property (nonatomic, weak) id<OTHomeCategoryViewDelegate>              delegate;\n@property (nonatomic, strong) NSArray                                   *cateList;\n@property (nonatomic, strong) UICollectionView                          *collectionView;\n\n- (void)collectionViewScrollToCellIndex:(NSInteger)index;\n\n@end\n\n", "comment_ratio": 0.27586206896551724}
{"lang": "c", "code": "#ifndef OBSGetBucketWebsiteModel_h\n#define OBSGetBucketWebsiteModel_h\n#import \"OBSBaseModel.h\"\n#import \"OBSBaseNetworking.h\"\n#import \"OBSClient.h\"\n#import \"OBSServiceBaseModel.h\"\n#import \"OBSServiceCommonEntities.h\"\n#import \"OBSServiceConstDefinition.h\"\n\n\n#pragma mark - request\n\n/**\n \u83b7\u53d6\u7f51\u7ad9\u6258\u7ba1\u914d\u7f6e\n */\n@protocol OBSGetBucketWebsiteProtocol\n@required\n\n/**\n \u6876\u540d\n */\n@property (nonatomic, strong, nonnull) NSString *bucketName;\n@end\n\n\n/**\n \u83b7\u53d6\u6876\u9759\u6001\u7f51\u7ad9\u6258\u7ba1\u914d\u7f6e\n */\n@interface OBSGetBucketWebsiteRequest: OBSBaseRequest<OBSGetBucketWebsiteProtocol>\n\n/**\n \u6876\u540d\n */\n@property (nonatomic, strong, nonnull) NSString *bucketName;\n\n/**\n \u521d\u59cb\u5316\u83b7\u53d6\u6876\u9759\u6001\u7f51\u7ad9\u6258\u7ba1\u914d\u7f6erequest\n\n @param bucketName \u6876\u540d\n @return \u83b7\u53d6\u6876\u9759\u6001\u7f51\u7ad9\u6258\u7ba1\u914d\u7f6e\n */\n-(instancetype)initWithBucketName:(NSString*) bucketName;\n@end\n\n#pragma mark - networking request\n@interface OBSGetBucketWebsiteRequestNetworking : OBSServiceNetworkingCommandRequest\n@end\n\n    //response\n#pragma mark - response\n\n/**\n \u83b7\u53d6\u6876\u9759\u6001\u7f51\u7ad9\u6258\u7ba1\u914d\u7f6eresponse\n */\n@interface OBSGetBucketWebsiteResponse: OBSServiceResponse\n\n/**\n \u9759\u6001\u7f51\u7ad9\u6258\u7ba1\u914d\u7f6e\n */\n@property (nonatomic, strong, nonnull) __kindof OBSAbstractWebsiteConf *configuration;\n@end\n\n\n#pragma mark - client method\n@interface OBSClient(getBucketWebsite)\n\n/**\n \u83b7\u53d6\u6876\u9759\u6001\u7f51\u7ad9\u6258\u7ba1\u914d\u7f6e\n\n @param request \u83b7\u53d6\u6876\u9759\u6001\u7f51\u7ad9\u6258\u7ba1\u914d\u7f6erequest\n @param completionHandler \u83b7\u53d6\u6876\u9759\u6001\u7f51\u7ad9\u6258\u7ba1\u914d\u7f6e\u56de\u8c03\n @return OBSBFTask\n */\n- (OBSBFTask*)getBucketWebsite:(__kindof OBSBaseRequest<OBSGetBucketWebsiteProtocol>*)request\n            completionHandler:(void (^)(OBSGetBucketWebsiteResponse  * response, NSError * error))completionHandler;\n@end\n\n#endif /* OBSGetBucketWebsiteModel_h */\n\n", "comment_ratio": 0.13186813186813187}
{"lang": "c", "code": "#ifndef Socket_class\n#define Socket_class\n\n\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <netdb.h>\n#include <unistd.h>\n#include <string>\n#include <arpa/inet.h>\n\n\nconst int MAXHOSTNAME = 200;\nconst int MAXCONNECTIONS = 5;\nconst int MAXRECV = 1000000;\n\nclass Socket\n{\n public:\n  Socket();\n  virtual ~Socket();\n\n  // Server initialization\n  bool create();\n  bool bind ( const int port );\n  bool listen() const;\n  bool accept ( Socket& ) const;\n\n  // Client initialization\n  bool connect ( const std::string host, const int port );\n\n  // Data Transimission\n  bool send ( const std::string ) const;\n  int recv ( std::string& ) const;\n\n\n  void set_non_blocking ( const bool );\n\n  bool is_valid() const { return m_sock != -1; }\n\n private:\n\n  int m_sock;\n  sockaddr_in m_addr;\n\n\n};\n\n\n#endif\n\n", "comment_ratio": 0.1}
{"lang": "c", "code": "#include \"aardvark.h\"\n#include <stdio.h>\n#include <stdlib.h>\n\n//=========================================================================\n// CONSTANTS\n//=========================================================================\n#define BUFFER_SIZE 65535\n\n#define SLAVE_RESP_SIZE 26\n\n#define INTERVAL_TIMEOUT 500\n\n//=========================================================================\n// FUNCTIONS\n//=========================================================================\nstatic u08 data_in[BUFFER_SIZE];\n\nstatic void dump(Aardvark handle, int timeout_ms)\n{\n\tint trans_num = 0;\n\tint result;\n\tu08 addr;\n\n\tprintf(\"Watching slave I2C data...\\n\");\n\n\t// Wait for data on bus\n\tresult = aa_async_poll(handle, timeout_ms);\n\tif(result == AA_ASYNC_NO_DATA)\n\t{\n\t\tprintf(\"No data available.\\n\");\n\t\treturn;\n\t}\n\n\tprintf(\"\\n\");\n\n\t// Loop until aa_async_poll times out\n\tfor(;;)\n\t{\n\t\t// Read the I2C message.\n\t\t// This function has an internal timeout (see datasheet), though\n\t\t// since we have already checked for data using aa_async_poll,\n\t\t// the timeout should never be exercised.\n\t\tif(result == AA_ASYNC_I2C_READ)\n\t\t{\n\t\t\t// Get data written by master\n\t\t\tint num_bytes = aa_i2c_slave_read(handle, &addr, BUFFER_SIZE, data_in);\n\t\t\tint i;\n\n\t\t\tif(num_bytes < 0)\n\t\t\t{\n\t\t\t\tprintf(\"error: %s\\n\", aa_status_string(num_bytes));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Dump the data to the screen\n\t\t\tprintf(\"*** Transaction #%02d\\n\", trans_num);\n\t\t\tprintf(\"Data read from master:\");\n\t\t\tfor(i = 0; i < num_bytes; ++i)\n\t\t\t{\n\t\t\t\tif((i & 0x0f) == 0)\n\t\t\t\t\tprintf(\"\\n%04x:  \", i);\n\t\t\t\tprintf(\"%02x \", data_in[i] & 0xff);\n\t\t\t\tif(((i + 1) & 0x07) == 0)\n\t\t\t\t\tprintf(\" \");\n\t\t\t}\n\t\t\tprintf(\"\\n\\n\");\n\t\t}\n\n\t\telse if(result == AA_ASYNC_I2C_WRITE)\n\t\t{\n\t\t\t// Get number of bytes written to master\n\t\t\tint num_bytes = aa_i2c_slave_write_stats(handle);\n\n\t\t\tif(num_bytes < 0)\n\t\t\t{\n\t\t\t\tprintf(\"error: %s\\n\", aa_status_string(num_bytes));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Print status information to the screen\n\t\t\tprintf(\"*** Transaction #%02d\\n\", trans_num);\n\t\t\tprintf(\"Number of bytes written to master: %04d\\n\", num_bytes);\n\n\t\t\tprintf(\"\\n\");\n\t\t}\n\n\t\telse\n\t\t{\n\t\t\tprintf(\"error: non-I2C asynchronous message is pending\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\t++trans_num;\n\n\t\t// Use aa_async_poll to wait for the next transaction\n\t\tresult = aa_async_poll(handle, INTERVAL_TIMEOUT);\n\t\tif(result == AA_ASYNC_NO_DATA)\n\t\t{\n\t\t\tprintf(\"No more data available from I2C master.\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n//=========================================================================\n// MAIN PROGRAM\n//=========================================================================\nint main(int argc, char* argv[])\n{\n\tAardvark handle;\n\n\tint port = 0;\n\tu08 addr = 0;\n\tint timeout_ms = 0;\n\n\tu08 slave_resp[SLAVE_RESP_SIZE];\n\tint i;\n\n\tif(argc < 4)\n\t{\n\t\tprintf(\"usage: aai2c_slave PORT SLAVE_ADDR TIMEOUT_MS\\n\");\n\t\tprintf(\"  SLAVE_ADDR is the slave address for this device\\n\");\n\t\tprintf(\"\\n\");\n\t\tprintf(\"  The timeout value specifies the time to\\n\");\n\t\tprintf(\"  block until the first packet is received.\\n\");\n\t\tprintf(\"  If the timeout is -1, the program will\\n\");\n\t\tprintf(\"  block indefinitely.\\n\");\n\t\treturn 1;\n\t}\n\n\tport = atoi(argv[1]);\n\taddr = (u08)strtol(argv[2], 0, 0);\n\ttimeout_ms = atoi(argv[3]);\n\n\t// Open the device\n\thandle = aa_open(port);\n\tif(handle <= 0)\n\t{\n\t\tprintf(\"Unable to open Aardvark device on port %d\\n\", port);\n\t\tprintf(\"Error code = %d\\n\", handle);\n\t\treturn 1;\n\t}\n\n\t// Ensure that the I2C subsystem is enabled\n\taa_configure(handle, AA_CONFIG_SPI_I2C);\n\n\t// Disable the Aardvark adapter's power pins.\n\t// This command is only effective on v2.0 hardware or greater.\n\t// The power pins on the v1.02 hardware are not enabled by default.\n\taa_target_power(handle, AA_TARGET_POWER_NONE);\n\n\t// Set the slave response; this won't be used unless the master\n\t// reads bytes from the slave.\n\tfor(i = 0; i < SLAVE_RESP_SIZE; ++i)\n\t\tslave_resp[i] = 'A' + i;\n\n\taa_i2c_slave_set_response(handle, SLAVE_RESP_SIZE, slave_resp);\n\n\t// Enable the slave\n\taa_i2c_slave_enable(handle, addr, 0, 0);\n\n\t// Watch the I2C port\n\tdump(handle, timeout_ms);\n\n\t// Disable the slave and close the device\n\taa_i2c_slave_disable(handle);\n\taa_close(handle);\n\n\treturn 0;\n}\n\n", "comment_ratio": 0.165}
{"lang": "c", "code": "#ifndef __MHI_DUT_INCLUDED_H\r\n#define __MHI_DUT_INCLUDED_H\r\n//---------------------------------------------------------------------------------\r\n//\t\t\t\t\t\tIncludes\t\t\t\t\t\t\t\t\t\r\n//---------------------------------------------------------------------------------\r\n#include \"mhi_ieee_address.h\"\r\n#include \"mhi_mib_id.h\"\r\n\r\n\r\n#define   MTLK_PACK_ON\r\n#include \"mtlkpack.h\"\r\n\r\n//---------------------------------------------------------------------------------\r\n//\t\t\t\t\t\tDefines\t\t\t\t\t\t\t\t\t\r\n//---------------------------------------------------------------------------------\r\n#define TPC_ARRAY_SIZE\t\t\t\t\t(3)\r\n#define DUT_3ANT_ARRAY\t\t\t\t\t(3)\r\n#define DUT_4ANT_ARRAY\t\t\t\t\t(4)\r\n\r\n#define BIST_RESULTS_ARRAY_SIZE\t\t\t(7) \r\n\r\n#define UMI_DEBUG_BLOCK_SIZE            (384)\r\n#define UMI_C100_DATA_SIZE   (UMI_DEBUG_BLOCK_SIZE - (sizeof(uint16) + sizeof(uint16) + sizeof(C100_MSG_HEADER)))\r\n#define UMI_DEBUG_DATA_SIZE  (UMI_DEBUG_BLOCK_SIZE - (sizeof(uint16) + sizeof(uint16)))\r\n#define DUT_MSG_HEADER_LENGTH\t\t\t(8)\r\n#define DUT_MSG_DATA_LENGTH\t\t\t\t(504)\t\r\n#define MAX_DUT_EEPROM_ACCESS_SIZE (DUT_MSG_DATA_LENGTH-16)\r\n#define DUT_MSG_DRIVER_FW_GENERAL_HEADER_LENGTH\t(4*sizeof(uint32))\r\n\r\n// Efuse power limits\r\n#define EFUSE_POWER_LIMITS_START_ADDRESS (0x41)\r\n#define EFUSE_POWER_LIMITS_CIS_HEADER_OFFSET (2)\r\n#define EFUSE_POWER_LIMITS_FLIPPING_CONSTANT (128)\r\n#define EFUSE_POWER_LIMITS_VERSION_LENGTH\t (1)\r\n#define EFUSE_POWER_LIMITS_VERSION\t\t\t (1)\t// Must be equal to the value which is written in eFuse\r\n\r\n#define MAX_ANTENNAS_NUMBER_RSSI 4\r\n\r\ntypedef enum dutChipModule\r\n{\r\n\tDUT_CHIP_MODULE_UMAC_MEM\t= 1,\r\n\tDUT_CHIP_MODULE_LMAC_MEM,\r\n\tDUT_CHIP_MODULE_PHY,\r\n\tDUT_CHIP_MODULE_RF,\r\n\tDUT_CHIP_MODULE_AFE,\r\n} dutChipModule_e;\r\n\r\ntypedef enum dutNvMemoryType\r\n{\r\n\tDUT_NV_MEMORY_EEPROM\t\t= 1,\r\n\tDUT_NV_MEMORY_FLASH\t\t\t= 2,\r\n\tDUT_NV_MEMORY_EFUSE\t\t\t= 3,\r\n} dutNvMemoryType_e;\r\n\r\ntypedef enum dutChipVar\r\n{\r\n\tDUT_CHIP_VAR_TPC_FREQ\t\t= 31,\r\n\r\n} dutChipVar_e;\r\n\r\ntypedef enum dutRiscMode\r\n{\r\n\tDUT_RISC_STOP  = 0,\r\n\tDUT_RISC_START,\r\n\tDUT_RISC_LAST\r\n} dutRiscMode_e;\r\n\r\ntypedef struct dutAddVap\r\n{\r\n\tuint8 vapIndex;\t\t/* vapNumber_e */\r\n} dutAddVap_t;\r\n\r\ntypedef struct dutRemoveVap\r\n{\r\n\tuint8 vapIndex;\t\t/* vapNumber_e */\r\n} dutRemoveVap_t;\r\n\r\ntypedef enum dutCalibrationType\r\n{\r\n\tDUT_CALIBRATION_TYPE_ONLINE,\r\n\tDUT_CALIBRATION_TYPE_OFFLINE,\r\n\tDUT_CALIBRATION_TYPE_INVALID\r\n}dutCalibrationType_e;\r\n\r\ntypedef enum dutCalibrationMaskType\r\n{\r\n\tDUT_CALIBRATION_MASK_TYPE_DEFAULT,\r\n\tDUT_CALIBRATION_MASK_TYPE_CONFIGURABLE\r\n}dutCalibrationMaskType_e;\r\n\r\ntypedef enum calibrationReturnStatusType\r\n{\r\n\tCALIBRATION_RETURN_STATUS_OK,\r\n\tCALIBRATION_RETURN_STATUS_CHANNEL_NOT_SET,\r\n\tCALIBRATION_RETURN_STATUS_CALIBRATION_IN_PROCESS,\r\n}calibrationReturnStatusType_e;\r\n\r\ntypedef enum bandRadioType\r\n{\r\n\tRADIO0,\r\n\tRADIO1\r\n}bandRadioType_e;\r\n\r\n\r\n//---------------------------------------------\r\n//\t\tDut Message Definition\t\t\t\t\t\t\t\t\t\r\n//---------------------------------------------\r\ntypedef enum{\r\n\t// Dut Mngmnt Module Messages\r\n\tDUT_HW_DEPENDENT_CONFIG_REQ = 0x02,\r\n\tDUT_HW_DEPENDENT_CONFIG_CFM,\r\n\tDUT_CONFIGURE_REQ,\r\n\tDUT_CONFIGURE_CFM,\r\n\tDUT_SET_CHANNEL_REQ,\r\n\tDUT_SET_CHANNEL_CFM,\r\n\tDUT_READ_EEPROM_REQ,\r\n\tDUT_READ_EEPROM_CFM,\r\n\tDUT_WRITE_EEPROM_REQ,// = 0x0A\r\n\tDUT_WRITE_EEPROM_CFM,\r\n\tDUT_READ_BIST_RESULTS_REQ,\r\n\tDUT_READ_BIST_RESULTS_CFM,\r\n\tDUT_READ_MEMORY_REQ,\r\n\tDUT_READ_MEMORY_CFM,\r\n\tDUT_WRITE_MEMORY_REQ,// = 0x10\r\n\tDUT_WRITE_MEMORY_CFM,\r\n\tDUT_WRITE_SECURED_REGISTER_REQ,\r\n\tDUT_WRITE_SECURED_REGISTER_CFM,\r\n\tDUT_READ_FREQ_TPC_STRUCTS_REQ,\r\n\tDUT_READ_FREQ_TPC_STRUCTS_CFM,\r\n\tDUT_START_CALIBRATION_REQ,\t\t   \r\n\tDUT_START_CALIBRATION_CFM,   \r\n\tDUT_RUN_CALIBRATION_REQ,\r\n\tDUT_RUN_CALIBRATION_CFM,\r\n\tDUT_STOP_FW_REQ,// = 0x1A\r\n\tDUT_STOP_FW_CFM,\r\n\tDUT_SET_TPC_ANT_PARAMS_REQ,\r\n\tDUT_SET_TPC_ANT_PARAMS_CFM,\r\n\tDUT_SET_TPC_CONFIG_REQ,\r\n\tDUT_SET_TPC_CONFIG_CFM,\r\n\t// Dut Hw Acces Module Messages\r\n\tDUT_READ_CHIP_VERSION_REQ,// = 0x100\r\n\tDUT_READ_CHIP_VERSION_CFM,\r\n\tDUT_READ_GENRISC_VERSION_REQ ,\t  \t\t\r\n\tDUT_READ_GENRISC_VERSION_CFM,\r\n\tDUT_ENABLE_TX_ANTENNA_REQ,\t\t\r\n\tDUT_ENABLE_TX_ANTENNA_CFM,\r\n\tDUT_ENABLE_RX_ANTENNA_REQ,\r\n\tDUT_ENABLE_RX_ANTENNA_CFM,\r\n\tDUT_SET_DEFAULT_ANTENNA_SET_REQ,\t\r\n\tDUT_SET_DEFAULT_ANTENNA_SET_CFM,\r\n\tDUT_TX_TONE_REQ,// = 0x10A\r\n\tDUT_TX_TONE_CFM,\r\n\tDUT_TX_SPACELESS_REQ,\r\n\tDUT_TX_SPACELESS_CFM,\r\n\tDUT_SET_SCRAMBLER_MODE_REQ,\r\n\tDUT_SET_SCRAMBLER_MODE_CFM,\r\n\tDUT_SET_IFS_REQ,// = 0x110\r\n\tDUT_SET_IFS_CFM,\r\n\tDUT_SET_POWER_OUT_VEC_REQ,\r\n\tDUT_SET_POWER_OUT_VEC_CFM,\r\n\tDUT_GET_POWER_OUT_VEC_REQ,\r\n\tDUT_GET_POWER_OUT_VEC_CFM,\r\n\tDUT_READ_PACKET_COUNTERS_REQ,\r\n\tDUT_READ_PACKET_COUNTERS_CFM,\r\n    DUT_SET_TX_POWER_LIMIT_REQ,\r\n    DUT_SET_TX_POWER_LIMIT_CFM,\r\n\tDUT_SET_RISC_MODE_REQ,// = 0x11A\r\n\tDUT_SET_RISC_MODE_CFM,\r\n\tDUT_GET_RX_EVM_REQ,\r\n\tDUT_GET_RX_EVM_CFM,\r\n\t//RFIC\r\n\tDUT_GET_TX_POWER_FEEDBACK_REQ,\r\n\tDUT_GET_TX_POWER_FEEDBACK_CFM,\r\n\tDUT_GET_RX_GAINS_REQ, \r\n\tDUT_GET_RX_GAINS_CFM,\r\n\tDUT_GET_XTAL_VALUE_REQ,// = 0x120\r\n\tDUT_GET_XTAL_VALUE_CFM,\r\n\tDUT_SET_XTAL_VALUE_REQ,\r\n\tDUT_SET_XTAL_VALUE_CFM,\r\n\tDUT_GET_RSSI_REQ,\r\n\tDUT_GET_RSSI_CFM,\r\n\tDUT_GET_TEMPERATURE_SENSOR_REQ,\r\n\tDUT_GET_TEMPERATURE_SENSOR_CFM,\r\n\tDUT_SET_RFM_MODE_REQ,\r\n\tDUT_SET_RFM_MODE_CFM,\r\n\tDUT_SET_RF_LOOPBACK_REQ,// = 0x12A\r\n\tDUT_SET_RF_LOOPBACK_CFM,\r\n\tDUT_SET_GIPO_OUTPUT_LEVEL_REQ,\r\n\tDUT_SET_GIPO_OUTPUT_LEVEL_CFM,\r\n\tDUT_CANCEL_TX_PHASE_REQ,\r\n\tDUT_CANCEL_TX_PHASE_CFM,\r\n\tDUT_SET_CDD_SET_REQ,// = 0x130\r\n\tDUT_SET_CDD_SET_CFM,\r\n\tDUT_SET_QBF_REQ,\r\n\tDUT_SET_QBF_CFM,\r\n\tDUT_GET_LNA_PARAMS_REQ,\r\n\tDUT_GET_LNA_PARAMS_CFM,\r\n\tDUT_SET_LNA_PARAMS_REQ,\r\n\tDUT_SET_LNA_PARAMS_CFM,\r\n\tDUT_SET_RX_COUNTER_REQ,\r\n\tDUT_SET_RX_COUNTER_CFM,\r\n\tDUT_GET_RX_COUNTER_REQ,// = 0x13A\r\n\tDUT_GET_RX_COUNTER_CFM,\r\n\tDUT_SET_TX_BOOST_REQ,\r\n\tDUT_SET_TX_BOOST_CFM,\r\n\tDUT_LOGGER_SET_SEVERITY_REQ,\r\n\tDUT_LOGGER_SET_SEVERITY_CFM,\r\n\tDUT_LOGGER_SET_FILTER_REQ,// = 0x140\r\n\tDUT_LOGGER_SET_FILTER_CFM,\r\n\tDUT_LOGGER_FLUSH_BUF_REQ,\r\n\tDUT_LOGGER_FLUSH_BUF_CFM,\r\n\tDUT_SET_RATE_REQ,\r\n\tDUT_SET_RATE_CFM,\r\n\tDUT_GET_FW_INFO_REQ,\r\n\tDUT_GET_FW_INFO_CFM,\r\n\tDUT_SET_POWER_AND_PACKET_LENGTH_REQ,\r\n\tDUT_SET_POWER_AND_PACKET_LENGTH_CFM,\r\n\tDUT_SET_S2D_GAIN_AND_OFFSET_REQ,\r\n\tDUT_SET_S2D_GAIN_AND_OFFSET_CFM,\r\n\tDUT_GET_RATE_REQ,\r\n\tDUT_GET_RATE_CFM,\r\n\t// RSSI \r\n\tDUT_SET_RSSI_GAIN_BLOCK_REQ,\r\n\tDUT_SET_RSSI_GAIN_BLOCK_CFM,\r\n\tDUT_GET_CW_POWER_REQ,\r\n\tDUT_GET_CW_POWER_CFM,\r\n\tDUT_SET_RSSI_S2D_GAIN_AND_OFFSET_REQ,\r\n\tDUT_SET_RSSI_S2D_GAIN_AND_OFFSET_CFM,\r\n\tDUT_GET_AUX_ADC_RSSI_REQ,\r\n\tDUT_GET_AUX_ADC_RSSI_CFM,\r\n\tDUT_GET_RSSI_DB_REQ,\r\n\tDUT_GET_RSSI_DB_CFM,\r\n\tDUT_GET_CLIPPING_REQ,\r\n\tDUT_GET_CLIPPING_CFM,\r\n\t// TPC\r\n\tDUT_SHIFT_POWER_OUT_VECTOR_REQ,\r\n\tDUT_SHIFT_POWER_OUT_VECTOR_CFM,\r\n\tDUT_GET_TX_GAINS_REQ,\r\n\tDUT_GET_TX_GAINS_CFM,\r\n\tDUT_START_RSSI_CALIBRATION_REQ,\r\n\tDUT_START_RSSI_CALIBRATION_CFM,\r\n\tDUT_END_RSSI_CALIBRATION_REQ,\r\n\tDUT_END_RSSI_CALIBRATION_CFM,\t\r\n\tDUT_SET_LNA_MID_GAIN_REQ,\r\n\tDUT_SET_LNA_MID_GAIN_CFM,\r\n\tDUT_SET_RX_BAND_REQ,\r\n\tDUT_SET_RX_BAND_CFM,\r\n\tDUT_SET_RX_BAND_LUT_REQ,\r\n\tDUT_SET_RX_BAND_LUT_CFM,\r\n\tDUT_GET_POUT_TABLE_OFFSET_REQ,\r\n\tDUT_GET_POUT_TABLE_OFFSET_CFM,\r\n\tDUT_SET_POUT_TABLE_OFFSET_REQ,\r\n\tDUT_SET_POUT_TABLE_OFFSET_CFM,\r\n\tDUT_ENABLE_RX_AGGREGATE_REQ,\r\n\tDUT_ENABLE_RX_AGGREGATE_CFM,\r\n\t// Dut Tx Module Messages\r\n\tDUT_START_TX_REQ\t= 0x200,\r\n\tDUT_START_TX_CFM,\r\n\tDUT_STOP_TX_REQ,\r\n\tDUT_STOP_TX_CFM,\r\n\tDUT_START_TX_VECTOR_REQ,\r\n\tDUT_START_TX_VECTOR_CFM,\r\n\tDUT_GET_TX_VECTOR_ANT_REQ,\r\n\tDUT_GET_TX_VECTOR_ANT_CFM,\r\n\r\n\r\n\tDUT_UNKNOWN_MSG = 0x300,\r\n\tDUT_MAX_VAL = 0xFFFF,\r\n} dutMessagesId_e;\r\n\r\n\r\n\r\ntypedef enum dutDriverMessagesIdEnum_t\r\n{\r\n\tDUT_SERVER_MSG_RESET_MAC\t\t\t= 0x01,\r\n\tDUT_SERVER_MSG_UPLOAD_PROGMODEL\t\t= 0x02,\r\n\tDUT_SERVER_MSG_MAC_C100\t\t\t\t= 0x03,\r\n\tDUT_SERVER_MSG_RESEND_NOT_IN_USE\t= 0x04,\r\n\tDUT_SERVER_MSG_DRIVER_GENERAL\t\t= 0x05,\r\n\tDUT_SERVER_MSG_ADD_VAP\t\t \t\t= 0x06,\r\n\tDUT_SERVER_MSG_REMOVE_VAP\t\t \t= 0x07,\t\r\n\tDUT_SERVER_MSG_SET_BSS\t\t\t \t= 0x08,\t\r\n\tDUT_SERVER_MSG_SET_WMM_PARAMETERS \t= 0x09,\t\r\n\tDUT_SERVER_MSG_STOP_VAP_TRAFFIC\t \t= 0x0A,\r\n\tDUT_SERVER_MSG_DRIVER_FW_GENERAL\t= 0x0B,\t\r\n\tDUT_SERVER_MSG_PLATFORM_DATA_FIELDS = 0x0C,\r\n \tDUT_SERVER_MSG_CNT \t\t\t\t\t= 0x0D\r\n} dutDriverMessagesId_e;\r\n\r\n\r\ntypedef enum\r\n{\r\n\t// DGM - driver general message\r\n\tDUT_DGM_READ_NV_MEMORY_REQ = 0x2,\r\n\tDUT_DGM_READ_NV_MEMORY_CFM,\r\n\tDUT_DGM_WRITE_NV_MEMORY_REQ,\r\n\tDUT_DGM_WRITE_NV_MEMORY_CFM,\r\n\tDUT_DGM_FLUSH_NV_MEMORY_REQ,\r\n\tDUT_DGM_FLUSH_NV_MEMORY_CFM,\r\n\tDUT_DGM_GET_NV_FLASH_NAME_REQ,\r\n\tDUT_DGM_GET_NV_FLASH_NAME_CFM,\r\n\tDUT_DGM_CHANGE_BAND_REQ,\r\n\tDUT_DGM_CHANGE_BAND_CFM\r\n} dutDriverGeneralMsgId_e;\r\n\r\n\r\ntypedef enum\r\n{\r\n\tDUT_STATUS_PASS\t\t= 1,\r\n\tDUT_STATUS_FAIL     = 2,\r\n\tDUT_STATUS_TX_ALREADY_STOPPED = 3,\r\n\tDUT_STATUS_TX_STOP_IS_ONGOING = 4,\r\n\tDUT_STATUS_TX_START_IS_ONGOING = 5,\r\n\tDUT_STATUS_MAX_VAL = MAX_UINT16,\r\n} dutStatus_e ;\r\n\r\n//---------------------------------------------------------------------------------\r\n//\t\t\t\t\t\tData Type Definition\t\t\t\t\t\t\t\t\t\r\n//---------------------------------------------------------------------------------\r\n\r\n/*DUT_SERVER_MSG_DRIVER_FW_GENERAL*/\r\ntypedef struct dutDriverFwGeneralMsg\r\n{\r\n\tuint32 umiReqId;\r\n\tuint32 umiLen;\r\n\tuint32 reserved0;\r\n\tuint32 reserved1;\r\n\tuint8  param[MTLK_PAD4(DUT_MSG_DATA_LENGTH + DUT_MSG_HEADER_LENGTH)];\r\n}dutDriverFwGeneralMsg_t;\r\n\r\ntypedef struct dutMessage\r\n{\r\n\tuint16 \tmsgLength;\r\n\tuint16 \tstatus; /* dutStatus_e */\r\n\tuint8 \treserved[2];\r\n\tuint16 \tmsgId;\t/* dutMessagesId_e */\r\n\tuint8 \tdata[MTLK_PAD4(DUT_MSG_DATA_LENGTH)];\r\n} __MTLK_PACKED dutMessage_t;\r\n\r\n#define dutDriverMessageHeaderLength 8\r\n\r\ntypedef struct _C100_MSG_HEADER\r\n{\r\n\tuint8   u8Task;\r\n\tuint8   u8Instance;\r\n\tuint16  u16MsgId;\r\n} __MTLK_PACKED C100_MSG_HEADER;\r\n\r\ntypedef struct _UMI_C100\r\n{\r\n\tuint16 u16Length;\r\n\tuint16 u16stream;\r\n\tC100_MSG_HEADER sC100hdr;\r\n\tuint8  au8Data[MTLK_PAD4(UMI_C100_DATA_SIZE)];\r\n} __MTLK_PACKED UMI_C100;\r\n\r\n// To Align with mhi_umi convention\r\ntypedef  dutMessage_t UMI_DUT;\r\n//----- Hw Dependent Params----------//\r\ntypedef struct dutHwDependentConfParams\r\n{\r\n\tuint32 xtalValue;\r\n\tint8   extLNAbypass;\r\n\tint8   extLNAhigh;\r\n} dutHwDependentConfParams_t;\r\n\r\ntypedef enum\r\n{\r\n\tPRIMARY_LOW_40_LOW_20,\r\n\tPRIMARY_LOW_40_HIGH_20,\r\n\tPRIMARY_HIGH_40_LOW_20,\r\n\tPRIMARY_HIGH_40_HIGH_20,\r\n\tPRIMARY_MAX_VAL = MAX_UINT8,\r\n}PrimaryChannel_e;\r\n\r\n//----- FW Configure Params----------//\r\ntypedef struct dutConfigureParams\r\n{\r\n\tuint32\t\ttxLifeTime;\r\n\tuint16\t\terpRates11g;\r\n\tuint16\t\tcalibrationAlgoMask;\r\n\tIEEE_ADDR\tsIEEE_ADDR;\r\n\tuint8\t\tphyType;\r\n\tuint8\t\tnumOfRxChains;\r\n\tuint16\t\tspectrumMode; /* Bandwidth_e */\r\n\tint8\t\tforceTpc[TPC_ARRAY_SIZE];\r\n\tuint8\t\ttpcModeIsInClosedLoop; //  1 - Close loop\\ 0 - Open Loop\r\n} dutConfigureParams_t;\r\n\r\n//----- FW SetChannel Params----------//\r\ntypedef struct dutSetChannelParams\r\n{\r\n\tuint32 dummy;\r\n//\tIEEE_ADDR\tsIEEE_ADDR;\r\n//\tEEPROM_VERSION_TYPE sEepromInfo;\r\n//\tTPC_FREQ\tTPC_Freqs[TPC_ARRAY_SIZE][TPC_FREQ_STR_NUM]; // for each ant, 2 CB and 2 nCB structures\r\n\t// set channel params start\r\n//#ifdef DUT_NEW_SET_CHANNEL\t\r\n//\tuint8 \t\tlow_chan_num; \r\n//\tuint8 \t\tlow_chan_num2; // only for use with 80+80 mode\r\n//\tuint8 \t\tchan_width; // values from the chanWidth enum\r\n//\tuint8 \t\tprimary_chan_idx; // within the 1 to 8 channels specified by chan_width, i.e., from 0 to 7\r\n//#else\r\n//\tuint16\t\tchannel;\r\n//#endif\r\n\t// set channel params end\r\n//\tuint16\t\tcalibrationAlgoMask;\r\n//\tuint8\t\ttpcModeIsInClosedLoop; //  1 - Close loop\\ 0 - Open Loop\r\n//\tuint8\t\ttxPower;\r\n//\tuint8       tpcDebugMode;\r\n//\tuint8\t\tsecondaryChannel;\r\n} dutSetChannelParams_t;\r\n\r\n//----- Eeprom Params----------//\r\n\r\n\r\ntypedef struct dutEepromParams\r\n{\r\n\tuint32 address;\r\n\tuint32 eepromSize;\r\n\tuint32 length;\r\n\tuint8  data[MTLK_PAD4(MAX_DUT_EEPROM_ACCESS_SIZE)];\r\n} dutEepromParams_t;\r\n\r\n//----- NV memory Acces Params (Dut Driver Structure)----------//\r\ntypedef struct dutNvMemoryAccessParams\r\n{\r\n\tuint32 nvMemoryType;\r\n\tuint32 address;\r\n\tuint32 eepromSize;\r\n\tuint32 length;\r\n\tuint8  data[MTLK_PAD4(MAX_DUT_EEPROM_ACCESS_SIZE)];\r\n} __MTLK_PACKED dutNvMemoryAccessParams_t;\r\n\r\n\r\ntypedef struct dutNvMemoryFlushParams\r\n{\r\n\tuint32 nvMemoryType;\r\n\tuint8 verifyNvmData;\r\n    int8 verifyResult;\r\n} __MTLK_PACKED dutNvMemoryFlushParams_t;\r\n\r\ntypedef struct dutResetParams\r\n{\r\n  uint32 nvMemoryType;\r\n  uint32 eepromSize;\r\n  uint8  doReset; // 0 - Enable DUT mode on the fly, 1 - EnableDUT mode via acripts (using rmmode/insmode dut=1)\r\n  uint8  reserved[3];\r\n} __MTLK_PACKED dutResetParams_t;\r\n\r\n\r\n\r\n//----- Memory access Params DUT_READ_MEMORY_REQ\\CFM----------//\r\n//----- Memory access Params DUT_WRITE_MEMORY_REQ\\CFM----------//\r\n//----- Memory access Params DUT_WRITE_SECURED_REGISTER_REQ\\CFM----------//\r\n#define MAX_DUT_MEMORY_ACCESS_SIZE (256)\r\n\r\n\r\n\t\t\r\n\r\n\r\n\r\ntypedef struct dutMemoryAccessParams\r\n{\r\n\tuint16 module;\r\n\tuint16 length;\r\n\tuint32 address;\r\n\tuint8  data[MAX_DUT_MEMORY_ACCESS_SIZE];\r\n} dutMemoryAccessParams_t;\r\n\r\ntypedef struct dutSecuredWriteParams\r\n{\r\n\t/* modify secured register: */\r\n\t/* (*address) = (*address) & ~mask | data */\r\n\tuint32\taddress;\r\n\tuint32\tmask;\r\n\tuint32\tdata;\r\n} dutSecuredWriteParams_t;\r\n\r\n//----- Frequency TPC Params DUT_READ_FREQ_TPC_STRUCTS_REQ\\CFM----------//,\r\ntypedef union dutFreqTpcParams\r\n{\r\n   TPC_FREQ\t\t\t tpcFreqXYcal[DUT_3ANT_ARRAY * TPC_FREQ_XY_STR_NUM];\r\n   TPC_FREQ\t\t\t tpcFreq[DUT_4ANT_ARRAY * TPC_FREQ_STR_NUM];\r\n} dutFreqTpcParams_t;\r\n\r\ntypedef struct dutTpcConfig\r\n{\r\n\ttpcConfig_t\ttpcConfig;\r\n} dutTpcConfig_t;\r\n\r\n//----- Frequency TPC Params DUT_RUN_CALIBRATION_REQ\\CFM----------//,\r\ntypedef struct dutCalibrationParams\r\n{\r\n\tuint16 channel;\r\n//\tuint16 calibrationMask;\r\n//\tuint8\t\ttpcModeIsInClosedLoop; //  1 - Close loop\\ 0 - Open Loop\r\n} dutCalibrationParams_t;\r\n\r\n//----- Frequency TPC Params DUT_STOP_FW_REQ\\CFM----------//,\r\ntypedef struct dutStopFwParams\r\n{\r\n\tuint32 dummy;\r\n} dutStopFwParams_t;\r\n\r\n\r\n//----- Bist Results----------//\r\ntypedef struct dutBistResults\r\n{\r\n\tint8 bistResults[BIST_RESULTS_ARRAY_SIZE];\r\n} dutBistResults_t;\r\n\r\n//----- Chip Version----------//\r\ntypedef struct dutChipVersion\r\n{\r\n\tuint32 bbChipId;\r\n\tuint32 rfChipId;\r\n} dutChipVersion_t;\r\n\r\ntypedef struct dutRxCount\r\n{\r\n\tuint32 val;\r\n}dutRxCount;\r\n//--------------------------------------//\r\n//\tTx Data Types\t\t\t\t\t\t//\r\n//--------------------------------------//\r\ntypedef struct dutTxParams\r\n{\r\n\tuint32\t\tpacketLength;\r\n\tuint16\t\trepeats;\r\n\tuint8\t\tisTxEndless;\r\n\tuint8\t\tisDateLong;\r\n} dutTxParams_t;\r\n\r\n//--------------------------------------//\r\n//\tHw Configuration Data Types\t\t\t//\r\n//--------------------------------------//\r\n//-----  Read Hw Params DUT_READ_HW_VERSION_REQ\\CFM----------//\r\ntypedef struct dutHwParams\r\n{\r\n\tuint32\trevision;\r\n\tuint32\tminor;\r\n\tuint8\tbranchId;\r\n\tuint8\treleased;\r\n\tuint8\tmodified;\r\n\tuint8\tTx3Enabled;\r\n} dutHwParams_t;\r\n\r\n//-----  Set Tpc Table Params (DUT_SET_TPC_REQ\\CFM)----------//\r\ntypedef struct dutPowerOutVecParams\r\n{\r\n\tuint8\tant;\r\n\tuint8\tbandwidth;\r\n\tuint8\tpowerVectorIndex;\r\n\tuint8\tpowerVectorWord;\r\n} dutPowerOutVecParams_t;\r\n\r\ntypedef struct dutSetGain\r\n{\r\n\tuint8\tgainTableIndex;\r\n\tuint8\tgainWord;\r\n} dutSetGain_t;\r\n\r\n//-----  Rfic Rssi Params DUT_GET_RSSI_REQ\\CFM----------//\r\ntypedef struct dutRssiParams\r\n{\r\n\tuint8 rssi[DUT_4ANT_ARRAY];\r\n\tuint8 N;\r\n} dutRssiParams_t;\r\n\r\n//-----  Tpc Feedback params Params(DUT_GET_TPC_FEEDBACK_REQ\\CFM) ----------//\r\ntypedef struct dutTpcFeedbackparams\r\n{\r\n\tuint32\tnumOfSamples;\r\n\tuint32\tactualNumOfSamples;\r\n\tuint32  valueGain;\r\n\tuint32\tvalueSum[DUT_4ANT_ARRAY];\r\n} dutTpcFeedbackparams_t;\r\n//-----  Tx Tone Params (DUT_SET_TX_TONE_REQ\\CFM) ----------//\r\ntypedef struct dutTxToneParams\r\n{\r\n\tuint8 onOff;\r\n\tint8 amplitude;\r\n\tint8 power;\r\n\tuint8 binNum;\r\n} dutTxToneParams_t;\r\n\r\n//-----  Tx Spaceless Params (DUT_SET_SPACELESS_TX_REQ\\CFM) ----------//\r\ntypedef struct dutTxSpacelessParams\r\n{\r\n\tuint8 onOff;\r\n} dutTxSpacelessParams_t;\r\n\r\n//-----  Scrambler Mode Params (DUT_TX_SPACELESS_REQ\\CFM) ----------//\r\ntypedef struct dutScramblerParams\r\n{\r\n\tuint8 mode;\r\n} dutScramblerParams_t;\r\n\r\n//-----  Set IFS Params (DUT_SET_IFS_REQ\\CFM) ----------//\r\ntypedef struct dutIfsParams\r\n{\r\n\tuint32 spacingUsec;\r\n} dutIfsParams_t;\r\n\r\n//-----  Counters Params DUT_READ_PACKET_COUNTERS_REQ\\CFM----------//\r\ntypedef struct packetCountersParams\r\n{\r\n\tuint32 phyRxPacketCounter;\r\n\tuint32 phyRxCrcErrorCounter;\r\n\tuint32 fwPacketCounter;\r\n\tuint8  doReset;\r\n} packetCountersParams_t;\r\n\r\n//-----  Set Tx Power Limit  Params (DUT_SET_TX_POWER_LIMIT_REQ\\CFM)----------//\r\ntypedef struct powerLimitParams\r\n{\r\n    uint8 powerLimit;\r\n} powerLimitParams_t;\r\n\r\n//-----  Counters Params DUT_SET_RISC_MODE_REQ\\CFM----------//\r\ntypedef struct riscModeParams\r\n{\r\n\tdutRiscMode_e riscMode; // 0- Off 1 - On\r\n} riscModeParams_t;\r\n\r\n//-----  Set Antenna Params Params DUT_ENABLE_TX_ANTENNA_REQ\\CFM----------//\r\n//-----  Set Antenna Params Params DUT_ENABLE_RX_ANTENNA_REQ\\CFM----------//\r\ntypedef struct dutSetAntennaParams\r\n{\r\n\tuint8 enabledAntMask; // bit 0-3: Ants 0-3 ON (3 - ants 0,1 ON, 7 - ants 0,1,2 ON, 0xF - ants 0,1,2,3 ON, 0 - all off)\r\n} dutSetAntennaParams_t;\r\n\r\n//-----  Set Antenna Params Params (DUT_SET_DEFAULT_ANTENNA_SET_REQ\\CFM) ----------//\r\ntypedef struct antSelectionParams\r\n{\r\n\tuint8\tantSet;\r\n} antSelectionParams_t;\r\n//-----  Rfic Gains Params DUT_GET_TX_GAINS_REQ\\CFM ----------//\r\ntypedef struct dutAntTxGains\r\n{\r\n\tuint8\tbbGain;\r\n\tuint8\tpaDriverGain;\t\t// 3bit 0-High 1- Medium 2-Low\r\n\tuint8\tmixedGain;\r\n} dutAntTxGains_t;\r\n\r\ntypedef struct dutRficTxGainsParams\r\n{\r\n\tdutAntTxGains_t antTxGains[DUT_4ANT_ARRAY]; \r\n} dutRficTxGainsParams_t;\r\n\r\n//-----  Rfic Gains Params DUT_GET_RX_GAINS_REQ\\CFM ----------//\r\ntypedef struct dutAntRxGains\r\n{\r\n\tint16\tbbGain;\r\n\tint8\tlnaGain;\t\t// 3bit 0-High 1- Medium 2-Low\r\n\tuint8\ttype;\t\t\t// 0-ignore 1-OnlyBbGainIsValid\r\n} dutAntRxGains_t;\r\n\r\ntypedef struct dutRficRxGainsParams\r\n{\r\n\tdutAntRxGains_t antRxGains[DUT_4ANT_ARRAY]; \r\n} dutRficRxGainsParams_t;\r\n\r\n//-----  Xtal Params DUT_GET_XTAL_VALUE_REQ\\CFM----------//\r\ntypedef struct dutXtalParams\r\n{\r\n\tuint32 xtalValue;\r\n} dutXtalParams_t;\r\n\r\ntypedef struct dutLnaParams\r\n{\r\n\tint8\textLNAbypass;\r\n\tint8\textLNAhigh;\r\n} dutLnaParam_t;\r\n\r\ntypedef struct dutTxPhaseParams\r\n{\r\n\tuint32 TxPhaseValue;\r\n} dutTxPhaseParams_t;\r\n\r\ntypedef struct dutCddParams\r\n{\r\n\tuint32 CDDvalue;\r\n} dutCddParams_t;\r\n\r\ntypedef struct dutQbfParams\r\n{\r\n\tuint32 QBFvalue;\r\n} dutQbfParams_t;\r\n\r\n//-----  Rx Counter Params DUT_GET_RX_COUNTER_REQ\\CFM----------//\r\ntypedef struct dutRxCounter\r\n{\r\n\tuint32 rxCounter;\r\n} dutRxCounter_t;\r\n\r\n//-----  Tx power boost Params DUT_SET_TX_BOOST_REQ\\CFM----------//\r\ntypedef struct dutTxPowerBoost\r\n{\r\n\tuint8 ant0;\r\n\tuint8 ant1;\r\n\tuint8 ant2;\r\n\tuint8 ant3;\r\n} dutTxPowerBoost_t;\r\n\r\n//-----  start calibration Params DUT_START_CALIBRATION_REQ\\CFM----------//\r\ntypedef struct dutStartCalibrationParams\r\n{\r\n\tuint32\tmask;\t\t// calibration mask, see ClbrProcBit_e (only if maskType is configurable)\r\n\tuint32\tresults;\t// results as per mask\r\n\tuint8\tmaskType;\t// configurable = 0/ default = 1, /* dutCalibrationMaskType_e */\r\n\tuint8 \ttype;\t\t// offline = 0/ online = 1 /* dutCalibrationType_e */\r\n\tuint8\tstatus; /* calibrationReturnStatusType_e */\r\n\tuint8 \treserved;\r\n} dutStartCalibrationParams_t;\r\n\r\n\r\n// DUT_SET_RATE_REQ\r\ntypedef struct dutSetRate_tag\r\n{\r\n\tuint16\t\ttxRate;// NSS+MCS\r\n\tuint8\t \tphyMode; /* PHYMode */\r\n\tuint8\t\tcpMode; // values from CyclicPrefixmode_e\r\n\tuint8\t\tsignalBw;\r\n}dutSetRate_t;\r\n\r\n//DUT_GET_FW_INFO_REQ\r\ntypedef struct dutGetFwInfo_tag\r\n{\r\n\tuint8\t\t\tvapId;\r\n\tuint8\t\t\toperationMode;\r\n\tuint16\t\t\tspectrumMode; /* Bandwidth_e */\r\n\tuint16\t\t\tprimaryChannel;\r\n\tuint8\t\t\tphyMode;\r\n\tuint8 \t\t\tpsdTxAntMask;\r\n\tuint8 \t\t\tpsdRxAntMask;\r\n\tuint8\t\t\triscMode; // dutRiscMode_e\r\n\tuint8\t\t\tsupportedBandsPsd; // 2.4-5-dual\r\n\tuint8 \t\t\tcurrentRfBandPsd;//which one of the bands is the difault one;\r\n}dutGetFwInfo_t;\r\n\r\ntypedef struct dutPowerAndPacketLength_tag\r\n{\r\n\tuint16 packetLength;\r\n\tuint8 txPower;\r\n\tuint8 reserved;\r\n}dutPowerAndPacketLength_t;\r\n\r\ntypedef struct s2dParams\r\n{\r\n    uint8 gain;\r\n    uint8 offset;\r\n    uint8 region; //1-3\r\n    uint8 ant;\r\n    uint8 bw; \r\n\tuint8 pThreshold;\r\n}tpcS2dParams_t;\r\n\r\n//-----  DUT_SET_LNA_MID_GAIN_REQ\\CFM----------//\r\ntypedef struct dutLnaMidGain_tag\r\n{\r\n\tuint8 lnaMidGainValue[DUT_4ANT_ARRAY];\r\n} dutLnaMidGain_t;\r\n\r\ntypedef struct dutSetTransmitPowerVector_tag\r\n{\r\n\tuint16 lengthOfPowerVector;\r\n\tuint16 startingPacketLength;\r\n\tuint16 packetLengthIncrementPerIndex;\r\n\tuint8 powerIndexArray[64];\r\n\tuint8 numOfTransmitionPerPower[64];\r\n\t//uint16 measuredVoltagePerPower[16];\r\n} dutSetTransmitPowerVector_t;\r\n\r\ntypedef struct dutGetTransmitPowerVectorAntenna_tag\r\n{\r\n\tuint32 antennaIndex;\t \r\n\tuint16 measuredVoltagePerPower[64];\r\n} dutGetTransmitPowerVectorAntenna_t;\r\n\r\ntypedef struct dutSetRxBand_tag\r\n{\r\n\tuint8 rxBand;\r\n} dutSetRxBand_t;\r\n\r\ntypedef struct dutSetRxBandLUT_tag\r\n{\r\n\tuint16 rxBandLUT[4][7];\r\n} dutSetRxBandLUT_t;\r\n\r\ntypedef struct dutGetRxEvm_tag\r\n{\r\n\tuint8 rxEvm[DUT_4ANT_ARRAY];\r\n} dutGetRxEvm_t;\r\n\r\n\r\ntypedef struct Clipping_trigger\r\n{\r\n\tint clipping_trigger;\r\n} Clipping_trigger_t;\r\n\r\ntypedef enum\r\n{\r\n\tRSSI_REGION_LOW,\t\t// 0x0\t\t\r\n\tRSSI_REGION_HIGH,\t\t// 0x1\r\n\tRSSI_REGION_MID,\t\t// 0x2\t\r\n\tNUMBER_OF_RSSI_REGIONS_GEN6 = RSSI_REGION_MID,\r\n\tNUMBER_OF_RSSI_REGIONS\t// 0x3\r\n} RssiRegion_e;\r\n\r\ntypedef struct RssiDB_tag\r\n{\r\n\tuint32 alpha[MAX_ANTENNAS_NUMBER_RSSI][NUMBER_OF_RSSI_REGIONS];\r\n\tuint32 beta[MAX_ANTENNAS_NUMBER_RSSI][NUMBER_OF_RSSI_REGIONS];\t\r\n\tint32 s2dGain[MAX_ANTENNAS_NUMBER_RSSI][NUMBER_OF_RSSI_REGIONS];\r\n\tint32 s2dOffset[MAX_ANTENNAS_NUMBER_RSSI][NUMBER_OF_RSSI_REGIONS];\r\n\tuint32 gamma[MAX_ANTENNAS_NUMBER_RSSI][NUMBER_OF_RSSI_REGIONS];\r\n} RssiDBPower_t;\r\n\r\n\r\n// DUT_GET_RATE_HE_REQ\r\ntypedef struct dutGetRate_tag\r\n{\r\n\tuint8\t \tphyMode; \t\r\n\tuint8\t\tnss;\r\n\tuint8\t\tmcs;\r\n\tuint8\t\tgi;\t// 0-2\r\n\tuint8\t\tsignalBw;\r\n\tuint8\t\treserved[3];\r\n\tuint32\t\trate;\r\n}dutGetRate_t;\r\n\r\ntypedef struct dutChangeBand\r\n{\r\n   uint8 changeToRadio;\r\n   uint8 reserved[3];\r\n}dutChangeBand_t;\r\n\r\ntypedef struct dutPoutTableOffsetParams_tag\r\n{\r\n\tuint8\t \tantNum; \t\r\n\tuint8\t\tbw;\r\n\tshort \t\ttableOffset;\r\n}dutPoutTableOffsetParams_t;\r\n\r\ntypedef struct dutRxEnableAggregate\r\n{\r\n\tuint8\t\taggregate;    // 1 enable, 0 disable\r\n\tuint8\t\treserved[3];\r\n} dutRxEnableAggregate_t;\r\n\r\n\r\n\r\n\r\n#define MTLK_PACK_OFF\r\n#include \"mtlkpack.h\"\r\n\r\n#endif\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n", "comment_ratio": 0.13580246913580246}
{"lang": "c", "code": "#import <UIKit/UIKit.h>\n\n@interface AppDelegate : UIResponder <UIApplicationDelegate>\n\n@property (strong, nonatomic) UIWindow *window;\n\n\n@end\n\n\n", "comment_ratio": 0.3888888888888889}
{"lang": "c", "code": "#import <React/RCTViewManager.h>\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface RCTCropViewManager : RCTViewManager\n\n@end\n\nNS_ASSUME_NONNULL_END\n\n", "comment_ratio": 0.3888888888888889}
{"lang": "c", "code": "#ifndef __UIMENU_H__\n#define __UIMENU_H__\n\n#ifdef _MSC_VER\n#pragma once\n#endif\n\n#include \"observer_impl_base.hpp\"\n\nnamespace DuiLib {\n\n/////////////////////////////////////////////////////////////////////////////////////\n//\nstruct ContextMenuParam\n{\n\t// 1: remove all\n\t// 2: remove the sub menu\n\tWPARAM wParam;\n\tHWND hWnd;\n\tTNotifyUI Msg;\n};\n\nenum MenuAlignment\n{\n\teMenuAlignment_Left = 1 << 1,\n\teMenuAlignment_Top = 1 << 2,\n\teMenuAlignment_Right = 1 << 3,\n\teMenuAlignment_Bottom = 1 << 4,\n};\n\ntypedef class ObserverImpl<BOOL, ContextMenuParam> ContextMenuObserver;\ntypedef class ReceiverImpl<BOOL, ContextMenuParam> ContextMenuReceiver;\n\nextern ContextMenuObserver s_context_menu_observer;\n\n// MenuUI\nextern const TCHAR* const kMenuUIClassName;// = _T(\"MenuUI\");\nextern const TCHAR* const kMenuUIInterfaceName;// = _T(\"Menu\");\n\nclass CListUI;\nclass CMenuUI : public CListUI\n{\npublic:\n\tCMenuUI();\n\t~CMenuUI();\n\n    LPCTSTR GetClass() const;\n    LPVOID GetInterface(LPCTSTR pstrName);\n\n\tvirtual void DoEvent(TEventUI& event);\n\n    virtual bool Add(CControlUI* pControl);\n    virtual bool AddAt(CControlUI* pControl, int iIndex);\n\n    virtual int GetItemIndex(CControlUI* pControl) const;\n    virtual bool SetItemIndex(CControlUI* pControl, int iIndex);\n    virtual bool Remove(CControlUI* pControl, bool bDoNotDestroy=false);\n\n\tSIZE EstimateSize(SIZE szAvailable);\n\tint FindSelectable(int iIndex, bool bForward = true) const;\n\tbool SelectItem(int iIndex, bool bTakeFocus = false, bool bTriggerEvent = true);\n};\n\n/////////////////////////////////////////////////////////////////////////////////////\n//\n\n// MenuElementUI\nextern const TCHAR* const kMenuElementUIClassName;// = _T(\"MenuElement\");\nextern const TCHAR* const kMenuElementUIInterfaceName;// = _T(\"MenuElement);\nextern LPCTSTR EXPLANDICON;\nclass CMenuElementUI;\nclass CMenuWnd : public CWindowWnd, public ContextMenuReceiver, public INotifyUI\n{\npublic:\n\tCMenuWnd(HWND hParent = NULL);\n\t~CMenuWnd();\n    void Init(CMenuElementUI* pOwner, STRINGorID xml, LPCTSTR pSkinType, POINT point);\n    LPCTSTR GetWindowClassName() const;\n    void OnFinalMessage(HWND hWnd);\n\n    LRESULT HandleMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);\n\tLRESULT OnKeyDown(UINT uMsg, WPARAM wParam, LPARAM lParam);\n\tBOOL Receive(ContextMenuParam param);\n\tvoid Notify(TNotifyUI& msg);\npublic:\n\tHWND m_hParent;\n\tPOINT m_BasedPoint;\n\tSTRINGorID m_xml;\n\tCDuiString m_sType;\n    CPaintManagerUI m_pm;\n    CMenuElementUI* m_pOwner;\n    CMenuUI* m_pLayout;\n};\n\nclass CListContainerElementUI;\nclass CMenuElementUI : public CListContainerElementUI\n{\n\tfriend CMenuWnd;\npublic:\n    CMenuElementUI();\n\t~CMenuElementUI();\n\n    LPCTSTR GetClass() const;\n    LPVOID GetInterface(LPCTSTR pstrName);\n\n    bool DoPaint(HDC hDC, const RECT& rcPaint, CControlUI* pStopControl);\n\n\tvoid DrawItemText(HDC hDC, const RECT& rcItem);\n\n\tSIZE EstimateSize(SIZE szAvailable);\n\n\tbool Activate();\n\n\tvoid DoEvent(TEventUI& event);\n\n\tvoid SetAttribute(LPCTSTR pstrName, LPCTSTR pstrValue);\n\tCMenuWnd* GetMenuWnd();\n\n\tvoid CreateMenuWnd();\n\tvoid ReleaseMenuWnd();\n\tbool HasSupMenu();\n\n\tbool IsSeparator();\n\n\tstatic const int ICON_WIDTH = 30;\n\tstatic const int EXPLANDICON_SIZE = 20;\nprotected:\n\tvoid SetSupMenuVisible();\n\tCMenuWnd* m_pWindow;\n\tTDrawInfo m_diIcon;\n\tSIZE m_szIcon;\n\tbool m_bSeparator;\n\tDWORD m_dwSeparatorColor;\n\tRECT m_rcSeparatorPadding;\n};\n\n} // namespace DuiLib\n\n#endif // __UIMENU_H__\n\n", "comment_ratio": 0.1}
{"lang": "c", "code": "#import <Foundation/Foundation.h>\n\n@interface MTGOfferWallRewardInfo : NSObject\n\n/**\n *  The reward name as defined on Self Service\n */\n@property (nonatomic, copy  ) NSString  *rewardName;\n\n/**\n *  Amount of reward type given to the user\n */\n@property (nonatomic, assign) NSInteger rewardAmount;\n\n\n@end\n\n", "comment_ratio": 0.28}
